{"aid": "40271630", "title": "Unlocking the Mysteries of Trusted Boot: Secure System Boot Processes", "url": "https://kairos.io/blog/2024/04/10/unlocking-the-mysteries-of-trusted-boot-a-deep-dive-into-secure-system-boot-processes/", "domain": "kairos.io", "votes": 1, "user": "transpute", "posted_at": "2024-05-06 06:09:05", "comments": 0, "source_title": "Unlocking the Mysteries of Trusted Boot: A Deep Dive into Secure System Boot Processes", "source_text": "Unlocking the Mysteries of Trusted Boot: A Deep Dive into Secure System Boot Processes | Kairos - The immutable Linux meta-distribution for edge Kubernetes\n\nView page source Edit this page Create child page Create documentation issue\nCreate project issue\n\n# Unlocking the Mysteries of Trusted Boot: A Deep Dive into Secure System Boot\nProcesses\n\nBy Ettore Di Giacinto (Twitter) (GitHub) | Wednesday, April 10, 2024\n\nIn the evolving landscape of cybersecurity, protecting the integrity of\ncomputing systems from the moment they power on has become very important. As\nthreats become more sophisticated, understanding and implementing advanced\nboot security mechanisms like Trusted Boot, Full Disk Encryption (FDE), Secure\nBoot, and Measured Boot are critical for safeguarding data and ensuring system\nintegrity. This article demystifies these concepts, explores their\nsignificance, and examines their implementation in modern computing\nenvironments, particularly focusing on the Linux ecosystem and the approaches\nwithin the Kairos project.\n\n> We are facing new challenges as 2024 starts. While AI is pushing innovating\n> technologies to the edge, security becomes even more critical for\n> organizations to protect sensitive data.\n\n> Image credits\n> https://www.reddit.com/r/PBSOD/comments/c8nusw/it_is_now_safe_to_turn_off_your_computer_atm_in/\n\nAs industries evolve over time, security measures are increasing to protect\nedge devices from attackers. New attack vectors and vulnerabilities are\nexploited every day by cybercriminals, making it crucial for industries to\ncontinuously update and enhance their security systems. In the context of edge\ndevices, which are computing elements that process data at the edge of the\nnetwork, closer to the source of data generation, this need is even more\npronounced. These devices, including ATMs, point-of-sale systems, and IoT\ndevices, are often the front line of cybersecurity battles.\n\nOne of the primary challenges in securing edge devices is their inherent\ndiversity and distributed nature. Unlike centralized systems, edge devices are\nspread across various locations, often in unsecured or semi-secured\nenvironments, making physical and network security a significant concern. This\ndispersion also implies a broad attack surface, with each device potentially\noffering a unique set of vulnerabilities. What we are trying to build here is\na new foundation to define how to deploy secure devices which cannot be\ntampered with, and can keep data secure from malicious actors. We do want to\nprotect the software stack that we run on it .\n\nOur goal is simple but complex to achieve: No unauthorized access to the\nsoftware, to the data which is generated by the machine, and finally, we don\u2019t\nwant the machine to execute modified code.\n\n## The Essence of Boot Security and Encryption\n\nHere comes Trusted Boot and SENA to the rescue. Easier to explain with an\nAlice metaphor.\n\n> You can read more about Trusted Boot in the Lennart blog and about SENA in\n> our blog post\n\nLet\u2019s imagine Alice has this super cool treasure chest, chock-full of her most\nprized stuff. She\u2019s big on security, but in a high-tech way \u2013 kind of like how\nyour computer needs to keep its data safe. To get this done, your computer\nuses some smart tricks, things like Trusted Boot, Full Disk Encryption (FDE),\nSecure Boot, and Measured Boot.\n\nTo picture Full Disk Encryption, or FDE, think of it as Alice\u2019s treasure chest\nhaving a lock that only opens with a secret code. It\u2019s so clever that if\nsomeone breaks into her house and finds the chest, they still can\u2019t get inside\nwithout that special code. FDE is like that for your computer \u2013 it scrambles\nall your data so that only someone with the right password can read it.\n\nNext, there\u2019s Secure Boot. Imagine if Alice had this smart doorbell. When\nsomeone presses it, the doorbell checks if they\u2019re on the guest list. If\nthey\u2019re not, no entry. Secure Boot is your computer\u2019s version of this smart\ndoorbell. It checks every piece of software when your computer starts up and\nonly lets the good, trusted stuff in. It keeps out anything that looks fishy.\n\nAnd then, we have Measured Boot. Picture this as Alice keeping a super\ndetailed logbook. She writes down everything that goes on in her house \u2013 who\ncomes in, what they do, you name it. If anything odd pops up, she\u2019s on it.\nMeasured Boot does something similar for your computer. It watches over the\nstartup process, takes notes, and makes sure everything\u2019s running just like it\nshould, no funny business.\n\nPutting all these together, you\u2019ve got Trusted Boot, which is like Alice\u2019s\nultimate home security system \u2013 the secret-code lock, the smart doorbell, and\nthe detailed logbook, all working together. We\u2019re going to unpack how these\nnifty tools keep your computer as secure as Alice\u2019s treasure chest, making\nsure your digital world is safe every time you power up.\n\n## Challenges and Solutions in Implementing FDE on Linux\n\nWhile FDE is a standard feature in various operating systems, its\nimplementation in Linux presents unique challenges. The initial boot stage,\nincluding the kernel and initial file system setup, cannot be fully encrypted\nas they have to be read by the firmware and the kernel respectively, leaving a\nportion of the system exposed. The initramfs for instance is responsible for\nunencrypting the portions of the disk. However, through careful measures, this\nunencrypted segment can be protected against tampering, thus securing the\nsystem\u2019s boot process and the encrypted data it accesses.\n\nThe Kairos project adopts \u201cUnified Kernel Images\u201d (UKI) to enhance boot\nsecurity as defined by the UAPI group. UKI files are single, fat binaries that\ncontain the OS and necessary boot components in a single, verified file. This\napproach simplifies the boot process, allowing for the entire system to be\nbooted securely and efficiently, but it presents as well interesting\nchallenges due to the Firmware restrictions that might depend on the hardware\nused(such as booting EFI large files, or handling Secure Boot certificates).\nBy leveraging EFI files that can be signed and verified through Secure Boot\nand measured as a single entity, UKI files represent a significant advancement\nin boot security.\n\nCentral to the Trusted Boot mechanism is the Trusted Platform Module (TPM), a\ndedicated hardware (also emulated by firmware) component designed for secure\ncryptographic operations. TPM chips play a critical role in storing encryption\nkeys and measurements securely, enabling the system to verify boot integrity\nand encrypt user data effectively.\n\n## From Grub to systemd-boot\n\nTrusted Boot is deeply integrated into systemd and is currently being actively\ndeveloped. Linux offers a variety of init systems and bootloaders, such as\nGRUB. However, systemd includes tools like systemd-measure and ukify, which,\nalthough they work with various bootloaders, are particularly effective with\nsystemd-boot. What sets systemd-boot apart from GRUB and other bootloaders is\nits focus on hardware compatibility support. As we aim to support modern\nhardware that must meet specific requirements, we prioritize minimizing the\nattack surface. Therefore, a narrower scope of support is a better fit for our\nspecific needs and preferred over bootloaders designed for broad hardware\ncompatibility, which often carry legacy code and a large patchset (for\ninstance, you can see the number of patches that SUSE applies on top of\nstandard GRUB package to add support to specific hardware/improve the\nfunctionalities). This presents a strong argument for choosing systemd,\nespecially systemd-boot, over other bootloaders which targets recent hardware\nand a smaller scope.\n\nWhy this makes sense: We\u2019re now in an era where outdated hardware is not our\nconcern. Modern devices don\u2019t require old drivers, so we have the opportunity\nto streamline our systems. This translates to a principle of \u2019less is more\u2019 in\nour code and in our stack - less software in our stack means enhanced\nsecurity. We aim for a leaner runtime to run our software, minimizing\npotential security vulnerabilities. In addition, it also makes sense to use\ntools that adhere closely to standard specifications.\n\nConsidering the transition to modern hardware, especially with widespread EFI\nsupport, systemd-stub or systemd-boot is a strong contender to replace GRUB.\nGRUB has been a staple in the Linux community for years, evolving from\nversions 0.x to 2.x, which if you are seasoned like me, you have witnessed\nalmost all of them! However, it\u2019s worth considering the extensive patches\napplied by distributions and its expansive codebase. While its extensive\nsupport and scripting capabilities were once advantageous, they now detract\nfrom its suitability as a lightweight option.\n\nThe goal is clear: we aim to minimize complexity in building a secure,\nefficient stack, reusing as much components well trusted and established by\nthe community. By reducing the number of components, we strive for a more\nsecure and streamlined system.\n\n## Booting in Linux\n\nWhen a Linux system starts, it goes through a multi-stage process to load the\noperating system. This process can be broken down roughly into the following\nsteps:\n\n  1. Firmware Initialization: The system\u2019s firmware, which could be BIOS or UEFI, performs initial hardware checks and configurations. It then searches for a bootloader, which is typically located in the boot partition or the Master Boot Record (MBR) of the storage device.\n  2. Bootloader Execution: The bootloader, such as GRUB, is a software responsible for loading the main part of the operating system. Its primary task is to find the Linux kernel, usually located in the same partition, and load it into memory. The bootloader might present a menu or configuration options to choose different kernels or operating systems if multiple are installed.\n  3. Kernel Loading and Initialization: The kernel is the core of the Linux operating system. Once loaded, it initializes the system\u2019s hardware and sets up essential services. During this phase, the kernel decompresses and loads an initrd (initial ramdisk). The initrd is a temporary root file system loaded into memory. It includes essential tools and scripts needed to mount the real root file system. In modern Linux systems, initrd is often replaced by initramfs, which serves a similar purpose.\n  4. File System Setup and Transition: Inside initrd, scripts are executed to prepare the actual root file system. This includes tasks like decrypting and encrypted partitions if present. After preparations are complete, the system makes a transition, referred to as \u201cpivoting\u201d, to the actual root file system.\n  5. Root File System and User Data: The root partition, now mounted as the root file system, contains all the user data, system configurations, binaries, drivers, and other necessary components for the operating system to function. This is where the system runs from once the boot process is complete.\n\nThroughout these stages, the components\u2014firmware, bootloader, kernel, initrd,\nand the root file system\u2014work in a sequence to load the operating system\nsuccessfully.\n\nThis chain is the one we in the Linux and tech industry are very much familiar\nwith. Several designs and strategies have been developed to secure this stack\nover time, for instance Verified kernels and drivers, or Secure Boot to sign\nthe bootloader and be able to trust its authenticity. There are various\nbootloader implementations as well, tied to more secure HW (like TPM devices).\n\nHowever, as technologies and security measures evolved, attacks evolved as\nwell. Specific hardware now can be leveraged to increase the security posture\nof the boot process, and it is time for a change, as the market demands more\nsophisticated security measures to protect against malicious actors.\n\n## Booting with a TPM-equipped Hardware\n\nWhen a device equipped with TPM, and a sufficiently modern hardware boots,\nseveral steps happen sequentially.\n\nMany hardware platforms use a Core Root of Trust for Measurements (CRTM),\nwhich is the very first thing that boots, even before the firmware. The CRTM\ngets a hash of the firmware and sends it to the TPM chip, which measures the\nrunning software and is a requirement for trusted boot. The TPM chip then\nloads the firmware/BIOS.\n\nThe TPM takes note of the measurement and stores the hash in a bank of\nmultiple platform configuration registers (PCRs). In order to store\nmeasurements, the TPM chip extends the banks from the previous values, as\nthese changes to the stack are easy to recognize during the boot.\n\nNext, the BIOS or firmware measures the subsequent stage (bootloader or UKI)\nand sends it to the TPM, then loads the UKI and continues booting.\n\nOnce the TPM is asked to release an encryption key to unseal the full disk\nencryption, it will check if the measurements it has are valid. If a\nbootloader is present, it will have already measured the UKI files, and\nmeasurement also happens when initrd starts and when the running system is\nready to check any manipulations (e.g., kernel boot command line). The process\nis also bound to the secure boot signatures, so any manipulation of the UKI\nfiles would be allowed only by the key holders.\n\nIf a malicious attacker tries to load custom software or modify an image in\nany way, they must extend the PCR value and align it with the value it would\nhave had following an expected boot. The cryptographic robustness of the hash\nalgorithm makes achieving this computationally expensive, thereby helping to\nsupport security.\n\nIf the firmware or bootloader have been tampered with, the hash values stored\nin the PCR won\u2019t match expected measurements, and the system will flag an\nalert and prevent boot from happening \u2014 intentionally bricking the host device\nas a failsafe (the host is still recoverable by re-installing everything from\nscratch).\n\n## Kairos and Trusted Boot\n\nTo gain a deeper understanding of the mechanics behind EFI files and the boot\nprocess, let\u2019s delve into the way typical Linux distributions manage booting\nwith Full Disk Encryption (FDE):\n\n  * Initially, the firmware retrieves the bootloader from the boot partition (or Master Boot Record - MBR) and transitions control to a kernel.\n  * This kernel then unpacks an initrd, which houses essential tools needed for initializing the file system (FS) and transitioning to the operational system environment.\n\nIn this setup, each component is distinct: the Kernel and Initrd are separate\nfiles, whereas the root partition is a unified file system encompassing all\nuser data (such as installed binaries, password files, sensitive information,\ndrivers, etc.). The primary function of the initrd in this scenario is to\ndecrypt partitions and set up mount points as it transitions control to a\ndifferent partition.\n\nContrastingly, the Kairos architecture utilizes a singular image file that\namalgamates the rootfs, kernel, and initrd. Here, the initrd is responsible\nfor establishing the FS and activating the rootfs.\n\nThe bootloader plays a pivotal role in this architecture by accessing image\nfiles stored within the state partition.\n\nWhile the state partition remains unencrypted, the system\u2019s operational\nprojection is derived from the encrypted user-data partition. Directories such\nas /etc and /opt (which can be fully customized) are overlaid, safeguarding\nsensitive information from being exposed within the state partition.\nNevertheless, this design, along with the previously mentioned setup, is\nvulnerable to \u201cEvil Maid Attacks.\u201d These attacks involve altering the system\nby booting from a LiveCD and modifying the booted images.\n\nIn the context of the UKI (Unified Kernel Image) architecture, which closely\nresembles the Kairos model, the primary distinction lies in the storage of a\nsingular EFI image file within the boot partition. This arrangement\nfacilitates the signing and verification of EFI files to ensure they haven\u2019t\nbeen tampered with, leveraging SecureBoot in tandem with Measured Boot. These\nmechanisms verify that the image is certified by a trusted authority and\nremains unmodified.\n\nDuring the boot process, cryptographic assessments are made using the Trusted\nPlatform Module (TPM) to confirm the system\u2019s integrity. Drive decryption\nduring boot is contingent upon consistent signing by the same authority and\naccurate boot measurement matching. System upgrades involve updating the boot\nmeasurement to enable access to the user data partitions.\n\n## Security consideration\n\nThe existing framework guarantees that the initial phase (UKI file) remains\nimmutable, with only this phase capable of decrypting the drive\u2019s encrypted\ndata. Indeed there is no pivoting into another system like in the traditional\nLinux boot process. This design choice ensures that the system remains a\nsingle component, with the UKI file acting as the sole point of entry for the\nsystem.\n\nShifting to a different image would have introduced potential security\nvulnerabilities and constraints:\n\n  * The current Systemd tools lack the capability to assess another rootfs/file.\n  * There is an absence of mechanisms to incorporate PCR with hash checksums of bespoke files in the expanded PCR banks within systemd.\n  * The inability to evaluate a secondary phase means any alterations in this stage could remain undetected during operation.\n\nAlso, implementing measurements for a second phase would significantly\ncomplicate the update process, as each version (A/B, Recovery) would require\ncorresponding updates and measurements for every file involved in the\ntransition.\n\nAn alternative approach involves maintaining a singular initial phase, which\nwould entail measuring all subsequent stages. However, this concept remains a\ntopic of ongoing debate without any concrete solutions thus far.\n\nA concrete example: should a hacker remotely access the system without\nmeasures in place for the transitioned stage, they could alter the entire\nrootfs during operation without detection. In contrast, by leaving the first\nstage unaltered in the current method, modifications to the rootfs are\nprevented.\n\n## Learn More\n\nTrusted boot is one of many recommended security techniques \u2014 but it\u2019s\nabsolutely critical to ensuring you can trust the integrity of your device,\nparticularly when it\u2019s deployed in the field.\n\nWe\u2019ve only just scratched the surface of trusted boot as a concept, how it\nworks and the architectural details of the Kairos implementation that\ncontribute to the overall security posture. If you\u2019d like to learn more:\n\n  * Check out our CNCF presentation, available on demand.\n  * Learn more secure edge architectures including trusted boot, by downloading the SENA white paper.\n  * Check out Kairos\u2019 trusted boot architectural documentation and try it out for yourself.\n\n  * \u2190Previous\n  * Next\u2192\n\nLast modified April 17, 2024: update trusted boot docs and add blog post\n(#168) (90cc78a)\n\nProject supported by Spectro Cloud\n\nFollow us\n\n", "frontpage": false}
