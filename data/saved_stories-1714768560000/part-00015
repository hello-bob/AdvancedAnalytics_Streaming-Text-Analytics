{"aid": "40246438", "title": "Building a (Mini) 3D Flutter Game Engine \u2013 Part 1", "url": "https://nick-fisher.com/articles/building-a-mini-3d-flutter-game-engine-part-1/", "domain": "nick-fisher.com", "votes": 1, "user": "nmfisher", "posted_at": "2024-05-03 11:28:12", "comments": 0, "source_title": "Building a (Mini) 3D Flutter Game Engine - Part 1", "source_text": "Building a (Mini) 3D Flutter Game Engine - Part 1\n\n# Building a (Mini) 3D Flutter Game Engine - Part 1\n\n> If you want to see more progress on 3D in Flutter, please help by voting for\n> my game in the Flutter Global Gamers Challenge! Who knows, maybe this will\n> help connect me with the right people to secure resources for further work.\n\nIf you've been following me at all, you might know that I've been working on\nflutter_filament for some time now, a package that enables cross-platform 3D\nrendering in Flutter apps with the Filament Physically Based Rendering\nlibrary.\n\nI still haven't managed to write a blog post on the package itself, but if\nyou're interested, in the meantime you can check out a presentation I gave at\nthe Singapore Flutter meetup here and this GitHub issue for a high-level\noverview.\n\n## From Renderer To Game Engine\n\nI'm not a game developer or designer (aside from a few toy projects in my\nuniversity days), but I'd been itching to extend flutter_filament with a basic\ngame engine for some time now.\n\nWhen Google launched a Flutter game competition earlier in the year, it gave\nme a convenient excuse to set aside some time to do so.\n\nThat being said, no-one was sponsoring me to write a game, let alone a game\nengine. With bills to pay, I couldn't take too much time away from paying\nwork, so I needed to be very judicious and implement only the absolute bare\nminimum to make a game (hence the \"mini\" game engine).\n\nThe initial game concept was intentionally basic : paddle a canoe down a\nriver, fish rubbish out of the water with a net. Different objects would be\nworth different points, and the objective would be to collect as many points\nas possible before reaching the end of the river.\n\n> You've probably realized that this is not the game I ended up submitting for\n> the competition. After I went through the engine work below, I started\n> afresh with a different concept, which I'll cover in part 2.\n\nThe 2D UI overlay would be handled by Flutter, and I already had a renderer in\nflutter_filament, so I was able to render/transform 3D objects, add\nlights/skybox, and play animations.\n\nWhat I needed to add, though, was:\n\n  1. the ability to attach an over-the-shoulder camera\n  2. collision detection to stop the canoe itself clipping through the river banks, and to detect when an object was caught by the net\n  3. keyboard/mouse controls for moving the character and triggering the animations\n\n(1) was very straightforward, simply because I could cheat and avoid the issue\nby exporting the canoe/character model from Blender with a camera node as a\nchild. This was time away from paid work, I had no shame in taking shortcuts\nevery which way I went!\n\n## Collision detection\n\nCollision detection wasn't going to be as trivial as that, but I was hoping I\ncould get away with something simple like the following pseudo-code:\n\n    \n    \n    void collides(Entity entity1, Entity entity2) { // implement this } void calculateCollisions() { for(auto entity1 : scene) { for(auto entity2 : scene) { if(entity1 != entity2 && collides(entity1, entity2)) { collisionCallback(entity1, entity2); } } } } void renderLoop() { while(true) { calculateCollisions(); render(); } }\n\nThis O(N^2) complexity in the hot path would obviously be terrible for a real\ngame engine, but this concept only needed a few dozen renderable entities so I\ndidn't expect it to be a problem.\n\nImplementing the actual collides(...) method didn't appear too difficult at\nfirst glance either. The Filament library (and the glTF format more generally)\nexpose axis-aligned bounding boxes for assets, so I thought I could get away\nwith something as simple as:\n\n    \n    \n    auto aabb1 = worldTransform(entity1,entity1.aabb); auto aabb2 = worldTransform(entity2,entity2.aabb); for(auto vertex : aabb1.vertices) { if(aabb2.contains(vertex)) { return true; } }\n\nHowever, there were a few problems with this simple approach.\n\nOne is that Filament uses the rest pose of the model to calculate the bounding\nbox when it is imported. This isn't a problem for static (i.e. non-animated)\nmodels - like determining whether the canoe hit the river bed. But for a\ncharacter model with a swipe animation, the bounding box remains fixed and\ndoesn't account for the fact that the animated limb is now \"outside\" this box.\n\nAnother is that this is an axis-aligned bounding box, meaning that the extent\nalong each axis changes depending on the rotation of the model. This means\nthat the AABBs can intersect, even though visually, there's no collision.\n\nThe other problem is that the bounding box of the top-level entity is\n(obviously) larger than the bounding box of the actual object we want to test\n(the end of the net). We only want to award points when the net hits the\nfloating object in the water, not (for example) when the canoe reverses into\none.\n\nIn keeping with the spirit of \"do as little work as possible\", I avoided the\nissue again by attaching a number of small hidden cubes in Blender to the\ncollidable parts (the riverbanks, the canoe and the front of the canoe where\nthe scoop animation would intersect with the water).\n\n## Keyboard/mouse control\n\nAt this stage I was mostly working on the desktop (MacOS) version, so I wanted\nto be able to use conventional FPS controls to move the character (WASD keys\nfor forward/back/strafe, mouse movement for look and the mouse button for the\n\"swing net\" action).\n\nIn a normal game engine, you'd expect to be able to collect/process user input\ninside the main loop:\n\n    \n    \n    void main() { while(true) { processInput(); calculateCollisions(); waitForVsync(); render(); } }\n\nThis doesn't quite fit the way that flutter_filament is structured though,\nwhere the Flutter UI loop is running on the main thread and a separate render\nloop running on a background thread.\n\nThere's no inherent reason why we couldn't process keyboard and mouse events\nin both loops. But with the Flutter framework providing tools to handle user\ninput across all supported platforms, why reinvent the wheel?\n\nI had already implemented basic manipulation via Flutter GestureDetector\nwidgets for the main 'scene' camera, so it was relatively straightforward to\nextend this to manipulating the camera attached to the model.\n\nTo maintain consistent movement speed (and to stop the transform updates when\na collision is detected), though, I needed to queue up the user input so it\nwas only processed once per (render) frame.\n\nAs a side note, I don't think there's any inherent reason why I couldn't\nrestructure flutter_filament to run more like a conventional game engine loop:\n\n    \n    \n    void main() { while(true) { processInput(); calculateCollisions(); waitForVsync(); flutterEngine.tick(); render(); } }\n\nIn this structure, the Flutter engine would render into an offscreen render\ntarget, and the game engine is then responsible for compositing this at the\ntop of the scene view. This strikes me as functionally similar to the Flutter\n\"add-to-app\" scenario, so this is probably feasible - I just haven't had any\ncompelling reason to do so yet.\n\nIn the next post, I'll go into some more detail on the engine work needed for\nthe second iteration (GPU instancing, menu callbacks on entity mouseover).\n\nNick Fisher | 2024\n\n", "frontpage": false}
