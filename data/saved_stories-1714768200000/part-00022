{"aid": "40245686", "title": "Figma's Journey to TypeScript", "url": "https://www.figma.com/blog/figmas-journey-to-typescript-compiling-away-our-custom-programming-language/", "domain": "figma.com", "votes": 1, "user": "soheilpro", "posted_at": "2024-05-03 09:14:19", "comments": 0, "source_title": "Figma\u2019s journey to TypeScript | Figma Blog", "source_text": "Figma\u2019s journey to TypeScript | Figma Blog\n\nSkip to main content\n\n### Featured Topics\n\n  * ### Design systems\n\n  * ### Engineering\n\n### Explore topics\n\n  * 3D design\n  * AI\n  * Accessibility\n  * Behind the scenes\n  * Brainstorming\n  * Branding\n  * Career & education\n  * Case study\n  * Collaboration\n  * Config\n  * Culture\n  * Design\n  * Design thinking\n  * Diagramming\n  * Events\n  * Hiring\n  * Infrastructure\n  * Leadership\n  * Localization\n  * Marketing\n  * Meetings\n  * Motion\n  * News\n  * Operations\n  * Plugins & tooling\n  * Portfolio\n  * Product management\n  * Product updates\n  * Productivity\n  * Profiles & interviews\n  * Prototyping\n  * Quality & performance\n  * React\n  * Report\n  * Research\n  * Security\n  * Social impact\n  * Strategy\n  * The Long & Short of It\n  * Thought leadership\n  * Tips & inspiration\n  * Typography\n  * UI/UX\n  * Wireframing\n  * Writing\n\nMay 1, 2024\n\n# Figma\u2019s journey to TypeScript: Compiling away our custom programming\nlanguage\n\nBrandon LinSoftware Engineer\n\nInside FigmaQuality & performanceEngineeringInfrastructureBehind the scenes\n\nWe\u2019ve long written core parts of our mobile rendering architecture in Skew,\nthe custom programming language we invented to squeeze additional performance\nout of our playback engine. Here\u2019s how we automatically migrated Skew to\nTypeScript without disrupting a single day of development.\n\nSkew began as a side project in the early days of Figma. At the time, Skew\nfulfilled a critical need at Figma: to build out our prototype viewer with\nsupport on both the web and mobile. What started as a way to quickly spin this\nup became an entire compile-to-JavaScript programming language that enabled\nmore advanced optimizations and faster compile times. But as we accumulated\nmore and more code in Skew in the prototype viewer over the years, we slowly\nrealized that it was difficult for new hires to ramp up on, couldn\u2019t easily\nintegrate with the rest of our codebase, and was missing a developer ecosystem\noutside of Figma. The pain of scaling it grew to outweigh its original\nadvantages.\n\nWe recently finished migrating all Skew code at Figma to TypeScript, the\nindustry standard language for the web. TypeScript is a sea change for the\nteam and enables:\n\n  * Streamlined integration with both internal and external code via static imports and native package management\n  * A massive developer community that has built tools like linters, bundlers, and static analyzers\n  * Modern JavaScript features like async/await and a more flexible type system\n  * Seamless onboarding for new developers and lower friction for other teams\n\nLeft: A snippet of Skew code.Right: Typescript code corresponding to this Skew\ncode.\n\nThis migration only recently became possible for three reasons:\n\n  * More mobile browsers started to support WebAssembly\n  * We replaced many core components of our Skew engine with the corresponding components from our C++ engine, which meant we wouldn\u2019t lose as much performance if we moved to TypeScript\n  * Team growth allowed us to allocate resources to focus on the developer experience\n\n#### WebAssembly saw widespread mobile support and improved performance\n\nWhen we first built Figma\u2019s mobile codebase, mobile browsers didn\u2019t support\nWebAssembly and couldn\u2019t load large bundles in a performant way. This meant\nthat it wasn\u2019t possible to use our main C++ engine code (which would need to\ncompile to WebAssembly). At the same time, TypeScript was in its infancy; it\nwasn\u2019t the obvious choice compared to Skew, which had static types and a\nstricter type system that allowed for advanced compiler optimizations.\nFortunately, WebAssembly obtained widespread mobile support by 2018 and,\naccording to our tests, reliable mobile performance by 2020.\n\n#### Other performance improvements caught up to Skew\u2019s optimizations\n\nWhen we first started using Skew, there were a few key benefits: classic\ncompiler optimizations, like constant folding and devirtualization, along with\nweb-specific ones like generating JavaScript code with real integer\noperations. The longer we spent with these optimizations, the harder it was to\njustify a departure from a language we had cultivated for so long. For\ninstance, in 2020, benchmarks indicated that loading Figma prototypes would\u2019ve\nbeen nearly twice as slow using TypeScript in Safari, which was a blocker\nbecause Safari was (and still is*) the only browser engine allowed on iOS.\n\n*In iOS 17.4, Apple opened up its system to other browser engines for users in the EU. WebKit remains the only browser engine for other users around the world.\n\nSome years after WebAssembly obtained widespread mobile support, we replaced\nmany core components of our Skew engine with the corresponding components from\nour C++ engine. Since the components we replaced were the hottest code\npaths\u2014like file loading\u2014we wouldn\u2019t lose as much performance if we moved to\nTypeScript. This experience gave us confidence that we could forego the\nadvantages of Skew\u2019s optimizing compiler.\n\n#### Figma\u2019s prototyping and mobile teams grew\n\nIn Figma\u2019s earlier years, we couldn\u2019t justify diverting resources to perform\nan automated migration because we were building as fast as possible with a\nsmall team. Scaling the prototyping and mobile teams into larger organizations\nafforded us the resources to do so.\n\n## Converting the codebase\n\nWhen we first prototyped this migration in 2020, our benchmarks showed that\nperformance would be nearly twice as slow using TypeScript. Once we saw that\nWebAssembly support was good enough and moved the core of the mobile engine to\nC++, we fixed up our old prototype during our company Maker Week. We\ndemonstrated a working migration that passed all tests. Despite the thousands\nof developer experience issues and non-fatal type errors, we had a rough plan\nto migrate all of our Skew code safely.\n\nOur goal was simple: convert the whole codebase to TypeScript. While we could\nhave manually rewritten each file, we couldn\u2019t afford to interrupt developer\nvelocity to rewrite the entire codebase. More importantly, we wanted to avoid\nruntime errors and performance degradations for our users. While we ended up\nautomating this migration, it wasn\u2019t a quick switch. Unlike moving from\nanother \u201cJavaScript-with-types\u201d language to TypeScript, Skew had actual\nsemantic differences that made us uncomfortable with an immediate switch to\nTypeScript. For example, TypeScript only initializes namespaces and classes\nafter we import a file, meaning we could run into runtime errors if we import\nthe files in an unexpected order. By contrast, Skew makes every symbol\navailable at runtime to the rest of the codebase upon loading, so these\nruntime errors wouldn\u2019t be a problem.\n\nEvan has said he took some learnings from this experience to make web bundler\nesbuild.\n\nWe opted to gradually roll out a new code bundle generated from TypeScript so\nthat there would be minimal disruptions to developer workflows. We developed a\nSkew-to-TypeScript transpiler that could take Skew code as input and output\ngenerated TypeScript code, building upon the work that Evan Wallace, Figma\u2019s\nformer CTO, started years ago.\n\n#### Phase 1: Write Skew, build Skew\n\nWe kept the original build process intact, developed the transpiler, and\nchecked in the TypeScript code to GitHub to show developers what the new\ncodebase would look like.\n\nDeveloping a Typescript transpiler, alongside our original Skew pipeline\n\n#### Phase 2: Write Skew, build TypeScript\n\nOnce we generated a TypeScript bundle that passed all of our unit tests, we\nstarted rolling out production traffic to build from the TypeScript codebase\ndirectly. In this phase, developers still wrote Skew, and our transpiler\ntranspiled their code into TypeScript and updated TypeScript code living in\nGitHub. Additionally, we continued to fix type errors in the generated code;\nTypeScript could still generate a valid bundle even if there were type errors!\n\nRolling out production traffic to the TypeScript codebase that our TypeScript\ncompiler generated from Skew source code\n\n#### Phase 3: Write TypeScript, build TypeScript\n\nOnce everyone went through the TypeScript build process, we needed to make the\nTypeScript code the source of truth for development. After identifying a time\nwhen no one was merging code, we cut off the auto-generation process and\ndeleted the Skew code from the codebase, effectively requiring that developers\nwrite code in TypeScript.\n\nMaking the cutover to use the Typescript codebase as the source of truth for\ndevelopers\n\nThis was a solid approach. Having full control over the workings of the Skew\ncompiler meant we could use it to make Phase 1 much easier; we could add and\nmodify parts of the Skew compiler with complete freedom to satisfy our needs.\nOur gradual rollout also ended up paying dividends. For example, we internally\ncaught a breakage with our Smart Animate feature as we were rolling out\nTypeScript. Our gated approach allowed us to quickly turn off the rollout, fix\nthe breakage, and rethink how to proceed with our rollout plan.\n\nWe also gave ample notice about the cutover to use TypeScript. On a Friday\nnight, we merged all the necessary changes to remove the auto-generation\nprocess and to make all of our continuous integration jobs run off the\nTypeScript files directly.\n\n## A note on our transpiler work\n\nIf you don\u2019t know how compilers work, here\u2019s a bird\u2019s-eye view: A compiler\nitself consists of a frontend and a backend. The frontend is responsible for\nparsing and understanding the input code and performing things like type-\nchecking and syntax checking. The frontend then converts this code to an\nintermediate representation (IR), a data structure that fully captures the\noriginal semantics and logic of the original input code, but structured so\nthat we don\u2019t need to worry about re-parsing the code.\n\nThe backend of the compiler is responsible for turning this IR into a variety\nof different languages. In a language like C, for example, one backend would\ntypically generate assembly/machine code, and in the Skew compiler, the\nbackend generates mangled and minified JavaScript.\n\nA transpiler is a special type of compiler whose backends produce human-\nreadable code rather than mangled machine-like code; in our case, the backend\nwould need to take the Skew IR and produce human-readable TypeScript.\n\nThe process of writing the transpiler was relatively straightforward in the\nbeginning: We borrowed a lot of inspiration from the JavaScript backend with\nthe appropriate code to generate based on the information we encountered in\nthe IR. At the tail end we ran into several issues that were trickier to track\ndown and deal with:\n\n  * Performance issues with array destructuring: Moving away from JavaScript array destructuring yielded up to 25% in performance benefits.\n  * Skew\u2019s \u201cdevirtualization\u201d optimization:\n  * Initialization order matters in TypeScript: Symbol ordering in TypeScript matters as opposed to Skew, so our transpiler needed to generate code that respected this ordering.\n\n##### Performance issues with array destructuring\n\nWhen investigating offline performance differences between Skew and TypeScript\nin some sample prototypes, we noticed that the frame rate was lower in\nTypeScript. After much investigation, we found out the root cause was array\ndestructuring\u2013which, it turns out, is rather slow in JavaScript.\n\nTo complete an operation like const [a, b] = function_that_returns_an_array(),\nJavaScript constructs an iterator that iterates through the array instead of\ndirectly indexing from the array, which is slower. We were doing this to\nretrieve arguments from JavaScript\u2019s arguments keyword, resulting in slower\nperformance on certain test cases. The solution was simple: We generated code\nto directly index the arguments array instead of destructuring, and improved\nper-frame latency by up to 25%!\n\n##### Skew\u2019s \u201cdevirtualization\u201d optimization\n\nCheck out this post to learn more about devirtualization.\n\nAnother issue was divergent behavior between how TypeScript and Skew deal with\nclass methods, which caused the aforementioned breakage in Smart Animate\nduring our rollout. The Skew compiler does something called devirtualization,\nwhich is when\u2013under certain conditions\u2013a function gets pulled out of a class\nas a performance optimization and gets hoisted to a global function:\n\nJavaScript\n\n    \n    \n    myObject.myFunc(a, b) // becomes... myFunc(myObject, a, b)\n\nThis optimization happens in Skew but not TypeScript. The Smart Animate\nbreakage happened because myObject was null, and we saw different\nbehaviors\u2013the devirtualized call would run fine but the non-devirtualized call\nwould result in null access exception. This made us worry if there were other\nsuch call sites that had the same problem.\n\nTo assuage our worries, we added logging in all functions that would partake\nin devirtualization to see if this problem had ever occurred in production.\nAfter enabling this logging for a brief period of time, we analyzed our logs\nand fixed all problematic call sites, making us more confident in the\nrobustness of our TypeScript code.\n\n##### Initialization order matters in TypeScript\n\nA third issue we encountered is how each respective language honors\ninitialization order. In Skew, you can declare variables, classes and\nnamespaces, and function definitions anywhere in code and it won\u2019t care about\nthe order in which they are declared. In TypeScript, however, it does matter\nwhether you initialize global variables or class definitions first;\ninitializing static class variables before the class definition is a compile-\ntime error.\n\nOur initial version of the transpiler got around this by generating TypeScript\ncode without using namespaces, effectively flattening every single function\ninto the global scope. This maintained similar behavior to Skew, but the\nresulting code was not very readable. We reworked parts of the transpiler to\nemit TypeScript code in the proper order for clarity and accuracy, and added\nback TypeScript namespaces for readability.\n\nDespite these challenges, we eventually built a transpiler that passed all of\nour unit tests and produced compiling TypeScript code that matched Skew\u2019s\nperformance. We opted to fix some small issues either manually in Skew source\ncode, or once we cut over to TypeScript\u2014rather than writing a new modification\nto the transpiler to fix them. While it would be ideal for all fixes to live\nin the transpiler, the reality is that some changes weren\u2019t worth automating\nand we could move faster by fixing some issues this way.\n\n## Case study: Keeping developers happy with source maps\n\nThroughout this process, developer productivity was always top of mind. We\nwanted to make the migration to TypeScript as easy as possible, which meant\ndoing everything we could to avoid downtime and create a seamless debugging\nexperience.\n\nWeb developers primarily debug with debuggers supplied by modern web browsers;\nyou set a breakpoint in your source code and when the code reaches this point,\nthe browser will pause and developers can inspect the state of the browser\u2019s\nJavaScript engine. In our case, a developer would want to set breakpoints in\nSkew or TypeScript (depending on which phase of the project we were in).\n\nBut the browser itself can only understand JavaScript, while breakpoints are\nactually set in Skew or TypeScript. How does it know where to stop in the\ncompiled JavaScript bundle given a breakpoint in source code? Enter: source\nmaps, the way a browser knows how to link together compiled code to source\ncode. Let\u2019s look at a simple example with this Skew code:\n\nPlain text\n\n    \n    \n    def helper() { return [1, 3, 4, 5]; } def myFunc(myInt int) int { var arrayOfInts List<int> = helper(); return arrayOfInts[0] + 1; }\n\nThis code might get compiled and minified down to the following JavaScript:\n\nJavaScript\n\n    \n    \n    function c(){return [1,3,4,5];}function myFunc(a){let b=c();return b[0]+1;}\n\nThis syntax is hard to read. Source maps map sections of the generated\nJavaScript back to specific sections of the source code (in our case, Skew). A\nsource map between the code snippets would show mappings between:\n\n  * helper \u2192 c\n  * myInt \u2192 a\n  * arrayOfInts \u2192 b\n\nCheck out this article on source maps for more technical details on\ngenerating, understanding, and debugging source maps.\n\nA source map normally will have file extension .map. One source map file will\nassociate with the final JavaScript bundle so that, given a code location in\nthe JavaScript file, the source map for our JavaScript bundle would tell us:\n\n  * The Skew file this section of JavaScript came from\n  * The code location within this Skew file that corresponds to this portion of JavaScript\n\nWhenever a developer sets a debugger breakpoint in Skew, the browser simply\nreverses this source map, looks up the portion of JavaScript that this Skew\nline corresponds to, and sets a breakpoint there.\n\nHere\u2019s how we applied this to our TypeScript migration: Our original\ninfrastructure generated Skew to JavaScript source maps that we used for\ndebugging. However, in Phase 2 of our migration, our bundle generation\npipeline was completely different, generating TypeScript followed by bundling\nwith esbuild. If we tried to use the same source maps from our original\ninfrastructure, we would get incorrect mappings between JavaScript and Skew\ncode, and developers would be unable to debug their code while we\u2019re in this\nphase.\n\nWe needed to generate new source maps using our new build process. This\ninvolved three pieces of work, illustrated below:\n\nDiagram of generating new sourcemaps using our new build process\n\nStep 1: Generate a TypeScript \u2192 JavaScript source map ts-to-js.map. esbuild\ncan automatically generate this map when it generates the JavaScript bundle.\n\nStep 2: Generate a Skew \u2192 TypeScript source map for each Skew source file. If\nwe name the file file.sk, the transpiler will name the source map file.map. By\nemulating how the Skew \u2192 JavaScript backend of the Skew compiler creates\nsource maps, we implemented this in our TypeScript transpiler.\n\nStep 3: Compose these source maps together to yield a map from Skew to\nJavaScript. For this, we implemented the following logic in our build process:\n\nFor each entry E in ts-to-js.map:\n\n  * Determine which TypeScript file this entry maps into and open its source map, fileX.map.\n  * Look up the TypeScript code location from E in this source map, fileX.map, to obtain the code location in the corresponding Skew file fileX.sk.\n  * Add this as a new entry in our final source map: the JavaScript code location from E combined with the Skew code location.\n\nWith our final source map handy, we could now map our new JavaScript bundle to\nSkew without disrupting the developer experience.\n\n## Case study: Conditional compilation\n\nIn Skew, top-level \u201cif\u201d statements allow for conditional code compilation, and\nwe specify the conditions using compile-time constants via a \u201cdefines\u201d option\npassed to the Skew compiler. We can use this to define multiple build\ntargets\u2014which bundle in different parts of the code\u2014for a given codebase, so\nwe can have different bundles for different ways of using the same codebase.\nFor example, one bundle variant could be the actual bundle that\u2019s deployed to\nusers, and another could be one used only for unit testing. This allows us to\nspecify that certain functions or classes use different implementations in\ndebug or release builds.\n\nTo be more explicit, the following Skew code defines a different\nimplementation for a TEST build:\n\nPlain text\n\n    \n    \n    if BUILD == \"TEST\" { class HTTPRequest { def send(body string) HTTPResponse { # test-only implementation... } def testOnlyFunction { console.log(\"hi!\") } } } else { class HTTPRequest { def send(body string) HTTPResponse { # real implementation... } } }\n\nThis would compile to the following JavaScript when passing a BUILD: \"TEST\"\ndefinition to the Skew compiler:\n\nJavaScript\n\n    \n    \n    function HTTPRequest() {} HTTPRequest.prototype.send = function(body) { // test-only implementation... } HTTPRequest.prototype.testOnlyFunction = function(body) { console.log(\"hi!\") }\n\nHowever, conditional compilation is not part of TypeScript. Instead, we had to\nperform the conditional compilation in the build step after type-checking, as\npart of the bundling step using esbuild\u2019s \u201cdefines\u201d and dead code elimination\nfeatures. The defines could therefore no longer influence type-checking,\nmeaning code like the above example where the method testOnlyFunction is only\ndefined in the BUILD: \"TEST\" build could not exist in Typescript.\n\nWe fixed this problem by converting the above Skew code to the following\nTypeScript code:\n\nJavaScript\n\n    \n    \n    // Value defined during esbuild step declare const BUILD: string class HTTPRequest { send(body: string): HTTPResponse { if (BUILD == \"TEST\") { // test-only implementation... } else { // real implementation... } } testOnlyFunction() { if (BUILD == \"TEST\") { console.log(\"hi!\") } else { throw new Error(\"Unexpected call to test-only function\") } } }\n\nThis compiles to the same JavaScript code that the original Skew code also\ndirectly compiled to:\n\nJavaScript\n\n    \n    \n    function HTTPRequest() {} HTTPRequest.prototype.send = function(body) { // test-only implementation... } HTTPRequest.prototype.testOnlyFunction = function(body) { console.log(\"hi!\") }\n\nUnfortunately, our final bundle was now slightly larger. Some symbols that\nwere originally only available in one compile-time mode became present in all\nmodes. For example, we only used testOnlyFunction when the build mode BUILD\nwas set to \"TEST\", but after this change the function was always present in\nthe final bundle. In our testing, we found this increase in bundle size to be\nacceptable. We were still be able to remove unexported top-level symbols,\nthough, via tree-shaking.\n\n## A new era of prototyping development, now in TypeScript\n\nBy migrating all Skew code to TypeScript, we modernized a key codebase at\nFigma. Not only did we pave the way for it to integrate much more easily with\ninternal and external code, developers are working more efficiently as a\nresult. Writing the codebase initially in Skew was a good decision given the\nneeds and capabilities of Figma at the time. However, technologies are\nconstantly improving and we learned to never doubt the rate at which they\nmature. Even though TypeScript may not have been the right choice back then,\nit definitely is now.\n\nWe want to reap all the benefits of moving to TypeScript, so our work doesn\u2019t\nstop here. We\u2019re exploring a number of future possibilities: integration with\nthe rest of our codebase, significantly easier package management, and direct\nuse of new features from the active TypeScript ecosystem. We learned a lot\nabout different facets of TypeScript\u2014like import resolutions, module systems,\nand JavaScript code generation\u2014and we can\u2019t wait to put those learnings to\ngood use.\n\nWe would like to thank Andrew Chan, Ben Drebing, and Eddie Shiang for their\ncontributions to this project. If work like this appeals to you, come work\nwith us at Figma!\n\n## Create and collaborate with Figma\n\nGet started for free\n\n## Use Cases\n\n  * UI design\n  * UX design\n  * Wireframing\n  * Diagramming\n  * Brainstorming\n  * Online whiteboard\n  * Team collaboration\n  * Agile workflows\n  * Strategic planning\n  * Mind mapping\n  * Concept mapping\n  * Org charts\n  * Online sticky notes\n  * Templates\n  * Agencies\n  * Figma for education\n\n## Explore\n\n  * Design\n  * Prototyping\n  * Design systems\n  * Development features\n  * Collaboration features\n  * Design process\n  * FigJam\n  * What's new\n  * Releases\n  * Pricing\n  * Enterprise\n  * Organization\n  * Professional\n  * Customers\n  * Security\n  * Integrations\n  * Contact\n\n## Resources\n\n  * Blog\n  * Best practices\n  * Color wheel\n  * Support\n  * Developers\n  * Resource library\n  * Reports & Insights\n  * Webinars\n  * Downloads\n  * Careers\n  * Our story\n  * Affiliate program\n  * Partners\n  * Legal and Privacy\n  * Modern Slavery Statement\n  * Climate Disclosure Statement\n  * Status\n\n## Compare\n\n  * Sketch\n  * Adobe XD\n  * Invision Studio\n  * Framer\n  * Design on Windows\n  * Miro\n\nEnglish\n\n", "frontpage": false}
