{"aid": "40284500", "title": "Eli Bendersky: Unification", "url": "https://eli.thegreenplace.net/2018/unification/", "domain": "thegreenplace.net", "votes": 1, "user": "PaulHoule", "posted_at": "2024-05-07 12:02:19", "comments": 0, "source_title": "Unification", "source_text": "Unification - Eli Bendersky's website\n\nEli Bendersky's website\n\n  * About\n  * Projects\n  * Archives\n\n# Unification\n\nNovember 12, 2018 at 05:49 Tags Python , Programming , Math\n\nIn logic and computer science, unification is a process of automatically\nsolving equations between symbolic terms. Unification has several interesting\napplications, notably in logic programming and type inference. In this post I\nwant to present the basic unification algorithm with a complete\nimplementation.\n\nLet's start with some terminology. We'll be using terms built from constants,\nvariables and function applications:\n\n  * A lowercase letter represents a constant (could be any kind of constant, like an integer or a string)\n  * An uppercase letter represents a variable\n  * f(...) is an application of function f to some parameters, which are terms themselves\n\nThis representation is borrowed from first-order logic and is also used in the\nProlog programming language. Some examples:\n\n  * V: a single variable term\n  * foo(V, k): function foo applied to variable V and constant k\n  * foo(bar(k), baz(V)): a nested function application\n\n## Pattern matching\n\nUnification can be seen as a generalization of pattern matching, so let's\nstart with that first.\n\nWe're given a constant term and a pattern term. The pattern term has\nvariables. Pattern matching is the problem of finding a variable assignment\nthat will make the two terms match. For example:\n\n  * Constant term: f(a, b, bar(t))\n  * Pattern term: f(a, V, X)\n\nTrivially, the assignment V=b and X=bar(t) works here. Another name to call\nsuch an assignment is a substitution, which maps variables to their assigned\nvalues. In a less trivial case, variables can appear multiple times in a\npattern:\n\n  * Constant term: f(top(a), a, g(top(a)), t)\n  * Pattern term: f(V, a, g(V), t)\n\nHere the right substitution is V=top(a).\n\nSometimes, no valid substitutions exist. If we change the constant term in the\nlatest example to f(top(b), a, g(top(a)), t), then there is no valid\nsubstitution becase V would have to match top(b) and top(a) simultaneously,\nwhich is not possible.\n\n## Unification\n\nUnification is just like pattern matching, except that both terms can contain\nvariables. So we can no longer say one is the pattern term and the other the\nconstant term. For example:\n\n  * First term: f(a, V, bar(D))\n  * Second term f(D, k, bar(a))\n\nGiven two such terms, finding a variable substitution that will make them\nequivalent is called unification. In this case the substitution is {D=a, V=k}.\n\nNote that there is an infinite number of possible unifiers for some solvable\nunification problem. For example, given:\n\n  * First term: f(X, Y)\n  * Second term: f(Z, g(X))\n\nWe have the substitution {X=Z, Y=g(X)} but also something like {X=K, Z=K,\nY=g(K)} and {X=j(K), Z=j(K), Y=g(j(K))} and so on. The first substitution is\nthe simplest one, and also the most general. It's called the most general\nunifier or mgu. Intuitively, the mgu can be turned into any other unifier by\nperforming another substitution. For example {X=Z, Y=g(X)} can be turned into\n{X=j(K), Z=j(K), Y=g(j(K))} by applying the substitution {Z=j(K)} to it. Note\nthat the reverse doesn't work, as we can't turn the second into the first by\nusing a substitution. So we say that {X=Z, Y=g(X)} is the most general unifier\nfor the two given terms, and it's the mgu we want to find.\n\n## An algorithm for unification\n\nSolving unification problems may seem simple, but there are a number of subtle\ncorner cases to be aware of. In his 1991 paper Correcting a Widespread Error\nin Unification Algorithms, Peter Norvig noted a common error that exists in\nmany books presenting the algorithm, including SICP.\n\nThe correct algorithm is based on J.A. Robinson's 1965 paper \"A machine-\noriented logic based on the resolution principle\". More efficient algorithms\nhave been developed over time since it was first published, but our focus here\nwill be on correctness and simplicity rather than performance.\n\nThe following implementation is based on Norvig's, and the full code (with\ntests) is available on GitHub. This implementation uses Python 3, while\nNorvig's original is in Common Lisp. There's a slight difference in\nrepresentations too, as Norvig uses the Lisp-y (f X Y) syntax to denote an\napplication of function f. The two representations are isomorphic, and I'm\npicking the more classical one which is used in most papers on the subject. In\nany case, if you're interested in the more Lisp-y version, I have some Clojure\ncode online that ports Norvig's implementation more directly.\n\nWe'll start by defining the data structure for terms:\n\n    \n    \n    class Term: pass class App(Term): def __init__(self, fname, args=()): self.fname = fname self.args = args # Not shown here: __str__ and __eq__, see full code for the details... class Var(Term): def __init__(self, name): self.name = name class Const(Term): def __init__(self, value): self.value = value\n\nAn App represents the application of function fname to a sequence of\narguments.\n\n    \n    \n    def unify(x, y, subst): \"\"\"Unifies term x and y with initial subst. Returns a subst (map of name->term) that unifies x and y, or None if they can't be unified. Pass subst={} if no subst are initially known. Note that {} means valid (but empty) subst. \"\"\" if subst is None: return None elif x == y: return subst elif isinstance(x, Var): return unify_variable(x, y, subst) elif isinstance(y, Var): return unify_variable(y, x, subst) elif isinstance(x, App) and isinstance(y, App): if x.fname != y.fname or len(x.args) != len(y.args): return None else: for i in range(len(x.args)): subst = unify(x.args[i], y.args[i], subst) return subst else: return None\n\nunify is the main function driving the algorithm. It looks for a substitution,\nwhich is a Python dict mapping variable names to terms. When either side is a\nvariable, it calls unify_variable which is shown next. Otherwise, if both\nsides are function applications, it ensures they apply the same function\n(otherwise there's no match) and then unifies their arguments one by one,\ncarefully carrying the updated substitution throughout the process.\n\n    \n    \n    def unify_variable(v, x, subst): \"\"\"Unifies variable v with term x, using subst. Returns updated subst or None on failure. \"\"\" assert isinstance(v, Var) if v.name in subst: return unify(subst[v.name], x, subst) elif isinstance(x, Var) and x.name in subst: return unify(v, subst[x.name], subst) elif occurs_check(v, x, subst): return None else: # v is not yet in subst and can't simplify x. Extend subst. return {**subst, v.name: x}\n\nThe key idea here is recursive unification. If v is bound in the substitution,\nwe try to unify its definition with x to guarantee consistency throughout the\nunification process (and vice versa when x is a variable). There's another\nfunction being used here - occurs_check; I'm retaining its classical name from\nearly presentations of unification. Its goal is to guarantee that we don't\nhave self-referential variable bindings like X=f(X) that would lead to\npotentially infinite unifiers.\n\n    \n    \n    def occurs_check(v, term, subst): \"\"\"Does the variable v occur anywhere inside term? Variables in term are looked up in subst and the check is applied recursively. \"\"\" assert isinstance(v, Var) if v == term: return True elif isinstance(term, Var) and term.name in subst: return occurs_check(v, subst[term.name], subst) elif isinstance(term, App): return any(occurs_check(v, arg, subst) for arg in term.args) else: return False\n\nLet's see how this code handles some of the unification examples discussed\nearlier in the post. Starting with the pattern matching example, where\nvariables are just one one side:\n\n    \n    \n    >>> unify(parse_term('f(a, b, bar(t))'), parse_term('f(a, V, X)'), {}) {'V': b, 'X': bar(t)}\n\nNow the examples from the Unification section:\n\n    \n    \n    >>> unify(parse_term('f(a, V, bar(D))'), parse_term('f(D, k, bar(a))'), {}) {'D': a, 'V': k} >>> unify(parse_term('f(X, Y)'), parse_term('f(Z, g(X))'), {}) {'X': Z, 'Y': g(X)}\n\nFinally, let's try one where unification will fail due to two conflicting\ndefinitions of variable X.\n\n    \n    \n    >>> unify(parse_term('f(X, Y, X)'), parse_term('f(r, g(X), p)'), {}) None\n\nLastly, it's instructive to trace through the execution of the algorithm for a\nnon-trivial unification to see how it works. Let's unify the terms\nf(X,h(X),Y,g(Y)) and f(g(Z),W,Z,X):\n\n  * unify is called, sees the root is an App of function f and loops over the arguments.\n\n    * unify(X, g(Z)) invokes unify_variable because X is a variable, and the result is augmenting subst with X=g(Z)\n    * unify(h(X), W) invokes unify_variable because W is a variable, so the subst grows to {X=g(Z), W=h(X)}\n    * unify(Y, Z) invokes unify_variable; since neither Y nor Z are in subst yet, the subst grows to {X=g(Z), W=h(X), Y=Z} (note that the binding between two variables is arbitrary; Z=Y would be equivalent)\n    * unify(g(Y), X) invokes unify_variable; here things get more interesting, because X is already in the subst, so now we call unify on g(Y) and g(Z) (what X is bound to)\n\n      * The functions match for both terms (g), so there's another loop over arguments, this time only for unifying Y and Z\n      * unify_variable for Y and Z leads to lookup of Y in the subst and then unify(Z, Z), which returns the unmodified subst; the result is that nothing new is added to the subst, but the unification of g(Y) and g(Z) succeeds, because it agrees with the existing bindings in subst\n  * The final result is {X=g(Z), W=h(X), Y=Z}\n\n## Efficiency\n\nThe algorithm presented here is not particularly efficient, and when dealing\nwith large unification problems it's wise to consider more advanced options.\nIt does too much copying around of subst, and also too much work is repeated\nbecause we don't try to cache terms that have already been unified.\n\nFor a good overview of the efficiency of unification algorithms, I recommend\nchecking out two papers:\n\n  * \"An Efficient Unificaiton algorithm\" by Martelli and Montanari\n  * \"Unification: A Multidisciplinary survey\" by Kevin Knight\n\nFor comments, please send me an email.\n\n\u00a9 2003-2024 Eli Bendersky\n\nBack to top\n\n", "frontpage": false}
