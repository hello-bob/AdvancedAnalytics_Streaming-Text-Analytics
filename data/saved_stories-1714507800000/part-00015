{"aid": "40209511", "title": "A smooth and sharp image interpolation you probably haven't heard of", "url": "https://wordsandbuttons.online/a_smooth_and_sharp_image_interpolation.html", "domain": "wordsandbuttons.online", "votes": 1, "user": "ingve", "posted_at": "2024-04-30 10:48:26", "comments": 0, "source_title": "A smooth and sharp image interpolation you probably haven't heard of", "source_text": "A smooth and sharp image interpolation you probably haven't heard of\n\n# A smooth and sharp image interpolation you probably haven't heard of\n\nImage interpolation is guessing pixels between pixels. You can go without, but\nthen when you upscale your image or do any other image transformation, you'll\nsee square pixels.\n\nHere is the image to play with. The thing is interactive, you can control the\nframe with your mouse or your fingers.\n\nAnd here are the square pixels.\n\nYou can make the picture nice and smooth by employing an image interpolation.\n\nCommon interpolations for that are bilinear and bicubic. (see Bi-whatever\ntransformations) The downside of the bilinear one is that it makes your image\ncontinuous, so no squares, but not smooth, so the upscale still looks\nunnatural. The downside of bicubic interpolation is that, while it does give\nyou a nice and smooth picture, it smudges the thing a little so sharp features\n1 pixel wide appear to be 3 pixels wide after the interpolation.\n\nHere is another interpolation you probably haven't heard about before.\n\nThis is an inverse weight interpolation, a close relative of a SWInE, not to\nbe confused with \"spline\". The whole inverse weight family is not highly\npopular partially due to its computational issues, and partially, because\ntheir localization for spatial applications is tricky. But here, for the image\ninterpolation, the localization is not tricky at all.\n\nLet's start with a simple 1D case. We have a pair of values and we want to\ninterpolate between them.\n\nF(x_1) = y_1 F(x_2) = y_2\n\nLet's define the interpolating function as a weighted sum of values divided by\nthe sum of weights, where each weight is the inverse x-axis distance between\nthe data point we have and the interpolating function argument.\n\n\u2200 x, x_i < x < x_i+1 F(x) =| y_i * k(x - x_i) + y_i+1 * k(x_i+1 - x)  \n---|---  \nk(x - x_i) + k(x_i+1 - x)  \nk(x) =| 1  \n---|---  \nx  \n  \nYou probably noticed that when the argument coincides with one of the data\npoints, we have a division by zero, so the formula doesn't work. Well, in the\nideal world, it's okay, we do have a value for every data point anyway. We can\njoin or values outside or on the data points with the interpolation function\nfrom within.\n\nF(x_i) = y_i\n\nIn the real world, there are computationally problematic areas near the data\npoints. Which would have been bad, but image interpolation is an inherently\ninaccurate problem to begin with. You have to guess color values in the 0..255\ndiscrete range, so any computational error below 1/512 doesn't bother you at\nall.\n\nNow, for the image interpolation, the data points are, of course,\n2-dimensional.\n\nF(x_j, y_i) = z_ij\n\nAnd the formula is larger.\n\nF(x) =| z_ij k(x - x_j) k(y - y_i) + z_i(j+1) k(x_j+1 - x) k(y - y_i) +\nz_(i+1)j k(x - x_j) k(y_i+1 - y) + z_(i+1)(j+1) k(x_j+1 - x) k(y_i+1 - y)  \n---|---  \nk(x - x_j) k(y - y_i) + k(x_j+1 - x) k(y - y_i) + k(x - x_j) k(y_i+1 - y) +\nk(x_j+1 - x) k(y_i+1 - y)  \nk(x) =| 1  \n---|---  \nx  \n  \nBut, generally, it's the same formula. The sum of weighted values divided by\nthe sum of weights. The only non-obvious generalization here is that the\nweights for each axis contribute via a product and not a sum or anything else.\n\nThis interpolation gives us a continuous and smooth image, where every\ninterpolated value only depends on the four neighboring pixel values. The\nimage becomes smooth, but sharp features remain sharp.\n\nIndex #mathematics #algorithms #demos| \u2190 there's more.| \\+ Github & Twitter &\nRSS  \n---|---|---\n\n", "frontpage": false}
