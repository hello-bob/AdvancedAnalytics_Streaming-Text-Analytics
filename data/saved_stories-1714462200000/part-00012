{"aid": "40205821", "title": "Nil / Nil / Null / NSNull", "url": "https://nshipster.com/nil/", "domain": "nshipster.com", "votes": 1, "user": "Cloudef", "posted_at": "2024-04-30 00:13:06", "comments": 0, "source_title": "nil / Nil / NULL / NSNull", "source_text": "nil / Nil / NULL / NSNull - NSHipster\n\n# nil / Nil / NULL / NSNull\n\nWritten by Mattt January 7^th, 2013\n\nThis article has been translated into:\n\n    \u4e2d\u6587\n\nUnderstanding the concept of nothingness is as much a philosophical issue as\nit is a pragmatic one. We are inhabitants of a universe of somethings, yet\nreason in a logical universe of ontological uncertainties. As a physical\nmanifestation of a logical system, computers are faced with the intractable\nproblem of how to represent nothing with something.\n\nIn Objective-C, there are a few different varieties of nothing: NULL, nil,\nNil, and NSNull.\n\nSymbol| Value| Meaning  \n---|---|---  \nNULL| (void *)0| literal null value for C pointers  \nnil| (id)0| literal null value for Objective-C objects  \nNil| (Class)0| literal null value for Objective-C classes  \nNSNull| [NSNull null]| singleton object used to represent null  \n  \n## NULL\n\nC represents nothing as 0 for primitive values and NULL for pointers (which is\nequivalent to 0 in a pointer context).\n\nThe only time you see NULL in Objective-C code is when interacting with low-\nlevel C APIs like Core Foundation or Core Graphics.\n\n## nil\n\nObjective-C builds on C\u2019s representation of nothing by adding nil. nil is an\nobject pointer to nothing. Although semantically distinct from NULL, they are\ntechnically equivalent.\n\nNewly-alloc\u2018d NSObjects start life with their contents set to 0. For this\nreason, it\u2019s unnecessary to set an object\u2019s non-primitive properties to nil in\nits initializer.\n\nPerhaps the most notable behavior of nil, however, is that it can have\nmessages sent to it without a problem. In other languages, like Java, this\nkind of behavior would crash your program. But in Objective-C, invoking a\nmethod on nil returns a zero value \u2014 which is to say, \u201cnil begets nil\u201c. This\nfact alone significantly simplifies things for Objective-C developers, as it\nobviates the need to check for nil before doing anything:\n\n    \n    \n    // For example, this expression... if (name != nil && [name isEqualToString:@\"Steve\"]) { ... } // ...can be simplified to: if ([name isEqualToString:@\"Steve\"]) { ... }\n\nWith vigilance, this quirk of Objective-C can be a convenient feature rather\nthan a lurking source of bugs in your application.\n\nMake sure to guard against cases where nil values are unwanted, either with a\nprecondition assertion (NSParameterAssert) or by checking explicitly and\nreturning early.\n\n## Nil\n\nIn addition to nil, the Objective-C runtime defines Nil as a class pointer to\nnothing. This lesser-known title-case cousin of nil doesn\u2019t show up much very\noften, but it\u2019s at least worth noting.\n\n## NSNull\n\nOn the framework level, Foundation defines NSNull. NSNull defines a class\nmethod (+null) that returns the singleton NSNull object. NSNull represents\nnothing with an actual object rather than a zero value like nil or NULL.\n\nNSNull is used throughout Foundation and other frameworks to skirt around the\nlimitations of collections like NSArray and NSDictionary not being able to\ncontain nil values. You can think of NSNull as effectively boxing the NULL or\nnil value so that it can be used in collections:\n\n    \n    \n    NSMutableDictionary *mutableDictionary = [NSMutableDictionary dictionary]; mutableDictionary[@\"someKey\"] = [NSNull null]; NSLog(@\"%@\", [mutableDictionary allKeys]); // @[@\"someKey\"]\n\nWhy does Objective-C have four values for nothing when one might suffice? It\nall goes back to a common refrain, about how Objective-C bridges the\nprocedural paradigm of C with Smalltalk-inspired object-oriented paradigm.\n\nIn the procedural world of C, values are indistinguishable from their numeric\nvalue. The same zero value might represent the first index of an array, the\nterminating byte of a string, or the simply result of \u201c2 - 2\u201d. Objective-C\nconstructs an object-oriented layer on top of these primitives, and in so\ndoing establishes a distinct logical universe. This abstraction allows for a\nsentinel value, the NSNull singleton, to be defined independently of numbers.\nnil (and Nil) therefore serve as intermediaries between these worlds at their\nconvergence point: zero.\n\nNSMutableHipster\n\nQuestions? Corrections? Issues and pull requests are always welcome.\n\nWritten by\n\nMattt\n\nMattt (@mattt) is a writer and developer in Portland, Oregon.\n\nNext Article\n\n# __attribute__\n\nA recurring theme of this publication has been the importance of a healthy\nrelationship with the compiler. Like any craft, one\u2019s effectiveness as a\npractitioner is contingent on how they treat their tools. Take good care of\nthem, and they\u2019ll take good care of you.\n\n\ud83c\udd6d \ud83c\udd6f \ud83c\udd0f NSHipster.com is released under a Creative Commons BY-NC License.\n\n", "frontpage": false}
