{"aid": "40173441", "title": "Fugue: A Basic List CRDT", "url": "https://mattweidner.com/2022/10/21/basic-list-crdt.html", "domain": "mattweidner.com", "votes": 1, "user": "stopachka", "posted_at": "2024-04-26 19:52:42", "comments": 0, "source_title": "Fugue: A Basic List CRDT - Matthew Weidner", "source_text": "Fugue: A Basic List CRDT - Matthew Weidner\n\n# Fugue: A Basic List CRDT\n\nMatthew Weidner | Oct 21st, 2022 Home | RSS Feed Keywords: collaborative text editing, CRDTs, Lists, Fugue, Plain Tree\n\n> Update: This post was previously titled \u201cPlain Tree: A Basic List CRDT\u201d.\n> Since posting, I and Martin Kleppmann wrote a paper about this list CRDT and\n> renamed it Fugue.\n\n> The main ideas in this post are described in slides here.\n\nCollaborative text editing was the original motivation for Conflict-free\nReplicated Data Types (CRDTs) (WOOT 2005), and it is still a popular use case.\nIt is also the most difficult CRDT application: the underlying List CRDTs have\ncomplicated algorithms and implementations, and there are a lot of them spread\nthroughout academic papers and software libraries. This makes them\nintimidating to study.\n\nIn this post, I describe Fugue, a basic List CRDT that I find fairly easy to\nunderstand, plus some simple implementations. My goal is that you will also\nunderstand it, filling in a gap from my previous post. Despite its simplicity,\nthe CRDT described here is my preferred List CRDT. In particular, Collabs uses\nit for all list implementations.\n\nYou don\u2019t need to have read the previous post, Designing Data Structures for\nCollaborative Apps, but its introduction may be useful if you are new to CRDTs\nand collaborative editing.\n\n# # What We Need: A \u201cUniquely Dense Total Order\u201d\n\nTo start, let\u2019s think about making a collaborative plain text editor, like\nthis Collabs demo. The editor\u2019s state is a text string, replicated on each\nuser\u2019s device, such that any user can insert (type) or delete characters from\nthe string.\n\nIn usual CRDT style, we mandate that all users see their own changes\nimmediately, but also reflect other users\u2019 changes once they receive them,\npossibly after an unbounded network delay. The end result must be consistent\nacross all users (CRDT correctness/strong eventual consistency) and should\nalso be \u201creasonable\u201d, e.g., edits to two different parts of the text each show\nup as expected.\n\nWe can generalize this problem to collaborating on arbitrary lists of\nimmutable values. Collaborating text editing is a special case: a list of\ncharacters. A List CRDT is a CRDT for such lists, with insert and delete\noperations. Formally, the operations on a List CRDT are:\n\n  * insert(i, x): Inserts a new element with value x at index i, between the existing elements at indices i and i+1. All later elements (index >= i+1) are shifted one to the right.\n  * delete(i): Deletes the element at index i. All later elements (index >= i+1) are shifted one the left.\n\nHandling concurrent operations\u2014while ensuring that the results are consistent\nfor all users and also reasonable\u2014is tricky because concurrent operations mess\nup each others\u2019 indices.\n\nAlice typed \" the\" at index 17, but concurrently, Bob typed \" gray\" in front\nof her. From Bob's perspective, Alice's insert should happen at index 22.\n\nTo handle this, most List CRDTs abandon indices internally. Instead, they\nassign each list element a unique immutable position at the time of insertion,\nwhich abstractly describes how to sort elements relative to each other. The\nuser-visible state of the List CRDT is just the elements sorted by their\npositions. insert and delete internally operate on positions, only using their\nindex argument i to look up the current positions at/near that index.\n\nIf two users insert elements concurrently, then those elements are sorted\nbased on their positions. Since all users see the same positions (and the same\nsort order on positions), they all sort these concurrent elements identically,\nensuring CRDT correctness. Deleting one element doesn\u2019t affect the positions\nof any other elements, so it is easy to ensure correctness for delete\noperations as well (see my previous post for details).\n\nSo, to make our List CRDT (hence our collaborative plain text editor), all we\nneed is a way to sort and create these unique immutable positions. In other\nwords, we need an implementation of the following TypeScript interface (also\non GitHub):\n\n    \n    \n    /** * Helper interface for sorting and creating unique immutable positions, * suitable for use in a List CRDT. * * @type P The type of positions. Treated as immutable. */ export interface UniquelyDenseTotalOrder<P> { /** * Usual compare function for sorts: returns negative if a < b in * their sort order, positive if a > b. */ compare(a: P, b: P): number; /** * Returns a globally unique new position c such that a < c < b. * * \"Globally unique\" means that the created position must be distinct * from all other created positions, including ones created concurrently * by other users. * * When a is undefined, it is treated as the start of the list, i.e., * this returns c such that c < b. Likewise, undefined b is treated * as the end of the list. */ createBetween(a: P | undefined, b: P | undefined): P; }\n\nMathematically, this interface says that positions must be drawn from a total\norder, with two extra requirements:\n\n  * It is dense: between any two elements a < b, there is a c such that a < c < b.\n  * Furthermore, it is uniquely dense: users can request a new globally unique such c between any a < b. (Unlike \u201cdense total order\u201d, this is not a standard math term.)\n\nA few notes about the UniquelyDenseTotalOrder interface:\n\n  * An implementation may choose to have state that it uses in compare and createBetween. For example, an optimized implementation will often store all the positions it has seen in a sorted data structure, then use that to answer compare calls quickly.\n  * An implementation may choose to behave like a CRDT itself, e.g,. by broadcasting messages to replicas of the UniquelyDenseTotalOrder on different devices (op-based CRDT) and/or by implementing a merge function (state-based CRDT). For example, an implementation might broadcast newly-created positions to other users in createBetween, together with metadata needed to compare them to existing positions.\n\nYou may be familiar with fractional indexing, which uses a dense total order,\nand wonder how UniquelyDenseTotalOrder differs. The answer is our added\n\u201cglobally unique\u201d requirement: if two users call createBetween(a, b)\nconcurrently for the same a and b, then we require both users to get different\nresults. That way, it\u2019s later possible to createBetween those two results.\n\nStarting from text \"ab\", two users concurrently type 'c' and 'd' at the same\nplace. After syncing, the order of 'c' and 'd' is arbitrary but must be\nconsistent across all users; suppose 'c' is first, so the text is now \"acdb\".\nLater, a user might try to type 'e' in between 'c' and 'd'. This doesn't work\nwith fractional indexing because 'c' and 'd' have the same position - there\nare no positions \"between\" them. But it does work in a\nUniquelyDenseTotalOrder-based List CRDT, due to our global uniqueness\nrequirement.\n\n# # A Basic Uniquely Dense Total Order\n\nIt remains to implement UniquelyDenseTotalOrder. That\u2019s what most List CRDT\npapers do, although they usually wrap it in the UniquelyDenseTotalOrder-to-\nList-CRDT conversion.\n\nThe rest of this post introduces a basic UniquelyDenseTotalOrder that I\nespecially like. Update: You can find more info in the paper \u201cThe Art of the\nFugue: Minimizing Interleaving in Collaborative Text Editing\u201d by myself and\nMartin Kleppmann.\n\nI\u2019ll focus on describing its semantics\u2014how its created positions compare to\neach other, independent of their literal representation\u2014and two simple,\nunoptimized implementations. In future posts, I hope to go into detail about\nproperties, comparisons to other List CRDTs, and optimized implementations.\n\n## # Intro: String Implementation\n\nStrings make good positions because they are already ordered, immutable, and\ncan be made arbitrarily long. You can even sort them in CRDT-unaware contexts,\ne.g., sorting a List CRDT\u2019s elements in a database using ORDER BY positions.\n\nTo make a UniquelyDenseTotalOrder<string>, we really just need to implement\ncreateBetween: given strings a and b with a < b in the lexicographic order,\nreturn a unique new string in between.\n\nHere\u2019s a simple way to do this:\n\n  * For convenience, we require that all positions end in 'R'.\n  * If a is not a prefix of b, append a globally unique new string to a (see next paragraph) and return that plus 'R'. This will be greater than a because it\u2019s longer, and less than b for the same reason that a < b.\n  * If a is a prefix of b (necessarily strictly shorter):\n\n    1. Replace the 'R' at the end of b with an 'L'.\n    2. Append a globally unique new string to that (see next paragraph) and return it plus 'R'. This will be less than b because 'L' < 'R', and greater than a because a is still a strictly-shorter prefix.\n\nHow do we get a globally unique new string? One strategy is to make it random\nand sufficiently long, e.g., a UUID. However, UUIDs are rather long, making it\ninefficient to send positions over the network. Instead, we use a causal dot:\na pair (replicaID, counter), where replicaID is a reasonably short ID for the\nlocal replica (device)\u2014say 10 random characters\u2014and counter is a local counter\nincremented for each causal dot.\n\nIn code (complete code here):\n\n    \n    \n    class StringFugue implements UniquelyDenseTotalOrder<string> { /** * Local replica ID, set in constructor. * All replicaIDs have the same length. */ readonly replicaID: string; // Local counter. private counter = 0; createBetween(a: string | undefined, b: string | undefined): string { // A globally unique new string, in the form of a causal dot. const uniqueStr = `${this.replicaID}${this.counter++}`; if (a !== undefined && b !== undefined) { if (!b.startsWith(a)) { // a is not a prefix of b. return a + uniqueStr + 'R'; } else { // a is a strict prefix of b. const bWithL = b.slice(0, -1) + 'L'; return bWithL + uniqueStr + 'R'; } } else { // Edge cases... } } // compare... }\n\nOr, a code golf version (note: slightly different positions):\n\n    \n    \n    class GolfStringFugue implements UniquelyDenseTotalOrder<string> { readonly id: string; private c = 0; createBetween(a = \"R\", b = \"Z\"): string { return ( // \"One line\" List CRDT :) (b.startsWith(a) ? b.slice(0, -1) + \"L\" : a) + `${this.id}${this.c++}R` ); } // ... }\n\nI wouldn\u2019t recommend using these exact implementations due to their large\nposition sizes, but they could be useful in a pinch.\n\n## # Semantics\n\nThe string implementation above works, but we\u2019d like to understand it better.\n\nI claim that mathematically, we can model our uniquely dense total order as a\nrooted binary-ish tree:\n\n  * Each node in the tree, except for the root, has a parent and a side (left or right child). Multiple nodes can have the same parent and side, which is why it is \u201cbinary-ish\u201d instead of binary.\n  * Each node is labelled by a causal dot.\n  * The sort order on nodes is given by the tree walk (in-order traversal): first traverse a node\u2019s left children, then visit the node, then traverse its right children. Ties between children on the same side are broken using the causal dots.\n  * Positions are given by nodes in the tree.\n\nExample of a tree with corresponding text \"abcde\". Observe that the root has\ntwo left children, sorted by their causal dots; this can happen due to\nconcurrent insertions.\n\nThe same tree with a new node (\"alice\", 2), inserted as a right child of\n(\"alice\", 0). Its text is now \"afbcde\". Note that this insertion corresponds\nto the hard case above (though with different text).\n\nIn our string implementation, each string position describes a path in this\ntree, starting at the root: it alternates between listing the next node\u2019s ID,\nand an 'L' or 'R' indicating whether the following node is a left or right\nchild.\n\nIn this tree with corresponding text \"abcd\", our string implementation assigns\nthe following positions:\n\n  * a: \"alice0R\"\n  * b: \"bobby0Ldavid0R\"\n  * c: \"bobby0R\"\n  * d: \"bobby0Rbobby1R\"\n\nObserve that these are lexicographically ordered.\n\nYou can check that the lexicographic order on strings then matches our sort\norder on tree nodes: the 'L's and 'R's ensure that a string position is sorted\nin between its left and right descendants in the tree (since \"L...\" < \"R\" <\n\"R...\"), and the lexicographic order on IDs matches the tree\u2019s tie-breaking\nrule.\n\nFinally, createBetween(a, b) works as follows:\n\n  * If a is not an ancestor of b, create a new node as a right child of a, labeled by a new causal dot, and return that. (Example above.)\n  * If a is an ancestor of b, create a new node as a left child of b, labeled by a new causal dot, and return that. (Example immediately below.)\n\nThe tree from above with another new node, (\"david\", 1). This time, it is a\n*left* child of (\"alice\", 1), since its left neighbor (\"alice\", 0) already has\na right descendant. The text is now \"agfbcde\".\n\n## # Tree Implementation\n\nWe can implement our tree-based description literally. That is, we can program\na UniquelyDenseTotalOrder using an explicit tree data stucture, instead of\nusing the string implementation\u2019s implicit tree.\n\nThe last section\u2019s description is not quite an actual algorithm: it describes\nFugue in terms of a single, global view of the tree, but in reality, each user\nhas their own local copy of the tree. These local copies may be out of sync:\nthere can be an arbitrary delay between when one user calls createBetween and\nwhen other users hear about the created position.\n\nThe real algorithm is:\n\n  * A position is represented as a causal dot.\n  * Each user has, as local state, a binary-ish tree of the above form.\n  * In createBetween, the user creates a new node in its local tree as described above. It broadcasts the node\u2019s causal dot, parent causal dot, and side (left or right child) to all other users; upon receiving this message, the other users add that node to their own local tree. createBetween returns the node\u2019s label (causal dot) as the created position.\n  * In compare(a, b), the user finds nodes with labels a and b in its local tree. It then compares those nodes by their sort order in the tree walk.\n\nThe implicit global tree we described in Semantics corresponds to the union of\nall users\u2019 local trees. Describing things in terms of this global tree makes\nsense because (1) local trees and the global tree both only grow over\ntime\u2014they don\u2019t remove or modify existing nodes\u2014and (2) a user only receives\ncalls to compare or createBetween on nodes that it has in its local tree, and\nit returns the same answer as the global tree.\n\n> Here we assume message delivery in causal order, to ensure that when a user\n> receives a node broadcast by createBetween, it has already received the\n> parent node.\n\nCode for this algorithm is here.\n\nWe can summarize the resulting List CRDT with a single slide:\n\n### # Comparing the Implementations\n\nRelative to our first string implementation, this tree implementation has much\nbetter network efficiency: its positions - which the corresponding List CRDT\nwill broadcast to other clients over the network - have small constant size\n(~15 bytes), and likewise for the messages broadcast by createBetween (~30\nbytes with optimized encoding). This contrasts with the string positions,\nwhich can become arbitrarily long.\n\nHowever, the tree implementation has worse memory usage: each user needs to\nstore a copy of the entire tree, including positions that are no longer used\nby the outer List CRDT (tombstones). Also, it is hard to use the tree\nimplementation\u2019s positions in CRDT-unaware contexts, since they can\u2019t be\ncompared directly like strings.\n\n> See also: the LSEQ paper\u2019s discussion of tombstones vs variable-size\n> identifiers for List CRDTs.\n\nIn practice, you\u2019ll want to use a more optimized implementation than either of\nthe two described here. I hope to discuss these later, but for now, note that\nCollabs\u2019s list data structures (e.g. CText) all use an optimized version of\nthe tree implementation.\n\n> Aside. I think of both implementations as variations on \u201cthe same\u201d Fugue\n> List CRDT. However, the CRDT literature sometimes assigns different names to\n> List CRDTs that are substantially similar except for (say) different\n> optimizations, e.g., LSEQ vs. Logoot. At the other extreme, it is sometimes\n> to possible to find two very different algorithms with the same user-visible\n> behavior: given a (distributed) trace of compare and createBetween (or\n> insert and delete) operations, they assign positions with the same sort\n> orders. The example I have in mind is Seph Gentle\u2019s description of a YATA-\n> style algorithm implementing RGA\u2019s behavior (section \u201cImproving the data\n> structure\u201d). An old version of the Fugue paper described a similar algorithm\n> equivalent to Fugue (\u201cList-Fugue\u201d); it\u2019s omitted from the current version\n> for length reasons, but we (myself, Seph, and Martin) hope to formalize it\n> in a future tech report.\n\n# # Conclusion\n\nI hope the above description of the Fugue List CRDT made sense and was not too\nintimidating. If you\u2019ve also read Designing Data Structures for Collaborative\nApps, you now know what I consider the fundamentals of CRDTs-for-\ncollaboration.\n\nAs I mentioned, Fugue is my preferred List CRDT. In future posts, I hope to\ndetail why this is, and also put it in context within the List CRDT\nliterature. So look forward to posts on:\n\n  * Fugue\u2019s \u201cnon-interleaving\u201d guarantees.\n  * Other List CRDTs: Logoot, Treedoc, RGA, LSEQ, YATA, and how they relate to Fugue.\n  * Efficient implementations.\n\nUpdate: You can find info about most of these topics (non-interleaving\nguarantees, relation to RGA and YATA/Yjs, and efficient implementations) in\nthe Fugue paper.\n\nIn the meantime, feel free to ask me about these directly.\n\nWorking TypeScript code for the above snippets is on GitHub.\n\n\u2b50\ufe0f I'm on the market for a software engineering job post-PhD.\n\nHome \u2022 Matthew Weidner \u2022 PhD student at CMU CSD \u2022 mweidner037@gmail.com \u2022\n@MatthewWeidner3 \u2022 LinkedIn \u2022 GitHub\n\n", "frontpage": false}
