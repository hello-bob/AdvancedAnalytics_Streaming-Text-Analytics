{"aid": "40174516", "title": "Giving Rust a chance for in-kernel codecs", "url": "https://lwn.net/SubscriberLink/970565/ac5ffc2e9ad20f1e/", "domain": "lwn.net", "votes": 3, "user": "orf", "posted_at": "2024-04-26 21:28:39", "comments": 0, "source_title": "Giving Rust a chance for in-kernel codecs [LWN.net]", "source_text": "Giving Rust a chance for in-kernel codecs [LWN.net]\n\nLWN .net News from the source\n\n  * Content\n\n    * Weekly Edition\n    * Archives\n    * Search\n    * Kernel\n    * Security\n    * Events calendar\n    * Unread comments\n    * LWN FAQ\n    * Write for us\n\n| |\n\nSubscribe / Log in / New account\n\n# Giving Rust a chance for in-kernel codecs\n\n## [LWN subscriber-only content]\n\n### Welcome to LWN.net\n\nThe following subscription-only content has been made available to you by an LWN subscriber. Thousands of subscribers depend on LWN for the best news from the Linux and free software communities. If you enjoy this article, please consider accepting the trial offer on the right. Thank you for visiting LWN.net!| | \n\n### Free trial subscription\n\nTry LWN for free for 1 month: no payment or credit card required. Activate\nyour trial subscription now and see why thousands of readers subscribe to\nLWN.net.  \n---  \n  \nApril 26, 2024\n\nThis article was contributed by Daniel Almeida\n\nVideo playback is undeniably one of the most important features in modern\nconsumer devices. Yet, surprisingly, users are by and large unaware of the\nintricate engineering involved in the compression and decompression of video\ndata, with codecs being left to find a delicate balance between image quality,\nbandwidth, and power consumption. In response to constant performance\npressure, video codecs have become complex and hardware implementations are\nnow common, but programming these devices is becoming increasingly difficult\nand fraught with opportunities for exploitation. I hope to convey how Rust can\nhelp fix this problem.\n\nSome time ago, I proposed to the Linux media community that, since codec data\nis particularly sensitive, complex, and hard to parse, we could write some of\nthe codec drivers in Rust to benefit from its safety guarantees. Some\nimportant concerns were raised back then, in particular that having to\nmaintain a Rust abstraction layer would impose a high cost on the already\noverstretched maintainers. So I went back to the drawing board and came up\nwith a new, simpler proposal; it differs a bit from the general flow of the\nRust-for-Linux community so far by realizing that we can convert error-prone\ndriver sections without writing a whole layer of Rust bindings.\n\n#### The dangers of stateless decoders\n\nMost of my blog posts at Collabora have focused on the difference between\nstateful and stateless codec APIs. I recommend a quick reading of this one for\nan introduction to the domain before following through with this text. This\ntalk by my colleague Nicolas Dufresne is also a good resource. Stateless\ndecoders operate as a clean slate and, in doing so, they require a lot of\nmetadata that is read directly from the bit stream before decoding each and\nevery frame. Note that this metadata directs the decoding, and is used to make\ncontrol-flow decisions within the codec; erroneous or incorrect metadata can\neasily send a codec astray.\n\nUser space is responsible for parsing this metadata and feeding it to the\ndrivers, which perform a best-effort validation routine before consuming it to\nget instructions on how to proceed with the decoding process. It is the\nkernel's responsibility to comb through and transfer this data to the\nhardware. The parsing algorithms are laid out by the codec specification,\nwhich are usually hundreds of pages long and subject to errata like any other\ntechnical document.\n\nGiven the above, it is easy to see the finicky nature of stateless decoder\ndrivers. Not long ago, some researchers crafted a program capable of emitting\na syntactically correct but semantically non-compliant H.264 stream exploiting\nthe weaknesses that are inherent to the decoding process. Interested readers\ncan refer themselves to the actual paper.\n\n#### The role of Video4Linux2 codec libraries\n\nA key aspect of hardware accelerators is that they implement significant parts\nof a workload in hardware, but often not all of it. For codec drivers in\nparticular, this means that the metadata is not only used to control the\ndecoding process in the device, it is also fed to codec algorithms that run in\nthe CPU.\n\nThese codec algorithms are laid out in the codec's specification, and it would\nnot make sense for each driver to have a version of that in their source code,\nso that part gets abstracted away as kernel libraries. To see the code\nimplementing these codecs, look at files like\ndrivers/media/v4l2-core/v4l2-vp9.c, v4l2-h264.c, and v4l2-jpeg.c in the kernel\nsources.\n\nWhat's more, with the introduction of more AV1 drivers and the proposed V4L2\nStateless Encoding API, the number of codec libraries will probably increase.\nWith the stateless encoding API, a new challenge will be to capture parts of\nthe metadata in the kernel successfully, bit by bit, while parsing data\nreturned from the device. For more information on the stateless encoding\ninitiative, see this talk, by my colleague Andrzej Pietrasiewicz or the\nmailing-list discussion. A tentative user-space API for H.264 alongside a\ndriver for Hantro devices was also submitted last year, although the\ndiscussion is still on a RFC level.\n\n#### Why Rust?\n\nSecurity and reliability are paramount in software development; in the kernel,\ninitiatives aimed at improving automated testing and continuous integration\nare gaining ground. As much as this is excellent news, it does not fix many of\nthe hardships that stem from the use of C as the chosen programming language.\nThe work being done by Miguel Ojeda and others in the Rust-for-Linux project\nhas the potential to finally bring relief to problems such as complex locking,\nerror handling, bounds checking, and hard-to-track ownership that span a large\nnumber of domains and subsystems.\n\nCodec code is also plagued by many of the pitfalls listed above and we have\ndiscussed at length about the finicky and error-prone nature of codec\nalgorithms and metadata. Said algorithms, as we've seen, will use the metadata\nto guide the control flow on the fly and also to index into various memory\nlocations. That has been shown to be a major problem in the user-space stack,\nand the problem is even more critical at the kernel level.\n\nRust can help by making a whole class of errors impossible, thus significantly\nreducing the attack surface. In particular, raw pointer arithmetic and\nproblematic memcpy() calls can be eliminated, array accesses can be checked at\nrun time, and error paths can be greatly simplified. Complicated algorithms\ncan be expressed more succinctly through the use of more modern abstractions\nsuch as iterators, ranges, generics, and the like. These add up to a more\nsecure driver and, thus, a more secure system.\n\n#### Porting codec code to Rust, piece by piece\n\nIf adding a layer of Rust abstractions is deemed problematic for some, a\ncleaner approach can focus on using Rust only where it matters by converting a\nfew functions at a time. This technique composes well, and works by\ninstructing the Rust compiler to generate code that obeys the C calling\nconvention by using the extern \"C\" construct, so that existing C code in the\nkernel can call into Rust seamlessly. Name-mangling also has to be turned off\nfor whatever symbols the programmer plans to expose, while a [repr(C)]\nannotation ensures that the Rust compiler will lay out structs, unions, and\narrays as C would for interoperability.\n\nOnce the symbol and machine code are in the object file, calling these\nfunctions now becomes a matter of matching signatures and declarations between\nC and Rust. Maintaining the ABI between both layers can be challenging but,\nfortunately, this is a problem that is solved by employing cbindgen, a\nstandalone tool from Mozilla that is capable of generating an equivalent C\nheader from a Rust file.\n\nWith that header in place, the linker will do the rest, and a seamless\ntransition into Rust will take place at run time. Once in Rust land, one can\nfreely call other Rust functions that do not have to be annotated with\n#[no_mangle] or extern \"C\", which is why it's advisable to use the C entry\npoint only as a facade for the native Rust code:\n\n    \n    \n    // The C API for C drivers. pub mod c { use super::*; #[no_mangle] pub extern \"C\" fn v4l2_vp9_fw_update_probs_rs( probs: &mut FrameContext, deltas: &bindings::v4l2_ctrl_vp9_compressed_hdr, dec_params: &bindings::v4l2_ctrl_vp9_frame, ) { super::fw_update_probs(probs, deltas, dec_params); }\n\nIn this example, v4l2_vp9_fw_update_probs_rs() is called from C, but\nimmediately jumps to fw_update_probs(), a native Rust function where the\nactual implementation lives.\n\nIn a C driver, the switch is as simple as calling the _rs() version instead of\nthe C version. The parameters needed by a Rust function can be neatly packed\ninto a struct on the C side, freeing the programmer from writing abstractions\nfor a lot of types.\n\n#### Putting that to the test\n\nGiven the ability to rewrite error-prone C code into Rust one function at a\ntime, I believe it is now time to rewrite our codec libraries, together with\nany driver code that directly accesses the bit stream parameters. Thankfully,\nit is easy to test codec drivers and their associated libraries, at least for\ndecoders.\n\nThe Fluster tool by Fluendo can automate conformance testing by running a\ndecoder and comparing its results against that of the canonical\nimplementation. This gives us an objective metric for regressions and, in\neffect, tests the whole infrastructure: from drivers, to codec libraries and,\neven, the V4L2 framework. My plan is to see Rust code being tested on KernelCI\nin the near future so as to assess its stability and establish a case for its\nupstreaming.\n\nBy gating any new Rust code behind a KConfig option, users can keep running\nthe C implementation while the continuous-integration system tests the Rust\nversion. It is by establishing this level of trust that I hope to see Rust\ngain ground in the kernel.\n\nReaders willing to judge this initiative may refer to the patch set I sent to\nthe Linux media mailing list. It ports the VP9 library written by\nPietrasiewicz into Rust as a proof of concept, converting both the hantro and\nrkvdec drivers to use the new version. It then converts error-prone parts of\nrkvdec itself into Rust, which encompasses all code touching the VP9 bit\nstream parameters directly, showing how Rust and C can both coexist within a\ndriver.\n\nSo far, only one person has replied, noting that the patches did not introduce\nany regressions for them. I plan on discussing this idea further in the next\nMedia Summit, the annual gathering of the kernel media developers that is yet\nto take place this year.\n\nIn my opinion, not only should we strive to convert the existing libraries to\nRust, but we should also aim to write the new libraries that will invariably\nbe needed directly in Rust. If this proves successful, I hope to show that\nthere will be no more space for C codec libraries in the media tree. As for\ndrivers, I hope to see Rust used where it matters: in places where its safety\nand improved ergonomics proves worth the hassle.\n\n#### Getting involved\n\nThose willing to contribute to this effort may start by introducing themselves\nto video codecs by reading the specification for their codec of choice. A good\nsecond step is to refer to GStreamer or FFmpeg to learn how stateless codec\nAPIs can be used to drive a codec accelerator. For GStreamer, in particular,\nlook for the v4l2codecs plugin. Learning cbindgen is better accomplished by\nreferring to the cbindgen documentation provided by Mozilla. Lastly, reading\nthrough a codec driver like rkvdec and the V4L2 memory-to-memory stateless\nvideo decoder interface documentation can also be helpful.\n\nIndex entries for this article  \n---  \nKernel| Development tools/Rust  \nKernel| Video4Linux2  \nGuestArticles| Almeida, Daniel  \n  \n> Did you like this article? Please accept our trial subscription offer to be\n> able to see more content like it and to participate in the discussion.  \n> ---  \n  \n(Log in to post comments)\n\nCopyright \u00a9 2024, Eklektix, Inc. Comments and public postings are copyrighted\nby their creators. Linux is a registered trademark of Linus Torvalds\n\n", "frontpage": false}
