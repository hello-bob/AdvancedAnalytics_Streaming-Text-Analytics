{"aid": "40204297", "title": "Highlights from Git 2.45", "url": "https://github.blog/2024-04-29-highlights-from-git-2-45/", "domain": "github.blog", "votes": 1, "user": "nalgeon", "posted_at": "2024-04-29 21:23:34", "comments": 0, "source_title": "Highlights from Git 2.45", "source_text": "Highlights from Git 2.45 - The GitHub Blog\n\nSkip to content\n\n  * Open Source\n\n# Highlights from Git 2.45\n\nGit 2.45 is here with experimental support for reftables, and SHA-256\ninteroperability. Get our take on the latest here.\n\nAuthor\n\nTaylor Blau\n\nApril 29, 2024\n\nThe open source Git project just released Git 2.45 with features and bug fixes\nfrom over 96 contributors, 38 of them new. We last caught up with you on the\nlatest in Git back when 2.44 was released.\n\nTo celebrate this most recent release, here is GitHub\u2019s look at some of the\nmost interesting features and changes introduced since last time.\n\n## Preliminary reftable support\n\nGit 2.45 introduces preliminary support for a new reference storage backend\ncalled \u201creftable,\u201d promising faster lookups, reads, and writes for\nrepositories with any number of references.\n\nIf you\u2019re unfamiliar with our previous coverage of the new reftable format,\ndon\u2019t worry, this post will catch you up to speed (and then some!). But if you\njust want to play around with the new reference backend, you can initialize a\nnew repository with --ref-format=reftable like so:\n\n    \n    \n    $ git init --ref-format=reftable /path/to/repo Initialized empty Git repository in /path/to/repo/.git $ cd /path/to/repo $ git commit --allow-empty -m 'hello reftable!' [main (root-commit) 2eb0810] hello reftable! $ ls -1 .git/reftable/ 0x000000000001-0x000000000002-565c6bf0.ref tables.list $ cat .git/reftable/tables.list 0x000000000001-0x000000000002-565c6bf0.ref\n\nWith that out of the way, let\u2019s jump into the details. If you\u2019re new to this\nseries, or didn\u2019t catch our initial coverage of the reftable feature, don\u2019t\nworry, here\u2019s a refresher. When we talk about references in Git, we\u2019re\nreferring to the branches and tags that make up your repository. In essence, a\nreference is nothing more than a name (like refs/heads/my-feature, or\nrefs/tags/v1.0.0) and the object ID of the thing that reference points at.\n\nGit has historically stored references in your repository in one of two ways:\neither \u201cloose\u201d as a file inside of $GIT_DIR/refs (like $GIT_DIR/refs/heads/my-\nfeature) or \u201cpacked\u201d as an entry inside of the file at $GIT_DIR/packed_refs.\n\nFor most repositories today, the existing reference backend works fine. For\nrepositories with a truly gigantic number of references, however, the existing\nbackend has some growing pains. For instance, storing a large number of\nreferences as \u201cloose\u201d can lead to directories with a large number of entries\n(slowing down lookups within that directory) and/or inode exhaustion.\nLikewise, storing all references in a single packed_refs file can become\nexpensive to maintain, as even small reference updates require a significant\nI/O-cost to rewrite the entire packed_refs file on each update.\n\nThat\u2019s where the reftable format comes in. Reftable is an entirely new format\nfor storing Git references. Instead of storing loose references, or constantly\nupdating a large packed_refs file, reftable implements a binary format for\nstoring references that promises to achieve:\n\n  * Near constant-time lookup for individual references, and near constant-time verification that a given object ID is referred to by at least one reference.\n  * Efficient lookup of entire reference namespaces through prefix compression.\n  * Atomic reference updates that scale with the size of the reference update, not the number of overall references.\n\nThe reftable format is incredibly detailed (curious readers can learn more\nabout it in more detail by reading the original specification), but here\u2019s a\nhigh-level overview. A repository can have any number of reftables (stored as\n*.ref files), each of which is organized into variable-sized blocks. Blocks\ncan store information about a collection of references, refer to the contents\nof other blocks when storing references across a collection of blocks, and\nmore.\n\nThe format is designed to both (a) take up a minimal amount of space (by\nstoring reference names with prefix compression) and (b) support fast lookups,\neven when reading the .ref file(s) from a cold cache.\n\nMost importantly, the reftable format supports multiple *.ref files, meaning\nthat each reference update transaction can be processed individually without\nhaving to modify existing *.ref files. A separate compaction process describes\nhow to \u201cmerge\u201d a range of adjacent *.ref files together into a single *.ref\nfile to maintain read performance.\n\nThe reftable format was originally designed by Shawn Pearce for use in JGit to\nbetter support the large number of references stored by Gerrit. Back in our\nHighlights from Git 2.35 post, we covered that an implementation of the\nreftable format had landed in Git. In that version, Git did not yet know how\nto use the new reftable code in conjunction with its existing reference\nbackend system, meaning that you couldn\u2019t yet create repositories that store\nreferences using reftable.\n\nIn Git 2.45, support for a reftable-powered storage backend has been\nintegrated into Git\u2019s generic reference backend system, meaning that you can\nplay with reftable on your own repository by running:\n\n    \n    \n    $ git init --ref-format=reftable /path/to/repo\n\n[source, source, source, source, source, source, source, source, source,\nsource]\n\n## Preliminary support for SHA-1 and SHA-256 interoperability\n\nReturning readers of this series will be familiar with our ongoing coverage of\nthe Git project\u2019s hash function transition. If you\u2019re new around here, or need\na refresher, don\u2019t worry!\n\nGit identifies objects (the blobs, trees, commits, and tags that make up your\nrepository) by a hash of their contents. Since its inception, Git has used the\nSHA-1 hash function to hash and identify objects in a repository.\n\nHowever, the SHA-1 function has known collision attacks (e.g., Shattered, and\nShambles), meaning that a sufficiently motivated attacker can generate a\ncolliding pair of SHA-1 inputs, which have the same SHA-1 hash despite\ncontaining different contents. (Many providers, like GitHub, use a SHA-1\nimplementation that detects and rejects inputs that contain the telltale signs\nof being part of a colliding pair attack. For more details, see our post,\nSHA-1 collision detection on GitHub.com).\n\nAround this time, the Git project began discussing a plan to transition from\nSHA-1 to a more secure hash function that was not susceptible to the same\nchosen-prefix attacks. The project decided on SHA-256 as the successor to\nGit\u2019s use of SHA-1 and work on supporting the new hash function began in\nearnest. In Git 2.29 (released in October 2020), Git gained experimental\nsupport for using SHA-256 instead of SHA-1 in specially-configured\nrepositories. That feature was declared no longer experimental in Git 2.42\n(released in August 2023).\n\nOne of the goals of the hash function transition was to introduce support for\nrepositories to interoperate between SHA-1 and SHA-256, meaning that\nrepositories could in theory use one hash function locally, while pushing to\nanother repository that uses a different hash function.\n\nGit 2.45 introduces experimental preliminary support for limited\ninteroperability between SHA-1 and SHA-256. To do this, Git 2.45 introduces a\nnew concept called the \u201ccompatibility\u201d object format, and allows you to refer\nto objects by either their given hash, or their \u201ccompatibility\u201d hash. An\nobject\u2019s compatibility hash is the hash of an object as it would have been\nwritten under the compatibility hash function.\n\nTo give you a better sense of how this new feature works, here\u2019s a short demo.\nTo start, we\u2019ll initialize a repository in SHA-256 mode, and declare that\nSHA-1 is our compatibility hash function:\n\n    \n    \n    $ git init --object-format=sha256 /path/to/repo Initialized empty Git repository in /path/to/repo/.git $ cd /path/to/repo $ git config extensions.compatObjectFormat sha1\n\nThen, we can create a simple commit with a single file (README) whose contents\nare \u201cHello, world!\u201d:\n\n    \n    \n    $ echo 'Hello, world!' >README $ git add README $ git commit -m \"initial commit\" [main (root-commit) 74dcba4] initial commit Author: A U Thor <author@example.com> 1 file changed, 1 insertion(+) create mode 100644 README\n\nNow, we can ask Git to show us the contents of the commit object we just\ncreated with cat-file. As we\u2019d expect, the hash of the commit object, as well\nas its root tree are computed using SHA-256:\n\n    \n    \n    $ git rev-parse HEAD | git cat-file --batch 74dcba4f8f941a65a44fdd92f0bd6a093ad78960710ac32dbd4c032df66fe5c6 commit 202 tree ace45d916e870ce0fadbb8fc579218d01361da4159d1e2b5949f176b1f743280 author A U Thor <author@example.com> 1713990043 -0400 committer C O Mitter <committer@example.com> 1713990043 -0400 initial commit\n\nBut we can also tell git rev-parse to output any object IDs using the\ncompatibility hash function, allowing us to ask for the SHA-1 object ID of\nthat same commit object. When we print its contents out using cat-file, its\nroot tree OID is a different value (starting with 7dd4941980 instead of\nace45d916e), this time computed using SHA-1 instead of SHA-256:\n\n    \n    \n    $ git rev-parse --output-object-format=sha1 HEAD 2a4f4a2182686157a2dc887c46693c988c912533 $ git rev-parse --output-object-format=sha1 HEAD | git cat-file --batch 2a4f4a2182686157a2dc887c46693c988c912533 commit 178 tree 7dd49419807b37a3afd2f040891a64d69abb8df1 author A U Thor <author@example.com> 1713990043 -0400 committer C O Mitter <committer@example.com> 1713990043 -0400 initial commit\n\nSupport for this new feature is still considered experimental, and many\nfeatures may not work quite as you expect them to. There is still much work\nahead for full interoperability between SHA-1 and SHA-256 repositories, but\nthis release delivers an important first step towards full interoperability\nsupport.\n\n[source]\n\n  * If you\u2019ve ever scripted around your repository, then you have no doubt used git rev-list to list commits or objects reachable from some set of inputs. rev-list can also come in handy when trying to diagnose repository corruption, including investigating missing objects.\n\nIn the past, you might have used something like git rev-list --missing=print\nto gather a list of objects which are reachable from your inputs, but are\nmissing from the local repository. But what if there are missing objects at\nthe tips of your reachability query itself? For instance, if the tip of some\nbranch or tag is corrupt, then you\u2019re stuck:\n\n    \n        $ git rev-parse HEAD | tr 'a-f1-9' '1-9a-f' >.git/refs/heads/missing $ git rev-list --missing=print --all | grep '^?' fatal: bad object refs/heads/missing\n\nHere, Git won\u2019t let you continue, since one of the inputs to the reachability\nquery itself (refs/heads/missing, via --all) is missing. This can make\ndebugging missing objects in the reachable parts of your history more\ndifficult than necessary.\n\nBut with Git 2.45, you can debug missing objects even when the tips of your\nreachability query are themselves missing, like so:\n\n    \n        $ git rev-list --missing=print --all | grep '^?' ?70678e7afeacdcba1242793c3d3d28916a2fd152\n\n[source]\n\n  * One of Git\u2019s lesser-known features are \u201creference logs,\u201d or \u201creflogs\u201d for short. These reference logs are extremely useful when asking questions about the history of some reference, such as: \u201cwhat was main pointing at two weeks ago?\u201d or \u201cwhere was I before I started this rebase?\u201d.\n\nEach reference has its own corresponding reflog, and you can use the git\nreflog command to see the reflog for the currently checked-out reference, or\nfor an arbitrary reference by running git reflog refs/heads/some/branch.\n\nIf you want to see what branches have corresponding reflogs, you could look at\nthe contents of .git/logs like so:\n\n    \n        $ find .git/logs/refs/heads -type f | cut -d '/' -f 3-\n\nBut what if you\u2019re using reftable? In that case, the reflogs are stored in a\nbinary format, leaving tools like find out of your reach.\n\nGit 2.45 introduced a new sub-command git reflog list to show which references\nhave corresponding reflogs available to them, regardless of whether or not you\nare using reftable.\n\n[source]\n\n  * If you\u2019ve ever looked closely at Git\u2019s diff output, you might have noticed the prefixes a/ and b/ used before file paths to indicate the before and after versions of each file, like so:\n    \n        $ git diff HEAD^ -- GIT-VERSION-GEN diff --git a/GIT-VERSION-GEN b/GIT-VERSION-GEN index dabd2b5b89..c92f98b3db 100755 --- a/GIT-VERSION-GEN +++ b/GIT-VERSION-GEN @@ -1,7 +1,7 @@ #!/bin/sh GVF=GIT-VERSION-FILE -DEF_VER=v2.45.0-rc0 +DEF_VER=v2.45.0-rc1 LF=' '\n\nIn Git 2.45, you can now configure alternative prefixes by setting the\ndiff.srcPrefix and diff.dstPrefix configuration options. This can come in\nhandy if you want to make clear which side is which (by setting them to\nsomething like \u201cbefore\u201d and \u201cafter,\u201d respectively). Or if you\u2019re viewing the\noutput in your terminal, and your terminal supports hyperlinking to paths, you\ncould change the prefix to ./ to allow you to click on filepaths within a diff\noutput.\n\n[source]\n\n  * When writing a commit message, Git will open your editor with a mostly blank file containing some instructions, like so:\n    \n        # Please enter the commit message for your changes. Lines starting # with '#' will be ignored, and an empty message aborts the commit. # # On branch main # Your branch is up to date with 'origin/main.\n\nSince 2013, Git has supported customizing the comment character to be\nsomething other than the default #. This can come in handy, for instance, if\nyou\u2019re trying to refer to a GitHub issue by its numeric shorthand (e.g.\n#12345). If you write #12345 at the beginning of a line in your commit\nmessage, Git will treat the entire line as a comment and ignore it.\n\nIn Git 2.45, Git allows not just any single ASCII character, but any arbitrary\nmulti-byte character or even an arbitrary string. Now, you can customize your\ncommit message template by setting core.commentString (or core.commentChar,\nthe two are synonyms for one another) to your heart\u2019s content.\n\n[source]\n\n  * Speaking of comments, git config learned a new option to help document your .gitconfig file. The .gitconfig file format allows for comments beginning with a # character, meaning that everything following that # until the next newline will be ignored.\n\nThe git config command gained a new --comment option, which allows specifying\nan optional comment to leave at the end of the newly configured line, like so:\n\n    \n        $ git config --comment 'to show the merge base' merge.conflictStyle diff3 $ tail -n 2 .git/config [merge] conflictStyle = diff3 # to show the merge base\n\nThis can be helpful when tweaking some of Git\u2019s more esoteric settings to try\nand remember why you picked a particular value.\n\n[source]\n\n  * Sometimes when you are rebasing or cherry-picking a series of commits, one or more of those commits become \u201cempty\u201d (i.e., because they contain a subset of changes that have already landed on your branch).\n\nWhen rebasing, you can use the --empty option to specify how to handle these\ncommits. --empty supports a few options: \u201cdrop\u201d (to ignore those commits),\n\u201ckeep\u201d (to keep empty commits), or \u201cstop\u201d which will halt the rebase and ask\nfor your input on how to proceed.\n\nDespite its similarity to git rebase, git cherry-pick never had an equivalent\noption to --empty. That meant that if you were cherry-picking a long sequence\nof commits, some of which became empty, you\u2019d have to type either git cherry-\npick --skip (to drop the empty commit), or git commit --allow-empty (to keep\nthe empty commit).\n\nIn Git 2.45, git cherry-pick learned the same --empty option from git rebase,\nmeaning that you can specify the behavior once at the beginning of your\ncherry-pick operation, instead of having to specify the same thing each time\nyou encounter an empty commit.\n\n[source]\n\n## The rest of the iceberg\n\nThat\u2019s just a sample of changes from the latest release. For more, check out\nthe release notes for 2.45, or any previous version in the Git repository.\n\nTags:\n\n  * Git\n\n## We do newsletters, too\n\nGet tips, technical guides, and best practices right in your inbox.\n\nSubscribe\n\n## Table of Contents\n\n  * Preliminary reftable support\n  * Preliminary support for SHA-1 and SHA-256 interoperability\n  * The rest of the iceberg\n\n## More on Git\n\n### Highlights from Git 2.44\n\nThe first Git release of 2024 is here! Take a look at some of our highlights\non what's new in Git 2.44.\n\nTaylor Blau\n\n### Highlights from Git 2.43\n\nThe last Git release of 2023 is here! Take a look at some of our highlights on\nwhat's new in Git 2.43.\n\nTaylor Blau\n\n### Measuring Git performance with OpenTelemetry\n\nUse our new open source Trace2 receiver component and OpenTelemetry to capture\nand visualize telemetry from your Git commands.\n\nJeff Hostetler\n\n## Related posts\n\nOpen Source\n\n## Using open source to help the earth\n\nThis Earth Day, we discuss how tech and open source are helping two\norganizations combat the effects of a changing climate.\n\nPaull Young\n\nOpen Source\n\n## Empowering women through open source\n\nA discussion about how tech is aiding organizations fighting for gender\nequality, what it means to be a woman in tech and the world today, and advice\non how we all move forward.\n\nJiyon Yun\n\nCommunity\n\n## Game Bytes \u00b7 March 2024\n\nGame Bytes is our monthly series taking a peek at the world of gamedev on\nGitHub\u2014featuring game engine updates, game jam details, open source games,\nmods, maps, and more. Game on!\n\nLee Reilly\n\n## Explore more from GitHub\n\n### Open Source\n\nGaming, Git, new releases, and more.\n\nLearn more\n\n### GitHub Universe 2024\n\nGet tickets to the 10th anniversary of our global developer event on AI,\nDevEx, and security.\n\nGet tickets\n\n### GitHub Copilot\n\nDon't fly solo. Try 30 days for free.\n\nLearn more\n\n### Work at GitHub!\n\nCheck out our current job openings.\n\nLearn more\n\n## Subscribe to our newsletter\n\nCode with confidence. Discover tips, technical guides, and best practices in\nour biweekly newsletter just for devs.\n\n## Product\n\n  * Features\n  * Security\n  * Enterprise\n  * Customer Stories\n  * Pricing\n  * Resources\n\n## Platform\n\n  * Developer API\n  * Partners\n  * Atom\n  * Electron\n  * GitHub Desktop\n\n## Support\n\n  * Docs\n  * Community Forum\n  * Training\n  * Status\n  * Contact\n\n## Company\n\n  * About\n  * Blog\n  * Careers\n  * Press\n  * Shop\n\n  * GitHub on X\n  * GitHub on Facebook\n  * GitHub on YouTube\n  * GitHub on Twitch\n  * GitHub on TikTok\n  * GitHub on LinkedIn\n  * GitHub\u2019s organization on GitHub\n\n  * \u00a9 2024 GitHub, Inc.\n  * Terms\n  * Privacy\n\nWe use optional cookies to improve your experience on our websites and to\ndisplay personalized advertising based on your online activity. If you reject\noptional cookies, only cookies necessary to provide you the services listed\nabove will be used. You may change your selection on which cookies to accept\nby clicking \"Manage Cookies\" at the bottom of the page to change your\nselection. This selection is maintained for 180 days. Please review your\nselections regularly.\n\nHow to manage cookie preferences | Privacy Statement | Third-Party Cookies.\n\n", "frontpage": false}
