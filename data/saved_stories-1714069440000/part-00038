{"aid": "40154689", "title": "Memgraph's Deep Path Traversal Capabilities", "url": "https://memgraph.com/blog/memgraph-deep-path-traversal-capabilities", "domain": "memgraph.com", "votes": 10, "user": "m_pes", "posted_at": "2024-04-25 07:53:02", "comments": 0, "source_title": "Memgraph\u2019s Deep Path Traversal Capabilities", "source_text": "Memgraph\u2019s Deep Path Traversal Capabilities\n\nReal-Time Payments Authorization with Memgraph\n\nGet started\n\nBack to blog\n\nProduct\n\n# Memgraph\u2019s Deep Path Traversal Capabilities\n\nApril 24, 2024\n\nMatea Pesic\n\nLet\u2019s explore Memgraph deep path traversal algorithms, how they work, and how\nthey enhance query processing and boost performance in large-scale graph\nenvironments.\n\nIn contrast to other graph databases, Memgraph deep path traversals\nefficiently handle complex graph queries, as these algorithms have been built\ninto Memgraph's core. This eliminates the need for the overhead of business\nlogic on the application side.\n\n## Types of Deep Path Traversals\n\nThere are four built-in deep path traversal algorithms in Memgraph:\n\n  * Depth-first search (DFS),\n  * Breadth-first search (BFS),\n  * Weighted Shortest Path (WSP)\n  * All Shortest Paths (ASP).\n\nWe\u2019ll dive deep into each of these and give optimization solutions.\n\n## Depth-First Search\n\nThe DFS algorithm starts at the root node and explores each neighboring node\nas far as possible. The moment it reaches a dead-end, it backtracks until it\nfinds a new, undiscovered node, then traverses from that node to find more\nundiscovered nodes. In that way, the algorithm visits each node in the graph.\n\n### Using DFS\n\nDFS returns all the paths found between given nodes and is the most suitable\nfor determining the existence of paths between two nodes in a graph. If the\nalgorithm's output is null, no paths are available between the nodes. The DFS\nalgorithm will provide all possible paths if the output is not null.\n\nThe following query will show all the paths from node n to node m:\n\n    \n    \n    MATCH path=(n {id: 0})-[*]->(m {id: 8}) RETURN path;\n\nYou can filter relationships by type by defining the type after the\nrelationship list variable. You decide the direction by adding or removing an\narrow from the dash, constrain the path length and constrain the expansion\nbased on property values.\n\nThe following query showcases all three possibilities. It allows traversal\nonly across CLOSE_TO relationship type, it limits the path length to 5 hops\nand the expansion is allowed over relationships with an eu_border property\nequal to false and to nodes with a drinks_USD property less than 15:\n\n    \n    \n    MATCH path=(n {id: 0})-[r:CLOSE_TO *..5 (r, n | r.eu_border = false AND n.drinks_USD < 15)]->(m {id: 8}) RETURN path;\n\n## Breadth-First Search\n\nIn BFS, traversal starts from a single node, and the order of visited nodes is\ndecided based on nodes' breadth (distance from the source node). When we visit\na particular node, we can safely assume that all the nodes which are closer to\nthe source node have already been visited. This results in finding the\nshortest path from the source node to the newly visited node.\n\n### Using BFS\n\nBFS is ideal for finding the shortest path between two nodes in an unweighted\ngraph or between the start node and any other node in the graph. Since it\ntraverses all nodes at a given depth before moving to the next level, it\nensures that the shortest path is found.\n\nThe following query will show the shortest path between nodes n and m:\n\n    \n    \n    MATCH path=(n {id: 0})-[*BFS]->(m {id: 8}) RETURN path;\n\nSimilar to DFS, with BFS you can also filter relationships by type, constrain\nthe path length and constrain expansion based on the property values.\n\nThe following query showcases all the mentioned possibilities. It allows\ntraversal only across CLOSE_TO relationship type, it limits the path length to\nfrom 3 to 5 hops and the expansion is allowed over relationships with an\neu_border property equal to false and to nodes with a drinks_USD property less\nthan 15:\n\n    \n    \n    MATCH path=(n {id: 0})-[r:CLOSE_TO *BFS 3..5 (r, n | r.eu_border = false AND n.drinks_USD < 15)]->(m {id: 8}) RETURN path;\n\n## Weighted Shortest Path\n\nIn graph theory, the weighted shortest path problem is the problem of finding\na path between two nodes in a graph such that the sum of the weights of\nrelationships connecting nodes, or the sum of the weight of some node property\non the path, is minimized.\n\n### Using WSP\n\nUse the weighted shortest path algorithm to find the shortest path between two\nnodes in a graph with weighted edges. This is particularly useful in scenarios\nwhere the cost or distance between nodes varies, such as road networks (where\nedges represent distances or travel times) or communication networks (where\nedges represent latency or cost).\n\nWhen the goal is to optimize a specific metric along the path (e.g.,\nminimizing cost, maximizing profit), a weighted shortest path algorithm can\nhelp find the path that optimizes that metric.\n\nTo find the weighted shortest path between nodes based on the value of the\ntotal_USD node property, traversing only across CLOSE_TO relationships and\nreturning the result as a graph, use the following query:\n\n    \n    \n    MATCH path=(n {id: 0})-[:CLOSE_TO *WSHORTEST (r, n | n.total_USD)]-(m {id: 15}) RETURN path;\n\nTo find the weighted shortest path between nodes based on the value of the\ntotal_USD node property, traversing only across CLOSE_TO relationships with a\nmaximum length of 5 relationships while allowing the expansion only over\nrelationships with an eu_border property equal to false and to nodes with a\ndrinks_USD property less than 15 use the following query:\n\n    \n    \n    MATCH path=(n {id: 0})-[:CLOSE_TO *WSHORTEST 5 (r, n | n.total_USD) total_weight (r, n | r.eu_border = false AND n.drinks_USD < 15)]-(m {id: 46}) RETURN path,total_weight;\n\n## All Shortest Paths\n\nFinding all shortest paths is an expansion of the weighted shortest paths\nproblem. The goal of finding the shortest path is obtaining any minimum sum of\nweights on the path from one node to the other. However, there could be\nmultiple similar-weighted paths, and this algorithm fetches them all.\n\n### Using ASP\n\nUse the all shortest paths algorithm to find all shortest paths between nodes\nin a graph with weighted edges. This is useful when you need to analyze the\nnetwork structure or when there may be multiple identical shortest paths\nbetween pairs of nodes with minimum cost.\n\nThe following query searches for all shortest paths with a default weight\nequal to 1:\n\n    \n    \n    MATCH path=(n {id: 0})-[:CloseTo *ALLSHORTEST (r, n | 1)]-(m {id: 15}) RETURN path;\n\nTo find the all shortest paths between nodes based on the value of the\ntotal_USD node property, traversing only across CLOSE_TO relationships with\nmaximum length of 5 relationships while allowing the expansion only over\nrelationships with an eu_border property equal to false and to nodes with a\ndrinks_USD property less than 15 use the following query:\n\n    \n    \n    MATCH path=(n {id: 0})-[:CLOSE_TO *ALLSHORTEST 5 (r, n | n.total_USD) total_weight (r, n | r.eu_border = false AND n.drinks_USD < 15)]-(m {id: 46}) RETURN path,total_weight;\n\n## Optimizing Graph Traversals\n\nOptimizing traversal algorithms can significantly enhance performance in\nMemgraph, especially when dealing with large datasets. Techniques like\ncreating indexes, filtering by relationship type, and constraining path\nlengths can help streamline queries and reduce execution time.\n\nHere\u2019s an example of how you can optimize a traversal to find all cities\nconnected to London through the shortest road paths using BFS. We'll find all\nshortest paths from the starting node with the name property being London to\nall of the nodes in the dataset.\n\n    \n    \n    MATCH path=(:City {name: 'London'})-[*BFS]->(:City) RETURN path;\n\nThis query returns nodes representing cities London is connected to with the\ntransportation network. Since we didn't provide any restrictions and\nfiltering, the algorithm scans and traverses through the entire dataset which\ncan lead to slower performance on larger-scale datasets.\n\n### Creating Indexes\n\nCreating indexes on relevant properties can drastically speed up traversal\nqueries by shortening the database scanning time. In Memgraph, indexes can be\ncreated using Cypher queries like:\n\n    \n    \n    CREATE INDEX ON :Node(property)\n\nThis query creates an index on the property of nodes, enabling faster lookups\nduring algorithm traversals.\n\n### Filtering by Relationship Type\n\nUnlike other graph databases, Memgraph supports inline filtering, enabling\nefficient traversal through graph structures. This approach allows for precise\ncontrol over how relationships are traversed, including filtering by type and\nthe direction of the relationship, avoiding subsequent filtering using the\nWHERE clause.\n\nLet's take the same example from above, but this time limiting traversal\nacross roads only, eliminating other types of transportation. In other words,\nwe'll provide a relationship type filter to the previously used query and\nlimit it only to traverse through the relationship type ROAD.\n\n    \n    \n    MATCH path=(:City {name: 'London'})-[r:ROAD *BFS]->(:City) RETURN path;\n\nThis way, Memgraph eliminates traversing through unnecessary relationships,\nshortening the execution time.\n\n### Filtering by Property Value\n\nTraversal algorithms allow an expression filter that determines if an\nexpansion is allowed over a certain relationship or node property value.\n\nLet's take the same example from above, but this time limiting traversal\nthrough the European roads only. We want to apply filters to the relationship\nproperty continent and set the value to exactly Europe.\n\n    \n    \n    MATCH path=(:City {name: 'London'})-[r:ROAD *BFS (r, n | r.continent = 'Europe')]->(:City) RETURN path;\n\nThis way, Memgraph eliminates traversing through unnecessary relationships and\nproperty values, shortening the execution time even more.\n\n### Constraining Path Length\n\nBy constraining the length of the path, the algorithm won't do unnecessary\nscanning and return results after finding results with the maximum number of\nhops.\n\nThe following query will only return the results if the path is equal to or\nshorter than 2 hops:\n\n    \n    \n    MATCH path=(:City {name: 'London'})-[r:ROAD *BFS ..2 (r, n | r.continent = 'Europe')]->(:City) RETURN path;\n\nBy knowing your dataset's schema and filtering and limiting the wanted\nresults, you can achieve a much more optimized way of using the traversal\nalgorithms.\n\n## Conclusion\n\nUnlike many graph databases that rely on external libraries or plugins for\ndeep path traversals, Memgraph integrates these algorithms directly into the\ncore system. This direct integration means less overhead and better\nperformance. The traversals can take full advantage of Memgraph\u2019s internal\noptimizations and architecture.\n\nThe variety of supported algorithms\u2014DFS, BFS, WSP, and ASP\u2014allows users to\ntailor their graph queries to the specific demands of their data and use case\nscenarios.\n\nAdditionally, Memgraph's support for advanced query optimization techniques,\nsuch as creating indexes, filtering by relationship type or property values,\nand constraining path lengths, empowers developers to fine-tune their queries\nfor maximum performance. These capabilities are essential for exploring and\nanalyzing large-scale graph data efficiently and can unlock deeper insights\ninto complex datasets.\n\nFor developers and data scientists looking for a robust, scalable, and\nefficient solution for graph data management, Memgraph offers a compelling\nplatform that enhances both the development experience and the analytical\ncapabilities of your applications. Whether you are working on real-time\nrecommendation systems, network analysis, or complex routing problems,\nMemgraph's powerful traversal and optimization features are designed to meet\nyour needs. Start leveraging these advanced capabilities in Memgraph today to\ndrive your graph-based projects toward more innovative and performant\noutcomes.\n\n## Further Reading\n\n  * Graph Search Algorithms: Developer's Guide\n\n  * Graph Database Query Languages You Should Try\n\n  * How to Optimize Deep Path Traversals\n\nJoin us on Discord!\n\nFind other developers performing graph analytics in real time with Memgraph.\n\nJoin now\n\nProduct\n\nDatabase\n\nTools\n\nEnterprise\n\nPricing\n\nEnterprise license\n\nLegal\n\nPartners\n\nContact us\n\nResources\n\nUse cases\n\nBlog\n\nResource hub\n\nBenchmark\n\nPlayground\n\nDevelopers\n\nDocs\n\nPython\n\nNetworkX\n\nNeo4j Devs\n\nCompany\n\nAbout us\n\nCareers\n\nCompany\n\nAbout us\n\nCareers\n\n\u00a9 2024 Memgraph Ltd. All rights reserved.\n\nTerms & Privacy\n\n", "frontpage": false}
