{"aid": "40093658", "title": "Git Bisect-Find", "url": "https://kevincox.ca/2024/05/19/git-bisect-find/", "domain": "kevincox.ca", "votes": 7, "user": "nalgeon", "posted_at": "2024-04-20 01:09:56", "comments": 0, "source_title": "Announcing git bisect-find - Kevin Cox", "source_text": "Announcing git bisect-find - Kevin Cox\n\n# You appear to be using Chrome\n\nChrome is harmful for the web. Google abuses its market share to push user-\nharmful features to the web platform. In order to reduce Google's harmful\ninfluence should use any other browser.\n\nFor an example of a harmful API being pushed by Google read my post about the\nWeb Environment Integrity API.\n\nConsider using another browser, Firefox is great.\n\n# Announcing git bisect-find\n\nPosted in 30 days\n\nThis is a small utility that I wrote to compliment git bisect. git bisect is a\nfantastic tool. In the most basic usage you give it one \u201cgood\u201d commit (a\ncommit that doesn\u2019t yet include some property) and at least one \u201cbad\u201d commit\n(one that does have it). git bisect will then guide you through the search,\npicking commits to test that cut the search space in half. This allows you to\nefficiently identify the first commit with a particular feature.\n\nHowever one of the premises of git bisect is that you know a good commit.\nOften times you notice a bug but don\u2019t yet know a good version. Was that\nbroken in the last release? Or is it new? Maybe it was broken unnoticed in the\npast couple of releases? Sure, you could start checking out various revisions\nto see if the bug is there, but why do this manually?\n\nThis is where git bitsect-find comes in. It will take just a bad commit, and\nstep back looking for the first good commit. Basic usage looks like this:\n\n## Basic Usage\n\nFirst check out your bad commit:\n\n    \n    \n    $ git checkout main\n\nThen start bisecting with git bisect-find bad.\n\nYou will be asked to start a regular git bisect run, type y.\n\nThen a new candidate commit will be checked out. If the candidate commit is\nbad run git bisect-find bad and a new candidate will be checked out. Repeat\nthe test and mark process until a good commit is found.\n\nOnce you have a good commit found you are done with git bisect-find. Just run\ngit bisect good and continue with the regular bisection process.\n\n## More\n\nThere are more complete docs in the README. There are also more features to\nadd (like automatic bisection). However the basics have already been quite\nuseful to me so I figured I would share.\n\n## Mechanism\n\nThere really isn\u2019t anything too special about the way it works. It just jumps\nback twice as far each time (following first parents). All state is logged via\nregular git bisect so once you find a good commit all of your git bisect-find\nbad (and git bisect-find skip) commands are remembered as regular git bisect\nbad and git bisect skip would be.\n\nI do wonder if jumping back by twice as much is optimal. Obviously jumping\nright to the first commit would reduce the number of git bisect-find steps.\nBut would result in more git bisect. But git bisect is quite efficient. (Not\nto mention that the first commit is likely not particularly interesting.) At\nsome point I should probably work out which growth pattern results in the\nshortest number of total steps. However I think the optimal number also\ndepends on the distribution of the age of the target commit. But either way\ndoubling works well enough for this tool to be very helpful for me.\n\nFeed - Newsletter - Private Feedback\n\n", "frontpage": true}
