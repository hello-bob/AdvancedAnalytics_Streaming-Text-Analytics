{"aid": "40156037", "title": "Bluefin", "url": "https://hackage.haskell.org/package/bluefin-0.0.4.3/docs/Bluefin.html", "domain": "haskell.org", "votes": 1, "user": "todsacerdoti", "posted_at": "2024-04-25 11:17:16", "comments": 0, "source_title": "Bluefin", "source_text": "Bluefin\n\nbluefin-0.0.4.3: The Bluefin effect system\n\n  * Instances\n  * Quick Jump\n  * Source\n  * Contents\n  * Index\n\nSafe Haskell| Safe-Inferred  \n---|---  \nLanguage| Haskell2010  \n  \nBluefin\n\nContents\n\n  * In brief\n  * Introduction\n\n    * Multiple effects of the same type\n    * Exception handles\n    * Effect scoping\n    * Type signatures\n  * Comparison to other effect systems\n\n    * Everything except effectful\n    * effectful\n  * Implementation\n  * Tips\n  * Creating your own effects\n  * Example\n\n# In brief\n\nBluefin is an effect system which allows you to freely mix a variety of\neffects, including\n\n  * Bluefin.EarlyReturn, for early return\n  * Bluefin.Exception, for exceptions\n  * Bluefin.IO, for I/O\n  * Bluefin.State, for mutable state\n  * Bluefin.Stream, for streams\n\nBluefin effects are accessed through explicitly though value-level handles.\n\n# Introduction\n\nBluefin is a Haskell effect system with a new style of API. It is distinct\nfrom prior effect systems because effects are accessed explicitly through\nvalue-level handles which occur as arguments to effectful operations. Handles\n(such as State handles, which allow access to mutable state) are introduced by\nhandlers (such as evalState, which sets the initial state). Here's an example\nwhere a mutable state effect handle, sn, is introduced by its handler,\nevalState.\n\n    \n    \n    -- If n < 10 then add 10 to it, otherwise -- return it unchanged example1 :: Int -> Int example1 n = runPureEff $ -- Create a new state handle, sn, and -- initialize the value of the state to n evalState n $ \\sn -> do n' <- get sn when (n' < 10) $ modify sn (+ 10) get sn\n    \n    \n    >>> example1 5 15 >>> example1 12 12\n\nThe handle sn is used in much the same way as an STRef or IORef.\n\n## Multiple effects of the same type\n\nA benefit of value-level effect handles is that it's simple to have multiple\neffects of the same type in scope at the same time. It is simple to\ndisambiguate them, because they are distinct values! By contrast, existing\neffect systems require the disambiguation to occur at the type level, which\nimposes challenges.\n\nHere is a Bluefin example with two mutable Int state effects in scope.\n\n    \n    \n    -- Compare two values and add 10 -- to the smaller example2 :: (Int, Int) -> (Int, Int) example2 (m, n) = runPureEff $ evalState m $ \\sm -> do evalState n $ \\sn -> do do n' <- get sn m' <- get sm if n' < m' then modify sn (+ 10) else modify sm (+ 10) n' <- get sn m' <- get sm pure (n', m')\n    \n    \n    >>> example2 (5, 10) (15, 10) >>> example2 (30, 3) (30, 13)\n\n## Exception handles\n\nBluefin exceptions are accessed through Exception handles. An Exception handle\nis introduced by a handler, such as try, and that handler is where the\nexception, if thrown, will be handled. This arrangement differs from normal\nHaskell exceptions in two ways. Firstly, every Bluefin exception will be\nhandled \u2013 it is not possible to have an unhandled Bluefin exception. Secondly,\na Bluefin exception can be handled in only one place \u2013 normal Haskell\nexceptions can be handled in a variety of places, and the closest handler of\nmatching type on the stack will be the one that will be chosen upon throw.\n\nexample3 shows how to use Bluefin to calculate the sum of numbers from 1 to n,\nbut stop if the sum becomes bigger than 20. The exception handle, ex, which\nhas type Exception String e, cannot escape the scope of its handler, try. If\nthrown it will be handled at that try, and nowhere else.\n\n    \n    \n    example3 :: Int -> Either String Int example3 n = runPureEff $ try $ \\ex -> do evalState 0 $ \\total -> do for_ [1..n] $ \\i -> do soFar <- get total when (soFar > 20) $ do throw ex (\"Became too big: \" ++ show soFar) put total (soFar + i) get total\n    \n    \n    >>> example3 4 Right 10 >>> example3 10 Left \"Became too big: 21\"\n\n## Effect scoping\n\nBluefin's use of the type system is very similar to Control.Monad.ST: it\nensures that a handle can never escape the scope of its handler. That is, once\nthe handler has finished running there is no way you can use the handle\nanymore.\n\n## Type signatures\n\nThe type signatures of Bluefin functions follow a common pattern which looks\nlike\n\n    \n    \n    (e1 :> es, ...) -> <Handle> e1 -> ... -> Eff es r\n\nHere <Handle> could be, for example, State Int, Exception String or IOE.\nConsider the function below, incrementReadLine. It reads integers from\nstandard input, accumulates them into a state; it returns when it reads the\ninput integer 0 and it throws an exception if it encounters an input line it\ncannot parse.\n\nFirstly, let's look at the arguments, which are all handles to Bluefin\neffects. There is a state handle, an exception handle, and an IO handle, which\nallow modification of an Int state, throwing a String exception, and\nperforming IO operations respectively. They are each tagged with a different\neffect type, e1, e2 and e3 respectively, which are always kept polymorphic.\n\nSecondly, let's look at the return value, Eff es (). This means the\ncomputation is performed in the Eff monad and the resulting value produced is\nof type (). Eff is tagged with the effect type es, which is also always kept\npolymorphic.\n\nFinally, let's look at the constraints. They are what tie together the effect\ntags of the arguments to the effect tag of the result. For every argument\neffect tag en we have a constraint en :> es. That tells us the that effect\nhandle with tag en is allowed to be used within the effectful computation. If\nwe didn't have the e1 :> es constraint, for example, that would tell us that\nthe State Int e1 isn't actually used anywhere in the computation.\n\nGHC and editor tools like HLS do a good job of inferring these type\nsignatures.\n\n    \n    \n    incrementReadLine :: (e1 :> es, e2 :> es, e3 :> es) => State Int e1 -> Exception String e2 -> IOE e3 -> Eff es () incrementReadLine state exception io = do withJump $ \\break -> forever $ do line <- effIO io getLine i <- case readMaybe line of Nothing -> throw exception (\"Couldn't read: \" ++ line) Just i -> pure i when (i == 0) $ jumpTo break modify state (+ i)\n\nNow let's look at how we can run such a function. Each effect must be handled\nby a corresponding handler, for example runState for the state effect, try for\nthe exception effect and runEff for the IO effect. The type signatures of\nhandlers also follow a common pattern, which looks like\n\n    \n    \n    (forall e. <Handle> e -> Eff (e :& es) a) -> Eff es r\n\nThis means that the effect e, corresponding to the handle <Handle> e, has been\nhandled and removed from the set of remaining effects, es. (The signatures for\nrunEff and runPureEff are slightly different because they remove Eff itself.)\nHere, then, is how we can run incrementReadLine:\n\n    \n    \n    runIncrementReadLine :: IO (Either String Int) runIncrementReadLine = runEff $ \\io -> do try $ \\exception -> do ((), r) <- runState 0 $ \\state -> do incrementReadLine state exception io pure r >>> runIncrementReadLine 1 2 3 0 Right 6 >>>> runIncrementReadLine 1 2 3 Hello Left \"Couldn't read: Hello\"\n\n# Comparison to other effect systems\n\n## Everything except effectful\n\nThe design of Bluefin is strongly inspired by and based on effectful. All the\npoints in effectful's comparison of itself to other effect systems apply to\nBluefin too.\n\n## effectful\n\nThe major difference between Bluefin and effectful is that in Bluefin effects\nare represented as value-level handles whereas in effectful they are\nrepresented only at the type level. effectful could be described as \"a well-\ntyped implementation of the ReaderT IO pattern\", and Bluefin could be\ndescribed as a well-typed implementation of something even simpler: the Handle\npattern. The aim of the Bluefin style of value-level effect tracking is to\nmake it even easier to mix effects, especially effects of the same type. Only\ntime will tell which approach is preferable in practice.\n\n\"Why not just implement Bluefin as an alternative API on top of effectful?\"\n\nIt would be great to share code between the two projects! But I don't know to\nimplement Bluefin's Bluefin.Compound effects in effectful.\n\n# Implementation\n\nBluefin has a similar implementation style to effectful. Eff is an opaque\nwrapper around IO, State is an opaque wrapper around IORef, and throw throws\nan actual IO exception. Coroutine is implemented simply as a function.\n\n    \n    \n    newtype Eff (es :: Effects) a = UnsafeMkEff (IO a) newtype State s (st :: Effects) = UnsafeMkState (IORef s) newtype Coroutine a b (s :: Effects) = UnsafeMkCoroutine (a -> IO b)\n\nThe type parameters of kind Effects are phantom type parameters which track\nwhich effects can be used in an operation. Bluefin uses them to ensure that\neffects cannot escape the scope of their handler, in the same way that the\ntype parameter to the ST monad ensures that mutable state references cannot\nescape runST. When the type system indicates that there are no unhandled\neffects it is safe to run the underlying IO action using unsafePerformIO,\nwhich is the approach taken to implement runPureEff. Consequently, it is\nimpossible for a pure value retured from runPureEff to access any Bluefin\ninternal state or throw a Bluefin internal exception.\n\n# Tips\n\n  * Use NoMonoLocalBinds and NoMonomorphismRestriction for better type inference. (You can always change back to the default after adding inferred type signatures.)\n  * Writing a handler often requires an explicit type signature.\n\n# Creating your own effects\n\nSee Bluefin.Compound.\n\n# Example\n\n    \n    \n    countPositivesNegatives :: [Int] -> String countPositivesNegatives is = runPureEff $ evalState (0 :: Int) $ \\positives -> do r <- try $ \\ex -> evalState (0 :: Int) $ \\negatives -> do for_ is $ \\i -> do case compare i 0 of GT -> modify positives (+ 1) EQ -> throw ex () LT -> modify negatives (+ 1) p <- get positives n <- get negatives pure $ \"Positives: \" ++ show p ++ \", negatives \" ++ show n case r of Right r' -> pure r' Left () -> do p <- get positives pure $ \"We saw a zero, but before that there were \" ++ show p ++ \" positives\"\n\nProduced by Haddock version 2.29.1\n\nCollapse All Instances By Default\n\nYou can find any exported type, constructor, class, function or pattern\ndefined in this package by (approximate) name.\n\nKey| Shortcut  \n---|---  \ns| Open this search box  \nesc| Close this search box  \n\u2193,ctrl + j| Move down in search results  \n\u2191,ctrl + k| Move up in search results  \n\u21b5| Go to active search result\n\n", "frontpage": false}
