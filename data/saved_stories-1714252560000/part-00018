{"aid": "40180334", "title": "Testing HTML with Modern CSS", "url": "https://heydonworks.com/article/testing-html-with-modern-css/", "domain": "heydonworks.com", "votes": 1, "user": "leephillips", "posted_at": "2024-04-27 14:44:07", "comments": 0, "source_title": "Testing HTML With Modern CSS: HeydonWorks", "source_text": "Testing HTML With Modern CSS: HeydonWorks\n\nSkip to content\n\n# Testing HTML With Modern CSS\n\n7th April 2024\n\nA long time ago, I wrote a reasonably popular bit of open source code called\nREVENGE.CSS (the caps are intentional). You should know upfront, this hasn\u2019t\nbeen maintained for years and if I ever did get round to maintaining it, it\nwould only be to add the \u201cNo Maintenance Intended\u201d badge. Alas, that would\ntechnically count as maintenance.\n\nAnyway, I was recently reminded of its existence because, curiously, I was\ncontacted by a company who were looking to sponsor its development. Nothing\ncame of this, which is the usual way these impromptu side quests go. But it\ngot me thinking again about CSS-based testing (testing HTML integrity using\nCSS selectors) and what recent advancements in CSS itself may have to offer.\n\nIn a nutshell, the purpose of REVENGE.CSS is to apply visual regressions to\nany markup anti-patterns. It makes bad HTML look bad, by styling it using a\nsickly pink color and the infamous Comic Sans MS font. It was provided as a\nbookmarklet for some time but I zapped that page in a Marie Kondo-inspired re-\nplatforming of this site.\n\nThe selectors used to apply the vengeful styles make liberal use of negation,\nwhich was already available *squints at commit history* about 11 years ago?\n\nHere are a few rules pertaining to anchors:\n\n    \n    \n    a:not([href]), a[href=\"\"], a[href$=\"#\"], a[href^=\"javascript\"] {...}\n\nRespectively, these cover anchors that\n\n  1. Don\u2019t have href attributes (i.e. don\u2019t conventionally function as links and are not focusable by keyboard)\n  2. Have an empty href attribute\n  3. Have an href attribute suffixed with a # (an unnamed page fragment)\n  4. Are doing some bullhonky with JavaScript, which is the preserve of <button>s\n\nSince I released REVENGE.CSS, I did some more thinking about CSS-based testing\nand even gave a 2016 talk about it at Front Conference Zurich called \u201cTest\nDriven HTML\u201d.\n\nOne of the things I recommended in this talk was the use of an invalid CSS\nERROR property to describe the HTML shortcomings. This way, you could inspect\nthe element and read the error in developer tools. It\u2019s actually kind of neat,\nbecause you get a warning icon for free!\n\nYou can even restyle this particular ERROR property in your Chrome dev tools\n(to remove the line-through style, for starters) should you wish.\n\nFor context, REVENGE.CSS previously used pseudo-content to describe the\nerrors/anti-patterns on the page itself. As you might imagine, this came up\nagainst a lot of layout issues and often the errors were not (fully) visible.\nHence diverting error messages into the inspector.\n\n## Custom properties\n\nIn 2017, a year or so after the Zurich conference, we would get custom\nproperties: a standardized way to create arbitrary properties/variables in\nCSS. Not only does this mean we can now define and reuse error styling, but we\ncan also secrete error messages without invalidating the stylesheet:\n\n    \n    \n    :root { --error-outline: 0.25rem solid red; } a:not([href]) { outline: var(--error-outline); --error: 'The link does not have an href. Did you mean to use a <button>?'; }\n\nOf course, if there are multiple errors, only one would take precedence. So,\ninstead, it makes sense to give them each a unique\u2014if prefixed\u2014name:\n\n    \n    \n    a[href^=\"javascript\"] { outline: var(--error-outline); --error-javascript-href: 'The href does not appear to include a location. Did you mean to use a <button>?'; } a[disabled] { outline: var(--error-outline); --error-anchor-disabled: 'The disabled property is not valid on anchors (links). Did you mean to use a <button>?'; }\n\nNow both errors will show up upon inspection in dev tools.\n\n## Expressive selectors\n\nSince 2017, we\u2019ve benefited from a lot more CSS selector expressiveness. For\nexample, when I wrote REVENGE.CSS, I would not have been able to match a\n<label> that both\n\n  * lacks a for attribute and\n  * does not contain an applicable form element.\n\nNow I can match such a thing:\n\n    \n    \n    label:not(:has(:is(input,output,textarea,select))):not([for]) { outline: var(--error-outline); --error-unassociated-label: 'The <label> neither uses the `for` attribute nor wraps an applicable form element' }\n\nBy the same token, I can also test for elements that do not have applicable\nparents or ancestors. In this case, I\u2019m just using a --warning-outline style,\nsince inputs outside of <form>s are kind of okay, sometimes.\n\n    \n    \n    input:not(form input) { outline: var(--warning-outline); --error-input-orphan: 'The input is outside a <form> element. Users may benefit from <form> semantics and behaviors.' }\n\n(Side note: It\u2019s interesting to me that :not() allows you to kind of \u201creach\nup\u201d in this way.)\n\n## Cascade layers\n\nThe specificity of these testing selectors varies wildly. Testing for an empty\n<figcaption> requires much less specificity than testing for a <figure> that\ndoesn\u2019t have an ARIA label or a descendant <figcaption>. To ensure all the\ntests take precedence over normal styles, they can be placed in the highest of\ncascade layers.\n\n    \n    \n    @layer base, elements, layout, theme, tests;\n\nTo ensure errors take precedence over warnings we\u2019re probably looking at\ndeclaring error and warning layers within our tests.css stylesheet (should we\nbe maintaining just one). Here is how that might look for a suite of <figure>\nand <figcaption> tests:\n\n    \n    \n    @layer warnings { figure[aria-label]:not(:has(figcaption)) { outline: var(--warning-outline); --warning-figure-label-not-visible: 'The labeling method used is not visible and only available to assistive software'; } figure[aria-label] figcaption { outline: var(--warning-outline); --warning-overridden-figcaption: 'The figure has a figcaption that is overridden by an ARIA label'; } } @layer errors { figcaption:not(figure > figcaption) { outline: var(--error-outline); --error-figcaption-not-child: 'The figcaption is not a direct child of a figure'; } figcaption:empty { padding: 0.5ex; /* give it some purchase */ outline: var(--error-outline); --error-figcaption-empty: 'The figcaption is empty'; } figure:not(:is([aria-label], [aria-labelledby])):not(:has(figcaption)) { outline: var(--error-outline); --error-no-figure-label: 'The figure is not labeled by any applicable method'; } figure > figcaption ~ figcaption { outline: var(--error-outline); --error-multiple-figcaptions: 'There are two figcaptions for one figure'; } }\n\n## Testing without JavaScript?\n\nInevitably, some people are going to ask \u201cWhy don\u2019t you run these kinds of\ntests with JavaScript? Like most people already do?\u201d\n\nThere\u2019s nothing wrong with using JavaScript to test JavaScript and there\u2019s\nlittle wrong with using JavaScript to test HTML. But given the power of modern\nCSS selectors, it\u2019s possible to test for most kinds of HTML pattern using CSS\nalone. No more elem.parentNode shenanigans!\n\nAs a developer who works visually/graphically, mostly in the browser, I prefer\nseeing visual regressions and inspector information to command line logs. It\u2019s\na way of testing that fits with my workflow and the technology I\u2019m most\ncomfortable with.\n\nI like working in CSS but I also think it\u2019s fitting to use declarative code to\ntest declarative code. It\u2019s also useful that these tests just live inside a\n.css file. Separation of concerns means you can use the tests in your\ndevelopment stack, across development stacks, or lift them out into a\nbookmarklet to test any page on the web.\n\nI\u2019m a believer in design systems that do not provide behavior (JavaScript).\nInstead, I prefer to provide just styles and document state alongside them.\nThere are a few reasons for this but the main one is to sublimate the design\nsystem away from JS framework churn. The idea of shipping tests with the\ncomponent CSS written in CSS sits well with me.\n\n## How I use this in client work\n\nI had a client for whom I was auditing various sites/properties for\naccessibility. In the process, I identified a few inaccessible patterns that\nwere quite unique to them and not something generic tests (like those that\nmake up the Lighthouse accessibility suite) would identify.\n\nOne of these patterns was the provision of breadcrumb trails unenclosed by a\nlabeled <nav> landmark (as recommended by the WAI). I can identify any use of\nthis pattern with the following test:\n\n    \n    \n    ol[class*=\"breadcrumb\"]:not(:is(nav[aria-label], nav[aria-labelledby]) ol) { outline: var(--error-outline); --error-undiscoverable-breadcrumbs: 'It looks like you have provided breadcrumb navigation outside a labeled `<nav>` landmark'; }\n\n(Note that this test finds both the omission of a <nav> element and the\ninclusion of a <nav> element but without a label.)\n\nAnother issue that came up was content not falling within a landmark\n(therefore escaping screen reader landmark navigation):\n\n    \n    \n    body :not(:is(header,nav,main,aside,footer)):not(:is(header,nav,main,aside,footer) *):not(.skip-link) { outline: var(--error-outline); --error-content-outside-landmark: 'You have some content that is not inside a landmark (header, nav, main, aside, or footer)'; }\n\n(A more generalized version of this test would have to include the equivalent\nARIA roles [role=\"banner\"], [role=\"navigation\"] etc.)\n\nAs a consultant, I\u2019m often not permitted to access a client\u2019s stack directly,\nto set up or extend accessibility-related tests. Where I am able to access the\nstack, there\u2019s often a steep learning curve as to how everything fits\ntogether. I also have to go through various internal processes to contribute.\nIt\u2019s often the case there are multiple stacks/sites/platforms involved and\nthey each have idiosyncratic approaches to testing. Some may not have Node-\nbased testing in place yet at all. Some may do testing in a language I can\nbarely read or write, like Java.\n\nSince a test stylesheet is just CSS I can provide it independently. I don\u2019t\nneed to know the stack (or stacks) to which it can be applied. It\u2019s an\nexpedient way for clients to locate instances of specific bad patterns I\u2019ve\nidentified for them\u2014and without having to \u201conboard\u201d me to help them do so.\n\nAnd it\u2019s not just accessibility issues CSS tests can be used to find. What\nabout HTML bloat?\n\n    \n    \n    :is(div > div > div > div > *) { outline: var(--warning-outline); --warning-divitis: 'There\u2019s a whole lot of nesting going on here. Is it needed to achieve the layout? (it is not)'; }\n\nOr general usability?\n\n    \n    \n    header nav:has(ul > ul) { outline: var(--warning-outline); --warning-nested-navigation: 'You appear to be using tiered/nested navigation in your header. This can be difficult to traverse. Index pages with tables of content are preferable.'; }\n\nIf you liked this post, please check out my videos about the web and maybe buy\na T-shirt or hoodie or something.\n\nRSS\n\nSite and contents by Heydon Pickering Enquiries: heydon@heydonworks.com\n\n", "frontpage": false}
