{"aid": "40187286", "title": "Building a Simple Load Balancer Part 2", "url": "https://hcrypt.net/2024/03/10/Building-a-Simple-Load-Balancer-Part-2/", "domain": "hcrypt.net", "votes": 1, "user": "udev4096", "posted_at": "2024-04-28 09:36:28", "comments": 0, "source_title": "Building a Simple Load Balancer Part 2", "source_text": "Building a Simple Load Balancer Part 2 \u00b7 Hcrypt\n\n### Hcrypt\n\n# Building a Simple Load Balancer Part 2\n\nI am quite late on the second part. I had implemented it just after writing\nthe first part but forgot to write the second part. So, here we are.\n\nCheckout the first part, if you haven\u2019t already. It\u2019s nothing fancy, very\nbasic and simple Go. The third iteration of this post (if I get to it) would\nprobably be implementing other algorithms, apart from round robin.\n\nImplementing round robin is dead simple. You just create a slice of servers\nand keep going over each index of servers.\n\n## Implementation\n\nSo, we will be running a load balancer (remember, load balancer is also just a\nserver) and forward requests to the servers in the slice or array one by one.\nSimple right? Let\u2019s dive in.\n\nCreate a separate folder named balancer and create a new file balancer.go\n\nFirst, we will create a slice. Before that, make sure that the servers are\nrunning on the desired port.\n\nI have added a port flag for the previous program which makes it easy to test\nthis on a single machine.\n\n    \n    \n    go run server.go -port 8081 go run server.go -port 8082 ...\n\nAnd then declare a slice:\n\n    \n    \n    var servers = []string{ \"127.0.0.1:8081\", \"127.0.0.1:8082\", }\n\nNow, as we did in the previous part, create a simple HTTP server with route to\n\u201c/hello\u201d.\n\n> Note: I used /hello endpoint in the last post and that is why I am using\n> /hello here. You can use any other routes as well.\n    \n    \n    func main() { http.HandleFunc(\"/hello\", loadBalancer) log.Println(\"starting load balancer at 8000\") log.Fatal(http.ListenAndServe(\":8000\", nil)) }\n\nAll that\u2019s left to do is configure the route to redirect or so to say act as a\nproxy (just like nginx) for the underlying servers.\n\nHow do we approach it? First let\u2019s make a counter. We will increment it after\nchoosing the server.\n\n    \n    \n    var counter uint64\n\nFor selecting the server, we can use modulo (%) operator. The purpose of using\nthe modulo operator (%) here is to ensure that the index variable always falls\nwithin the range of valid server indices (0 to len(servers)-1).\n\n    \n    \n    index := counter % uint64(len(servers)) serverURL := servers[index] counter++\n\nWe got the address, now we will redirect the request to the desired server.\nFor that, we can use NewSingleHostReverseProxy function from httputil package.\n\n    \n    \n    proxy := httputil.NewSingleHostReverseProxy(&url.URL{ Scheme: \"http\", Host: serverURL }) proxy.ServeHTTP(w, r)\n\nAfter that, just print out the address of the client and the server.\n\n    \n    \n    fmt.Printf(\"Received request from %s, forwarding to %s\\n\", r.RemoteAddr, serverURL)\n\nThe complete program:\n\n    \n    \n    package main import ( \"fmt\" \"log\" \"net/http\" \"net/http/httputil\" \"net/url\" ) var servers = []string{ \"127.0.0.1:8081\", \"127.0.0.1:8082\", } var counter uint64 func main() { http.HandleFunc(\"/hello\", loadBalancer) log.Println(\"starting load balancer at 8000\") log.Fatal(http.ListenAndServe(\":8000\", nil)) } func loadBalancer(w http.ResponseWriter, r *http.Request) { index := counter % uint64(len(servers)) serverURL := servers[index] counter++ proxy := httputil.NewSingleHostReverseProxy(&url.URL{ Scheme: \"http\", Host: serverURL }) proxy.ServeHTTP(w, r) fmt.Printf(\"Received request from %s, forwarding to %s\\n\", r.RemoteAddr, serverURL) }\n\n## Testing time\n\nRun the load balancer:\n\n    \n    \n    go run balancer/balancer.go\n\nSend a curl request to it:\n\n    \n    \n    curl 127.0.0.1:8000/hello\n\nLet\u2019s see the server log, we should get the headers and \u201chello world!\u201d message\nthat we implemented in the previous part.\n\nScore! We got the forwarded request to the desired server. We can make\nmultiple curl requests to verify if round robin is working.\n\nSeems to be working as expected! In the next part, I will explore different\nload balancing algorithms and try to implement it. Thank you for sticking till\nthe end!\n\nKeep experimenting!\n\n", "frontpage": false}
