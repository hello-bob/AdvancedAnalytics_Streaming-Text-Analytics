{"aid": "40211044", "title": "ClickHouse JOINs 100x Faster", "url": "https://www.tinybird.co/blog-posts/clickhouse-joins-improvements", "domain": "tinybird.co", "votes": 2, "user": "stacyz", "posted_at": "2024-04-30 14:02:08", "comments": 0, "source_title": "ClickHouse JOINs... 100x faster", "source_text": "ClickHouse JOINs... 100x faster\n\n\ud83d\udc25Free Training: Learn to build Real-Time Analytics over KafkaRegister \u2192\n\nProductPricingUse CasesDocsBlog\n\nProductPricingUse CasesDocsBlogStart building\n\nSign InStart building\n\nApr 30, 2024\n\n# ClickHouse JOINs... 100x faster\n\nWe recently introduced two pull requests to ClickHouse that significantly\nimprove JOIN performance in common scenarios.\n\nClickHouseBuilding In Public\n\nMaksim Kita\n\nRecently, we introduced two new pull requests to ClickHouse that will be\navailable with ClickHouse 24.4. These changes improve the performance of JOINs\nacross many production scenarios, in some cases increasing query speed by\nmultiple orders of magnitude.\n\n## PR #1: JOIN predicate pushdown using equivalence classes\n\nPredicate pushdown is a query optimization technique used in database\nmanagement systems to significantly reduce the amount of data a query\nprocesses.\n\nIn ClickHouse, as in most other SQL databases, query execution is divided into\nmultiple stages:\n\n  1. Query parsing.\n  2. Query analysis.\n  3. Build a logical query plan.\n  4. Optimize logical query plan.\n  5. Build a physical query plan.\n  6. Optimize physical query plan.\n  7. Execute physical query plan.\n\nIn most databases, the logical query plan is a tree where each node is a\nrelational algebra operator, and the leaves of the query plan tree are data\nsources, usually table scans.\n\nIt's convenient to represent the steps of a query plan with relational\nalgebra. The relational algebra and its operators are well-studied, and many\nknown optimizations exist.\n\nOne such optimization is predicate pushdown.\n\nPredicate pushdown improves query performance by pushing predicates closer to\noperators that scan data. Early filtering helps subsequent steps of a query\nplan to process much less data, improve index usage, and - in distributed\ndatabases - significantly reduce the amount of data transfer between nodes.\n\nA predicate pushdown optimization can be applied to most relational algebra\noperators, such as projections, aggregations, sorts, and unions. But the most\nimportant optimization is the JOIN step predicate pushdown, simply because\nJOIN operators typically produce huge amounts of data.\n\nIt's important to note that for some operators it is safe to push only part of\nthe predicate. In such a scenario, the predicate needs to be split into parts.\nIn databases, it makes sense to store predicates in conjunctive normal form,\napplying each predicate pushdown optimization separately for each conjunction,\nif necessary.\n\nHere's an example:\n\nLet's look at the ClickHouse logical query plan for this query:\n\nIn this example, the predicate is pushed to the LEFT side of the JOIN. Note\nthat I added SETTINGS optimize_move_to_prewhere = 0, because otherwise that\nFilter step would be converted to PREWHERE for the left table.\n\nBefore ClickHouse 24.4, a simple version of predicate pushdown optimization\nwas used for JOINs. Notably, it did not consider equivalence classes of JOINed\ncolumns (that is, equivalent columns after the JOIN is performed).\n\nIn PR #61216, we introduced a more complex analysis of predicates that uses\nequivalence classes and can transform predicates that are applied to one side\nof JOIN to predicates that can be applied to another side of JOIN. In\naddition, the predicate will be split into different parts and only safe parts\nwill be pushed down, if necessary.\n\nConsider the example:\n\nIn this example, we know that the id column from test_table_1 is equivalent to\nthe id column of test_table_2, and we can transform the test_table_1.id = 5\npredicate to test_table_2.id = 5 and push it to the right table.\n\nFilter pushdown optimization for different JOIN types has different logic:\n\n  1. For INNER JOINs we can push all predicates to both sides of the JOIN. We can also transform predicates that use only equivalent columns from the LEFT side to the RIGHT side and vice versa.\n  2. For LEFT/RIGHT JOINs we can push conditions that use only columns from the LEFT/RIGHT table to the LEFT/RIGHT JOIN side. We can also transform predicates that use only equivalent columns from the LEFT side to the RIGHT side for LEFT JOINs and from the RIGHT side to the LEFT side for RIGHT JOINs.\n\nLet's look at the query plan after this optimization was implemented:\n\nNow, the predicate is pushed to both the LEFT and RIGHT sides of the JOIN. We\nalso see improvements in query performance of INNER, LEFT and RIGHT JOINs in\nabsolute numbers:\n\nHere are the complete results of ClickHouse performance tests, with the\nhighlights shown below.\n\nThese changes improved JOIN speed on INNER and LEFT JOINs by over 180x.\n\nThis optimization additionally resolves several related, preexisting issues in\nClickHouse. Here are some examples:\n\n  1. #10913\n  2. #45242\n  3. #55054\n  4. #55058\n  5. #26268\n\n## PR #2: Automatically converting OUTER to INNER JOIN\n\nWe introduced another change that allows ClickHouse to automatically convert\nan OUTER JOIN to an INNER JOIN if the predicate after JOIN filters all non-\njoined rows with default values.\n\nThis technique allows for additional optimization opportunities because after\nthe JOIN is converted from OUTER to INNER, we can apply predicate pushdown in\nmore scenarios.\n\nUsing the same table setup as the previous optimization...\n\nHere's the ClickHouse logical query plan:\n\nNote\n\nWith actions = 1, we can see more query plan details like JOIN type, concrete\nactions that will be executed, and other details. Note that I just kept the\nkey part of the query plan so we can see that we have LEFT JOIN type.\n\nIn this example, we know the predicate test_table_2.id = 5 will always filter\nnon-joined rows from the LEFT JOIN with default values.\n\nIn #62907, we introduced an analysis that can automatically convert an OUTER\nJOIN to an INNER JOIN. During that analysis, we can understand that the\npredicate after an OUTER JOIN will always filter non-joined rows with default\nvalues. In that case, we can convert an OUTER JOIN to INNER JOIN.\n\nWe do this by trying to perform constant folding of the predicate that is\nexecuted after the OUTER JOIN, where we replace all RIGHT/LEFT side columns\nfor LEFT/RIGHT JOIN with constant default values columns. If the result of\npredicate constant folding is constant False or NULL we can convert the OUTER\nJOIN to an INNER JOIN.\n\nHere's the query plan after this optimization was implemented:\n\nHere, the LEFT JOIN is changed to an INNER JOIN. We can see the Filter step is\npushed down because for an INNER JOIN it is safe to push test_table_2.id = 5\nto both sides of the JOIN.\n\nWe also see improvements in initial query performance after the optimization\nwas applied:\n\nIn the ClickHouse performance test results we see huge improvements for INNER,\nLEFT, and RIGHT JOINs:\n\nThese changes improved ClickHouse JOIN performance significantly, often by\nseveral orders of magnitude.\n\n## Conclusion\n\nIn databases, You can achieve significant performance improvement by using\nhigh-level logical optimizations on top of the query plan. Such optimizations\nwork well together and can be combined to provide even better performance\nimprovements, such as we have shown here.\n\nThese two PRs, which are available in ClickHouse 24.4, have dramatically\nimproved JOIN performance across many production scenarios, and will markedly\nimprove performance for ClickHouse users.\n\nDo you like this post?\n\nTo pick up a draggable item, press the space bar. While dragging, use the\narrow keys to move the item. Press space again to drop the item in its new\nposition, or press escape to cancel.\n\nRelated posts\n\nReal-time Data\n\nReal-time Data Visualization: How to build faster dashboards\n\nCameron Archer\n\nContent Lead\n\nAug 08, 2023\n\nProduct\n\nA new way to create intermediate Data Sources in Tinybird\n\nTinybird\n\nTeam\n\nJun 15, 2023\n\nProduct\n\nExport data from Tinybird to Amazon S3 with the S3 Sink\n\nTinybird\n\nTeam\n\nMar 21, 2024\n\nTech\n\nTinybird: A ksqlDB alternative when stateful stream processing isn't enough\n\nAlasdair Brown\n\nDevRel Lead\n\nJul 27, 2023\n\nProduct\n\nTo the limits of SQL... and beyond\n\nDavid Margulies\n\nSales Engineer\n\nJul 15, 2022\n\nProductOur Beliefs\n\nAutomating data workflows with plaintext files and Git\n\nAlberto Romeu\n\nBackend Developer\n\nOct 23, 2023\n\nDev Q&As\n\nChatting GraphQL with Jamie Barton of Grafbase\n\nTinybird\n\nTeam\n\nApr 24, 2023\n\nReal-time Data\n\nWhat it takes to build a real-time recommendation system\n\nJoe Karlsson\n\nDeveloper Advocate\n\nJul 25, 2023\n\nClickHouse\n\nWe launched an open source ClickHouse Knowledge Base\n\nTinybird\n\nTeam\n\nOct 11, 2022\n\nOur Beliefs\n\nThe definition of real-time data\n\nAlasdair Brown\n\nDevRel Lead\n\nJul 29, 2022\n\n### Build fast data products, faster.\n\nTry Tinybird and bring your data sources together and enable engineers to\nbuild with data in minutes. No credit card required, free to get started.\n\nStart buildingRequest a demo\n\nNeed more? Contact sales for Enterprise support.\n\nSpain Calle del Dr. Fourquet, 27 28012 Madrid\n\nUSA 41 East 11th Street 11th floor New York, NY 10003\n\n#### Company\n\nProductPricingROI CalculatorAbout UsShopCareersRequest a demo\n\n#### Resources\n\nDocsBlogCommunityLive CodingCustomer StoriesTinybird for StartupsRSS Feed\n\n#### Integrations\n\nAmazon S3Kafka Data StreamsGoogle Cloud StorageGoogle\nBigQuerySnowflakeConfluent\n\n#### Use Cases\n\nIn-Product AnalyticsOperational IntelligenceRealtime PersonalizationAnomaly\nDetection & AlertsUsage Based PricingSports Betting/GamingSmart Inventory\nManagementManaged ClickHouse\n\nAll systems operational\n\nCopyright \u00a9 2024 Tinybird. All rights reserved\n\nTerms & conditionsCookiesSecurity\n\nSpain Calle del Dr. Fourquet, 27 28012 Madrid\n\nUSA 41 East 11th Street 11th floor New York, NY 10003\n\nWe use our own cookies on our websites to enhance your experience and analyze\nour traffic. By clicking \u201cAllow all\u201d or turning an option on in Cookie\nPreferences, you agree to this, as outlined in our Cookie Policy\n\n", "frontpage": false}
