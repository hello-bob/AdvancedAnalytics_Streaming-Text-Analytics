{"aid": "40256080", "title": "Bilithification", "url": "https://blog.glyph.im/2023/07/bilithification.html", "domain": "glyph.im", "votes": 1, "user": "genericlemon24", "posted_at": "2024-05-04 09:07:52", "comments": 0, "source_title": "Deciphering Glyph :: Bilithification", "source_text": "Deciphering Glyph :: Bilithification\n\nDeciphering\n\nGlyph\n\n  * About\n  * Archives\n  * Mastodon\n  * GitHub\n  * Patrons\n\n# Bilithification\n\nNot sure how to do microservices? Split your monolith in half.\n\nprogrammingarchitecturemicroservicesmanagementsupported Thursday July 20, 2023\n\nSeveral years ago at O\u2019Reilly\u2019s Software Architecture conference, within a\ncomprehensive talk on refactoring \u201cTechnical Debt: A Masterclass\u201d, r0ml^1\npresented a concept that I think should be highlighted.\n\nIf you have access to O\u2019Reilly Safari, I think the video is available there,\nor you can get the slides here. It\u2019s well worth watching in its own right. The\ntalk contains a lot of hard-won wisdom from a decades-long career, but in\nslides 75-87, he articulates a concept that I believe resolves the perennial\npendulum-swing between microservices and monoliths that we see in the Software\nas a Service world.\n\nI will refer to this concept as \u201cthe bilithification strategy\u201d.\n\n## Background\n\nPersonally, I have long been a microservice skeptic. I would generally\narticulate this skepticism in terms of \u201cYAGNI\u201d.\n\nHere\u2019s the way I would advise people asking about microservices before\nencountering this concept:\n\n> Microservices are often adopted by small teams due to their advertised\n> benefits. Advocates from very large organizations\u2014ones that have been very\n> successful with microservices\u2014frequently give talks claiming that\n> microservices are more modular, more scalable, and more fault-tolerant than\n> their monolithic progenitors. But these teams rarely appreciate the costs,\n> particularly the costs for smaller orgs. Specifically, there is a fixed\n> operational marginal cost to each new service, and a fairly large fixed\n> operational overhead to the infrastructure for an organization deploying\n> microservices in at all.\n>\n> With a large enough team, the operational cost is easy to absorb. As the\n> overhead is fixed, it trends towards zero as your total team size and system\n> complexity trend towards infinity. Also, in very large teams, the enforced\n> isolation of components in separate services reduces complexity. It does so\n> specifically intentionally causing the software architecture to mirror the\n> organizational structure of the team that deploys it. This \u2014 at the cost of\n> increased operational overhead and decreased efficiency \u2014 allows independent\n> parts of the organization to make progress independently, without blocking\n> on each other. Therefore, in smaller teams, as you\u2019re building, you should\n> bias towards building a monolith until the complexity costs of the monolith\n> become apparent. Then you should build the infrastructure to switch to\n> microservices.\n\nI still stand by all of this. However, it\u2019s incomplete.\n\nWhat does it mean to \u201cswitch to microservices\u201d?\n\nThe biggest thing that this advice leaves out is a clear understanding of the\n\u201cmicro\u201d in \u201cmicroservice\u201d. In this framing, I\u2019m implicitly understanding\n\u201cmicro\u201d services to be services that are too small \u2014 or at least, too small\nfor your team. But if they do work for large organizations, then at some\npoint, you need to have them. This leaves open several questions:\n\n  * What size is the right size for a service?\n  * When should you split your monolith up into smaller services?\n  * Wait, how do you even measure \u201csize\u201d of a service? Lines of code? Gigabytes of memory? Number of team members?\n\nIn a specific situation I could probably look at these questions for that\nsituation, and make suggestions as to the appropriate course of action, but\nthat\u2019s based largely on vibes. There\u2019s just a lot of drawing on complex\nexperiences, not a repeatable pattern that a team could apply on their own.\n\nWe can be clear that you should always start with a monolith. But what should\nyou do when that\u2019s no longer working? How do you even tell when it\u2019s no longer\nworking?\n\n## Bilithification\n\nEvery codebase begins as a monolith. That is a single (mono) rock (lith).\nHere\u2019s what it looks like.\n\nLet\u2019s say that the monolith, and the attendant team, is getting big enough\nthat we\u2019re beginning to consider microservices. We might now ask, \u201cwhat is the\nappropriate number of services to split the monolith into?\u201d and that could\nprovoke endless debate even among a team with total consensus that it might\nneed to be split into some number of services.\n\nRather than beginning with the premise that there is a correct number, we may\nobserve instead that splitting the service into N services where N is more\nthan one may be accomplished splitting the service in half N-1 times.\n\nSo let\u2019s bi (two) lithify (rock) this monolith, and take it from 1 to 2 rocks.\n\nThe task of splitting the service into two parts ought to be a manageable\namount of work \u2014 two is a definitively finite number, as composed to the\ninfinite point-cloud of \u201cmicroservices\u201d. Thus, we should search, first, for a\nsingle logical seam along which we might cleave the monolith.\n\nIn many cases\u2014as in the specific case that r0ml gave\u2014the easiest way to\narticulate a boundary between two parts of a piece of software is to\nconceptualize a \u201cfrontend\u201d and a \u201cbackend\u201d. In the absence of any other clear\nboundary, the question \u201cdoes this functionality belong in the front end or the\nback end\u201d can serve as a simple razor for separating the service.\n\nRemember: the reason we\u2019re splitting this software up is because we are also\nsplitting the team up. You need to think about this in terms of people as well\nas in terms of functionality. What division between halves would most reduce\nthe number of lines of communication, to reduce the quadratic increase in\nrequired communication relationships that comes along with the linear increase\nin team size? Can you identify two groups who need to talk amongst themselves,\nbut do not need to talk with all of each other?^2\n\nOnce you\u2019ve achieved this separation, we no longer have a single rock, we have\ntwo half-rocks: hemiliths to borrow from the same Greek root that gave us\n\u201cmonolith\u201d.\n\nBut we are not finished, of course. Two may not be the correct number of\nservices to end up with. Now, we ask: can we split the frontend into a\nfrontend and backend? Can we split the backend? If so, then we now have four\nrocks in place of our original one:\n\nYou might think that this would be a \u201ctetralith\u201d for \u201cfour\u201d, but as they are\nof a set, they are more properly a tetartolith.\n\n## Repeat As Necessary\n\nAt some point, you\u2019ll hit a point where you\u2019re looking at a service and asking\n\u201cwhat are the two pieces I could split this service into?\u201d, and the answer\nwill be \u201cnone, it makes sense as a single piece\u201d. At that point, you will know\nthat you\u2019ve achieved services of the correct size.\n\nOne thing about this insight that may disappoint some engineers is the\nrealization that service-oriented architecture is much more an engineering\nmanagement tool than it is an engineering tool. It\u2019s fun to think that\n\u201cmicroservices\u201d will let you play around with weird technologies and niche\nprogramming languages consequence-free at your day job because those can all\nbe \u201cseparate services\u201d, but that was always a fantasy. Integrating multiple\ntechnologies is expensive, and introducing more moving parts always introduces\nmore failure points.\n\n## Advanced Techniques: A Multi-Stack Microservice Environment\n\nYou\u2019ll note that splitting a service heavily implies that the resulting\nservices will still all be in the same programming language and the same tech\nstack as before. If you\u2019re interested in deploying multiple stacks (languages,\nframeworks, libraries), you can proceed to that outcome via bilithification,\nbut it is a multi-step process.\n\nFirst, you have to complete the strategy that I\u2019ve already outlined above. You\nneed to get to a service that is sufficiently granular that it is atomic; you\ndon\u2019t want to split it up any further.\n\nLet\u2019s call that service \u201cX\u201d.\n\nSecond, you identify the additional complexity that would be introduced by\nusing a different tech stack. It\u2019s important to be realistic here! New\ntechnology always seems fun, and if you\u2019re investigating this, you\u2019re probably\npredisposed to think it would be an improvement. So identify your costs first\nand make sure you have them enumerated before you move on to the benefits.\n\nThird, identify the concrete benefits to X\u2019s problem domain that the new tech\nstack would provide.\n\nFinally, do a cost-benefit analysis where you make sure that the costs from\nstep 2 are clearly exceeded by the benefits from step three. If you can\u2019t\nreadily identify that in advance \u2013 sometimes experimentation is required \u2014\nthen you need to treat this as an experiment, rather than as a strategic\ndirection, until you\u2019ve had a chance to answer whatever questions you have\nabout the new technology\u2019s benefits benefits.\n\nNote, also, that this cost-benefit analysis requires not only doing the\ntechnical analysis but getting buy-in from the entire team tasked with\nmaintaining that component.\n\n## Conclusion\n\nTo summarize:\n\n  1. Always start with a monolith.\n  2. When the monolith is too big, both in terms of team and of codebase, split the monolith in half until it doesn\u2019t make sense to split it in half any more.\n  3. (Optional) Carefully evaluate services that want to adopt new technologies, and keep the costs of doing that in mind.\n\nThere is, of course, a world of complexity beyond this associated with\nmanaging the cost of a service-oriented architecture and solving specific\ntechnical problems that arise from that architecture.\n\nIf you remember the tetartolith, though, you should at least be able to get to\nthe right number and size of services for your system.\n\nThank you to my patrons who are supporting my writing on this blog. If you\nlike what you\u2019ve read here and you\u2019d like to read more of it, or you\u2019d like to\nsupport my various open-source endeavors, you can support my work as a\nsponsor! I am also available for consulting work if you think your\norganization could benefit from more specificity on the sort of insight you've\nseen here.\n\n  1. AKA \u201cmy father\u201d \u21a9\n\n  2. Denouncing \u201csilos\u201d within organizations is so common that it\u2019s a tired trope at this point. There is no shortage of vaguely inspirational articles across the business trade-rag web and on LinkedIn exhorting us to \u201cbreak down silos\u201d, but silos are the point of having an organization. If everybody needs to talk to everybody else in your entire organization, if no silos exist to prevent the necessity of that communication, then you are definitionally operating that organization at minimal efficiency. What people actually want when they talk about \u201cbreaking down silos\u201d is a re-org into a functional hierarchy rather than a role-oriented hierarchy (i.e., \u201cthis is the team that makes and markets the Foo product, this is the team that makes and markets the Bar product\u201d as opposed to \u201cthis is the sales team\u201d, \u201cthis is the engineering team\u201d). But that\u2019s a separate post, probably. \u21a9\n\n\u00a9 Glyph 2024; All Rights Reserved Excepting Those Which Are Not. See my\ndisclosure statements for information on my interests, financial and\notherwise.\n\nMastodon\n\n", "frontpage": false}
