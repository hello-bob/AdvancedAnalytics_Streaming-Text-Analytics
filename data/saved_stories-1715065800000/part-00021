{"aid": "40279129", "title": "Lila: A Lil Interpreter in Posix Awk", "url": "https://beyondloom.com/blog/lila.html", "domain": "beyondloom.com", "votes": 2, "user": "RodgerTheGreat", "posted_at": "2024-05-06 20:29:09", "comments": 0, "source_title": null, "source_text": "# Lila: a Lil Interpreter in POSIX AWK\n\nAWK is among the most ubiquitous programming languages in the world. Much like\ned, the standard text editor, awk is a mandatory component of any POSIX\noperating system. On a fresh-out-of-the-box Mac, tunneling into the embedded\nLinux environment on your router, or scrabbling away at GitBash on a Windows\nmachine, you may not have access to Python, Perl, or even Tcl, but you can\nrest assured that some flavor of awk is already installed. This is a powerful\nproposition.\n\nIn our modern age, AWK is frequently regarded as a domain-specific language\nakin to sed, constrained in its usefulness to batch processing of semi-\nstructured text files and streams. While many features of the language are\nindeed tailored to this ecological niche, AWK is a fully general-purpose\nlanguage; AWK provides concise and familiar control structures, floating-point\narithmetic, a small but flexible toolkit of string manipulation operations,\nand powerful associative arrays. I could simply tell you that AWK can do\nnearly anything, but perhaps it would be more persuasive to show you?\n\n## The Name\u2019s Lila\n\nLila is an implementation of Lil in AWK. Lil is a multi-paradigm language with\na rich set of primitive operators and a \u201cbatteries-included\u201d standard library\nfeaturing such goodies as JSON, XML, CSV and structured binary parsing, first-\nclass database-style tables with a SQL-like query syntax, and functional\nniceties like a REPL and tail-call elimination.\n\n    \n    \n    % ./lila.awk select k:first value v:count value by value from \"AABABBBBBBABACBA\" +-----+---+ | k | v | +-----+---+ | \"A\" | 6 | | \"B\" | 9 | | \"C\" | 1 | +-----+---+\n\nA complete Lil system demonstrates by construction solutions to a broad range\nof interesting and practical programming tasks. It also provides some\nintriguing possibilities for making the Lil ecosystem more self-hosting and\nportable: Lila can subsist anywhere there\u2019s an AWK, even places C compilers\nand JavaScript interpreters dare not venture!\n\nIn broad strokes, Lila\u2019s interpreter closely follows the structure of the\nC-based Lil interpreter: It tokenizes and parses source code strings,\nassembling them in a single pass into a stream of bytecode instructions which\nare executed by a stack-based virtual machine. Primitive operators and the\nguts of Lil\u2019s \u201cInterface\u201d values are AWK functions written in terms of boxed\n\u201cLil-values\u201d which represent Lil\u2019s core data structures: numbers, strings,\nlists, dictionaries, tables, and functions.\n\nSince AWK associative arrays cannot be recursively nested, an AWK associative\narray cannot directly represent, say, a Lil dictionary. Instead, Lila uses a\ncollection of global associative arrays to represent a heap of Lil-value\n\u201cstructs\u201d keyed by numeric indices. From the perspective of most of the AWK\ncode that uses Lil-values, these indices are simply pointers! All the members\nof Lil-values are represented as AWK numbers or strings.\n\n## Performance Anxiety\n\nComputers, one often hears, are pretty fast. Lila\u2019s interpreter, however, is\ndoing quite a bit of indirection and string acrobatics with each expression.\nIs it still usably performant, or are we looking at speeds rivaled by dead\nsnails in molasses?\n\nAn experiment was performed on my 2020 M1 Macbook Air comparing the C and JS-\nbased reference implementations of Lilt with Lila running under a variety of\nAWK implementations: mawk, gawk, goawk, and the BSD awk which ships with MacOS\n(v20200816 in this case). As my benchmarks, I used Mandel.lil, a naive\nMandelbrot set renderer designed to hammer the Lil interpreter and garbage\ncollector, and the Lil integration test suite:\n\nInterpreter| Mandel| Tests  \n---|---|---  \nc-lilt (release)| 0.08s| 0.27s  \nc-lilt (debug)| 0.36s| 0.79s  \njs-lilt| 0.42s| 1.58s  \nmawk| 3.61s| 0.95s  \ngawk| 6.58s| 2.47s  \ngoawk| 10.66s| 4.32s  \nawk| 15.09s| 162.97s  \n  \nOf the AWKs tested, mawk makes a truly impressive showing. The \u201cone-true\u201d AWK\nfares much poorer, particularly with the integration suite. I ran a similar\nexperiment on my 9-year old intel-based Macbook Air which provides awk version\n20070501, and- curiously- even on that far humbler machine I was able to\ndrastically outstrip the M1 with a more \u201cmodern\u201d AWK release, completing the\nintegration suite successfully in about 16 seconds.\n\nYour mileage may vary, but overall I found that even on my slowest computers\nand their most ancient AWKs Lila offers a viably interactive REPL experience.\n\nThere aren\u2019t many monolithic AWK scripts on the internet of a similar scale\nand complexity to lila.awk. If you\u2019re the maintainer of an AWK- or you\u2019re\nthinking of becoming one- Lila might be a useful tool for investigating\nperformance and correctness.\n\n## Conclusion\n\nHopefully this article has mildly piqued your interest in AWK, Lil, or their\ncombination. The next time you find yourself drawing in a Python dependency\nfor simple command-line automation or struggling to express complex logic in a\nshell script, consider reaching for AWK.\n\nSometimes the best tool is the tool you already have.\n\nback\n\n", "frontpage": false}
