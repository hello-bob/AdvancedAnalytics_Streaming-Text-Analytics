{"aid": "40221828", "title": "File Modes in C++20", "url": "https://euroquis.nl//blabla/2024/04/30/chmod.html", "domain": "euroquis.nl", "votes": 2, "user": "LorenDB", "posted_at": "2024-05-01 11:24:11", "comments": 0, "source_title": "File modes in C++20", "source_text": "File modes in C++20 | [bobulate]\n\n[bobulate]\n\n# File modes in C++20\n\nApr 30, 2024 \u2022 adridg\n\nI was looking at some code that sets file permissions \u2013 file modes \u2013 by\ncalling chmod(2). The command-line chmod(1) has a bunch of possibilities for\nsetting permissions, but the underlying system-call needs an int, and the C\nheaders for it are annoying to use. So I fired up some C++ machinery to \u201cmake\nit nicer to use\u201d.\n\n> tl;dr: scroll to the bottom for a compile-time, compact way of writing file\n> permissions so that chmod(filename, \"rwx--x--x\"_mode) does something\n> plausible, with good error messages in case of typo\u2019s.\n\nThe manpage for chmod(1) is fairly extensive. There are two ways to specify a\nfile mode, either in octal or symbolically. Octal is just a number,\nsymbolically is much more complicated.\n\nOn the C API side, the manpage for chmod(2) shows you need a pathname and a\nmode, and there are a whole bunch of symbolic constants to use, like S_IRUSR.\n\n### How I think about file modes\n\nIt turns out I nearly always think about file modes in octal. I have somehow\ninternalized things like \u201c755 for executables\u201d and \u201c666 for crap\u201d and \u201c600 for\nfiles in ~/.ssh\u201d but I don\u2019t really have names for these things. If I think\nabout it, I can use the symbolic manipulations like ugo+rw for crap. But I\ndon\u2019t see permissions in this symbolic form, and the octal form is persnickety\nin C source, probably because I don\u2019t expect everyone to know \u201cleading 0 means\noctal\u201d.\n\nBut there is a form in which I see file modes every day: the output from ls\n-l, where permissions are shown with 10 characters, the first 10 on this line:\n\n    \n    \n    -rw-r--r-- 1 adridg users 0 Apr 30 11:46 example.txt\n\nThe first - says something about the type of file and is - for regular files,\nd for directories, l for symbolic links, and there are others, too. That\u2019s not\nreally the mode, though, while the next 9 characters are: each group of three\nshows r, w, and x in that order, or a - in each position, indicating the read,\nwrite, or execute bit for the corresponding class of logins. The first three\nare the current user, next three are group, the last three for others.\n\nThe C code to call chmod with this mode looks like\n\n    \n    \n    chmod(\"example.txt\", 0644); chmod(\"example.txt\", S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);\n\nOne is octal-arcane and the other is just arcane and hard-to-read.\n\n### Turning readable modes into numbers\n\nSo I thought to myself: I can write a C++ function that turns the 9-characters\nof the mode in text form, into an actual mode_t value (that\u2019s an integer).\n\nThat\u2019s a trivial exercise, really, although it gets a bit persnickety in error\nhandling. I would just throw on an incorrect length, or any incorrect\ncharacter, and leave it at that.\n\nFrom there, though, I went on to: I can write a consteval C++ function that\ndoes the computation at compile-time (guaranteed to be only at compile-time,\nbecause consteval). This is a function that can only be called with a compile-\ntime string literal, so the function signature is potentially:\n\n    \n    \n    consteval mode_t from_readable_mode(const char (&permission_string)[10])\n\nThe array-reference is to 10 characters because there are 9 mode characters,\nand then a trailing NUL byte (zero) in a string literal. This function can be\ncalled (in the context, sill, of chmod()) like so:\n\n    \n    \n    chmod(\"example.txt\", from_readable_mode(\"rw-r--r--\"));\n\nand at compile-time that is already computed to be 420 (that\u2019s 0644 octal).\n\nThe last step of make-it-cool (for an appropriate value of \u201ccool\u201d) is to turn\nthe whole thing into a user-defined literal. In my source code I can now write\n\n    \n    \n    chmod(\"example.txt\", \"rw-r--r--\"_mode);\n\nWhich really satisfies my own desire for \u201creadable, compact, compile-time\u201d.\n\n### Don\u2019t get me started on Qt\n\nFor some reason, the values of QFileDevice::Permission are in hexadecimal, but\nwritten as hex, look like the corresponding octal values. So in Qt code if you\ndon\u2019t use the symbolic representation of the flags, and just go ram an integer\ninto there, you get 0x644 meaning the same as 0660 in the call to chmod() and\neverything becomes just that much more confusing and fraught.\n\n### Meaningful error messages\n\nC++ and \u201chelpful, friendly, easy-to-read error messages\u201d go together like\npeaches and .. battery acid? Like things that don\u2019t go well together at all.\nIn recent GCC versions there has been a marked improvement in the look of\nerror messages.\n\nWith some judicious use of templates and naming of types, existing error\nmessages can be improved. You still get a veritable torrent of messages, but\nif, somewhere in the middle, the error message (here, from Clang 17) says:\n\n    \n    \n    mode.h:26:9: note: subexpression not valid in a constant expression 26 | throw invalid_permission_character{}; mode.h:41:9: note: in call to 'expected_character_at_position(&\"rwxbadbug\"[0])' 41 | detail::expected_character_at_position<3, 'r'>(s) |\n\nThen it\u2019s a lot easier to decide that the character at position 3 \u2013 the letter\nb \u2013 is not expected, and maybe an r was expected there instead.\n\n### User-defined file mode literals\n\nHere is the definition of my _mode literal. String-based literals get a\npointer and a size, which is inconvenient because they don\u2019t turn back into\nfixed-size arrays.\n\n    \n    \n    consteval mode_t operator\"\"_mode(const char *s, size_t len) { if (len != 9) { throw detail::invalid_permission_string_length{}; } return detail::from_readable_mode_string(s); }\n\nAnyway, if the string is the wrong size then a meaningful exception is thrown,\nwhich isn\u2019t constexpr, so you get a meaningful error message:\n\n    \n    \n    mode.h:65:9: note: subexpression not valid in a constant expression 65 | throw detail::invalid_permission_string_length{}; main.cc:44:24: note: in call to 'operator\"\"_mode(&\"birb\"[0], 4)' 44 | std::cout << \"birb\"_mode;\n\nHere us the implementation of the function that does the actual work, turning\nthe string into a mode_t:\n\n    \n    \n    consteval mode_t from_readable_mode_string(const char * const s) { return detail::expected_character_at_position<0, 'r'>(s) | detail::expected_character_at_position<1, 'w'>(s) | detail::expected_character_at_position<2, 'x'>(s) | detail::expected_character_at_position<3, 'r'>(s) | detail::expected_character_at_position<4, 'w'>(s) | detail::expected_character_at_position<5, 'x'>(s) | detail::expected_character_at_position<6, 'r'>(s) | detail::expected_character_at_position<7, 'w'>(s) | detail::expected_character_at_position<8, 'x'>(s); }\n\nIt\u2019s really wordy, which is unfortunate, but by writing it like this, the\nerror message \u2013 at least with Clang 17 \u2013 repeats the template parameters and\nmentions the specific subexpression that is problematic.\n\nHere is a Clang 17 error message when using an inappropriate permission\ncharacter:\n\n    \n    \n    mode.h:26:9: note: subexpression not valid in a constant expression 26 | throw invalid_permission_character{}; mode.h:44:9: note: in call to 'expected_character_at_position(&\"------uwu\"[0])' 44 | detail::expected_character_at_position<6, 'r'>(s) | mode.h:67:12: note: in call to 'from_readable_mode_string(&\"------uwu\"[0])' 67 | return detail::from_readable_mode_string(s);\n\nHuh, I guess you can\u2019t give uWu permission to others. The same error message\nfrom GCC 13 looks similar:\n\n    \n    \n    main.cc:44:18: in 'constexpr' expansion of 'operator\"\"_mode(((const char*)\"------uwu\"), 9)' mode.h:67:45: in 'constexpr' expansion of 'detail::from_readable_mode_string(s)' mode.h:44:55: in 'constexpr' expansion of 'detail::expected_character_at_position<6, 'r'>(((const char*)s))' mode.h:26:9: error: expression '<throw-expression>' is not a constant expression 26 | throw invalid_permission_character{};\n\nAnd here\u2019s the implementation that turns a single character into a bit in a\nfile mode value:\n\n    \n    \n    template<int position, char accept> consteval mode_t expected_character_at_position(const char * const permission_string) { const char c = permission_string[position]; if(c == accept) { return 1 << (8-position); } if(c == '-') { return 0; } throw invalid_permission_character{}; }\n\nThis is a bit wordy, but it ensures that position and the acceptable\n(expected) char are front-and-center in error messages, and that the expected\ncharacter and - are the only characters for which this is a constant\nexpression \u2013 everything else will fail because exceptions aren\u2019t constexpr.\n\nSo there you have it, a compact constexpr representation of file modes with\nmeaningful error messages. You can find the code in my personal GitHub\nrepository playground, in the subdirectory mode/ . I won\u2019t link it here\nbecause, frankly, it is time I get my ass in gear and migrate to some other\nforge.\n\n## [bobulate]\n\n  * [bobulate]\n  * adriaan@euroquis.nl\n\n  * adriaandegroot\n  * adriaandegroot\n  * kdedude\n\nMy personal site of programming, C++, baking, KDE and FreeBSD things.\n\n", "frontpage": false}
