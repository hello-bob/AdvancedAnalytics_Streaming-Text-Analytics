{"aid": "40163777", "title": "TypeScript 5.5 Beta", "url": "https://devblogs.microsoft.com/typescript/announcing-typescript-5-5-beta/", "domain": "microsoft.com", "votes": 4, "user": "bpierre", "posted_at": "2024-04-25 22:19:22", "comments": 0, "source_title": "Announcing TypeScript 5.5 Beta", "source_text": "Announcing TypeScript 5.5 Beta - TypeScript\n\nSkip to main content\n\nMicrosoft\n\nTypeScript\n\nTypeScript\n\n  * Light\n  * Dark\n\nLogin\n\n# Announcing TypeScript 5.5 Beta\n\nDaniel Rosenwasser\n\nApril 25th, 20240 0\n\nToday we are excited to announce the availability of TypeScript 5.5 Beta.\n\nTo get started using the beta, you can get it through NuGet, or through npm\nwith the following command:\n\n    \n    \n    npm install -D typescript@beta\n\nHere\u2019s a quick list of what\u2019s new in TypeScript 5.5!\n\n  * Inferred Type Predicates\n  * Control Flow Narrowing for Constant Indexed Accesses\n  * Type Imports in JSDoc\n  * Regular Expression Syntax Checking\n  * Isolated Declarations\n  * The ${configDir} Template Variable for Configuration Files\n  * Consulting package.json Dependencies for Declaration File Generation\n  * Editor and Watch-Mode Reliability Improvements\n  * Performance and Size Optimizations\n  * Easier API Consumption ECMAScript Modules\n  * The transpileDeclaration API\n  * Notable Behavioral Changes\n\n    * Disabling Features Deprecated in TypeScript 5.0\n\n## Inferred Type Predicates\n\nThis section was written by Dan Vanderkam, who implemented this feature in\nTypeScript 5.5. Thanks Dan!\n\nTypeScript\u2019s control flow analysis does a great job of tracking how the type\nof a variable changes as it moves through your code:\n\n    \n    \n    interface Bird { commonName: string; scientificName: string; sing(): void; } // Maps country names -> national bird. // Not all nations have official birds (looking at you, Canada!) declare const nationalBirds: Map<string, Bird>; function makeNationalBirdCall(country: string) { const bird = nationalBirds.get(country); // bird has a declared type of Bird | undefined if (bird) { bird.sing(); // bird has type Bird inside the if statement } else { // bird has type undefined here. } }\n\nBy making you handle the undefined case, TypeScript pushes you to write more\nrobust code.\n\nIn the past, this sort of type refinement was more difficult to apply to\narrays. This would have been an error in all previous versions of TypeScript:\n\n    \n    \n    function makeBirdCalls(countries: string[]) { // birds: (Bird | undefined)[] const birds = countries .map(country => nationalBirds.get(country)) .filter(bird => bird !== undefined); for (const bird of birds) { bird.sing(); // error: 'bird' is possibly 'undefined'. } }\n\nThis code is perfectly fine: we\u2019ve filtered all the undefined values out of\nthe list. But TypeScript hasn\u2019t been able to follow along.\n\nWith TypeScript 5.5, the type checker is fine with this code:\n\n    \n    \n    function makeBirdCalls(countries: string[]) { // birds: Bird[] const birds = countries .map(country => nationalBirds.get(country)) .filter(bird => bird !== undefined); for (const bird of birds) { bird.sing(); // ok! } }\n\nNote the more precise type for birds.\n\nThis works because TypeScript now infers a type predicate for the filter\nfunction. You can see what\u2019s going on more clearly by pulling it out into a\nstandalone function:\n\n    \n    \n    // function isBirdReal(bird: Bird | undefined): bird is Bird function isBirdReal(bird: Bird | undefined) { return bird !== undefined; }\n\nbird is Bird is the type predicate. It means that, if the function returns\ntrue, then it\u2019s a Bird (if the function returns false then it\u2019s undefined).\nThe type declarations for Array.prototype.filter know about type predicates,\nso the net result is that you get a more precise type and the code passes the\ntype checker.\n\nTypeScript will infer that a function returns a type predicate if these\nconditions hold:\n\n  1. The function does not have an explicit return type or type predicate annotation.\n  2. The function has a single return statement and no implicit returns.\n  3. The function does not mutate its parameter.\n  4. The function returns a boolean expression that\u2019s tied to a refinement on the parameter.\n\nGenerally this works how you\u2019d expect. Here\u2019s a few more examples of inferred\ntype predicates:\n\n    \n    \n    // const isNumber: (x: unknown) => x is number const isNumber = (x: unknown) => typeof x === 'number'; // const isNonNullish: <T>(x: T) => x is NonNullable<T> const isNonNullish = <T,>(x: T) => x != null;\n\nPreviously, TypeScript would have just inferred that these functions return\nboolean. It now infers signatures with type predicates like x is number or x\nis NonNullable<T>.\n\nType predicates have \"if and only if\" semantics. If a function returns x is T,\nthen it means that:\n\n  1. If the function returns true then x is has type T.\n  2. If the function returns false then x does not have type T.\n\nIf you\u2019re expecting a type predicate to be inferred but it\u2019s not, then you may\nbe running afoul of the second rule. This often comes up with \"truthiness\"\nchecks:\n\n    \n    \n    function getClassroomAverage(students: string[], allScores: Map<string, number>) { const studentScores = students .map(student => allScores.get(student)) .filter(score => !!score); return studentScores.reduce((a, b) => a + b) / studentScores.length; // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ // error: Object is possibly 'undefined'. }\n\nTypeScript did not infer a type predicate for score => !!score, and rightly\nso: if this returns true then score is a number. But if it returns false, then\nscore could be either undefined or a number (specifically, 0). This is a real\nbug: if any student got a zero on the test, then filtering out their score\nwill skew the average upwards. Fewer will be above average and more will be\nsad!\n\nAs with the first example, it\u2019s better to explicitly filter out undefined\nvalues:\n\n    \n    \n    function getClassroomAverage(students: string[], allScores: Map<string, number>) { const studentScores = students .map(student => allScores.get(student)) .filter(score => score !== undefined); return studentScores.reduce((a, b) => a + b) / studentScores.length; // ok! }\n\nA truthiness check will infer a type predicate for object types, where there\u2019s\nno ambiguity. Remember that functions must return a boolean to be a candidate\nfor an inferred type predicate: x => !!x might infer a type predicate, but x\n=> x definitely won\u2019t.\n\nExplicit type predicates continue to work exactly as before. TypeScript will\nnot check whether it would infer the same type predicate. Explicit type\npredicates (\"is\") are no safer than a type assertion (\"as\").\n\nIt\u2019s possible that this feature will break existing code if TypeScript now\ninfers a more precise type than you want. For example:\n\n    \n    \n    // Previously, nums: (number | null)[] // Now, nums: number[] const nums = [1, 2, 3, null, 5].filter(x => x !== null); nums.push(null); // ok in TS 5.4, error in TS 5.5\n\nThe fix is to tell TypeScript the type that you want using an explicit type\nannotation:\n\n    \n    \n    const nums: (number | null)[] = [1, 2, 3, null, 5].filter(x => x !== null); nums.push(null); // ok in all versions\n\nFor more information, check out the implementing pull request and Dan\u2019s blog\npost about implementing this feature.\n\n## Control Flow Narrowing for Constant Indexed Accesses\n\nTypeScript is now able to narrow expressions of the form obj[key] when both\nobj and key are effectively constant.\n\n    \n    \n    function f1(obj: Record<string, unknown>, key: string) { if (typeof obj[key] === \"string\") { // Now okay, previously was error obj[key].toUpperCase(); } }\n\nIn the above, neither obj nor key are ever mutated, so TypeScript can narrow\nthe type of obj[key] to string after the typeof check. For more information,\nsee the implementing pull request here.\n\n## Type Imports in JSDoc\n\nToday, if you want to import something only for type-checking in a JavaScript\nfile, it is cumbersome. JavaScript developers can\u2019t simply import a type named\nSomeType if it\u2019s not there at runtime.\n\n    \n    \n    // ./some-module.d.ts export interface SomeType { // ... } // ./index.js import { SomeType } from \"./some-module\"; // runtime error! /** * @param {SomeType} myValue */ function doSomething(myValue) { // ... }\n\nSomeType won\u2019t exist at runtime, so the import will fail. Developers can\ninstead use a namespace import instead.\n\n    \n    \n    import * as someModule from \"./some-module\"; /** * @param {someModule.SomeType} myValue */ function doSomething(myValue) { // ... }\n\nBut ./some-module is still imported at runtime \u2013 which might also not be\ndesirable.\n\nTo avoid this, developers typically had to use import(...) types in JSDoc\ncomments.\n\n    \n    \n    /** * @param {import(\"./some-module\").SomeType} myValue */ function doSomething(myValue) { // ... }\n\nIf you wanted to reuse the same type in multiple places, you could use a\ntypedef to avoid repeating the import.\n\n    \n    \n    /** * @typedef {import(\"./some-module\").SomeType} SomeType */ /** * @param {SomeType} myValue */ function doSomething(myValue) { // ... }\n\nThis helps with local uses of SomeType, but it gets repetitive for many\nimports and can be a bit verbose.\n\nThat\u2019s why TypeScript now supports a new @import comment tag that has the same\nsyntax as ECMAScript imports.\n\n    \n    \n    /** @import { SomeType } from \"some-module\" */ /** * @param {SomeType} myValue */ function doSomething(myValue) { // ... }\n\nHere, we used named imports. We could also have written our import as a\nnamespace import.\n\n    \n    \n    /** @import * as someModule from \"some-module\" */ /** * @param {someModule.SomeType} myValue */ function doSomething(myValue) { // ... }\n\nBecause these are just JSDoc comments, they don\u2019t affect runtime behavior at\nall.\n\nWe would like to extend a big thanks to Oleksandr Tarasiuk who contributed\nthis change!\n\n## Regular Expression Syntax Checking\n\nUntil now, TypeScript has typically skipped over most regular expressions in\ncode. This is because regular expressions technically have an extensible\ngrammar and TypeScript never made any effort to compile regular expressions to\nearlier versions of JavaScript. Still, this meant that lots of common problems\nwould go undiscovered in regular expressions, and they would either turn into\nerrors at runtime, or silently fail.\n\nBut TypeScript now does basic syntax checking on regular expressions!\n\n    \n    \n    let myRegex = /@robot(\\s+(please|immediately)))? do some task/; // ~ // error! // Unexpected ')'. Did you mean to escape it with backslash?\n\nThis is a simple example, but this checking can catch a lot of common\nmistakes. In fact, TypeScript\u2019s checking goes slightly beyond syntactic\nchecks. For instance, TypeScript can now catch issues around backreferences\nthat don\u2019t exist.\n\n    \n    \n    let myRegex = /@typedef \\{import\\((.+)\\)\\.([a-zA-Z_]+)\\} \\3/u; // ~ // error! // This backreference refers to a group that does not exist. // There are only 2 capturing groups in this regular expression.\n\nThe same applies to named capturing groups.\n\n    \n    \n    let myRegex = /@typedef \\{import\\((?<importPath>.+)\\)\\.(?<importedEntity>[a-zA-Z_]+)\\} \\k<namedImport>/; // ~~~~~~~~~~~ // error! // There is no capturing group named 'namedImport' in this regular expression.\n\nTypeScript\u2019s checking is now also aware of when certain RegExp features are\nused when newer than your target version of ECMAScript. For example, if we use\nnamed capturing groups like the above in an ES5 target, we\u2019ll get an error.\n\n    \n    \n    let myRegex = /@typedef \\{import\\((?<importPath>.+)\\)\\.(?<importedEntity>[a-zA-Z_]+)\\} \\k<importedEntity>/; // ~~~~~~~~~~~~ ~~~~~~~~~~~~~~~~ // error! // Named capturing groups are only available when targeting 'ES2018' or later.\n\nThe same is true for certain regular expression flags as well.\n\nNote that TypeScript\u2019s regular expression support is limited to regular\nexpression literals. If you try calling new RegExp with a string literal,\nTypeScript will not check the provided string.\n\nWe would like to thank GitHub user graphemecluster who iterated a ton with us\nto get this feature into TypeScript.\n\n## Isolated Declarations\n\nThis section was co-authored by Rob Palmer who supported the design of\nisolated declarations.\n\nDeclaration files (a.k.a. .d.ts files) describe the shape of existing\nlibraries and modules to TypeScript. This lightweight description includes the\nlibrary\u2019s type signatures and excludes implementation details such as the\nfunction bodies. They are published so that TypeScript can efficiently check\nyour usage of a library without needing to analyse the library itself. Whilst\nit is possible to handwrite declaration files, if you are authoring typed\ncode, it\u2019s much safer and simpler to let TypeScript generate them\nautomatically from source files using --declaration.\n\nThe TypeScript compiler and its APIs have always had the job of generating\ndeclaration files; however, there are some use-cases where you might want to\nuse other tools, or where the traditional build process doesn\u2019t scale.\n\n### Use-case: Faster Declaration Emit Tools\n\nImagine if you wanted to create a faster tool to generate declaration files,\nperhaps as part of a publishing service or a new bundler. Whilst there is a\nthriving ecosystem of blazing fast tools that can turn TypeScript into\nJavaScript, the same is not true for turning TypeScript into declaration\nfiles. The reason is that TypeScript\u2019s inference allows us to write code\nwithout explicitly declaring types, meaning declaration emit can be complex.\n\nLet\u2019s consider a simple example of a function that adds two imported\nvariables.\n\n    \n    \n    // util.ts export let one = \"1\"; export let one = \"2\"; // add.ts import { one, two } from \"./util\"; export function add() { return one + two; }\n\nEven if the only thing we want to do is generate add.d.ts, TypeScript needs to\ncrawl into another imported file (util.ts), infer that the type of one and two\nare strings, and then calculate that the + operator on two strings will lead\nto a string return type.\n\n    \n    \n    // add.d.ts export declare function add(): string;\n\nWhile this inference is important for the developer experience, it means that\ntools that want to generate declaration files would need to replicate parts of\nthe type-checker including inference and the ability to resolve module\nspecifiers to follow the imports.\n\n### Use-case: Parallel Declaration Emit and Parallel Checking\n\nImagine if you had a monorepo containing many projects and a multi-core CPU\nthat just wished it could help you check your code faster. Wouldn\u2019t it be\ngreat if we could check all those projects at the same time by running each\nproject on a different core?\n\nUnfortunately we don\u2019t have the freedom to do all the work in parallel. The\nreason is that we have to build those projects in dependency order, because\neach project is checking against the declaration files of their dependencies.\nSo we must build the dependency first to generate the declaration files.\nTypeScript\u2019s project references feature works the same way, building the set\nof projects in \"topological\" dependency order.\n\nAs an example, if we have two projects called backend and frontend, and they\nboth depend on a project called core, TypeScript can\u2019t start type-checking\neither frontend or backend until core has been built and its declaration files\nhave been generated.\n\nIn the above graph, you can see that we have a bottleneck. Whilst we can build\nfrontend and backend in parallel, we need to first wait for core to finish\nbuilding before either can start.\n\nHow could we improve upon this? Well, if a fast tool could generate all those\ndeclaration files for core in parallel, TypeScript then could immediately\nfollow that by type-checking core, frontend, and backend also in parallel.\n\n### Solution: Explicit Types!\n\nThe common requirement in both use-cases is that we need a cross-file type-\nchecker to generate declaration files. Which is a lot to ask from the tooling\ncommunity.\n\nAs a more complex example, if we want a declaration file for the following\ncode...\n\n    \n    \n    import { add } from \"./add\"; const x = add(); export function foo() { return x; }\n\n...we would need to generate a signature for foo. Well that requires looking\nat the implementation of foo. foo just returns x, so getting the type of x\nrequires looking at the implementation of add. But that might require looking\nat the implementation of add\u2018s dependencies, and so on. What we\u2019re seeing here\nis that generating declaration files requires a whole lot of logic to figure\nout the types of different places that might not even be local to the current\nfile.\n\nStill, for developers looking for fast iteration time and fully parallel\nbuilds, there is another way of thinking about this problem. A declaration\nfile only requires the types of the public API of a module \u2013 in other words,\nthe types of the things that are exported. If, controversially, developers are\nwilling to explicitly write out the types of the things they export, tools\ncould generate declaration files without needing to look at the implementation\nof the module \u2013 and without reimplementing a full type-checker.\n\nThis is where the new --isolatedDeclarations option comes in.\n--isolatedDeclarations reports errors when a module can\u2019t be reliably\ntransformed without a type-checker. More plainly, it makes TypeScript report\nerrors if you have a file that isn\u2019t sufficiently annotated on its exports.\n\nThat means in the above example, we would see an error like the following:\n\n    \n    \n    export function foo() { // ~~~ // error! Function must have an explicit // return type annotation with --isolatedDeclarations. return x; }\n\n### Why are errors desirable?\n\nBecause it means that TypeScript can\n\n  1. Tell us up-front whether other tools will have issues with generating declaration files\n  2. Provide a quick fix to help add these missing annotations.\n\nThis mode doesn\u2019t require annotations everywhere though. For locals, these can\nbe ignored, since they don\u2019t affect the public API. For example, the following\ncode would not produce an error:\n\n    \n    \n    import { add } from \"./add\"; const x = add(\"1\", \"2\"); // no error on 'x', it's not exported. export function foo(): string { return x; }\n\nThere are also certain expressions where the type is \"trivial\" to calculate.\n\n    \n    \n    // No error on 'x'. // It's trivial to calculate the type is 'number' export let x = 10; // No error on 'y'. // We can get the type from the return expression. export function y() { return 20; } // No error on 'z'. // The type assertion makes it clear what the type is. export function z() { return Math.max(x, y()) as number; }\n\n### Using isolatedDeclarations\n\nisolatedDeclarations requires that either the declaration or composite flags\nare also set.\n\nNote that isolatedDeclarations does not change how TypeScript performs emit \u2013\njust how it reports errors. Importantly, and similar to isolatedModules,\nenabling the feature in TypeScript won\u2019t immediately bring about the potential\nbenefits discussed here. So please be patient and look forward to future\ndevelopments in this space. Keeping tool authors in mind, we should also\nrecognize that today, not all of TypeScript\u2019s declaration emit can be easily\nreplicated by other tools wanting to use it as a guide. That\u2019s something we\u2019re\nactively working on improving.\n\nWe also feel it is worth calling out that isolatedDeclarations should be\nadopted on a case-by-case basis. There are some developer ergonomics that are\nlost when using isolatedDeclarations, and thus it may not be the right choice\nif your setup is not leveraging the two scenarios mentioned earlier. For\nothers, the work on isolatedDeclarations has already uncovered many\noptimizations and opportunities to unlock different parallel build strategies.\nIn the meantime, if you\u2019re willing to make the trade-offs, we believe\nisolatedDeclarations can be a powerful tool to speed up your build process\nonce external tooling becomes available.\n\n### Credit\n\nWork on isolatedDeclarations has been a long-time collaborative effort between\nthe TypeScript team and the infrastructure and tooling teams within Bloomberg\nand Google. Individuals like Hana Joo from Google who implemented the quick\nfix for isolated declaration errors (more on that soon), as well as Ashley\nClaymore, Jan K\u00fchle, Lisa Velden, Rob Palmer, and Thomas Chetwin have been\ninvolved in discussion, specification, and implementation for many months. But\nwe feel it is specifically worth calling out the tremendous amount of work\nprovided by Titian Cernicova-Dragomir from Bloomberg. Titian has been\ninstrumental in driving the implementation of isolatedDeclarations and has\nbeen a contributor to the TypeScript project for years prior.\n\nWhile the feature involved many changes, you can see the core work for\nIsolated Declarations here.\n\n## The ${configDir} Template Variable for Configuration Files\n\nIt\u2019s common in many codebases to reuse a shared tsconfig.json file that acts\nas a \"base\" for other configuration files. This is done by using the extends\nfield in a tsconfig.json file.\n\n    \n    \n    { \"extends\": \"../../tsconfig.base.json\", \"compilerOptions\": { \"outDir\": \"./dist\" } }\n\nOne of the issues with this is that all paths in the tsconfig.json file are\nrelative to the location of the file itself. This means that if you have a\nshared tsconfig.base.json file that is used by multiple projects, relative\npaths often won\u2019t be useful in the derived projects. For example, imagine the\nfollowing tsconfig.base.json:\n\n    \n    \n    { \"compilerOptions\": { \"typeRoots\": [ \"./node_modules/@types\" \"./custom-types\" ], \"outDir\": \"dist\" } }\n\nIf author\u2019s intent was that every tsconfig.json that extends this file should\n\n  1. output to a dist directory relative to the derived tsconfig.json , and\n  2. have a custom-types directory relative to the derived tsconfig.json,\n\nthen this would not work. The typeRoots paths would be relative to the\nlocation of the shared tsconfig.base.json file, not the project that extends\nit. Each project that extends this shared file would need to declare its own\noutDir and typeRoots with identical contents. This could be frustrating and\nhard to keep in sync between projects, and while the example above is using\ntypeRoots, this is a common problem for paths and other options.\n\nTo solve this, TypeScript 5.5 introduces a new template variable ${configDir}.\nWhen ${configDir} is written in certain path fields of a tsconfig.json or\njsconfig.json files, this variable is substituted with the containing\ndirectory of the configuration file in a given compilation. This means that\nthe above tsconfig.base.json could be rewritten as:\n\n    \n    \n    { \"compilerOptions\": { \"typeRoots\": [ \"${configDir}/node_modules/@types\" \"${configDir}/custom-types\" ], \"outDir\": \"${configDir}/dist\" } }\n\nNow, when a project extends this file, the paths will be relative to the\nderived tsconfig.json, not the shared tsconfig.base.json file. This makes it\neasier to share configuration files across projects and ensures that the\nconfiguration files are more portable.\n\nIf you intend to make a tsconfig.json file extendable, consider if a ./ should\ninstead be written with ${configDir}.\n\nFor more information, see the proposal issue and the implementing pull\nrequest.\n\n## Consulting package.json Dependencies for Declaration File Generation\n\nPreviously, TypeScript would often issue an error message like\n\n    \n    \n    The inferred type of \"X\" cannot be named without a reference to \"Y\". This is likely not portable. A type annotation is necessary.\n\nThis was often due to TypeScript\u2019s declaration file generation finding itself\nin the contents of files that were never explicitly imported in a program.\nGenerating an import to such a file could be risky if the path ended up being\nrelative. Still, for codebases with explicit dependencies in the dependencies\n(or peerDependencies and optionalDependencies) of a package.json, generating\nsuch an import should be safe under certain resolution modes. So in TypeScript\n5.5, we\u2019re more lenient when that\u2019s the case, and many occurrences of this\nerror should disappear.\n\nSee this pull request for more details on the change.\n\n## Editor and Watch-Mode Reliability Improvements\n\nTypeScript has either added some new functionality or fixed existing logic\nthat makes --watch mode and TypeScript\u2019s editor integration feel more\nreliable. That should hopefully translate to fewer TSServer/editor restarts.\n\n### Correctly Refresh Editor Errors in Configuration Files\n\nTypeScript can generate errors for tsconfig.json files; however, those errors\nare actually generated from loading a project, and editors typically don\u2019t\ndirectly request those errors for tsconfig.json files. While this sounds like\na technical detail, it means that when all errors issued in a tsconfig.json\nare fixed, TypeScript doesn\u2019t issue a new fresh empty set of errors, and users\nare left with stale errors unless they reload their editor.\n\nTypeScript 5.5 now intentionally issues an event to clear these out. See more\nhere.\n\n### Better Handling for Deletes Followed by Immediate Writes\n\nInstead of overwriting files, some tools will opt to delete them and then\ncreate new files from scratch. This is the case when running npm ci, for\ninstance.\n\nWhile this can be efficient for those tools, it can be problematic for\nTypeScript\u2019s editor scenarios where deleting a watched might dispose of it and\nall of its transitive dependencies. Deleting and creating a file in quick\nsuccession could lead to TypeScript tearing down an entire project and then\nrebuilding it from scratch.\n\nTypeScript 5.5 now has a more nuanced approach by keeping parts of a deleted\nproject around until it picks up on a new creation event. This should make\noperations like npm ci work a lot better with TypeScript. See more information\non the approach here.\n\n### Symlinks are Tracked in Failed Resolutions\n\nWhen TypeScript fails to resolve a module, it will still need to watch for any\nfailed lookup paths in case the module is added later. Previously this was not\ndone for symlinked directories, which could cause reliability issues in\nmonorepo-like scenarios when a build occurred in one project but was not\nwitnessed in the other. This should be fixed in TypeScript 5.5, and means you\nwon\u2019t need to restart your editor as often.\n\nSee more information here.\n\n### Project References Contribute to Auto-Imports\n\nAuto-imports no longer requires at least one explicit import to dependent\nprojects in a project reference setup. Instead, auto-import completions should\njust work across anything you\u2019ve listed in the references field of your\ntsconfig.json.\n\nSee more on the implementing pull request.\n\n## Performance and Size Optimizations\n\n### Monomorphized Objects in Language Service and Public API\n\nIn TypeScript 5.0, we ensured that our Node and Symbol objects had a\nconsistent set of properties with a consistent initialization order. Doing so\nhelps reduce polymorphism in different operations, which allows runtimes to\nfetch properties more quickly.\n\nBy making this change, we witnessed impressive speed wins in the compiler;\nhowever, most of these changes were performed on internal allocators for our\ndata structures. The language service, along with TypeScript\u2019s public API,\nuses a different set of allocators for certain objects. This allowed the\nTypeScript compiler to be a bit leaner, as data used only for the language\nservice would never be used in the compiler.\n\nIn TypeScript 5.5, the same monomorphization work has been done for the\nlanguage service and public API. What this means is that your editor\nexperience, and any build tools that use the TypeScript API, will get a decent\namount faster. In fact, in our benchmarks, we\u2019ve seen a 5-8% speedup in build\ntimes when using the public TypeScript API\u2019s allocators, and language service\noperations getting 10-20% faster. While this does imply an increase in memory,\nwe believe that tradeoff is worth it and hope to find ways to reduce that\nmemory overhead. Things should feel a lot snappier now.\n\nFor more information, see the change here.\n\n### Monomorphized Control Flow Nodes\n\nIn TypeScript 5.5, nodes of the control flow graph have been monomorphized so\nthat they always hold a consistent shape. By doing so, check times will often\nbe reduced by about 1%.\n\nSee this change here.\n\n### Optimizations on Control Flow Graph\n\nIn many cases, control flow analysis will traverse nodes that don\u2019t provide\nany new information. We observed that in the absence of any early termination\nor effects in the antecedents (or \"dominators\") of certain nodes meant that\nthose nodes could always be skipped over. As such, TypeScript now constructs\nits control flow graphs to take advantage of this by linking to an earlier\nnode that does provide interesting information for control flow analysis. This\nyields a flatter control flow graph, which can be more efficient to traverse.\nThis optimization has yielded modest gains, but with up to 2% reductions in\nbuild time on certain codebases.\n\nYou can read more here.\n\n### TypeScript Package Size Reduction\n\nFurther leveraging our transition to modules in 5.0, we\u2019ve significantly\nreduced TypeScript\u2019s overall package size by making tsserver.js and\ntypingsInstaller.js import from a common API library instead of having each of\nthem produce standalone bundles.\n\nThis reduces TypeScript\u2019s size on disk from 30.2 MB to 20.4 MB, and reduces\nits packed size from 5.5 MB to 3.7 MB!\n\n### Node Reuse in Declaration Emit\n\nAs part of the work to enable isolatedDeclarations, we\u2019ve substantially\nimproved how often TypeScript can directly copy your input source code when\nproducing declaration files.\n\nFor example, let\u2019s say you wrote\n\n    \n    \n    export const strBool: string | boolean = \"hello\"; export const boolStr: boolean | string = \"world\";\n\nNote that the union types are equivalent, but the order of the union is\ndifferent. When emitting the declaration file, TypeScript has two equivalent\noutput possibilities.\n\nThe first is to use a consistent canonical representation for each type:\n\n    \n    \n    export const strBool: string | boolean; export const boolStr: string | boolean;\n\nThe second is to re-use the type annotations exactly as written:\n\n    \n    \n    export const strBool: string | boolean; export const boolStr: boolean | string;\n\nThe second approach is generally preferable for a few reasons:\n\n  * Many equivalent representations still encode some level of intent that is better to preserve in the declaration file\n  * Producing a fresh representation of a type can be somewhat expensive, so avoiding is better\n  * User-written types are usually shorter than generated type representations\n\nIn 5.5, we\u2019ve greatly improved the number of places where TypeScript can\ncorrectly identify places where it\u2019s safe and correct to print back types\nexactly as they were written in the input file. Many of these cases are\ninvisible performance improvements \u2013 TypeScript would generate fresh sets of\nsyntax nodes and serialize them into a string. Instead, TypeScript can now\noperate over the original syntax nodes directly, which is much cheaper and\nfaster.\n\n## Easier API Consumption ECMAScript Modules\n\nPreviously, if you were writing an ECMAScript module in Node.js, named imports\nwere not available from the typescript package.\n\n    \n    \n    import { createSourceFile } from \"typescript\"; // error import * as ts from \"typescript\"; ts.createSourceFile // error ts.default.createSourceFile // works - but ugh!\n\nThis is because cjs-module-lexer did not recognize the pattern of TypeScript\u2019s\ngenerated CommonJS code. This has been fixed, and users can now use named\nimports from the TypeScript npm package with ECMAScript modules in Node.js.\n\n    \n    \n    import { createSourceFile } from \"typescript\"; // works now! import * as ts from \"typescript\"; ts.createSourceFile // works now!\n\nFor more information, see the change here.\n\n## The transpileDeclaration API\n\nTypeScript\u2019s API exposes a function called transpileModule. It\u2019s intended to\nmake it easy to compile a single file of TypeScript code. Because it doesn\u2019t\nhave access to an entire program, the caveat is that it may not produce the\nright output if the code violates any errors under the isolatedModules option.\n\nIn TypeScript 5.5, we\u2019ve added a new similar API called transpileDeclaration.\nThis API is similar to transpileModule, but it\u2019s specifically designed to\ngenerate a single declaration file based on some input source text. Just like\ntranspileModule, it doesn\u2019t have access to a full program, and a similar\ncaveat applies: it only generates an accurate declaration file if the input\ncode is free of errors under the new isolatedDeclarations option.\n\nIf desired, this function can be used to parallelize declaration emit across\nall files under isolatedDeclarations mode. Note that while you might\nexperience some of the performance overhead of transpileModule in\ntranspileDeclaration, we\u2019re working on ways to optimize this further.\n\nFor more information, see the implementation here.\n\n## Notable Behavioral Changes\n\nThis section highlights a set of noteworthy changes that should be\nacknowledged and understood as part of any upgrade. Sometimes it will\nhighlight deprecations, removals, and new restrictions. It can also contain\nbug fixes that are functionally improvements, but which can also affect an\nexisting build by introducing new errors.\n\n### Disabling Features Deprecated in TypeScript 5.0\n\nTypeScript 5.0 deprecated the following options and behaviors:\n\n  * charset\n  * target: ES3\n  * importsNotUsedAsValues\n  * noImplicitUseStrict\n  * noStrictGenericChecks\n  * keyofStringsOnly\n  * suppressExcessPropertyErrors\n  * suppressImplicitAnyIndexErrors\n  * out\n  * preserveValueImports\n  * prepend in project references\n  * implicitly OS-specific newLine\n\nTo continue using the deprecated options above, developers using TypeScript\n5.0 and other more recent versions have had to specify a new option called\nignoreDeprecations with the value \"5.0\".\n\nIn TypeScript 5.5, these options no longer have any effect. To help with a\nsmooth upgrade path, you may still specify them in your tsconfig, but these\nwill be an error to specify in TypeScript 6.0. See also the Flag Deprecation\nPlan which outlines our deprecation strategy.\n\nMore information around these deprecation plans is available on GitHub, which\ncontains suggestions in how to best adapt your codebase.\n\n### lib.d.ts Changes\n\nTypes generated for the DOM may have an impact on type-checking your codebase.\nFor more information, see the DOM updates for TypeScript 5.5.\n\n### Respecting File Extensions and package.json in Other Module Modes\n\nBefore Node.js implemented support for ECMAScript modules in v12, there was\nnever a good way for TypeScript to know whether .d.ts files it found in\nnode_modules represented JavaScript files authored as CommonJS or ECMAScript\nmodules. When the vast majority of npm was CommonJS-only, this didn\u2019t cause\nmany problems \u2013 if in doubt, TypeScript could just assume that everything\nbehaved like CommonJS. Unfortunately, if that assumption was wrong it could\nallow unsafe imports:\n\n    \n    \n    // node_modules/dep/index.d.ts export declare function doSomething(): void; // index.ts // Okay if \"dep\" is a CommonJS module, but fails if // it's an ECMAScript module - even in bundlers! import dep from \"dep\"; dep.doSomething();\n\nIn practice, this didn\u2019t come up very often. But in the years since Node.js\nstarted supporting ECMAScript modules, the share of ESM on npm has grown.\nFortunately, Node.js also introduced a mechanism that can help TypeScript\ndetermine if a file is an ECMAScript module or a CommonJS module: the .mjs and\n.cjs file extensions and the package.json \"type\" field. TypeScript 4.7 added\nsupport for understanding these indicators, as well as authoring .mts and .cts\nfiles; however, TypeScript would only read those indicators under --module\nnode16 and --module nodenext, so the unsafe import above was still a problem\nfor anyone using --module esnext and --moduleResolution bundler, for example.\n\nTo solve this, TypeScript 5.5 reads and stores module format information\nencoded by file extensions and package.json \"type\" in all module modes, and\nuses it to resolve ambiguities like the one in the example above in all modes\n(except for amd, umd, and system).\n\nA secondary effect of respecting this format information is that the format-\nspecific TypeScript file extensions (.mts and .cts) or an explicitly set\npackage.json \"type\" in your own project will override your --module option if\nit\u2019s set to commonjs or es2015 through esnext. Previously, it was technically\npossible to produce CommonJS output into a .mjs file or vice versa:\n\n    \n    \n    // main.mts export default \"oops\"; // $ tsc --module commonjs main.mts // main.mjs Object.defineProperty(exports, \"__esModule\", { value: true }); exports.default = \"oops\";\n\nNow, .mts files (or .ts files in scope of a package.json with \"type\":\n\"module\") never emit CommonJS output, and .cts files (or .ts files in scope of\na package.json with \"type\": \"commonjs\") never emit ESM output.\n\nMore details are available on the change here.\n\n### Stricter Parsing for Decorators\n\nSince TypeScript originally introduced support for decorators, the specified\ngrammar for the proposal has been tightened up. TypeScript is now stricter\nabout what forms it allows. While rare, existing decorators may need to be\nparenthesized to avoid errors.\n\n    \n    \n    class DecoratorProvider { decorate(...args: any[]) { } } class D extends DecoratorProvider { m() { class C { @super.decorate // error method1() { } @(super.decorate) // okay method2() { } } } }\n\nSee more information on the change here.\n\n### undefined is No Longer a Definable Type Name\n\nTypeScript has always disallowed type alias names that conflict with built-in\ntypes:\n\n    \n    \n    // Illegal type null = any; // Illegal type number = any; // Illegal type object = any; // Illegal type any = any;\n\nDue to a bug, this logic didn\u2019t also apply to the built-in type undefined. In\n5.5, this is now correctly identified as an error:\n\n    \n    \n    // Now also illegal type undefined = any;\n\nBare references to type aliases named undefined never actually worked in the\nfirst place. You could define them, but you couldn\u2019t use them as an\nunqualified type name.\n\n    \n    \n    export type undefined = string; export const m: undefined = \"\"; // ^ // Errors in 5.4 and earlier - the local definition of 'undefined' was not even consulted.\n\nFor more information, see the change here.\n\n## What\u2019s Next?\n\nAt this point, TypeScript 5.5 is what we\u2019d call \"feature-stable\". The focus on\nTypeScript 5.5 will be bug fixes, polish, and certain low-risk editor\nfeatures. We\u2019ll have a release candidate available in a bit over month,\nfollowed by a stable release soon after. If you\u2019re interested in planning\naround the release, be sure to keep an eye on our iteration plan which has\ntarget release dates and more.\n\nAs a note: while beta is a great way to try out the next version of\nTypeScript, you can also try a nightly build to get the most up-to-date\nversion of TypeScript 5.5 up until our release candidate. Our nightlies are\nwell-tested and can even be tested solely in your editor.\n\nSo please try out the beta or a nightly release today and let us know what you\nthink!\n\nHappy Hacking!\n\n\u2013 Daniel Rosenwasser and the TypeScript Team\n\n### Daniel Rosenwasser Senior Program Manager, TypeScript\n\nFollow\n\n### Read next\n\nAnnouncing TypeScript 5.4\n\nToday we're excited to announce the release of TypeScript 5.4! If you're not\nfamiliar with TypeScript, it's a language that builds on top of JavaScript by\nmaking it ...\n\nDaniel Rosenwasser March 6, 2024\n\n0 comment\n\nAnnouncing TypeScript 5.4 RC\n\nToday we're excited to announce our Release Candidate of TypeScript 5.4!\nBetween now and the stable release of TypeScript 5.4, we expect no further\nchanges apart from ...\n\nDaniel Rosenwasser February 22, 2024\n\n2 comments\n\n## 0 comments\n\n### Leave a commentCancel reply\n\nLog in to start the discussion.\n\n##### Code Block\n\nFeedback\n\nYour Privacy Choices Consumer Health Privacy\n\nNotifications\n\n", "frontpage": true}
