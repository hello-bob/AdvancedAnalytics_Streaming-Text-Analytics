{"aid": "40104179", "title": "The Alternative Implementation Problem", "url": "https://pointersgonewild.com/2024/04/20/the-alternative-implementation-problem/", "domain": "pointersgonewild.com", "votes": 1, "user": "ingve", "posted_at": "2024-04-21 09:00:53", "comments": 0, "source_title": "The Alternative Implementation Problem", "source_text": "The Alternative Implementation Problem | Pointers Gone Wild\n\nSkip to content\n\nFollow:\n\n    RSS\n    Twitter\n\nPointers Gone Wild\n\nA blog about programming, technology and society.\n\n  * Home\n  * About Me\n  * GitHub\n\nTags\n\ncoding, compiler, javascript, programming, python, ruby\n\n# The Alternative Implementation Problem\n\nApril 20, 2024\n\nIn this post, I want to talk about a dynamic that I\u2019ve seen play itself over\nand over again in the software world. In fact, I would venture a guess that\nthis kind of situation probably happens in the hardware world as well, but\nI\u2019ll speak about software systems since this is where my experience lies. This\ndiscussion is going to touch a bit on human psychology, and outline a common\ntrap so that you can hopefully avoid getting stuck in it.\n\nMost of my career, both in academia and industry, has been spent trying to\noptimize dynamically-typed programming languages. During my master\u2019s I worked\non a simple optimizing JIT for MATLAB. For my PhD I worked on a JIT for\nJavaScript. Today I\u2019m working on YJIT, an optimizing JIT for Ruby which has\nnow been upstreamed into CRuby.\n\nDuring my PhD, while working on my own JavaScript JIT, I read many papers and\nblog posts about JIT compilers for other dynamic languages. I read about the\ndesign of HotSpot, Self, LuaJIT, PyPy, TruffleJS, V8, SpiderMonkey, and\nJavaScriptCore among others. I also had the chance to interact with and meet\nface to face with many of the really smart people behind these projects.\n\nOne of the things that struck me is that the PyPy project was kind of stuck in\na weird place. They had developed an advanced JIT compiler for Python which\ncould produce great speedups over CPython. By all accounts many people could\nbenefit from these performance gains, but PyPy was seeing very little use in\nthe \u201creal world\u201d. One of the challenges that they faced is that Python is a\nmoving target. New versions of CPython come out regularly, always adding many\nnew features, and PyPy struggles to keep up, is always several Python versions\nbehind. If you want you Python software to be PyPy-compatible, you\u2019re much\nmore limited in terms of which Python features you use, and most Python\nprogrammers don\u2019t want to have to think about that.\n\nReading about LuaJIT, I found that it was and still is highly regarded. Many\npeople regard its creator, Mike Pall, as an incredible programmer. LuaJIT\noffers great performance gains over the default, interpreted Lua\nimplementation, and has seen some decent adoption in the wild. However, I\nagain saw that there are a number of Lua users who do not want to use LuaJIT\nbecause the Lua language keeps adding new features and LuaJIT is several\nversions behind. This is a bit strange considering that Lua is a language that\nis known for its minimalism. It seems like they could have made an effort to\nslow down the addition of new features and/or coordinate with Mike Pall, but\nthis wasn\u2019t done.\n\nAlmost 4 years ago, I joined Shopify to work on Ruby. For some reason, the\nspace of Ruby JITs has been particularly competitive, and there had been a\nnumber of projects to build Ruby JITs. The TruffleRuby JIT boasted the most\nimpressive performance numbers, but again, had seen limited deployments. There\nwere some practical reasons for this, the warm up time of TruffleRuby is much\nlonger than that of CRuby, but I also saw a similar dynamic to that of PyPy\nand LuaJIT, where CRuby kept adding features, and TruffleRuby contributors had\nto work hard to try and keep up. It didn\u2019t really matter if TruffleRuby could\nbe quite a bit faster, because Ruby users would always view CRuby as the\ncanonical implementation, and anything that wasn\u2019t fully compatible wasn\u2019t\nseen as worthy of consideration.\n\nHopefully, at this point, you see where I\u2019m going with this. What I\u2019ve\nconcluded, based on experience, is that positioning your project as an\nalternative implementation of something is a losing proposition. It doesn\u2019t\nmatter how smart you are. It doesn\u2019t matter how hard you work. The problem is,\nwhen you build an alternative implementation, you\u2019ve made yourself subject to\nthe whims of the canonical implementation. They have control over the\ndirection of the project, and all you can do is try to keep up. In the case of\nJITted implementations of traditionally interpreted languages, there\u2019s a bit\nof a weird dynamic, because it\u2019s much faster to implement new features in an\ninterpreter. The implementers of the canonical implementation may see you as\ncompetition they are trying to outrun. You may be stuck trying to ice skate\nuphill.\n\nAlmost 4 years ago, with support from Shopify, two dedicated colleagues and I\nstarted a project to build YJIT, yet another Ruby JIT. The difference is that\nwe made the key choice to build YJIT not as an alternative implementation, but\ndirectly inside CRuby itself. This came with a number of design tradeoffs, but\ncritically, YJIT could be 100% compatible with every CRuby feature from the\nstart. YJIT is now the \u201cofficial\u201d Ruby JIT, and is deployed at Shopify,\nDiscourse and GitHub among others. If you\u2019ve visited github.com today, or any\nShopify store, you\u2019ve interacted with YJIT. We\u2019ve had more success than any\nother Ruby JIT compiler so far, and compatibility has been key in achieving\nthis.\n\nYou may read this and think that the key lesson of this post follows the old\nadage that \u201cif you can\u2019t beat them, join them\u201d. In some ways, I suppose it\ndoes. What I want to say is that if you start a project to try and position\nyourself as an alternative but better implementation of something, you are\nlikely to find yourself stuck in a spot where you\u2019re always playing catch up\nand living in the shadow of the canonical implementation. The canonical\nproject keeps evolving, and you have no choice but to follow along with\nlimited decisional power over where your own project is headed. That\u2019s no fun.\nYou may have better luck trying to join up with the canonical implementation\ninstead. However, that\u2019s only part of the answer.\n\nIn the Ruby space, there is also Crystal, a Ruby-like language that is\nstatically compiled with type inference. This language is intentionally not\nRuby-compatible, it has chosen to diverge from Ruby, but has still seen\nlimited success. I think this is interesting because it gives us a broader\nperspective. Rubyists don\u2019t like Crystal because it\u2019s almost-Ruby-but-not-\nquite. It looks like Ruby, syntactically, but has many subtle differences and\nis very much incompatible in practice. This just confuses people, it breaks\ntheir expectations. Crystal probably would have had better luck if it had\nnever marketed itself as being similar to Ruby in the first place.\n\nPeter Thiel has a saying that \u201ccompetition is for losers\u201d. His main point is\nthat you shouldn\u2019t put yourself in a position where you\u2019re forced to compete\nif you don\u2019t have to. My advice to younger programmers would be, if you\u2019re\nthinking of creating your own programming language, for example, then don\u2019t go\ntrying to create a subset of Python, or something superficially very close to\nan existing language. Do your own thing. That way, you can evolve your system\nat your own pace and in your own direction, without being chained by\nexpectations that your language should have to match the performance, feature\nset, or library ecosystem of another implementation.\n\nI\u2019ll finish with some caveats. What I said above applies when you have a\nsituation where there is a canonical implementation of a language or system.\nIt doesn\u2019t apply in a space where you have open standards. For example, if you\nwant to implement your own JSON parser, there is a clearly defined\nspecification that is relatively small and doesn\u2019t evolve very fast. This is\nvery much something you can achieve. You also have a situation where there are\nmultiple browser-based implementations of JavaScript. This is possible in part\nbecause there is an external standard body that governs the JS specification,\nand the people working on the JS standard understand that JIT-compiled\nimplementations are critical for performance and guide the evolution of the\nlanguage accordingly. They are not in the game of adding many new features as\nfast as possible.\n\n### Share this:\n\n  * Twitter\n  * Reddit\n  * Facebook\n\nLike Loading...\n\nFrom \u2192 Programming, Programming Languages\n\nOne Comment\n\n  1. Mike S. permalink\n\nI think your post raises the larger issue that the industry prizes innovation\nover stability, and we all suffer as a result.\n\nCryptography APIs, unfortunately, have no choice but evolve as flaws are\ndiscovered and fixed.\n\nBut aside from tremendous (and impressive) speed improvements, does Ruby 3.2\nor newer truly have killer features over 2.6? Do Python users absolutely need\nthe features in the latest CPython point release over Pypy?\n\nI\u2019m not saying it\u2019s practical to pick an older version and standardize on it.\nIt often isn\u2019t. I\u2019m just lamenting the state of the industry.\n\nReply\n\n### Leave a comment Cancel reply\n\nThe Race to Make Humans Obsolete \u00bb\n\n  * ## @Love2Code on twitter\n\nMy Tweets\n\n  * ## Recent Posts\n\n    * The Alternative Implementation Problem\n    * The Race to Make Humans Obsolete\n    * Human-Scale vs Asymmetric Social Media\n    * Preparing UVM for 3D Graphics\n    * Software Bugs That Cause Real-World Harm\n    * Memory, Pages, mmap, and Linear Address Spaces\n    * Building a Minimalistic Virtual Machine\n    * Typed vs Untyped Virtual Machines\n  * ## Category Cloud\n\nArt Artificial Intelligence Artificial Life Assembly Biology Compilers\nCreativity D Language Electronics Future Game Development Grad studies\nGraphics Higgs JavaScript Microcontrollers Microprocessors Music Programming\nProgramming Languages Psychology Rant Robotics Tachyon Technology\nUncategorized UVM work x86 Zeta\n\n  * ## Archives\n\n  * ## Blog Stats\n\n    * 719,533 hits\n\nBlog at WordPress.com.\n\n  * Comment\n  * Reblog\n  * Subscribe Subscribed\n\n    * Pointers Gone Wild\n    * Already have a WordPress.com account? Log in now.\n\n  * Privacy\n  *     * Pointers Gone Wild\n    * Customize\n    * Subscribe Subscribed\n    * Sign up\n    * Log in\n    * Copy shortlink\n    * Report this content\n    * View post in Reader\n    * Manage subscriptions\n    * Collapse this bar\n\n%d\n\n", "frontpage": false}
