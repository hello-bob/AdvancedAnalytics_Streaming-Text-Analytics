{"aid": "40274113", "title": "Weaver: An ergonomic CLI parsing library for Roc lang", "url": "https://sammohr.dev/blog/announcing-weaver", "domain": "sammohr.dev", "votes": 1, "user": "rtfeldman", "posted_at": "2024-05-06 12:59:16", "comments": 0, "source_title": "Announcing Weaver - Sam Mohr", "source_text": "Announcing Weaver - Sam Mohr\n\nSam Mohr\n\n  * Keyboards\n  * Blog\n  * Sudoku\n\n  * Keyboards\n  * Blog\n  * Sudoku\n\n# Announcing Weaver\n\n## Having your cake and eating it, too\n\nWritten on: Sunday, May 5, 2024\n\nThis is an announcement for Weaver, my arg parsing library for the Roc\nlanguage. I did a talk on Weaver that you can watch here, the transcript for\nwhich is available as a gist here.\n\nProgramming languages, much like life, are mired in decisions concerning\nscarcity. \u201cThere is no silver bullet.\u201d If you want the convenience of using\nPython for prototyping your project, you\u2019ll either need to rewrite it into a\ncompiled language at some point or face scaling issues relating to both\nperformance and complexity management. That\u2019s what I love so much about the\nbudding Roc language: it\u2019s very ergonomic to write, but it\u2019s designed from the\nground up to be well-typed, fast to compile, and fast to run. Roc is all about\nletting me not feel like I\u2019m making a big sacrifice in using it.\n\nThere are many efforts by the Roc language to achieve this uncompromising\nsimplicity; most recently, the await bang syntax (e.g. data = Http.get! url)\nhas made writing effectful code much more ergonomic while still being safe.\nThough that\u2019s a great feature, I personally was most enamored with the record\nbuilder syntax that was added last year by @agu-z.\n\n## What\u2019s a record builder?\n\nThe builder pattern : <\\- is syntax sugar that turns this:\n\n    \n    \n    init { a: <- foo, b: <- bar, } |> finish\n\ninto this:\n\n    \n    \n    init (a1 -> b1 -> { a: a1, b: b1 }) |> foo |> bar |> finish\n\nIt\u2019s a syntax in Roc that lets you call multiple functions on an applicative\nfunctor and store the results in a record. If you don\u2019t know what an\napplicative functor is, you can read about it here, but it\u2019s basically a\nconvenient type that allows for effectful-like programming. There are lots of\ntasks that are made much simpler, or even possible at all, with this syntax:\n\n  * Batching parallel HTTP requests\n  * Incrementing a counter for successive function calls\n  * Parsing JSON data or command-line arguments\n\nThat last one is the first thing I thought of when I saw this syntax, a way to\nparse, not validate my command line arguments without metaprogramming/macros!\nNormally, when you get a list of command line arguments and want to parse them\ninto specific values, you\u2019ll define your flags and parameters, and whatever\nlibrary will give you back a dictionary with string values for everything you\nasked for. You can see what I mean with this simplified Python example:\n\n    \n    \n    config = Cli( name=\"my-app\", flags=[\"-f/--force\"], params={ \"file\": \"string\", \"amount\": \"number\" } ) args = [\"my-app\", \"--force\", \"abc.txt\", \"5\"] data = config.parse(args) data == { \"force\": \"true\", \"file\": \"abc.txt\": \"amount\": \"5\" }\n\nYou then you have to go in and validate that data after it\u2019s already parsed:\n\n    \n    \n    force = data[\"force\"] == \"true\" file = data[\"file\"] or \"\" amount = int(data[\"amount\"]) # might throw if invalid\n\nNow, if the above Python was written using its standard library, then it would\nreturn an object with the actual data types in it (e.g. data.amount = 5), but\nthat is only possible because Python is dynamically typed, and I don\u2019t want to\nlive in that kind of jungle. So as long as we live in Type Land, then we need\nto do the above.\n\n## Macro-based parser builders\n\nHowever, if you have macros like in Rust, then you can get the above for\nfree^** with clap, a magical and type-safe library for argument parsing! All\nyou do is define a struct with your options and then put some annotations:\n\n    \n    \n    /// A tool to color some data. #[derive(Debug, Parser)] pub struct ArgConfig { /// The color of your output. #[clap(short, long)] pub color: String, /// How much logging to show. #(clap(count)) pub verbosity: usize, }\n\nAnd clap will generate code during compilation to do what we had to manually\ndo in Python, and we can just call a single function to handle everything:\n\n    \n    \n    let config = ArgConfig::parse(); config == ArgConfig { color: \"abc\".to_owned(), verbosity: 3 }\n\nYou may have noticed a conspicuous asterisk or two on the word \u201cfree\u201d when I\nsaid clap generates this for free. The hidden cost here is a compile time\ncost: macros are a box of legos bundled on top of any language they\u2019re in, and\nmake compilation a good deal slower. Any Rust engineer (myself included) will\ntell you how much serde or sqlx contributes to their development slowdown. Not\nto mention that Rust\u2019s procedural macros, like the ones that clap uses here,\nare extremely powerful, which lets you do write very convenient-to-use code\nthat unfortunately makes it much harder for readers to know what\u2019s actually\nhappening in the code they\u2019re writing.\n\nKnowing about these difficulties in conveniently parsing data is what makes me\nso excited about using Roc\u2019s record builder syntax to solve this problem! One\nHackers-inspired montage of cracking out code later, I\u2019ve now released version\n0.2.0 of Weaver, my library for parsing CLI args using this great : <\\- ...\ndoohickey.\n\n## Show me an example!\n\nWeaver CLI\u2019s look like this:\n\n    \n    \n    cli = Cli.weave { alpha: <- Opt.maybeU64 { short: \"a\", long: \"alpha\" }, verbosity: <- Opt.count { short: \"v\", long: \"verbose\" } file: <- Param.str { name: \"file\" }, files: <- Param.strList { name: \"files\" }, } |> Cli.finish { name: \"transmogrify\", version: \"1.0.0\", description: \"Transform some files into a new state.\" } |> Cli.assertValid main = when Cli.parseOrDisplayMessage cli (Arg.list!) is Ok data -> data == { alpha: 5, verbosity: 1, file: \"1.txt\", files: [\"2.txt\", \"3.txt\"] } Err message -> Stderr.line message\n\nThere are a few cool things I want to point out:\n\n  * We didn\u2019t explicitly define the type of any of our fields in the CLI config, all of their types were inferred from the functions we called.\n  * The cli we defined didn\u2019t require us to pass the arguments ahead of time, because Weaver is able to be very modular thanks to how the builder syntax works.\n  * Like with Rust\u2019s clap, we also get automatic help text and usage text without writing any extra code, but here it\u2019s done without any macros.\n\nThe main takeaway is that we get a simple API to parse CLI args in a type-safe\nway without needing to do metaprogramming at compile time. To be fair, there\nwas a lot more work necessary to develop this library than it is to use (keep\nreading), but that parallels how the Roc language works: the language team has\ndone a lot of great design work and optimization to make it so that you don\u2019t\nhave to worry about writing performant or safe code, it happens by virtue of\nwriting anything that compiles in Roc.\n\nWeaver has everything you need already to write a CLI parser to get your app\nrolling, but there are a few other features I\u2019m planning on adding when I get\nto it:\n\n  * Completion generation for popular shells (e.g. zsh, fish, bash, etc.)\n  * Detecting whether to style help text if in a TTY or not\n  * A one-and-done parsing function like clap\u2019s once module params are implemented\n  * Check the README for a more complete list\n\nIf there\u2019s a feature that\u2019s missing that you would find crucial to writing a\nCLI using Weaver, please make an issue and I can jump on doing what the\ncommunity finds important. I want to make Weaver a one-stop-shop for CLI\nparsing in Roc!\n\n## What I like about writing Roc\n\nI love writing code in Roc. It\u2019s awesome. There are tons of great features\nthat I take for granted like the type system, the super helpful compiler error\nmessages, and the clean syntax, but the biggest two are definitely the\nexpressiveness and the good dev experience.\n\n### It\u2019s expressive\n\nRoc has something I\u2019ve not seen in any other programming language: anonymous\ntag unions. You can create sum types like in Rust, but you don\u2019t need to write\na type that captures all variants of your sum type, you just write code and\nRoc will figure out which variants you used, and make sure you handle all\nvariants where necessary.\n\nSo not only does Roc know that color\u2019s type in\n\n    \n    \n    score = when color is Red -> 5 Green -> 10 Blue -> 15\n\nis [Red, Green, Blue], but you can use the same tag in different contexts and\nRoc will group the unions differently:\n\n    \n    \n    myScore = when myColor is Red -> 5 Green -> 10 yourScore = when yourColor is Green -> 10 Custom score -> score allColors = [myColor, yourColor]\n\nmyColor is typed [Red, Green] and yourScore is typed [Green, Custom U64], but\nallColors is typed List [Red, Green, Custom U64]. Just one of many magic\nfeatures in Roc.\n\n### It has great DX\n\nRoc only accepts features that can be parsed and type-checked very quickly,\nmeaning that you can expect your code to always type-check in milliseconds.\nThat paired with a language server and a tree sitter implementation makes for\na great experience writing code. It will take some time for Roc to mature\nenough to test this, but I\u2019m pretty confident that Roc will be a great\nlanguage for monorepos, meaning I won\u2019t have to eat my golang brussel sprouts\nwhen working on large, collaborative codebases.\n\nSince the compiler errors are so helpful, you can just start writing code and\nthe type-checker will tell you what part of your code is missing. That was a\ngodsend during my development of Weaver with how complicated some of the types\nthat I was dealing with were.\n\nWhen I had a working prototype and needed to get the library ready for\nrelease, refactoring was a breeze, since everything is just functions, as Roc\nis a pure functional language, and also doesn\u2019t support name shadowing. I just\ncopied around text and renamed functions, and then added doc comments and made\na GitHub release. Nothing to it!\n\n### Should I use Roc?\n\nIf you\u2019re wondering whether or not you should write code in Roc, the tl;dr is\ngo for it now if you don\u2019t mind using an alpha-language, but probably you\nshould wait a couple years until they do versioned releases so you can get\nstability guarantees. There are definitely a lot of compiler bugs at the\nmoment, but they are getting fixed as the months go by.\n\nThe thing that gives me the most confidence that I\u2019ll be using Roc at my job\nsomeday is the team of developers currently working on Roc. The GitHub repo is\nalways active with new issues and pull requests, and I don\u2019t have to worry\nabout a low bus factor. Above all, the BDFN (Benevolent Dictator For Now) is\nRichard Feldman, who is a big player from the Elm ecosystem and the reason Roc\nexists at all. He is so knowledgeable about how to make the right programming\nlanguage that I have no doubt that Roc will be a great language in the next\nfew years!\n\n## How to build a library, one magic trick at a time\n\nIf you\u2019re curious about how Weaver works, keep reading, but if not, you can\nuse it right now by copying the example in the README into a file and running\nit with roc example.roc -- ARGS.\n\n# \ud83d\udc4b\n\n...okay, you didn\u2019t run away. Good! I learned a good bit while writing Weaver,\nand anyone writing Roc code with or without the record builder syntax could\nprobably glean something from my experience. I\u2019ll start by explaining the gist\nof how Weaver works, and then we\u2019ll get into some nitty gritty bits. Fair\nwarning, I\u2019m assuming your familiar with how Roc works, which you can learn\nfrom the tutorial if you haven\u2019t already.\n\n### Wrangling the curried builder\n\nCli.weave is the entry point for any Weaver CLI, and it creates a CLI builder\nthat receives the curried builder and initializes an empty metadata config.\n\nEach new field (e.g. Opt.maybeStr or Param.u64) does the following:\n\n  * Add their metadata to the config\n  * Update the parser to a new parser\n\nWhat we want at the end is a parser of type List Str -> Result data CliErr,\nand all metadata defined. To get that parser, we need some way of getting from\nthe curried builder:\n\n    \n    \n    A -> B -> C -> { a: A, b: B, c: C }\n\nto an uncurried argument parser:\n\n    \n    \n    List Str -> Result { a: A, b: B, c: C } CliErr\n\nWe do this by having each field parser (e.g. Opt.i16List) take an applicative\nfunctor that currently has a data parser of type A -> rest and returns an\napplicative functor that has a data parser of type rest, and we end up working\nthrough the curried builder until we have a simple function at the end.\n\nFor example, the type of Opt.i16List is:\n\n    \n    \n    OptionConfigBaseParams -> (CliBuilder (List I16 -> state) GetOptionsAction -> CliBuilder state GetOptionsAction)\n\nwhere CliBuilder state action is the builder we pass around. The state\nrepresents what remains of the original A -> B -> C -> { ... } we have\nremaining in our builder. You\u2019ll notice that the second parameter has a state\nof List I16 -> state, which sets the corresponding field to List I16 and\nreturns the remaining state for deconstruction by the rest of the field\nextractor functions.\n\nYou should look at the source of Weaver to properly understand how this works\nif you want to build your own builder pattern library for Roc.\n\n### Enforcing field ordering with typestate\n\nBased on looking at how other CLIs work, including the official roc CLI,\nthere\u2019s a precedence on the order in which arguments should be parsed:\n\n  * options (-a or --alpha),\n  * then subcommands,\n  * and then parameters (file.txt)\n\nThis lets us handle these cases correctly:\n\n  * both roc example.roc and roc test example.roc\n  * parameters starting with - (e.g. a file named \u201c-file.txt\u201d)\n\nWe want to allow starting the builder with Opts, Subcommands, or Params. We\nshould be able to move to any following field from a prior type, but not move\nback. e.g. Opt to Subcommand or Opt to Param, but not Param to Opt. To achieve\nthe above, the CliBuilder has a type variable called action that can either\nbe:\n\n  * { getOptions: {} } (alias GetOptionsAction)\n  * { getParams: {} } (alias GetParamsAction)\n  * [] (alias StopCollectingAction)\n\nThis is an approach called typestate that I learned from the Rust ecosystem.\nTypestate encodes the state of the program into its types, like a finite state\nmachine. We follow this recipe when traversing the \u201cfinite state machine\u201d:\n\n  1. On builder creation, the action is { getOptions: {} }.\n\nWe can start taking Opt, Subcommand, or Param.\n\n  2. Opt.* takes { getOptions: {} } and returns { getOptions: {} }.\n\nWe can only take Opts at the beginning of building as any other action will\nnot type-check.\n\n  3. Subcommand.* takes { getOptions: {} } and returns { getParams: {} }.\n\nSubcommands must come after Opts (though none are required) and before Params.\n\n  4. Param.* takes {}action and returns { getParams: {} }.\n\nOnce we start taking Params, we can\u2019t take anything else but Params. All other\nactions need { getOptions: {} } as the input action. The {} at the beginning\nof the {}action parameter says that whatever action parameter is passed must\nbe a record of some type, disallowing the [] empty union type that is returned\nafter a Param.*List call.\n\n  5. Param.*List takes action and returns [].\n\nOnce we take a list of params, we can\u2019t take anything else as it will consume\nall remaining parameters. This type-checks because of the other actions need\ntheir action to be some kind of struct, not a tag union.\n\nThis specific recipe for transitions between field actions means that the\ncompiler keeps the user from compiling code that doesn\u2019t have their fields\n(and therefore the underlying parser) in the right order! It\u2019s tricky to wrap\nyour head around, but it\u2019s definitely the coolest thing I applied in building\nWeaver!\n\n## Thanks for reading!\n\nP.S please check out Roc if you haven\u2019t already.\n\nBye!\n\n", "frontpage": false}
