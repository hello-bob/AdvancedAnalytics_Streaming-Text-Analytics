{"aid": "40256600", "title": "At some point, JavaScript got good", "url": "https://jonbeebe.net/2024/05/javascript-got-good/", "domain": "jonbeebe.net", "votes": 13, "user": "jonbeebe", "posted_at": "2024-05-04 10:55:13", "comments": 0, "source_title": "At some point, JavaScript got good \u00b7 jonbeebe.net", "source_text": "At some point, JavaScript got good \u00b7 jonbeebe.net\n\n# At some point, JavaScript got good\n\nMay 4, 2024\n\njavascript\n\nI\u2019ve been both fortunate and unfortunate to have worked with JavaScript full-\ntime since about 2012. It was \u201cunfortunate\u201d because prior to around 2015\u2014when\nmajor improvements started coming to the ECMAScript spec\u2014the language was a\nreal pain to wrangle on a daily basis.\n\nHowever, I\u2019m also very fortunate because while there\u2019s been a lot of\nimprovements made to JavaScript since then, the fundamental way the language\nworks is still the same, so having a deeper understanding of the new syntax\n(sans sugar) is useful when it comes to debugging, working with legacy\nprojects, or digging deeper into lower-level code. I\u2019m also able to better\nappreciate just how good us JS devs have it these days.\n\n### Short background\n\nI started working with JavaScript professionally back when I worked for a\nsmall startup called Lanica back in 2012. It was an Appcelerator-funded\ncompany that made a mobile game engine for the Titanium SDK (we worked out of\nthe Appcelerator offices in Mountain View, CA).\n\nComing from Lua, which is a simple but very \u201csane\u201d scripting language (that I\nused heavily at a prior company), JavaScript was quite the nightmare to learn\n(well) and use. I later moved onto working on traditional web frontends in\nJavaScript (anyone remember Backbone.js?) and backend development with\nNode.js.\n\nThe things I disliked most were function-scoped variables, caller context,\ncallback hell, and writing \u201cfunction() function() function()...\u201d\n(everywhere!). All of these things combined made it frustrating to not only\nwrite JavaScript code, but to read as well.\n\n### Function vs. block scoped variables\n\nThe let and const keywords have all but completely replaced var for defining\nvariables. Aside from the obvious benefit of knowing whether a variable is\nmutable or not, a lesser-known benefit is that variables defined with let and\nconst are block-scoped as opposed to function-scoped (var), which helps\nprevent a lot of subtle bugs from creeping into your code.\n\nWe used to have to fake it with self-executing anonymous functions:\n\n    \n    \n    function example() { // without block-scoping: for (var i = 0; i < list.length; i += 1) { var x = list[i]; // x looks like it is block-scoped but it's NOT! } // although defined in the loop's block above, // x is accessible anywhere in the function console.log(x); console.log(i); // the iterator is also available here // block scoping could be \"faked\" with a // self-executing anonymous function: for (i = 0; i < list.length; i += 1) { (function() { var y = list[i]; // y is only accessible within this function })(); } }\n\nThe second loop where block-scope is \u201cfaked\u201d works, but it\u2019s much less\nreadable and more error-prone than true block-scoping (more on this a little\nfurther). JavaScript codebases were littered with stuff like this all over the\nplace to work around the quirks of the language.\n\n### Function context (this)\n\nThese days, if you\u2019re using the this keyword, you\u2019re likely writing code for a\nclass method referencing the current instance (similar to other object-\noriented languages). In the previous era of JavaScript, you had to be keenly\naware of a thing called \u201cfunction context\u201d (also referred to as \u201cthis\u201d\ncontext) and what this refers to could differ based on how the function is\ncalled.\n\nI wouldn\u2019t be surprised if JavaScript developers who learned the language\npost-ES6 are unaware of what function context is, because it\u2019s not as directly\nused as much as before.\n\nIn short, JavaScript has a \u201ccontext\u201d for each function call that is mapped to\nthe this keyword. Remember the previous code example where we defined an\nanonymous function that called itself? It would cause issues if we tried to\naccess the outer function\u2019s this keyword within that function:\n\n    \n    \n    function example() { console.log(\"1:\", this.someVar); // 1: \"hello\" (function() { console.log(\"2:\", this.someVar); // 2: undefined })(); } example.call({ someVar: \"hello\" });\n\nBecause each function has their own caller context, the inner function doesn\u2019t\ninherit the outer function\u2019s context so this doesn\u2019t refer to the same thing.\nYou would need to store the outer function\u2019s this value in a separate\nvariable, or use call() or apply() to explicitly set the inner function\u2019s\ncontext (thisArg).\n\nECMAScript 2015 (ES6) introduced \u201carrow functions\u201d, which on the surface looks\nlike a way to save us from having to type \u201cfunction\u201d all the time (and it\ndoes), but there\u2019s more to it than that. These arrow functions also inherit\nthe context from the parent scope at the time they are defined. So this\nexample works as you would expect:\n\n    \n    \n    function example() { console.log(\"1:\", this.someVar); // 1: \"hello\" (() => { console.log(\"2:\", this.someVar); // 2: \"hello\" })(); } example.call({ someVar: \"hello\" });\n\nI can\u2019t remember the last time I had to use call() or apply() in modern\nJavaScript codebases, or had to fix a bug because this wasn\u2019t what it appeared\nto be. But I remember a time when I had to be painfully aware of function\ncaller context at all times. If I never have to use call() and apply() ever\nagain, I\u2019d be okay with that.\n\n### Callback hell\n\nBefore promises and async/await were built-in, there was callback hell. If you\nhaven\u2019t had the pleasure of working with JavaScript in those days, consider\nyourself lucky. For example:\n\n    \n    \n    function getResults(callback) { makeFirstRequest(function(result1, err1) { if (err1) { callback(null, err1); return; } makeSecondRequest(function(result2, err2) { if (err2) { callback(null, err2); return; } makeThirdRequest(function(result3, err3) { if (err3) { callback(null, err3); return; } // return result via top-level callback argument callback({ result1: result1, result2: result2, result3: result3, }, null); }) }); }); } getResults(function(result, err) { if (err) { console.log(err.message); return; } console.log(\"Got results:\", results); });\n\nThe code above is just to illustrate the concept, so there\u2019s certainly cleaner\nways to write it, but no matter how much lipstick you put on that pig, it\u2019s\nstill painful to look at (let alone write).\n\nThe example calls a function (getResults()) that makes three requests,\ncombines the results and \u201creturns\u201d an object (or an error) via a callback\nfunction. This (or some variation of it) is how asynchronous code was handled\nin JavaScript, and is known as \u201ccallback hell\u201d because the labrynth of nested\ncallbacks (just imagine if each nested function was larger and more complex).\n\nContrast the above with how easy we have it today with promises and\nasync/await (along with object shorthand syntax and error handling):\n\n    \n    \n    async function getResults() { const result1 = await makeFirstRequest() const result1 = await makeSecondRequest(); const result3 = await makeThirdRequest(); return { result1, result2, result3, }; } try { const results = await getResults(); console.log(\"Got results:\", results); } catch (err) { console.log(err.message); }\n\nThe asynchronous nature of Node.js is where callback hell was really\nprevalent, but it was not uncommon to run into this on the frontend as well\n(ie. making network requests).\n\n### Towards the future\n\nAfter the big \u201cboost\u201d that JavaScript got with ECMAScript 2015 (ES6), there\nhave been continuous improvements to the language and it just keeps getting\nbetter. Because of the wide range of implementations, the use of transpilers\nhas become standard in the community, so we can all take advantage of the\nnewest JavaScript features on a per-project basis, without worrying (too much)\nabout what each individual JS engine supports.\n\nLater versions of JavaScript didn\u2019t remove any of the \u201cwarts\u201d that are often\nassociated with the language. You can still write code in exactly the same way\nas before (if you\u2019re a masochist), but newer features added better ways to\nwrite code that effectively make the old way of doing things obsolete\n(although there are still some oddities to be aware of). Combined with good\nlinting tools such as ESLint and (more recently) Biome.js, the JavaScript of\ntoday is almost unrecognizable from what it used to be.\n\nIn hindsight, it\u2019s actually pretty amazing how the language was able to evolve\nso much while maintaining near complete backwards compatibility with prior\nlanguage specs. There\u2019s still a lot of disdain for JavaScript in the wider\nprogramming community, but I think it\u2019s because people were scarred from the\nJavaScript of yesterday (and I don\u2019t blame them!). But I think if it were\njudged based on the language it is today, most people would see that it\u2019s\nactually pretty nice now.\n\nI\u2019ve since gone \u201call in\u201d on TypeScript, but as a superset, at the end of the\nday it\u2019s still \u201cjust JavaScript\u201d (with types). I personally wouldn\u2019t start a\nnew JavaScript project without it these days, but that\u2019s a topic for another\nday.\n\njonbeebe.net\n\nHello, I'm Jonathan Beebe. This is my space on the web where I share my work,\npublish writings, and link to random things I find interesting.\n\nRead about the new design in 2024 \u2192\n\n  * Home page\n\nthe most recent posts and links\n\n  * Back cover\n\nwhat is this website and who is its author?\n\n  * Posts archive\n\nlisting of all (non-link) posts on this site\n\n  * Shared links\n\narchive of links I've shared over time\n\n  * My projects\n\nvarious things I'm working on\n\n  * Reading list\n\nbooks I have read and recommend\n\n  * Mailing list\n\nthe newsletter, sent weekly\n\n  * Contact info\n\nquestions, comments? send me a message\n\n### Most recent posts\n\n  * At some point, JavaScript got good\n  * Prefix your user scripts for easy access\n  * From Linux back to the Mac\n  * jonbeebe.net in 2024 and beyond\n  * Understanding React Hooks and Dependencies\n  * Equality, object references, and conditions in JavaScript\n  * ESLint and Prettier configs for React\n  * Basic fuzzy matching function\n  * Managing multiple Node.js installs with nvm\n\n### Explore by topic\n\nai^2 blogging^2 configs^1 culture^1 feel-good^1 fonts^1 gaming^2 google^1\njavascript^5 linux^1 mac^1 node^1 react^2 reading^1 scripting^2 shell^1 tech-\nindustry^3 tips^1 tutorial^3 typescript^2 web^1 website^2 wildlife^1\n\n", "frontpage": true}
