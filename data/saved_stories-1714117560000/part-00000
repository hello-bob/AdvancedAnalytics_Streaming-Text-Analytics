{"aid": "40164047", "title": "With or Without Enums in TypeScript", "url": "https://blog.beraliv.dev/2022-09-10-with-or-without-enums", "domain": "beraliv.dev", "votes": 1, "user": "beraliv", "posted_at": "2024-04-25 22:50:59", "comments": 0, "source_title": "With or without enums in TypeScript", "source_text": "With or without enums in TypeScript | beraliv\n\nberaliv\n\n# With or without enums in TypeScript\n\n10 Sept 2022\n\n## What\n\nYou're uncertain whether you need to use enums or not. Here are some points\nthat make it easy to come to a conclusion.\n\n## Why use enums\n\n### No lookup objects for const enums\n\nValues of const enums are inlined and lookup objects aren't emitted to\nJavaScript.\n\nConst enums\n\n    \n    \n    1// typescript\n    \n    2const enum Answer {\n    \n    3 No = \"No\",\n    \n    4 Yes = \"Yes\",\n    \n    5}\n    \n    6\n    \n    7const yes = Answer.Yes;\n    \n    8const no = Answer.No;\n    \n    9\n    \n    10// javascript\n    \n    11const yes = \"Yes\"; /* Answer.Yes */\n    \n    12const no = \"No\"; /* Answer.No */\n\n\ud83c\udfdd Playground \u2013 https://tsplay.dev/m3Xg2W\n\nSee the difference in bundle size impact for enums and const enums\n\n### Refactoring\n\nGiven existing enum HttpMethod, when you want to replace existing value \"POST\"\nwith e.g. \"post\", you change enum's value and you're done!\n\nAs you use references in your codebase, HttpMethod.Post persists but only\nvalue is updated.\n\nEnum usage when we need to change value 'POST'\n\n    \n    \n    1enum HttpMethod {\n    \n    2 Get = \"GET\",\n    \n    3 Post = \"POST\",\n    \n    4}\n    \n    5\n    \n    6const method: HttpMethod = HttpMethod.Post;\n    \n    7// ^? 'POST'\n\nThis argument isn't very strong, because:\n\n  1. Values are rarely changed\n  2. It's not only possible solution (union types, object + as const)\n\n### Opaque-like type\n\nIf you're not familiar with Opaque types, it's a way to declare types of the\nsame structure, which are not assignable to each other.\n\nThe perfect example can be 2 currencies (e.g. USD and EUR). You cannot simply\nput dollars into euro account without taking into account currency exchange\nrate:\n\nOpaque type example\n\n    \n    \n    1declare const brand: unique symbol;\n    \n    2\n    \n    3type Brand<K, T> = K & { readonly [brand]: T };\n    \n    4\n    \n    5type USD = Brand<number, \"USD\">;\n    \n    6type EUR = Brand<number, \"EUR\">;\n    \n    7\n    \n    8let euroAccount = 0 as EUR;\n    \n    9let dollarAccount = 50 as USD;\n    \n    10\n    \n    11// Error: Type '\"USD\"' is not assignable to type '\"EUR\"'.\n    \n    12euroAccount = dollarAccount;\n\nString enums act like opaque types. It means that we can only assign values of\nthis enum, but not string literals.\n\nYou cannot use string literals as string enum value\n\n    \n    \n    1const enum VolumeStatus {\n    \n    2 AUDIBLE = \"AUDIBLE\",\n    \n    3 MUTED = \"MUTED\",\n    \n    4 FORCE_MUTED = \"FORCE_MUTED\",\n    \n    5}\n    \n    6\n    \n    7class Volume {\n    \n    8 public status: VolumeStatus = VolumeStatus.AUDIBLE;\n    \n    9}\n    \n    10\n    \n    11const volume = new Volume();\n    \n    12volume.status = VolumeStatus.AUDIBLE;\n    \n    13\n    \n    14// Error: Type '\"AUDIBLE\"' is not assignable to type 'VolumeStatus'.\n    \n    15volume.status = \"AUDIBLE\";\n\n\ud83c\udfdd Playground \u2013 https://tsplay.dev/W4xY4W\n\n## Why not use enums\n\n### Numeric enums are NOT type-safe (TypeScript below 5.0)\n\nGiven numeric enum and any variable of its type, TypeScript 4.9.5 and below\nallowed you to assign any number to it.\n\nTypeScript allow to assign any number to variable of numeric enum type for\nTypeScript 4.9.5 and below\n\n    \n    \n    1enum Output {\n    \n    2 Error = 1,\n    \n    3 Warning = 2,\n    \n    4 Log = 3,\n    \n    5}\n    \n    6\n    \n    7interface Options {\n    \n    8 output?: Output;\n    \n    9}\n    \n    10\n    \n    11const options: Options = {};\n    \n    12options.output = Output.Error;\n    \n    13options.output = Output.Warning;\n    \n    14options.output = Output.Log;\n    \n    15\n    \n    16// oops, but still safe\n    \n    17options.output = 3;\n    \n    18\n    \n    19// !!! OOPS !!! unsafe \ud83d\ude05\n    \n    20options.output = 4;\n    \n    21options.output = 5;\n\nPlease check the playground to test it for TypeScript 4.9.5 -\nhttps://www.typescriptlang.org/play?preserveConstEnums=true&ts=4.9.5#code/KYOwrgtgBA8mAuAHBUDeAoKWoFEBOeA9nlALxQCMANJtgOoCGeIAliAOZlQBMN2UAGUKdyAZhoBfdOjbxgeAGYMAxsFiJ4LQiADOaWlkIJk8APwAuWMYQBudFPTLtO+FEIatuyzA-\nOuqCTt3TWcAOiMkFHI4SPhQ-\nCI8IN9dcOtXaPTQxmY2dmSQ1IiTLhiTUKF86QB6ard3HSooACMUFxYAGw6oHQYFYHRgzx002K5RO3RaqABCOdgYAAUAZVn5sF0+tUBeDcBQPcGUkeKoqAAWAuHRkvIAVhsgA\n\ud83c\udfdd\ufe0f\n\nBeginning with TypeScript 5.0, this issue has been resolved and addressed within the release, eliminating it as a concern going forward. For more details, please read TypeScript 5.0 Release | Enum Overhaul.\n\nPlayground for latest TypeScript - https://tsplay.dev/wXgg9W \ud83c\udfdd\ufe0f\n\n### Enum is NOT just a type feature added\n\nTypeScript is supposed to be JavaScript, but with static type features added.\n\nIf we remove all of the types from TypeScript code, what's left should be\nvalid JavaScript code.\n\nThe formal word used in the TypeScript documentation is \"type-level\nextension\":\n\n> Most TypeScript features are type-level extensions to JavaScript, and they\n> don't affect the code's runtime behaviour.\n\nGiven function add in TypeScript:\n\nTypeScript example\n\n    \n    \n    1function add(x: number, y: number): number {\n    \n    2 return x + y;\n    \n    3}\n    \n    4\n    \n    5add(1, 2); // Evaluates to 3\n\nBy removing types, it becomes valid JS code:\n\nSame example but in JavaScript\n\n    \n    \n    1function add(x, y) {\n    \n    2 return x + y;\n    \n    3}\n    \n    4\n    \n    5add(1, 2); // Evaluates to 3\n\nUnfortunately, enums break this rule (in comparison to classes which only add\ntype information on top of existing JS code) for now.\n\nYou can simply try to execute this code in the browser and you will get a\nsyntax error:\n\nEnum is reserved keyword but cannot be used now\n\n    \n    \n    1// Uncaught SyntaxError: Unexpected reserved word\n    \n    2enum Answer { No = 0, Yes = 1 }\n\nAt the moment of writing this blog post, proposal for ECMAScript enums was on\nstage 0.\n\n### Const enum + preserveConstEnums option === enum + potential pitfalls\n\nWhen you use const enums, their values are inlined and no lookup object is\nemitted to JavaScript.\n\nHowever, when you enable preserveConstEnums option in tsconfig.json, lookup\nobject is emitted.\n\nConst enums with enabled preserveConstEnums\n\n    \n    \n    1// typescript\n    \n    2const enum Answer {\n    \n    3 No = 0,\n    \n    4 Yes = \"Yes\",\n    \n    5}\n    \n    6\n    \n    7const yes = Answer.Yes;\n    \n    8const no = Answer.No;\n    \n    9\n    \n    10// javascript\n    \n    11var Answer;\n    \n    12(function (Answer) {\n    \n    13 Answer[(Answer[\"No\"] = 0)] = \"No\";\n    \n    14 Answer[\"Yes\"] = \"Yes\";\n    \n    15})(Answer || (Answer = {}));\n    \n    16\n    \n    17const yes = \"Yes\"; /* Answer.Yes */\n    \n    18const no = 0; /* Answer.No */\n\nIn addition, when you publish const enums or consume them from declaration\nfiles, you may face ambient const enums pitfalls.\n\n## Choose your solution\n\nLet's sum up what we just discussed in a table:\n\nApproach| Declaration| No lookup objects^1| Type-safe^2| Refactoring^3|\nOptimal^4| Type-only^5| Opaque-like^6  \n---|---|---|---|---|---|---|---  \nNumeric enums| enum Answer { No = 0, Yes = 1 }| \u274c| \u2705\u26a0\ufe0f| \u2705| \u274c| \u274c| \u274c  \nString enums| enum Answer { No = 'No', Yes = 'Yes' }| \u274c| \u2705| \u2705| \u274c| \u274c| \u2705  \nHeterogeneous enums| enum Answer { No = 0, Yes = 'Yes' }| \u274c| \u2705\u26a0\ufe0f| \u2705| \u274c| \u274c| \u274c  \nNumeric const enums| const enum Answer { No = 0, Yes = 1 }| \u2705| \u2705\u26a0\ufe0f| \u2705| \u2705| \u274c| \u274c  \nString const enums| const enum Answer { No = 'No', Yes = 'Yes' }| \u2705| \u2705| \u2705| \u2705|\n\u274c| \u2705  \nHeterogeneous const enums| const enum Answer { No = 0, Yes = 'Yes' }| \u2705| \u2705\u26a0\ufe0f|\n\u2705| \u2705| \u274c| \u274c  \nObject + as const| const ANSWER = { No: 0, Yes: \"Yes\" } as const| \u274c| \u2705| \u2705| \u2705|\n\u274c| \u274c  \nUnion types| type Answer = 0 | 'Yes'| \u2705| \u2705| \u274c| \u2705| \u2705| \u274c  \n  \n  1. Union types are type-only feature so no JS code is emitted. Const enums inline their values and don't emit lookup objects. Other solutions, i.e. object + as const and normal enums, emit lookup objects.\n\n  2. As mentioned above, all numeric enums (whether normal, heterogeneous or const) are type-safe starting with TypeScript 5.0 onwards. But if TypeScript in your project is 4.9.5 or below, any numeric enums won't be type-safe as you can assign any number to the variable of its type.\n\n  3. Only union type lacks refactoring. It means that if you need to update value in a codebase, you will require to run type check over your codebase and fix all type errors. Enums and objects encapsulate it by saving lookup object.\n\n  4. To be able to compare approaches between each other, please have a look at Bundle-size impact.\n\n  5. Only union types are type-only feature. Other solutions emit lookup objects or aren't just a type feature added.\n\n  6. We treat all string enums as opaque-like types. It means that only their values can be assigned to the variable of its type.\n\n## How to get rid of enums\n\nIf you decided to get rid of enums, here are my suggestions.\n\n### Numeric enum => object + as const + Values\n\nWe can use as const and expose JS objects the same way we do it with numeric\nenums but in a safe way.\n\nIt's also included in Enums - Objects vs. Enums | TypeScript Docs\n\nBefore:\n\nExample with numeric enums for TypeScript 4.9.5 or below\n\n    \n    \n    1enum Output {\n    \n    2 Error = 1,\n    \n    3 Warning = 2,\n    \n    4 Log = 3,\n    \n    5}\n    \n    6\n    \n    7interface Options {\n    \n    8 output?: Output;\n    \n    9}\n    \n    10\n    \n    11const options: Options = {};\n    \n    12options.output = Output.Error;\n    \n    13options.output = Output.Warning;\n    \n    14options.output = Output.Log;\n    \n    15\n    \n    16// oops, but still safe\n    \n    17options.output = 3;\n    \n    18\n    \n    19// safe starting with TypeScript 5.0 \ud83d\ude05\n    \n    20options.output = 4;\n    \n    21options.output = 5;\n\nAfter:\n\nSame example with object, as const and Values\n\n    \n    \n    1const OUTPUT = {\n    \n    2 Error: 1,\n    \n    3 Warning: 2,\n    \n    4 Log: 3,\n    \n    5} as const;\n    \n    6\n    \n    7type Values<Type> = Type[keyof Type];\n    \n    8\n    \n    9type TOutput = Values<typeof OUTPUT>;\n    \n    10\n    \n    11interface Options2 {\n    \n    12 output?: TOutput;\n    \n    13}\n    \n    14\n    \n    15const options2: Options2 = {};\n    \n    16options2.output = OUTPUT.Error;\n    \n    17options2.output = OUTPUT.Warning;\n    \n    18options2.output = OUTPUT.Log;\n    \n    19\n    \n    20// valid and safe\n    \n    21options2.output = 3;\n    \n    22\n    \n    23// invalid\n    \n    24options2.output = 4;\n    \n    25options2.output = 5;\n\n\ud83c\udfdd Together in Playground \u2013 https://tsplay.dev/wOXX6N\n\n### String const enum => union type + inlined string literals\n\nValues within string const enums are usually self-explanatory, so we can use\nunion types without losing readability.\n\nBundle size will be the same as same string literals are inlined when you use\nconst enum.\n\nBefore:\n\nExample with string const enum\n\n    \n    \n    1const enum OutputType {\n    \n    2 LOG = \"LOG\",\n    \n    3 WARNING = \"WARNING\",\n    \n    4 ERROR = \"ERROR\",\n    \n    5}\n    \n    6\n    \n    7type OutputEvent =\n    \n    8 | { type: OutputType.LOG; data: Record<string, unknown> }\n    \n    9 | { type: OutputType.WARNING; message: string }\n    \n    10 | { type: OutputType.ERROR; error: Error };\n    \n    11\n    \n    12const output = (event: OutputEvent): void => {\n    \n    13 console.log(event);\n    \n    14};\n    \n    15\n    \n    16output({ type: OutputType.LOG, data: {} });\n    \n    17output({ type: OutputType.WARNING, message: \"Reload app\" });\n    \n    18output({ type: OutputType.ERROR, error: new Error(\"Unexpected error\") });\n\nAfter:\n\nSame example with string literal types\n\n    \n    \n    1type OutputEvent2 =\n    \n    2 | { type: \"LOG\"; data: Record<string, unknown> }\n    \n    3 | { type: \"WARNING\"; message: string }\n    \n    4 | { type: \"ERROR\"; error: Error };\n    \n    5\n    \n    6const output2 = (event: OutputEvent2): void => {\n    \n    7 console.log(event);\n    \n    8};\n    \n    9\n    \n    10output2({ type: \"LOG\", data: {} });\n    \n    11output2({ type: \"WARNING\", message: \"Reload app\" });\n    \n    12output2({ type: \"ERROR\", error: new Error(\"Unexpected error\") });\n\nIf you need to keep values (i.e. \"LOG\" | \"WARNING\" | \"ERROR\") in a separate type, like OutputType previously in enum, you still can do it:\n\nInferring type from OutputEvent2\n\n    \n    \n    1type TOutput = OutputEvent2[\"type\"];\n    \n    2// ^? \"LOG\" | \"WARNING\" | \"ERROR\"\n\n\ud83c\udfdd Together in Playground \u2013 https://tsplay.dev/mM1klm\n\n### Numeric const enums => it depends\n\nValues within numeric const enums are usually unreadable (e.g. 0, 1).\n\nWhen a meaning doesn't make much sense, you can still use union type:\n\nUnion types\n\n    \n    \n    1type Digit = 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9;\n\nOtherwise, follow the approach with Numeric enum => object + as const +\nValues.\n\nIt will definitely increase your bundle size. But again, it will keep you code\ntype-safe by eliminating assignment of any number.\n\nTo compare the bundle size, please have a look at Bundle size impact\n\n## What about ambient enums\n\nApart from enums and const enums, there are ambient enums.\n\nIt's a way to describe the shape of existing enum types, e.g.:\n\nDeclaration of ambient enum\n\n    \n    \n    1declare enum Colour {\n    \n    2 Red = \"red\",\n    \n    3 Green = \"green\",\n    \n    4 Blue = \"blue\",\n    \n    5}\n\nUsually you can find them in declaration files, e.g. @prisma/client\n\n@prisma/client/runtime/index.d.ts\n\n    \n    \n    1declare enum IsolationLevel {\n    \n    2 ReadUncommitted = \"ReadUncommitted\",\n    \n    3 ReadCommitted = \"ReadCommitted\",\n    \n    4 RepeatableRead = \"RepeatableRead\",\n    \n    5 Snapshot = \"Snapshot\",\n    \n    6 Serializable = \"Serializable\",\n    \n    7}\n\nIt's still very unlikely that you use ambient enums directly in your codebase.\nI would recommend to avoid using them.\n\n### Ambient const enum pitfalls\n\nIf you DO use them, you probably already know that inlining enum values come\nwith subtle implication, here are some of them:\n\n  1. They are incompatible with isolatedModules option in tsconfig.json\n\n  2. If you export const enums and provide them as an API to other libraries, it can lead to surprising bugs, e.g. Const enums in the TS Compiler API can make depending on typescript difficult \ud83d\udc1e\n\n  3. Unresolvable imports for const enums used as values cause errors at runtime with importsNotUsedAsValues option in tsconfig.json set to \"preserve\"\n\nTypeScript advises to:\n\n> A. Do not use const enums at all. You can easily ban const enums with the\n> help of a linter. Obviously this avoids any issues with const enums, but\n> prevents your project from inlining its own enums. Unlike inlining enums\n> from other projects, inlining a project\u2019s own enums is not problematic and\n> has performance implications.\n\n> B. Do not publish ambient const enums, by deconstifying them with the help\n> of preserveConstEnums. This is the approach taken internally by the\n> TypeScript project itself. preserveConstEnums emits the same JavaScript for\n> const enums as plain enums. You can then safely strip the const modifier\n> from .d.ts files in a build step.\n\nRead more about const enum pitfalls.\n\n## Bundle size impact\n\nLet's first have a look at examples (I left only examples with heterogeneous\nvalues):\n\nEnums\n\n    \n    \n    1// typescript\n    \n    2enum Answer {\n    \n    3 No = 0,\n    \n    4 Yes = \"Yes\",\n    \n    5}\n    \n    6\n    \n    7const yes = Answer.Yes;\n    \n    8const no = Answer.No;\n    \n    9\n    \n    10// javascript\n    \n    11var Answer;\n    \n    12(function (Answer) {\n    \n    13 Answer[(Answer[\"No\"] = 0)] = \"No\";\n    \n    14 Answer[\"Yes\"] = \"Yes\";\n    \n    15})(Answer || (Answer = {}));\n    \n    16\n    \n    17const yes = Answer.Yes;\n    \n    18const no = Answer.No;\n\nConst enums\n\n    \n    \n    1// typescript\n    \n    2const enum Answer {\n    \n    3 No = 0,\n    \n    4 Yes = \"Yes\",\n    \n    5}\n    \n    6\n    \n    7const yes = Answer.Yes;\n    \n    8const no = Answer.No;\n    \n    9\n    \n    10// javascript\n    \n    11const yes = \"Yes\"; /* Answer.Yes */\n    \n    12const no = 0; /* Answer.No */\n\nConst enums with enabled preserveConstEnums\n\n    \n    \n    1// typescript\n    \n    2const enum Answer {\n    \n    3 No = 0,\n    \n    4 Yes = \"Yes\",\n    \n    5}\n    \n    6\n    \n    7const yes = Answer.Yes;\n    \n    8const no = Answer.No;\n    \n    9\n    \n    10// javascript\n    \n    11var Answer;\n    \n    12(function (Answer) {\n    \n    13 Answer[(Answer[\"No\"] = 0)] = \"No\";\n    \n    14 Answer[\"Yes\"] = \"Yes\";\n    \n    15})(Answer || (Answer = {}));\n    \n    16\n    \n    17const yes = \"Yes\"; /* Answer.Yes */\n    \n    18const no = 0; /* Answer.No */\n\nAmbient enums\n\n    \n    \n    1// typescript\n    \n    2declare enum Answer {\n    \n    3 No = 0,\n    \n    4 Yes = \"Yes\",\n    \n    5}\n    \n    6\n    \n    7const yes = Answer.Yes;\n    \n    8const no = Answer.No;\n    \n    9\n    \n    10// javascript\n    \n    11const yes = Answer.Yes;\n    \n    12const no = Answer.No;\n\nAmbient const enums\n\n    \n    \n    1// typescript\n    \n    2declare const enum Answer {\n    \n    3 No = 0,\n    \n    4 Yes = \"Yes\",\n    \n    5}\n    \n    6\n    \n    7const yes = Answer.Yes;\n    \n    8const no = Answer.No;\n    \n    9\n    \n    10// javascript\n    \n    11const yes = \"Yes\"; /* Answer.Yes */\n    \n    12const no = 0; /* Answer.No */\n\nObject + as const\n\n    \n    \n    1// typescript\n    \n    2const ANSWER = {\n    \n    3 No: 0,\n    \n    4 Yes: \"Yes\",\n    \n    5} as const;\n    \n    6\n    \n    7const yes = ANSWER.Yes;\n    \n    8const no = ANSWER.No;\n    \n    9\n    \n    10// javascript\n    \n    11const ANSWER = {\n    \n    12 No: 0,\n    \n    13 Yes: \"Yes\",\n    \n    14};\n    \n    15\n    \n    16const yes = ANSWER.Yes;\n    \n    17const no = ANSWER.No;\n\nUnion types\n\n    \n    \n    1// typescript\n    \n    2type Answer = 0 | \"Yes\";\n    \n    3\n    \n    4const yes: Answer = \"Yes\";\n    \n    5const no: Answer = 0;\n    \n    6\n    \n    7// javascript\n    \n    8const yes = \"Yes\";\n    \n    9const no = 0;\n\nGiven 3 different types of values (numeric, string and heterogeneous), let's\ncompare the bundle size (in bytes) of different solutions:\n\nApproach| Enum| Const enum| Const enum + preserveConstEnums| Object + as\nconst| Union type  \n---|---|---|---|---|---  \nNumeric values| 126| 44| 112| 80| 44  \nHeterogeneous values| 124| 48| 117| 83| 48  \nString values| 116| 49| 108| 83| 49  \n  \nWhen you need to keep a lookup object (enum, const enum + preserveConstEnums\nand object + as const), the optimal solution is always an object + as const.\n\nWhen you don't need a lookup object (const enum and union type), both const\nenum and union type are optimal.\n\nIf you're interested in comparison itself, please go to Github repo with-or-\nwithout-enums-bundle-size-impact \ud83d\udd17\n\n## Shout out\n\nThis article couldn't be that good without the help of:\n\n  * AleksandrSI\n  * Joe Previte\n  * bautistaaa\n  * Bishwajit Jha\n\nThank you mates, your feedback was really helpful! \ud83d\udc4f\n\n## Links \ud83d\udd17\n\n  1. How do the different enum variants work in TypeScript? | Stack Overflow\n\n  2. TS features to avoid | Execute Program\n\n  3. Numeric enums | TypeScript Docs\n\n  4. String enums | TypeScript Docs\n\n  5. Heterogeneous enums | TypeScript Docs\n\n  6. Const enums | TypeScript Docs\n\n  7. Const enum pitfalls | TypeScript Docs\n\n  8. Ambient enums | TypeScript Docs\n\n  9. Do you need ambient const enums or would a non-const enum work | TypeScript Issue comment\n\n  10. JavaScript reserved keywords\n\n  11. Proposal for ECMAScript enums | GitHub\n\n  12. with-or-without-enums-bundle-size-impact | GitHub\n\ntypescript\n\n## Comments\n\nWritten by Alexey Berezin who loves London \ud83c\udff4, players \u23ef and TypeScript \ud83e\uddba\nFollow me on Twitter\n\n### Let's chat and have fun \ud83e\uddd1\ud83d\udcbb\ud83d\udc69\ud83d\udcbb\n\nNo more often than once a week I write \ud83d\udcc4 about TypeScript \ud83e\uddba, video playback \ud83d\udcfa\nand frontend related topics. You can unsubscribe in any time \u2198\ufe0f\n\nNot Playing\n\n\u00a9 2024, Powered by\n\n", "frontpage": false}
