{"aid": "40258048", "title": "A Guide on GraphQL Authorization", "url": "https://gebna.gg/blog/a-guide-on-graphql-authorization", "domain": "gebna.gg", "votes": 2, "user": "gebna", "posted_at": "2024-05-04 14:44:11", "comments": 0, "source_title": "A Guide on GraphQL Authorization", "source_text": "A Guide on GraphQL Authorization\n\ngebna.gg contact me rss\n\n# A Guide on GraphQL Authorization\n\n#### Written by Bahaa Zidan\n\n#### 2022-09-16\n\nThe GraphQL spec is very open-ended. It leaves many concerns to be implemented\nby programmers as they see fit. Among the concerns that are not strictly\noutlined in the spec are Authentication and Authorization. In this article,\nI\u2019ll walk you through one possible approach to building a great authorization\nframework for use in your GraphQL API.\n\nI\u2019ll assume that the reader already have a basic understanding of backend\ndevelopment in general and have built at least basic GraphQL APIs before. If\nyou haven\u2019t, please take a quick look at the official graphql tutorial.\n\n## Authentication\n\nBefore we get into authorization, let\u2019s have a super basic authentication\nsetup in our GraphQL server. We won\u2019t get into the login/signup flows. But we\nshould at the very least have a way to identify who exactly is using our\nGraphQL API.\n\n    \n    \n    const server = new ApolloServer({ schema, // ... context: ({ req }) => { return { authenticatedUser: getAuthenticatedUser(req), // ... } }, plugins: [ //... ], })\n\nHere we\u2019re using apollo-server. The same can be implemented using any other\nspec-compliant graphql server. Implementing getAuthenticatedUser function is\nbeyond the scope of this article. But no matter how it\u2019s implemented. It\nshould return a Promise of a user object. That way, queries won\u2019t have to be\nblocked on authenticated user unless it is necessary.\n\n## Possible Approaches\n\nNow when it comes to authorization, there are many approaches out there. Most\nof them can be boiled down to these 3:\n\n### Imperative Approach\n\nThe simplest way to start implementing authorization is to have your\nauthorization checks write there in the resolver code. Let\u2019s run with an\nexample of a graphql mutation called editArticle.\n\n    \n    \n    export const postResolvers = { Query: { // ... }, Mutation: { editArticle: async (_parent, args, context) => { const authenticatedUser = await context.authenticatedUser // Check if a user is logged in if (!authenticatedUser) throw new Error('User must be authenticated!') // Check if a user is authorized to perform this action // i.e. check if the user is the author of the article const post = await context.repos.post.findOne(args.post.id) if (authenticatedUser.id !== post.author.id) { throw new Error('User must be the author of the post!') } // Otherwise we proceed with the main resolver code. // Note: `context.repo` is just an abstraction layer that maps to a data source. return context.repos.post.editAritcle(args) }, }, }\n\nThis approach is fine for toy projects. But it becomes a hell to maintain very\nquickly if you\u2019re building something serious. Imagine you want to add more\nauth checks. Maybe implement banning features. Imagine a change of auth policy\nis required to be implemented system-wide, you\u2019d have to go and read the\nresolver code for every single query and mutation you have in your API. It\ndoesn\u2019t scale with the size and/or complexity of your application.\n\n### Middleware\n\nA much better approach is using middlewares. Continuing with our editArticle\nexample, let\u2019s see how can this approach be better. I\u2019m gonna be using\ngraphql-shield for these examples. But the same can be achieved using any\nmiddleware library.\n\nWe first start by defining our rules. These are functions that return a\nboolean. If true, execution will continue.\n\n    \n    \n    const isAuthenticated = rule({ cache: 'contextual' })(async (_parent, _args, context) => { const authenticatedUser = await context.authenticatedUser return authenticatedUser !== null }) const isArticleAuthor = rule({ cache: 'contextual' })(async (_parent, args, context) => { const authenticatedUser = await context.authenticatedUser const post = await context.repos.post.findOne(args.post.id) return authenticatedUser.id === post.author.id })\n\nThen we create the permissions map.\n\n    \n    \n    const permissions = shield({ Query: { // ... }, Mutation: { editArticle: and(isAuthenticated, isArticleAuthor), }, })\n\nThen we use applyMiddleware from the graphql-middleware package to apply these\nrules to our schema.\n\n    \n    \n    const schema = applyMiddleware(makeSchema(typeDefs, resolvers), permissions)\n\nAnd since we\u2019ve externalized all our auth checks into their own functions and\nmiddlewares, we can delete all these imperative checks from our resolver code.\n\n    \n    \n    export const resolvers = { Query: { // ... }, Mutation: { editArticle: async (_parent, args, context) => { return context.repos.post.editAritcle(args) }, }, }\n\nNow we have a clean resolver code that acts as a routing layer that maps our\noperation to a data source. This approach is already a massive improvement\nover the imperative approach. But while decoupling authorization code from the\nresolver implementation led a much leaner code and allowed for reusing auth\nrules, it also introduced a major flaw. Now we\u2019re developing our authorization\nin a vacuum and then attaching it to our api implementation. We\u2019re now\ntreating authorization as if it\u2019s a concern separate from our API and that can\nlead to poor readability down the line. That\u2019s where our next approach comes\nto the rescue.\n\n### The Auth Directive\n\nDirectives are a great tool to dynamically change the behaviour or even shape\nof your schema. Let\u2019s see how we can use them to create a powerful\nauthorization framework while still being very simple to implement.\n\nContinuing with our editArticle mutation example, assume that this is the\nschema we have:\n\n    \n    \n    type Post { id: ID! title: String! content: String! } extend type Mutation { editArticle(title: String!, postId: ID!, content: String!): Post }\n\nAs of now, this schema only defines the types our GraphQL API exposes, our\nimplementation is in the resolvers, and our authorization is defined using\nmiddlewares somewhere completely separate in code. Using Directives we can\ndefine our authorization rules right there in the schema itself. And instead\nof middlewares, we\u2019re going to make a declarative authorization framework\nusing directives.\n\nTo create a directive we need to define its\u2019 types in our schema: First we\ndefine an enum called Scope this enum is going to hold all the possible scopes\nthat we\u2019re going to check against. Here we define one scope called\nwrite_article that represents having write access to an article.\n\n    \n    \n    enum Scope { write_article # ... }\n\nThen we define our directive. Its\u2019 name, arguments, and what kind of objects\ncan this directive be applied to. For now this directive can be applied to\nobjects and field definitions in our graphql schema. For more information\nabout the directive syntax, consult the graphql-tools documentation.\n\n    \n    \n    directive @requireAuth(scopes: [Scope!]) on OBJECT | FIELD_DEFINITION\n\nNow let\u2019s provide an implementation of this directive. The current directives\nAPI provided by graphql-tools is very simple to understand but a bit gnarly to\nimplement :D. All we\u2019re actually doing is we\u2019re making a transformation\nfunction that takes in an executable schema and returns an executable schema\nthat is slightly modified.\n\n    \n    \n    import { mapSchema, MapperKind, getDirective } from '@graphql-tools/utils' import { defaultFieldResolver } from 'graphql' export const requireAuthDirectiveTransformer = (schema) => { const directiveName = 'requireAuth' return mapSchema(schema, { [MapperKind.OBJECT_FIELD]: (fieldConfig) => { const directive = getDirective(schema, fieldConfig, directiveName)?.[0] if (!directive) return const { resolve = defaultFieldResolver } = fieldConfig fieldConfig.resolve = async function ( source, // this is the query/mutation arguments. args: any, context: Context, info ) { // AUTH CHECKS WILL GO HERE const result = await resolve(source, args, context, info) return result } return fieldConfig }, }) }\n\nIt may look like much, but all this code does is checking whether or not our\ndirective has been applied to a certain field. And if so, we\u2019re going to\nredefine the resolver of that field to run our authorization checks before we\nrun the original field resolver.\n\nNow let\u2019s add those checks:\n\n    \n    \n    export const requireAuthDirectiveTransformer = (schema) => { const directiveName = 'requireAuth' return mapSchema(schema, { [MapperKind.OBJECT_FIELD]: (fieldConfig) => { const directive = getDirective(schema, fieldConfig, directiveName)?.[0] if (!directive) return const { resolve = defaultFieldResolver } = fieldConfig fieldConfig.resolve = async function ( source, // this is the query/mutation arguments. args: any, context: Context, info ) { const authenticatedUser = await context.authenticatedUser if (!authenticatedUser) { throw new AuthenticationError('You must be authenticated!') } if (directive.scopes?.includes('write_article')) { const postId = args.post.id if (!postId) throw new UserInputError('Missing input: [post.id]') const post = await context.repos.post.findOne(postId) if (authenticatedUser.id !== post.author.id) { throw new UserInputError('User must be the author of the article!') } } // MORE SCOPES CAN GO HERE const result = await resolve(source, args, context, info) return result } return fieldConfig }, }) }\n\nAll that\u2019s left is to run the transformer function on our schema before we\nexport it:\n\n    \n    \n    const schema = requireAuthDirectiveTransformer(makeExecutableSchema(typeDefs, resolvers))\n\nFinally we can use the requireAuth directive anywhere in our schema.\n\n    \n    \n    extend type Mutation { editArticle(title: String!, postId: ID!, content: String!): Post @requireAuth(scopes: [write_post]) }\n\nWe can extend the directive by defining more scopes. We can also have one\nquery depend on multiple scopes at once by having the requireAuth directive\ntake an array of scopes as an argument.\n\nSo we get the same composability we had using middlewares. But now we define\nour authorizations declaratively within our schema without having to worry\nabout implementation or order of execution. Everything we need declared in one\nplace: the schema.\n\n## Conclusion\n\nAny of these approaches can work. It all depends on the size and complexity of\nyour project. If you\u2019re building a toy project then having imperative auth\nchecks right there in your resolvers might not be so bad. If you\u2019re building\nsomething serious, I invite you to consider either the middleware or the\ndirective approach. Personally, I tend to prefer the auth directive as it\nallows me to include all API concerns in the schema. I think of it the same\nway I think of css-in-js and JSX allowing frontend devs to include everything\na component needs in one place. In future articles, I\u2019ll show you how I use\ndirectives to handle data validation as well.\n\n# Thank you for reading!\n\n  * For any questions or comments, feel free to contact me\n  * Add my blog's rss to your feed\n  * Buy me a coffee\n\nYou're not obligated to do any of that. I wholeheartedly appreciate you taking\nthe time to read my work.\n\n\ud83c\udf49\n\n", "frontpage": false}
