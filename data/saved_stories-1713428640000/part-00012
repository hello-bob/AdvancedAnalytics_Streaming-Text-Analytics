{"aid": "40072166", "title": "Fastest Zero Allocation Golang LRU for key value pairs in []byte", "url": "https://github.com/cloudxaas/gocache/tree/main/lru/bytes", "domain": "github.com/cloudxaas", "votes": 3, "user": "cloudxaas", "posted_at": "2024-04-18 01:51:33", "comments": 0, "source_title": "gocache/lru/bytes at main \u00b7 cloudxaas/gocache", "source_text": "gocache/lru/bytes at main \u00b7 cloudxaas/gocache \u00b7 GitHub\n\nSkip to content\n\nSign in\n\n# Search code, repositories, users, issues, pull requests...\n\nSearch syntax tips\n\nSign in\n\nSign up\n\nYou signed in with another tab or window. Reload to refresh your session. You\nsigned out in another tab or window. Reload to refresh your session. You\nswitched accounts on another tab or window. Reload to refresh your session.\nDismiss alert\n\ncloudxaas / gocache Public\n\n  * Sponsor\n  * Notifications\n  * Fork 0\n  * Star 0\n\n/\n\n# bytes\n\n/\n\n## Directory actions\n\n## More options\n\n## Directory actions\n\n## More options\n\n## Latest commit\n\nkolinfluence\n\nUpdate README.md\n\nApr 18, 2024\n\na54ef6f \u00b7 Apr 18, 2024Apr 18, 2024\n\n## History\n\nHistory\n\n/\n\n# bytes\n\n/\n\n## Folders and files\n\nName| Name| Last commit message| Last commit date  \n---|---|---|---  \n  \n### parent directory\n\n..  \n  \n### README.md\n\n|\n\n### README.md\n\n| Update README.md| Apr 18, 2024  \n  \n### go.mod\n\n|\n\n### go.mod\n\n| Create go.mod| Apr 18, 2024  \n  \n### go.sum\n\n|\n\n### go.sum\n\n| Create go.sum| Apr 18, 2024  \n  \n### lrubytes.go\n\n|\n\n### lrubytes.go\n\n| Update lrubytes.go| Apr 18, 2024  \n  \n### lrubytes_sharded.go\n\n|\n\n### lrubytes_sharded.go\n\n| Update lrubytes_sharded.go| Apr 18, 2024  \n  \n### lrubytes_test.go\n\n|\n\n### lrubytes_test.go\n\n| Update lrubytes_test.go| Apr 18, 2024  \n  \n## README.md\n\n# cxlrubytes - Fastest Zero Allocation LRU Cache in Golang (for key, value\npairs in []byte)\n\nWelcome to the repository for the fastest LRU cache implementations available\nfor Go. This LRU cache is uniquely designed to limit the memory usage\ndirectly, rather than by the number of entries. This makes it ideal for\napplications where the memory footprint is critical, such as in embedded\nsystems or high-performance computing environments where resources are tightly\nmanaged.\n\n## Features\n\n  * Memory-Size Limited: Unlike other LRU caches that limit the number of entries, this cache controls the total memory used, allowing for better resource management in memory-constrained environments.\n  * High Performance: Designed with performance in mind, benchmarks demonstrate extremely low latency and zero allocations during operations, ensuring minimal impact on application throughput.\n  * Concurrency Safe: Implements synchronization to manage concurrent access, making it suitable for high-concurrency scenarios.\n\n## Benchmarks\n\nThe cache has been rigorously benchmarked on a system with the following\nspecifications:\n\n  * OS: Linux\n  * Architecture: AMD64\n  * CPU: AMD Ryzen 5 7640HS w/ Radeon 760M Graphics\n\nBenchmark results:\n\n    \n    \n    go test -bench=. -benchmem goos: linux goarch: amd64 pkg: github.com/cloudxaas/gocache/lru/bytes cpu: AMD Ryzen 5 7640HS w/ Radeon 760M Graphics BenchmarkPhusluLRUPut-12 60035966 17.91 ns/op 0 B/op 0 allocs/op BenchmarkPhusluLRUGet-12 70038372 16.98 ns/op 0 B/op 0 allocs/op BenchmarkPhusluLRUDelete-12 122154745 9.735 ns/op 0 B/op 0 allocs/op BenchmarkPut-12 79242625 15.46 ns/op 0 B/op 0 allocs/op BenchmarkGet-12 81756193 14.35 ns/op 0 B/op 0 allocs/op BenchmarkDelete-12 290940819 4.116 ns/op 0 B/op 0 allocs/op BenchmarkPutParallel-12 22028478 49.44 ns/op 0 B/op 0 allocs/op BenchmarkGetParallel-12 23141043 46.35 ns/op 0 B/op 0 allocs/op BenchmarkDeleteParallel-12 38440218 27.76 ns/op 0 B/op 0 allocs/op BenchmarkShardedPutParallel-12 44919225 24.89 ns/op 0 B/op 0 allocs/op BenchmarkShardedGetParallel-12 45716688 24.26 ns/op 0 B/op 0 allocs/op BenchmarkShardedDeleteParallel-12 180548754 6.693 ns/op 0 B/op 0 allocs/op PASS ok github.com/cloudxaas/gocache/lru/bytes 18.230s\n\nreference : https://github.com/phuslu/lru\n\nThese benchmarks illustrate the efficiency and speed of the cache, which is\ndesigned to operate with zero memory allocations during runtime operations,\ncontributing to its high performance.\n\n## Usage\n\nTo use this cache, include it in your Go project and create a cache instance\nspecifying the maximum memory it should use:\n\n    \n    \n    package main import ( cxlrubytes \"github.com/cloudxaas/gocache/lru/bytes\" \"fmt\" ) func main() { // Initialize a new LRU cache with a max memory limit of 10 MB cache := cxlrubytes.NewLRUCache(10 * 1024 * 1024) // Example of adding a value to the cache cache.Put([]byte(\"key1\"), []byte(\"value1\")) // Retrieve a value if value, found := cache.Get([]byte(\"key1\")); found { fmt.Println(\"Retrieved:\", string(value)) } // Delete a value cache.Delete([]byte(\"key1\")) }\n\n### Sharded version\n\nTheoretically should work better in high concurrency environment with multiple\ngoroutines. Use this option when you have a lot of cpu cores.\n\n    \n    \n    package main import ( cxlrubytes \"github.com/cloudxaas/gocache/lru/bytes\" \"fmt\" ) func main() { // Initialize a new sharded LRU cache with a total memory limit of 10 MB across 16 shards shardCount := uint8(16) totalMemory := int64(10 * 1024 * 1024) // 10 MB total memory for the cache cache := cxlrubytes.NewShardedCache(shardCount, totalMemory) // Example of adding and retrieving values cache.Put([]byte(\"key1\"), []byte(\"value1\")) if value, found := cache.Get([]byte(\"key1\")); found { fmt.Println(\"Retrieved:\", string(value)) } // Delete a value cache.Delete([]byte(\"key1\")) }\n\n## Footer\n\n\u00a9 2024 GitHub, Inc.\n\nYou can\u2019t perform that action at this time.\n\n", "frontpage": false}
