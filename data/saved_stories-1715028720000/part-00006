{"aid": "40272968", "title": "C23 Stdbit.h Quick Reference", "url": "https://www.corsix.org/content/stdbit-quick-reference", "domain": "corsix.org", "votes": 2, "user": "abhi9u", "posted_at": "2024-05-06 10:09:33", "comments": 0, "source_title": "C23 stdbit.h quick reference", "source_text": "C23 stdbit.h quick reference\n\n<\n\n# C23 stdbit.h quick reference\n\nPosted at corsix.org on May 6, 2024\n\nMacros| Implementation  \n---|---  \n#define __STDC_ENDIAN_LITTLE__| Some integer constant  \n#define __STDC_ENDIAN_BIG__| Some integer constant  \n#define __STDC_ENDIAN_NATIVE__| __STDC_ENDIAN_LITTLE__ or __STDC_ENDIAN_BIG__\n(\u2020)  \nRegular functions| Implementation  \nunsigned stdc_leading_zeros(T x)| lzcnt(x)  \nunsigned stdc_first_leading_one(T x)| x ? lzcnt(x) + 1 : 0  \nunsigned stdc_trailing_zeros(T x)| tzcnt(x)  \nunsigned stdc_first_trailing_one(T x)| x ? tzcnt(x) + 1 : 0  \nunsigned stdc_count_ones(T x)| popcnt(x)  \nbool stdc_has_single_bit(T x)| popcnt(x) == 1  \nunsigned stdc_bit_width(T x)| x ? floor(log2(x)) + 1 : 0  \nT stdc_bit_floor(T x)| x ? (T)1 << floor(log2(x)) : 0  \nT stdc_bit_ceil(T x)| x ? (T)1 << ceil(log2(x)) : 1 (\u2021)  \nInverted functions| Implementation  \nunsigned stdc_leading_ones(T x)| lzcnt((T)~x)  \nunsigned stdc_first_leading_zero(T x)| (T)~x ? lzcnt((T)~x) + 1 : 0  \nunsigned stdc_trailing_ones(T x)| tzcnt((T)~x)  \nunsigned stdc_first_trailing_zero(T x)| (T)~x ? tzcnt((T)~x) + 1 : 0  \nunsigned stdc_count_zeros(T x)| popcnt((T)~x)  \n  \n(\u2020) Or some third value if the execution environment is neither little endian\nnor big endian.\n\n(\u2021) Undefined if the << overflows or if the result does not fit in T.\n\nWhere:\n\n  * T denotes either unsigned char or unsigned short or unsigned int or unsigned long or unsigned long long. Each function taking T is type-generic, dispatching to one of these five variants. The individual variants are also available by appending a _uc or _us or _ui or _ul or _ull suffix to the function name. Implementations might also support uint128_t.\n  * lzcnt returns the number of leading zero bits. For an input of zero, this is sizeof(T) * CHAR_BIT.\n  * tzcnt returns the number of trailing zero bits. For an input of zero, this is sizeof(T) * CHAR_BIT.\n  * popcnt returns the number of set bits. For an input with all bits set, this is sizeof(T) * CHAR_BIT.\n  * log2(0) is undefined, log2 coincides with tzcnt for inputs that are powers of two, and otherwise log2 is strictly monotonic and returns a float.\n\nThe inverted functions can all be implemented by inverting the input and then\npassing it to one of the regular functions.\n\nThe stdc_first_leading_ functions are slightly slippery, and require a careful\nreading of the standard. For example, stdc_first_leading_one is defined as:\n\n> Returns the most significant index of the first 1 bit in value, plus 1. If\n> it is not found, this function returns 0.\n\nIn turn, most significant index has the following unintuitive definition:\n\n> The most significant index is the 0-based index counting from the most\n> significant bit, 0, to the least significant bit, w \u2212 1, where w is the\n> width of the type that is having its most significant index computed.\n\nThe initial patches for these functions in musl got this wrong, instead using\nthe more intuitive definition of most significant index.\n\n", "frontpage": false}
