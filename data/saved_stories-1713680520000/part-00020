{"aid": "40101116", "title": "HTTP Query Method", "url": "https://www.ietf.org/archive/id/draft-ietf-httpbis-safe-method-w-body-02.html", "domain": "ietf.org", "votes": 1, "user": "greatNespresso", "posted_at": "2024-04-20 21:21:30", "comments": 0, "source_title": "The HTTP QUERY Method", "source_text": "The HTTP QUERY Method\n\nInternet-Draft| The HTTP QUERY Method| November 2021  \n---|---|---  \nReschke, et al.| Expires 13 May 2022| [Page]  \n  \nWorkgroup:\n\n    HTTP\nPublished:\n\n    9 November 2021\nIntended Status:\n\n    Standards Track\nExpires:\n\n    13 May 2022\nAuthors:\n\n    \n\nJ. Reschke\n\ngreenbytes\n\nA. Malhotra\n\nJ.M. Snell\n\n# The HTTP QUERY Method\n\n## Abstract\n\nThis specification defines a new HTTP method, QUERY, as a safe, idempotent\nrequest method that can carry request content.\u00b6\n\n## Editorial Note\n\nThis note is to be removed before publishing as an RFC.\u00b6\n\nDiscussion of this draft takes place on the HTTP working group mailing list\n(ietf-http-wg@w3.org), which is archived at\nhttps://lists.w3.org/Archives/Public/ietf-http-wg/.\u00b6\n\nWorking Group information can be found at https://httpwg.org/; source code and\nissues list for this draft can be found at https://github.com/httpwg/http-\nextensions/labels/safe-method-w-body.\u00b6\n\nThe changes in this draft are summarized in Appendix A.2.\u00b6\n\n## Status of This Memo\n\nThis Internet-Draft is submitted in full conformance with the provisions of\nBCP 78 and BCP 79.\u00b6\n\nInternet-Drafts are working documents of the Internet Engineering Task Force\n(IETF). Note that other groups may also distribute working documents as\nInternet-Drafts. The list of current Internet-Drafts is at\nhttps://datatracker.ietf.org/drafts/current/.\u00b6\n\nInternet-Drafts are draft documents valid for a maximum of six months and may\nbe updated, replaced, or obsoleted by other documents at any time. It is\ninappropriate to use Internet-Drafts as reference material or to cite them\nother than as \"work in progress.\"\u00b6\n\nThis Internet-Draft will expire on 13 May 2022.\u00b6\n\n## Copyright Notice\n\nCopyright (c) 2021 IETF Trust and the persons identified as the document\nauthors. All rights reserved.\u00b6\n\nThis document is subject to BCP 78 and the IETF Trust's Legal Provisions\nRelating to IETF Documents (https://trustee.ietf.org/license-info) in effect\non the date of publication of this document. Please review these documents\ncarefully, as they describe your rights and restrictions with respect to this\ndocument. Code Components extracted from this document must include Simplified\nBSD License text as described in Section 4.e of the Trust Legal Provisions and\nare provided without warranty as described in the Simplified BSD License.\u00b6\n\n\u25b2\n\n## Table of Contents\n\n## 1\\. Introduction\n\nThis specification defines the HTTP QUERY request method as a means of making\na safe, idempotent request that contains content.\u00b6\n\nMost often, this is desirable when the data conveyed in a request is too\nvoluminous to be encoded into the request's URI. For example, while this is an\ncommon and interoperable query:\u00b6\n\n    \n    \n    GET /feed?q=foo&limit=10&sort=-published HTTP/1.1 Host: example.org\n\n\u00b6\n\nif the query parameters extend to several kilobytes or more of data it may not\nbe, because many implementations place limits on their size. Often these\nlimits are not known or discoverable ahead of time, because a request can pass\nthrough many uncoordinated systems. Additionally, expressing some data in the\ntarget URI is inefficient, because it needs to be encoded to be a valid URI.\u00b6\n\nEncoding query parameters directly into the request URI also effectively casts\nevery possible combination of query inputs as distinct resources. Depending on\nthe application, that may not be desirable.\u00b6\n\nAs an alternative to using GET, many implementations make use of the HTTP POST\nmethod to perform queries, as illustrated in the example below. In this case,\nthe input parameters to the search operation are passed along within the\nrequest payload as opposed to using the request URI.\u00b6\n\nA typical use of HTTP POST for requesting a search\u00b6\n\n    \n    \n    POST /feed HTTP/1.1 Host: example.org Content-Type: application/x-www-form-urlencoded q=foo&limit=10&sort=-published\n\n\u00b6\n\nThis variation, however, suffers from the same basic limitation as GET in that\nit is not readily apparent -- absent specific knowledge of the resource and\nserver to which the request is being sent -- that a safe, idempotent query is\nbeing performed.\u00b6\n\nThe QUERY method provides a solution that spans the gap between the use of GET\nand POST. As with POST, the input to the query operation is passed along\nwithin the payload of the request rather than as part of the request URI.\nUnlike POST, however, the method is explicitly safe and idempotent, allowing\nfunctions like caching and automatic retries to operate.\u00b6\n\nThe key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\",\n\"SHOULD NOT\", \"RECOMMENDED\", \"NOT RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this\ndocument are to be interpreted as described in BCP 14 [RFC2119] [RFC8174]\nwhen, and only when, they appear in all capitals, as shown here.\u00b6\n\n## 2\\. QUERY\n\nThe QUERY method is used to initiate a server-side query. Unlike the HTTP GET\nmethod, which requests that a server return a representation of the resource\nidentified by the target URI (as defined by Section 7.1 of [RFCHTTP]), the\nQUERY method is used to ask the server to perform a query operation (described\nby the request payload) over some set of data scoped to the effective request\nURI. The payload returned in response to a QUERY cannot be assumed to be a\nrepresentation of the resource identified by the effective request URI.\u00b6\n\nThe body payload of the request defines the query. Implementations MAY use a\nrequest body of any content type with the QUERY method, provided that it has\nappropriate query semantics.\u00b6\n\nQUERY requests are both safe and idempotent with regards to the resource\nidentified by the request URI. That is, QUERY requests do not alter the state\nof the targeted resource. However, while processing a QUERY request, a server\ncan be expected to allocate computing and memory resources or even create\nadditional HTTP resources through which the response can be retrieved.\u00b6\n\nA successful response to a QUERY request is expected to provide some\nindication as to the final disposition of the operation. For instance, a\nsuccessful query that yields no results can be represented by a 204 No Content\nresponse. If the response includes content, it is expected to describe the\nresults of the operation. In some cases, the server may choose to respond\nindirectly to the QUERY request by returning a 3xx Redirection with a Location\nheader field specifying an alternate Request URI from which the results can be\nretrieved using an HTTP GET request. Various non-normative examples of\nsuccessful QUERY responses are illustrated in Section 4.\u00b6\n\nThe semantics of the QUERY method change to a \"conditional QUERY\" if the\nrequest message includes an If-Modified-Since, If-Unmodified- Since, If-Match,\nIf-None-Match, or If-Range header field ([RFCHTTP], Section 13). A conditional\nQUERY requests that the query be performed only under the circumstances\ndescribed by the conditional header field(s). It is important to note,\nhowever, that such conditions are evaluated against the state of the target\nresource itself as opposed to the collected results of the search operation.\u00b6\n\n### 2.1. Caching\n\nThe response to a QUERY method is cacheable; a cache MAY use it to satisfy\nsubsequent QUERY requests as per Section 4 of [HTTP-CACHING]).\u00b6\n\nThe cache key for a query (see Section 2 of [HTTP-CACHING]) MUST incorporate\nthe request content. When doing so, caches SHOULD first normalize request\ncontent to remove semantically insignificant differences, thereby improving\ncache efficiency, by:\u00b6\n\n  * Removing content encoding(s)\u00b6\n  * Normalizing based upon knowledge of format conventions, as indicated by the any media type suffix in the request's Content-Type field (e.g., \"+json\")\u00b6\n  * Normalizing based upon knowledge of the semantics of the content itself, as indicated by the request's Content-Type field.\u00b6\n\nNote that any such normalization is performed solely for the purpose of\ngenerating a cache key; it does not change the request itself.\u00b6\n\n## 3\\. The \"Accept-Query\" Header Field\n\nThe \"Accept-Query\" response header field MAY be used by a server to directly\nsignal support for the QUERY method while identifying the specific query\nformat media type(s) that may be used.\u00b6\n\n    \n    \n    Accept-Query = 1#media-type\n\n\u00b6\n\nThe Accept-Query header field specifies a comma-separated listing of media\ntypes (with optional parameters) as defined by Section 8.3.1 of [RFCHTTP].\u00b6\n\nThe order of types listed by the Accept-Query header field is insignificant.\u00b6\n\n## 4\\. Examples\n\nThe non-normative examples in this section make use of a simple, hypothetical\nplain-text based query syntax based on SQL with results returned as comma-\nseparated values. This is done for illustration purposes only. Implementations\nare free to use any format they wish on both the request and response.\u00b6\n\n### 4.1. Simple QUERY with a Direct Response\n\nA simple query with a direct response:\u00b6\n\n    \n    \n    QUERY /contacts HTTP/1.1 Host: example.org Content-Type: example/query Accept: text/csv select surname, givenname, email limit 10\n\n\u00b6\n\nResponse:\u00b6\n\n    \n    \n    HTTP/1.1 200 OK Content-Type: text/csv surname, givenname, email Smith, John, john.smith@example.org Jones, Sally, sally.jones@example.com Dubois, Camille, camille.dubois@example.net\n\n\u00b6\n\n### 4.2. Simple QUERY with indirect response (303 See Other)\n\nA simple query with an Indirect Response (303 See Other):\u00b6\n\n    \n    \n    QUERY /contacts HTTP/1.1 Host: example.org Content-Type: example/query Accept: text/csv select surname, givenname, email limit 10\n\n\u00b6\n\nResponse:\u00b6\n\n    \n    \n    HTTP/1.1 303 See Other Location: http://example.org/contacts/query123\n\n\u00b6\n\nFetch Query Response:\u00b6\n\n    \n    \n    GET /contacts/query123 HTTP/1.1 Host: example.org\n\n\u00b6\n\nResponse:\u00b6\n\n    \n    \n    HTTP/1.1 200 OK Content-Type: text/csv surname, givenname, email Smith, John, john.smith@example.org Jones, Sally, sally.jones@example.com Dubois, Camille, camille.dubois@example.net\n\n\u00b6\n\n## 5\\. Security Considerations\n\nThe QUERY method is subject to the same general security considerations as all\nHTTP methods as described in [RFCHTTP].\u00b6\n\n## 6\\. IANA Considerations\n\nIANA is requested to add QUERY method in the permanent registry at\n<http://www.iana.org/assignments/http-methods> (see Section 16.1.1 of\n[RFCHTTP]).\u00b6\n\nTable 1Method Name| Safe| Idempotent| Specification  \n---|---|---|---  \nQUERY| Yes| Yes| Section 2  \n  \n## 7\\. Normative References\n\n[RFC2119]\n\n    Bradner, S., \"Key words for use in RFCs to Indicate Requirement Levels\", BCP 14, RFC 2119, DOI 10.17487/RFC2119, March 1997, <https://www.rfc-editor.org/info/rfc2119>.\n[RFC8174]\n\n    Leiba, B., \"Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words\", BCP 14, RFC 8174, DOI 10.17487/RFC8174, May 2017, <https://www.rfc-editor.org/info/rfc8174>.\n[RFCHTTP]\n\n    Fielding, R., Ed., Nottingham, M., Ed., and J. Reschke, Ed., \"HTTP Semantics\", Work in Progress, Internet-Draft, draft-ietf-httpbis-semantics-19, 10 September 2021, <https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-semantics-19>.\n[HTTP-CACHING]\n\n    Fielding, R., Ed., Nottingham, M., Ed., and J. Reschke, Ed., \"HTTP Semantics\", Work in Progress, Internet-Draft, draft-ietf-httpbis-cache-19, 10 September 2021, <https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-cache-19>.\n\n## Appendix A. Change Log\n\nThis section is to be removed before publishing as an RFC.\u00b6\n\n### A.1. Since draft-ietf-httpbis-safe-method-w-body-00\n\n  * Use \"example/query\" media type instead of undefined \"text/query\" (https://github.com/httpwg/http-extensions/issues/1450)\u00b6\n  * In Section 3, adjust the grammar to just define the field value (https://github.com/httpwg/http-extensions/issues/1470)\u00b6\n  * Update to latest HTTP core spec, and adjust terminology accordingly (https://github.com/httpwg/http-extensions/issues/1473)\u00b6\n  * Reference RFC 8174 and markup bcp14 terms (https://github.com/httpwg/http-extensions/issues/1497)\u00b6\n  * Update HTTP reference (https://github.com/httpwg/http-extensions/issues/1524)\u00b6\n  * Relax restriction of generic XML media type in request body (https://github.com/httpwg/http-extensions/issues/1535)\u00b6\n\n### A.2. Since draft-ietf-httpbis-safe-method-w-body-01\n\n  * Add minimal description of cacheability (https://github.com/httpwg/http-extensions/issues/1552)\u00b6\n  * Use \"QUERY\" as method name (https://github.com/httpwg/http-extensions/issues/1614)\u00b6\n  * Update HTTP reference (https://github.com/httpwg/http-extensions/issues/1669)\u00b6\n\n## Authors' Addresses\n\nJulian Reschke\n\ngreenbytes GmbH\n\nHafenweg 16\n\n48155 M\u00fcnster\n\nGermany\n\nEmail: julian.reschke@greenbytes.de\n\nURI: https://greenbytes.de/tech/webdav/\n\nAshok Malhotra\n\nEmail: malhotrasahib@gmail.com\n\nJames M Snell\n\nEmail: jasnell@gmail.com\n\n", "frontpage": false}
