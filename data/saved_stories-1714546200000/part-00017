{"aid": "40216706", "title": "Go Generics: Use Structs for Generic Arguments Lists", "url": "https://www.emoses.org/posts/reusable-patterns-in-go/", "domain": "emoses.org", "votes": 2, "user": "todsacerdoti", "posted_at": "2024-04-30 21:41:52", "comments": 0, "source_title": "Go Generics: Use Structs for Generic Arguments Lists", "source_text": "Go Generics: Use Structs for Generic Arguments Lists - Evan Moses\n\n# Evan Moses\n\nMy blog and projects\n\n# Go Generics: Use Structs for Generic Arguments Lists\n\n  * Apr 30, 2024\n  * Categories: blog\n  * #go , #programming , #patterns\n  * 8 minute read\n\n### TL;DR\n\n  * I wanted to build reusable code for a pattern in Go\n  * I had to fight the type system a bit but I won in the end\n  * We can pack argument lists into structs to make the pattern generic over different sets of arguments to functions\n  * Skip to the end of the post for spoilers\n\nI have a preference for functional-style programming. I tend to model\nalgorithms in my head as data and transforms of that data (versus, say,\nobjects with behaviors). When I see a pattern repeat itself in my code my\nfirst instinct is to reach for a higher-order function to abstract that\npattern.\n\nHowever, my day job is coding in Go. I have mixed feelings about the language\nand I\u2019m not gonna start a Go flame war here, but I don\u2019t think it\u2019s\ncontroversial to say that Go does not lend itself to functional patterns.\n\n## The pattern\n\nI implemented a new, faster algorithm with to make some security calculations\nfor our system; the details are unimportant, but if the result differed\nbetween the old code and my new algorithm, it would represent a serious\nproblem for our customers. To make sure my new algorithm worked correctly, my\nplan was to calculate it the new way and the old way, compare the two values,\nand return the old value, logging an error if there were differences. I added\ntwo feature flags: UseNewAlgorithmDark enabled the new calculation with\ncomparison and logging, and UseNewAlgorithmOnly stopped using the old\ncalculation and just returned the result of the new one.\n\nThere are actually a few different places in the code that would be using the\nnew code, and they did different calculations with it. So I now had multiple\nplaces in code that looked something like this:\n\n    \n    \n    func (c *Controller) GetImportantData( ctx context.Context, tenant *models.Tenant, userId string, filter *ImportantDataFilter, ) (*ImportantData, error) { useNewWay := c.HasFeature(ctx, tenant, features.UseNewAlgorithmDark) if useNewWay { newWayLaunched := c.HasFeature(ctx, tenant, features.UseNewAlgorithmOnly) newWayResult, err := c.getImportantDataNewWay(ctx, tenant, userId, filter) if err != nil { c.Log().Error(\"Error getting important data new way, falling back\") return c.getImportantDataOldWay(ctx, tenant, userId, filter) } // If the Launched flag is on, just return the new result if newWayLaunched { return newWayResult, nil } // otherwise get the result the old way... oldWayResult, err := c.getImportantDataOldWay(ctx, tenant, userId, filter) if err != nil { return nil, err } // ...and compare it against the result from the new way. if !dataIsEqual(newWayResult, oldWayResult) { // If there's a mismatch, log the error, but continue c.Log().Error(\"Mismatch between old way and new way for ImportantData\", zap.String(\"userId\", user_id), zap.Any(\"filter\", filter), ) } // and always return the old result. return oldWayResult, nil } return c.getImportantDataOldWay(ctx, tenant, userId, filter) }\n\nImportantly, not all the controller functions that used the launch feature\ntook the same sort of arguments. There was another that was almost identical,\nbut the signature looked like this:\n\n    \n    \n    func (c *Controller) GetDifferentData(ctx context.Context, tenant *models.Tenant, relatedThingId string) (*DifferentData, error) { ... }\n\n## The abstraction\n\nBeyond wanting to keep my code DRY, I wanted to codify the Dark Launch pattern\nso other folks on our team could reuse it. So I started with something like\nthis:\n\n    \n    \n    type DarkLaunch[T any] struct { OperationName string DarkFlag features.FeatureFlag LaunchFlag features.FeatureFlag NewWay func(context.Context, *models.Tenant) (T, error) OldWay func(context.Context, *models.Tenant) (T, error) Cmp func(T, T) bool Logger *zap.Logger //features.FeatureManager is an existing interface that has HasFeature FeatureManager features.FeatureManager } func (dl DarkLaunch[T]) Execute(ctx context.Context, tenant *models.Tenant) (T, error) { useNewWay := dl.FeatureManager.HasFeature(ctx, tenant, dl.DarkFlag) if useNewWay { newWayLaunched := dl.FeatureManager.HasFeature(ctx, tenant, dl.LaunchFlag) newWayResult, err := dl.NewWay(ctx, tenant) if err != nil { dl.Logger.Error(fmt.Sprintf(\"Error getting data new way for %s, falling back\", dl.OperationName)) return dl.OldWay(ctx, tenant) } if newWayLaunched { return newWayResult, nil } oldWayResult, err := dl.OldWay(ctx, tenant) if err != nil { var zero T return zero, err } if !dl.Cmp(newWayResult, oldWayResult) { dl.Logger.Error(fmt.Sprintf(\"Mismatch between old way and new way for %s\", dl.OperationName)) // Hmmm, I'm missing context data here for logging here, aren't I \ud83e\udd14 ) } return oldWayResult, nil } return c.OldWay(ctx, tenant) }\n\nAnd it could be consumed like so:\n\n    \n    \n    func (c *Controller) GetImportantData( ctx context.Context, tenant *models.Tenant, userId string, filter *ImportantDataFilter, ) (*ImportantData, error) { dl := DarkLaunch[*ImportantData]{ OperationName: \"GetImportantData\", DarkFlag: features.UseNewAlgorithmDark LaunchFlag: features.UseNewAlgorithmOnly NewWay: func(ctx context.Context, tenant *models.Tenant) (*ImportantData, error) { // close over extra arguments here return c.getImportantDataNewWay(ctx, tenant, userId, filter) } OldWay: func(ctx context.Context, tenant *models.Tenant) (*ImportantData, error) { // close over extra arguments here return c.getImportantDataOldWay(ctx, tenant, userId, filter) }, Cmp: dataIsEqual, Logger: c.Log(), FeatureManager: c.FeatureManager } return dl.Execute(ctx, tenant) }\n\nThis worked, but it was inelegant. For one thing, the only way to consume it\nis to make a fresh closure over the arguments each time you want to call it,\nwhich means you can\u2019t just define a DarkLaunch somewhere and reference it. You\nalso need to pass in related machinery (the logger and the feature manager).\nFinally, the generic Execute method doesn\u2019t have access to the arguments of\nthe NewWay/OldWay functions, so it can\u2019t log them if there are errors; we\u2019d\nprobably have to insert extra logging in the closures to log properly.\n\n### Go issues, and other languages\u2019 solutions\n\nThe problem is that DarkLaunch isn\u2019t generic over the arguments of the\nNewWay/OldWay functions. In more dynamic languages, you\u2019d be able to just\napply a function to an arbitrary set of arguments, for instance in Clojure:\n\n    \n    \n    (defn dark-launch [{:keys [get-feature dark-flag launch-flag old-way new-way cmp]} tenant & args] (if-not (get-feature dark-flag) (apply old-way tenant args) ;; This is the secret sauce (let [launched (get-feature launch-flag) new-way-result (apply new-way tenant args)] ;; Here it is again (if launched new-way-result (let [old-way-result (apply old-way tenant args)] ;; And here (when-not (cmp new-way-result old-way-result) (errorf \"Mismatch, args: %s\" args))) old-way-result))))) (def get-important-data-dl { :get-feature feature-getter :dark-flag :features/use-new-algorithm-dark :launch-flag :features/use-new-algorithm-only :old-way get-important-data-old-way :new-way get-important-data-new-way :cmp data-matches }) ;; It's tempting to fancier with macros and have something like defdarklaunch ;; but this is a simple port of the Go code and macros would be overcomplicated here anyway. (defn get-important-data [tenant userId filter] (dark-launch get-important-data-dl tenant userId filter))\n\nA language with a sophisticated type system can express the same idea but with\nstrong typing. I\u2019m sure it can be done in Haskell ^1, but I know enough\nTypeScript better, so taking advantage of variadic tuple types:\n\n    \n    \n    interface DarkLaunch<T, A extends any[]> { getFeature: (f: Feature) => boolean; darkFeature: Feature; launchFeature: Feature; oldWay: (ctx: Context, tenant: Tenant, ...args: [...A]) => T | undefined; newWay: (ctx: Context, tenant: Tenant, ...args: [...A]) => T | undefined; cmp: (a: T, b: T) => boolean; }\n\nThe TypeScript compiler will enforce that oldWay and newWay have the same\nnumber and type of arguments, which is what we want. And that gives us a clue\nto how we can solve this in Go.\n\n## A Go Solution\n\nWe don\u2019t have a anything like Variadic Tuple Types ^2 in Go, but we can\nexpress the idea of a set of types bundled together: it\u2019s a simple struct.\nThis requires re-writing the oldWay/newWay functions slightly to take their\narguments as a limited-use struct, but that\u2019s not really a big deal.\n\nThe other improvement I made was to bundle the \u201cauxiliary\u201d members of the\nstruct like the logger and the FeatureManager that are only used to actually\nexecute the code into an Executor interface. Controller already satisfied\nExecutor, so now we could bundle the whole thing into its own package. Here\u2019s\nthe final code:\n\n    \n    \n    package dark_launch type Executor interface { Log() *zap.Logger Features() features.FeatureManager } type DarkLaunch[T any, A any] struct { OperationName string DarkFlag features.FeatureFlag LaunchFlag features.FeatureFlag NewWay func(context.Context, *models.Tenant, A) (T, error) OldWay func(context.Context, *models.Tenant, A) (T, error) Cmp func(T, T) bool } func (dl DarkLaunch[T, A]) Execute( ctx context.Context, x Executor, tenant *models.Tenant, args A, ) (T, error) { useNewWay := x.Features().HasFeature(ctx, tenant, dl.DarkFlag) if useNewWay { newWayLaunched := x.Features().HasFeature(ctx, tenant, dl.LaunchFlag) newWayResult, err := dl.NewWay(ctx, tenant, args) if err != nil { x.Log().Error(fmt.Sprintf(\"Error getting data new way for %s, falling back\", dl.OperationName)) return dl.OldWay(ctx, tenant, args) } if newWayLaunched { return newWayResult, nil } oldWayResult, err := dl.OldWay(ctx, tenant, args) if err != nil { var zero T return zero, err } if !dl.Cmp(newWayResult, oldWayResult) { x.Log().Error(fmt.Sprintf(\"Mismatch between old way and new way for ImportantData\" zap.String(\"tenantId\", tenant.Id), zap.Any(\"args\", args), ) } return oldWayResult, nil } return dl.oldWay(ctx, tenant, args) } // ----- elsewhere ----- type importantDataArgs struct { userId string filter *ImportantDataFilter } func (c *Controller) GetImportantData( ctx context.Context, tenant *models.Tenant, userId string, filter *ImportantDataFilter, ) (*ImportantData, error) { // This could be defined outside this function without much extra work, but it would // only be a teensy efficiency gain and wouldn't add much readability. I'd do it if // the same args struct and getImporatantData* were re-used in a few different places. dl := DarkLaunch[*ImportantData, importantDataArgs]{ OperationName: \"GetImportantData\", DarkFlag: features.UseNewAlgorithmDark, LaunchFlag: features.UseNewAlgorithmOnly, NewWay: c.getImportantDataNewWay, OldWay: c.getImportantDataOldWay, Cmp: dataIsEqual, } return dl.Execute(ctx, c, tenant, importantDataArgs{userId: userId, filter: filter}) } // getImporantDataNewWay and getImportantDataOldWay must be re-written to take in the args struct func (c *Controller) getImportantDataNewWay( ctx context.Context, tenant *models.Tenant, args importantDataArgs, ) (*ImportantData, error) { ... } // GetDifferentData works the same, but since it only takes a single argument beyond the common args, // we don't even need a limited-use struct func (c *Controller) GetDifferentData(ctx context.Context, tenant *models.Tenant, relatedThingId string) (*DifferentData, error) { dl := DarkLaunch[*DifferentData, string]{ OperationName: \"GetDifferentData\", DarkFlag: features.UseNewAlgorithmDark, LaunchFlag: features.UseNewAlgorithmOnly, NewWay: c.getDifferentDataNewWay, OldWay: c.getDifferentDataOldWay, Cmp: dataIsEqual, } return dl.Execute(ctx, c, tenant, relatedThingId) }\n\nMuch prettier, huh? Go\u2019s type system isn\u2019t powerful enough to have a type\nargument that expresses an arbitrary-length but finite list of types as\nparameters to a function; however we can use a product type (aka a struct) to\nrepresent the finite list ^3.\n\n  1. I\u2019m not a Haskeller, suggestions welcome. Contact info in sidebar. \u21a9\ufe0e\n\n  2. That\u2019s fun to say \u21a9\ufe0e\n\n  3. My category theory knowledge comes almost exclusively from reading intro-to-Haskell blog posts linked from the orange site. Please be pedantic at me if I got my terminology wrong. \u21a9\ufe0e\n\n  * Emacs Tidbit: rectangle-number-lines\n\n  * ###### Rendered by Hugo | Subscribe\n\n", "frontpage": false}
