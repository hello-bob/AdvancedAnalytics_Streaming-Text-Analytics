{"aid": "40155811", "title": "BitVMX: A CPU for Universal Computation on Bitcoin", "url": "https://bitvmx.org/", "domain": "bitvmx.org", "votes": 1, "user": "wslh", "posted_at": "2024-04-25 10:47:07", "comments": 0, "source_title": "BitVMX", "source_text": "BitVMX\n\n# BitVMX: a CPU for Universal Computation on Bitcoin\n\nJoin our community\n\n#### BitVMX Builders\n\n## Secure, Extensible, Open-Source\n\nBitVMX is a new framework to optimistically execute arbitrary programs in\nBitcoin based on the N-party disputable computation paradigm pioneered by\nBitVM. BitVMX framework provides the foundations to run any CPU on Bitcoin,\nwith a focus to run a fully-compliant RISC-V processor programmable using a\nstandard compilation toolchain.\n\nOur vision is to create a secure, extensible, open-source, peer-reviewed and\nsidechain-agnostic framework that can be used to develop blockchain bridges,\naggregator oracles, and SNARK/STARK verifiers. As soon as BitVMX is able to\nrun a SNARK verifier, a myriad of new use cases can be brought to Bitcoin,\nfrom ZK-rollups to crazy use cases such as Zero Knowledge Contingent Payments\n(i.e. autonomous bug bounties paid for disclosure of vulnerabilities).\n\n## How Does BitVMX Work\n\nBitVMX represents a new form of covenant that does not require a soft or hard\nfork to Bitcoin. Funds can be locked in an UTXO with a spend condition that\ndepends on the result of the execution of a program. While the program must be\ndefined when the UTXO is created, the program input does not. In its simplest\nform, this is a two-party protocol where a first participant is the operator\nand the second is the verifier. First, both of them initially collaborate to\ncreate a small set of presigned transaction that guide the dispute resolution\nprotocol. Also both compute an initial deposit address. Funds sent to this\naddress will be governed by the predefined program. One of the precreated\ntransactions is the first kick-off transaction that signals the intention for\nthe prover to withdraw the funds. After the setup, the parties can lock funds\nand security deposits into the protocol and the funds can\u2019t be spent until the\nwithdrawal kick-off transaction is included in the blockchain.\n\nAt a later time, when the operator wants to withdraw the locked funds, she\nposts the kick-off transaction together with the input that makes the program\nhalt with an exit code that represents success. The input is always available\nto the verifier. The verifier watches the operator and executes the program\nlocally to check the correctness of the execution. If the verifier detects\ncheating, she will challenge the operator and both of them enter a Dispute\nResolution Protocol (DRP) on the Bitcoin blockchain (the DRP protocol is\nsometimes called the \u201cVerification Game\u201d) .\n\nn the DRP, the verifier becomes the challenger, se goal is to prove that the\noperator has cheated, and the operator becomes the responder (also known as\nprover), se goal is to respond to each challenger question, and prove he has\nnot cheated. All responses provided by the responder are signed, so that the\nchallenger can use the responder\u2019s responses in the further stages of the\nprotocol to prove cheating.\n\nThe DRP is as follows: both the responder and the challenger locally execute\nthe program associated with the UTXO with a predefined CPU and output the\nexecution trace. The trace is a list of steps until the CPU halts. Each step\nof the trace represents a step of the execution. For each step, the honest\nparties compute a step hash, which compresses the previous step hash, along\nwith the outputs of the current step, forming a cryptographically secure hash\nchain. The goal of the challenger in the DPR is to find a point in the trace\nwhere a \u201cmalfunction\u201d occurs. This is the point where the computation was\nbeing executed correctly until it was no longer. To find the malfunction, the\nchallenger will ask the prover to sign and publish different step hashes\nchosen by the challenger. To speed up the search, the challenger will use a\nn-ary dissection search.\n\nThe following simplified diagram shows how operator and verifier follow the\ntrace dissection search protocol:\n\nFormally, we define malfunction as a pair of consecutive steps such that the\nfist step has a correct step hash (which is signed by the responder), and the\nsecond step has an incorrect step hash (also signed by the responder). The\nmalfunction is defined from the point of view of the challenger. From the\npoint of view of the responder, there is no CPU fault: either she is cheating\nwhen providing the step hashes or she is providing the correct step hashes but\nthe challenger still wants to engage in the DPR for some unknown reason.\nHowever, BitVMX DPR is different from other dispute protocols. In TrueBit and\nBitVM CPU dispute protocols, a Merkle tree of all hash steps is used for the\nverifier to find the first point of malfunction. In BitVMX we don\u2019t use a tree\ndata structure and the verifier only finds a point of malfunction, which may\nnot be the first. However, the protocol gives enough information for the\nverifier to be able to prove that the operator has cheated in a number of\ncommunication rounds which is logarithmic to the number of executed steps.\n\nOnce the challenger knows the malfunctioning step, the next thing she must do\nto prove cheating is to learn what sub-operation within the step execution was\nfaulty. The CPU does multiple things in one step: it reads a number of words\nfrom memory, it reads the program counter (PC), it fetches the opcode, it\nperforms a computation and it writes back the results to one or more memory\nwords. Any of these sub-operations may be incorrect.\n\nProving an incorrect PC is as simple as comparing the PC in the incorrect step\nwith the PC written by the correct step immediately preceding it. Assuming\ncorrect input (the memory words, the PC and the opcode), proving an incorrect\ncomputation output is easy by executing the step onchain and comparing the\nonchain results with the results embedded in the responder\u2019s signed step\ntrace.\n\nProving an incorrect memory read takes a bit longer, because BitVMX does not\nmerkelize the memory, but nevertheless it\u2019s easy. Embedded in the trace, the\nresponder always includes the step number corresponding to the last trace step\nwhen the memory word read was written. The challenger learns this and requests\nthe trace step hash of that memory writing step. If the memory writing step\nhash is correct, the challenger can easily prove that the responder cheated,\nbecause the value written in the writing step must differ from the value read\nby the step reading the memory word. If the trace step hash is incorrect, then\nthe challenger has found an incorrect step followed by a correct one (remember\nthat originally the challenger found two consecutive steps, one correct and\nthe other incorrect). Therefore the challenger and the responder can engage in\na second step searching protocol on the trace, but this time the challenger\ntries to find a \u201crecovery\u201d, which is defined as a pair of steps where the\nfirst is incorrect, but the second is correct. Obviously such a miraculous\nrecovery is infeasible in practice, because it means that the prover found by\nchance two different hash chains that end with the same hash digest (the\ncorrect step hash). Therefore we assume the prover is cheating. Once the\nchallenger finds this new pair of consecutive steps, he can just challenge the\ncomputation of the hash function that links both step hashes.\n\nThe following diagram describes the two search processes, the first searching\nfrom the start of the trace to the last step (F), finding the malfunction step\n(q) referencing a last write step (t), then finding the recovery point (w):\n\nThe following flowchart represents the main challenger decision tree\n(simplified):\n\n## From Two-Party to N-Party\n\nThe BitVMX protocol can be easily described as a game of two parties, where\nthey initially collaborate to create the transaction templates that establish\na covenant DAG that guides the dispute process. Moving from two-party to\nN-party (N>2) is possible, but not straightforward, as there are multiple\ndesign decisions to make, as there can be collusion between parties. Should\nthere be one or multiple provers? Should all verifiers collaborate during the\ndispute or should each verifier proceed independently ? Should verifiers trust\non the other verifier\u2019s dispute process while it is conducted honestly or\nshould they aggressively challenge as fast as they can to avoid losing\nvaluable challenge time? If not a single UTXO but multiple UTXOs are\nencumbered by BitVMX covenants, then there are even more design choices to\nmake. Should security bonds be shared? Should operator withdrawals be rate\nlimited to prevent overloading the verifiers? During the course of our\nresearch, we plan to extend the 2-party protocol to multi-party and support\ndifferent staking and parallel dispute models.\n\nOne of the properties that is inextricable to BitVM and derived protocols is\nthat there is at least one transaction (the kick-off) which must be presigned\nby a set of parties (a committee), and if all those parties cheat, and later\ngenerate a different kick-off transaction, they can steal the funds. Since\nnobody can formally prove that she has destroyed a private key, users must\ntrust this commitee. The consequence is that BitVM and derived protocols have\na 1-of-N honesty assumption, where N is the size of the committee. This is\ntrue even if the DRP could be made permissionless and anyone could challenge.\n\n# How BitVMX Differs from BitVM\n\n## While BitVM is considered of theoretical interest, it\u2019s impractical for all\ninteresting use cases\n\n## Disputable Computation Paradigm\n\nBitVM was the first attempt to bring the Disputable Computation paradigm to\nBitcoin, it was conceived in Oct 2023 by Robin Linus. Under this paradigm, if\nall parties involved agree on the computation result, no computation is\nperformed onchain. In case any party disagrees, an onchain interaction begins\nto formally and efficiently solve the dispute: in the worst case, only a\nsingle disputed gate, wire or step of the computation is verified onchain.\n\nThe Disputable Computation paradigm was first envisioned by the TrueBit\nproject back in 2017 to be used for arbitration and later applied to the\ncreation of blockchain bridges. Due to its average low computing cost, the\nparadigm was chosen by Optimistic Rollups to build 2nd layers on altchains.\n\nThe closest protocol to BitVMX is BitVM, but BitVM does not refer to a single\nconcept, but four:\n\n  1. The BitVM Gate-based protocol (a.k.a. tapleaf circuits or \"BitVM0\"), partially defined in the BitVM white paper\n  2. The BitVM CPU design that was informally presented by Robin Linus in several talks and interviews (currently called BitVM1).\n  3. The partially implemented BitVM CPU, now deprecated, also authored by Robin Linus.\n  4. The BitVM2 single-challenge protocol, partially defined here.\n\nWe\u2019ll refer to the CPU when disambiguation is required. Since there is no full\nformal description of this BitVM CPU, we can only make our comparisons against\nthe straightforward design we reconstruct from Linus\u2019s interviews.\n\n## BitVMX vs BitVM (gate-based)\n\nThe BitVM gate-based protocol (BitVM0) is considered only of theoretical\ninterest, it\u2019s impractical for all interesting use cases, such as SNARK\nverification of running a sidechain light client. In contrast, BitVM CPU\n(a.k.a. BitVM1) and BitVMX are fully practical.\n\n## BitVMX vs BitVM CPU\n\nThe BitVMX CPU is similar to the BitVM CPU in that it searches through the\ntrace of the program execution. The \u201ccircuit\u201d of BitVM is replaced by the\ntrace of all instructions executed, where all loops are unrolled. However, the\nCPU protocols differ in the way information is exchanged, and instructions and\nmemory hashed. In contrast with the BitVM CPU, BitVMX does not require the\ncreation of a Merkle tree of instructions, nor a Merkle tree of memory words,\nnor even the use of the taproot tree! This makes BitVMX far more efficient to\nset up, and evaluate. BitVMX prover and verifiers build only a sequential hash\nchain that includes the outputs produced at each step plus each previous step\nhash. By using memory mapped registers, the output of any instruction consists\nof two words written to memory, one of them being the program counter. This\ninformation is enough to perform an n-ary search over the trace.\n\nTo avoid the need for memory merkelization, BitVMX uses a new\nchallenge/response protocol to detect memory access faults based on tracking\nthe last time each memory cell was written. Combined with shorter hash inputs,\nBitVMX linear hashing method enables the use of arbitrary amounts of memory\nand runs the virtual processor locally more than two times faster than the\nBitVM CPU.\n\nBitVMX construction is flexible enough to support the implementation of most\nof the existing CPUs, ranging from 8-bit to 64-bit cores. For example, it\u2019s\neasy and efficient to implement a MIPS core, or even a 64-bit RISC-V processor\nand run a Linux application on top of BitVMX. In contrast, BitVM CPU is\ndesigned for a single CPU type that is non-standard. RISC-V programs require\ntranslation to be run in the BitVM CPU. While BitVMX is flexible to run both\nRISC and CISC cores, RISC processors result in a simpler implementation. CISC\nprocessors may require longer scripts, increasing the challenge/response cost.\nImplementing a CISC processor on BitVMX would probably require the prover to\nshow intermediate results for microinstructions, and the verifier to challenge\nmicroinstructions instead of full instructions.\n\nBitVM CPU is designed to perform a binary search on the trace. This is an\ninherent limitation of BitVM CPU, as adding additional branches in the tree\nincreases the complexity of the design. The BLAKE3 hash function implemented\nin the BitVM CPU only hashes two 32-byte elements into one digest (a 2:1\ncompression). Adding more branches at each level of the tree requires some\ntricks. You can stack this 2:1 compression function multiple times (but you\nneed to allow the verifier to challenge the intermediate hashes) or you can\nexpand the size of the hash function input message. This last option is\nprohibitive due to the consequential expansion of the Bitcoin script.\nCurrently BLAKE3 2:1 compression consumes 100 Kbytes of script. A 4:1\ncompression would reach the standard transaction limit. An additional trick\n(also used by BitVM2) is to split BLAKE3 computation into sub-functions and\nlet the prover provide signed midstates for the verifier to choose which sub-\nfunction to challenge. This trick could reduce the script size 50%. However,\nall these tricks would make the BitVM CPU much more complex for limited\nbenefits. On the contrary, BitVMX allows a smooth tradeoff between worse case\nround complexity and the amount of data included in transactions by allowing\nthe free selection of the branch factor in the trace search. For example,\nusing a binary search over a 32-bit space trace BitVMX requires 70\ntransactions in the worst case, while BitVM requires 40. But using a 4-way\nsearch, we can reduce it to 36, outperforming BitVM CPU. Remarkably, we found\nan optimization to BitVMX to reduce the number of transactions to 20 using a\n16-way search (4 bits per query) without increasing the transaction payload\nassuming both prover and verifier act rationally during the dispute! This\nmeans that under approximately equally-sized payloads, the BitVMX worst case\nchallenge period would be half of BitVM\u2019s period. Increasing the number of\nhashes revealed in each iteration of the search we can reduce the number of\nrounds of the search. The impelmentators of BitVMX should choose thor sweep\nspot between challenge period and transaction cost.\n\n## BitVMX vs BitVM2\n\nWhile the BitVM CPU attempts to run any user-defined program, BitVM2 focuses\non running only a SNARK verifier, which in turn is capable of verifying the\ncorrect execution of longer programs. Instead of compiling the program\ndirectly to BitVM CPU or BitVMX, the BitVM2 protocol requires creating a SNARK\ncircuit to prove the execution of the program (setup), then proving the\nprogram execution for a particular input. Advanced ZK virtual machines such as\nZKVM can alleviate the task of writing the circuit, by leveraging on compilers\nthat accept procedural languages. Nevertheless, these rely on STARK provers,\nso that the SNARK verifier must verify the execution of a STARK verifier which\nin turn verifies the execution of the program. This technique has both\nbenefits and disadvantages. For complex programs, such as sidechain withdrawal\nverifications, there are several benefits of running a SNARK verifier. If the\ninput is long, and there is no need to make the input publicly available, then\nthe SNARK circuit can accept the input as a private witness. BitVMX requires\nall inputs to be public and signed (data availability of the input can be\nproven instead, but it\u2019s costly, and also requires the use of SNARKs). The\nsecond benefit is program size: with recursive SNARKs, the verifier trace is\nconstant size, and does not depend on the length of the computation. The\ndrawback of using SNARKs or SNARKs+STARKS is the complexity (amount of code\ninvolved) and attack surface. All the compilers, provers and verifiers may\ncontain bugs. Therefore executing a SNARK is riskier.\n\nSince BitVMX can also run a SNARK verifier, for complex programs the questions\ncomes down to which SNARK verifier (BitVMX or BitVM2) is better in terms of\nround complexity and transaction cost. With the information available today on\nBitVM2, it\u2019s seems that BitVM2 requires fewer onchain rounds, but parties must\npay a higer transaction cost.\n\nUsing the limited data available regarding BitVM, we extrapolate it to show a\ncomparison of each protocol executing a dispute over a SNARK verification.\nRound and transaction cost represent worse cases. Preprocessing time is based\non a single thread process running on a standard laptop.\n\nProtocol| Preprocessing Time| Storage| Rounds| Transaction virtual bytes  \n---|---|---|---|---  \nBitVM (gate-based)| Weeks| Terabytes| ~ 50| ~ 6 Megabytes  \nBitVM CPU| Days| Gigabytes| ~ 40| ~150 Kilobytes  \nBitVM2| Minutes| Megabytes| 2| ~ Tens of Megabytes  \nBitVMX (*)| Milliseconds| Kilobytes| ~ 40| ~80 Kilobytes  \n  \n(1) For the comparison we use a BitVMX protocol using 4-way search, the BLAKE3\nhashing function split into 8 challengeable sub-functions.\n\n# Who we are\n\nWe are a group of researchers (some independent and some sponsored by\ncompanies) that are openly collaborating to achieve the first production-ready\nimplementation of the BitVMX framework and the BitVMX RISC-V processor. Our\nobjective is to fully pass RISC-V official test suite, and be able to run any\nRISC-V program (even Linux!) on Bitcoin. Anyone is invited to collaborate in\nboth technical and project development areas.\n\n# The Team\n\nCurrently the team is composed of members of both Rootstock Labs and Fairgate\nLabs. The main sponsor is Rootstock Labs and the project is maintained by\nFairgate Labs.\n\n# Roadmap\n\nCurrently different companies and individuals have committed resources to\ndevelop BitVMX over the course of 2024. The people participating are both\nresearchers and coders. We can therefore present a roadmap to release a\nworking system during 2024. However, the roadmap is tentative, as the BitVM\ncommunity may find improvements that lead to a better design.\n\n# Resources\n\n\u00b7 BitVMX Repository \u00b7 Linked Messages Paper (coming soon!) \u00b7 BitVMX Paper\n(coming soon!) \u00b7 Telegram Channel\n\n# Acknowledgements\n\nBitVM was invented by Robin Linus and his work has inspired our research.\nRootstockLabs is the main sponsor of the BitVMX project. Fairgate Labs is\ncommitted long term to the BitVMX project. It will be providing a neutral\nrepository open to collaboration, project management, testing environment, QA,\na community roadmap, events and grants to build a community around BitVMX.\n\nThe BitVMX project is not and will not be affiliated with any token sale.\n\n## Join our community\n\n#### BitVMX Builders\n\nIntro Who We Are Resources Team\n\nlegal\n\n", "frontpage": false}
