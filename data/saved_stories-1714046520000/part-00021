{"aid": "40153664", "title": "Closure", "url": "https://en.wikipedia.org/wiki/Closure_(computer_programming)", "domain": "wikipedia.org", "votes": 2, "user": "behnamoh", "posted_at": "2024-04-25 05:07:21", "comments": 0, "source_title": "Closure (computer programming)", "source_text": "Closure (computer programming) - Wikipedia\n\nJump to content\n\nSearch\n\n# Closure (computer programming)\n\n  * \u0411\u044a\u043b\u0433\u0430\u0440\u0441\u043a\u0438\n  * Deutsch\n  * Eesti\n  * \u0395\u03bb\u03bb\u03b7\u03bd\u03b9\u03ba\u03ac\n  * Espa\u00f1ol\n  * \u0641\u0627\u0631\u0633\u06cc\n  * Fran\u00e7ais\n  * \ud55c\uad6d\uc5b4\n  * Italiano\n  * \u05e2\u05d1\u05e8\u05d9\u05ea\n  * Nederlands\n  * \u65e5\u672c\u8a9e\n  * Polski\n  * Portugu\u00eas\n  * \u0420\u0443\u0441\u0441\u043a\u0438\u0439\n  * Simple English\n  * \u0421\u0440\u043f\u0441\u043a\u0438 / srpski\n  * Suomi\n  * \u0ba4\u0bae\u0bbf\u0bb4\u0bcd\n  * \u0e44\u0e17\u0e22\n  * \u0423\u043a\u0440\u0430\u0457\u043d\u0441\u044c\u043a\u0430\n  * Ti\u1ebfng Vi\u1ec7t\n  * \u4e2d\u6587\n\nEdit links\n\nFrom Wikipedia, the free encyclopedia\n\nTechnique for creating lexically scoped first class functions\n\nFor other uses, see Closure (mathematics) and Closure (disambiguation).\n\nNot to be confused with the programming language Clojure.\n\nIn programming languages, a closure, also lexical closure or function closure,\nis a technique for implementing lexically scoped name binding in a language\nwith first-class functions. Operationally, a closure is a record storing a\nfunction^[a] together with an environment.^[1] The environment is a mapping\nassociating each free variable of the function (variables that are used\nlocally, but defined in an enclosing scope) with the value or reference to\nwhich the name was bound when the closure was created.^[b] Unlike a plain\nfunction, a closure allows the function to access those captured variables\nthrough the closure's copies of their values or references, even when the\nfunction is invoked outside their scope.\n\n## History and etymology[edit]\n\nThe concept of closures was developed in the 1960s for the mechanical\nevaluation of expressions in the \u03bb-calculus and was first fully implemented in\n1970 as a language feature in the PAL programming language to support\nlexically scoped first-class functions.^[2]\n\nPeter Landin defined the term closure in 1964 as having an environment part\nand a control part as used by his SECD machine for evaluating expressions.^[3]\nJoel Moses credits Landin with introducing the term closure to refer to a\nlambda expression with open bindings (free variables) that have been closed by\n(or bound in) the lexical environment, resulting in a closed expression, or\nclosure.^[4]^[5] This use was subsequently adopted by Sussman and Steele when\nthey defined Scheme in 1975,^[6] a lexically scoped variant of Lisp, and\nbecame widespread.\n\nSussman and Abelson also use the term closure in the 1980s with a second,\nunrelated meaning: the property of an operator that adds data to a data\nstructure to also be able to add nested data structures. This use of the term\ncomes from mathematics use, rather than the prior use in computer science. The\nauthors consider this overlap in terminology to be \"unfortunate.\"^[7]\n\n## Anonymous functions[edit]\n\nFurther information: Anonymous function\n\nThe term closure is often used as a synonym for anonymous function, though\nstrictly, an anonymous function is a function literal without a name, while a\nclosure is an instance of a function, a value, whose non-local variables have\nbeen bound either to values or to storage locations (depending on the\nlanguage; see the lexical environment section below).\n\nFor example, in the following Python code:\n\n    \n    \n    def f(x): def g(y): return x + y return g # Return a closure. def h(x): return lambda y: x + y # Return a closure. # Assigning specific closures to variables. a = f(1) b = h(1) # Using the closures stored in variables. assert a(5) == 6 assert b(5) == 6 # Using closures without binding them to variables first. assert f(1)(5) == 6 # f(1) is the closure. assert h(1)(5) == 6 # h(1) is the closure.\n\nthe values of a and b are closures, in both cases produced by returning a\nnested function with a free variable from the enclosing function, so that the\nfree variable binds to the value of parameter x of the enclosing function. The\nclosures in a and b are functionally identical. The only difference in\nimplementation is that in the first case we used a nested function with a\nname, g, while in the second case we used an anonymous nested function (using\nthe Python keyword lambda for creating an anonymous function). The original\nname, if any, used in defining them is irrelevant.\n\nA closure is a value like any other value. It does not need to be assigned to\na variable and can instead be used directly, as shown in the last two lines of\nthe example. This usage may be deemed an \"anonymous closure\".\n\nThe nested function definitions are not themselves closures: they have a free\nvariable which is not yet bound. Only once the enclosing function is evaluated\nwith a value for the parameter is the free variable of the nested function\nbound, creating a closure, which is then returned from the enclosing function.\n\nLastly, a closure is only distinct from a function with free variables when\noutside of the scope of the non-local variables, otherwise the defining\nenvironment and the execution environment coincide and there is nothing to\ndistinguish these (static and dynamic binding cannot be distinguished because\nthe names resolve to the same values). For example, in the below program,\nfunctions with a free variable x (bound to the non-local variable x with\nglobal scope) are executed in the same environment where x is defined, so it\nis immaterial whether these are actually closures:\n\n    \n    \n    x = 1 nums = [1, 2, 3] def f(y): return x + y map(f, nums) map(lambda y: x + y, nums)\n\nThis is most often achieved by a function return, since the function must be\ndefined within the scope of the non-local variables, in which case typically\nits own scope will be smaller.\n\nThis can also be achieved by variable shadowing (which reduces the scope of\nthe non-local variable), though this is less common in practice, as it is less\nuseful and shadowing is discouraged. In this example f can be seen to be a\nclosure because x in the body of f is bound to the x in the global namespace,\nnot the x local to g:\n\n    \n    \n    x = 0 def f(y): return x + y def g(z): x = 1 # local x shadows global x return f(z) g(1) # evaluates to 1, not 2\n\n## Applications[edit]\n\nThe use of closures is associated with languages where functions are first-\nclass objects, in which functions can be returned as results from higher-order\nfunctions, or passed as arguments to other function calls; if functions with\nfree variables are first-class, then returning one creates a closure. This\nincludes functional programming languages such as Lisp and ML, and many\nmodern, multi-paradigm languages, such as Julia, Python, and Rust. Closures\nare also often used with callbacks, particularly for event handlers, such as\nin JavaScript, where they are used for interactions with a dynamic web page.\n\nClosures can also be used in a continuation-passing style to hide state.\nConstructs such as objects and control structures can thus be implemented with\nclosures. In some languages, a closure may occur when a function is defined\nwithin another function, and the inner function refers to local variables of\nthe outer function. At run-time, when the outer function executes, a closure\nis formed, consisting of the inner function's code and references (the\nupvalues) to any variables of the outer function required by the closure.\n\n### First-class functions[edit]\n\nFurther information: First-class function\n\nClosures typically appear in languages with first-class functions\u2014in other\nwords, such languages enable functions to be passed as arguments, returned\nfrom function calls, bound to variable names, etc., just like simpler types\nsuch as strings and integers. For example, consider the following Scheme\nfunction:\n\n    \n    \n    ; Return a list of all books with at least THRESHOLD copies sold. (define (best-selling-books threshold) (filter (lambda (book) (>= (book-sales book) threshold)) book-list))\n\nIn this example, the lambda expression (lambda (book) (>= (book-sales book)\nthreshold)) appears within the function best-selling-books. When the lambda\nexpression is evaluated, Scheme creates a closure consisting of the code for\nthe lambda expression and a reference to the threshold variable, which is a\nfree variable inside the lambda expression.\n\nThe closure is then passed to the filter function, which calls it repeatedly\nto determine which books are to be added to the result list and which are to\nbe discarded. Because the closure has a reference to threshold, it can use\nthat variable each time filter calls it. The function filter might be defined\nin a separate file.\n\nHere is the same example rewritten in JavaScript, another popular language\nwith support for closures:\n\n    \n    \n    // Return a list of all books with at least 'threshold' copies sold. function bestSellingBooks(threshold) { return bookList.filter(book => book.sales >= threshold); }\n\nThe arrow operator => is used to define an arrow function expression, and an\nArray.filter method^[8] instead of a global filter function, but otherwise the\nstructure and the effect of the code are the same.\n\nA function may create a closure and return it, as in this example:\n\n    \n    \n    // Return a function that approximates the derivative of f // using an interval of dx, which should be appropriately small. function derivative(f, dx) { return x => (f(x + dx) - f(x)) / dx; }\n\nBecause the closure in this case outlives the execution of the function that\ncreates it, the variables f and dx live on after the function derivative\nreturns, even though execution has left their scope and they are no longer\nvisible. In languages without closures, the lifetime of an automatic local\nvariable coincides with the execution of the stack frame where that variable\nis declared. In languages with closures, variables must continue to exist as\nlong as any existing closures have references to them. This is most commonly\nimplemented using some form of garbage collection.\n\n### State representation[edit]\n\nA closure can be used to associate a function with a set of \"private\"\nvariables, which persist over several invocations of the function. The scope\nof the variable encompasses only the closed-over function, so it cannot be\naccessed from other program code. These are analogous to private variables in\nobject-oriented programming, and in fact closures are similar to stateful\nfunction objects (or functors) with a single call-operator method.\n\nIn stateful languages, closures can thus be used to implement paradigms for\nstate representation and information hiding, since the closure's upvalues (its\nclosed-over variables) are of indefinite extent, so a value established in one\ninvocation remains available in the next. Closures used in this way no longer\nhave referential transparency, and are thus no longer pure functions;\nnevertheless, they are commonly used in impure functional languages such as\nScheme.\n\n### Other uses[edit]\n\nClosures have many uses:\n\n  * Because closures delay evaluation\u2014i.e., they do not \"do\" anything until they are called\u2014they can be used to define control structures. For example, all of Smalltalk's standard control structures, including branches (if/then/else) and loops (while and for), are defined using objects whose methods accept closures. Users can easily define their own control structures also.\n  * In languages which implement assignment, multiple functions can be produced that close over the same environment, enabling them to communicate privately by altering that environment. In Scheme:\n\n    \n    \n    (define foo #f) (define bar #f) (let ((secret-message \"none\")) (set! foo (lambda (msg) (set! secret-message msg))) (set! bar (lambda () secret-message))) (display (bar)) ; prints \"none\" (newline) (foo \"meet me by the docks at midnight\") (display (bar)) ; prints \"meet me by the docks at midnight\"\n\n  * Closures can be used to implement object systems.^[9]\n\nNote: Some speakers call any data structure that binds a lexical environment a\nclosure, but the term usually refers specifically to functions.\n\n## Implementation and theory[edit]\n\nClosures are typically implemented with a special data structure that contains\na pointer to the function code, plus a representation of the function's\nlexical environment (i.e., the set of available variables) at the time when\nthe closure was created. The referencing environment binds the non-local names\nto the corresponding variables in the lexical environment at the time the\nclosure is created, additionally extending their lifetime to at least as long\nas the lifetime of the closure. When the closure is entered at a later time,\npossibly with a different lexical environment, the function is executed with\nits non-local variables referring to the ones captured by the closure, not the\ncurrent environment.\n\nA language implementation cannot easily support full closures if its run-time\nmemory model allocates all automatic variables on a linear stack. In such\nlanguages, a function's automatic local variables are deallocated when the\nfunction returns. However, a closure requires that the free variables it\nreferences survive the enclosing function's execution. Therefore, those\nvariables must be allocated so that they persist until no longer needed,\ntypically via heap allocation, rather than on the stack, and their lifetime\nmust be managed so they survive until all closures referencing them are no\nlonger in use.\n\nThis explains why, typically, languages that natively support closures also\nuse garbage collection. The alternatives are manual memory management of non-\nlocal variables (explicitly allocating on the heap and freeing when done), or,\nif using stack allocation, for the language to accept that certain use cases\nwill lead to undefined behaviour, due to dangling pointers to freed automatic\nvariables, as in lambda expressions in C++11^[10] or nested functions in GNU\nC.^[11] The funarg problem (or \"functional argument\" problem) describes the\ndifficulty of implementing functions as first class objects in a stack-based\nprogramming language such as C or C++. Similarly in D version 1, it is assumed\nthat the programmer knows what to do with delegates and automatic local\nvariables, as their references will be invalid after return from its\ndefinition scope (automatic local variables are on the stack) \u2013 this still\npermits many useful functional patterns, but for complex cases needs explicit\nheap allocation for variables. D version 2 solved this by detecting which\nvariables must be stored on the heap, and performs automatic allocation.\nBecause D uses garbage collection, in both versions, there is no need to track\nusage of variables as they are passed.\n\nIn strict functional languages with immutable data (e.g. Erlang), it is very\neasy to implement automatic memory management (garbage collection), as there\nare no possible cycles in variables' references. For example, in Erlang, all\narguments and variables are allocated on the heap, but references to them are\nadditionally stored on the stack. After a function returns, references are\nstill valid. Heap cleaning is done by incremental garbage collector.\n\nIn ML, local variables are lexically scoped, and hence define a stack-like\nmodel, but since they are bound to values and not to objects, an\nimplementation is free to copy these values into the closure's data structure\nin a way that is invisible to the programmer.\n\nScheme, which has an ALGOL-like lexical scope system with dynamic variables\nand garbage collection, lacks a stack programming model and does not suffer\nfrom the limitations of stack-based languages. Closures are expressed\nnaturally in Scheme. The lambda form encloses the code, and the free variables\nof its environment persist within the program as long as they can possibly be\naccessed, and so they can be used as freely as any other Scheme\nexpression.^[citation needed]\n\nClosures are closely related to Actors in the Actor model of concurrent\ncomputation where the values in the function's lexical environment are called\nacquaintances. An important issue for closures in concurrent programming\nlanguages is whether the variables in a closure can be updated and, if so, how\nthese updates can be synchronized. Actors provide one solution.^[12]\n\nClosures are closely related to function objects; the transformation from the\nformer to the latter is known as defunctionalization or lambda lifting; see\nalso closure conversion.^[citation needed]\n\n## Differences in semantics[edit]\n\n### Lexical environment[edit]\n\nAs different languages do not always have a common definition of the lexical\nenvironment, their definitions of closure may vary also. The commonly held\nminimalist definition of the lexical environment defines it as a set of all\nbindings of variables in the scope, and that is also what closures in any\nlanguage have to capture. However the meaning of a variable binding also\ndiffers. In imperative languages, variables bind to relative locations in\nmemory that can store values. Although the relative location of a binding does\nnot change at runtime, the value in the bound location can. In such languages,\nsince closure captures the binding, any operation on the variable, whether\ndone from the closure or not, are performed on the same relative memory\nlocation. This is often called capturing the variable \"by reference\". Here is\nan example illustrating the concept in ECMAScript, which is one such language:\n\n    \n    \n    // Javascript var f, g; function foo() { var x; f = function() { return ++x; }; g = function() { return --x; }; x = 1; alert('inside foo, call to f(): ' + f()); } foo(); // 2 alert('call to g(): ' + g()); // 1 (--x) alert('call to g(): ' + g()); // 0 (--x) alert('call to f(): ' + f()); // 1 (++x) alert('call to f(): ' + f()); // 2 (++x)\n\nFunction foo and the closures referred to by variables f and g all use the\nsame relative memory location signified by local variable x.\n\nIn some instances the above behaviour may be undesirable, and it is necessary\nto bind a different lexical closure. Again in ECMAScript, this would be done\nusing the Function.bind().\n\n### Example 1: Reference to an unbound variable[edit]\n\n^[13]\n\n    \n    \n    var module = { x: 42, getX: function() {return this.x; } } var unboundGetX = module.getX; console.log(unboundGetX()); // The function gets invoked at the global scope // emits undefined as 'x' is not specified in global scope. var boundGetX = unboundGetX.bind(module); // specify object module as the closure console.log(boundGetX()); // emits 42\n\n### Example 2: Accidental reference to a bound variable[edit]\n\nFor this example the expected behaviour would be that each link should emit\nits id when clicked; but because the variable 'e' is bound to the scope above,\nand lazy evaluated on click, what actually happens is that each on click event\nemits the id of the last element in 'elements' bound at the end of the for\nloop.^[14]\n\n    \n    \n    var elements = document.getElementsByTagName('a'); // Incorrect: e is bound to the function containing the 'for' loop, not the closure of \"handle\" for (var e of elements) { e.onclick = function handle() { alert(e.id); } }\n\nAgain here variable e would need to be bound by the scope of the block using\nhandle.bind(this) or the let keyword.\n\nOn the other hand, many functional languages, such as ML, bind variables\ndirectly to values. In this case, since there is no way to change the value of\nthe variable once it is bound, there is no need to share the state between\nclosures\u2014they just use the same values. This is often called capturing the\nvariable \"by value\". Java's local and anonymous classes also fall into this\ncategory\u2014they require captured local variables to be final, which also means\nthere is no need to share state.\n\nSome languages enable choosing between capturing the value of a variable or\nits location. For example, in C++11, captured variables are either declared\nwith [&], which means captured by reference, or with [=], which means captured\nby value.\n\nYet another subset, lazy functional languages such as Haskell, bind variables\nto results of future computations rather than values. Consider this example in\nHaskell:\n\n    \n    \n    -- Haskell foo :: Fractional a => a -> a -> (a -> a) foo x y = (\\z -> z + r) where r = x / y f :: Fractional a => a -> a f = foo 1 0 main = print (f 123)\n\nThe binding of r captured by the closure defined within function foo is to the\ncomputation (x / y)\u2014which in this case results in division by zero. However,\nsince it is the computation that is captured, and not the value, the error\nonly manifests when the closure is invoked, and then attempts to use the\ncaptured binding.\n\n### Closure leaving[edit]\n\nYet more differences manifest themselves in the behavior of other lexically\nscoped constructs, such as return, break and continue statements. Such\nconstructs can, in general, be considered in terms of invoking an escape\ncontinuation established by an enclosing control statement (in case of break\nand continue, such interpretation requires looping constructs to be considered\nin terms of recursive function calls). In some languages, such as ECMAScript,\nreturn refers to the continuation established by the closure lexically\ninnermost with respect to the statement\u2014thus, a return within a closure\ntransfers control to the code that called it. However, in Smalltalk, the\nsuperficially similar operator ^ invokes the escape continuation established\nfor the method invocation, ignoring the escape continuations of any\nintervening nested closures. The escape continuation of a particular closure\ncan only be invoked in Smalltalk implicitly by reaching the end of the\nclosure's code. These examples in ECMAScript and Smalltalk highlight the\ndifference:\n\n    \n    \n    \"Smalltalk\" foo | xs | xs := #(1 2 3 4). xs do: [:x | ^x]. ^0 bar Transcript show: (self foo printString) \"prints 1\"\n    \n    \n    // ECMAScript function foo() { var xs = [1, 2, 3, 4]; xs.forEach(function (x) { return x; }); return 0; } alert(foo()); // prints 0\n\nThe above code snippets will behave differently because the Smalltalk ^\noperator and the JavaScript return operator are not analogous. In the\nECMAScript example, return x will leave the inner closure to begin a new\niteration of the forEach loop, whereas in the Smalltalk example, ^x will abort\nthe loop and return from the method foo.\n\nCommon Lisp provides a construct that can express either of the above actions:\nLisp (return-from foo x) behaves as Smalltalk ^x, while Lisp (return-from nil\nx) behaves as JavaScript return x. Hence, Smalltalk makes it possible for a\ncaptured escape continuation to outlive the extent in which it can be\nsuccessfully invoked. Consider:\n\n    \n    \n    \"Smalltalk\" foo ^[ :x | ^x ] bar | f | f := self foo. f value: 123 \"error!\"\n\nWhen the closure returned by the method foo is invoked, it attempts to return\na value from the invocation of foo that created the closure. Since that call\nhas already returned and the Smalltalk method invocation model does not follow\nthe spaghetti stack discipline to facilitate multiple returns, this operation\nresults in an error.\n\nSome languages, such as Ruby, enable the programmer to choose the way return\nis captured. An example in Ruby:\n\n    \n    \n    # Ruby # Closure using a Proc def foo f = Proc.new { return \"return from foo from inside proc\" } f.call # control leaves foo here return \"return from foo\" end # Closure using a lambda def bar f = lambda { return \"return from lambda\" } f.call # control does not leave bar here return \"return from bar\" end puts foo # prints \"return from foo from inside proc\" puts bar # prints \"return from bar\"\n\nBoth Proc.new and lambda in this example are ways to create a closure, but\nsemantics of the closures thus created are different with respect to the\nreturn statement.\n\nIn Scheme, definition and scope of the return control statement is explicit\n(and only arbitrarily named 'return' for the sake of the example). The\nfollowing is a direct translation of the Ruby sample.\n\n    \n    \n    ; Scheme (define call/cc call-with-current-continuation) (define (foo) (call/cc (lambda (return) (define (f) (return \"return from foo from inside proc\")) (f) ; control leaves foo here (return \"return from foo\")))) (define (bar) (call/cc (lambda (return) (define (f) (call/cc (lambda (return) (return \"return from lambda\")))) (f) ; control does not leave bar here (return \"return from bar\")))) (display (foo)) ; prints \"return from foo from inside proc\" (newline) (display (bar)) ; prints \"return from bar\"\n\n## Closure-like constructs[edit]\n\nSome languages have features which simulate the behavior of closures. In\nlanguages such as C++, C#, D, Java, Objective-C, and Visual Basic (.NET)\n(VB.NET), these features are the result of the language's object-oriented\nparadigm.\n\n### Callbacks (C)[edit]\n\nSome C libraries support callbacks. This is sometimes implemented by providing\ntwo values when registering the callback with the library: a function pointer\nand a separate void* pointer to arbitrary data of the user's choice. When the\nlibrary executes the callback function, it passes along the data pointer. This\nenables the callback to maintain state and to refer to information captured at\nthe time it was registered with the library. The idiom is similar to closures\nin functionality, but not in syntax. The void* pointer is not type safe so\nthis C idiom differs from type-safe closures in C#, Haskell or ML.\n\nCallbacks are used extensively in graphical user interface (GUI) widget\ntoolkits to implement event-driven programming by associating general\nfunctions of graphical widgets (menus, buttons, check boxes, sliders,\nspinners, etc.) with application-specific functions implementing the specific\ndesired behavior for the application.\n\n#### Nested function and function pointer (C)[edit]\n\nWith a GNU Compiler Collection (GCC) extension, a nested function^[15] can be\nused and a function pointer can emulate closures, provided the function does\nnot exit the containing scope. The next example is invalid because adder is a\ntop-level definition (depending on compiler version, it could produce a\ncorrect result if compiled with no optimizing, i.e., at -O0):\n\n    \n    \n    #include <stdio.h> typedef int (*fn_int_to_int)(int); // type of function int->int fn_int_to_int adder(int number) { int add (int value) { return value + number; } return &add; // & operator is optional here because the name of a function in C is a pointer pointing on itself } int main(void) { fn_int_to_int add10 = adder(10); printf(\"%d\\n\", add10(1)); return 0; }\n\nBut moving adder (and, optionally, the typedef) in main makes it valid:\n\n    \n    \n    #include <stdio.h> int main(void) { typedef int (*fn_int_to_int)(int); // type of function int->int fn_int_to_int adder(int number) { int add (int value) { return value + number; } return add; } fn_int_to_int add10 = adder(10); printf(\"%d\\n\", add10(1)); return 0; }\n\nIf executed this now prints 11 as expected.\n\n### Local classes and lambda functions (Java)[edit]\n\nJava enables classes to be defined inside methods. These are called local\nclasses. When such classes are not named, they are known as anonymous classes\n(or anonymous inner classes). A local class (either named or anonymous) may\nrefer to names in lexically enclosing classes, or read-only variables (marked\nas final) in the lexically enclosing method.\n\n    \n    \n    class CalculationWindow extends JFrame { private volatile int result; // ... public void calculateInSeparateThread(final URI uri) { // The expression \"new Runnable() { ... }\" is an anonymous class implementing the 'Runnable' interface. new Thread( new Runnable() { void run() { // It can read final local variables: calculate(uri); // It can access private fields of the enclosing class: result = result + 10; } } ).start(); } }\n\nThe capturing of final variables enables capturing variables by value. Even if\nthe variable to capture is non-final, it can always be copied to a temporary\nfinal variable just before the class.\n\nCapturing of variables by reference can be emulated by using a final reference\nto a mutable container, for example, a one-element array. The local class will\nnot be able to change the value of the container reference, but it will be\nable to change the contents of the container.\n\nWith the advent of Java 8's lambda expressions,^[16] the closure causes the\nabove code to be executed as:\n\n    \n    \n    class CalculationWindow extends JFrame { private volatile int result; // ... public void calculateInSeparateThread(final URI uri) { // The code () -> { /* code */ } is a closure. new Thread(() -> { calculate(uri); result = result + 10; }).start(); } }\n\nLocal classes are one of the types of inner class that are declared within the\nbody of a method. Java also supports inner classes that are declared as non-\nstatic members of an enclosing class.^[17] They are normally referred to just\nas \"inner classes\".^[18] These are defined in the body of the enclosing class\nand have full access to instance variables of the enclosing class. Due to\ntheir binding to these instance variables, an inner class may only be\ninstantiated with an explicit binding to an instance of the enclosing class\nusing a special syntax.^[19]\n\n    \n    \n    public class EnclosingClass { /* Define the inner class */ public class InnerClass { public int incrementAndReturnCounter() { return counter++; } } private int counter; { counter = 0; } public int getCounter() { return counter; } public static void main(String[] args) { EnclosingClass enclosingClassInstance = new EnclosingClass(); /* Instantiate the inner class, with binding to the instance */ EnclosingClass.InnerClass innerClassInstance = enclosingClassInstance.new InnerClass(); for (int i = enclosingClassInstance.getCounter(); (i = innerClassInstance.incrementAndReturnCounter()) < 10; /* increment step omitted */) { System.out.println(i); } } }\n\nUpon execution, this will print the integers from 0 to 9. Beware to not\nconfuse this type of class with the nested class, which is declared in the\nsame way with an accompanied usage of the \"static\" modifier; those have not\nthe desired effect but are instead just classes with no special binding\ndefined in an enclosing class.\n\nAs of Java 8, Java supports functions as first class objects. Lambda\nexpressions of this form are considered of type Function<T,U> with T being the\ndomain and U the image type. The expression can be called with its .apply(T t)\nmethod, but not with a standard method call.\n\n    \n    \n    public static void main(String[] args) { Function<String, Integer> length = s -> s.length(); System.out.println( length.apply(\"Hello, world!\") ); // Will print 13. }\n\n### Blocks (C, C++, Objective-C 2.0)[edit]\n\nMain article: Blocks (C language extension)\n\nApple introduced blocks, a form of closure, as a nonstandard extension into C,\nC++, Objective-C 2.0 and in Mac OS X 10.6 \"Snow Leopard\" and iOS 4.0. Apple\nmade their implementation available for the GCC and clang compilers.\n\nPointers to block and block literals are marked with ^. Normal local variables\nare captured by value when the block is created, and are read-only inside the\nblock. Variables to be captured by reference are marked with __block. Blocks\nthat need to persist outside of the scope they are created in may need to be\ncopied.^[20]^[21]\n\n    \n    \n    typedef int (^IntBlock)(); IntBlock downCounter(int start) { __block int i = start; return [[ ^int() { return i--; } copy] autorelease]; } IntBlock f = downCounter(5); NSLog(@\"%d\", f()); NSLog(@\"%d\", f()); NSLog(@\"%d\", f());\n\n### Delegates (C#, VB.NET, D)[edit]\n\nC# anonymous methods and lambda expressions support closure:\n\n    \n    \n    var data = new[] {1, 2, 3, 4}; var multiplier = 2; var result = data.Select(x => x * multiplier);\n\nVisual Basic .NET, which has many language features similar to those of C#,\nalso supports lambda expressions with closures:\n\n    \n    \n    Dim data = {1, 2, 3, 4} Dim multiplier = 2 Dim result = data.Select(Function(x) x * multiplier)\n\nIn D, closures are implemented by delegates, a function pointer paired with a\ncontext pointer (e.g. a class instance, or a stack frame on the heap in the\ncase of closures).\n\n    \n    \n    auto test1() { int a = 7; return delegate() { return a + 3; }; // anonymous delegate construction } auto test2() { int a = 20; int foo() { return a + 5; } // inner function return &foo; // other way to construct delegate } void bar() { auto dg = test1(); dg(); // =10 // ok, test1.a is in a closure and still exists dg = test2(); dg(); // =25 // ok, test2.a is in a closure and still exists }\n\nD version 1, has limited closure support. For example, the above code will not\nwork correctly, because the variable a is on the stack, and after returning\nfrom test(), it is no longer valid to use it (most probably calling foo via\ndg(), will return a 'random' integer). This can be solved by explicitly\nallocating the variable 'a' on heap, or using structs or class to store all\nneeded closed variables and construct a delegate from a method implementing\nthe same code. Closures can be passed to other functions, as long as they are\nonly used while the referenced values are still valid (for example calling\nanother function with a closure as a callback parameter), and are useful for\nwriting generic data processing code, so this limitation, in practice, is\noften not an issue.\n\nThis limitation was fixed in D version 2 - the variable 'a' will be\nautomatically allocated on the heap because it is used in the inner function,\nand a delegate of that function can escape the current scope (via assignment\nto dg or return). Any other local variables (or arguments) that are not\nreferenced by delegates or that are only referenced by delegates that do not\nescape the current scope, remain on the stack, which is simpler and faster\nthan heap allocation. The same is true for inner's class methods that\nreference a function's variables.\n\n### Function objects (C++)[edit]\n\nC++ enables defining function objects by overloading operator(). These objects\nbehave somewhat like functions in a functional programming language. They may\nbe created at runtime and may contain state, but they do not implicitly\ncapture local variables as closures do. As of the 2011 revision, the C++\nlanguage also supports closures, which are a type of function object\nconstructed automatically from a special language construct called lambda-\nexpression. A C++ closure may capture its context either by storing copies of\nthe accessed variables as members of the closure object or by reference. In\nthe latter case, if the closure object escapes the scope of a referenced\nobject, invoking its operator() causes undefined behavior since C++ closures\ndo not extend the lifetime of their context.\n\nMain article: Anonymous function \u00a7 C++ (since C++11)\n\n    \n    \n    void foo(string myname) { int y; vector<string> n; // ... auto i = std::find_if(n.begin(), n.end(), // this is the lambda expression: [&](const string& s) { return s != myname && s.size() > y; } ); // 'i' is now either 'n.end()' or points to the first string in 'n' // which is not equal to 'myname' and whose length is greater than 'y' }\n\n### Inline agents (Eiffel)[edit]\n\nEiffel includes inline agents defining closures. An inline agent is an object\nrepresenting a routine, defined by giving the code of the routine in-line. For\nexample, in\n\n    \n    \n    ok_button.click_event.subscribe ( agent (x, y: INTEGER) do map.country_at_coordinates (x, y).display end )\n\nthe argument to subscribe is an agent, representing a procedure with two\narguments; the procedure finds the country at the corresponding coordinates\nand displays it. The whole agent is \"subscribed\" to the event type click_event\nfor a certain button, so that whenever an instance of the event type occurs on\nthat button \u2013 because a user has clicked the button \u2013 the procedure will be\nexecuted with the mouse coordinates being passed as arguments for x and y.\n\nThe main limitation of Eiffel agents, which distinguishes them from closures\nin other languages, is that they cannot reference local variables from the\nenclosing scope. This design decision helps in avoiding ambiguity when talking\nabout a local variable value in a closure - should it be the latest value of\nthe variable or the value captured when the agent is created? Only Current (a\nreference to current object, analogous to this in Java), its features, and\narguments of the agent can be accessed from within the agent body. The values\nof the outer local variables can be passed by providing additional closed\noperands to the agent.\n\n### C++Builder __closure reserved word[edit]\n\nEmbarcadero C++Builder provides the reserve word __closure to provide a\npointer to a method with a similar syntax to a function pointer.^[22]\n\nStandard C allows writing a typedef for a pointer to a function type using the\nfollowing syntax:\n\n    \n    \n    typedef void (*TMyFunctionPointer)( void );\n\nIn a similar way, a typedef can be declared for a pointer to a method using\nthis syntax:\n\n    \n    \n    typedef void (__closure *TMyMethodPointer)();\n\n## See also[edit]\n\n  * Anonymous function\n  * Blocks (C language extension)\n  * Command pattern\n  * Continuation\n  * Currying\n  * Funarg problem\n  * Lambda calculus\n  * Lazy evaluation\n  * Partial application\n  * Spaghetti stack\n  * Syntactic closure\n  * Value-level programming\n\n## Notes[edit]\n\n  1. ^ The function may be stored as a reference to a function, such as a function pointer.\n  2. ^ These names usually refer to values, mutable variables, or functions, but can also be other entities such as constants, types, classes, or labels.\n\n## References[edit]\n\n  1. ^ Sussman and Steele. \"Scheme: An interpreter for extended lambda calculus\". \"... a data structure containing a lambda expression, and an environment to be used when that lambda expression is applied to arguments.\" (Wikisource)\n  2. ^ Turner, David A. (2012). \"Some History of Functional Programming Languages\" (PDF). International Symposium on Trends in Functional Programming. Lecture Notes in Computer Science. Vol. 7829. Springer. pp. 1\u201320 See 12 \u00a72, note 8 for the claim about M-expressions. doi:10.1007/978-3-642-40447-4_1. ISBN 978-3-642-40447-4.\n  3. ^ Landin, P.J. (January 1964). \"The mechanical evaluation of expressions\" (PDF). The Computer Journal. 6 (4): 308\u2013320. doi:10.1093/comjnl/6.4.308.\n  4. ^ Moses, Joel (June 1970). \"The Function of FUNCTION in LISP, or Why the FUNARG Problem Should Be Called the Environment Problem\". ACM Sigsam Bulletin (15): 13\u201327. doi:10.1145/1093410.1093411. hdl:1721.1/5854. S2CID 17514262. AI Memo 199. \"A useful metaphor for the difference between FUNCTION and QUOTE in LISP is to think of QUOTE as a porous or an open covering of the function since free variables escape to the current environment. FUNCTION acts as a closed or nonporous covering (hence the term \"closure\" used by Landin). Thus we talk of \"open\" Lambda expressions (functions in LISP are usually Lambda expressions) and \"closed\" Lambda expressions. [...] My interest in the environment problem began while Landin, who had a deep understanding of the problem, visited MIT during 1966\u201367. I then realized the correspondence between the FUNARG lists which are the results of the evaluation of \"closed\" Lambda expressions in LISP and ISWIM's Lambda Closures.\"\n  5. ^ Wikstr\u00f6m, \u00c5ke (1987). Functional Programming using Standard ML. Prentice Hall. ISBN 0-13-331968-7. \"The reason it is called a \"closure\" is that an expression containing free variables is called an \"open\" expression, and by associating to it the bindings of its free variables, you close it.\"\n  6. ^ Sussman, Gerald Jay; Steele, Guy L. Jr. (December 1975). Scheme: An Interpreter for the Extended Lambda Calculus (Report). AI Memo 349.\n  7. ^ Abelson, Harold; Sussman, Gerald Jay; Sussman, Julie (1996). Structure and Interpretation of Computer Programs. MIT Press. pp. 98\u201399. ISBN 0-262-51087-1.\n  8. ^ \"array.filter\". Mozilla Developer Center. 10 January 2010. Retrieved 9 February 2010.\n  9. ^ \"Re: FP, OO and relations. Does anyone trump the others?\". 29 December 1999. Archived from the original on 26 December 2008. Retrieved 23 December 2008.\n  10. ^ Lambda Expressions and Closures C++ Standards Committee. 29 February 2008.\n  11. ^ \"6.4 Nested Functions\". GCC Manual. \"If you try to call the nested function through its address after the containing function exits, all hell breaks loose. If you try to call it after a containing scope level exits, and if it refers to some of the variables that are no longer in scope, you may be lucky, but it's not wise to take the risk. If, however, the nested function does not refer to anything that has gone out of scope, you should be safe.\"\n  12. ^ Foundations of Actor Semantics Will Clinger. MIT Mathematics Doctoral Dissertation. June 1981.\n  13. ^ \"Function.prototype.bind()\". MDN Web Docs. Retrieved 20 November 2018.\n  14. ^ \"Closures\". MDN Web Docs. Retrieved 20 November 2018.\n  15. ^ \"Nested functions\".\n  16. ^ \"Lambda Expressions\". The Java Tutorials.\n  17. ^ \"Nested, Inner, Member, and Top-Level Classes\". Joseph D. Darcy's Oracle Weblog. July 2007. Archived from the original on 31 August 2016.\n  18. ^ \"Inner Class Example\". The Java Tutorials: Learning the Java Language: Classes and Objects.\n  19. ^ \"Nested Classes\". The Java Tutorials: Learning the Java Language: Classes and Objects.\n  20. ^ \"Blocks Programming Topics\". Apple Inc. 8 March 2011. Retrieved 8 March 2011.\n  21. ^ Bengtsson, Joachim (7 July 2010). \"Programming with C Blocks on Apple Devices\". Archived from the original on 25 October 2010. Retrieved 18 September 2010.\n  22. ^ Full documentation can be found at http://docwiki.embarcadero.com/RADStudio/Rio/en/Closure\n\n## External links[edit]\n\n  * Original \"Lambda Papers\": A classic series of papers by Guy L. Steele Jr. and Gerald Jay Sussman discussing, among other things, the versatility of closures in the context of Scheme (where they appear as lambda expressions).\n  * Gafter, Neal (28 January 2007). \"A Definition of Closures\".\n  * Bracha, Gilad; Gafter, Neal; Gosling, James; von der Ah\u00e9, Peter. \"Closures for the Java Programming Language (v0.5)\".\n  * Closures: An article about closures in dynamically typed imperative languages, by Martin Fowler.\n  * Collection closure methods: An example of a technical domain where using closures is convenient, by Martin Fowler.\n\nRetrieved from\n\"https://en.wikipedia.org/w/index.php?title=Closure_(computer_programming)&oldid=1212801391\"\n\nCategories:\n\n  * Programming language concepts\n  * Implementation of functional programming languages\n  * Subroutines\n\nHidden categories:\n\n  * Articles with short description\n  * Short description matches Wikidata\n  * Use dmy dates from August 2020\n  * All articles with unsourced statements\n  * Articles with unsourced statements from December 2014\n  * Articles with unsourced statements from September 2011\n  * Articles with example C++ code\n  * Articles with example C Sharp code\n  * Articles with example D code\n  * Articles with example Eiffel code\n  * Articles with example Haskell code\n  * Articles with example Java code\n  * Articles with example JavaScript code\n  * Articles with example Objective-C code\n  * Articles with example Python (programming language) code\n  * Articles with example Ruby code\n  * Articles with example Scheme (programming language) code\n  * Articles with example Smalltalk code\n\n  * This page was last edited on 9 March 2024, at 17:10 (UTC).\n  * Text is available under the Creative Commons Attribution-ShareAlike License 4.0; additional terms may apply. By using this site, you agree to the Terms of Use and Privacy Policy. Wikipedia\u00ae is a registered trademark of the Wikimedia Foundation, Inc., a non-profit organization.\n\n  * Privacy policy\n  * About Wikipedia\n  * Disclaimers\n  * Contact Wikipedia\n  * Code of Conduct\n  * Developers\n  * Statistics\n  * Cookie statement\n  * Mobile view\n  * Edit preview settings\n\n", "frontpage": false}
