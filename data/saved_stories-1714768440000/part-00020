{"aid": "40246277", "title": "Unwind Considered Harmful?", "url": "https://smallcultfollowing.com/babysteps/blog/2024/05/02/unwind-considered-harmful/", "domain": "smallcultfollowing.com", "votes": 1, "user": "yamafaktory", "posted_at": "2024-05-03 11:01:23", "comments": 0, "source_title": "baby steps", "source_text": "Unwind considered harmful? \u00b7 baby steps\n\n# Unwind considered harmful?\n\n2 May 2024\n\nI\u2019ve been thinking a wild thought lately: we should deprecate panic=unwind.\nMost production users I know either already run with panic=abort or use\nunwinding in a very limited fashion, basically just to run to cleanup, not to\ntruly recover. Removing unwinding from most case meanwhile has a number of\nbenefits, allowing us to extend the type system in interesting and potentially\nvery impactful ways. It also removes a common source of subtle bugs. Note that\nI am not saying we should remove unwinding entirely: that\u2019s not an option,\nboth because of stability and because of Rust\u2019s mission to \u201cdeeply integrate\u201d\nwith all kinds of languages and systems.\n\n## Unwinding means all code must be able to stop at every point\n\nUnwinding puts a \u201cnon-local burden\u201d on the language. The fundamental premise\nof unwinding is that it should be possible for all code to just stop execution\nat any point (or at least at any function call) and then be restarted. But\nthis is not always possible. Sometimes code disturbs invariants which must be\nrestored before execution can continue in a reasonable way.\n\n## The impact of unwinding was supposed to be contained\n\nIn Graydon\u2019s initial sketches for Rust\u2019s design, he was very suspicious of\nunwinding.^1 Unwinding introduces implicit control flow that is difficult to\nreason about. Worse, this control flow doesn\u2019t surface during \u201cnormal\nexecution\u201d, it only shows up when things go wrong \u2014 this can tend to pile up,\nmaking a bad situation worse.\n\nThe initial idea was that unwinding would be allowed, but it would always\nunwinding the entire active thread. Moreover, since in very early Rust threads\ncouldn\u2019t share state at all (it was more like Erlang), that limited the damage\nthat a thread could do. It was reasonable to assume that programs could\nrecover.\n\n## But it escaped its bounds\n\nOver time, both of the invariants that limited unwinding\u2019s scope proved\nuntenable. Most importantly, we added shared-mutability with types like Mutex.\nThis was necessary to cover the full range of use cases Rust aims to cover,\nbut it meant that it was now possible for threads to leave data in a disturbed\nstate. We added \u201clock poisoning\u201d to account for that, but it\u2019s an ergonomic\nannoyance and an imperfect solution, and so libraries like parking_lot have\nsimply removed it.\n\nWe also added catch_unwind, allowing recovery within a thread. This was meant\nto be used in libraries like rayon that were simulating many logical threads\nwith one OS thread, but it of course opened the door to \u201ccatching\u201d exceptions\nin other scenarios. We added the idea of UnwindSafe to try and discourage\nabuse, but (in a familiar theme) it\u2019s an ergonomic annoyance and an imperfect\nsolution, and so many folks would prefer to just remove it.\n\n## Unwinding increases binary size and reduces optimization potential\n\nUnwinding is supposed to be a \u201czero-cost abstraction\u201d, but it\u2019s not really. To\nstart, it requires inserting \u201clanding pads\u201d \u2014 basically, the code that will\nexecute when unwinding occurs \u2014 which can take up quite a large amount of\nspace in your binary. Folks like Fuchsia have measured binary size\nimprovements of up to 10% by removing unwinding. Second, the need to account\nfor unwinding limits optimizations, because the compiler has to account for\nmore control-flow paths. I don\u2019t have a number for how high of an impact this\nis, but it\u2019s clearly not zero.\n\n## Unwinding puts limits on the borrow checker\n\nAccounting for unwinding also requires the borrow checker to be more\nconservative. Consider for example the function std::mem::swap. It\u2019d be nice\nif one could write this in safe code:\n\n    \n    \n    fn swap<T>( a: &mut T, b: &mut T, ) { let tmp = *a; *a = *b; *b = tmp; }\n\nThis code won\u2019t compile today, because let tmp = *a requires moving out of *a,\nand a is an &mut reference. That would leave the reference in an \u201cincomplete\u201d\nstate, so we don\u2019t allow it. But is that constraint truly needed? After all,\nthe reference is going to be restored a few lines below...?\n\nThe reason the borrow checker does not accept code like the above is due to\nunwinding. In general, if you move out of an &mut, you leave a hole behind\nthat MUST be filled before the function returns. In the function above, it is\nin fact guaranteed that the hole will be filled before swap returns. But in\ngeneral there is a very narrow range of code that can safely execute, since\nany function call (and many other operations besides) can initiative a panic!.\nAnd if unwinding occurred, then the code that restores the &mut value would\nnever execute. For this reason, we deemed it not worth the complexity to\nsupport moving out of &mut references.\n\n## Unwinding prevents code from running to completion\n\nIf the only cost of unwinding was moving out of &mutand inflated binary sizes,\nI would think that it\u2019s probably worth it to keep it. But over time it\u2019s\nbecome clear to me that this is just one special case of a more general\nchallenge with unwinding, which is that functions simply cannot rely on\nrunning to completion. This creates challenges in a number of areas.\n\n### Unwinding makes unsafe code really hard to write\n\nIf you are writing unsafe code, you have to be very to account for possible\nunwinding. And it can occur in a lot of places! Some of them are obvious, such\nas when the user gives you a closure and you call it. Others are less obvious,\nsuch as when you call a trait method like x.clone() where x has some unknown\ntype T: Clone. Others are downright obscure, such as when you execute vec[i] =\nnew_value and vec is a Vec<T> for some unknown type T \u2014 that last one will run\nthe destructor on vec[i] , which can panic, and hence can unwind (at least\nuntil RFC #3288 is accepted). When developing Rayon, I found I could not\nfeasibly track all the places that unwinding could occur, and thus gave up and\njust added code to abort if unwinding occurs when I don\u2019t expect it.\n\n### Unwinding makes Must Move types untenable\n\nIn a previous blog post I wrote about the idea of must move types. I am not\nsure if this idea is worth it on balance (although I think it might be, it\naddresses an awful lot of scenarios) but I think it will not be workable with\nunwinding. And the reason is the same as everything else: the point of a \u201cmust\nmove\u201d type is that it must be moved before the fn ends. This effectively means\nthere is some kind of action you must take. But unwinding assumes you can stop\nthe function at any point, so you can never guarantee that this action gets\ntaken (at least, not in a practical sense, in principle you could setup\ndestructors to take the action, but it would be unworkable I think).\n\n## Unwinding is of course useful\n\nI\u2019ve been dunking on unwinding, but it is of course useful (although I suspect\nless broadly than is commonly believed). The most obvious use case is\nrecovering in an \u201cevent-driven\u201d sort of process, like a webserver or perhaps a\nGUI. We\u2019ve all been to websites that dump a stack trace on our screen.\nUnwinding is one way that you could implement this sort of recovery in Rust.\nIt\u2019s not, however, the only way. We could look into constructs that leverage\nprocess-based recovery, for example. And of course unwinding-based recovery is\na bit risky, if there is shared state. Plus, in practice, a good many things\nthat become exceptions in Java are Result-return values in Rust.\n\nFor me, the key thing here is that virtually every network service I know of\nships either with panic=abort or without really leveraging unwinding to\nrecover, just to take cleanup actions and then exit. This could be done with\npanic=abort and exit handlers.\n\nOne other place that uses unwinding is the salsa framework, which uses it to\nabort cancelled operations in IDEs. It\u2019s useful there because all the code is\nside-effect free, so we really can unwinding without any impact. But we could\nalways find another solution to the problem.\n\n## Unwinding is in fact required...but only in narrow places\n\nI don\u2019t really think Rust should remove support for unwinding, of course. For\none thing, there is backwards compatibility to consider. But for another, I\nthink that Rust ought to have the goal that it ultimately supports any low-\nlevel thing you might want to do. There are C++ systems that use exceptions,\nand Rust ought to interoperate with them. But I don\u2019t think that means the\ndefault across all of Rust should be unwinding: it\u2019s more like \u201csomething you\nneed in a narrow part of your codebase so you can convert to Result\u201d.\n\n## Conclusion\n\nI think the argument for deprecating unwinding boils down to this: unwinding\npurports to make cheap recovery tenable, but it\u2019s not really reliable in the\nface of shared state. Meanwhile, it puts limits on what wec an do in the\nlanguage, ultimately decreasing reliability (because we can\u2019t guarantee\ncleanup is done) and ease of use (borrow checker is stricter, APIs that would\nrequire cleanup can\u2019t be written).\n\nHow could we deprecate it, though? It would basically become part of the ABI,\nmuch like C vs C-unwind. It\u2019d be possible to opt-in on a finer-grained basis.\nIn functions that are guaranteed not to have unwinding, the borrow checker\ncould be more permissive, and must-move types could be supported.\n\nI\u2019m definitely tempted to sketch out what deprecating unwinding might look\nlike in more detail. I\u2019d be curious to hear from folks that rely on unwinding\nto better understand where it is useful\u2014 and if we can find alternatives that\nmeet the need in a more narrowly tailored way!\n\n  1. For a time, we were exploring an alternative approach to panics called signals that didn\u2019t use unwinding at all \u2013 the idea was that, for each error condition, you would expose a hook point (a \u201csignal\u201d) that users could customize to control what to do in the case of error. This proved a bit too unfamiliar and kind of a pain in practice, and we wound up backing away from it. Today\u2019s panic hook is sort of a simpler version of that (it doesn\u2019t support in-place recovery, but it does enable in-place cleanup). \u21a9\ufe0e\n\n", "frontpage": false}
