{"aid": "40112722", "title": "Id30: Humanized IDs for URLs and More", "url": "https://magnushoff.com/blog/id30/", "domain": "magnushoff.com", "votes": 1, "user": "maggit", "posted_at": "2024-04-22 09:39:06", "comments": 0, "source_title": "Id30", "source_text": "Id30 \u2013 magnushoff.com\n\n# Id30\n\nHumanized IDs for URLs and more, by Magnus Hovland Hoff\n\n2024-04-10\n\nId30 is an encoding scheme for identifiers I have designed for use in URLs,\nand implemented in Rust. It is also a good fit for single-use keys meant to be\ncopied to another device, such as login codes sent via SMS or displayed on a\nTV screen. Id30 looks like the following: bpv3uq, zvaec2, rfmbyz, jwygvk or\neven 000000 and zzzzzz. Example URLs could be:\n\n  * https://example.com/item/n3znmz or\n  * https://example.com/watch?v=7rbjvz\n\nWhile the encoding is simply base 32 with a specific alphabet, decoding\nadditionally handles some confusable characters as well as case insensitivity.\nThe short IDs along with the leniency in decoding makes Id30 well-suited for\nreading, writing and transmitting verbally. This is an apparent niche use-case\nthat I found worth designing for when I discovered I had users struggling to\nverbally transmit URLs I had given them containing UUIDs, like\nhttps://example.com/item/{4d5edfae-a082-4b8f-a278-0fb1d43d504b} ..! It is easy\nfor the technically savvy to know to refuse typing such strings by hand, but\nother users aren't necessarily as sophisticated. And it's not always easy to\ncopy and paste a URL across all sorts of devices. In addition to computers,\nmobile phones and tablets, there are set-top boxes, smart TVs and other smart\ndevices that may need to display or input a URL, or even transmit one by\nspeech recognition or synthesized speech.\n\nTo keep the identifiers short, the key space is limited to 30 bits. A base 32\nencoding was chosen to allow case insensitivity and correction of confusables,\nand to work well with binary numbers. Each character then encodes five bits\n(since 25 = 32), giving six characters for 30 bits. 30 bits fit well within a\n32 bit integer, wasting only two bits.\n\nIs a 30 bit key space practical? That's just over 109 identifiers. For\ncomparison, YouTube's count of videos passed this threshold only in 2019 and\nis now up to four times as much (source). There's the old adage that you\nshould dress for the job you want, not the job you have. I think a lot of good\ncould come of designing web services for the scale you have, or are\nrealistically going to have, instead of the scale you're dreaming of.\n\nId30 looks its best when used for IDs that are randomly generated, otherwise\nyou'll end up with runs of very similar-looking IDs, like 00014a, 00014b,\n00014c, ... and so on. There are other reasons for using randomly generated\nIDs as well: user-facing sequential IDs can leak business sensitive\ninformation, such as count of users or other items in the database, and they\ncan exacerbate security breaches. Id30 leans into this and assumes that the\nIDs are randomly generated. How does that work out with a 30 bit key space?\nWith random generation, a collision could occur at any time, so verifying that\na new ID is unused is a prudent step. From the birthday paradox, we learn that\nthe probability of a collision having ever occured reaches 50% as the count of\nIDs reaches the square root of the key space size: \u221a2^30 = 2^15 = 32.768. So\nuntil reaching this number of IDs, the likelihood of having had a collision\nstays below 50%. That's a good anchor point, but what would be more\ninteresting is the function that gives you the expected number of attempts for\nsuccessfully generating a new ID given the count of IDs already in use. Maybe\nI'll take the time to figure out that function one day.\n\nAnother idea that's been floated to me is to rely on encryption to conceal\nsequential IDs. The gist of that idea is to use sequential IDs in the\ndatabase, which is typically helpful for database performance, and symmetric\nencryption (such as AES) to transform the IDs when exposing them to the user,\ndecrypting them when going the other way. This has some good properties,\nincluding that it is stateless. However, it unfortunately does not combine\nwell with Id30, because the ID size in this scheme must equal (or be an\nintegral multiple of) the block size of the cipher. Something to look into\nanother time, I suppose.\n\n## Encoding and decoding\n\nEncoding table  \n---  \nValue| Encodings  \n0| 0| o, O  \n1| 1| i, I, l, L  \n2| 2  \n3| 3  \n4| 4  \n5| 5  \n6| 6  \n7| 7  \n8| 8  \n9| 9  \n10| a| A  \n11| b| B  \n12| c| C  \n13| d| D  \n14| e| E  \n15| f| F, s, S  \n16| g| G  \n17| h| H  \n18| j| J  \n19| k| K  \n20| m| M  \n21| n| N  \n22| p| P  \n23| q| Q  \n24| r| R  \n25| t| T  \n26| u| U  \n27| v| V  \n28| w| W  \n29| x| X  \n30| y| Y  \n31| z| Z  \n  \nEncoding is simple. Given a 30 bit integer, split it into six five-bit chunks\nand encode each chunk individually by table-lookup:\n\nGiven number (base 10)| 378038020  \n---|---  \nIn base 2| 010110100010000110011100000100  \nFive-bit chunks (base 2)| 01011| 01000| 10000| 11001| 11000| 00100  \nFive-bit chunks (base 10)| 11| 8| 16| 25| 24| 4  \nFive-bit chunks, encoded| b| 8| g| t| r| 4  \nId30| \u2728 b8gtr4 \u2728  \n  \nThis encoding scheme allows fast implementations and gives strings that sort\nin the same sequence as the integer representation.\n\nDecoding is more involved to allow for alternative encodings, including case\ninsensitivity, and for input validation. Let's first go through the simple\ncase of decoding a valid Id30 in canonical encoding, which is just the above\nencoding process in reverse:\n\nGiven Id30| b8gtr4  \n---|---  \nEach character| b| 8| g| t| r| 4  \nDecoded by lookup table| 11| 8| 16| 25| 24| 4  \nIn base 2| 01011| 01000| 10000| 11001| 11000| 00100  \nComposed| 010110100010000110011100000100  \nAs base 10| 378038020  \n  \nDecoding should detect whether the given ID is canonical or not. We implement\nthis by adding an additional set bit, 0x20 = 32, for all alternative\ncharacters in the decoding table. The alternative characters are:\n\n  * All upper-case letters\n  * o/O as alternatives to 0, for visual similarity\n  * i/I and l/L as alternatives to 1, for visual similarity\n  * s/S as alternatives to f/F, for verbal similarity\n\nLet's say we were given an upper-case version of the same ID as above:\n\nGiven Id30| B8GTR4  \n---|---  \nEach character| B| 8| G| T| R| 4  \nDecoded by lookup table| 43| 8| 48| 57| 56| 4  \nIn base 2| 101011| 001000| 110000| 111001| 111000| 000100  \n  \nNow, let is_canonical be true if, and only if, all the 0x20-bits are zero. We\ncan find is_canonical by simple bit-testing, maybe after combining all the\nvalues with binary OR. is_canonical should be used for redirecting users to\ncanonical versions of your URLs, otherwise you will end up serving the same\nresource from multiple URLs, and that's both frowned upon by search engines\nand bad for caching. Note that the redirection does not require any database\nlookup or permissions checking. Since it is a syntactic fix only, it doesn't\nmatter if the target URL is present, absent, behind login or whatever else:\nfirst redirect to the canonical URL, then let that URL handler deal with the\ncomplexities.\n\nFor input validation, first verify that the length of the input is six bytes.\nIf it is, we still have to verify that all the bytes are valid code bytes, ie\nthat they are letters or numbers. A simple implementation is to use a lookup\ntable of size 256 to account for all possible input bytes, fill in all the\ncanonical and alternative encodings, and fill the rest with 0x40 = 64, a\nhitherto unused bit. If any of the decoded values have this bit set, we reject\nthe input as invalid.\n\nThe encoding and decoding tables are included as JSON at the bottom of this\npost.\n\n## Q&A\n\n### How does this compare to Sqids?\n\nSqids is another ID encoding scheme which also yields short strings, but there\nare numerous small differences beyond that, due to different design decisions.\n\nId30| Sqids  \n---|---  \nCase sensitivity| Case insensitive| Case sensitive  \nConfusable character handling| Yes| No  \nSequences look...| sequential| random1  \nPreserves sort order| Yes| No  \nBuilt-in word filtering| No| Yes  \nKey space size| 30 bits \u2248 109 IDs| Arbitrary  \nEncoded ID size| 6 chars| Variable  \nDecoded ID size| 4 bytes = 32 bits| Arbitrary  \nAlphabet| Fixed| Configurable  \nComplexity| Simpler| More complex  \n  \n1 While sequential IDs look random in Sqids, the documentation calls out that\nthis should not be relied on to conceal the sequence: they can still be\ndecoded to reveal the underlying numbers.\n\n### But what about rude IDs in Id30?\n\nAll six-char sequences of the encoding alphabet are valid Id30s, and some of\nthese will be considered rude or offensive by some subset of the population.\nThe inherent difficulty in this is that what might be considered inappropriate\nvaries by population and time. Handling this is out of scope for Id30, so to\nkeep your IDs safe in this sense, you have to make use of a library designed\nfor that, such as rustrict for Rust, and filter IDs at generation time.\n\nFor reference, these are the encoding and decoding tables as JSON:\n\nENCODING, as a string: \"0123456789abcdefghjkmnpqrtuvwxyz\"\n\nENCODING, to ASCII values: [48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 97, 98,\n99, 100, 101, 102, 103, 104, 106, 107, 109, 110, 112, 113, 114, 116, 117, 118,\n119, 120, 121, 122]\n\nDECODING: [64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,\n64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,\n64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9,\n64, 64, 64, 64, 64, 64, 64, 42, 43, 44, 45, 46, 47, 48, 49, 33, 50, 51, 33,\n52, 53, 32, 54, 55, 56, 47, 57, 58, 59, 60, 61, 62, 63, 64, 64, 64, 64, 64,\n64, 10, 11, 12, 13, 14, 15, 16, 17, 33, 18, 19, 33, 20, 21, 32, 22, 23, 24,\n47, 25, 26, 27, 28, 29, 30, 31, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,\n64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,\n64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,\n64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,\n64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,\n64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,\n64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,\n64, 64, 64, 64, 64, 64, 64, 64]\n\nThanks to Haakon Nilsen for discussing the drafts to this blog post with me!\n\nMagnus Hovland Hoff, 2024\n\n", "frontpage": false}
