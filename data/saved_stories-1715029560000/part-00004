{"aid": "40275139", "title": "New Disposable APIs in JavaScript", "url": "https://jonathan-frere.com/posts/disposables-in-javascript/", "domain": "jonathan-frere.com", "votes": 1, "user": "thunderbong", "posted_at": "2024-05-06 14:31:28", "comments": 0, "source_title": "Jonathan's Blog", "source_text": "New Disposable APIs in Javascript | Jonathan's Blog\n\n# Jonathan's Blog\n\n# New Disposable APIs in Javascript\n\nPosted 6th May 2024 in Tips, Javascript, Programming\n\nCover image based on Waldlandschaft mit Sonnenaufgang, Joseph Rebell (1809)\nBelvedere, Vienna\n\nJavascript\u2019s new \u201cExplicit Resource Management\u201d proposal adds the using\nstatement, a way to automatically close resources after you\u2019ve finished using\nthem. But as part of the same proposal, a number of other APIs have been added\nthat make using even more useful. I couldn\u2019t find a lot of documentation out\nthere when I was trying to figure out how these APIs work, so this article is\na bit of an overview of getting started with using, Disposables, and explicit\nresource management.\n\n## The Journey to Using using\n\nMany classes or objects represent some sort of resource, such as an open file\nor a database connection, that requires some cleanup logic when that resource\nis no longer in use. In NodeJS, the convention is typically to put this\ncleanup in a close() function. For example, the Server class in node:http has\na close() method that stops new connections and closes existing ones.\n\nThe problem with close alone is that it\u2019s easy not to call it. Sometimes it\u2019s\na matter of forgetting, but often errors and exceptions can trip us up.\nConsider this function:\n\n    \n    \n    async function saveMessageInDatabase(message: string) { const conn = new DatabaseConnection(); const { sender, recipient, content } = parseMessage(); await conn.insert({ sender, recipient, content }); await conn.close(); }\n\nThis creates a database connection at the start of the function, and closes it\nat the end. But we have a problem if parseMessage or conn.insert(...) throw an\nerror \u2014 in this situation, the saveMessageInDatabase function will stop\nwithout closing the connection, leaving unclosed resources hanging around.\n\nThe first step to solving this is to formalise how a resource gets closed. We\ncan do this using the Disposable interface or protocol:\n\n    \n    \n    interface Disposable { [Symbol.dispose]: () => void; }\n\nThis is very similar to methods like .close(), .cancel(), and so on, but we\nuse the well-known symbol Symbol.dispose instead. This helps the runtime to\ndistinguish between objects that have been intentionally made disposable\n(using this symbol), and objects that happen to have a certain name (e.g.\ndoor.close()).\n\nWith this in place, we can define the using syntax. using can be used in much\nthe same way as const, and behaves very similarly in most respects.\n\n    \n    \n    // was: const varName = new MyDisposableObject(); // now: using varName = new MyDisposableObject(); varName.method();\n\nHowever, using has a couple of restrictions in addition to the normal\nbehaviour of const:\n\n  * With using, the variable must implement the Disposable protocol \u2014 i.e. it must have a Symbol.dispose method that can be called without arguments.\n  * With using, you cannot destructure the variable you\u2019re interested in (e.g. using { field1, field2 } = disposable()).\n\nWhen we leave the scope where a using variable was defined (i.e. when we\nreturn from the function in which using was used, or leave the if-block, or an\nexception gets thrown, etc), then the Symbol.dispose method will be called.\n\nIn addition, the dispose methods will be called in the reverse order to the\nway they were defined. So the object that was created first will be disposed\nof last. This reverse order is deliberate: we don\u2019t want the database to be\ncleaned up while other resources are still using it!\n\nAn example:\n\n    \n    \n    function create(data: string) { console.log(`creating disposable object with data ${data}`); return { data: data, [Symbol.dispose]() { console.log(`disposing disposable object with data ${data}`); }, } } function main() { using data1 = create(\"first\"); using data2 = create(\"second\"); console.log(`using ${data1.data} and ${data2.data}`); } console.log(\"before main\"); main(); console.log(\"after main\");\n\nThis will produce the following logs:\n\n    \n    \n    before main creating disposable object with data first creating disposable object with data second using first and second disposing disposable object with data second disposing disposable object with data first after main\n\n## Async Disposables\n\nOften, when we want to dispose of a resource in Javascript, that\ncleanup/close/disposal operation will need to be asynchonous \u2014 for example due\nto waiting for connections to be cleaned up or data to be flushed.\n\nSo in addition to the standard Disposable protocol, there\u2019s a second one,\nAsyncDisposable. This uses the Symbol.asyncDispose method, which returns a\npromise that should resolve when the resource is completely closed.\n\nTo use an async disposable, we have the await using syntax, which does the\nsame thing as a normal using declaration, but, well, asynchronously. It must\nbe called inside an async function (i.e. it needs to be called in a place\nwhere normal await is allowed).\n\nThe await using syntax can also handle non-async Disposable objects, which\nmeans if you don\u2019t know whether a given resource is going to be asynchronously\nor synchronously disposed, you can use await using and cover both options.\n\nawait using| using  \n---|---  \nUsable In:| async functions only| async and sync functions  \nProtocol:| AsyncDisposable + Disposable| only Disposable  \nSymbol:| Symbol.asyncDispose/Symbol.dispose| Symbol.dispose  \n  \n## Collections of Disposables\n\nSometimes it\u2019s not enough to use function scope to handle resources. We might\nhave a class or object that owns and manages a number of different resources.\nIt would be useful if we could group all of its resources together in a\nsimilar way to using, but as a class variable or as part of a closure.\n\nOne convenient way of doing this is using the DisposableStack and\nAsyncDisposableStack classes. These represent stacks of resources managed by\nthe DisposableStack or AsyncDisposableStack object \u2014 if we clean up the stack,\nall the resources that it manages will also get cleaned up. They can be\ncreated using the new operator, and provide three different methods for adding\nresources to the stack:\n\n    \n    \n    const stack = new DisposableStack(); // or ` = new AsyncDisposableStack()` // .use() takes a resource, adds it to the resources managed by the stack, // and returns the resource so it can be used elsewhere. // The resource must be a disposable item using the `Symbol.dispose` method // (or `Symbol.asyncDispose` if using `AsyncDisposableStack`). const resource1 = stack.use(new MyResource()); // `.defer()` schedules a callback to take place when the stack gets disposed. const handle = setInterval(() => console.log(\"running\"), 5000); stack.defer(() => clearInterval(handle)); // .adopt() combines the above two behaviours: it takes a resource and a // disposal callback, and calls the callback with the resource as its argument // when the stack gets disposed. The resource does _not_ need to implement // the disposable protocol. const resource2 = stack.adopt(new OtherResource(), (r) => r.close());\n\nStacks are themselves disposable, so can be disposed of using the\nSymbol.dispose or Symbol.asyncDispose methods. For convenience, this method is\nalso exposed simple as .dispose() or .asyncDispose(). As mentioned earlier,\nthis method (either using Symbol.dispose/Symbol.asyncDispose or via the alias\nmethod) will dispose of all of the resources managed by this stack. Similarly\nto the using declaration, the resources will be cleaned up in reverse order to\nprevent issues where resources depend on each other.\n\nAsyncDisposableStack| DisposableStack  \n---|---  \nImplements:| AsyncDisposable| Disposable  \nManages:| AsyncDisposable + Disposable| only Disposable  \nDispose With:| .disposeAsync()| .dispose()  \n  \n## Useful Patterns with Explicit Resource Management\n\nHopefully by now it should be clear what disposable resources are, how they\ncan be manipulated, etc. But it still took me a while to get my head around\nsome typical patterns with disposables, how they can be manipulated, and some\nbest practices. So here are a few short sections which explain a couple of\nideas that are now possible, and the best ways to achieve some common goals.\n\n### Anonymous Defers\n\nIf you\u2019re coming from other languages with features similar to using, such as\nGo with its defer statement, then you may be surprised that using is really a\nvariable declaration \u2014 it\u2019s basically the same as const or let, but it also\nautomatically cleans up resources when the function has completed.\n\nAs a result, every time you use using, you need to declare a variable name.\nBut often you don\u2019t want to specify a variable name \u2014 e.g. if you want to\ndefer a callback until the end of the function. It\u2019s possible to do something\nlike using _ = ..., using _ as a kind of informal placeholder, but this only\nworks once per function body.\n\nThe best solution I\u2019ve found is DisposableStack (or AsyncDisposableStack) and\nthe defer method:\n\n    \n    \n    function main() { using stack = new DisposableStack(); console.log(\"starting function\"); stack.defer(() => console.log(\"ending function\")); console.log(\"during function body\"); }\n\n### Disposable Timeouts and Intervals\n\nThe specification gives a list of various browser and JS APIs that will be\nretrofitted with the disposable mechanism, but one API that is noticeably\nmissing is the setInterval and setTimeout functions. Currently, they can be\ncancelled using the clearInterval and clearTimeout functions, and we can use\ndefer to integrate them into a disposable stack:\n\n    \n    \n    function main() { using stack = new DisposableStack(); const handle = setInterval(() => {/* ... */}, 5000); stack.defer(() => clearInterval(handle)); // ... }\n\nIn fact, if you\u2019re using NodeJS, you can go one better. The NodeJS timers\n(i.e. setInterval and friends) already return an object (Timeout) with lots of\nuseful functions like .unref(). Recent versions of v18 and upwards now also\ninclude a Symbol.dispose key for these objects, which means you can simplify\nthe above code to this:\n\n    \n    \n    function main() { using setInterval(() => {/* ... */}, 5000); // ... }\n\nAnd in the browser, we can write a similar utility function:\n\n    \n    \n    export function interval(...args: Parameters<typeof setInterval>): Disposable { const handle = setInterval(...args); return { [Symbol.dispose]: () => clearInterval(handle) }; }\n\n### The Use-and-Move Maneuver\n\nOne more subtle but incredibly powerful method in the DisposableStack arsenal\nis .move(). This creates a new stack, moves all of the resources in the\ncurrent stack into the new stack, and then marks the original stack as\ndisposed. None of the resources will be disposed except for the original\nstack.\n\nThis is a powerful tool for anywhere where you\u2019re creating resources for use\nelsewhere (so you want to put them in a stack), but the very act of creating\nresources is something that might fail (so you want to be using that stack\nwhen you create them.\n\nConsider this example, which can cause resource leakages:\n\n    \n    \n    export function badOpenFiles( fileList: string[] ): { files: File[] } & Disposable { const stack = new DisposableStack(); const files = []; for (const fileName of fileList) { files.push(stack.use(open(fileName))); } return { files, [Symbol.dispose]: () => stack.dispose(), }; }\n\nIf I call this with a list of files, it\u2019ll open all of those files and return\nthem as single disposable object, that when it gets disposed of, closes all\nthe files again.\n\nBut let\u2019s say I call this with the file list [\"file1.txt\", \"file2.txt\", \"file-\ndoes-not-exist.txt\", \"file4.txt\"]. Now, the first two files get created and\nadded to the stack, but the third one causes an error, which exists the\nfunction. But because the stack was never added to a using declaration\nanywhere, those files will never be closed, which causes resource leakage.\n\nThe .move() function allows us to do this instead:\n\n    \n    \n    export function openFiles(fileList: string[]): { files: File[] } & Disposable { // Note we use the stack here, which means this stack will be cleaned up // when we return from the function. using stack = new DisposableStack(); const files = []; for (const fileName of fileList) { files.push(stack.use(open(fileName))); } // We've successfully created all the files with no errors. // Move the opened file resources out of the stack, and into a new // one that won't get closed at the end of this function. const closer = stack.move(); return { files, [Symbol.dispose]: () => closer.dispose() }; }\n\n### The Disposable Wrapper\n\nRight now, Disposables are still relatively new, and so it\u2019s not unlikely that\nthe library you\u2019re working with doesn\u2019t support them, opting instead for a\n.close() method or something similar. But Javascript is a dynamic language, so\nit\u2019s not too hard to get these tools to behave. Here\u2019s an example for MongoDB,\nwhich at the time of writing does not support using or any of the disposable\nprotocols:\n\n    \n    \n    function createMongoClient( connection: string, options?: MongoClientOptions ): MongoClient & Disposable { const client = new MongoClient(connection, options); if (client[Symbol.asyncDispose]) throw new Error(\"this code is unnecessary\"); return Object.assign(client, { [Symbol.asyncDispose]: () => client.close() }); }\n\nThis will add a Symbol.asyncDispose method to the client, meaning you can use\nit in await using declarations and with AsyncDisposableStack#use(). In\naddition, if you ever update to a version of MongoDB that does implement the\nAsyncDisposable protocol, you\u2019ll get an error reminding you to delete the\ncode.\n\n### Awaiting Signals\n\nA common pattern for NodeJS servers is to start up the web server, and then\nadd event handlers for the OS\u2019s \u201cquit\u201d signals (e.g. SIGINT). Inside these\nhandlers, we can shut the server down, clean up resources, etc.\n\nThis works fine, but the control flow can be difficult to follow, and we have\nto manually call the Symbol.dispose and Symbol.asyncDispose methods where\nthat\u2019s relevant. It would be nice if there was a way to tie the lifetime of\nthe application to the lifetime of a single function, so that when that\nfunction exits, the server will also automatically exit, closing and disposing\nof all resources along the way.\n\nEnter NodeJS\u2019s once function, which converts an event into a promise^1:\n\n    \n    \n    import { once } from \"node:events\"; // waits until the `SIGINT` signal has been triggered, e.g. from Ctrl-C await once(process, \"SIGINT\");\n\nUsing this, we can write a main() function that lives for the entire length of\nthe application, and quits when the application is stopped, automatically\ncleaning up any resources after itself:\n\n    \n    \n    async function main() { await using stack = new AsyncDisposableStack(); await using resource = createResource(); // ... etc, for as many resources as make sense // alternatively, use the \"Disposable Wrapper\" pattern from earlier const server = stack.adopt(express(), server => server.close()); // add routes, use resources, etc server.get(/* ... */); logger.info(\"starting application on port 5000\"); server.listen(5000, () => logger.info(\"application started\")); await Promise.race([ once(process, \"SIGINT\"), // Ctrl-C once(process, \"SIGTERM\"), // OS/k8s/etc requested termination // etc. ]); logger.info(\"shutting down application\"); }\n\nBecause all of our resources are managed either by using directly, or by the\nstack which is in turn tied to the application\u2019s lifespan, we don\u2019t need to\nmanually close anything after the signals have been handled \u2014 everything will\nautomatically be gracefully shutdown.\n\n## Using Explicit Resource Management Today\n\nRight now, explicit resource management is a stage three proposal \u2014 that means\nthat the specification has been completed and approved, and browsers and other\ntools are encouraged to start implementing the proposal, and trying the\nfeature out in practice^2.\n\nThis means that if you want to try this feature out right now, you\u2019re going to\nneed to transpile the syntax to a format supported by older browsers, and\nprovide a polyfill for the various global objects that the feature requires.\n\nIn terms of transpiling, both Typescript and Babel support the using ...\nsyntax. For Typescript, you\u2019ll need version 5.2 or greater to handle the\nsyntax. In the tsconfig.json file, the target should be ES2022 or lower in\norder to do the transpilation (otherwise Typescript will leave the syntax\nunchanged), and the lib setting should include esnext.disposable (or\nalternatively the whole esnext bundle of types) to ensure that the right set\nof types is included. For Babel, including the stage-3 preset, or explicitly\nadding the @babel/plugin-proposal-explicit-resource-management plugin should\nensure that everything gets compiled correctly.\n\nNeither Typescript nor Babel include a polyfill for the various global types\ndiscussed here, which means you\u2019ll also need a polyfill. For this, there are\nvarious options, including disposablestack, which I\u2019ve been using, and CoreJS.\n\n## Bringing It All Together\n\nLet\u2019s say we\u2019re writing something on the backend, and there\u2019s a lot of\ninteractions with users. We want a class that handles all of our user-based\nlogic:\n\n  * It can create/read/update/delete our user objects in the database\n  * It automatically deletes users that haven\u2019t been active in the last five minutes (we\u2019re very GDPR conscious here, we don\u2019t keep data a second longer than we need to)\n  * It provides a stream of all the new users inserted into the database, so that elsewhere we can send them a lovely greeting message.\n\nWe\u2019ll use dependency injection so that we don\u2019t need to create the database\nconnection ourselves, but some of the resources will be managed by the user\nservice. We can use the AsyncDisposableStack to group those resources\ntogether, and we\u2019ll add a Symbol.asyncDispose method that delegates to the\nstack\u2019s dispose method to handle that disposal. We can even implement\nTypescript\u2019s AsyncDisposable interface to make sure that we get everything\nright:\n\n    \n    \n    export class UserService implements AsyncDisposable { #conn: DB.Conn; #stack = new AsyncDisposableStack(); #intervalHandle: NodeJS.Timeout; #streamHandle: DB.StreamHandle; constructor(conn: DB.Conn) { // Our DB connection, passed in via dependency injection -- so we don't want // to add this to the set of resources managed by this service! this.#conn = conn; // Remember, NodeJS's `Timeout` class already has a `Symbol.dispose` method, // so we can add that to the stack this.#timeoutHandle = this.#stack.use( setInterval(() => this.deleteInactiveUsers(), 60 * 1000) ); // For resources that don't have the right methods, `.adopt()` is the // easiest way to add an \"on dispose\" cleanup function this.#streamHandle = this.#stack.adopt( this.#createNewUserStream(), // Closing this stream is an async operation, hence why we're using // Symbol.asyncDispose, AsyncDisposableStack, etc. async (stream) => await stream.close() ); } async [Symbol.asyncDispose]() { await this.#stack.dispose(); } // ... methods and implementation details }\n\nNow we need to actually construct all of our resources somewhere. We can add a\ncreateResources function that creates the resources, returns a disposable\nobject that cleans up all of the resources together, and also ensures that if\nan error occurs during resource construction, everything will still get\ncleaned up gracefully \u2014 this is the power of the stack!\n\n    \n    \n    export async function createResources(config: Config) { await using stack = new AsyncDisposableStack(); const db = new MyDbDriver(config.connectionString); const conn = stack.use(await db.connect()); // When the stack disposes of its resources, the `UserService` will be cleaned // up before the `conn`, which prevents errors where the `UserService` is // trying to use a connection that doesn't exist anymore. const userService = stack.use(new UserService(conn)); // Now all the resources have been set up, use .move() to create a new stack // and return a dispose method based on the new stack. const closer = stack.move(); return { userService, [Symbol.asyncDispose]: async () => await closer.dispose(), }; }\n\nNow finally, we need to plug all of this into our server implementation, and\nmake sure that everything gets cleaned up when the server gracefully exits. We\ncan use signals and promises to catch the events that should trigger a\nshutdown, and use the using declarations to automatically clean up any\nresources.\n\n    \n    \n    async function main() { const config = await loadConfig(); using resources = createResources(config); using stack = new AsyncDisposableStack(); // create wrapper functions around APIs that don't yet support disposables using server = createFastify({}); server.get(/* route using resources.userService */) await server.listen({ port: 3000 }) logger.info(\"server running on port 3000\"); // use `once` to turn one-time events into promises await Promise.race([ once(process, \"SIGINT\"), once(process, \"SIGTERM\"), once(process, \"SIGHUP\"), ]); logger.info(\"server terminated, closing down\"); // resources will all be cleaned up here }\n\n## More Resources\n\nThere\u2019s a lot more information out there about the explicit resource\nmanagement proposal, but given how Google isn\u2019t working as well as it once\nwas, here are some links to help you find it:\n\n  * The original proposal in the TC39 GitHub organisation. The documentation is a bit technically-focussed here, but the issues provide a lot of good context for the APIs, and a number of examples that explain why certain decisions were made.\n  * Typescript 5.2\u2019s release notes include a section about resource management, how to use it, and how to get it working in Typescript.\n  * Various tickets/bugs/issues about implementing explicit resource management:\n\n    * Chrome\n    * Firefox\n    * Safari\n  * Prior art in other languages:\n\n    * C#\u2019s using statement is a big influence here.\n    * Go\u2019s defer statement inspired the .defer method.\n    * Python\u2019s ExitStack is an explicit inspiration for the DisposableStack and AsyncDisposableStack classes.\n\n  1. Note that if you don\u2019t have access to NodeJS, you can replicate this functionality using new Promise(...) manually, although this can be tricky to do properly as it\u2019s difficult to ensure that resources get correctly cleaned up once an event has been triggered. \u21a9\ufe0e\n\n  2. For the people who like that sort of thing, you can see the tickets where this is being implemented for Chrome, Firefox, and Safari. \u21a9\ufe0e\n\nThis work is licensed under CC BY-SA 4.0\n\n", "frontpage": false}
