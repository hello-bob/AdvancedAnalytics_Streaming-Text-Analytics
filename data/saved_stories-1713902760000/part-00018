{"aid": "40130302", "title": "The last days of my type checker for JavaScript", "url": "https://jsmonk.github.io/2024-01-29-last-days-of-hegel/", "domain": "jsmonk.github.io", "votes": 8, "user": "bk496", "posted_at": "2024-04-23 10:22:09", "comments": 0, "source_title": "The last days of my type checker for JavaScript", "source_text": "The last days of my type checker for JavaScript\n\n# The last days of my type checker for JavaScript\n\nPosted on January 29, 2024\n\nTL;DR Last year, I started to work on the 2.0 version of my static type\nchecker for JavaScript written in Rust, but, unfortunately, I see that\nnowadays, TypeScript won. The idea of strict type-checking for JavaScript is\nless popular than in 2019. Additionally, another way to bring stricter types\ninto the web exists. So, I lost my belief that there could be an audience for\nsuch a tool and decided to close the project.\n\n## To make the story short\n\nAt the beginning of 2019, I worked in a small outsourcing company called\nWookieeLabs. In most of the projects, we preferred to use Flow over the\nTypeScript. There were a lot of benefits such as nominal classes, type\nvariances, opaque types, smooth integration with React. But the main reason\nwas that Flow in 2019 was just JavaScript with types.\n\nBut the way Flow type inference was working in 2019 was not ideal:\n\n    \n    \n    const id = x => x; const a = id(2); // number | string const b = id(\"string\"); // number | string\n\nYou can play with this example here\n\nSo, Flow analyzed the usage of the function and, based on it, inferred the type of a function. In the example above, we provided to the id function a number and a string, so, based on the usage, the tool infered the type of the id as (x: number | string) => number | string.\n\nHowever, the Flow team did a significant job of fixing such behavior by\nrequiring annotations in places where the tool knows it will not have a local\ntyping context. You can read about it here.\n\nAt the same time, there was hype about the new \u201clanguage\u201d (syntax for OCaml)\ncalled ReasonML (today there is also an alternative project called ReScript).\n\nAnd I was wondering, what if we take the power of the Hindley-Milner type\ninference, as strict as possible type system for JavaScript and the simple\nFlow like types syntax and combine it inside a single tool. So, I created\nHegel as my university bachelor project and started to talk about it at some\nconferences.\n\nYou can check the main differences in comparison with TypeScript here and with\nFlow here\n\nBut my favorite example that describes what the tool provides is this:\n\n    \n    \n    // The type of the function is: (string) => { name: string, ... } throws SyntaxError | TypeError function deserializeUser(stringifiedUserJson) { /* the result type is unknown because there is no `any` type */ const maybeUser = JSON.parse(stringifiedUserJson); /* it throws a SyntaxError, so it was added to the type signature */ if ( typeof maybeUser === \"object\" && maybeUser !== null // a proof that `maybeUser` is an object \"name\" in maybeUser && typeof maybeUser.name === \"string\" // a proof that there is a property called `name` with `string` type ) { return maybeUser; // the result type is { name: string, ... } } throw new TypeError(\"Provided serialized user is invalid!\"); } try { /* the type of `foo` is { name: string, ... } */ const foo = deserializeUser(\"42\"); } catch (e) { // the type of `e` is SyntaxError | TypeError | unknown }\n\n## And there were difficulties\n\nBecause most of the time I was the only contributor in the core modules,\nworking on a full-time job and continuing study as a master didn\u2019t give me\nenough time to contribute more, so there were (and still) a lot of issues and\nbugs, that should be fixed, so the development took a long time.\n\nAlso, speaking at local conferences didn\u2019t help a lot in finding a lot of new\ncontributors.\n\n> I want to thank everyone who supported me with the project, proposed\n> exciting ideas, and helped me prepare different examples. Some people also\n> helped me fix grammar mistakes in the documentation, review all the\n> sections, and set up the CI/CD. You all are unbelievable.\n\nAt some point (around March 2021), I struggled with all the COVID-19\nrestrictions and the rumors about the upcoming war between Ukraine and Russia.\nSo, my wife and I relocated to the Netherlands two months before the war\nstarted.\n\n> I also want to say a big thank you to JetBrains. You not only gave me the\n> possibility to work on such exciting projects but literally saved my and my\n> wife\u2019s lives.\n\nAfter a while, I started to rework the core system differently to support an\nincremental compilation (to improve analysis speed) and an intermediate\nrepresentation (to support multiple syntaxes, including TypeScript syntax; the\ntool had previously worked directly with the AST).\n\nBut during that time, I felt like I was trying to overtake a Ferrari, and the\ncommunity interest in such a project was already insignificant.\n\n## Reflection on the project\n\n> For today, I have only results for the State of JavaScript 2022, and as soon\n> as the results of State of JavaScript 2023 become available, I will update\n> the numbers.\n\nThe following things made me lose the belief that I should continue my work:\n\n  * The developers of TypeScript are doing an excellent language and working a lot on its improvement, so it is the most popular alternative for JavaScript nowadays (98.9% question respondents use TypeScript, the nearest competitor is Elm with the result 2.3%)\n  * JavaScript as a technology and community is already mature, so the new tools, frameworks, and libraries take a small part of the market. Here you can take a look on the usage of Deno (one of the Deno prototypes was presented in 2019) comparing to the Node.js, or the comparison of frameworks usage where we can see that the new frameworks such as Solid.js or qwik take 6% and 2%\n  * Based on my communication with different developers, I realized that TypeScript changed how developers think about the types in JavaScript. In 2019, people thought of types as the rules restricting the language for developing safer software (fewer bugs or unexpected runtime errors). Still, today, people think more about describing any (even not so secure) software with types. All of these fancy template literal types, conditional types, an unchecked body of assert functions and type predicates, and of course any, give people a fantastic tool to cover existed code with types but doesn\u2019t force to re-design it to make it safer.\n  * I see other opportunities to increase the language diversity on the web (further in the article)\n\nSo, primarily based on those things, I decided to close the project Hegel.\n\n## Other projects and other opportunities\n\nLast year, I unexpectedly realized what a big and fantastic job was done on\nwasm as a technology. Proposals such as GC proposal and Exception handling\nhelp to bring to the web more and more programming languages with stricter\ntype system that are already familiar to people, that have already a mature\necosystem of build tools, libraries, frameworks, but also Component Model\nproposes the solution to interop between of them, that means sharing parts of\nthe extensive ecosystems between each other.\n\nSo, this is one of the reasons why I decided to join Kotlin/Wasm team and\nfocus most of the time on helping to bring the amazing Kotlin and its\necosystem into the web.\n\nSuppose you are still looking for the analyzing tool for your JavaScript\nproject. In that case, you can bring your attention to a cool project called\nEzno, which provides strict type checking and also (because it\u2019s a full\ncompiler) focuses on optimizing your code. Ben is doing an incredible job.\n\nTags: OSS TypeScript Kotlin wasm\n\nShare: Twitter LinkedIn\n\n  * RSS\n  * GitHub\n  * Twitter\n  * Twitch\n\n2024 \u2022 Edit page\n\nPowered by Beautiful Jekyll\n\n", "frontpage": true}
