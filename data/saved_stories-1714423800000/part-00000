{"aid": "40199041", "title": "Implementing Scalable GitOps with Argo CD and ApplicationSets: A Case Study", "url": "https://aviadhaham.me/posts/implementing-gitops-with-argo-cd-and-applicationsets/", "domain": "aviadhaham.me", "votes": 2, "user": "aviadhaham", "posted_at": "2024-04-29 14:49:07", "comments": 0, "source_title": "Implementing Scalable GitOps With Argo CD and ApplicationSets: A Case Study", "source_text": "Implementing Scalable GitOps With Argo CD and ApplicationSets: A Case Study \u2013\naviadhaham.me\n\n# Implementing Scalable GitOps With Argo CD and ApplicationSets: A Case Study\n\n> This infrastructure was developed at Nexxen, where I\u2019m currently employed.\n\nTransitioning from the inefficient \u201cApp of Apps\u201d model, we adopted GitOps with\nArgo CD and ApplicationSets for improved efficiency and reliability. The old\nsystem, with its hunderds of declarative Argo Applications and frequent manual\nchanges them, was operationally taxing, error-prone and not scalable.\n\nThe shift to a declarative GitOps approach using ApplicationSets has\nsignificantly minimized manual interventions, enhancing the scalability and\naccuracy of our deployment processes.\n\nIn this blog post, I\u2019ll explore our approach to establishing a scalable and\nmaintainable GitOps infrastructure using the Argo CD ApplicationSets CRD.\n\nI will delve into how we:\n\n  1. Bootstrap and manage Argo CD configurations.\n  2. Structure our ApplicationSets and GitOps deployments repository for scalability (utilizing the git generator).\n  3. Leverage ApplicationSets to automate deployment processes.\n  4. Manage and scale our deployments across multiple clusters and environments.\n\n> I provided real examples, from two teams, Octo and Datamine2, to give you a\n> better understanding of how we structure our deployments.\n\n## Introduction to Our GitOps Setup\n\nWe divided our configurations into two repositories.\n\n  * The argocd-management repository, accessible only to system administrators, contains sensitive Argo CD configurations.\n\n  * Developers mainly use the gitops-deployments repository for deployment manifests.\n\n> This strategy safeguards our management configurations and aligns with the\n> principle of least privilege.\n\nOur GitOps framework is built around two main repositories:\n\n### argocd-management repository:\n\nManages Argo CD\u2019s foundational configurations, including AppProjects and\nApplicationSets.\n\n  * Example directory structure\n    \n        \u251c\u2500\u2500 app-of-appprojects.yml \u251c\u2500\u2500 app-of-appsets.yml \u251c\u2500\u2500 appprojects | \u251c\u2500\u2500 [more team based directories] \u2502 \u251c\u2500\u2500 octo \u2502 \u2502 \u251c\u2500\u2500 appproject-infra-non-prod.yml \u2502 \u2502 \u251c\u2500\u2500 appproject-infra-prod.yml \u2502 \u2502 \u251c\u2500\u2500 appproject-orphans-non-prod.yml \u2502 \u2502 \u251c\u2500\u2500 appproject-orphans-prod.yml \u2502 \u2502 \u2514\u2500\u2500 kustomization.yaml \u2502 \u251c\u2500\u2500 sunflower \u2502 \u2502 \u251c\u2500\u2500 appproject-datamine2-non-prod.yml \u2502 \u2502 \u251c\u2500\u2500 appproject-datamine2-prod.yml \u2502 \u2502 \u2514\u2500\u2500 kustomization.yaml \u2502 \u2514\u2500\u2500 kustomization.yaml \u251c\u2500\u2500 appsets | \u251c\u2500\u2500 [more team based directories] \u2502 \u251c\u2500\u2500 octo \u2502 \u2502 \u251c\u2500\u2500 appset-infra-non-prod.yml \u2502 \u2502 \u251c\u2500\u2500 appset-infra-prod.yml \u2502 \u2502 \u251c\u2500\u2500 appset-orphans-non-prod.yml \u2502 \u2502 \u251c\u2500\u2500 appset-orphans-prod.yml \u2502 \u2502 \u2514\u2500\u2500 kustomization.yaml \u2502 \u251c\u2500\u2500 sunflower \u2502 \u2502 \u251c\u2500\u2500 appset-datamine2-non-prod.yml \u2502 \u2502 \u251c\u2500\u2500 appset-datamine2-prod.yml \u2502 \u2502 \u2514\u2500\u2500 kustomization.yaml \u2502 \u2514\u2500\u2500 kustomization.yaml \u2514\u2500\u2500 bootstrap.yml\n\n### gitops-deployments repository:\n\nActs as the single source of truth for all declarative deployments within our\norganization.\n\n> This is a monorepo gitops repository that contains all the Kubernetes\n> manifests that are used/deployed across all the company.\n\n  * Example directory structure\n    \n        deployments \u2502 \u251c\u2500\u2500 [more team based directories] \u251c\u2500\u2500 octo \u2502 \u251c\u2500\u2500 infra \u2502 \u2502 \u251c\u2500\u2500 devlake \u2502 \u2502 \u2502 \u2514\u2500\u2500 envs \u2502 \u2502 \u2502 \u2514\u2500\u2500 prod \u2502 \u2502 \u2502 \u251c\u2500\u2500 appset_config.json \u2502 \u2502 \u2502 \u251c\u2500\u2500 kustomization.yaml \u2502 \u2502 \u2502 \u251c\u2500\u2500 ui_deployment_patch.yml \u2502 \u2502 \u2502 \u2514\u2500\u2500 values.yml \u2502 \u2502 \u2514\u2500\u2500 vault-auth \u2502 \u2502 \u2514\u2500\u2500 envs \u2502 \u2502 \u2514\u2500\u2500 prod \u2502 \u2502 \u251c\u2500\u2500 appset_config.json \u2502 \u2502 \u251c\u2500\u2500 kustomization.yaml \u2502 \u2502 \u2514\u2500\u2500 resources.yml \u2502 \u2514\u2500\u2500 orphans \u2502 \u251c\u2500\u2500 aws-search \u2502 \u2502 \u251c\u2500\u2500 base \u2502 \u2502 \u2502 \u251c\u2500\u2500 deployment.yml \u2502 \u2502 \u2502 \u251c\u2500\u2500 kustomization.yaml \u2502 \u2502 \u2502 \u2514\u2500\u2500 service.yml \u2502 \u2502 \u251c\u2500\u2500 envs \u2502 \u2502 \u2502 \u2514\u2500\u2500 prod \u2502 \u2502 \u2502 \u251c\u2500\u2500 appset_config.json \u2502 \u2502 \u2502 \u2514\u2500\u2500 kustomization.yaml \u2502 \u2502 \u2514\u2500\u2500 variants \u2502 \u2502 \u2514\u2500\u2500 prod \u2502 \u2502 \u251c\u2500\u2500 deployment.yml \u2502 \u2502 \u2514\u2500\u2500 kustomization.yaml \u2502 \u2514\u2500\u2500 another-app \u2502 \u251c\u2500\u2500 base \u2502 \u2502 \u251c\u2500\u2500 deployment.yml \u2502 \u2502 \u2514\u2500\u2500 kustomization.yaml \u2502 \u2514\u2500\u2500 envs \u2502 \u2514\u2500\u2500 prod \u2502 \u251c\u2500\u2500 appset_config.json \u2502 \u251c\u2500\u2500 consul_configmap.yml \u2502 \u251c\u2500\u2500 consul_deployment.yml \u2502 \u2514\u2500\u2500 kustomization.yaml \u2502 \u2514\u2500\u2500 datamine2 \u251c\u2500\u2500 datamine-amoeba-appprd \u2502 \u251c\u2500\u2500 base \u2502 \u2502 \u251c\u2500\u2500 deployment.yml \u2502 \u2502 \u251c\u2500\u2500 kustomization.yaml \u2502 \u251c\u2500\u2500 envs \u2502 \u2502 \u251c\u2500\u2500 non-prod-sandbox \u2502 \u2502 \u2502 \u251c\u2500\u2500 appset_config.json \u2502 \u2502 \u2502 \u251c\u2500\u2500 kustomization.yaml \u2502 \u2502 \u251c\u2500\u2500 non-prod-staging \u2502 \u2502 \u2502 \u251c\u2500\u2500 kustomization.yaml \u2502 \u2502 \u2514\u2500\u2500 prod \u2502 \u2502 \u251c\u2500\u2500 appset_config.json \u2502 \u2502 \u251c\u2500\u2500 kustomization.yaml \u2502 \u2514\u2500\u2500 variants \u2502 \u251c\u2500\u2500 prod \u2502 \u2502 \u251c\u2500\u2500 env.yml \u2502 \u2502 \u251c\u2500\u2500 kustomization.yaml \u2502 \u251c\u2500\u2500 sandbox \u2502 \u2502 \u251c\u2500\u2500 env.yml \u2502 \u2502 \u251c\u2500\u2500 kustomization.yaml \u2502 \u2514\u2500\u2500 staging \u2502 \u251c\u2500\u2500 env.yml \u2502 \u251c\u2500\u2500 kustomization.yaml \u2514\u2500\u2500 datamine-amoeba-catalog \u251c\u2500\u2500 base \u2502 \u251c\u2500\u2500 deployment.yml \u2502 \u251c\u2500\u2500 kustomization.yaml \u251c\u2500\u2500 envs \u2502 \u251c\u2500\u2500 non-prod-sandbox \u2502 \u2502 \u251c\u2500\u2500 appset_config.json \u2502 \u2502 \u2514\u2500\u2500 kustomization.yaml \u2502 \u251c\u2500\u2500 non-prod-staging \u2502 \u2502 \u2514\u2500\u2500 kustomization.yaml \u2502 \u2514\u2500\u2500 prod \u2502 \u251c\u2500\u2500 appset_config.json \u2502 \u2514\u2500\u2500 kustomization.yaml \u2514\u2500\u2500 variants \u251c\u2500\u2500 prod \u2502 \u251c\u2500\u2500 env.yml \u2502 \u251c\u2500\u2500 kustomization.yaml \u251c\u2500\u2500 sandbox \u2502 \u251c\u2500\u2500 env.yml \u2502 \u251c\u2500\u2500 kustomization.yaml \u2514\u2500\u2500 staging \u251c\u2500\u2500 env.yml \u251c\u2500\u2500 kustomization.yaml\n\n## Our Approach to Bootstrapping and Managing Argo CD\n\nAlthough ApplicationSets offer significant reductions in time and manual\nerrors by automating deployment processes, integrating them with Kustomize has\nelevated their effectiveness.\n\nBy managing ApplicationSets and AppProjects through Argo CD applications\nthemselves (app-of-appsets and app-of-appprojects) we have automated even the\napplication of these configurations to the cluster. This meta-management layer\nensures that all changes are self-maintaining and self-applying, which\nenhances automation and reduces the need for manual oversight even further.\n\n> We utlize the power of the Application CRD to manage the AppProjects, and\n> the Application factories, the ApplicationSets!\n\nBelow, I\u2019ll explain our approach more in detail:\n\n  * We start our setup with a bootstrap operation defined in the bootstrap.yml file, which contains all necessary configurations for initializing Argo CD.\n\n> At the time of writing this post, it only contains an AppProject manifest\n> (named management), that we use for the two root YAMLs I will mention below.\n\n  * In order to reconstruct our setup, the only manual steps we need to perform are the following:\n\n    1. Apply the bootstrap configuration:\n        \n                kubectl apply -f bootstrap.yml\n\n    2. Set up management for AppProjects and ApplicationSets:\n        \n                kubectl apply -f app-of-appprojects.yml kubectl apply -f app-of-appsets.yml\n\n  * To make changes (add, delete, or edit), simply update the appprojects and appsets directories using the kustomize structure. Each change will be automatically detected by either the app-of-appprojects or app-of-appsets respectively.\n\n### Diagram: How It\u2019s Working Together\n\n## Understanding Our ApplicationSet Approach\n\n  * Generators: Using generators, the ApplicationSet constructs a dynamic list of Argo CD applications to be managed. These generators use patterns and parameters defined in configuration files (like appset_config*.json that you\u2019ll see below) to determine which applications should exist (or be deleted).\n\n  * Scalability: This approach enables the ApplicationSet to scale efficiently, as it can automatically adjust the number of managed applications based on the repository\u2019s current state. New applications are created, and outdated ones are removed without manual intervention.\n\n  * Considerations:\n\n    * Any directory that won\u2019t have the appset_config*.json file or that won\u2019t match its appropriate ApplicationSet, will be ignored by the ApplicationSet.\n\n    * It\u2019s also important to make sure that no other ApplicationSet is targeting the same directory, as it may lead to conflicts and unexpected behavior.\n\n## Our ApplicationSets Strategies\n\nWe have two main strategies for our ApplicationSets:\n\n### GitLab Subgroup-based ApplicationSets\n\nApplicationSets are primarily organized per GitLab subgroup, automatically\ngenerating Argo CD Applications for each service or application within the\nsubgroup.\n\n  * \u201cOrphans\u201d ApplicationSets (for applications/repos that do not belong to any subgroup) As we have many applications that do not belong to any subgroup, we handle them as \u201corphans\u201d (both in terms of ApplicationSets and in the gitops-deployments repo).\n\n> Rationale: We encountered issues when creating an ApplicationSet that\n> watches the root hierarchy of the group, as it did not behave as expected.\n> Instead, we decided to separate the \u201corphans\u201d into a different directory and\n> handle the path logic in the CI using simple bash code. For more details on\n> how we resolved this issue, refer to the Q&A section.\n\n### Prod and Non-Prod Environments\n\n  * The production environments are handled by ApplicationSets that target directories with a prod prefix in their paths, and non-production environments with a non-prod prefix.\n\n> Rationale: By using prefixes for prod* and non-prod*, we can effectively\n> manage different types of deployments in separate ApplicationSets. This\n> approach also ensures that the user only needs to add these prefixes when\n> they want the deployments to be picked up and watched by the corresponding\n> ApplicationSet for deployment.\n\n### Examples ApplicationSet Manifests\n\nReal example ApplicationSets config that we use for our own DevOps team\n(\u201cOcto\u201d):\n\n  * Infra:\n    \n        apiVersion: argoproj.io/v1alpha1 kind: ApplicationSet metadata: name: octo-infra-prod namespace: argocd spec: generators: - git: repoURL: git@git.company.com:octo/gitops-deployments.git revision: main files: - path: deployments/octo/infra/**/envs/prod*/appset_config*.json template: metadata: name: \"octo-{{path[3]}}-{{cluster.name}}-{{env}}\" finalizers: - resources-finalizer.argocd.argoproj.io namespace: argocd spec: project: octo-infra-prod source: repoURL: git@git.company.com:octo/gitops-deployments.git targetRevision: main path: \"{{path}}\" destination: server: \"{{cluster.address}}\" namespace: \"{{namespace}}\" syncPolicy: automated: selfHeal: true prune: true syncOptions: - CreateNamespace=true\n\n  * Orphans:\n    \n        apiVersion: argoproj.io/v1alpha1 kind: ApplicationSet metadata: name: octo-orphans-prod namespace: argocd spec: generators: - git: repoURL: git@git.company.com:octo/gitops-deployments.git revision: main files: - path: deployments/octo/orphans/**/envs/prod*/appset_config*.json template: metadata: name: \"octo-{{path[3]}}-{{cluster.name}}-{{env}}\" finalizers: - resources-finalizer.argocd.argoproj.io namespace: argocd spec: project: octo-orphans-prod source: repoURL: git@git.company.com:octo/gitops-deployments.git targetRevision: main path: \"{{path}}\" destination: server: \"{{cluster.address}}\" namespace: \"{{namespace}}\" syncPolicy: automated: selfHeal: true prune: true syncOptions: - CreateNamespace=true\n\nThese ApplicationSets targets the orphans/infra directory within the octo\nsubgroup in the gitops-deployments repo, focusing on the prod environment.\n\n> For more details about the appset_config*.json files, refer to the Q&A\n> section.\n\n## Scale Strategies with ApplicationSets\n\nOur architecture leverages ApplicationSets to facilitate scalability in the\nfollowing ways:\n\n  * Deploying New Services: Adding a new directory in the gitops-deployments, to a path crawled by a specific ApplicationSet will make the ApplicationSet add another crawl (thanks to the globbing ** in the path), and so, if the rest of the path is matching the regex/path in the rest of the path, it will add your new service, including all its environments.\n\n  * Deploying the Same Service to Multiple Clusters: Adding a new JSON configuration file (matching the regex appset_config*.json) in the relevant envs directory automatically triggers the creation of a new Argo Application tailored to the specific parameters defined within the file.\n\n> This makes scaling out to additional clusters or deployment environments\n> seamless.\n\n  * Multi-environment Management (Prod/Non-Prod): By defining separate paths for different environments (like prod, non-prod-staging, non-prod-sandbox), ApplicationSets can manage deployments across multiple environments efficiently, creating distinct sets of applications for each environment.\n\n### Example of Environments (envs) Structure\n\nThe envs directory structure plays a crucial role in how ApplicationSets\nmanage deployments:\n\n    \n    \n    envs/ \u251c\u2500\u2500 non-prod-sandbox/ \u2502 \u251c\u2500\u2500 appset_config-a.json \u2502 \u251c\u2500\u2500 appset_config-b.json \u2502 \u251c\u2500\u2500 kustomization.yml \u251c\u2500\u2500 non-prod-staging/ \u2502 \u251c\u2500\u2500 appset_config-c.json \u2502 \u251c\u2500\u2500 kustomization.yml \u251c\u2500\u2500 prod/ \u251c\u2500\u2500 appset_config-d.json \u251c\u2500\u2500 kustomization.yml\n\n## Q&A\n\n  * Q: How did you overcome the difference between the GitLab repositories heirarcy and the gitops-deployments repo heirarcy?\n\n  * A: we implemented in the CI, a logic that checks if the repository is in the \u201croot\u201d / group level, and then adds to its path in gitops-deployments, the orphans/ directory, so it will hit the right path in the gitops repo.\n\n    * Snippet from our Gitlab CI\u2019s before_script logic:\n        \n                if [[ $CI_PROJECT_PATH =~ ^[^/]+/[^/]+$ ]]; then FULL_PROJECT_PATH=\"$CI_PROJECT_NAMESPACE/orphans/$CI_PROJECT_NAME\" else FULL_PROJECT_PATH=\"$CI_PROJECT_PATH\" fi\n\n  * Q: What are the appset_config*.json files?\n\n  * A: The appset_config*.json files provide additional parameters for the ApplicationSet; that way we can combine both the ones we get from the git generator and the ones we define in the JSON file.\n\n    * Example appset_config.json file:\n\n      * taken from deployments/sunflower/datamine2/datamine-amoeba-appprd/envs/prod, from the gitops-deployments repo\n\n      * Of course, you can structure your ApplicationSet and your JSON file in any way that suits your organization\u2019s needs.\n            \n                        { \"env\": \"prod\", \"cluster\": { \"name\": \"dc1-november\", \"address\": \"https://10.1.1.1:6443\", \"dc\": \"dc1\" } }\n\n  * Q: How do we integrate Helm in our deployment approach?\n\n  * A: Our deployment approach integrates Helm, allowing us to manage Helm-based and native Kubernetes deployments seamlessly. Key integration points include:\n\n    * Enabling Helm in Kustomize: We modify the argocd-cm ConfigMap to include the --enable-helm flag in the Kustomize build command.\n\n    * Example Kustomization Config:\n        \n                apiVersion: kustomize.config.k8s.io/v1beta1 kind: Kustomization helmCharts: - name: devlake repo: https://apache.github.io/incubator-devlake-helm-chart releaseName: devlake namespace: devlake version: 1.0.0-beta3 valuesFile: values.yml\n\n  * Q: How do we integrate Helm in our deployment approach?\n\n  * A: Helm deployments work in a similar way to normal applications, where the entrypoint is the environment\u2019s kustomization.yml file. This file should include a helmCharts section. Key integration points include:\n\n> This enables flexibility by allowing Helm-based deployments to be patched\n> and to create native K8s resources along the Helm releases.\n\n    * Enabling Helm in Kustomize: We modify the argocd-cm ConfigMap to include the --enable-helm flag in the Kustomize build command.\n\n    * Example Kustomization Config:\n        \n                apiVersion: kustomize.config.k8s.io/v1beta1 kind: Kustomization helmCharts: - name: devlake repo: https://apache.github.io/incubator-devlake-helm-chart releaseName: devlake namespace: devlake version: 1.0.0-beta3 valuesFile: values.yml\n\n2024-04-28\n\n#devops #argocd #gitops #kubernetes #applicationsets\n\n\u00a9 2024 Aviad Haham. All rights reserved.\n\n", "frontpage": false}
