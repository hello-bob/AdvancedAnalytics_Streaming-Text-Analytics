{"aid": "40260406", "title": "Vector Similarity Search in DuckDB", "url": "https://duckdb.org/2024/05/03/vector-similarity-search-vss.html", "domain": "duckdb.org", "votes": 1, "user": "CharlesW", "posted_at": "2024-05-04 21:25:30", "comments": 0, "source_title": "Vector Similarity Search in DuckDB", "source_text": "Vector Similarity Search in DuckDB \u2013 DuckDB\n\nSupport\n\n# Vector Similarity Search in DuckDB\n\nMax Gabrielsson2024-05-03\n\nTL;DR: This blog post shows a preview of DuckDB\u2019s new vss extension, which\nintroduces support for HNSW (Hierarchical Navigable Small Worlds) indexes to\naccelerate vector similarity search.\n\nIn DuckDB v0.10.0, we introduced the ARRAY data type, which stores fixed-sized\nlists, to complement the existing variable-size LIST data type.\n\nThe initial motivation for adding this data type was to provide optimized\noperations for lists that can utilize the positional semantics of their child\nelements and avoid branching as all lists have the same length. Think e.g. the\nsort of array manipulations you\u2019d do in NumPy: stacking, shifting, multiplying\n\u2013 you name it. Additionally, we wanted to improve our interoperability with\nApache Arrow, as previously Arrow\u2019s fixed-size list types would be converted\nto regular variable-size lists when ingested into DuckDB, losing some type\ninformation.\n\nHowever, as the hype for vector embeddings and semantic similarity search was\ngrowing, we also snuck in a couple of distance metric functions for this new\nARRAY type: array_distance, array_inner_product and array_cosine_similarity\n\n> #### Note\n>\n> If you\u2019re one of today\u2019s lucky 10000 and haven\u2019t heard of word embeddings or\n> vector search, the short version is that it\u2019s a technique used to represent\n> documents, images, entities - data as high-dimensional vectors and then\n> search for similar vectors in a vector space, using some sort of\n> mathematical \u201cdistance\u201d expression to measure similarity. This is used in a\n> wide range of applications, from natural language processing to\n> recommendation systems and image recognition, and has recently seen a surge\n> in popularity due to the advent of generative AI and availability of pre-\n> trained models.\n\nThis got the community really excited! While we (DuckDB Labs) initially went\non record saying that we would not be adding a vector similarity search index\nto DuckDB as we deemed it to be too far out of scope, we were very interested\nin supporting custom indexes through extensions in general. Shoot, I\u2019ve been\npersonally nagging on about wanting to plug-in an \u201cR-Tree\u201d index since the\ninception of DuckDBs spatial extension! So when one of our client projects\nevolved into creating a proof-of-concept custom \u201cHNSW\u201d index extension, we\nsaid that we\u2019d give it a shot. And... well, one thing led to another.\n\nFast forward to now and we\u2019re happy to announce the availability of the vss\nvector similarity search extension for DuckDB! While some may say we\u2019re late\nto the vector search party, we\u2019d like to think the party is just getting\nstarted!\n\nAlright, so what\u2019s in vss?\n\n## The Vector Similarity Search (VSS) Extension\n\nOn the surface, vss seems like a comparatively small DuckDB extension. It does\nnot provide any new data types, scalar functions or copy functions, but rather\na single new index type: HNSW (Hierarchical Navigable Small Worlds), which is\na graph-based index structure that is particularly well-suited for high-\ndimensional vector similarity search.\n\n    \n    \n    -- Create a table with an array column CREATE TABLE embeddings (vec FLOAT[3]); -- Create an HNSW index on the column CREATE INDEX idx ON embeddings USING HNSW (vec);\n\nThis index type can\u2019t be used to enforce constraints or uniqueness like the\nbuilt-in ART index, and can\u2019t be used to speed up joins or index regular\ncolumns either. Instead, the HNSW index is only applicable to columns of the\nARRAY type containing FLOAT elements and will only be used to accelerate\nqueries calculating the \u201cdistance\u201d between a constant FLOAT ARRAY and the\nFLOAT ARRAY\u2019s in the indexed column, ordered by the resulting distance and\nreturning the top-n results. That is, queries of the form:\n\n    \n    \n    SELECT * FROM embeddings ORDER BY array_distance(vec, [1, 2, 3]::FLOAT[3]) LIMIT 3;\n\nwill have their logical plan optimized to become a projection over a new HNSW\nindex scan operator, removing the limit and sort altogether. We can verify\nthis by checking the EXPLAIN output:\n\n    \n    \n    EXPLAIN SELECT * FROM embeddings ORDER BY array_distance(vec, [1, 2, 3]::FLOAT[3]) LIMIT 3;\n    \n    \n    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 PROJECTION \u2502 \u2502 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2502 \u2502 #0 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 PROJECTION \u2502 \u2502 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2502 \u2502 vec \u2502 \u2502array_distance(vec, [1.0, 2\u2502 \u2502 .0, 3.0]) \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 HNSW_INDEX_SCAN \u2502 \u2502 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2502 \u2502 t1 (HNSW INDEX SCAN : \u2502 \u2502 idx) \u2502 \u2502 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2502 \u2502 vec \u2502 \u2502 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2502 \u2502 EC: 3 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\nYou can pass the HNSW index creation statement a metric parameter to decide\nwhat kind of distance metric to use. The supported metrics are l2sq, cosine\nand inner_product, matching the three built-in distance functions:\narray_distance, array_cosine_similarity and array_inner_product. The default\nis l2sq, which uses Euclidean distance (array_distance):\n\n    \n    \n    CREATE INDEX l2sq_idx ON embeddings USING HNSW (vec) WITH (metric = 'l2sq');\n\nTo use cosine distance (array_cosine_similarity):\n\n    \n    \n    CREATE INDEX cos_idx ON embeddings USING HNSW (vec) WITH (metric = 'cosine');\n\nTo use inner product (array_inner_product):\n\n    \n    \n    CREATE INDEX ip_idx ON embeddings USING HNSW (vec) WITH (metric = 'ip');\n\n## Implementation\n\nThe vss extension is based on the usearch library, which provides a flexible\nC++ implementation of the HNSW index data structure boasting very impressive\nperformance benchmarks. While we currently only use a subset of all the\nfunctionality and tuning options provided by usearch, we\u2019re excited to explore\nhow we can leverage more of its features in the future. So far we\u2019re mostly\nhappy that it aligns so nicely with DuckDB\u2019s development ethos. Much like\nDuckDB itself, usearch is written in portable C++11 with no external\ndependencies and released under a permissive license, making it super smooth\nto integrate into our extension build and distribution pipeline.\n\n## Limitations\n\nThe big limitation as of now is that the HNSW index can only be created in in-\nmemory databases, unless the SET hnsw_enable_experimental_persistence = \u27e8bool\u27e9\nconfiguration parameter is set to true. If this parameter is not set, any\nattempt to create an HNSW index in a disk-backed database will result in an\nerror message, but if the parameter is set, the index will not only be created\nin memory, but also persisted to disk as part of the DuckDB database file\nduring checkpointing. After restarting or loading a database file with a\npersisted HNSW index, the index will be lazily loaded back into memory\nwhenever the associated table is first accessed, which is significantly faster\nthan having to re-create the index from scratch.\n\nThe reasoning for locking this feature behind an experimental flag is that we\nstill have some known issues related to persistence of custom indexes that we\nwant to address before enabling it by default. In particular, WAL recovery is\nnot yet properly implemented for custom indexes, meaning that if a crash\noccurs or the database is shut down unexpectedly while there are uncommited\nchanges to a HNSW-indexed table, you can end up with data loss or corruption\nof the index. While it is technically possible to recover from a unexpected\nshutdown manually by first starting DuckDB separately, loading the vss\nextension and then ATTACHing the database file, which ensures that the HNSW\nindex functionality is available during WAL-playback, you should not rely on\nthis for production workloads.\n\nWe\u2019re actively working on addressing this and other issues related to index\npersistence, which will hopefully make it into DuckDB v0.10.3, but for now we\nrecommend using the HNSW index in in-memory databases only.\n\nAt runtime however, much like the ART the HNSW index must be able to fit into\nRAM in its entirety, and the memory allocated by the HNSW at runtime is\nallocated \u201coutside\u201d of the DuckDB memory management system, meaning that it\nwont respect DuckDB\u2019s memory_limit configuration parameter.\n\nAnother current limitation with the HNSW index so far are that it only\nsupports the FLOAT (a 32-bit, single-precision floating point) type for the\narray elements and only distance metrics corresponding to the three built in\ndistance functions, array_distance, array_inner_product and\narray_cosine_similarity. But this is also something we\u2019re looking to expand\nupon in the near future as it is much less of a technical limitation and more\nof a \u201cwe haven\u2019t gotten around to it yet\u201d limitation.\n\n## Conclusion\n\nThe vss extension for DuckDB is a new extension that adds support for creating\nHNSW indexes on fixed-size list columns in DuckDB, accelerating vector\nsimilarity search queries. The extension can currently be installed on DuckDB\nv0.10.2 on all supported platforms (including WASM!) by running INSTALL vss;\nLOAD vss. The vss extension treads new ground for DuckDB extensions by\nproviding a custom index type and we\u2019re excited to refine and expand on this\nfunctionality going forward.\n\nWhile we\u2019re still working on addressing some of the limitations above,\nparticularly those related to persistence (and performance), we still really\nwant to share this early version the vss extension as we believe this will\nopen up a lot of cool opportunities for the community. So make sure to check\nout the vss extension documentation for more information on how to work with\nthis extension!\n\nThis work was made possible by the sponsorship of a DuckDB Labs customer! If\nyou are interested in similar work for specific capabilities, please reach out\nto DuckDB Labs. Alternatively, we\u2019re happy to welcome contributors! Please\nreach out to the DuckDB Labs team over on Discord or on the vss extension\nGitHub repository to keep up with the latest developments.\n\n# Recent posts\n\n2024-08-15\n\n### DuckCon #5 in Seattle\n\n2024-05-03\n\n### Vector Similarity Search in DuckDB\n\n2024-04-02\n\n### duckplyr: dplyr Powered by DuckDB\n\nAll blog posts\n\n###### Documentation\n\nInstallation SQL Introduction Why DuckDB\n\n###### Internals\n\nFAQs Code of Conduct Foundation Trademark Use\n\n###### Commercial Support\n\nDuckDB Labs Support Options\n\n###### Community\n\nX (Twitter) LinkedIn Discord GitHub Stack Overflow\n\n\u00a9 2024 DuckDB Foundation, Amsterdam NL\n\n", "frontpage": false}
