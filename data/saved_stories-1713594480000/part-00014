{"aid": "40092764", "title": "My journey through backwards compatibility", "url": "https://jam.engineering/graphql-backwards-compatibility/", "domain": "jam.engineering", "votes": 2, "user": "prestonp08", "posted_at": "2024-04-19 22:46:28", "comments": 0, "source_title": "Maintaining backwards compatibility in GraphQL | Jam.dev", "source_text": "Maintaining backwards compatibility in GraphQL | Jam.dev\n\nEngineering\n\n# Navigating backwards compatibility in GraphQL\n\nGraphQL strategies to help you manage interactions between evolving systems\nmore effectively.\n\nPreston Pham\n\nApr 19, 2024 \u2022 5 min read\n\nHi, I'm Preston, a full stack engineer at Jam. Today, I'm excited to share how\nwe manage GraphQL, and a few lessons learned - the hard way! GraphQL is a\npowerful tool, but it's not without its pitfalls. We faced challenges\nmaintaining a seamless interaction between evolving systems.\n\nI hope this break-down of issues we encountered and the solutions we arrived\nat will help you navigate the challenges of GraphQL backwards compatibility.\n\n## The need for backwards compatibility\n\nBackwards compatibility is fundamental when two systems, such as a GraphQL\nclient and server, need to communicate seamlessly while the shared interface\nevolves on both sides.\n\nJam is a Chrome extension for bug reporting. We use GraphQL to handle\nsubmitting bug reports from the extension client as well as reading data from\nthe dashboard client.\n\nA unique challenge we face is the delay in deploying updates to our browser\nextension, subject to Chrome's review process. In most web-based SaaS\napplications, you can freely deploy changes at anytime and clients will get\nthe updated version immediately (barring any other caching mechanisms). With a\nbrowser based extension, certain vendors like Chrome manage a systematic\nreview process that isn't automatic. In practice, submitting an extension or\nupdating an extension can take 1-2 business days before Chrome Web Store\napproves a change and releases it to end users.\n\nThis delay means that any breaking changes in our service can't be immediately\nrectified, emphasizing the need for a robust approach to maintaining backwards\ncompatibility.\n\nRegardless of the speed at which you deploy, at a certain scale, deploying\nbreaking changes will affect users. Unless you can deploy both the client and\nserver at the same exact time, you will have users who may be running stale\nclients and requesting data from a newer GraphQL server. In this case breaking\nchanges can and will compromise your users experience.\n\n## Learning from experience: GraphQL case study\n\nA few years back, a minor change led to a significant disruption, taking about\n20-30 minutes to resolve. This incident highlighted the impact of incompatible\nchanges and the need for a solid strategy to handle them.\n\nMore recently, we had another brief incident related to breaking changes but\nwe assumed the change was fully behind a feature flag. To put it briefly, we\nwanted to make breaking changes because of an upcoming feature where we needed\nto adapt to changing product requirements. We anticipated that end users would\nnot see these changes since they would not have a particular feature toggle\npresent.\n\nWhat happened? We use feature flags to guard new bits of functionality. As we\nwere preparing for a feature, we added new GraphQL properties under a commonly\nused query called the me query. This provides important context for the logged\nin user such as user email, the workspaces the user belongs to, user\npreferences, etc.\n\nEvery dashboard page load and every extension installation will consult the me\nquery to provide some important details about the logged in user. This makes\nit useful for adding on more commonly requested bits of data, but it is a\ndouble-edged sword as we'll describe shortly.\n\nAfter we added more data to this particular query for an upcoming feature, we\nfailed to realize the consequence of modifying the new GraphQL objects with\nrespect to older GraphQL clients! Any breaking changes would cause disruption\nif end users are using older extension versions or had a stale tab on the Jam\ndashboard.\n\nOur assumption was that a feature flag was enough to guard a new feature and\nthat we would be able to add, remove or modify GraphQL fields. But this proved\nto be incorrect. We needed to make sure that new GraphQL query paths did not\naffect the hot path for existing clients.\n\n    \n    \n    me query { teams { id name entitlements { // \u2190 this property is new! Any child properties that change would be breaking changes! ... } } }\n\nSo, we ended up gating application logic on the resolved data, but needed to\nvary the query itself. Old clients that don\u2019t have the feature flag should not\nfetch new API data.\n\nTo summarize, we needed to adopt one of two conventions:\n\n  * Avoid querying paths if they are volatile and subject to iteration. If we introduce a new GraphQL property we must handle backwards compatibility. This tends to be a slower workflow because we need to be mindful of changes and mark properties for deprecation and later delete them after client usage subsides.\n  * Introduce new queries and objects that are separate from existing queries. As long as these are separated and executed only when a feature flag applies, we can iterate rapidly and make destructive changes if needed.\n\nFor this particular example, we ended up with the latter strategy because we\nwere still rapidly iterating. At Jam, we try our best to ship features through\nincremental changes even if they are incomplete because shipping large change-\nsets incur more risk. In our experience, shipping small, inert changes are\nideal but we must also take into account changes that risk modifying existing\nclients.\n\n## Strategies for backwards compatibility\n\n  * Versioning GraphQL Objects: A straightforward method is to version your GraphQL queries and objects, allowing older clients to continue functioning with the API version they were designed for.\n  * Parameterizing versions: Using version parameters or HTTP headers is another method, though less recommended in GraphQL.\n  * Adopting a versionless API approach: The most idiomatic way in GraphQL is to create a versionless API, ensuring your API can cater to clients running outdated code.\n\n### Implementing the versionless approach\n\n  * Avoid removing or renaming types: Instead of removing or renaming types, always add new types or queries.\n  * Use of deprecated directives: Marking elements as deprecated can guide clients during introspection, but it's loosely enforced and requires a mindful approach.\n  * Mindful communication and staging: Communicate changes clearly and phase them out slowly, allowing clients to adapt smoothly.\n\n## Advanced strategies and testing challenges\n\n  * Introspection API: Clients can use the introspection API to understand available APIs and handle errors gracefully. This approach helps ensure applications work as expected without lingering issues.\n  * Testing complexities: Supporting many versions of clients multiplies testing complexities. We explored using a sub-module of our repo at an earlier commit to test interactions but found it impractical.\n\n### Adopting conventions and automation\n\nWe've adopted conventions to address backwards compatibility issues. However,\nremembering these conventions, especially for new engineers, can be\nchallenging. To help, we employed tools like GraphQL Inspector in our CI\nprocess. This tool warns us of any breaking changes, categorizing them as\nsafe, dangerous, or breaking, and blocks builds if necessary. It's a crucial\npart of our strategy to automate and prevent potential issues.\n\n## Balancing innovation and stability in GraphQL\n\nAt Jam, we\u2019ve learned a lot through our journey with GraphQL, and adapted to\nstrike the right balance between innovation and stability. The methods we've\ndeveloped are not just about maintaining an API, but about ensuring a smooth,\nuninterrupted experience for our users.\n\nI hope our story helps you in your GraphQL endeavors. Reach out if you want to\nJam!\n\n## Dealing with bugs is \ud83d\udca9, but not with Jam.\n\nCapture bugs fast, in a format that thousands of developers love.\n\nGet Jam for free\n\n## All the AI demos from Jam + Mercury + Product Hunt AI Night\n\nJam, Product Hunt, and Mercury hosted SF builders for AI demos. Watch:\nmarketing campaigns, videos of famous actors & more\u2014 all made by AI.\n\nApr 11, 2024 \u2014 1 min read\n\n## Time traveling debuggers w/ Adam Chalmers (Zoo.dev)\n\nDiscover Zoo's breakthrough in CAD: time traveling debuggers and custom KCL.\nTalk by Adam Chalmers, engineer at Zoo.dev.\n\nMar 18, 2024 \u2014 2 min read\n\nWe're Online\n\nFollow us for product updates, events and clever jokes\n\n\u00a9 2024 All Rights Reserved\n\nPrivacy policy Terms of service\n\n", "frontpage": false}
