{"aid": "40130741", "title": "Good Ideas in Computer Science", "url": "https://danielchasehooper.com/posts/good-ideas-in-cs/", "domain": "danielchasehooper.com", "votes": 2, "user": "cmpit", "posted_at": "2024-04-23 11:41:37", "comments": 0, "source_title": "Good Ideas in Computer Science", "source_text": "Good Ideas in Computer Science \u30fb Daniel Hooper\n\nDaniel Hooper\n\nHome \u30fb Posts \u30fb Projects\n\n# Good Ideas in Computer Science\n\nApril 21, 2024\u30fb3 minute read\n\nProgrammers love arguing for their favorite technologies. C++ vs Rust. Mac vs\nPC. These arguments overshadow the victories of Computer Science \u2014 the ideas\nthat we all agree on. To unearth these ideas, I recently asked a simple\nquestion on Twitter/X:\n\n> What ideas in computer science are universally considered good?\n\nBy \u201cuniversally considered good\u201d I mean they aren\u2019t debated. Ideas so\nwidespread and effective that you might not even think of them as being\ninvented. Each idea may not be suitable in all situations, but you won\u2019t find\na programmer that thinks you should never use them. I intentionally focus on\nideas, not implementations. For example: Unix contains many good ideas, but is\nnot on the list because it is an implementation.\n\nHere\u2019s my list, including the year each idea appeared:\n\n  * Binary Numbers (1500s)\n  * Boolean Algebra (1847)\n  * Floating Point Numbers (1936)\n  * Programmable Computers (1938)\n  * Arrays (1942)\n  * Callable Units (1947)\n  * Hashmaps (1953)\n  * Call Stack (1957)^1\n  * Structured Programing (1958)\n  * Portable Programming Languages^2\n  * Processes (1958)\n  * Packet Switching (1962)\n  * Virtual Address Space (1963)^3\n  * Memory Protection (1964)\n  * Version Control (1972)\n  * Public Key Cryptography (1973)\n  * Graphical User Interfaces (1973)\n\nIntentionally excluded:\n\n  * Garbage Collection\n\nThere are numerous examples of teams fighting the garbage collector to hit\nperformance goals^4. The CPU/Memory performance gap necessitates control over\nmemory to have performant code.\n\n  * Databases\n\nDatabases are more than just one idea, and there are many ways to combine\nthose ideas into a \u201cdatabase shape\u201d. Some good ideas in databases: Structured\nquery language, B-trees, ACID transactions.\n\n  * Other data structures and algorithms\n\nThere are too many to list. Few are as universal as arrays and hashmaps, which\nappear in almost all programs.\n\n  * Object Oriented Programming\n\nMany do not consider Object Oriented Programming good^5. I recommend data\noriented design as a replacement worldview.\n\nBy 1974, 50 years ago, we had most of what we call modern computing. Today\u2019s\nfundamentals are the same \u2014 a C programmer from 1974 would feel at home on a\nmodern computer except for the alien-like speed. I hope we have new ideas that\nin 50 years will be universally considered good.\n\nDiscuss on Twitter/X Discuss on Hacker News\n\n  1. Here\u2019s a look at programming before the call stack \u21a9\ufe0e\n\n  2. It\u2019s unclear to me what language was the first to compile to multiple architectures. Reach out if you know. \u21a9\ufe0e\n\n  3. By \u201cVirtual Address Space\u201d I mean the ability for Program A and Program B to be written without knowledge of each other and run simultaneously without memory interference. This allows both to use the same virtual memory address, say 0x12345678, because it maps to different physical memory addresses. Some people confused this with paging (which moves data from RAM to the hard drive when RAM usage is high), and memory mapping (which allows you to access the hard drive using memory instructions). \u21a9\ufe0e\n\n  4. Twitch, INSIDE, Minecraft, LinkedIn \u21a9\ufe0e\n\n  5. OOP is bad, Clean Code Horrible Performance, What\u2019s wrong with OOP \u21a9\ufe0e\n\n\u2756\n\n", "frontpage": false}
