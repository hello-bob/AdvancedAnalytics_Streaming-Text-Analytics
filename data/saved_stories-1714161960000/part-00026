{"aid": "40167694", "title": "Hardened Malloc Designed for Linux", "url": "https://github.com/GrapheneOS/hardened_malloc", "domain": "github.com/grapheneos", "votes": 1, "user": "whereistimbo", "posted_at": "2024-04-26 10:32:42", "comments": 0, "source_title": "GitHub - GrapheneOS/hardened_malloc: Hardened allocator designed for modern systems. It has integration into Android's Bionic libc and can be used externally with musl and glibc as a dynamic library for use on other Linux-based platforms. It will gain more portability / integration over time.", "source_text": "GitHub - GrapheneOS/hardened_malloc: Hardened allocator designed for modern\nsystems. It has integration into Android's Bionic libc and can be used\nexternally with musl and glibc as a dynamic library for use on other Linux-\nbased platforms. It will gain more portability / integration over time.\n\nSkip to content\n\n## Navigation Menu\n\nSign in\n\n# Search code, repositories, users, issues, pull requests...\n\nSearch syntax tips\n\nSign in\n\nSign up\n\nYou signed in with another tab or window. Reload to refresh your session. You\nsigned out in another tab or window. Reload to refresh your session. You\nswitched accounts on another tab or window. Reload to refresh your session.\nDismiss alert\n\nGrapheneOS / hardened_malloc Public\n\n  * Notifications\n  * Fork 90\n  * Star 1.2k\n\nHardened allocator designed for modern systems. It has integration into\nAndroid's Bionic libc and can be used externally with musl and glibc as a\ndynamic library for use on other Linux-based platforms. It will gain more\nportability / integration over time.\n\ngrapheneos.org/\n\n### License\n\nMIT license\n\n1.2k stars 90 forks Branches Tags Activity\n\nStar\n\nNotifications\n\n# GrapheneOS/hardened_malloc\n\nThis commit does not belong to any branch on this repository, and may belong\nto a fork outside of the repository.\n\n3 Branches\n\n667 Tags\n\n## Folders and files\n\nName| Name| Last commit message| Last commit date  \n---|---|---|---  \n  \n## Latest commit\n\nthestingerupdate copyright noticeFeb 15, 2024749640c \u00b7 Feb 15, 2024Feb 15,\n2024\n\n## History\n\n714 Commits  \n  \n### .github\n\n|\n\n### .github\n\n| Run the testsuite on multiple compiler versions| Nov 5, 2023  \n  \n### androidtest\n\n|\n\n### androidtest\n\n| mte: use tag 0 for freed slots, stop reserving tag 15| Jan 23, 2024  \n  \n### config\n\n|\n\n### config\n\n| add configuration for self-init| Sep 14, 2022  \n  \n### include\n\n|\n\n### include\n\n| android: add function for disabling MTE at runtime| Oct 30, 2023  \n  \n### test\n\n|\n\n### test\n\n| test: add regression test for missing init() in realloc()| Sep 27, 2023  \n  \n### third_party\n\n|\n\n### third_party\n\n| update libdivide to 5.0.0| Jul 17, 2021  \n  \n### .clang-tidy\n\n|\n\n### .clang-tidy\n\n| silence unwanted tidy warning| Jun 10, 2023  \n  \n### .gitignore\n\n|\n\n### .gitignore\n\n| update gitignore for config template system| Jan 12, 2022  \n  \n### Android.bp\n\n|\n\n### Android.bp\n\n| android: enable MTE on devices that declare having it| Oct 30, 2023  \n  \n### CREDITS\n\n|\n\n### CREDITS\n\n| mte: add scudo to CREDITS file| Oct 30, 2023  \n  \n### KERNEL_FEATURE_WISHLIST.md\n\n|\n\n### KERNEL_FEATURE_WISHLIST.md\n\n| MREMAP_DONTUNMAP may be usable in realloc| May 12, 2021  \n  \n### LICENSE\n\n|\n\n### LICENSE\n\n| update copyright notice| Feb 15, 2024  \n  \n### Makefile\n\n|\n\n### Makefile\n\n| Revert \"use safe_flag for -fstack-clash-protection\"| Nov 14, 2023  \n  \n### README.md\n\n|\n\n### README.md\n\n| mte: use tag 0 for freed slots, stop reserving tag 15| Jan 23, 2024  \n  \n### arm_mte.h\n\n|\n\n### arm_mte.h\n\n| mte: remove util.h dependency from arm_mte.h| Jan 23, 2024  \n  \n### calculate_waste.py\n\n|\n\n### calculate_waste.py\n\n| limit precision for fragmentation in table| Jun 12, 2019  \n  \n### chacha.c\n\n|\n\n### chacha.c\n\n| chacha: add constant for number of rounds| Apr 9, 2019  \n  \n### chacha.h\n\n|\n\n### chacha.h\n\n| use a consistent style for fixed-size int types| Oct 4, 2018  \n  \n### h_malloc.c\n\n|\n\n### h_malloc.c\n\n| mte: use tag 0 for freed slots, stop reserving tag 15| Jan 23, 2024  \n  \n### memory.c\n\n|\n\n### memory.c\n\n| add support for Arm MTE memory tagging| Oct 30, 2023  \n  \n### memory.h\n\n|\n\n### memory.h\n\n| add support for Arm MTE memory tagging| Oct 30, 2023  \n  \n### memtag.h\n\n|\n\n### memtag.h\n\n| mte: use tag 0 for freed slots, stop reserving tag 15| Jan 23, 2024  \n  \n### mutex.h\n\n|\n\n### mutex.h\n\n| wrap mutex type to enable future optimization| Sep 7, 2018  \n  \n### new.cc\n\n|\n\n### new.cc\n\n| conditionally include bits/functexcept.h| Jun 10, 2023  \n  \n### pages.c\n\n|\n\n### pages.c\n\n| reuse a single size alignment implementation| Jan 16, 2022  \n  \n### pages.h\n\n|\n\n### pages.h\n\n| reorganize pages.h header| Jan 16, 2022  \n  \n### preload.sh\n\n|\n\n### preload.sh\n\n| add lib prefix to the shared object name| Dec 5, 2018  \n  \n### random.c\n\n|\n\n### random.c\n\n| can now depend on libc having a getrandom wrapper| Mar 29, 2020  \n  \n### random.h\n\n|\n\n### random.h\n\n| initialize size class CSPRNGs from init CSPRNG| Apr 15, 2019  \n  \n### util.c\n\n|\n\n### util.c\n\n| android: restore the default SIGABRT handler in fatal_error()| Dec 31, 2023  \n  \n### util.h\n\n|\n\n### util.h\n\n| remove an always-true sizeof(u8) assert| Oct 30, 2023  \n  \n## Repository files navigation\n\n# Hardened malloc\n\n  * Introduction\n  * Dependencies\n  * Testing\n\n    * Individual Applications\n    * Automated Test Framework\n  * Compatibility\n  * OS integration\n\n    * Android-based operating systems\n    * Traditional Linux-based operating systems\n  * Configuration\n  * Core design\n  * Security properties\n  * Randomness\n  * Size classes\n  * Scalability\n\n    * Small (slab) allocations\n\n      * Thread caching (or lack thereof)\n    * Large allocations\n  * Memory tagging\n  * API extensions\n  * Stats\n  * System calls\n\n## Introduction\n\nThis is a security-focused general purpose memory allocator providing the\nmalloc API along with various extensions. It provides substantial hardening\nagainst heap corruption vulnerabilities. The security-focused design also\nleads to much less metadata overhead and memory waste from fragmentation than\na more traditional allocator design. It aims to provide decent overall\nperformance with a focus on long-term performance and memory usage rather than\nallocator micro-benchmarks. It offers scalability via a configurable number of\nentirely independent arenas, with the internal locking within arenas further\ndivided up per size class.\n\nThis project currently supports Bionic (Android), musl and glibc. It may\nsupport other non-Linux operating systems in the future. For Android, there's\ncustom integration and other hardening features which is also planned for musl\nin the future. The glibc support will be limited to replacing the malloc\nimplementation because musl is a much more robust and cleaner base to build on\nand can cover the same use cases.\n\nThis allocator is intended as a successor to a previous implementation based\non extending OpenBSD malloc with various additional security features. It's\nstill heavily based on the OpenBSD malloc design, albeit not on the existing\ncode other than reusing the hash table implementation. The main differences in\nthe design are that it's solely focused on hardening rather than finding bugs,\nuses finer-grained size classes along with slab sizes going beyond 4k to\nreduce internal fragmentation, doesn't rely on the kernel having fine-grained\nmmap randomization and only targets 64-bit to make aggressive use of the large\naddress space. There are lots of smaller differences in the implementation\napproach. It incorporates the previous extensions made to OpenBSD malloc\nincluding adding padding to allocations for canaries (distinct from the\ncurrent OpenBSD malloc canaries), write-after-free detection tied to the\nexisting clearing on free, queues alongside the existing randomized arrays for\nquarantining allocations and proper double-free detection for quarantined\nallocations. The per-size-class memory regions with their own random bases\nwere loosely inspired by the size and type-based partitioning in\nPartitionAlloc. The planned changes to OpenBSD malloc ended up being too\nextensive and invasive so this project was started as a fresh implementation\nbetter able to accomplish the goals. For 32-bit, a port of OpenBSD malloc with\nsmall extensions can be used instead as this allocator fundamentally doesn't\nsupport that environment.\n\n## Dependencies\n\nDebian stable (currently Debian 12) determines the most ancient set of\nsupported dependencies:\n\n  * glibc 2.36\n  * Linux 6.1\n  * Clang 14.0.6 or GCC 12.2.0\n\nFor Android, the Linux GKI 5.10, 5.15 and 6.1 branches are supported.\n\nHowever, using more recent releases is highly recommended. Older versions of\nthe dependencies may be compatible at the moment but are not tested and will\nexplicitly not be supported.\n\nFor external malloc replacement with musl, musl 1.1.20 is required. However,\nthere will be custom integration offering better performance in the future\nalong with other hardening for the C standard library implementation.\n\nFor Android, only the current generation, actively developed maintenance\nbranch of the Android Open Source Project will be supported, which currently\nmeans android13-qpr2-release.\n\n## Testing\n\n### Individual Applications\n\nThe preload.sh script can be used for testing with dynamically linked\nexecutables using glibc or musl:\n\n    \n    \n    ./preload.sh krita --new-image RGBA,U8,500,500\n\nIt can be necessary to substantially increase the vm.max_map_count sysctl to\naccommodate the large number of mappings caused by guard slabs and large\nallocation guard regions. The number of mappings can also be drastically\nreduced via a significant increase to CONFIG_GUARD_SLABS_INTERVAL but the\nfeature has a low performance and memory usage cost so that isn't recommended.\n\nIt can offer slightly better performance when integrated into the C standard\nlibrary and there are other opportunities for similar hardening within C\nstandard library and dynamic linker implementations. For example, a library\nregion can be implemented to offer similar isolation for dynamic libraries as\nthis allocator offers across different size classes. The intention is that\nthis will be offered as part of hardened variants of the Bionic and musl C\nstandard libraries.\n\n### Automated Test Framework\n\nA collection of simple, automated tests are provided and can be run with the\nmake command as follows:\n\n    \n    \n    make test\n\n## Compatibility\n\nOpenSSH 8.1 or higher is required to allow the mprotect PROT_READ|PROT_WRITE\nsystem calls in the seccomp-bpf filter rather than killing the process.\n\n## OS integration\n\n### Android-based operating systems\n\nOn GrapheneOS, hardened_malloc is integrated into the standard C library as\nthe standard malloc implementation. Other Android-based operating systems can\nreuse the integration code to provide it. If desired, jemalloc can be left as\na runtime configuration option by only conditionally using hardened_malloc to\ngive users the choice between performance and security. However, this reduces\nsecurity for threat models where persistent state is untrusted, i.e. verified\nboot and attestation (see the attestation sister project).\n\nMake sure to raise vm.max_map_count substantially too to accommodate the very\nlarge number of guard pages created by hardened_malloc. This can be done in\ninit.rc (system/core/rootdir/init.rc) near the other virtual memory\nconfiguration:\n\n    \n    \n    write /proc/sys/vm/max_map_count 1048576\n\nThis is unnecessary if you set CONFIG_GUARD_SLABS_INTERVAL to a very large\nvalue in the build configuration.\n\n### Traditional Linux-based operating systems\n\nOn traditional Linux-based operating systems, hardened_malloc can either be\nintegrated into the libc implementation as a replacement for the standard\nmalloc implementation or loaded as a dynamic library. Rather than rebuilding\neach executable to be linked against it, it can be added as a preloaded\nlibrary to /etc/ld.so.preload. For example, with libhardened_malloc.so\ninstalled to /usr/local/lib/libhardened_malloc.so, add that full path as a\nline to the /etc/ld.so.preload configuration file:\n\n    \n    \n    /usr/local/lib/libhardened_malloc.so\n\nThe format of this configuration file is a whitespace-separated list, so it's\ngood practice to put each library on a separate line.\n\nOn Debian systems libhardened_malloc.so should be installed into /usr/lib/ to\navoid preload failures caused by AppArmor profile restrictions.\n\nUsing the LD_PRELOAD environment variable to load it on a case-by-case basis\nwill not work when AT_SECURE is set such as with setuid binaries. It's also\ngenerally not a recommended approach for production usage. The recommendation\nis to enable it globally and make exceptions for performance critical cases by\nrunning the application in a container / namespace without it enabled.\n\nMake sure to raise vm.max_map_count substantially too to accommodate the very\nlarge number of guard pages created by hardened_malloc. As an example, in\n/etc/sysctl.d/hardened_malloc.conf:\n\n    \n    \n    vm.max_map_count = 1048576\n\nThis is unnecessary if you set CONFIG_GUARD_SLABS_INTERVAL to a very large\nvalue in the build configuration.\n\nOn arm64, make sure your kernel is configured to use 4k pages since we haven't\nyet added support for 16k and 64k pages. The kernel also has to be configured\nto use 4 level page tables for the full 48 bit address space instead of only\nhaving a 39 bit address space for the default hardened_malloc configuration.\nIt's possible to reduce the class region size substantially to make a 39 bit\naddress space workable but the defaults won't work.\n\n## Configuration\n\nYou can set some configuration options at compile-time via arguments to the\nmake command as follows:\n\n    \n    \n    make CONFIG_EXAMPLE=false\n\nConfiguration options are provided when there are significant compromises\nbetween portability, performance, memory usage or security. The core design\nchoices are not configurable and the allocator remains very security-focused\neven with all the optional features disabled.\n\nThe configuration system supports a configuration template system with two\nstandard presets: the default configuration (config/default.mk) and a light\nconfiguration (config/light.mk). Packagers are strongly encouraged to ship\nboth the standard default and light configuration. You can choose the\nconfiguration to build using make VARIANT=light where make VARIANT=default is\nthe same as make. Non-default configuration templates will build a library\nwith the suffix -variant such as libhardened_malloc-light.so and will use an\nout-variant directory instead of out for the build.\n\nThe default configuration template has all normal optional security features\nenabled (just not the niche CONFIG_SEAL_METADATA) and is quite aggressive in\nterms of sacrificing performance and memory usage for security. The light\nconfiguration template disables the slab quarantines, write after free check,\nslot randomization and raises the guard slab interval from 1 to 8 but leaves\nzero-on-free and slab canaries enabled. The light configuration has solid\nperformance and memory usage while still being far more secure than mainstream\nallocators with much better security properties. Disabling zero-on-free would\ngain more performance but doesn't make much difference for small allocations\nwithout also disabling slab canaries. Slab canaries slightly raise memory use\nand slightly slow down performance but are quite important to mitigate small\noverflows and C string overflows. Disabling slab canaries is not recommended\nin most cases since it would no longer be a strict upgrade over traditional\nallocators with headers on allocations and basic consistency checks for them.\n\nFor reduced memory usage at the expense of performance (this will also reduce\nthe size of the empty slab caches and quarantines, saving a lot of memory,\nsince those are currently based on the size of the largest size class):\n\n    \n    \n    make \\ N_ARENA=1 \\ CONFIG_EXTENDED_SIZE_CLASSES=false\n\nThe following boolean configuration options are available:\n\n  * CONFIG_WERROR: true (default) or false to control whether compiler warnings are treated as errors. This is highly recommended, but it can be disabled to avoid patching the Makefile if a compiler version not tested by the project is being used and has warnings. Investigating these warnings is still recommended and the intention is to always be free of any warnings.\n  * CONFIG_NATIVE: true (default) or false to control whether the code is optimized for the detected CPU on the host. If this is disabled, setting up a custom -march higher than the baseline architecture is highly recommended due to substantial performance benefits for this code.\n  * CONFIG_CXX_ALLOCATOR: true (default) or false to control whether the C++ allocator is replaced for slightly improved performance and detection of mismatched sizes for sized deallocation (often type confusion bugs). This will result in linking against the C++ standard library.\n  * CONFIG_ZERO_ON_FREE: true (default) or false to control whether small allocations are zeroed on free, to mitigate use-after-free and uninitialized use vulnerabilities along with purging lots of potentially sensitive data from the process as soon as possible. This has a performance cost scaling to the size of the allocation, which is usually acceptable. This is not relevant to large allocations because the pages are given back to the kernel.\n  * CONFIG_WRITE_AFTER_FREE_CHECK: true (default) or false to control sanity checking that new small allocations contain zeroed memory. This can detect writes caused by a write-after-free vulnerability and mixes well with the features for making memory reuse randomized / delayed. This has a performance cost scaling to the size of the allocation, which is usually acceptable. This is not relevant to large allocations because they're always a fresh memory mapping from the kernel.\n  * CONFIG_SLOT_RANDOMIZE: true (default) or false to randomize selection of free slots within slabs. This has a measurable performance cost and isn't one of the important security features, but the cost has been deemed more than acceptable to be enabled by default.\n  * CONFIG_SLAB_CANARY: true (default) or false to enable support for adding 8 byte canaries to the end of memory allocations. The primary purpose of the canaries is to render small fixed size buffer overflows harmless by absorbing them. The first byte of the canary is always zero, containing overflows caused by a missing C string NUL terminator. The other 7 bytes are a per-slab random value. On free, integrity of the canary is checked to detect attacks like linear overflows or other forms of heap corruption caused by imprecise exploit primitives. However, checking on free will often be too late to prevent exploitation so it's not the main purpose of the canaries.\n  * CONFIG_SEAL_METADATA: true or false (default) to control whether Memory Protection Keys are used to disable access to all writable allocator state outside of the memory allocator code. It's currently disabled by default due to a significant performance cost for this use case on current generation hardware, which may become drastically lower in the future. Whether or not this feature is enabled, the metadata is all contained within an isolated memory region with high entropy random guard regions around it.\n\nThe following integer configuration options are available:\n\n  * CONFIG_SLAB_QUARANTINE_RANDOM_LENGTH: 1 (default) to control the number of slots in the random array used to randomize reuse for small memory allocations. This sets the length for the largest size class (either 16kiB or 128kiB based on CONFIG_EXTENDED_SIZE_CLASSES) and the quarantine length for smaller size classes is scaled to match the total memory of the quarantined allocations (1 becomes 1024 for 16 byte allocations with 16kiB as the largest size class, or 8192 with 128kiB as the largest).\n  * CONFIG_SLAB_QUARANTINE_QUEUE_LENGTH: 1 (default) to control the number of slots in the queue used to delay reuse for small memory allocations. This sets the length for the largest size class (either 16kiB or 128kiB based on CONFIG_EXTENDED_SIZE_CLASSES) and the quarantine length for smaller size classes is scaled to match the total memory of the quarantined allocations (1 becomes 1024 for 16 byte allocations with 16kiB as the largest size class, or 8192 with 128kiB as the largest).\n  * CONFIG_GUARD_SLABS_INTERVAL: 1 (default) to control the number of slabs before a slab is skipped and left as an unused memory protected guard slab. The default of 1 leaves a guard slab between every slab. This feature does not have a direct performance cost, but it makes the address space usage sparser which can indirectly hurt performance. The kernel also needs to track a lot more memory mappings, which uses a bit of extra memory and slows down memory mapping and memory protection changes in the process. The kernel uses O(log n) algorithms for this and system calls are already fairly slow anyway, so having many extra mappings doesn't usually add up to a significant cost.\n  * CONFIG_GUARD_SIZE_DIVISOR: 2 (default) to control the maximum size of the guard regions placed on both sides of large memory allocations, relative to the usable size of the memory allocation.\n  * CONFIG_REGION_QUARANTINE_RANDOM_LENGTH: 256 (default) to control the number of slots in the random array used to randomize region reuse for large memory allocations.\n  * CONFIG_REGION_QUARANTINE_QUEUE_LENGTH: 1024 (default) to control the number of slots in the queue used to delay region reuse for large memory allocations.\n  * CONFIG_REGION_QUARANTINE_SKIP_THRESHOLD: 33554432 (default) to control the size threshold where large allocations will not be quarantined.\n  * CONFIG_FREE_SLABS_QUARANTINE_RANDOM_LENGTH: 32 (default) to control the number of slots in the random array used to randomize free slab reuse.\n  * CONFIG_CLASS_REGION_SIZE: 34359738368 (default) to control the size of the size class regions.\n  * CONFIG_N_ARENA: 4 (default) to control the number of arenas\n  * CONFIG_STATS: false (default) to control whether stats on allocation / deallocation count and active allocations are tracked. See the section on stats for more details.\n  * CONFIG_EXTENDED_SIZE_CLASSES: true (default) to control whether small size class go up to 128kiB instead of the minimum requirement for avoiding memory waste of 16kiB. The option to extend it even further will be offered in the future when better support for larger slab allocations is added. See the section on size classes below for details.\n  * CONFIG_LARGE_SIZE_CLASSES: true (default) to control whether large allocations use the slab allocation size class scheme instead of page size granularity. See the section on size classes below for details.\n\nThere will be more control over enabled features in the future along with\ncontrol over fairly arbitrarily chosen values like the size of empty slab\ncaches (making them smaller improves security and reduces memory usage while\nlarger caches can substantially improves performance).\n\n## Core design\n\nThe core design of the allocator is very simple / minimalist. The allocator is\nexclusive to 64-bit platforms in order to take full advantage of the abundant\naddress space without being constrained by needing to keep the design\ncompatible with 32-bit.\n\nThe mutable allocator state is entirely located within a dedicated metadata\nregion, and the allocator is designed around this approach for both small\n(slab) allocations and large allocations. This provides reliable,\ndeterministic protections against invalid free including double frees, and\nprotects metadata from attackers. Traditional allocator exploitation\ntechniques do not work with the hardened_malloc implementation.\n\nSmall allocations are always located in a large memory region reserved for\nslab allocations. On free, it can be determined that an allocation is one of\nthe small size classes from the address range. If arenas are enabled, the\narena is also determined from the address range as each arena has a dedicated\nsub-region in the slab allocation region. Arenas provide totally independent\nslab allocators with their own allocator state and no coordination between\nthem. Once the base region is determined (simply the slab allocation region as\na whole without any arenas enabled), the size class is determined from the\naddress range too, since it's divided up into a sub-region for each size\nclass. There's a top level slab allocation region, divided up into arenas,\nwith each of those divided up into size class regions. The size class regions\neach have a random base within a large guard region. Once the size class is\ndetermined, the slab size is known, and the index of the slab is calculated\nand used to obtain the slab metadata for the slab from the slab metadata\narray. Finally, the index of the slot within the slab provides the index of\nthe bit tracking the slot in the bitmap. Every slab allocation slot has a\ndedicated bit in a bitmap tracking whether it's free, along with a separate\nbitmap for tracking allocations in the quarantine. The slab metadata entries\nin the array have intrusive lists threaded through them to track partial slabs\n(partially filled, and these are the first choice for allocation), empty slabs\n(limited amount of cached free memory) and free slabs (purged / memory\nprotected).\n\nLarge allocations are tracked via a global hash table mapping their address to\ntheir size and random guard size. They're simply memory mappings and get\nmapped on allocation and then unmapped on free. Large allocations are the only\ndynamic memory mappings made by the allocator, since the address space for\nallocator state (including both small / large allocation metadata) and slab\nallocations is statically reserved.\n\nThis allocator is aimed at production usage, not aiding with finding and\nfixing memory corruption bugs for software development. It does find many\nlatent bugs but won't include features like the option of generating and\nstoring stack traces for each allocation to include the allocation site in\nrelated error messages. The design choices are based around minimizing\noverhead and maximizing security which often leads to different decisions than\na tool attempting to find bugs. For example, it uses zero-based sanitization\non free and doesn't minimize slack space from size class rounding between the\nend of an allocation and the canary / guard region. Zero-based filling has the\nleast chance of uncovering latent bugs, but also the best chance of mitigating\nvulnerabilities. The canary feature is primarily meant to act as padding\nabsorbing small overflows to render them harmless, so slack space is helpful\nrather than harmful despite not detecting the corruption on free. The canary\nneeds detection on free in order to have any hope of stopping other kinds of\nissues like a sequential overflow, which is why it's included. It's assumed\nthat an attacker can figure out the allocator is in use so the focus is\nexplicitly not on detecting bugs that are impossible to exploit with it in use\nlike an 8 byte overflow. The design choices would be different if performance\nwas a bit less important and if a core goal was finding latent bugs.\n\n## Security properties\n\n  * Fully out-of-line metadata/state with protection from corruption\n\n    * Address space for allocator state is entirely reserved during initialization and never reused for allocations or anything else\n    * State within global variables is entirely read-only after initialization with pointers to the isolated allocator state so leaking the address of the library doesn't leak the address of writable state\n    * Allocator state is located within a dedicated region with high entropy randomly sized guard regions around it\n    * Protection via Memory Protection Keys (MPK) on x86_64 (disabled by default due to low benefit-cost ratio on top of baseline protections)\n    * [future] Protection via MTE on ARMv8.5+\n  * Deterministic detection of any invalid free (unallocated, unaligned, etc.)\n\n    * Validation of the size passed for C++14 sized deallocation by delete even for code compiled with earlier standards (detects type confusion if the size is different) and by various containers using the allocator API directly\n  * Isolated memory region for slab allocations\n\n    * Top-level isolated regions for each arena\n    * Divided up into isolated inner regions for each size class\n\n      * High entropy random base for each size class region\n      * No deterministic / low entropy offsets between allocations with different size classes\n    * Metadata is completely outside the slab allocation region\n\n      * No references to metadata within the slab allocation region\n      * No deterministic / low entropy offsets to metadata\n    * Entire slab region starts out non-readable and non-writable\n    * Slabs beyond the cache limit are purged and become non-readable and non-writable memory again\n\n      * Placed into a queue for reuse in FIFO order to maximize the time spent memory protected\n      * Randomized array is used to add a random delay for reuse\n  * Fine-grained randomization within memory regions\n\n    * Randomly sized guard regions for large allocations\n    * Random slot selection within slabs\n    * Randomized delayed free for small and large allocations along with slabs themselves\n    * [in-progress] Randomized choice of slabs\n    * [in-progress] Randomized allocation of slabs\n  * Slab allocations are zeroed on free\n  * Detection of write-after-free for slab allocations by verifying zero filling is intact at allocation time\n  * Delayed free via a combination of FIFO and randomization for slab allocations\n  * Large allocations are purged and memory protected on free with the memory mapping kept reserved in a quarantine to detect use-after-free\n\n    * The quarantine is primarily based on a FIFO ring buffer, with the oldest mapping in the quarantine being unmapped to make room for the most recently freed mapping\n    * Another layer of the quarantine swaps with a random slot in an array to randomize the number of large deallocations required to push mappings out of the quarantine\n  * Memory in fresh allocations is consistently zeroed due to it either being fresh pages or zeroed on free after previous usage\n  * Random canaries placed after each slab allocation to absorb and then later detect overflows/underflows\n\n    * High entropy per-slab random values\n    * Leading byte is zeroed to contain C string overflows\n  * Possible slab locations are skipped and remain memory protected, leaving slab size class regions interspersed with guard pages\n  * Zero size allocations are a dedicated size class with the entire region remaining non-readable and non-writable\n  * Extension for retrieving the size of allocations with fallback to a sentinel for pointers not managed by the allocator [in-progress, full implementation needs to be ported from the previous OpenBSD malloc-based allocator]\n\n    * Can also return accurate values for pointers within small allocations\n    * The same applies to pointers within the first page of large allocations, otherwise it currently has to return a sentinel\n  * No alignment tricks interfering with ASLR like jemalloc, PartitionAlloc, etc.\n  * No usage of the legacy brk heap\n  * Aggressive sanity checks\n\n    * Errors other than ENOMEM from mmap, munmap, mprotect and mremap treated as fatal, which can help to detect memory management gone wrong elsewhere in the process.\n  * Memory tagging for slab allocations via MTE on ARMv8.5+\n\n    * random memory tags as the baseline, providing probabilistic protection against various forms of memory corruption\n    * dedicated tag for free slots, set on free, for deterministic protection against accessing freed memory\n    * guarantee distinct tags for adjacent memory allocations by incrementing past matching values for deterministic detection of linear overflows\n    * [future] store previous random tag and increment it to get the next tag for that slot to provide deterministic use-after-free detection through multiple cycles of memory reuse\n\n## Randomness\n\nThe current implementation of random number generation for randomization-based\nmitigations is based on generating a keystream from a stream cipher (ChaCha8)\nin small chunks. Separate CSPRNGs are used for each small size class in each\narena, large allocations and initialization in order to fit into the fine-\ngrained locking model without needing to waste memory per thread by having the\nCSPRNG state in Thread Local Storage. Similarly, it's protected via the same\napproach taken for the rest of the metadata. The stream cipher is regularly\nreseeded from the OS to provide backtracking and prediction resistance with a\nnegligible cost. The reseed interval simply needs to be adjusted to the point\nthat it stops registering as having any significant performance impact. The\nperformance impact on recent Linux kernels is primarily from the high cost of\nsystem calls and locking since the implementation is quite efficient\n(ChaCha20), especially for just generating the key and nonce for another\nstream cipher (ChaCha8).\n\nChaCha8 is a great fit because it's extremely fast across platforms without\nrelying on hardware support or complex platform-specific code. The security\nmargins of ChaCha20 would be completely overkill for the use case. Using\nChaCha8 avoids needing to resort to a non-cryptographically secure PRNG or\nsomething without a lot of scrutiny. The current implementation is simply the\nreference implementation of ChaCha8 converted into a pure keystream by ripping\nout the XOR of the message into the keystream.\n\nThe random range generation functions are a highly optimized implementation\ntoo. Traditional uniform random number generation within a range is very high\noverhead and can easily dwarf the cost of an efficient CSPRNG.\n\n## Size classes\n\nThe zero byte size class is a special case of the smallest regular size class.\nIt's allocated in a dedicated region like other size classes but with the\nslabs never being made readable and writable so the only memory usage is for\nthe slab metadata.\n\nThe choice of size classes for slab allocation is the same as jemalloc, which\nis a careful balance between minimizing internal and external fragmentation.\nIf there are more size classes, more memory is wasted on free slots available\nonly to allocation requests of those sizes (external fragmentation). If there\nare fewer size classes, the spacing between them is larger and more memory is\nwasted due to rounding up to the size classes (internal fragmentation). There\nare 4 special size classes for the smallest sizes (16, 32, 48, 64) that are\nsimply spaced out by the minimum spacing (16). Afterwards, there are four size\nclasses for every power of two spacing which results in bounding the internal\nfragmentation below 20% for each size class. This also means there are 4 size\nclasses for each doubling in size.\n\nThe slot counts tied to the size classes are specific to this allocator rather\nthan being taken from jemalloc. Slabs are always a span of pages so the slot\ncount needs to be tuned to minimize waste due to rounding to the page size.\nFor now, this allocator is set up only for 4096 byte pages as a small page\nsize is desirable for finer-grained memory protection and randomization. It\ncould be ported to larger page sizes in the future. The current slot counts\nare only a preliminary set of values.\n\nsize class| worst case internal fragmentation| slab slots| slab size| internal\nfragmentation for slabs  \n---|---|---|---|---  \n16| 93.75%| 256| 4096| 0.0%  \n32| 46.88%| 128| 4096| 0.0%  \n48| 31.25%| 85| 4096| 0.390625%  \n64| 23.44%| 64| 4096| 0.0%  \n80| 18.75%| 51| 4096| 0.390625%  \n96| 15.62%| 42| 4096| 1.5625%  \n112| 13.39%| 36| 4096| 1.5625%  \n128| 11.72%| 64| 8192| 0.0%  \n160| 19.38%| 51| 8192| 0.390625%  \n192| 16.15%| 64| 12288| 0.0%  \n224| 13.84%| 54| 12288| 1.5625%  \n256| 12.11%| 64| 16384| 0.0%  \n320| 19.69%| 64| 20480| 0.0%  \n384| 16.41%| 64| 24576| 0.0%  \n448| 14.06%| 64| 28672| 0.0%  \n512| 12.3%| 64| 32768| 0.0%  \n640| 19.84%| 64| 40960| 0.0%  \n768| 16.54%| 64| 49152| 0.0%  \n896| 14.17%| 64| 57344| 0.0%  \n1024| 12.4%| 64| 65536| 0.0%  \n1280| 19.92%| 16| 20480| 0.0%  \n1536| 16.6%| 16| 24576| 0.0%  \n1792| 14.23%| 16| 28672| 0.0%  \n2048| 12.45%| 16| 32768| 0.0%  \n2560| 19.96%| 8| 20480| 0.0%  \n3072| 16.63%| 8| 24576| 0.0%  \n3584| 14.26%| 8| 28672| 0.0%  \n4096| 12.48%| 8| 32768| 0.0%  \n5120| 19.98%| 8| 40960| 0.0%  \n6144| 16.65%| 8| 49152| 0.0%  \n7168| 14.27%| 8| 57344| 0.0%  \n8192| 12.49%| 8| 65536| 0.0%  \n10240| 19.99%| 6| 61440| 0.0%  \n12288| 16.66%| 5| 61440| 0.0%  \n14336| 14.28%| 4| 57344| 0.0%  \n16384| 12.49%| 4| 65536| 0.0%  \n  \nThe slab allocation size classes end at 16384 since that's the final size for\n2048 byte spacing and the next spacing class matches the page size of 4096\nbytes on the target platforms. This is the minimum set of small size classes\nrequired to avoid substantial waste from rounding.\n\nThe CONFIG_EXTENDED_SIZE_CLASSES option extends the size classes up to 131072,\nwith a final spacing class of 16384. This offers improved performance compared\nto the minimum set of size classes. The security story is complicated, since\nthe slab allocation has both advantages like size class isolation completely\navoiding reuse of any of the address space for any other size classes or other\ndata. It also has disadvantages like caching a small number of empty slabs and\ndeterministic guard sizes. The cache will be configurable in the future,\nmaking it possible to disable slab caching for the largest slab allocation\nsizes, to force unmapping them immediately and putting them in the slab\nquarantine, which eliminates most of the security disadvantage at the expense\nof also giving up most of the performance advantage, but while retaining the\nisolation.\n\nsize class| worst case internal fragmentation| slab slots| slab size| internal\nfragmentation for slabs  \n---|---|---|---|---  \n20480| 20.0%| 1| 20480| 0.0%  \n24576| 16.66%| 1| 24576| 0.0%  \n28672| 14.28%| 1| 28672| 0.0%  \n32768| 12.5%| 1| 32768| 0.0%  \n40960| 20.0%| 1| 40960| 0.0%  \n49152| 16.66%| 1| 49152| 0.0%  \n57344| 14.28%| 1| 57344| 0.0%  \n65536| 12.5%| 1| 65536| 0.0%  \n81920| 20.0%| 1| 81920| 0.0%  \n98304| 16.67%| 1| 98304| 0.0%  \n114688| 14.28%| 1| 114688| 0.0%  \n131072| 12.5%| 1| 131072| 0.0%  \n  \nThe CONFIG_LARGE_SIZE_CLASSES option controls whether large allocations use\nthe same size class scheme providing 4 size classes for every doubling of\nsize. It increases virtual memory consumption but drastically improves\nperformance where realloc is used without proper growth factors, which is\nfairly common and destroys performance in some commonly used programs. If\nlarge size classes are disabled, the granularity is instead the page size,\nwhich is currently always 4096 bytes on supported platforms.\n\n## Scalability\n\n### Small (slab) allocations\n\nAs a baseline form of fine-grained locking, the slab allocator has entirely\nseparate allocators for each size class. Each size class has a dedicated lock,\nCSPRNG and other state.\n\nThe slab allocator's scalability primarily comes from dividing up the slab\nallocation region into independent arenas assigned to threads. The arenas are\njust entirely separate slab allocators with their own sub-regions for each\nsize class. Using 4 arenas reserves a region 4 times as large and the relevant\nslab allocator metadata is determined based on address, as part of the same\napproach to finding the per-size-class metadata. The part that's still open to\ndifferent design choices is how arenas are assigned to threads. One approach\nis statically assigning arenas via round-robin like the standard jemalloc\nimplementation, or statically assigning to a random arena which is essentially\nthe current implementation. Another option is dynamic load balancing via a\nheuristic like sched_getcpu for per-CPU arenas, which would offer better\nperformance than randomly choosing an arena each time while being more\npredictable for an attacker. There are actually some security benefits from\nthis assignment being completely static, since it isolates threads from each\nother. Static assignment can also reduce memory usage since threads may have\nvarying usage of size classes.\n\nWhen there's substantial allocation or deallocation pressure, the allocator\ndoes end up calling into the kernel to purge / protect unused slabs by\nreplacing them with fresh PROT_NONE regions along with unprotecting slabs when\npartially filled and cached empty slabs are depleted. There will be\nconfiguration over the amount of cached empty slabs, but it's not entirely a\nperformance vs. memory trade-off since memory protecting unused slabs is a\nnice opportunistic boost to security. However, it's not really part of the\ncore security model or features so it's quite reasonable to use much larger\nempty slab caches when the memory usage is acceptable. It would also be\nreasonable to attempt to use heuristics for dynamically tuning the size, but\nthere's not a great one size fits all approach so it isn't currently part of\nthis allocator implementation.\n\n#### Thread caching (or lack thereof)\n\nThread caches are a commonly implemented optimization in modern allocators but\naren't very suitable for a hardened allocator even when implemented via arrays\nlike jemalloc rather than free lists. They would prevent the allocator from\nhaving perfect knowledge about which memory is free in a way that's both race\nfree and works with fully out-of-line metadata. It would also interfere with\nthe quality of fine-grained randomization even with randomization support in\nthe thread caches. The caches would also end up with much weaker protection\nthan the dedicated metadata region. Potentially worst of all, it's inherently\nincompatible with the important quarantine feature.\n\nThe primary benefit from a thread cache is performing batches of allocations\nand batches of deallocations to amortize the cost of the synchronization used\nby locking. The issue is not contention but rather the cost of synchronization\nitself. Performing operations in large batches isn't necessarily a good thing\nin terms of reducing contention to improve scalability. Large thread caches\nlike TCMalloc are a legacy design choice and aren't a good approach for a\nmodern allocator. In jemalloc, thread caches are fairly small and have a form\nof garbage collection to clear them out when they aren't being heavily used.\nSince this is a hardened allocator with a bunch of small costs for the\nsecurity features, the synchronization is already a smaller percentage of the\noverall time compared to a much leaner performance-oriented allocator. These\nbenefits could be obtained via allocation queues and deallocation queues which\nwould avoid bypassing the quarantine and wouldn't have as much of an impact on\nrandomization. However, deallocation queues would also interfere with having\nglobal knowledge about what is free. An allocation queue alone wouldn't have\nmany drawbacks, but it isn't currently planned even as an optional feature\nsince it probably wouldn't be enabled by default and isn't worth the added\ncomplexity.\n\nThe secondary benefit of thread caches is being able to avoid the underlying\nallocator implementation entirely for some allocations and deallocations when\nthey're mixed together rather than many allocations being done together or\nmany frees being done together. The value of this depends a lot on the\napplication and it's entirely unsuitable / incompatible with a hardened\nallocator since it bypasses all of the underlying security and would destroy\nmuch of the security value.\n\n### Large allocations\n\nThe expectation is that the allocator does not need to perform well for large\nallocations, especially in terms of scalability. When the performance for\nlarge allocations isn't good enough, the approach will be to enable more slab\nallocation size classes. Doubling the maximum size of slab allocations only\nrequires adding 4 size classes while keeping internal waste bounded below 20%.\n\nLarge allocations are implemented as a wrapper on top of the kernel memory\nmapping API. The addresses and sizes are tracked in a global data structure\nwith a global lock. The current implementation is a hash table and could\neasily use fine-grained locking, but it would have little benefit since most\nof the locking is in the kernel. Most of the contention will be on the\nmmap_sem lock for the process in the kernel. Ideally, it could simply map\nmemory when allocating and unmap memory when freeing. However, this is a\nhardened allocator and the security features require extra system calls due to\nlack of direct support for this kind of hardening in the kernel. Randomly\nsized guard regions are placed around each allocation which requires mapping a\nPROT_NONE region including the guard regions and then unprotecting the usable\narea between them. The quarantine implementation requires clobbering the\nmapping with a fresh PROT_NONE mapping using MAP_FIXED on free to hold onto\nthe region while it's in the quarantine, until it's eventually unmapped when\nit's pushed out of the quarantine. This means there are 2x as many system\ncalls for allocating and freeing as there would be if the kernel supported\nthese features directly.\n\n## Memory tagging\n\nRandom tags are set for all slab allocations when allocated, with 4 excluded\nvalues:\n\n  1. the reserved 0 tag\n  2. the previous tag used for the slot\n  3. the current (or previous) tag used for the slot to the left\n  4. the current (or previous) tag used for the slot to the right\n\nWhen a slab allocation is freed, the reserved 0 tag is set for the slot. Slab\nallocation slots are cleared before reuse when memory tagging is enabled.\n\nThis ensures the following properties:\n\n  * Linear overflows are deterministically detected.\n  * Use-after-free are deterministically detected until the freed slot goes through both the random and FIFO quarantines, gets allocated again, goes through both quarantines again and then finally gets allocated again for a 2nd time.\n  * Since the default 0 tag is reserved, untagged pointers can't access slab allocations and vice versa.\n\nSlab allocations are done in a statically reserved region for each size class\nand all metadata is in a statically reserved region, so interactions between\ndifferent uses of the same address space is not applicable.\n\nLarge allocations beyond the largest slab allocation size class (128k by\ndefault) are guaranteed to have randomly sized guard regions to the left and\nright. Random and FIFO address space quarantines provide use-after-free\ndetection. We need to test whether the cost of random tags is acceptable to\nenabled them by default, since they would be useful for:\n\n  * probabilistic detection of overflows\n  * probabilistic detection of use-after-free once the address space is out of the quarantine and reused for another allocation\n  * deterministic detection of use-after-free for reuse by another allocator.\n\nWhen memory tagging is enabled, checking for write-after-free at allocation\ntime and checking canaries are both disabled. Canaries will be more thoroughly\ndisabled when using memory tagging in the future, but Android currently has\nvery dynamic memory tagging support where it can be disabled at any time which\ncreates a barrier to optimizing by disabling redundant features.\n\n## API extensions\n\nThe void free_sized(void *ptr, size_t expected_size) function exposes the\nsized deallocation sanity checks for C. A performance-oriented allocator could\nuse the same API as an optimization to avoid a potential cache miss from\nreading the size from metadata.\n\nThe size_t malloc_object_size(void *ptr) function returns an upper bound on\nthe accessible size of the relevant object (if any) by querying the malloc\nimplementation. It's similar to the __builtin_object_size intrinsic used by\n_FORTIFY_SOURCE but via dynamically querying the malloc implementation rather\nthan determining constant sizes at compile-time. The current implementation is\njust a naive placeholder returning much looser upper bounds than the intended\nimplementation. It's a valid implementation of the API already, but it will\nbecome fully accurate once it's finished. This function is not currently safe\nto call from signal handlers, but another API will be provided to make that\npossible with a compile-time configuration option to avoid the necessary\noverhead if the functionality isn't being used (in a way that doesn't change\nbreak API compatibility based on the configuration).\n\nThe size_t malloc_object_size_fast(void *ptr) is comparable, but avoids\nexpensive operations like locking or even atomics. It provides significantly\nless useful results falling back to higher upper bounds, but is very fast. In\nthis implementation, it retrieves an upper bound on the size for small memory\nallocations based on calculating the size class region. This function is safe\nto use from signal handlers already.\n\n## Stats\n\nIf stats are enabled, hardened_malloc keeps tracks allocator statistics in\norder to provide implementations of mallinfo and malloc_info.\n\nOn Android, mallinfo is used for mallinfo-based garbage collection triggering\nso hardened_malloc enables CONFIG_STATS by default. The malloc_info\nimplementation on Android is the standard one in Bionic, with the information\nprovided to Bionic via Android's internal extended mallinfo API with support\nfor arenas and size class bins. This means the malloc_info output is fully\ncompatible, including still having jemalloc-1 as the version of the data\nformat to retain compatibility with existing tooling.\n\nOn non-Android Linux, mallinfo has zeroed fields even with CONFIG_STATS\nenabled because glibc mallinfo is inherently broken. It defines the fields as\nint instead of size_t, resulting in undefined signed overflows. It also\nmisuses the fields and provides a strange, idiosyncratic set of values rather\nthan following the SVID/XPG mallinfo definition. The malloc_info function is\nstill provided, with a similar format as what Android uses, with tweaks for\nhardened_malloc and the version set to hardened_malloc-1. The data format may\nbe changed in the future.\n\nAs an example, consider the following program from the hardened_malloc tests:\n\n    \n    \n    #include <pthread.h> #include <malloc.h> __attribute__((optimize(0))) void leak_memory(void) { (void)malloc(1024 * 1024 * 1024); (void)malloc(16); (void)malloc(32); (void)malloc(4096); } void *do_work(void *p) { leak_memory(); return NULL; } int main(void) { pthread_t thread[4]; for (int i = 0; i < 4; i++) { pthread_create(&thread[i], NULL, do_work, NULL); } for (int i = 0; i < 4; i++) { pthread_join(thread[i], NULL); } malloc_info(0, stdout); }\n\nThis produces the following output when piped through xmllint --format -:\n\n    \n    \n    <?xml version=\"1.0\"?> <malloc version=\"hardened_malloc-1\"> <heap nr=\"0\"> <bin nr=\"2\" size=\"32\"> <nmalloc>1</nmalloc> <ndalloc>0</ndalloc> <slab_allocated>4096</slab_allocated> <allocated>32</allocated> </bin> <bin nr=\"3\" size=\"48\"> <nmalloc>1</nmalloc> <ndalloc>0</ndalloc> <slab_allocated>4096</slab_allocated> <allocated>48</allocated> </bin> <bin nr=\"13\" size=\"320\"> <nmalloc>4</nmalloc> <ndalloc>0</ndalloc> <slab_allocated>20480</slab_allocated> <allocated>1280</allocated> </bin> <bin nr=\"29\" size=\"5120\"> <nmalloc>2</nmalloc> <ndalloc>0</ndalloc> <slab_allocated>40960</slab_allocated> <allocated>10240</allocated> </bin> <bin nr=\"45\" size=\"81920\"> <nmalloc>1</nmalloc> <ndalloc>0</ndalloc> <slab_allocated>81920</slab_allocated> <allocated>81920</allocated> </bin> </heap> <heap nr=\"1\"> <bin nr=\"2\" size=\"32\"> <nmalloc>1</nmalloc> <ndalloc>0</ndalloc> <slab_allocated>4096</slab_allocated> <allocated>32</allocated> </bin> <bin nr=\"3\" size=\"48\"> <nmalloc>1</nmalloc> <ndalloc>0</ndalloc> <slab_allocated>4096</slab_allocated> <allocated>48</allocated> </bin> <bin nr=\"29\" size=\"5120\"> <nmalloc>1</nmalloc> <ndalloc>0</ndalloc> <slab_allocated>40960</slab_allocated> <allocated>5120</allocated> </bin> </heap> <heap nr=\"2\"> <bin nr=\"2\" size=\"32\"> <nmalloc>1</nmalloc> <ndalloc>0</ndalloc> <slab_allocated>4096</slab_allocated> <allocated>32</allocated> </bin> <bin nr=\"3\" size=\"48\"> <nmalloc>1</nmalloc> <ndalloc>0</ndalloc> <slab_allocated>4096</slab_allocated> <allocated>48</allocated> </bin> <bin nr=\"29\" size=\"5120\"> <nmalloc>1</nmalloc> <ndalloc>0</ndalloc> <slab_allocated>40960</slab_allocated> <allocated>5120</allocated> </bin> </heap> <heap nr=\"3\"> <bin nr=\"2\" size=\"32\"> <nmalloc>1</nmalloc> <ndalloc>0</ndalloc> <slab_allocated>4096</slab_allocated> <allocated>32</allocated> </bin> <bin nr=\"3\" size=\"48\"> <nmalloc>1</nmalloc> <ndalloc>0</ndalloc> <slab_allocated>4096</slab_allocated> <allocated>48</allocated> </bin> <bin nr=\"29\" size=\"5120\"> <nmalloc>1</nmalloc> <ndalloc>0</ndalloc> <slab_allocated>40960</slab_allocated> <allocated>5120</allocated> </bin> </heap> <heap nr=\"4\"> <allocated_large>4294967296</allocated_large> </heap> </malloc>\n\nThe heap entries correspond to the arenas. Unlike jemalloc, hardened_malloc\ndoesn't handle large allocations within the arenas, so it presents those in\nthe malloc_info statistics as a separate arena dedicated to large allocations.\nFor example, with 4 arenas enabled, there will be a 5th arena in the\nstatistics for the large allocations.\n\nThe nmalloc / ndalloc fields are 64-bit integers tracking allocation and\ndeallocation count. These are defined as wrapping on overflow, per the\njemalloc implementation.\n\nSee the section on size classes to map the size class bin number to the\ncorresponding size class. The bin index begins at 0, mapping to the 0 byte\nsize class, followed by 1 for the 16 bytes, 2 for 32 bytes, etc. and large\nallocations are treated as one group.\n\nWhen stats aren't enabled, the malloc_info output will be an empty malloc\nelement.\n\n## System calls\n\nThis is intended to aid with creating system call whitelists via seccomp-bpf\nand will change over time.\n\nSystem calls used by all build configurations:\n\n  * futex(uaddr, FUTEX_WAIT_PRIVATE, val, NULL) (via pthread_mutex_lock)\n  * futex(uaddr, FUTEX_WAKE_PRIVATE, val) (via pthread_mutex_unlock)\n  * getrandom(buf, buflen, 0) (to seed and regularly reseed the CSPRNG)\n  * mmap(NULL, size, PROT_NONE, MAP_ANONYMOUS|MAP_PRIVATE, -1, 0)\n  * mmap(ptr, size, PROT_NONE, MAP_ANONYMOUS|MAP_PRIVATE|MAP_FIXED, -1, 0)\n  * mprotect(ptr, size, PROT_READ)\n  * mprotect(ptr, size, PROT_READ|PROT_WRITE)\n  * mremap(old, old_size, new_size, 0)\n  * mremap(old, old_size, new_size, MREMAP_MAYMOVE|MREMAP_FIXED, new)\n  * munmap\n  * write(STDERR_FILENO, buf, len) (before aborting due to memory corruption)\n  * madvise(ptr, size, MADV_DONTNEED)\n\nThe main distinction from a typical malloc implementation is the use of\ngetrandom. A common compatibility issue is that existing system call\nwhitelists often omit getrandom partly due to older code using the legacy\n/dev/urandom interface along with the overall lack of security features in\nmainstream libc implementations.\n\nAdditional system calls when CONFIG_SEAL_METADATA=true is set:\n\n  * pkey_alloc\n  * pkey_mprotect instead of mprotect with an additional pkey parameter, but otherwise the same (regular mprotect is never called)\n\nAdditional system calls for Android builds with LABEL_MEMORY:\n\n  * prctl(PR_SET_VMA, PR_SET_VMA_ANON_NAME, ptr, size, name)\n\n## About\n\nHardened allocator designed for modern systems. It has integration into\nAndroid's Bionic libc and can be used externally with musl and glibc as a\ndynamic library for use on other Linux-based platforms. It will gain more\nportability / integration over time.\n\ngrapheneos.org/\n\n### Topics\n\nsecurity memory memory-allocator malloc hardening memory-allocation quarantine\nmalloc-library slab-allocator grapheneos\n\n### Resources\n\nReadme\n\n### License\n\nMIT license\n\n### Security policy\n\nSecurity policy\n\nActivity\n\nCustom properties\n\n### Stars\n\n1.2k stars\n\n### Watchers\n\n48 watching\n\n### Forks\n\n90 forks\n\nReport repository\n\n## Releases 12\n\n12 Latest\n\nSep 28, 2023\n\n\\+ 11 releases\n\n## Sponsor this project\n\n  * thestinger Daniel Micay\n\n  * https://grapheneos.org/donate\n\nLearn more about GitHub Sponsors\n\n## Packages 0\n\nNo packages published\n\n## Contributors 12\n\n## Languages\n\n  * C 74.8%\n  * C++ 9.5%\n  * Python 8.3%\n  * Makefile 5.8%\n  * Java 1.5%\n  * Shell 0.1%\n\n## Footer\n\n\u00a9 2024 GitHub, Inc.\n\nYou can\u2019t perform that action at this time.\n\n", "frontpage": false}
