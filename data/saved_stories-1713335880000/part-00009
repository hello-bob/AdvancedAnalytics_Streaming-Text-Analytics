{"aid": "40055757", "title": "Prism (new Ruby parser) in 2024", "url": "https://railsatscale.com/2024-04-16-prism-in-2024/", "domain": "railsatscale.com", "votes": 12, "user": "ufuk", "posted_at": "2024-04-16 18:49:15", "comments": 0, "source_title": "Prism in 2024", "source_text": "Prism in 2024 | Rails at Scale\n\nRails at Scale\n\n# Prism in 2024\n\n2024-04-16 \u2022 Kevin Newton\n\nIn Ruby 3.3.0, a new standard library was added to CRuby called Prism. Prism\nis a parser for the Ruby language, exposed as both a C library (optionally\nusable by CRuby) and a Ruby library (usable as a Ruby gem). The Prism project\nrepresents many person-years worth of effort, and is the result of a\ncollaboration between Shopify, CRuby core contributors, other Ruby\nimplementation authors, and Ruby tooling developers.\n\nThis post provides an overview of the Prism project \u2014 why it exists, where it\nstands today, and what the future holds. It also gives some insight into the\nbroader ecosystem of Ruby parsers, intermediate representations, and tools.\nThis includes some well-known projects that you are likely to have heard of\n(e.g., Ripper) and newer projects that you may not yet be familiar with (e.g.,\nLRama).\n\nIf you\u2019re low on time and just want the conclusion, here it is: if you need to\nparse Ruby code for whatever reason, use the Prism library. Regardless of any\nfuture decisions made by the CRuby core team, this library is guaranteed to\nlive on in perpetuity as the definitive Ruby parser API. It is well-\ndocumented, error-tolerant, portable to every major Ruby implementation, and\nhas a clear path to future improvements.\n\nThe story of the Ruby language frontend is long, fragmented, and complex. It\nincludes many projects, each with their own (sometimes conflicting) goals. To\nunderstand the current state of affairs, it\u2019s necessary to look back at the\nhistory of the Ruby frontend, to see how the language has evolved over time.\nThere is a lot to digest here, so we will try to make this as brief as\npossible.\n\n## History\n\nRuby was created in early 1993. At the time, it was very common for language\ndesigners to generate their parsers using a tool called Yacc, which stood for\n\u201cYet Another Compiler Compiler\u201d. Yacc takes a grammar file (a file suffixed\nwith .y that describes the syntax of a language) and generates a parser for\nthat language (in this case a .c file). Matz took this same approach; the\nfirst parser of the Ruby language shipped with Ruby 0.01 was generated by\nYacc.\n\n### 1994-01-07: CRuby 0.06\n\nThe oldest available changelog entry that has an explicit version attached is\nfor CRuby 0.06. At this point the parser was generated by Yacc and written in\nC.\n\nFundamental to the current state of the Ruby frontend is that at this point\nRuby was a tree-walk interpreter. This means that after generating a syntax\ntree, the Ruby runtime would walk the tree to execute the code. This is in\ncontrast to the current CRuby runtime YARV, which is a bytecode interpreter.\nAll syntax errors, warnings, and other diagnostics were generated by the\nparser itself, and the parser was tightly coupled to the runtime. The syntax\ntree that was generated was explicitly designed for speedy execution, not for\nanalysis or transformation.\n\nThis is a very important point, and worth spending some extra time\nconsidering. You can still see its impact in the structure of the CRuby syntax\ntree today. You can use ruby --dump=parsetree -e [SOURCE] to see the parsed\ntree.\n\nConsider how the following examples are represented and how they differ from\nthe actual source code.\n\n  * for left, right in elements do end\n  * def foo = return :bar\n  * puts \"World!\"; BEGIN { puts \"Hello!\" }\n  * /foo #{bar}/o\n\nNotice that all of the deviations in the syntax tree from the source code make\nsense for the use case of an interpreter and/or compiler \u2014 they make things\nmore efficient. But also notice that they make things significantly more\ndifficult for any other use case.\n\n### 1995-12-21: CRuby 0.95\n\nRuby 0.95 was released at the end of 1995, and in this release there was a new\nentry in the ToDo file at the root of the repository: hand written parser\n(recursive descent). We\u2019ve written before about hand-written recursive descent\nparsers and how they differ from generated LALR parsers in the Prism\nannouncement post, so I won\u2019t rehash it here. Suffice to say, we believe a\nhand-written recursive descent parser is the best choice for a language like\nRuby, and it appears from this early version of CRuby that (at least at the\ntime) Matz agreed.\n\n### 2000-10-01: nodeDump\n\nIn 2000, Dave Thomas created the nodeDump project, which walked the Ruby AST\nand generated documentation. To our knowledge, this is the first attempt to\naccess and manipulate the Ruby syntax tree outside of the CRuby runtime\nitself. While this project was made obsolete by the Ruby 1.9 switch and\ntherefore is no longer maintained, it is worth mentioning that from the\nearliest public days of Ruby a desire for a Ruby parser API existed.\n\n### 2001-09-10: JRuby\n\nIn 2001, Jan Arne Petersen began work on a reimplementation of Ruby for the\nJava Virtual Machine that was a direct port of the Ruby 1.6 code named JRuby.\nThis project still exists and is in use in production systems to this day. The\nparser took a copy of the parse.y grammar file used as the input to Yacc and\nrewrote its actions in Java. Since then, any changes to the Ruby grammar have\nbeen manually copied over to JRuby through this same process.\n\nThis is another important point: every change to the CRuby grammar file\ninduced a change in the JRuby grammar file. This is not a unique story; every\nunique Ruby parser developed since these early days (14 by our count) has had\nto do the same thing. This is a significant investment of time and effort.\n\nSomewhat incredibly, JRuby has managed to stay on top of the grammar changes\nand in its latest release supports nearly all of the syntax of CRuby 3.3.0\n(the latest released version at the time of writing this post). We say nearly\nhere because minute differences have existed between the two parsers since the\nbeginning. While JRuby\u2019s parser has been by far the most comprehensive\nalternative Ruby parser over the years, getting to 100% parity with all of the\nvarious eccentricities is extremely difficult.\n\n### 2001-10-20: Ripper\n\nIn 2001, around the time of Ruby 1.7, Aoki Minero released the first version\nof the Ripper library. This was an event-driven parser that allowed users to\nbuild their own syntax trees. It worked by copying the Ruby grammar file and\nmodifying the actions to dispatch events that called out to user-defined\nmethods. Originally this project existed on its own, before the maintenance of\nit proved to be difficult and it was eventually merged into CRuby three years\nlater.\n\nThis parser still exists today as a standard library. Although it has had the\nexplicit Ripper is still early-alpha version. warning at the top of its\ndocumentation for the past 20 years, it has still served as the choice of\nparser for many projects (including yard, prettier, rubyfmt, etc.). These\nprojects chose Ripper for myriad reasons, but the two that stand out are: it\nwas the only standard library parser available and it was the only parser\nguaranteed to parse exactly as the current version of CRuby (a somewhat unique\nconstraint necessary for tools like IRB).\n\n### 2003-08-04: CRuby 1.8.0\n\nThe year 2003 was a big time for the Ruby language. The first international\nRuby conference occurred, the popular \u201cpickaxe\u201d book was published, and Ruby\nCentral was founded. CRuby released version 1.8.0, the last minor CRuby\nversion to include the tree-walk interpreter.\n\nWith all of these things happening, a new entry in the ToDo file appeared in\nCRuby: Parser API. Likely this was a reaction to the demand that was already\npresent in the ecosystem: developers wanted to build tools on top of the Ruby\nsyntax tree and couldn\u2019t.\n\nIn contrast, there was prior art in other language ecosystems. Perl had the\nPPI module starting in 2001, which allowed developers to access the syntax\ntree without the Perl runtime. CPython shipped with the dis module starting in\n1990, which gave developers access to the bytecode, and later in 2005 shipped\nthe ast module. It is table-stakes within any language ecosystem to be able to\naccess the syntax tree and/or the bytecode to create high-quality tooling, and\nRuby was behind in this regard.\n\n### 2004-09-17: CRuby e77ddaf\n\nIn 2004, Ripper was merged and along with it CRuby switched from using Yacc to\nusing its spiritual successor: GNU Bison. Bison was compatible with Yacc and\nboasted a number of improvements including reentrancy. Ripper was also built\non top of Bison, meaning it was necessary to switch to Bison to support\nmerging Ripper.\n\nIt\u2019s important to note that this meant that in order to compile CRuby from\nsource developers had to have Bison installed on their system. This was not a\nsignificant change (previously developers had to have Yacc installed), but\nit\u2019s worth mentioning because this pain-point existed until only very\nrecently.\n\n### 2004-11-10: ParseTree\n\nAlso in 2004, Ryan Davis released a library called ParseTree, which gave\ndevelopers access to the CRuby syntax tree using a C extension that converted\nit into Ruby primitives (arrays, strings, symbols, integers, etc.). This\nrelied heavily on the structure of the CRuby 1.8 syntax tree, effectively\nmirroring it into a Ruby structure. While this project did not survive the 1.8\nto 1.9 migration, it was the spiritual predecessor to the ruby_parser gem.\n\n### 2007-11-14: ruby_parser\n\nIn 2007, Ryan Davis closed down his work on the ParseTree library and instead\nreplaced it with the ruby_parser gem, which worked on both the CRuby 1.8 and\n1.9 branches. (At the time, 1.9 was a long-lived branch that housed the YARV\nbytecode interpreter). This project was different from ParseTree; it took the\napproach of copying the grammar file, rewriting the actions in Ruby, and then\nfeeding it into the racc parser generator.\n\nThis project still exists today, and is the basis of many tools in the Ruby\necosystem (including but not limited to flog, dawnscanner, and fasterer). This\nis the first true fragmentation within the CRuby parser ecosystem; developers\ncould now choose between using Ripper or ruby_parser.\n\n### 2007-12-25: CRuby 1.9.0\n\nAt long last in 2007 CRuby released version 1.9, which among other things\nincluded the YARV bytecode interpreter. This was the first version that\nincluded Ripper as a standard library. Merging in Ripper meant that CRuby now\nmaintained two parsers: the Bison-generated parser that was compiled into YARV\nbytecode, and the Ripper parser that was exposed as a standard library.\n\nIn order to marry these two requirements, Ripper was fashioned as a pre-\nprocessing step on the existing grammar file. Within the actions of the\ngrammar file a special domain-specific language was used in C language\ncomments to describe the actions that Ripper would take. A tool was created\nthat would extract these comments and generate a clean grammar file that\nitself could then be passed into Bison. If this sounds complicated, that\u2019s\nbecause it is. Ripper\u2019s setup means that any changes to the grammar file might\ninadvertently change the semantics of Ripper, a caveat that exists to this\nday.\n\n### 2012-04-19: mruby\n\nIn 2012, four days after Ruby 1.9 was recognized by the ISO as an\ninternational standard, work began on a new Ruby implementation called mruby.\nIt was meant as a \u201clightweight\u201d version of Ruby suitable for smaller devices\nwith limited memory.\n\nThe parser started out as a copy of an earlier version of the CRuby parser,\nbut quickly developed its own syntax tree more in the style of a Lisp\nS-expression. While effort has been made to update its syntax tree to include\nnewer CRuby features, it is proven both difficult and at times undesirable.\n\nImportantly, mruby was designed to be embedded and portable. This meant it\ncould serve as a submodule of other libraries. As such, its parser has been\nused to power other projects (notably Artichoke Ruby) because it is accessible\nfrom other languages.\n\n### 2013-04-15: parser\n\nOne year later in 2013, the parser gem was created. Again, it took the grammar\nfile from CRuby. It then rewrote the actions in Ruby. Using a lexer generated\nby ragel and a parser generated by racc, it provided a Ruby API for accessing\nthe Ruby syntax tree.\n\nThis project proved quite popular, thanks in part to tireless efforts to\nexactly match CRuby parsing semantics for every version (a separate grammar\nfile is checked in for each supported version). It was convenient enough that\ntools like rubocop ended up switching over from Ripper to use it. This is the\nmost widely-used Ruby parser in the ecosystem today outside of the CRuby\nparser itself. It is the basis for most of the static analysis tooling in use\ntoday.\n\nWhile this project was quite successful, the caveat is that it further\nfragmented the community. Now developers could choose between using Ripper,\nruby_parser, and parser. Static analysis tools that were being developed at\nthe time ended up not being able to reuse code from one another, and instead\nthe community reimplemented the same logic in multiple projects. Worse still,\nthe CRuby codebase only used its own parser, which meant any improvements to\ntooling generated by the ecosystem outside of CRuby were lost to the reference\nimplementation.\n\nTo keep up with syntax changes, tooling has been developed to open issues on\nthe repository any time a change to CRuby\u2019s parse.y file is committed. This is\na common story that we\u2019ve already seen in this post going back to JRuby in\n2001.\n\n### 2013-10-26: TruffleRuby\n\nAlso in 2013, Oracle Labs started a new Ruby implementation based on partial\nevaluation of self-optimizing AST interpreters. To do so, it used two Java-\nbased technologies: the Truffle AST interpreter framework and the Graal JIT\ncompiler. Given its basis in Java, TruffleRuby initially joined the JRuby\nproject as an alternative runtime backend called JRuby+Truffle. However, as\nthe projects drifted apart in design, TruffleRuby broke off as a standalone\nproject again and forked the JRuby parser to adapt to its own core library.\n\nTruffleRuby boasts the highest peak performance of any Ruby implementation to\ndate. It leverages the power of multiple JIT compilers and the GraalVM\necosystem to achieve this. While it isn\u2019t widely-used in production systems,\nthe concepts that it has introduced have been quite influential in the Ruby\ncommunity. Perhaps most notably, contributors to TruffleRuby have drastically\nadvanced the Ruby Spec Suite, a comprehensive test suite for the Ruby\nlanguage.\n\n### 2017-02-26: typedruby\n\nIn 2017, a project called typedruby was created, which introduced gradual\nstatic typing for Ruby. In order to parse Ruby code it rewrote the lexer from\nruby_parser, copied the grammar file from CRuby 2.4.0, and rewrote the actions\nin C++.\n\nThis project is not still under active development, but it is worth mentioning\nhere because the parser it created was eventually vendored into another C++\nproject: Sorbet. Sorbet is a gradual static type checker for Ruby that was\ndeveloped by Stripe. It is still in active use in production systems of the\nlargest Ruby codebases around today.\n\n### 2018-01-15: CRuby 0f3dcbdf\n\nIn 2018, commit 0f3dcbdf introduced an AST module in CRuby to help with\nwriting tests for the parser. This ended up being renamed to\nRubyVM::AbstractSyntaxTree and was released as an experimental feature in Ruby\n2.6.0. Many caveats were attached to this feature, including warnings of\nfuture changes and the fact that it was not guaranteed to be stable. This was\nthe first time the CRuby parser was exposed as a public API from within CRuby\nitself and not from a community project.\n\nFor the most part, the warnings appear to have worked. Not many projects have\nbeen developed on top of this feature. The most notable exception is the\nerror_highlight gem, a core library that provides better error messages by\nincluding snippets of the source code that generated the errors.\n\n### 2019-04-17: CRuby 9738f96\n\nIn 2019, CRuby introduced the concept of pattern matching. This was the\nlargest influx of new syntax into the Ruby language since Ruby 1.9 12 years\nearlier. The parse.y file added a whopping 714 lines of code to support this\nnew feature.\n\nInherently, this meant that every parser in the ecosystem had to be updated to\nsupport this new syntax. Inadvertently, this spelled the end of claiming 100%\ncompatibility for most of the parsers in the ecosystem for many years. Most of\nthem started out with a subset of the whole feature, supporting only the most\ncommon use-cases. Here you can see a timeline of these efforts:\n\n  * 2019-05-08 - parser\n  * 2020-09-22 - Sorbet\n  * 2021-04-07 - JRuby\n  * 2021-08-30 - ruby_parser\n  * 2023-04-08 - TruffleRuby\n\n### 2019-11-12: Natalie\n\nIn 2019, Tim Morgan created the Natalie project, an ahead-of-time compiled C++\nRuby implementation. The parser was hand-written, using the syntax tree\nstructure developed by Ryan Davis in the ruby_parser project. Over time, the\nparser was extracted into its own project called natalie_parser.\n\n### 2020-01-18: picoruby\n\nIn 2020, an alternative mruby implementation was created called picoruby. The\nproject was meant to be a minimal, small-footprint implementation of mruby\nthat would function well on microcontroller boards like a Raspberry Pi. The\nparser was copied from the mruby project and then modified to better suite the\nneeds and requirements of the project.\n\n### 2022-09-12: Prism\n\nAt this point in the timeline in late 2022, the first commit was made on the\nPrism project, the topic of this blog post. We\u2019ll come back to this topic\nmomentarily.\n\n### 2023-05-12: CRuby a1b01e77\n\nIn 2023, Kaneko Yuichiro created commit a1b01e77, which added LRama as the new\nparser generator in CRuby. LRama is a reimplementation of the Bison parser\ngenerator written in Ruby. It took the same parse.y file that had been used\nfor the past 20 years and generated the same parse.c file that Bison would\nhave. This solved problems that had existed since the creation of the CRuby\nparser; developers compiling CRuby from source would no longer have to have\nYacc/Bison installed on their system. Additionally, small differences in Bison\nversions would no longer accidentally break the parser.\n\nLRama was a significant shift in the maintenance of the CRuby parser. Because\nthe entire parser generation pipeline was now controlled by CRuby, it became\npossible to modify the grammar file in ways that were not previously possible\nwith Bison. You can see this in commits that refactor Ripper and in commits\nthat introduce the use of the ? operator to the grammar file like terms? and\n\u2018\\n\u2019?.\n\nIt\u2019s important to note that this change is not without downsides. If you\u2019ve\nbeen reading carefully, you\u2019ll remember that almost every other parser in the\necosystem relied on mirroring changes in parse.y into their own grammar files.\nAt the time of this commit that included the parsers in JRuby, TruffleRuby,\nruby_parser, parser, and Sorbet, as well as all of the downstream tools that\ndepend on these projects.\n\n### 2023-06-12: CRuby b481b673\n\nIn mid-2023, Kaneko Yuichiro created CRuby commit b481b673, introducing the\nconcept of a \u201cuniversal\u201d parser. You can read more about it in the issue. The\nidea was to incrementally extract the existing CRuby parser into a standalone\nlibrary.\n\nThis was accomplished by providing a callback interface where consumers would\nimplement all of the features needed by the parser. Over time, the number of\ncallbacks necessary to implement as a consumer has decreased, with the stated\ngoal of eventually having the fewest number of callbacks possible.\n\nWork continues on this project today. At the time of writing, this interface\ncan be optionally used by CRuby, but it has not been adopted elsewhere in the\necosystem.\n\n### Other projects\n\nI\u2019ve purposefully omitted a large number of projects from this list, in a\n(somewhat failing) effort to keep this history as brief as possible. A number\nof other parsers and syntax trees were developed throughout this time and\ncontributed to the overall development of the Ruby frontend ecosystem. Here\nare a few of them:\n\nProject| Parser  \n---|---  \nCardinal| A hand-written parser in Parrot  \nIronRuby| A copy of the CRuby parser, rewritten in .NET  \nMacRuby| A copy of the CRuby parser, rewritten in Objective-C  \nRubinius| Melbourne, a copy of CRuby parser, rewritten in Ruby  \nRuby Intermediate Language| A hand-written parser in OCaml  \nSyntax Tree| A syntax tree built on top of Ripper  \nTopaz| A copy of the CRuby parser, rewritten in RPython  \n  \n## Prism\n\nAt the time of Prism\u2019s conception in early 2022, we faced a fragmented\necosystem with a large number of disparate requirements. Taking into account\nthe history of the Ruby frontend and the current state of the ecosystem, it\nwas clear that if a single parser were going to be written, it would have to\nsolve everything at the same time to avoid risking becoming yet another\noption.\n\nStandards\n\nWe wanted to solve these problems for a lot of reasons, but the biggest was\nthe sheer maintenance cost. In early 2022, Shopify was investing in CRuby,\nTruffleRuby, parser (via downstream projects like rubocop and packwerk), and\nSorbet. We had developers who were actively working on syntax updates for\nTruffleRuby. We also had developers who had recently invested months of effort\nbringing pattern matching to Sorbet. Simply put, exploring the possibility of\na single parser that all of these projects could use made quite a lot of\nsense.\n\nTaking stock of the community, we realized that we could never claim to be a\nuniversal parser unless we worked closely with the maintainers of all of the\nvarious parsers in the ecosystem to determine their needs and meet them. We\nwould also need a clear migration path for all of the existing projects to\nmove over to a new parser, which was no small feat. In the end, we came up\nwith the following list:\n\nConcern| Description  \n---|---  \nCompatibility| No one would want to adopt a new parser that didn\u2019t parse the\nsame code the exact same way as their existing parser.  \nMaintainability| Every project in the ecosystem wanted a parser that was easy\nto maintain and update.  \nPerformance| No projects would want to adopt a new parser that was slower than\ntheir existing parser.  \nError\u2010tolerance| To be useable as the basis for IDE tooling, the new parser\nmust be error-tolerant (a requirement of all of the implementations, as well\nas Sorbet and Ruby LSP).  \nPortability| At this time there were parsers being actively maintained in C,\nC++, Ruby, Rust, and Java. All except the last could function through FFI, but\nrequiring a Java process to call back and forth into native functions was not\na good solution. Instead, we would need to develop a serialization format that\ncould be used by the Java projects that could retrieve the syntax tree with a\nsingle FFI call.  \nReentrancy| The parser would need to be reentrant in order to be used in a\nmulti-threaded environment.  \nIdentifiable| The parser would need to generate syntax trees whose nodes could\nbe consistently identified across parses. This was a requirement of\nerror_highlight, which reparses the source code to find the exact location of\nerrors.  \nSmall footprint| The footprint would need to be small in order to be suitable\nfor implementations like mruby and picoruby.  \nMigration path| We would need to provide a clear migration path for all of the\nexisting projects to move over to a new parser.  \n  \nWith this large, ambitious list of requirements, we went to work. After a\nyear\u2019s worth of work, we had:\n\n  * designed a new syntax tree that fit the needs of all of the stakeholders\n  * created a new parser that could lex all Ruby code on rubygems.org exactly as CRuby\u2019s parser did\n  * began work on integrating the parser into most of the projects in the ecosystem\n\nAt this point we opened our first pull request against CRuby to merge in our\nefforts in CRuby cc7f765f in late June of 2023. Because CRuby has been a\nbytecode interpreter since 1.9, our next step was then to generate the same\nbytecode instructions as the existing CRuby compiler, so we set out to do\nthat.\n\nIn the meantime, we also began work on our migration story to make it easier\nfor existing projects to migrate over to Prism. We began developing\n\u201ctranslation\u201d layers that would translate Prism\u2019s syntax tree into the syntax\ntree of the other existing parsers. This included Ripper, ruby_parser, and\nparser.\n\n## Today\n\nThe history and the work we\u2019ve done on Prism brings us to today. After two\nyears worth of work, here is where the ecosystem outside of CRuby currently\nstands:\n\nProject| Status  \n---|---  \nNatalie| Toward the end of last year, Natalie completed its migration to\nPrism. This was the first adopter, and Tim helped find a number of bugs in\nPrism that we were able to fix.  \nJRuby| Earlier this year, JRuby completed its migration to Prism. They were\none of the earliest adopters, and after weathering all of the various breaking\nchanges that Prism introduced while it was being developed, they can now boast\na peak of a 3x speedup in parsing time.  \nTruffleRuby| Also earlier this year, TruffleRuby completed its migration to\nPrism. In their announcement they mention the parser that Prism is about twice\nas fast as their previous parser.  \npicoruby| As of writing, the author of picoruby is working on experimenting\nwith both Prism and the \u201cuniversal\u201d parser. They have not yet completed their\nmigration, but plan to present their findings at RubyKaigi next month.  \nruby_parser| Earlier this year we completed our translation layer to the\nruby_parser syntax tree. This can be used as the basis of tools relying on\nthis parser to migrate over to Prism, and is showing a nice speedup in parsing\ntime.  \nparser| Earlier this year we also completed our translation layer to the\nparser syntax tree. It was successful enough that it was immediately adopted\ninto rubocop and released as an optional configuration in the latest version.\nThe author of rubocop also mentioned he would consider switching the parser\nover to Prism directly in the future. Other tools also began using this\ntranslation layer, including packwerk.  \nRipper| Most recently, we completed our translation layer to the Ripper event\nstream. This was the most complex translation layer to write, but it now\nallows tools to migrate over to Prism that may have been relying on this\n\u201cexperimental\u201d tool.  \nSorbet| To reap the benefits of our work, we are considering attempting to\nmigrate the Sorbet project over to using Prism. This work is currently being\nevaluated.  \n  \nA number of other open-source libraries and implementations have also adopted\nor are experimenting with Prism, a few of which include:\n\n  * Garnet \u2014 a Ruby implementation written in TypeScript, via the WASM bindings\n  * Opal - a Ruby-to-JavaScript translator, via the Ruby gem and WASM bindings\n  * Rails - in various ways\n  * Ruby LSP - a language server protocol implementation for Ruby, migrated from Syntax Tree\n\nNumerous other closed-source tools have also been developed since the\ninception of Prism, both inside and outside of Shopify. These includes tools\ndeveloped in Ruby, C++, Rust, and JavaScript, all via the various bindings\nthat Prism provides.\n\nIn total, at this point if picoruby (and potentially mruby) choose to adopt\nPrism going forward, this will mean every Ruby implementation and parser in\nthe world will be using Prism, except CRuby.\n\n## CRuby and the future\n\nUnsurprisingly, the reference implementation of Ruby is the most difficult to\nmigrate. There are a number of factors that make switching to Prism difficult,\nlayed out below.\n\n### Magnitude\n\nPrism designed its own syntax tree from the ground-up with the concerns of the\nvarious stakeholders in mind. This necessarily means we also need to write our\nown compiler to match the instruction sequences generated by CRuby. All told\nat the time of writing this accounts for about 9000 lines of code. With a\nchange as large as replacing the parser and compiler, it\u2019s difficult to ensure\nthat every edge case is covered. Trepidation about the sheer size of the\nchange is warranted and understandable.\n\n### Compatibility\n\nWhile we continue to make progress on this every day, there are still a small\nnumber of edge cases indicating slight deviations with Prism. The vast\nmajority of these have to do with the compiler, as opposed to the parser,\nwithin modules like TracePoint and Coverage. We are actively working on\nreducing these differences, but it is a slow process.\n\nAs of writing, we are failing 105/21813 tests and 42/32601 specs. Confidently,\nwe can say we will have them resolved by the next CRuby release (if not\nsignificantly sooner). In the meantime we will be testing Shopify\u2019s core\nmonolith with --parser=prism in our CI environment to ensure that we catch any\nregressions that might occur, in addition to passing all of the tests and\nspecs.\n\n### Competition\n\nAs previously mentioned, the other effort within CRuby to improve the Ruby\nfrontend ecosystem is the \u201cuniversal\u201d parser. While Prism has been adopted by\nnearly every other parser and implementation in the ecosystem, efforts have\ncontinued on the \u201cuniversal\u201d parser to ease the maintenance burden of the\nCRuby developers. While Prism has been merged into CRuby as an library, it has\nnot yet been adopted as the default parser because both the Prism project and\nthe \u201cuniversal\u201d parser project have been asked to compete.\n\nUnfortunately this means developing CRuby itself is going to be difficult\nuntil such a time as a decision is made. Any changes to the grammar or\ncompiler will have to be done twice: once for the existing pipeline and once\nfor Prism. Fortunately for those not developing CRuby, to ease concerns about\nthe future Matz has agreed that going forward the official parser API for Ruby\nwill be the Prism API. This means regardless of which parser (Prism or the\n\u201cuniversal\u201d parser) is adopted as the official solution for CRuby, the\ndeveloper-facing API will be the same. This is a significant win for the Ruby\necosystem, as it means developers can develop against Prism today and do not\nhave to worry about whichever internal solution CRuby ends up choosing.\n\n## Wrapping up\n\nWe hope this post has brought some clarity as to the relationship between\nPrism, LRama, \u201cuniversal\u201d parser, and the broader Ruby frontend ecosystem. We\nare excited about the progress the whole community has made in rallying around\na single syntax tree, and are very excited about the possibilities this\nenables. By sharing a single source of truth for parsing, the whole community\ncan start to benefit from things like better error messages, shared indices\nfor code navigation, and more. Overall, we are excited to see what the future\nholds for the Ruby frontend ecosystem, and are excited to be a part of it.\n\nSubscribe\n\n  * Shopify Engineering\n\nThe Ruby and Rails Infrastructure team at Shopify exists to help ensure that\nRuby and Rails are 100-year tools that will continue to merit being our\ntoolchain of choice.\n\nThis work is licensed under a Creative Commons Attribution-NonCommercial-\nShareAlike 4.0 International License.\n\n", "frontpage": true}
