{"aid": "40283981", "title": "A Comprehensive Introduction to CDNs", "url": "https://00f.net/2024/05/07/what-is-a-cdn/", "domain": "00f.net", "votes": 1, "user": "jedisct1", "posted_at": "2024-05-07 10:17:59", "comments": 0, "source_title": "Frank DENIS random thoughts.", "source_text": "A comprehensive introduction to CDNs | Frank DENIS random thoughts.\n\n# Frank DENIS random thoughts.\n\n## A comprehensive introduction to CDNs\n\nFor many people, CDNs are an obvious requirement for any public API or web\nservice. However, I\u2019ve come to realize that for the vast majority, they remain\nsomewhat mysterious - or something they\u2019re unaware of, even though they\nunknowingly use them daily.\n\nSo, here\u2019s a very accessible, hands-on illustration of what a CDN does, using\nFastly as an example.\n\n## What do CDNs do?\n\nA CDN is a cloud service that can be added in front of existing web servers.\nInstead of connecting directly to the content servers, clients will connect to\nthe proxy nodes operated by the CDN.\n\nBut why would you do this?\n\n  * First, it\u2019s an easy way to improve security. CDNs have a massive amount of bandwidth and can seamlessly mitigate DDoS attacks.\n  * In addition to just passing traffic through, CDNs can store a copy of the content in their local cache. The next time a request for cached content comes in, the CDN can directly send the content to the client without having to hit the original content server at all. This can drastically reduce the load on that server.\n  * As a side effect, if the content server is temporarily down or overloaded, as long as the content is cached by the CDN, clients won\u2019t even notice.\n  * CDNs typically implement recent protocols. If the content server doesn\u2019t support HTTP/3, simply add a CDN in front of it, and you\u2019re done \u2013 clients can now use that protocol without having to change anything on the content server.\n  * Okay, so far what we\u2019ve described is a traditional reverse proxy. But CDNs have such proxies all over the world. This means that there will be multiple copies of the content, spread everywhere. No matter where the actual content source is, clients will download content from a node that\u2019s close to their location, decreasing latency and improving reliability.\n  * Modern CDNs can do something else: execute code. The intent here is not to replace generic serverless functions but to be able to filter, transform, or aggregate content in real-time, without having to rewrite the original content server.\n  * For example, HTTP message signatures can be verified, or transparently computed before being delivered to clients.\n  * Also, they generally have APIs and UIs to get an overview of how your services are performing.\n\n## What\u2019s pretty cool about Fastly\n\nHere are a few things I like about Fastly:\n\n  * They offer a free tier, equivalent to around $50 per month, which is more than enough to explore how CDNs work and measure their impact on your services.\n  * They have a program to support open-source projects, which is great for the community.\n  * Cache entries can be flushed instantly. Additionally, they have a system to group resources into buckets, allowing you to flush everything in a bucket at once. This means that if necessary, content can be easily updated before it expires.\n  * One of the most appealing features of that CDN is its flexibility. You can enable it for individual host names without having to delegate your entire domain to them. There\u2019s no need to change all your links to one of their domains either. Simply set a DNS entry for your own domain to point to one of their DNS names or IP addresses, and you\u2019re good to go. This approach makes it very easy and safe to test a CDN without making significant changes to your existing setup. If things don\u2019t go well, reverting is also easy: just delete or restore the DNS entries to their previous values, and you\u2019re done. And what\u2019s more, this even works with TLS. Not something they advertise, but this feature is, as far as I know, surprisingly unique to Fastly.\n  * They don\u2019t store query logs by default, but if you need them, you can enable logging and have the data sent to a third-party service of your choice.\n  * Fastly also allows you to associate arbitrary WebAssembly modules with a service, which enables you to control how individual requests are handled. The environment provides APIs that allow you to inspect and modify queries and responses, manage the cache, and more. These APIs leverage the widely available WASI-Core (also known as wasi-preview1, wasm32-wasi, wasip1, etc.) ABI, which makes them easily accessible from any language that can compile to WebAssembly.\n\nFastly is a very powerful platform, and fortunately, there\u2019s a wealth of\ndocumentation available. While this abundance of documentation is great, it\ncan also feel overwhelming. Therefore, what follows are some simple steps to\nhelp you get started.\n\n## Terminology\n\n  * A service is an entity that responds to HTTP queries sent to a given virtual host name. If you want to put two completely different websites or APIs behind a CDN, you generally need to create two services. These services will have distinct rules, statistics, code, and can be enabled and disabled independently.\n  * A domain refers to a host name, as in \u201ca DNS record name\u201d. DNS folks will feel offended. But it means that if you own the domain example.com, you can enable Fastly for test.example.com only by entering test.example.com whenever a form field asks for a \u201cdomain\u201d. This will work without affecting anything else in the example.com zone.\n  * A host, origin, or content server refers to the machine that the CDN proxies relay HTTP queries to and receive responses from.\n  * A backend or upstream server is an origin along with a set of parameters, such as whether TLS must be used to connect, timeouts, etc. A required parameter is the name of the backend, which must be unique for a given service.\n  * A subscription does not refer to a regular payment schedule. Instead, it\u2019s a cron job that automatically updates TLS certificates.\n\n## Setting up a simple distributed cache\n\nGo to https://fastly.com and create a free account.\n\nHere\u2019s what we\u2019re going to do next: set up everything so that\nhttps://fastly.example.com acts as a caching layer for https://example.com.\nWhen people connect to https://fastly.example.com, they will see exactly the\nsame content, but cached and protected by a CDN.\n\nServices can be created in the CDN and Compute tabs:\n\n  * CDN: I\u2019d recommend this when only basic HTTP caching is needed. It\u2019s possible to run a bit of code, but using a DSL that has a lot of limitations compared to WebAssembly modules.\n  * Compute: This also does HTTP caching, but is far more flexible, as it allows requests to be handled by custom code compiled to WebAssembly.\n\nTo start with, we\u2019re going to create a simple distributed cache, not running\nany custom code.\n\nSo in the \u201cCDN\u201d tab, click the \u201cCreate a CDN service\u201d button.\n\n  * Service name: This is a text description of the service. It can be anything; it\u2019s just for UI purposes.\n  * Domain: Don\u2019t be fooled: this is the host name you want clients to connect to instead of connecting directly to the origin. In this case, it should be fastly.example.com.\n  * Origin: This is where the CDN will relay fastly.example.com traffic to, i.e., the actual server hosting the content. We want example.com content to be served as fastly.example.com, so the origin should be set to example.com. This is not a URI, just a host name or an IP address.\n\nNote that the origin server doesn\u2019t have to be configured for\nfastly.example.com. It should never see traffic for that virtual host name;\nonly the CDN will.\n\nBy the way, I own the sk.tl domain but not example.com, and want to post\nactual screenshots of the procedure rather than a simulation. The screenshots\nsay sk.tl instead of example.com. Either way, these are just examples, and you\nshould use your own domain names or this is very unlikely to work.\n\nDon\u2019t click the \u201cTest domain\u201d button now; there\u2019s more to be done.\n\n## Setting up TLS certificates\n\nBut wait, example.com already exists, and is served over TLS. We\u2019d like\nfastly.example.com to be accessible over TLS as well, but since this is going\nto be handled on a completely different set of servers, how would that work?\n\nFortunately, Fastly makes that easy. No changes are required in the current\nexample.com configuration, including the existing TLS certificates and how\nthey are updated. The TLS configuration for fastly.example.com is going to be\ncompletely independent, and automatically managed by the CDN.\n\nClick the Security tab, followed by the Manage certificates button and the Get\nstarted button:\n\nIn the \u201cdomains\u201d form, enter the host names to issue TLS certificates for. Not\nthe domain name. Select \u201cLet\u2019s Encrypt\u201d as the certification authority,\n\u201cHTTP/3 + 0RTT\u201d for the TLS configuration, and hit Submit.\n\nA nasty warning may appear:\n\nThis is fine. Click verification options and unfold the ACME HTTP/CNAME\nchallenge section:\n\nThis is telling you how to set up the proper DNS record for the host name. In\nthat case, I added the following entry to the zone: fastly 60 IN CNAME\nn.sni.global.fastly.net.\n\nOnce this is done, wait for authoritative DNS to get the entry, and reload the\npage. After a while, verification should pass:\n\nThere\u2019s nothing to change on the origin\u2019s TLS configuration. Once again,\ncertificates for the host name registered on the CDN are going to be\nindependently managed. I don\u2019t think using Let\u2019s Encrypt on Fastly, and\nsomething else on the origin, is a problem either.\n\n## Testing the cached version of the website\n\nNow, wait for a little while until the configuration has been propagated\nglobally. Then, browse https://fastly.example.com and you should see the same\ncontent as the original website, except that everything feels faster (assuming\nthe content is cacheable).\n\n## Configuration versions\n\nIf you go to the \u201cCDN\u201d tab again, the service is displayed:\n\nAnd can be clicked on:\n\nThe stats will become more interesting once the service receives actual\ntraffic.\n\nThe \u201cPurge\u201d button resets the cache or specific URIs. This is very useful\nduring development.\n\nBut how do you edit the configuration? The \u201cEdit configuration\u201d button\nsuggests cloning version 1 (active). What does that mean?\n\nThe idea is that at a given point in time, a specific version of the\nconfiguration is deployed. This includes all the parameters, code, and so on.\n\nAnd once deployed, this version cannot be modified. Instead, it can be cloned.\nOn that clone, any number of changes can be made, but they will only be\ndeployed all at once, after the new version is activated to replace the\nprevious one.\n\nThis is quite nice, because it\u2019s also possible to revert to any previous\nversion. So, if after having made a couple of changes, it turns out that\nsomething looks wrong, it\u2019s possible to revert all the knobs to the previous\nworking state, rather than having to find what exact knob introduced the\nissue.\n\nAnd of course, any version can be cloned, not just the last one. It\u2019s not\nexactly as powerful as Git, but this is still very useful, especially when\nmaking changes to production services.\n\n## Apex domains\n\nIn the previous example, we assigned fastly.example.com to the CDN by adding a\nCNAME DNS record.\n\nHowever, if everything works well, we might eventually want example.com to be\nhandled by Fastly, with some hostnames like origin.example.com being the\norigin.\n\nHere\u2019s the thing: example.com is a zone that contains other things, so it\ncan\u2019t be a CNAME record. This is a limitation of the DNS protocol itself.\n\nFortunately, instead of a CNAME record, we can also use IP addresses.\nSomething I\u2019ve only found in Fastly\u2019s offering and deserves more attention.\n\nGo back to the \u201cSecurity\u201d tab, click \u201cManage certificates\u201d, then unfold the\n\u201cView details\u201d section on the right side of the box for the existing\ncertificate.\n\nSee the IP addresses at the bottom? Here\u2019s the good news: these IP addresses\ndon\u2019t change. They are anycast addresses, so connecting to them will still\nreach servers close to clients.\n\nSo, as an alternative to CNAME records, regular A entries can be configured.\nAnd that works perfectly with apex domains such as, in our example,\nexample.com.\n\n## Setting up a Fastly Compute service\n\nIn addition to caching, we can run arbitrary code whenever our service\nreceives a request.\n\nFirst, delete the existing service. Go to the \u201cCDN\u201d tab, click on the service\nname, and in the \u201cOptions\u201d tab, choose \u201cDeactivate\u201d.\n\nFollow the instructions, then open the \u201cOptions\u201d tab again, and click\n\u201cDelete\u201d. Wait for a little while and reload the page: the service should be\ngone. The previously created TLS certificates are not deleted, though. There\u2019s\nno need to recreate them.\n\nTime to explore the \u201cCompute\u201d tab. Open it, followed by a click on the \u201cCreate\nservice\u201d button.\n\nBefore doing anything else, I\u2019d recommend opening the \u201cOptions\u201d menu and\nediting the service name.\n\nRemember that \u201cdomains\u201d are hostnames. So, enter the hostname that clients\nwill connect to, for example fastly.example.com, in the \u201cDomains\u201d form.\n\nNext, we need to register backends, i.e., how to connect to origin servers and\nretrieve the content. In the left pane, click the \u201cHosts\u201d link:\n\nand add the hostname (not a URI) or IP address of the origin.\n\nRemember that backends have several properties describing how to connect, but\nalso a name. That name is how the backend will be referenced in the code, so\nit\u2019s crucial to choose it wisely.\n\nBy default, we can see that it\u2019s simply called \u201cHost 1\u201d, which is not ideal.\nSo, click on the backend link to edit the properties and immediately change\nthe name. It\u2019s perfectly fine to set it to the same value as the hostname.\nHere, I\u2019m just going to call it \u201corigin\u201d:\n\nScroll all the way down and click \u201cUpdate\u201d.\n\nIn a simple caching scenario, that would be enough. But here, a critical piece\nis missing: the WebAssembly application that will run and decide how to handle\nHTTP requests.\n\n## The Fastly command-line tool\n\nWhile the API could be used directly, Fastly has an open-source command-line\ntool written in Go that can be downloaded here: Fastly command-line tool.\n\nThis tool is really handy for interacting with the CDN without the web UI, but\nalso for deploying WebAssembly modules. So, we\u2019re going to use it.\n\n## Deploying a WebAssembly module on Fastly\n\nFastly has a set of low-level APIs for interacting with the environment using\nWebAssembly. To use them in an idiomatic way, several high-level abstraction\nlibraries exist, at least for Go, JavaScript, Rust, Swift, and Zig. Fastly\nthemselves only maintain libraries for the first three, but they do not\ndiscourage third-party libraries for other languages.\n\nThe Compute service is billed according to bandwidth, CPU usage, and memory\nusage. Zig produces WebAssembly code that is generally faster and more memory-\nefficient than the other options. Since the language allows for precise\ncontrol over memory allocations, it can guarantee that the limits of the\nsubscription plan cannot be exceeded.\n\nWe will thus be using Zig to create our first WebAssembly module to run on\nFastly\u2019s servers.\n\nThe Zig library for Fastly Compute is called Zigly. The easiest way to start\nis to copy the Zigly example directory.\n\nOf course, the Zig toolchain must have been installed, in addition to the\nfastly command-line tool described above.\n\nWe\u2019re going to use the fastly command to set up a few things in the same\ndirectory:\n\n    \n    \n    fastly compute init\n\nThe command will report that the directory is not empty, which is fine. Please\nproceed.\n\nFor the name, we\u2019ll just use package. This is not the name of the service. It\ncan be anything, but it\u2019s easier to use the same name everywhere, as build\nscripts can be reused. package simply matches the name of the WebAssembly\nfile, as defined in the build.zig file.\n\nWhen asked for the language, choose Other ('bring your own' Wasm binary). This\ncreates a fastly.toml file that we can ignore for now.\n\nEdit that file and set service_id to the string displayed below the service\nname in the \u201cCompute\u201d tab of the web interface. It looks like\nmPc3P9NZaATbVTwC5z53f4.\n\nThe source code in src/main.zig is very concise:\n\n    \n    \n    // The backend name (registered as a \"host\" for that service in the Fastly UI) const backend_name = \"backend\"; // The hostname to use in the Host header when making requests to the backend // It can be set to `null` to use the original Host header const host_header = \"example.com\"; // Proxy all incoming requests to the backend, with transparent caching. pub fn main() !void { var downstream = try zigly.downstream(); try downstream.proxy(backend_name, host_header); }\n\ndownstream represents a connection from the client to the CDN, and upstream\nrepresents a connection from the CDN to some other server, such as the origin.\n\nIn this example, we tell the CDN to proxy everything from the client to a\nbackend, changing the Host: header along the way.\n\nbackend_name should be set to the name of the backend we previously registered\nin the web UI (i.e., origin). And host_header should be set to what the origin\nexpects (for example, example.com).\n\nLet\u2019s compile this to WebAssembly:\n\n    \n    \n    zig build -Doptimize=ReleaseSmall\n\nThe resulting Fastly Compute WebAssembly module can be found in zig-\nout/bin/package.wasm:\n\n    \n    \n    $ ls -l zig-out/bin/package.wasm -rwxr--r-- 1 j wheel 2867 May 6 22:47 zig-out/bin/package.wasm\n\nFor reference, the empty Rust template (which doesn\u2019t proxy anything, just\nreturns an empty response) weighs 5.2 MB.\n\nThe next step is to create an archive, suitable for being uploaded to the CDN:\n\n    \n    \n    fastly compute pack -w zig-out/bin/package.wasm\n\nAnd finally, we can deploy it:\n\n    \n    \n    fastly compute deploy\n\nAfter deployment, wait for a little while. It takes a couple of seconds to\ndeploy the application globally.\n\nThen, browse to the address of the service, and you should receive the content\nfrom the origin. The fastly compute serve command can be used for local\ntesting.\n\nNote that if you get a 500 Internal Server Error response while using the\nabove example, it may be that the backend_name constant was not properly set.\n\nCongratulations! You have just deployed a WebAssembly application globally.\n\nThe example code above may seem like it\u2019s not doing much, but remember that\nthis is not just a module running on a WebAssembly runtime, but rather\nmiddleware in a CDN pipeline. As a result, even without any additional code,\nthe content is automatically cached. Of course, it\u2019s also possible to reject\nconnections, send static content or dynamically generated content, and more.\n\nIf a cacheable resource is accessed multiple times, the origin will only be\nhit the first time, and the WebAssembly application won\u2019t even run: everything\nwill be directly served from the cache.\n\nCaching also applies to queries made by the WebAssembly application itself.\n\n## CDNs are simple and useful\n\nCDNs can feel obscure and intimidating. However, they are actually quite\nsimple to use and can quickly improve the security and efficiency of a web\nservice without requiring significant changes. With the ability to run\narbitrary code, modern CDNs can also support any custom logic you may have, no\nmatter how complex.\n\nI know what you\u2019re thinking. Why isn\u2019t this website (and most of my websites\nand services) using a CDN, then?\n\nIf a service receives little to no traffic, such as this blog, let\u2019s be\nhonest: a CDN is not going to make a significant difference.\n\nBut there\u2019s another reason: I manage my own DNS servers and I don\u2019t want to\ndelegate my domains to a CDN. Services like resolver.dnscrypt.info run a\ncustom DNS server, so that wouldn\u2019t work. The same applies to TLS\ncertificates. I want to maintain control over most of them the way I want (for\nexample, so that DoH hashes don\u2019t change). I also don\u2019t want to alter any of\nthe URIs of my services, as unfortunately required by many CDNs. My dream was\nto be able to enable CDN proxying only for cherry-picked services, without\ntouching anything else. And I only recently realized that it was possible\nusing Fastly. Now you know, too.\n\n  * Work\n  * Instagram\n  * Opensource\n  * DNSCrypt\n\nFrank Denis (Jedi/Sector One) blog at pureftpd.org\n\nTwitter: @simple_images | @jedisct1\n\n", "frontpage": false}
