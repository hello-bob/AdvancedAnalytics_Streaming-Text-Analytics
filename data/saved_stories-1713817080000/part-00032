{"aid": "40114148", "title": "Secure Boot and TPM-Backed Full Disk Encryption on NixOS", "url": "https://jnsgr.uk/2024/04/nixos-secure-boot-tpm-fde/", "domain": "jnsgr.uk", "votes": 3, "user": "jnsgruk", "posted_at": "2024-04-22 13:27:53", "comments": 0, "source_title": "Secure Boot & TPM-backed Full Disk Encryption on NixOS", "source_text": "Secure Boot & TPM-backed Full Disk Encryption on NixOS \u00b7 Jon Seager\n\n\u2193Skip to main content\n\n  1. /\n  2. Blog/\n  3. Secure Boot & TPM-backed Full Disk Encryption on NixOS/\n\n# Secure Boot & TPM-backed Full Disk Encryption on NixOS\n\n20 April 2024\u00b72682 words\u00b713 mins\n\n## Introduction #\n\nFor the last decade (whoa...) or so, I\u2019ve defaulted to using LUKS-encrypted\ndrives for my machines. In general, I configure an unencrypted boot/EFI\npartition, then place either an ext4 or btrfs filesystem inside a LUKS\ncontainer which is used for the root partition.\n\nSome of my machines also have extra disks: my desktop has a 1TB NVMe drive for\nroot, and a 2TB NVMe \u201cdata\u201d drive mounted in my home directory under\n/home/jon/data. I don\u2019t like having to type two different encryption\npassphrases at boot, so I usually have the extra disk automatically unlocked\nby putting the key in a file on the root drive, and placing an entry in\n/etc/crypttab.\n\nThis setup works fine for desktop machines, but it\u2019s cumbersome on headless\nmachines because unattended reboots require the disk passphrase to be entered\nat boot. Even then, all of my computers are exclusively used by me, and this\nsetup means I have to enter two passwords on every boot to get to a working\ndesktop environment (one for the disk, and one for the login manager).\n\nI solved this recently with a combination of Secure Boot and a Trusted\nPlatform Module (TPM), so let\u2019s look at those first with a brief and high-\nlevel overview of each.\n\n## What\u2019s a TPM? #\n\nMost machines that have been manufactured in the last decade, and certainly in\nthe last 5 years, contain a cryptographic coprocessor conforming to the\nTrusted Platform Module (TPM) spec. The TPM is a dedicated microcontroller\nprimarily used for verifying the integrity of a machine.\n\nTPMs can be used for storing cryptographic key material and performing basic\ncryptographic operations. The general premise is that keys can be loaded into\nthe TPM, which enables the TPM to perform cryptographic operations using that\nkey (signing, encrypting, etc.), but the key cannot be recovered or read from\nthe TPM unless certain conditions are met. TPMs also provide other facilities\nsuch as secure random number generation, which in turn enables them to\nsecurely generate cryptographic keys.\n\nVerifying system integrity essentially boils down to being able to ensure the\nmachine hasn\u2019t been tampered with between boots, and that the boot process\nitself hasn\u2019t been compromised. A given firmware or operating system can take\nhardware \u201cmeasurements\u201d and store those measurements in dedicated slots called\nPlatform Configuration Registers (PCRs). The measurements pertain to the\nunderlying hardware and configuration of the machine. The TPM itself never\nperforms the actual verification of the PCRs, and in fact has no knowledge of\nwhether a measurement is inherently \u201cgood\u201d or \u201cbad\u201d, but it can provide signed\nattestations of their values, which are then judged by the application\nrequesting the attestation according to some policy.\n\nEach PCR contains a hash representing a particular hardware measurement, which\ncan be read at any time, but cannot be overwritten. Rather than allowing a\ntraditional write operation, PCRs are updated through an \u201cextend\u201d operation\nwhich depends on the previous hash value, creating a chain of trust not\ndissimilar from how a blockchain is formed. This means that a given\nmeasurement can never be fully removed from the TPM.\n\nOnce the measurements are stored in the PCRs, there are various times and\npurposes for which the firmware or an operating system might read them - one\nexample is for remote attestation during login to a system. In this scenario\nthe attestation can be used to verify that the machine hasn\u2019t been tampered\nwith (perhaps in an Evil Maid attack). One could also store a Certificate\nAuthority signing key in a TPM, and have the Certificate Authority software\ninterface with the TPM to sign certificates using the PKCS#11 standard.\n\nMy use-case is to enabling the TPM to provide the passphrase to unlock a LUKS-\nencrypted disk, which is what I\u2019ll focus on in this post.\n\n## Secure Boot #\n\nSecure Boot is the mechanism by which the code executed by a machine\u2019s Unified\nExtensible Firmware Interface (UEFI) can be verified as trusted. In the vast\nmajority of cases, the first thing executed by the UEFI is a bootloader.\n\nWhen Secure Boot is enabled, each binary executed by the UEFI must contain a\nchecksum and a signature - which the UEFI verifies before launching the code.\nIn the case that either the checksum or signature do not match, the UEFI will\nrefuse the execute the code, and the boot process will halt.\n\nMany OEM machines ship with Microsoft Windows installed, and thus ship with\nthe necessary keys to validate signatures created with Microsoft\u2019s certificate\nauthority. Linux systems are able to utilise these keys through shim - a small\nand easily verifiable piece of software which is signed by Microsoft. shim\nsits between the UEFI and the bootloader in the boot process, obviating the\nneed for every Linux bootloader to be signed by Microsoft on every release.\nThe shim is designed to extend trust from the keys trusted by the computer\u2019s\nfirmware to a new set of keys controlled by the operating system.\n\nBut what does Secure Boot get us in reality? By signing the kernel, and in\nsome cases a single UEFI PE binary known as a Unified Kernel Image (UKI)\n(which contains the bootloader, the kernel, the command-line used to boot the\nkernel, and other resources), one can be reasonably sure that the boot process\nhasn\u2019t been tampered with.\n\nThis process thwarts a number of common physical attack vectors, such as\nmanipulating the kernel command line to bypass the machine\u2019s login and drop\nstraight to a root shell - and combined with disk encryption can prevent\noffline data transfer from the machine. It also defends against malware which\ncompromises the operating system\u2019s boot process such that it can start before\nthe OS and obfuscate it\u2019s presence.\n\n## Threat Modelling #\n\nAs with any security measure, Secure Boot is not a silver bullet. You should\nalways consider your own personal threat model, and the sorts of attacks\nyou\u2019re looking to defend against.\n\nFor example, Secure Boot can help prevent the sort of malware infections\ndescribed in the previous section, but if an attacker gets physical access to\nyour machine, and the UEFI isn\u2019t adequately protected, they could simply\ndisable secure boot and carry on unhindered.\n\nI mitigate this by password protecting the UEFI. This isn\u2019t perfect, but is\nlikely sufficient protection for my threat model which is more about\nprotecting chancers and petty thieves from gaining access to my information,\nthan from determined attackers who gain physical access to my property.\n\nStoring keys in a TPM is theoretically safe, in that each TPM has a unique\nseed which cannot be retrieved, and enables the TPM to deterministically\ngenerate keys between reboots. It\u2019s very difficult to retrieve the seed, and\nthus very difficult to duplicate a TPM, but not impossible. Even then, the\nLinux kernel\u2019s communication with the TPM on-the-wire is unencrypted, and the\nsame can be said for many other subsystems which use the TPM. A recent example\nof this vulnerability was demonstrated by sniffing a Bitlocker key off the LPC\nbus in a Lenovo X1 Carbon laptop (using a Raspberry Pi Pico, no less). In many\nmodern machines this is mitigated by the TPM being on-CPU, but the point still\nstands.\n\nI choose to enroll Microsoft\u2019s platform keys, which in theory degrades the\nsecurity of my device in the case that Microsoft\u2019s signing key is compromised,\nthough all of my machines are compatible with fwupd and can receive updates to\nthe database through that mechanism if required (and in fact have done in the\npast 18 months). This could be further mitigated by using custom keys and\ncertificates for the full chain, but this is more overhead for daily\noperations and updates. It\u2019s also worth considering whether you have the\nresources to fully secure your own chain - especially by comparison to\nMicrosoft who spend tens of millions of dollars per year on security. If an\nattacker wants your information, and are able to compromise Microsoft\u2019s CA,\nyour own CA may not be such a hurdle.\n\nSecurity measures are always a trade-off between Confidentiality, Availability\nand Integrity (CIA). In general, the more rigidly secure boot is implemented\nand configured, the more you\u2019re protecting confidentiality and integrity. The\nchoices I\u2019ve made are slightly more in favour of availability, but nonetheless\nraise the bar for any attacker significantly.\n\n## Enabling Secure Boot on NixOS #\n\nNow for the fun part! The process for enabling Secure Boot on NixOS has\nsimplified in recent months owing to the creation of lanzaboote - a project\nwhich takes of preparing and signing Unified Kernel Images containing a custom\nstub, the bootloader, the Linux kernel, the kernel\u2019s initrd and the kernel\ncommand line. lanzaboote also takes care of installing the UKI on the ESP\npartition so the UEFI can execute it at boot.\n\nThe lanzaboote stub differs slightly from systemd-stub, in that it doesn\u2019t\nrequire the kernel and initrd to be part of the UKI. This is important for a\ngeneration-based operating system like NixOS because bundling the kernel and\ninitrd into a new UKI for every generation would consume a lot of disk space,\nand quickly exhaust the ESP on most machines. In lanzaboote\u2019s implementation,\nthe kernel and initrd are stored separately on the ESP, and the chain of trust\nis preserved by validating the signature of the kernel, and embedding a\ncryptographic hash of the initrd into the signed UKI.\n\nThe project takes advantage of systems that have bootspec enabled, which is a\nrelatively recent NixOS RFC that ensures configured machines maintain a file\ncontaining a set of memoised facts about a system\u2019s closure. Bootspec aims to\n\u201cprovide more uniform feature support\u201d to bootloaders in the NixOS ecosystem\nand \u201cenable NixOS users to implement custom bootloader tools and policy\u201d - of\nwhich lanzaboote is one.\n\n### Generating Secure Boot Keys #\n\nThe first step is to generate some keys for the secure boot process. This can\nbe achieved using the sbctl package:\n\n    \n    \n    1 2 3 4\n\n|\n\n    \n    \n    \u276f sudo nix run nixpkgs#sbctl create-keys Created Owner UUID 6ac34cc3-a23d-9745-ef33-a03f523d20a3 Creating secure boot keys...\u2713 Secure boot keys created!  \n  \n---|---  \n  \nThis should only take a few seconds at maximum, and will result in a set of\nkeys being populated in /etc/secureboot:\n\n    \n    \n    1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17\n\n|\n\n    \n    \n    \u276f tree /etc/secureboot /etc/secureboot \u251c\u2500\u2500 files.db \u251c\u2500\u2500 GUID \u2514\u2500\u2500 keys \u251c\u2500\u2500 db \u2502 \u251c\u2500\u2500 db.key \u2502 \u2514\u2500\u2500 db.pem \u251c\u2500\u2500 dbx \u2502 \u251c\u2500\u2500 dbx.key \u2502 \u2514\u2500\u2500 dbx.pem \u251c\u2500\u2500 KEK \u2502 \u251c\u2500\u2500 KEK.key \u2502 \u2514\u2500\u2500 KEK.pem \u2514\u2500\u2500 PK \u251c\u2500\u2500 PK.key \u2514\u2500\u2500 PK.pem  \n  \n---|---  \n  \n### Enable Bootspec #\n\nEnsure that bootspec is enabled in your Nix configuration. You can see this in\nmy flake for my desktop machine on Github:\n\n    \n    \n    1 2 3\n\n|\n\n    \n    \n    { boot.bootspec.enabled = true; }  \n  \n---|---  \n  \n### Enable lanzaboote #\n\nI use a flake to configure all of my machines, so I\u2019m able to get access to\nlanzaboote by adding the upstream flake as an input to my own nixos-config\nflake:\n\n    \n    \n    1 2 3 4 5\n\n|\n\n    \n    \n    # ... inputs = { lanzaboote.url = \"github:nix-community/lanzaboote\"; }; # ...  \n  \n---|---  \n  \nOnce you\u2019ve added lanzaboote as a dependency, you\u2019ll need to import the\nlanzaboote module:\n\n    \n    \n    1 2 3\n\n|\n\n    \n    \n    # ... imports = [ lanzaboote.nixosModules.lanzaboote ]; # ...  \n  \n---|---  \n  \nIn my flake, I use a custom helper function to build NixOS configurations, so\nthe module is passed directly to lib.nixosSystem through the modules\nattribute.\n\nThe lanzaboote module replaces the systemd-boot module, and as such you must\nexplicitly disable systemd-boot when enabling lanzaboote:\n\n    \n    \n    1 2 3 4 5 6 7\n\n|\n\n    \n    \n    boot = { loader.systemd-boot.enable = lib.mkForce false; lanzaboote = { enable = true; pkiBundle = \"/etc/secureboot\"; }; };  \n  \n---|---  \n  \nThis is represented in my config here.\n\nOnce enabled, rebuild your system (in my case with sudo nixos-rebuild switch\n--flake /home/jon/nixos-config) and verify that your machine is ready for\nSecure Boot. Don\u2019t panic about the kernel images being reported as not signed,\nthis is expected:\n\n    \n    \n    1 2 3 4 5 6 7 8 9 10\n\n|\n\n    \n    \n    \u276f sudo nix run unstable#sbctl verify Verifying file database and EFI images in /boot... \u2713 /boot/EFI/BOOT/BOOTX64.EFI is signed \u2713 /boot/EFI/Linux/nixos-generation-414-376jna572gsb23snqs67t7s4bwxzb3epblmdnzweghuepopml2va.efi is signed \u2713 /boot/EFI/Linux/nixos-generation-415-iqulgohymbdppgtxzho6ou3fcuxjbxhumpzm4vojmipwy3sbmuna.efi is signed \u2713 /boot/EFI/Linux/nixos-generation-416-kxnzioafnduwwck3oypo7rqwtoat745czp2bpehoufp4yqiawypa.efi is signed \u2717 /boot/EFI/nixos/kernel-6.8.2-242idodyvf36cpl6s5dskjy6mo4tjhszuwa3hye7qcjyuo5vnehq.efi is not signed \u2717 /boot/EFI/nixos/kernel-6.8.5-zqulrwsucm6okcyns6v2jhh6fregk3bvsdth3yloqfymfbgnh64a.efi is not signed \u2717 /boot/EFI/nixos/kernel-6.8.7-6mmixkr6ewywm5swgbi5ethbpgnyia4borzmkevcjx7n7t3mtida.efi is not signed \u2713 /boot/EFI/systemd/systemd-bootx64.efi is signed  \n  \n---|---  \n  \n### Prepare the UEFI #\n\nReboot your machine and enter the UEFI interface. This part of the process\nwill vary from machine to machine depending on the UEFI implementation, but\nyou\u2019re looking to enable Secure Boot, and clear the preloaded Secure Boot\nkeys. This may be referred to as \u201cSetup Mode\u201d, or erasing the \u201cPlatform Keys\u201d.\n\nWhile you\u2019re here, I\u2019d also advise setting a UEFI password before rebooting\nback into NixOS.\n\n### Enroll Secure Boot Keys #\n\nThe final stage in the process is to enroll your newly generated Secure Boot\nkeys from step 1 into the UEFI. This is again achieved with sbctl:\n\n    \n    \n    1 2 3 4\n\n|\n\n    \n    \n    \u276f sudo nix run nixpkgs#sbctl enroll-keys -- --microsoft Enrolling keys to EFI variables... With vendor keys from microsoft...\u2713 Enrolled keys to the EFI variables!  \n  \n---|---  \n  \nI chose to use the --microsoft option to also enroll the UEFI vendor\ncertificates from Microsoft. Some systems contain firmware that is signed and\nvalidated when Secure Boot is enabled, and omitting the Microsoft keys could\nprevent your device from booting - omit this option with caution!\n\n### Verify Secure Boot #\n\nOnce you\u2019ve enrolled the keys, reboot the machine back into NixOS and use\nbootctl to confirm that Secure Boot is in fact enabled:\n\n    \n    \n    1 2 3 4 5 6 7\n\n|\n\n    \n    \n    \u276f bootctl status System: Firmware: UEFI 2.80 (American Megatrends 5.26) Firmware Arch: x64 Secure Boot: enabled (user) TPM2 Support: yes Boot into FW: supported  \n  \n---|---  \n  \n## TPM Unlock of Root Partition #\n\nNow that we\u2019re (reasonably) confident that no one can tamper with the boot\nprocess, we can progress to allowing the machine to auto-unlock the encrypted\ndisk using a key stored in the TPM.\n\nThis is actually more common than you might think - Windows has enabled this\nbehaviour by default for some time with Bitlocker disk encryption, and\nCanonical is also working on bringing TPM-backed full disk encryption to\nUbuntu.\n\nThis is probably the easiest step of them all! A simple invocation of systemd-\ncryptenroll is all that\u2019s required. The arguments below instruct the machine\nthat PCRs 0, 2 and 7 should be measured and verified before the TPM is allowed\nto unlock the disk:\n\n    \n    \n    1\n\n|\n\n    \n    \n    \u276f sudo systemd-cryptenroll --tpm2-device=auto --tpm2-pcrs=0+2+7 /dev/nvme0n1p2  \n  \n---|---  \n  \nAnd that\u2019s it! The next time you reboot, your disk should be automatically\nunlocked by the TPM, and your machine should boot straight to your display\nmanager, or the TTY login if no display manager is configured.\n\n## Useful Resources #\n\nNone of the knowledge in this post is novel, but rather the culmination of\nsome knowledge acquired over the past few years, and some more targeted\nreading more recently. In the process, I learned a bunch from the following:\n\n  * Lanzaboote on Github\n  * ArchWiki on UEFI Secure Boot\n  * NixOS Discourse Post on TPM Unlock\n  * Bootspec RFC\n  * Lennart Poettering\u2019s UKI Talk at FOSDEM 2024\n  * James Bottomley\u2019s TPM Talk at FOSDEM 2024 The Trusted Platform Module Key Hierarchy\n\n## Summary #\n\nAbout 5 years ago, I was sporting a fully secure-boot enabled Dell XPS 13\nrunning Arch Linux. Back then, the process was complicated, manual, and\nrequired a lot of maintenance between upgrades. For me, it was more pain than\ngain, but an interesting learning experience nonetheless.\n\nWhen I sat down earlier this year to enable Secure Boot on NixOS, I\u2019d set\naside a few hours. I was astounded that 10 minutes later I was finished. I\nwrote this post as a memo to my future self, but also to illustrate how simple\nit can be to enable Secure Boot and TPM disk unlock in 2024.\n\nI don\u2019t claim to be an expert on the inner workings of TPMs, nor Secure Boot.\nThe things I can say for certain are that TPMs are complex, that there are\nimprovements that could be made to Linux\u2019s interactions with the TPM, and that\na determined and well-resourced attacker is likely going to succeed one way or\nanother.\n\nIf you spot an inaccuracy in this post, reach out and let me know on Mastodon,\non Telegram, by email, or however you prefer!\n\nUntil next time!\n\nAuthor\n\nJon Seager\n\nHusband, father, leader, software engineer, geek.\n\n\u2190\u2192 Simplifying Test & Release of Snapped GUI Apps 18 March 2024\n\n\u2191\n\n", "frontpage": false}
