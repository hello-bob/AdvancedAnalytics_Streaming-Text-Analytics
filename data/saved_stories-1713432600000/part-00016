{"aid": "40071330", "title": "Formal Methods: Just Good Engineering Practice?", "url": "https://brooker.co.za/blog/2024/04/17/formal.html", "domain": "brooker.co.za", "votes": 1, "user": "luu", "posted_at": "2024-04-17 23:43:52", "comments": 0, "source_title": "Formal Methods: Just Good Engineering Practice? - Marc's Blog", "source_text": "Formal Methods: Just Good Engineering Practice? - Marc's Blog\n\n# Marc's Blog\n\n# About Me\n\nMy name is Marc Brooker. I've been writing code, reading code, and living\nvicariously through computers for as long as I can remember. I like to build\nthings that work. I also dabble in machining, welding, cooking and skiing.\n\nI'm currently an engineer at Amazon Web Services (AWS) in Seattle, where I\nwork on databases, serverless, and serverless databases. Before that, I worked\non EC2 and EBS. All opinions are my own.\n\n# Links\n\nMy Publications and Videos @marcbrooker on Mastodon @MarcJBrooker on Twitter\n\n# Formal Methods: Just Good Engineering Practice?\n\nYes. The answer is yes. In your face, Betteridge.\n\nEarlier this week, I did the keynote at TLA+ conf 2024. My message in the\nkeynote was something I have believed to be true for a long time: formal\nmethods are an important part of good software engineering practice. If you\u2019re\na software engineer, especially one working on large-scale systems,\ndistributed systems, or critical low-level system, and are not using formal\nmethods as part of your approach, you\u2019re probably wasting time and money.\n\nBecause, ultimately, engineering is an exercise in optimizing for time and\nmoney^1.\n\n> \u201cIt would be well if engineering were less generally thought of, and even\n> defined, as the art of constructing. In a certain important sense it is\n> rather the art of not constructing; or, to define it rudely but not inaptly,\n> it is the art of doing that well with one dollar, which any bungler can do\n> with two after a fashion.\u201d Arthur Wellington^2\n\nAt first, this may seem counter-intuitive. Formal methods aren\u2019t cheap, aren\u2019t\nparticularly easy, and don\u2019t fit well into every software engineering\napproach. Its reasonable to start with the belief that a formal approach would\nincrease costs, especially non-recurring engineering costs. My experience is\nthat this isn\u2019t true, for two reasons. The first is rework. Software\nengineering is somewhat unique in the engineering fields in that design and\nconstruction tend to happen at the same time, and a lot of construction can be\nstarted without a advancing much into design. This isn\u2019t true in electrical\nengineering (designing a PCB or laying cables can\u2019t really be done until\ndesign is complete), or civil engineering (starting the earthworks before you\nknow what you\u2019re building is possible, but a reliable way to waste money), or\nmechanical engineering, and so on. This is a huge strength of software - its\nmutability has been one of the reasons it has taken over the world - but can\nalso significantly increase the cost of design iterations by turning design\niterations into implementation iterations. The second is the cost of change.\nOnce an API or system has customers, changing it becomes many times more\nexpensive and difficult. This is fundamentally related to Hyrum\u2019s Law:\n\n> With a sufficient number of users of an API, it does not matter what you\n> promise in the contract: all observable behaviors of your system will be\n> depended on by somebody.\n\nIsolating the behavior of systems with APIs is an excellent idea. In fact, I\nwould consider it one of the most important ideas in all of software\nengineering. Hyrum\u2019s Law reminds us of the limitations of the approach: users\nwill end up depending on every conceivable implementation detail of an API.\nThis doesn\u2019t mean change is impossible. I have been involved in many projects\nin my career that have completely re-implemented the system behind APIs. It\nmerely means that change is expensive, and that abstractions like APIs don\u2019t\neffectively change that reality.\n\nBy saving on the cost of rework, and by getting interface changes out of the\nway earlier, formal design work can significantly increase the speed and\nefficiency of the software building process.\n\nWhat kinds of systems?\n\nThis doesn\u2019t seem to apply to all kinds of software. Software which is heavily\ndriven by fast-evolving or hard-to-formalize user requirements, from UIs and\nweb sites to implementations of pricing logic, may require so much ongoing\nrework that the value of up-front design is diluted (or its costs\nsignificantly increased). This is the underlying idea behind agile: by running\nimplementation and requirements-gathering in parallel the wall-clock time-to-\nmarket can be reduced. More importantly, where requirements gathering is an\nongoing process, it allows implementations to be completed even while\nrequirements evolve. In many cases, this parallel approach to development is\noptimal, and even necessary to make any progress at all.\n\nOn the other hand, much of the software behind large-scale, distributed, and\nlow-level systems has well understood requirements. Or, at least, a large\nenough subset of well understood static requirements that upfront formal\ndesign reduces rework and bug density during the implementation phase (and\nafter, when the system is in production) considerably.\n\nMuch of the debate about design-up-front vs agile comes from folks on\ndifferent ends of the software spectrum talking past each other. We shouldn\u2019t\nbe surprised that software with very different models for requirements-\ngathering would have different optimal engineering approaches. It seems like\nthe closer the requirements process is to the laws of physics the more\nvaluable design, and formal design, are in the engineering process. The closer\nthe requirements are to users\u2019 opinions, the less valuable they are.\n\nThe other disagreement in this space also seems to come from different ideas\nabout what formal approaches are, and how they\u2019re valuable. I, for example,\ntend to see much of the circles and arrows school of software design as a\nwaste of time that doesn\u2019t directly engage with the really hard questions.\nThat opinion may stem from ignorance, and is one I hold weakly. But I am sure\nthat my university SE class experience of describing 100 lines of code in 100\nreams of UML left me with an unreasonably low opinion of the benefits of\ndesigning software. Done badly, or with bad tools, even the most valuable\nthings are useless.\n\nWhich tools?\n\nFormal methods and automated reasoning are broad fields, with a vast number of\ntools. Over my career, in my domain in big cloud systems, I have found the\nfollow set useful (but am sure there are tools I would find useful if only I\nknew them).\n\n  * Specification languages like P, TLA+, and Alloy, along with their associated model checkers.\n  * Deterministic simulation tools like turmoil that allow, along with fuzzing, a principled approach to searching a state space through testing.\n  * Verification-aware programming languages like Dafny and code verifiers like Kani. I\u2019m not a deep expert in these tools, and have used them a lot less than the others.\n  * Numerical simulation techniques. I tend to build my own (as I\u2019ve written about before), but there are many frameworks and tools out there.\n\nI like the survey of methods in Using Lightweight Formal Methods to Validate a\nKey-Value Storage Node in Amazon S3 too. That\u2019s a great place to start.\n\nBut, to the point of this post, we don\u2019t want to get too tied to the idea that\nverifying an implementation is the only worthy end goal here. That is a worthy\ngoal indeed, but I have found a great deal of value in using tools like TLA+\nand P to think through designs more quickly and concretely before building.\n\nFaster software, faster\n\nBack in 2015 when we were writing How Amazon Web Services Uses Formal Methods\nfor CACM, my focus was very much on correctness. On verifying the safety and\nliveness properties of my designs, and in getting to a correct design faster.\nIn talking to one of the teams that was using TLA+ on an internal lock\nmanagement system, I discovered something I loved even more. These words, from\nTable 1:\n\n> verified an aggressive optimization\n\nThis was eye-opening. Not only do tools like TLA+ help us to build systems\nfaster, they help us to build faster systems. They allow us to quickly explore\nfor possible optimizations, find the constraints that really matter, and check\nwhether our proposed optimizations are correct. They, in many cases, remove\nthe hard trade-off between correctness and performance which many systems can\nget stuck in.\n\nConclusion\n\nUsing tools to help us think about the design of systems at the design stage\ncan significantly increase the speed of software development, reduce risk, and\nallow us to develop more optimal systems from the beginning. For those of us\nworking on large-scale and complex systems, they are simply a part of a good\nengineering practice.\n\nFootnotes\n\n  1. And other related things, like performance, scalability, sustainability, and efficiency.\n  2. I love this quote so much I bought a copy of this Wellington\u2019s 1877 book just to see it on paper.\n\n## Other Posts\n\n\u00ab Back to the blog index\n\n  * 25 Mar 2024 \u00bb Finding Needles in a Haystack with Best-of-K\n  * 04 Mar 2024 \u00bb The Builder's Guide to Better Mousetraps\n  * 12 Feb 2024 \u00bb Better Benchmarks Through Graphs\n\nMarc Brooker The opinions on this site are my own. They do not necessarily\nrepresent those of my employer. marcbrooker@gmail.com\n\nRSS Atom\n\nThis work is licensed under a Creative Commons Attribution 4.0 International\nLicense.\n\n", "frontpage": false}
