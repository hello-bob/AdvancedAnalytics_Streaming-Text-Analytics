{"aid": "40291417", "title": "Docs as code is a broken promise", "url": "https://thisisimportant.net/posts/docs-as-code-broken-promise/", "domain": "thisisimportant.net", "votes": 3, "user": "billybuckwheat", "posted_at": "2024-05-07 21:00:58", "comments": 0, "source_title": "Docs as code is a broken promise", "source_text": "Docs as code is a broken promise | This is important\n\nDocs as code is a broken promise\n\n# \ud83c\udfe0 This is important\n\n# Docs as code is a broken promise\n\nApril 10, 2024\n\nDocs as code is a much-vaunted workflow and toolchain for writing, publishing,\nand maintaining technical documentation \u2014 but in practice, docs as code\ndoesn\u2019t deliver on its promise.\n\n## What is docs as code?\n\nAccording to the Docs as Code page in the Documentation guide for Write the\nDocs:\n\n> Documentation as Code (Docs as Code) refers to a philosophy that you should\n> be writing documentation with the same tools as code:\n>\n>   * Issue Trackers\n>   * Version Control (Git)\n>   * Plain Text Markup (Markdown, reStructuredText, Asciidoc)\n>   * Code Reviews\n>   * Automated Tests\n>\n\n>\n> This means following the same workflows as development teams, and being\n> integrated in the product team. It enables a culture where writers and\n> developers both feel ownership of documentation, and work together to make\n> it as good as possible.\n\nThis is promising \u2014 shared ownership of documentation and a shared goal to\nmake documentation as good as possible by sharing the same tools and\nprocesses.\n\nAll too often, however, I find that this philosophy is adopted as a set of\ntools, and the processes and integration are ignored. Even if you have\nprocesses in place, the tools you use to do docs as code make it easy to\ncircumvent the processes, even unintentionally.\n\n## The promise of docs as code\n\nIf your documentation workflows follow the development workflows, as a\ntechnical writer, you can get your job done more easily.\n\nIf you do docs as code...\n\n  * Documentation reviews can take the same format as code reviews\u2014a pull request\u2014making it easier to get reviews from engineers.\n  * Code samples can be automatically tested, or better yet, pulled in at build time from the product code.\n  * Doc changes can happen in sync with the product changes if docs are in the same repo, streamlining the release cycle.\n  * Documentation can be versioned, and you can keep track of when and how a given page was last updated.\n\n## The pitfalls of docs as code\n\nWriting content isn\u2019t the same as developing code, and as a result, doing docs\nas code has pitfalls:\n\n  * Git is confusing\n  * Processes must be defined and reflected in Git workflows\n  * Tools to write docs can be inconsistent\n  * Merge gates and build checks are great... if you have them\n  * Reviewing content in the repository is hard to read\n\nLet me explain...\n\n### Git is confusing\n\nTo do docs as code, writers need to learn how to use and troubleshoot Git. And\nGit isn\u2019t simple \u2014 Julia Evans made an entire Zine about it and has been\nworking on a longer series about Git concepts to make it much clearer.\n\nThere is a deep level of complexity with Git, and while you can go a long way\nonly knowing how to git fetch, git pull, and git merge, it\u2019s easy to get into\nan unexpected state with your cloned Git repo, local branch, or disastrous\nmerge conflict resolution decisions. In those cases, often the best\ntroubleshooting is starting over \u2014 and that\u2019s not a great experience!\n\n### Processes must be defined and reflected in Git workflows\n\nWhen you use a docs as code workflow, you need to codify your docs processes\nand instantiate them in your Git workflow. So you not only need to define the\nfollowing:\n\n  * When to publish doc updates\n  * How to release doc updates\n  * How to coordinate a docs release with a product release\n\nYou also need to define Git best practices for your team about how to manage\nthose, such as:\n\n  * Whether to use release branches, or merge pull requests frequently but publishing infrequently.\n  * Whether to use Git rebase or Git merge to maintain Git history in a given branch.\n  * Whether and how to use feature branches and pull requests.\n  * Whether to squash merge pull requests to main.\n\nEven if you manage to define best practices that your team is committed to\nfollowing, there isn\u2019t a way to force your documentation contributors to\nadhere to all of these best practices. Due to the lack of enforcement of these\nbest practices, you can easily end up in a situation where writers follow\nslightly different practices based on what their tools make easy to do.\n\nAs just one example, I spent several weeks merging all my pull requests to\nmain, instead of squash merging as was the best practice. At some point, I\u2019d\nneeded to do a regular merge and preserve all my branch commits on main, and\nGitHub \u201chelpfully\u201d remembered my last-used setting.\n\nBecause the best practice was just a practice, and not enforced, it took me\nseveral weeks of cluttering up main with my chaotic branch commit history\nbefore I realized what was happening. In the meantime, the best practice of\nsquash merging, meant to maintain a clear association between a PR of feature\nchanges and a Jira ticket, was completely ignored with no warning.\n\n### Tools to write docs can be inconsistent\n\nIn a typical docs as code environment, you write locally and push your changes\nup to a central repository. Unlike a typical content management system (CMS)\nlike WordPress or Drupal, or software like MadCap Flare, the writing\nenvironment isn\u2019t shared \u2014 only the content is the same.\n\nInstead, the writing environment is relatively uncontrolled by default \u2014 a\nwriter can choose to write their content in whatever system they want, so long\nas they can commit text to the Git repository.\n\nA writer contributing to the documentation can write in a basic text editor\nlike Sublime Text, an extension-filled Visual Studio Code setup, in vim, or\nsome other tool \u2014 even the GitHub or GitLab UI!\n\nBecause only the end result matters to docs as code, different writers and\ndocumentation contributors can use different tools with different settings and\nfunctionality. However, these environment inconsistencies can lead to\ninconsistent content quality and style, and make issues with content\ndevelopment more difficult to troubleshoot.\n\nIf you use a text editor that doesn\u2019t have a spell checker installed, you can\neasily introduce typos into the documentation \u2014 but only the topics that you\ncontribute to. If your colleague doesn\u2019t use a system supported by the\nautomated style checker recommended by your team, the style of their\ndocumentation topics will deviate from company style.\n\n### Merge gates and build checks are great... if you have them\n\nOne advantage of docs as code is the extensibility and automated nature of the\nworkflows. Because you can treat documentation content like code, you can\nimplement some code-like practices, like checking the validity of your\ndocumentation markup when you propose changes to the documentation with your\npull request (a merge gate) or when you build the documentation site (a build\ncheck).\n\nHowever, to take advantage of these capabilities, you often need to build the\ntools and checks yourself, or get your documentation platform team to build\nthem for you \u2014 right after they work on the rest of the backlog of\nimprovements for the customer-facing documentation site.\n\nSome companies put a lot of effort into engineering efficiency, with entire\ndeveloper experience teams devoted to improving engineering workflows.\nMeanwhile, documentation teams are often lucky to get one engineer to work on\nthe documentation site itself, let alone help enable any special docs as code\nworkflows. This makes sense for the business, but it makes it difficult to\ntake advantage of what docs as code can do for you.\n\nFor example, you could set up merge gates or build checks to perform\ndocumentation quality improvement tasks like the following:\n\n  * Optimize image size\n  * Lint content to standardize and correct markup\n  * Check for broken links\n  * Test code examples\n  * Validate adherence to the style guide\n  * Check spelling and grammar\n\nSome of these might make more sense to implement in your writing tool directly\n(such as with Visual Studio Code extensions), but then you would need to\nrequire writers to all use the same writing tools configured in the same way.\n\nWithout resources to implement custom merge gates or build checks for\ndocumentation quality, documentation writers have the added process burden of\nopening a pull request, requesting reviews and approvals, and miss out on the\npotential advantage of automating tedious tasks. And if their content is in\nthe same repository as the product code, they also need to wait for a bunch of\nunrelated tests to pass before they can merge any doc updates.\n\n### Reviewing content in the repository is hard to read\n\nA much-touted benefit to docs as code is that the content is in the same tools\nused by engineers, which makes it easy to get technical reviews done in\nGitHub, GitLab, or your Git provider of choice.\n\nUnfortunately, documentation reviews in a pull request can be confusing. Just\nlike reviewing UI code is difficult if you only have access to the source and\nnot a staging environment, if you can\u2019t provide your reviewers with a staged\nor preview version of the content, you might get a technical review full of\nconfused comments instead of helpful feedback.\n\nAn engineer might see that you deleted lines from a file, not realizing that\nyou deleted them because they were in the wrong place, not because the\ninformation was wrong.\n\nSomeone else might comment that you need to provide a note on several pages,\nnot realizing that you did that \u2014 using a single sourced content reference\nthat isn\u2019t obvious to someone who doesn\u2019t write documentation.\n\nParsing a documentation pull request and providing helpful comments requires\nthe reviewer experience the content the same way that a future customer will \u2014\nbut a pull request only provides the raw, marked up text.\n\n## Upholding the docs as code promise\n\nIn its current state, with these pitfalls I\u2019ve outlined (and more), I find it\nproblematic to recommend docs as code as a one-size-fits-all solution for all\nyour technical writing CMS needs. Docs as code is a workflow with processes\nand tools, and therefore requires investment, maintenance, and a decent amount\nof custom tooling to get true value out of it.\n\nIt\u2019s possible that using a well-resourced static site generator like\nDocusaurus or MkDocs as part of your docs as code workflow might address some\nof these pitfalls, but from my impressions writing, building, and deploying\nthis blog using the Hugo static site generator, it\u2019s unlikely. I\u2019d guess that\nthose give you extensions and flexibility to make a static site work well for\ndocumentation, but they don\u2019t solve the core writing experience challenges of\na docs as code workflow.\n\nIf you\u2019re considering implementing docs as code workflows, you can choose the\ndegree to which you want to adopt the practices. If you require a branch, pull\nrequest, and all build checks to pass to fix a typo, the time it takes to fix\na typo could easily triple. On the other hand, with that level of overhead,\nyou gain ultimate auditability of documentation changes \u2014 the what, when, why,\nand by whom.\n\nWhen considering docs as code workflows today, I often see what my friend\nreferred to as the \u201cmost extreme option\u201d \u2014 a writing team and toolchain that\nhas adopted all the practices from code development. I think to uphold the\npromise of docs as code, we could do to add a bit more of the docs back into\nthe workflow.\n\nAs Fabrizio Ferri Benedetti put it in his post, The pros and cons of using\nMarkdown ^1:\n\n> you want the docs to be the product [...] But be very careful about the\n> product not being, for example, the pipelines or the site you\u2019re gonna\n> render.\n\nThere are newer CMSes on the market, like ReadMe, Heretto, Paligo, and others.\nFrom my extremely limited experience using one of these CMSes, it seems like\nthe writing experience is much simpler, and there is a way to write Markdown\nwithout needing to use developer level tools.\n\nUnfortunately, it seems like these tools also still need to mature and borrow\nmore of the practices that do work in docs as code, like being able to\ncompartmentalize documentation drafts and release specific changes at a\nspecific time.\n\nIt could be as well that we are early enough in the docs as code ecosystem\nthat the tooling hasn\u2019t yet matured\u2014but Anne Gentle\u2019s book Docs Like Code came\nout in 2017, so this concept has been around for some time.\n\nI sincerely hope that the content management systems improve, or that we see\nmore standardized toolchains with guardrails that enforce best practices for\ndoing docs as code.\n\nThe easier it is to implement docs as code \u2014 consistently, without much room\nfor individual writer error \u2014 the easier it is to focus on producing high\nquality documentation, together. This is exactly why large companies have\nentire engineering efficiency teams.\n\nWhat would it take to get a writer efficiency community to focus on a\nspectacular docs as code experience?\n\n  1. That post is a follow-up of his comments in the webinar, Pros and Cons of Using Markdown for Technical Documentation Panel Discussion, which covers some of the same ground as I do in this post (and beyond), such as things about availability and scalability of the content for developers contributing to the content, and an illusion that implementing such a workflow can be free. \u21a9\ufe0e\n\nCopyright \u00a9 2023 Sarah Moir\n\n", "frontpage": false}
