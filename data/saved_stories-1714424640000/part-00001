{"aid": "40199229", "title": "WebAssembly performance patterns for web apps", "url": "https://web.dev/articles/webassembly-performance-patterns-for-web-apps", "domain": "web.dev", "votes": 1, "user": "tomayac", "posted_at": "2024-04-29 15:02:52", "comments": 0, "source_title": "WebAssembly performance patterns for web apps | Articles | web.dev", "source_text": "WebAssembly performance patterns for web apps | Articles | web.dev\n\nweb.dev uses cookies from Google to deliver and enhance the quality of its\nservices and to analyze traffic. Learn more.\n\n  * English\n  * Deutsch\n  * Espa\u00f1ol \u2013 Am\u00e9rica Latina\n  * Fran\u00e7ais\n  * Indonesia\n  * Italiano\n  * Polski\n  * Portugu\u00eas \u2013 Brasil\n  * Ti\u1ebfng Vi\u1ec7t\n  * T\u00fcrk\u00e7e\n  * \u0420\u0443\u0441\u0441\u043a\u0438\u0439\n  * \u05e2\u05d1\u05e8\u05d9\u05ea\n  * \u0627\u0644\u0639\u0631\u0628\u064a\u0651\u0629\n  * \u0641\u0627\u0631\u0633\u06cc\n  * \u0939\u093f\u0902\u0926\u0940\n  * \u09ac\u09be\u0982\u09b2\u09be\n  * \u0e20\u0e32\u0e29\u0e32\u0e44\u0e17\u0e22\n  * \u4e2d\u6587 \u2013 \u7b80\u4f53\n  * \u4e2d\u6587 \u2013 \u7e41\u9ad4\n  * \u65e5\u672c\u8a9e\n  * \ud55c\uad6d\uc5b4\n\nSign in\n\n  * On this page\n  * Assumptions\n  * Loading, compilation, and instantiation of the module\n  * Shift the task to a Web Worker\n\n    * Restructure of the main thread\n    * Bad: Task runs in Web Worker, but code is racy\n    * Better: Task runs in Web Worker, but with possibly redundant loading and compiling\n    * Good: Task runs in Web Worker, and loads and compiles only once\n    * Perfect: Task runs in inline Web Worker, and loads and compiles only once\n    * Lazy or eager Web Worker creation\n    * Keep the Web Worker around or not\n  * Demos\n  * Conclusions\n  * Acknowledgements\n\n  * Home\n  * Articles\n\nWas this helpful?\n\n# WebAssembly performance patterns for web apps\n\nbookmark_borderbookmark Stay organized with collections Save and categorize\ncontent based on your preferences.\n\n  * On this page\n  * Assumptions\n  * Loading, compilation, and instantiation of the module\n  * Shift the task to a Web Worker\n\n    * Restructure of the main thread\n    * Bad: Task runs in Web Worker, but code is racy\n    * Better: Task runs in Web Worker, but with possibly redundant loading and compiling\n    * Good: Task runs in Web Worker, and loads and compiles only once\n    * Perfect: Task runs in inline Web Worker, and loads and compiles only once\n    * Lazy or eager Web Worker creation\n    * Keep the Web Worker around or not\n  * Demos\n  * Conclusions\n  * Acknowledgements\n\nThomas Steiner\n\nIn this guide, aimed at web developers who want to benefit from WebAssembly,\nyou'll learn how to make use of Wasm to outsource CPU-intensive tasks with the\nhelp of a running example. The guide covers everything from best practices for\nloading Wasm modules to optimizing their compilation and instantiation. It\nfurther discusses shifting the CPU-intensive tasks to Web Workers and looks\ninto implementation decisions you'll be confronted with like when to create\nthe Web Worker and whether to keep it permanently alive or spin it up when\nneeded. The guide iteratively develops the approach and introduces one\nperformance pattern at a time, until suggesting the best solution to the\nproblem.\n\n## Assumptions\n\nAssume you have a very CPU-intensive task that you want to outsource to\nWebAssembly (Wasm) for its close-to-native performance. The CPU-intensive task\nused as an example in this guide calculates the factorial of a number. The\nfactorial is the product of an integer and all the integers below it. For\nexample, the factorial of four (written as 4!) is equal to 24 (that is, 4 * 3\n* 2 * 1). The numbers get big quickly. For example, 16! is 2,004,189,184. A\nmore realistic example of a CPU-intensive task could be scanning a barcode or\ntracing a raster image.\n\nA performant iterative (rather than recursive) implementation of a factorial()\nfunction is shown in the following code sample written in C++.\n\n    \n    \n    #include <stdint.h>\n    \n    extern \"C\" {\n    \n    // Calculates the factorial of a non-negative integer n. uint64_t factorial(unsigned int n) { uint64_t result = 1; for (unsigned int i = 2; i <= n; ++i) { result *= i; } return result; }\n    \n    }\n\nFor the rest of the article, assume there's a Wasm module based on compiling\nthis factorial() function with Emscripten in a file called factorial.wasm\nusing all code optimization best practices. For a refresher on how to do this,\nread Calling compiled C functions from JavaScript using ccall/cwrap. The\nfollowing command was used to compile factorial.wasm as standalone Wasm.\n\n    \n    \n    emcc -O3 factorial.cpp -o factorial.wasm -s WASM_BIGINT -s EXPORTED_FUNCTIONS='[\"_factorial\"]' --no-entry\n\nIn HTML, there's a form with an input paired with an output and a submit\nbutton. These elements are referenced from JavaScript based on their names.\n\n    \n    \n    <form> <label>The factorial of <input type=\"text\" value=\"12\" /></label> is <output>479001600</output>. <button type=\"submit\">Calculate</button> </form>\n    \n    \n    const input = document.querySelector('input'); const output = document.querySelector('output'); const button = document.querySelector('button');\n\n## Loading, compilation, and instantiation of the module\n\nBefore you can use a Wasm module, you need to load it. On the web, this\nhappens through the fetch() API. As you know that your web app depends on the\nWasm module for the CPU-intensive task, you should preload the Wasm file as\nearly as possible. You do this with a CORS-enabled fetch in the <head> section\nof your app.\n\n    \n    \n    <link rel=\"preload\" as=\"fetch\" href=\"factorial.wasm\" crossorigin />\n\nNote: You can optionally fine-tune the priority of the preload using the\nfetchpriority attribute so it doesn't compete with even more urgent resources.\n\nIn reality, the fetch() API is asynchronous and you need to await the result.\n\n    \n    \n    fetch('factorial.wasm');\n\nNext, compile and instantiate the Wasm module. There are temptingly named\nfunctions called WebAssembly.compile() (plus WebAssembly.compileStreaming())\nand WebAssembly.instantiate() for these tasks, but, instead, the\nWebAssembly.instantiateStreaming() method compiles and instantiates a Wasm\nmodule directly from a streamed underlying source like fetch()\u2014no await\nneeded. This is the most efficient and optimized way to load Wasm code.\nAssuming the Wasm module exports a factorial() function, you can then use it\nstraight away.\n\n    \n    \n    const importObject = {}; const resultObject = await WebAssembly.instantiateStreaming( fetch('factorial.wasm'), importObject, ); const factorial = resultObject.instance.exports.factorial;\n    \n    button.addEventListener('click', (e) => { e.preventDefault(); output.textContent = factorial(parseInt(input.value, 10)); });\n\n## Shift the task to a Web Worker\n\nIf you execute this on the main thread, with truly CPU-intensive tasks, you\nrisk blocking the entire app. A common practice is to shift such tasks to a\nWeb Worker.\n\n### Restructure of the main thread\n\nTo move the CPU-intensive task to a Web Worker, the first step is to\nrestructure the application. The main thread now creates a Worker, and, apart\nfrom that, only deals with sending the input to the Web Worker and then\nreceiving the output and displaying it.\n\n    \n    \n    /* Main thread. */\n    \n    let worker = null;\n    \n    // When the button is clicked, submit the input value // to the Web Worker. button.addEventListener('click', (e) => { e.preventDefault();\n    \n    // Create the Web Worker lazily on-demand. if (!worker) { worker = new Worker('worker.js');\n    \n    // Listen for incoming messages and display the result. worker.addEventListener('message', (e) => { output.textContent = e.result; }); }\n    \n    worker.postMessage({ integer: parseInt(input.value, 10) }); });\n\n### Bad: Task runs in Web Worker, but code is racy\n\nThe Web Worker instantiates the Wasm module and, upon receiving a message,\nperforms the CPU-intensive task and sends the result back to the main thread.\nThe problem with this approach is that instantiating a Wasm module with\nWebAssembly.instantiateStreaming() is an asynchronous operation. This means\nthat the code is racy. In the worst case, the main thread sends data when the\nWeb Worker isn't ready yet, and the Web Worker never receives the message.\n\n    \n    \n    /* Worker thread. */\n    \n    // Instantiate the Wasm module. // \ud83d\udeab This code is racy! If a message comes in while // the promise is still being awaited, it's lost. const importObject = {}; const resultObject = await WebAssembly.instantiateStreaming( fetch('factorial.wasm'), importObject, ); const factorial = resultObject.instance.exports.factorial;\n    \n    // Listen for incoming messages, run the task, // and post the result. self.addEventListener('message', (e) => { const { integer } = e.data; self.postMessage({ result: factorial(integer) }); });\n\nNote: You could introduce a messaging system where the Web Worker informs the\nmain thread once the Wasm module is ready, and only then accept incoming\nrequests.\n\n### Better: Task runs in Web Worker, but with possibly redundant loading and\ncompiling\n\nOne workaround to the problem of asynchronous Wasm module instantiation is to\nmove the Wasm module loading, compilation, and instantiation all into the\nevent listener, but this would mean that this work would need to happen on\nevery received message. With HTTP caching and the HTTP cache able to cache the\ncompiled Wasm bytecode, this is not the worst solution, but there's a better\nway.\n\nBy moving the asynchronous code to the beginning of the Web Worker and not\nactually waiting for the promise to fulfill, but rather storing the promise in\na variable, the program immediately moves on to the event listener part of the\ncode, and no message from the main thread will be lost. Inside of the event\nlistener, the promise can then be awaited.\n\n    \n    \n    /* Worker thread. */\n    \n    const importObject = {}; // Instantiate the Wasm module. // \ud83d\udeab If the `Worker` is spun up frequently, the loading // compiling, and instantiating work will happen every time. const wasmPromise = WebAssembly.instantiateStreaming( fetch('factorial.wasm'), importObject, );\n    \n    // Listen for incoming messages self.addEventListener('message', async (e) => { const { integer } = e.data; const resultObject = await wasmPromise; const factorial = resultObject.instance.exports.factorial; const result = factorial(integer); self.postMessage({ result }); });\n\n### Good: Task runs in Web Worker, and loads and compiles only once\n\nThe result of the static WebAssembly.compileStreaming() method is a promise\nthat resolves to a WebAssembly.Module. One nice feature of this object is that\nit can be transferred using postMessage(). This means the Wasm module can be\nloaded and compiled just once in the main thread (or even another Web Worker\npurely concerned with loading and compiling), and then be transferred to the\nWeb Worker responsible for the CPU-intensive task. The following code shows\nthis flow.\n\n    \n    \n    /* Main thread. */\n    \n    const modulePromise = WebAssembly.compileStreaming(fetch('factorial.wasm'));\n    \n    let worker = null;\n    \n    // When the button is clicked, submit the input value // and the Wasm module to the Web Worker. button.addEventListener('click', async (e) => { e.preventDefault();\n    \n    // Create the Web Worker lazily on-demand. if (!worker) { worker = new Worker('worker.js');\n    \n    // Listen for incoming messages and display the result. worker.addEventListener('message', (e) => { output.textContent = e.result; }); }\n    \n    worker.postMessage({ integer: parseInt(input.value, 10), module: await modulePromise, }); });\n\nOn the Web Worker side, all that remains is to extract the WebAssembly.Module\nobject and instantiate it. Since the message with the WebAssembly.Module isn't\nstreamed, the code in the Web Worker now uses WebAssembly.instantiate() rather\nthan the instantiateStreaming() variant from before. The instantiated module\nis cached in a variable, so the instantiation work only needs to happen once\nupon spinning up the Web Worker.\n\n    \n    \n    /* Worker thread. */\n    \n    let instance = null;\n    \n    // Listen for incoming messages self.addEventListener('message', async (e) => { // Extract the `WebAssembly.Module` from the message. const { integer, module } = e.data; const importObject = {}; // Instantiate the Wasm module that came via `postMessage()`. instance = instance || (await WebAssembly.instantiate(module, importObject)); const factorial = instance.exports.factorial; const result = factorial(integer); self.postMessage({ result }); });\n\n### Perfect: Task runs in inline Web Worker, and loads and compiles only once\n\nEven with HTTP caching, obtaining the (ideally) cached Web Worker code and\npotentially hitting the network is expensive. A common performance trick is to\ninline the Web Worker and load it as a blob: URL. This still requires the\ncompiled Wasm module to be passed to the Web Worker for instantiation, as the\ncontexts of the Web Worker and the main thread are different, even if they're\nbased on the same JavaScript source file.\n\nNote: Inlining Web Worker code by hand may harm the overall structure of your\ncodebase. One way to deal with this is to leave the actual inlining to build\ntools like [Vite that have special query suffixes like\n?inline](https://v3.vitejs.dev/guide/features.html#import-with-query-\nsuffixes).\n\n    \n    \n    /* Main thread. */\n    \n    const modulePromise = WebAssembly.compileStreaming(fetch('factorial.wasm'));\n    \n    let worker = null;\n    \n    const blobURL = URL.createObjectURL( new Blob( [ ` let instance = null;\n    \n    self.addEventListener('message', async (e) => { // Extract the \\`WebAssembly.Module\\` from the message. const {integer, module} = e.data; const importObject = {}; // Instantiate the Wasm module that came via \\`postMessage()\\`. instance = instance || await WebAssembly.instantiate(module, importObject); const factorial = instance.exports.factorial; const result = factorial(integer); self.postMessage({result}); }); `, ], { type: 'text/javascript' }, ), );\n    \n    button.addEventListener('click', async (e) => { e.preventDefault();\n    \n    // Create the Web Worker lazily on-demand. if (!worker) { worker = new Worker(blobURL);\n    \n    // Listen for incoming messages and display the result. worker.addEventListener('message', (e) => { output.textContent = e.result; }); }\n    \n    worker.postMessage({ integer: parseInt(input.value, 10), module: await modulePromise, }); });\n\n### Lazy or eager Web Worker creation\n\nSo far, all the code samples spun up the Web Worker lazily on-demand, that is,\nwhen the button was pressed. Depending on your application, it can make sense\nto create the Web Worker more eagerly, for example, when the app is idle or\neven as part of the app's bootstrapping process. Therefore, move the Web\nWorker creation code outside of the button's event listener.\n\n    \n    \n    const worker = new Worker(blobURL);\n    \n    // Listen for incoming messages and display the result. worker.addEventListener('message', (e) => { output.textContent = e.result; });\n\n### Keep the Web Worker around or not\n\nOne question that you may ask yourself is whether you should keep the Web\nWorker permanently around, or recreate it whenever you need it. Both\napproaches are possible and have their advantages and disadvantages. For\nexample, keeping a Web Worker permanently around may increase your app's\nmemory footprint and make dealing with concurrent tasks harder, since you\nsomehow need to map results coming from the Web Worker back to the requests.\nOn the other hand, your Web Worker's bootstrapping code might be rather\ncomplex, so there could be a lot of overhead if you create a new one each\ntime. Luckily this is something you can measure with the User Timing API.\n\nThe code samples so far have kept one permanent Web Worker around. The\nfollowing code sample creates a new Web Worker ad hoc whenever needed. Note\nthat you need to keep track of terminating the Web Worker yourself. (The code\nsnippet skips error handling, but in case something goes wrong, be sure to\nterminate in all cases, success or failure.)\n\n    \n    \n    /* Main thread. */\n    \n    let worker = null;\n    \n    const modulePromise = WebAssembly.compileStreaming(fetch('factorial.wasm'));\n    \n    const blobURL = URL.createObjectURL( new Blob( [ ` // Caching the instance means you can switch between // throw-away and permanent Web Worker freely. let instance = null;\n    \n    self.addEventListener('message', async (e) => { // Extract the \\`WebAssembly.Module\\` from the message. const {integer, module} = e.data; const importObject = {}; // Instantiate the Wasm module that came via \\`postMessage()\\`. instance = instance || await WebAssembly.instantiate(module, importObject); const factorial = instance.exports.factorial; const result = factorial(integer); self.postMessage({result}); }); `, ], { type: 'text/javascript' }, ), );\n    \n    button.addEventListener('click', async (e) => { e.preventDefault(); // Terminate a potentially running Web Worker. if (worker) { worker.terminate(); } // Create the Web Worker lazily on-demand. worker = new Worker(blobURL); worker.addEventListener('message', (e) => { worker.terminate(); worker = null; output.textContent = e.data.result; }); worker.postMessage({ integer: parseInt(input.value, 10), module: await modulePromise, }); });\n\n## Demos\n\nThere are two demos for you to play with. One with an ad hoc Web Worker\n(source code) and one with a permanent Web Worker (source code). If you open\nthe Chrome DevTools and check the Console, you can see the User Timing API\nlogs that measure the time it takes from the button click to the displayed\nresult on the screen. The Network tab shows the blob: URL request(s). In this\nexample, the timing difference between ad hoc and permanent is about 3\u00d7. In\npractice, to the human eye, both are indistinguishable in this case. The\nresults for your own real life app will most likely vary.\n\n## Conclusions\n\nThis post has explored some performance patterns for dealing with Wasm.\n\n  * As a general rule, prefer the streaming methods (WebAssembly.compileStreaming() and WebAssembly.instantiateStreaming()) over their non-streaming counterparts (WebAssembly.compile() and WebAssembly.instantiate()).\n  * If you can, outsource performance-heavy tasks in a Web Worker, and do the Wasm loading and compiling work only once outside of the Web Worker. This way, the Web Worker only needs to instantiate the Wasm module it receives from the main thread where the loading and compiling happened with WebAssembly.instantiate(), which means the instance can be cached if you keep the Web Worker around permanently.\n  * Measure carefully whether it makes sense to keep one permanent Web Worker around forever, or to create ad hoc Web Workers whenever they are needed. Also think when it is the best time to create the Web Worker. Things to take into consideration are memory consumption, the Web Worker instantiation duration, but also the complexity of possibly having to deal with concurrent requests.\n\nIf you take these patterns into account, you're on the right track to optimal\nWasm performance.\n\n## Acknowledgements\n\nThis guide was reviewed by Andreas Haas, Jakob Kummerow, Deepti Gandluri, Alon\nZakai, Francis McCabe, Fran\u00e7ois Beaufort, and Rachel Andrew.\n\nWas this helpful?\n\nExcept as otherwise noted, the content of this page is licensed under the\nCreative Commons Attribution 4.0 License, and code samples are licensed under\nthe Apache 2.0 License. For details, see the Google Developers Site Policies.\nJava is a registered trademark of Oracle and/or its affiliates.\n\nLast updated 2024-04-29 UTC.\n\n", "frontpage": false}
