{"aid": "40274576", "title": "Upcoming Sokol header API changes (May 2024)", "url": "https://floooh.github.io/2024/05/06/sokol-storage-buffers.html", "domain": "floooh.github.io", "votes": 1, "user": "ibobev", "posted_at": "2024-05-06 13:41:33", "comments": 0, "source_title": "Upcoming Sokol header API changes (May 2024)", "source_text": "Upcoming Sokol header API changes (May 2024)\n\nThe Brain Dump\n\n# Upcoming Sokol header API changes (May 2024)\n\nMay 6, 2024\n\nAka: \u201cthe storage buffer update\u201d\n\nIn a couple of days I will merge the next sokol-gfx feature update which adds\ninitial storage buffer support. The update also affects other headers and\ntools (most notably sokol_app.h, all headers with embedded shaders, and sokol-\nshdc - the cross-backend shader compiler).\n\nThe bad news first:\n\n  * This is \u2018gpu-readonly\u2019 support, e.g. it\u2019s not possible (yet) to write to storage buffers from shader code, gpu-write support will come in a future \u2018compute shaders\u2019 update.\n  * The following platform/backend combos don\u2019t get storage buffer support:\n\n    * all GLES3 backends (WebGL2, iOS+GLES3, Android): for WebGL2 and iOS there is no other choice since they are stuck with GLES 3.0, for Android, storage buffer support may be added later\n    * macOS+GL: macOS is stuck at GL 4.1, while storage buffers require at least GL 4.3\n  * This leaves the following platform/backend combos which support storage buffers:\n\n    * macOS + Metal\n    * iOS + Metal\n    * Windows + D3D11\n    * Windows + GL\n    * Linux + GL\n    * Web + WebGPU\n\nStorage buffers provide a convenient way to communicate large array-like data\nto shaders (the minimum guaranteed size for storage buffers is 128 MBytes),\nfor instance:\n\n  * for \u2018vertex pulling\u2019 to load per-vertex and/or per-instance data from storage buffers instead of relying on the fixed function vertex input stage\n  * as a more convenient and flexible way to load random access data in shaders compared to the old-school way of using \u2018data textures\u2019.\n\n...and as a \u2018drive-by\u2019 feature: sokol-gfx now finally allows to kick off a\ndraw call without any resource bindings and instead synthesize vertices \u2018out\nof thin air\u2019 in the vertex shader.\n\nThe root PR for the update is here: #1007.\n\n## New sample code\n\nThe following backend-agnostic samples have been added (those use sokol_app.h\nand sokol-shdc).\n\n> NOTE: You\u2019ll need a recent Chrome for the WebGPU sample links to work, also\n> expect some general breakage and rendering artifacts depending on the\n> platform (for instance I see pixel noise artifacts in the sbuftex-sapp\n> sample on my Windows PC with an NVIDIA RTX 2070, and Chrome on Android\n> straight up crashes the tab on most samples). Also please note that the\n> source code links in those samples will not be valid until all the update\n> PRs have been merged.\n\n  * triangle-bufferless-sapp: this demonstrates rendering without buffers (and is the only new sample that also works on backends without storage buffer support):\n\n    * WebGPU: triangle-bufferless-sapp.html\n    * C code: sapp/triangle-bufferless-sapp.c\n    * GLSL code: sapp/triangle-bufferless-sapp.glsl\n  * vertexpull-sapp: the cube-sapp sample ported to vertex pulling:\n\n    * WebGPU: vertexpull-sapp.html\n    * C code: sapp/vertexpull-sapp.c\n    * GLSL code: sapp/vertexpull-sapp.glsl\n  * sbuftex-sapp: a sample which uses a storage buffer in the fragment shader stage:\n\n    * WebGPU: sbuftex-sapp.html\n    * C code: sapp/sbuftex-sapp.c\n    * GLSL code: sapp/sbuftex-sapp.glsl\n  * instancing-pull-sapp: vertex pulling and instancing via storage buffers:\n\n    * WebGPU: instancing-pull-sapp.html\n    * C code: sapp/instancing-pull-sapp.c\n    * GLSL code: sapp/instancing-pull-sapp.glsl\n  * ozz-storagebuffer-sapp: the ozz-skin sample rewritten to pull vertices, instance- and skinning-matrices from storage buffers:\n\n    * WebGPU: ozz-storagebuffer-sapp.html\n    * C code: sapp/ozz-storagebuffer-sapp.c\n    * GLSL code: sapp/ozz-storagebuffer-sapp.glsl\n\nThe following backend-specific samples demonstrate how to use storage buffers\nwithout the sokol-shdc shader compiler:\n\n  * D3D11 d3d11/vertexpulling-d3d11.c\n  * Metal: metal/vertexpulling-metal.c\n  * WebGPU: wgpu/vertexpulling-wgpu.c\n  * desktop GL: glfw/vertexpulling-glfw.c\n\n## How to check for storage buffer support\n\nTo check for storage buffer support at runtime, call sg_query_features() and\ncheck the storage_buffer boolean in the result:\n\n    \n    \n    if (sg_query_features().storage_buffer) { // storage buffers are supported... } else { // storage buffers are *NOT* supported... }\n\n## Desktop GL version caveats (and a minor breaking change)\n\nThe sokol_gfx.h desktop-GL backend will now query what GL version it runs on\nto decide whether storage buffers are supported (storage buffers were added in\nGL 4.3).\n\nThe expected minimal version has been bumped to 4.1 on macOS and 4.3 on other\nplatforms, this also means that sokol_app.h will now by default create a 4.1\ncontext on macOS, and 4.3 context on other platforms.\n\nSince the GL version is now flexible, the configuration define SOKOL_GLCORE33\ndoesn\u2019t make much sense anymore and has been renamed to SOKOL_GLCORE. You\u2019ll\nget a proper compile error when trying to build with the old SOKOL_GLCORE33\ndefine.\n\nApart from rebuilding your shaders via an updated sokol-shdc, this is the only\nrequired change for existing code.\n\nIn sokol-shdc, the target language glsl330 has been removed and replaced with\nglsl410 and glsl430. When targeting the macOS GL backend, use glsl410,\notherwise glsl430.\n\n## A simple vertex pulling example\n\nFirst let\u2019s rewrite the cube-sapp.glsl shader to pull vertices from a storage\nbuffer instead of the fixed function vertex input.\n\nThe original shader declares the vertex input with vertex attributes:\n\n    \n    \n    in vec4 position; in vec4 color0;\n\n> NOTE: the cube-sapp.glsl shader makes use of a fixed function vertex input\n> feature which extends float[3] vertex data on the CPU side to vec4 with a\n> w-component 1.0 on the GPU side. Magic like this isn\u2019t supported when\n> reading from storage buffers (as far as I\u2019m aware at least).\n\nFor vertex pulling the input vertex attributes are replaced with a flexible-\narray struct inside a buffer interface block.\n\n    \n    \n    struct sb_vertex { vec3 pos; vec4 color; }; readonly buffer ssbo { sb_vertex vtx[]; };\n\n> NOTE: I\u2019m using sb_vertex for the struct name here because vertex is a\n> reserved keyword in the Metal Shading Language and would cause a compile\n> error when outputting MSL.\n\nDo not use an attribute like layout(std430, binding=0) for the buffer\ninterface block, sokol-shdc will take care of those details.\n\nThe original vertex shader looks like this:\n\n    \n    \n    void main() { gl_Position = mvp * position; color = color0; }\n\nConverted to vertex pulling it looks like this:\n\n    \n    \n    void main() { vec4 position = vec4(vtx[gl_VertexIndex].pos, 1.0); gl_Position = mvp * position; color = vtx[gl_VertexIndex].color; }\n\nNote how gl_VertexIndex (not gl_VertexID!) is used to index into the storage\nbuffer, this is because sokol-shdc shaders are written in \u2018Vulkan style\u2019, not\n\u2018GL style\u2019.\n\nWe also need to expand the vec3 input pos manually to a vec4 with w-component\n= 1.0.\n\nThat\u2019s all the changes needed on the shader side. Next compile the modified\nshader with:\n\n    \n    \n    sokol-shdc -i shader.glsl -o shader.h -l metal_macos:hlsl5:glsl430:wgsl -f sokol\n\nApart from the \u2018traditional\u2019 code-generation output, sokol-shdc will create\ntwo new declarations:\n\n  * A define #define SLOT_ssbo (0), this is the bind slot index to be used in the sg_bindings struct\n\n  * A C struct sb_vertex_t which maps the GLSL struct sb_vertex to the C side looking like this:\n    \n        SOKOL_SHDC_ALIGN(16) typedef struct sb_vertex_t { float pos[3]; uint8_t _pad_12[4]; float color[4]; } sb_vertex_t;\n\n> NOTE: with the right @ctype tags at the top of the shader we could also map\n> the struct members to C or C++ types, for instance with HandmadeMath.h\n> types:\n    \n    \n    SOKOL_SHDC_ALIGN(16) typedef struct sb_vertex_t { hmm_vec3 pos; uint8_t _pad_12[4]; hmm_vec4 color; } sb_vertex_t;\n\nNext let\u2019s see how the cube-sapp C code needs to be changed:\n\nThe original code creates a vertex buffer like this:\n\n    \n    \n    float vertices[] = { -1.0, -1.0, -1.0, 1.0, 0.0, 0.0, 1.0, 1.0, -1.0, -1.0, 1.0, 0.0, 0.0, 1.0, ... }; sg_buffer vbuf = sg_make_buffer(&(sg_buffer_desc){ .data = SG_RANGE(vertices), .label = \"cube-vertices\" });\n\nBy default sg_make_buffer() creates a vertex buffer, so the above is identical\nwith a more explicit:\n\n    \n    \n    sg_buffer vbuf = sg_make_buffer(&(sg_buffer_desc){ .type = SG_BUFFERTYPE_VERTEXBUFFER, .data = SG_RANGE(vertices), .label = \"cube-vertices\" });\n\n...when changing the code to use storage buffers we can use the code-generated\nsb_vertex_t struct to initialize the vertex data. This has the advantage that\nwe don\u2019t need to care about the obscure std430 memory layout rules:\n\n    \n    \n    sb_vertex_t vertices[] = { { .pos = { -1.0, -1.0, -1.0 }, .color = { 1.0, 0.0, 0.0, 1.0 } }, { .pos = { 1.0, -1.0, -1.0 }, .color = { 1.0, 0.0, 0.0, 1.0 } }, ... }; sg_buffer sbuf = sg_make_buffer(&(sg_buffer_desc){ .type = SG_BUFFERTYPE_STORAGEBUFFER, .data = SG_RANGE(vertices), .label = \"cube-vertices\", });\n\n...note how the buffer type has changed to SG_BUFFERTYPE_STORAGEBUFFER.\n\nOn to the sg_pipeline object. In the original code, a vertex layout must be\ndefined in the sg_pipeline_desc struct to configure the fixed function vertex\ninput stage:\n\n    \n    \n    state.pip = sg_make_pipeline(&(sg_pipeline_desc){ .layout = { .attrs = { [ATTR_vs_position].format = SG_VERTEXFORMAT_FLOAT3, [ATTR_vs_color0].format = SG_VERTEXFORMAT_FLOAT4 } }, .shader = shd, .index_type = SG_INDEXTYPE_UINT16, .cull_mode = SG_CULLMODE_BACK, .depth = { .write_enabled = true, .compare = SG_COMPAREFUNC_LESS_EQUAL, }, .label = \"cube-pipeline\" });\n\nWhen pulling vertex data from storage buffers such a vertex layout description\nisn\u2019t needed, so the pipeline creation can be simplified to this:\n\n    \n    \n    state.pip = sg_make_pipeline(&(sg_pipeline_desc){ .shader = shd, .index_type = SG_INDEXTYPE_UINT16, .cull_mode = SG_CULLMODE_BACK, .depth = { .write_enabled = true, .compare = SG_COMPAREFUNC_LESS_EQUAL, }, .label = \"cube-pipeline\" });\n\n...the original sg_bindings struct that\u2019s passed into sg_apply_bindings():\n\n    \n    \n    state.bind = (sg_bindings) { .vertex_buffers[0] = vbuf, .index_buffer = ibuf };\n\n...is changed like this (e.g. replace the vertex buffer binding with a storage\nbuffer binding on the vertex shader stage):\n\n    \n    \n    state.bind = (sg_bindings) { .index_buffer = ibuf .vs.storage_buffers[SLOT_ssbo] = sbuf, };\n\n...and that\u2019s it! On the CPU side, storage buffers actually simplify a lot of\ncode because you don\u2019t need a vertex layout in the sg_pipeline_desc struct,\nand you get a properly aligned and padded C struct for the storage buffer\ncontent from sokol-shdc.\n\n> NOTE: A \u2018proper\u2019 cross-backend sample should also check whether storage\n> buffers are actually supported via sg_query_features().storage_buffer and\n> render some sort of fallback.\n\n## Shader Authoring Caveats\n\nShader authoring via sokol-shdc is a bit more restricted than vanilla GLSL:\n\n  1. A storage buffer interface block must contain exactly one item, and this item must be a flexible struct array member. In vanilla GLSL you can have additional \u2018header items\u2019 in front of the flexible array member, but this turned out tricky to map to CPU-side non-C languages that don\u2019t allow flexible array members (I actually need to research the various target languages a bit more, maybe this rule can be relaxed in the future for some of the target languages).\n  2. Currently the following types are valid inside a storage buffer struct:\n\n     * bool, bvec2..4: mapped to int32_t, and int32_t[2..4]\n     * int, ivec2..4: mapped to int32_t, and int32_t[2..4]\n     * uint, uvec2..4: mapped to uint32_t, and uint32_t[2..4]\n     * float, vec2..4: mapped to float and float[2..4]\n     * matNxM where N=2..4 and M=1..4 mapped to float[2..64]\n  3. nested structs\n  4. arrays of the above\n\nPlease note that only few of those combinations are tested, especially when it\ncomes to correct array item padding and alignment. If you stumble over any\nproblems please write a ticket at https://github.com/floooh/sokol-\ntools/issues.\n\nTo load packed vertex components from storage buffers, use the following GLSL\nbuiltins:\n\n  * vec2 unpackUnorm2x16(uint p)\n  * vec2 unpackSnorm2x16(uint p)\n  * vec4 unpackUnorm4x8(uint p)\n  * vec4 unpackSnorm4x8(uint p)\n\n## Under the hood\n\n> NOTE: the following information about shader bind slots are only relevant if\n> you do not use the sokol shader compiler (sokol-shdc), but instead pass\n> \u2018raw\u2019 HLSL, MSL, GLSL or WGSL shaders into sokol_gfx.h. Also, this\n> information will become obsolete/irrelevant with another future update I\n> have in mind which will allow more flexibility when mapping sokol-gfx bind\n> slots to backend 3D API bind slots (see this planning ticket for more info:\n> #1037)\n\n### Metal\n\nOn Metal there is no \u2018buffer zoo\u2019 like in other 3D APIs, uniform-, vertex-,\nindex- and storage-buffers are all the same thing. The vertex- and fragment-\nshader stages have their own buffer bind slot spaces though.\n\nThe following bind slot ranges are used for the various sokol-gfx buffer\ntypes:\n\n  * on the vertex shader stage:\n\n    * slots 0..3 for uniform buffer bindings (sokol-gfx internally manages an uniform buffer which might be bound at up to four different offsets)\n    * slots 4..11 for vertex buffer bindings\n    * slots 12..19 for storage buffer bindings\n  * on the fragment shader stage:\n\n    * slots 0..3 for uniform buffer bindings\n    * slots 4..11 for storage buffer bindings\n\nWhen authoring Metal shaders directly you\u2019ll need to use the above bind slots\n(also see the low-level Metal backend samples).\n\n### D3D11\n\nOn D3D11, so called Byte Address Buffers are used for storage buffers which\nmakes their direct usage in manually written HLSL a bit awkward (but is not an\nissue when using sokol-shdc).\n\nIf this turns out to be a problem I might add D3D11-specific creation flags to\nsg_buffer_desc to allow using different D3D11 buffer and buffer-view types\nunder the hood, details like this might also change again once compute shader\nsupport is added.\n\nOn D3D11 and HLSL storage buffers share a bind slot range with texture\nbindings, that\u2019s why sokol-gfx defines the following bind ranges for textures\nand storage buffers in HLSL:\n\n  * register(t0..t15): reserved for texture bindings\n  * register(t16..t23): reserved for storage buffer bindings\n\nAlso see the low-level D3D11 backend samples for details.\n\n### WebGPU\n\nStorage buffers are created with WGPUBufferUsage_Storage. WebGPU uses a common\nbind slot space across all shader resource types and shader stages. Sokol-gfx\nreserves the following bind slot ranges for the different shader stages and\nresource types, use those when feeding manually written WGSL shaders into\nsokol-gfx:\n\n  * vertex shader stage:\n\n    * textures: @group(1) @binding(0..15)\n    * samplers: @group(1) @binding(16..31)\n    * storage buffers; @group(1) @binding(32..47)\n  * fragment shader stage:\n\n    * textures: @group(1) @binding(48..63)\n    * samplers: @group(1) @binding(64..79)\n    * storage buffers: @group(1) @binding(80..95)\n\nAlso see the low-level WebGPU backend samples for details\n\n### GL\n\nIn GL, storage buffers are bound to the GL_SHADER_STORAGE_BUFFER target.\nSokol-gfx does not lookup GLSL storage buffer interface blocks by name, but\ninstead expects that the GLSL code that\u2019s passed into sg_make_shader() uses a\nlayout(std430, binding=N) annotation to define the bind slot.\n\nThe vertex- and fragment-shader stage use a common bind space:\n\n  * on the vertex shader stage, use binding 0..7\n  * on the fragment shader stage, use binding 7..15\n\nAlso see the low-level desktop GL backend samples for details.\n\n## sokol-shdc updates\n\nSokol-shdc has been massively refactored, mainly with the goal to have a more\nrobust base for extracting reflection information from shaders and a more\n\u2018structured\u2019 approach to code generation so that supporting additional CPU-\nside languages will be easier in the future (I\u2019m not yet sure if that last\ngoal was actually achieved though, but time will tell).\n\nUnfortunately this massive refactoring also means that there\u2019s a possibility\nthat new bugs have sneaked in. If you notice anything weird, please write\ntickets here:\n\nhttps://github.com/floooh/sokol-tools/issues.\n\nA couple of unrelated lingering bugs have been fixed as well:\n\n  * C++ exceptions are now enabled and exceptions coming out of SPIRVCross are now caught and turned into proper error messages. Previously sokol-shdc would simply appear to crash if SPIRVCross emitted an error (because without C++ exceptions enabled, those errors would be turned into a panic which looks like a segfault).\n  * Error and warning line numbers had been off by a couple of lines recently. This has been fixed and error messages now point to the correct line again.\n  * A couple of somewhat esoteric code generation bugs in non-C code generators were fixed (but as I said, it\u2019s also quite likely that I have introduced new bugs in that area, since code generators were completely rewritten)\n\n## What\u2019s next:\n\nIn short:\n\n  * A resource binding cleanup (see #1037), the main motivation for this is that the sg_bindings struct is growing quite large and would grow even larger if a new compute shader stage is added. Furthermore, the artificial separation of shader stages when binding resources also doesn\u2019t map particularly well to some modern 3D APIs.\n  * After that it\u2019s finally time to tackle compute shaders. For this I need to come up with a resource synchronization strategy, but I will most likely just copy what WebGPU does.\n\nBut first I will probably take a little break and dabble a bit with Zig and\nemulator coding :)\n\n## The Brain Dump\n\n  * The Brain Dump\n  * floooh@gmail.com\n\n  * floooh\n  * flohofwoe\n\nThis is the blog and personal web page of Andre Weissflog (Floh, floooh,\nflohofwoe) mostly about programming stuff.\n\n", "frontpage": false}
