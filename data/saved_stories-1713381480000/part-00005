{"aid": "40061528", "title": "JExtract Guide (to generate Code to access the native library in Java)", "url": "https://github.com/openjdk/jextract/blob/master/doc/GUIDE.md", "domain": "github.com/openjdk", "votes": 1, "user": "lichtenberger", "posted_at": "2024-04-17 07:20:07", "comments": 0, "source_title": "jextract/doc/GUIDE.md at master \u00b7 openjdk/jextract", "source_text": "jextract/doc/GUIDE.md at master \u00b7 openjdk/jextract \u00b7 GitHub\n\nSkip to content\n\nSign in\n\n# Search code, repositories, users, issues, pull requests...\n\nSearch syntax tips\n\nSign in\n\nSign up\n\nYou signed in with another tab or window. Reload to refresh your session. You\nsigned out in another tab or window. Reload to refresh your session. You\nswitched accounts on another tab or window. Reload to refresh your session.\nDismiss alert\n\nopenjdk / jextract Public\n\n  * Notifications\n  * Fork 48\n  * Star 286\n\n/\n\n# GUIDE.md\n\n## Latest commit\n\nJornVernee\n\nAdd guide section about array types\n\nApr 16, 2024\n\ncde2665 \u00b7 Apr 16, 2024Apr 16, 2024\n\n## History\n\nHistory\n\n1000 lines (765 loc) \u00b7 42.1 KB\n\n/\n\n# GUIDE.md\n\n## File metadata and controls\n\n1000 lines (765 loc) \u00b7 42.1 KB\n\nRaw\n\n# Jextract Guide\n\nThe jextract tool parses header (.h) files of native libraries, and generates\nJava code, called bindings, which use the Foreign Function and Memory API (FFM\nAPI) under the hood, that can be used by a client to access the native\nlibrary.\n\nInteracting with native C code through the FFM API works by loading a native\nlibrary (e.g., a .so/.dll/.dylib file), which is essentially an archive of\nnative functions and global variables. The user then has to look up the\nfunctions they want to call using a SymbolLookup, and finally link the\nfunctions by using the Linker::downcallHandle method. Additionally, a client\nmay need to create function pointers for Java functions using\nLinker::upcallStub, access global variables through the addresses returned by\na lookup, and construct MemoryLayout instances for the structs they want to\naccess. The jextract tool aims to automate many of these steps, so that a\nclient can instead immediately start using the native libraries they are\ninterested in.\n\nThis guide shows how to run the jextract tool, and how to use the Java code\nthat it generates. The samples under the samples direcotry are also a good\nsource of examples.\n\nNote that at this time, jextract (and FFM) only supports C header files. If\nyou have a library written in another language, see the section on other\nlanguages.\n\n## Running Jextract\n\nA native library typically has an include directory which contains all the\nheader files that define the interface of the library, with one main header\nfile. Let's say we have a library called mylib stored at /path/to/mylib that\nhas a directory /path/to/mylib/include where the header files of that library\nare stored. And let's say that we have a shell open in the root directory of\nthe Java project we're working on, which has an src source directory\ncorresponding to the root package. A typical way to run jextract would be like\nthis:\n\n    \n    \n    $ jextract \\ --include-dir /path/to/mylib/include \\ --output src \\ --target-package org.jextract.mylib \\ --library mylib \\ /path/to/mylib/include/mylib.h\n\nIn this command:\n\n  * /path/to/mylib/include/mylib.h is the main header file of the native library we want to generate bindings for.\n  * \\--include-dir /path/to/mylib/include specifies a header file search directory, which is used to find header files included through #include in the main header file.\n  * \\--output src specifies the root directory for the output. This matches the root package of the project's source directory.\n  * \\--target-package org.jextract.mylib specifies the target package to which the generated classes and interfaces will belong. (Note that jextract will automatically create the directories representing the package structure under the src directory specified through --output)\n  * \\--library mylib tells jextract that the generated bindings should load the library called mylib. (The section on library loading discusses how this is done)\n\nNote that specifying the wrong header file to jextract may result in errors\nduring parsing. Please consult the documentation of the library in question\nabout which header file should be included. This is also the header file that\nshould be passed to jextract. If a library has multiple main header files,\nthey can be passed to jextract by creating a new header file which #includes\nthese header files, and then this new header file can be passed to jextract.\n\nThe library name specified to --library will be mapped to a platform specific\nlibrary file name, and should be findable through the OS's library search\nmechanism, typically by specifying the library's containing directory on\nLD_LIBRARY_PATH (Linux), DYLD_LIBRARY_PATH (Mac), or PATH (Windows). See the\nsection on library loading for more information.\n\nBesides these options, it is also possible to filter the output of jextract\nusing one of the --include-XYZ options that jextract has. See the section on\nfiltering for a more detailed overview. See also the full list of command line\noptions here.\n\nMost of the code that jextract generates will be available through a single\nclass. By default, the name of that class is derived from the name of the main\nheader file that is passed to jextract. For example, if the header file is\nnamed mylib.h, then the derived class name will be mylib_h. The class name can\nbe set explicitly using the --header-class-name option as well.\n\nBesides the main header class that is generated, jextract also generates\nseveral separate files for certain declarations in the C header file. Namely,\nstructs, unions, function pointer types, and typedefs of struct or union types\nresult in additional files being generated. (All of these are discussed in\nmore detail in the Using The Code Generated By Jextract section).\n\nJextract assumes that the version of a native library that a project uses is\nrelatively stable. Therefore, jextract is intended to be run once, and then\nfor the generated sources to be added to the project. Jextract only needs to\nbe run again when the native library, or jextract itself are updated. (This is\nalso the workflow that jextract itself follows: jextract depends on the\nlibclang native library in order to parse C sources).\n\n## Using The Code Generated By Jextract\n\nIn the following section we'll go over examples of declarations that might be\nfound in a C header file, show the code that jextract generates for these\ndeclarations, and show some examples of how to use the generated Java code.\n\nMost of the methods that jextract generates are static, and are designed to be\nimported using import static. Typically, to access the code that jextract\ngenerates for a header file called mylib.h, only the following two wildcard\nimports are needed:\n\n    \n    \n    import static org.mypackage.mylib_h.*; import org.mypackage.*;\n\nWhere org.mypackage is the package into which jextract puts the generates\nsource files (using --target-package/-t).\n\nThe former import statement will import all the static functions and fields\nfrom the class that jextract generates for the main header file of the\nlibrary. This includes methods to access functions, global variables, macros,\nenums, primitive typedefs, and layouts for builtin C types.\n\nThe latter import statement imports all the other classes generated by\njextract, which include: classes representing structs or unions, function\ntypes, and struct or union typedefs.\n\n### Builtin Type Layouts\n\nFor every jextract run, regardless of the contents of the library header\nfiles, jextract will generate a set of memory layouts for the common builtin C\ntypes in the main header class it generates:\n\n    \n    \n    // mylib_h.java public static final ValueLayout.OfBoolean C_BOOL = ValueLayout.JAVA_BOOLEAN; public static final ValueLayout.OfByte C_CHAR = ValueLayout.JAVA_BYTE; public static final ValueLayout.OfShort C_SHORT = ValueLayout.JAVA_SHORT; public static final ValueLayout.OfInt C_INT = ValueLayout.JAVA_INT; public static final ValueLayout.OfLong C_LONG_LONG = ValueLayout.JAVA_LONG; public static final ValueLayout.OfFloat C_FLOAT = ValueLayout.JAVA_FLOAT; public static final ValueLayout.OfDouble C_DOUBLE = ValueLayout.JAVA_DOUBLE; public static final AddressLayout C_POINTER = ValueLayout.ADDRESS .withTargetLayout( MemoryLayout.sequenceLayout(Long.MAX_VALUE, ValueLayout.JAVA_BYTE)); public static final ValueLayout.OfInt C_LONG = ValueLayout.JAVA_INT; public static final ValueLayout.OfDouble C_LONG_DOUBLE = ValueLayout.JAVA_DOUBLE;\n\nThe above layout constants represent the layouts for the C builtin types:\nbool, char, short, int, long long, float, double long, and long double.\nAdditionally, there is a C_POINTER layout which represents the layout for any\nC pointer type (such as T*). Note that the layouts that jextract generates\ndepend on the platform that jextract runs on. For instance, since these\nconstants were generated on Windows, the long type has the same layout as the\nJava int type, indicating a 32-bit value, and the long double type has the\nsame layout as the Java double type. (Note that the latter is only available\non Windows).\n\n### Functions\n\nLet's say we have a main library header file mylib.h that contains the\nfollowing function declaration:\n\n    \n    \n    // mylib.h void foo(int x);\n\nJextract will generate the following set of methods for this function in the\nmain header class it generates:\n\n    \n    \n    // mylib_h.java public static void foo(int x) { ... } // 1 public static MemorySegment foo$address() { ... } // 2 public static FunctionDescriptor foo$descriptor() { ... } // 3 public static MethodHandle foo$handle() { ... } // 4\n\nFirst and foremost, there is:\n\n  1. a static wrapper method that is generated that can be used to call the C function.\n\nBesides that, there are also several accessors that return additional meta-\ndata for the method:\n\n  2. the function's address, represented as a MemorySegment\n  3. the FunctionDescriptor\n  4. the MethodHandle returned by the FFM linker, which is used to implement the static wrapper method (1).\n\nThe parameter types and return type of this method depend on the carrier types\nof the layouts that make up the function descriptor of the function, which is\nitself derived from the parsed header files.\n\n### Global Variables\n\nFor a global variable declaration in a header file like this:\n\n    \n    \n    // mylib.h int bar;\n\nJextract generates the following:\n\n    \n    \n    // mylib_h.java public static OfInt bar$layout() { ... } // 1 public static MemorySegment bar$segment() { ... } // 2 public static int bar() { ... } // 3 public static void bar(int varValue) { ... } // 3\n\nbar$layout is the FFM memory layout of the global variable (1), and\nbar$segment is the address of the global variable (2).\n\nBesides that, jextract also generates a getter and a setter method to get and\nset the value of the global variable (3). Once again, the parameter and return\ntype of the getter and setter depend on the carrier type of the layout of the\nglobal variable, which is itself derived from the header files.\n\n### Constants (Macros & Enums)\n\nBoth macros and enums are translated similarly. If we have a header file\ncontaining these declarations:\n\n    \n    \n    // mylib.h #define MY_MACRO 42 enum MY_ENUM { A, B, C };\n\nJextract will generate simple getter methods to access the constant values of\nthe macro and the enum constants:\n\n    \n    \n    // mylib_h.java public static int MY_MACRO() { ... } public static int A() { ... } public static int B() { ... } public static int C() { ... }\n\nNote that the enum constants are exposed as top-level methods, rather than being nested inside a class called MY_ENUM, or through the use of a Java enum. This translation strategy mimics C's behavior of enum constants being accessible as a top-level declaration, and also makes it easier to do bitwise operations like A | B, which are not possible with Java enums.\n\nNot all types of macros are supported though. Only macros that have a\nprimitive numerical value, a string, or a pointer type are supported. Most\nnotably, function-like macros are not supported by jextract. (See the section\non unsupported features)\n\nNote that for macros, jextract only generates an accessor when it sees a macro\ndefinition, like the one in the example, in the header files it parses. When a\nmacro is defined using -D on the command line, no accessor will be generated.\n(See the section on pre-processor definitions)\n\n### Structs & Unions\n\nThings get a little more complicated for structs and unions. For a struct\ndeclaration like this:\n\n    \n    \n    // mylib.h struct Point { int x; int y; };\n\nJextract generates a separate class which roughly looks like the following:\n\n    \n    \n    // Point.java public class Point { public static final GroupLayout layout() { ... } // 3 public static final OfInt x$layout() { ... } // 2 public static final long x$offset() { ... } // 2 public static int x(MemorySegment struct) { ... } // 1 public static void x(MemorySegment struct, int fieldValue) { ... } // 1 public static final OfInt y$layout() { ... } // 2 public static final long y$offset() { ... } // 2 public static int y(MemorySegment struct) { ... } // 1 public static void y(MemorySegment struct, int fieldValue) { ... } // 1 public static MemorySegment asSlice(MemorySegment array, long index) { ... } // 5 public static long sizeof() { ... } // 3 public static MemorySegment allocate(SegmentAllocator allocator) { ... } // 4 public static MemorySegment allocateArray(long elementCount, SegmentAllocator allocator) { ... } // 4 public static MemorySegment reinterpret(MemorySegment addr, Arena arena, Consumer<MemorySegment> cleanup) { ... } // 6 public static MemorySegment reinterpret(MemorySegment addr, long elementCount, Arena arena, Consumer<MemorySegment> cleanup) { ... } // 6 }\n\nThere are:\n\n  1. a getter and setter for each field of the struct, which takes a pointer to a struct (a MemorySegment) to get/set the field from/to.\n  2. meta-data accessors for each field (xxx$layout() and xxx$offset()).\n  3. meta-data accessors sizeof and layout, which can be used to get the size and layout of the struct.\n  4. allocate* methods for allocating a single struct or arrays of structs.\n  5. an asSlice method which can be used to access elements of an array of structs.\n  6. two reinterpret methods which can be used to sanitize raw addresses returned by native code, or read from native memory.\n\nThe following example shows how to allocate a struct using the allocate\nmethod, and then sets both the x and y field to 10 and 5 respectively:\n\n    \n    \n    // Main.java try (Arena arena = Arena.ofConfined()) { MemorySegment point = Point.allocate(arena); Point.x(point, 10); Point.y(point, 5); // ... }\n\nFor working with arrays of structs, we can use the allocateArray method which\naccepts an additional element count, indicating the length of the array:\n\n    \n    \n    // Main.java try (Arena arena = Arena.ofConfined()) { int arrLen = 5; MemorySegment points = Point.allocateArray(arrLen, arena); for (int i = 0; i < arrLen; i++) { MemorySegment element = Point.asSlice(points, i); Point.x(element, 10 + i); Point.y(element, 5 + i); } // ... }\n\nIn the above example, the asSlice method is used to slice out a section of the\narray, which corresponds to a single Point struct element. This method can be\nused to access individual elements of the points array when given an index.\n\nFinally, the reinterpret method can be used to sanitize a pointer that is\nreturned from native code. Let's say we have a C function that creates an\ninstance of a Point, and returns a pointer to it, as well as a function that\ndeletes a point, given a pointer:\n\n    \n    \n    struct Point* new_point(void); void delete_point(struct Point* ptr);\n\nThe pointer that is returned by new_point does not have the correct bounds or\nlifetime associated with it. These properties can not be inferred: for\ninstance, a pointer could point at a single Point struct, or an array of\nmultiple Point structs.\n\nThe reinterpret method can be used to associate the correct bounds and\nlifetime:\n\n    \n    \n    // Main.java try (Arena arena = Arena.ofConfined()) { MemorySegment point = Point.reinterpret(new_point(), arena, mylib_h::delete_point); // ... } // 'delete_point` called here\n\nThe point segment returned by reinterpret has exactly the size of one Point\n(for arrays of struct, use the reinterpret overload that takes an element\ncount as well). The lifetime we associate with the segment is the lifetime\ndenoted by arena, and when the arena is closed, we want to call delete_point,\nwhich we can do by passing a method reference to delete_point as a cleanup\naction when calling reinterpret.\n\nThe class that jextract generates for unions is identical to the class\ngenerated for structs.\n\n### Function Pointers\n\nJextract generates a separate class for each function pointer type found in\nthe header files it parses. For instance, for a function pointer typedef like\nthis:\n\n    \n    \n    // mylib.h typedef int (*callback_t)(int x, int y);\n\nJextract generates the following class in a callback_t.java file:\n\n    \n    \n    // callback_t.java public class callback_t { public interface Function { int apply(int x, int y); } public static FunctionDescriptor descriptor() { ... } // 1 public static MemorySegment allocate(callback_t.Function fi, Arena arena) { ... } // 2 public static int invoke(MemorySegment funcPtr,int x, int y) { ... } // 3 }\n\nIn the generated class we have:\n\n  1. a meta-data accessor for the function descriptor (descriptor()).\n  2. an allocate method that can be used to allocate a new instance of this function pointer, whose implementation is defined by the fi functional interface instance.\n  3. an invoke method which can be used to invoke an instance of callback_t that we received from native code.\n\nFor instance, let's say we have a C function that accepts an instance of the\ncallback_t function pointer type:\n\n    \n    \n    // mylib.c int call_me_back(callback_t callback) { return callback(1, 2); }\n\nWe can call this function from Java as follows (assuming this function is also\nexported through the header files passed to jextract):\n\n    \n    \n    // Main.java try (Arena arena = Arena.ofConfined()) { MemorySegment cb = callback_t.allocate((a, b) -> a * b, arena); int result = call_me_back(cb); System.out.println(result); // prints: 2 } // 'cb' freed here\n\nHere we use the lambda (a, b) -> a * b as the implementation of the callback_t\ninstance we create using allocate. This method returns an upcall stub like the\nones returned by the Linker::upcallStub method. The arena argument denotes the\nlifetime of the upcall stub, meaning that the upcall stub will be freed when\nthe arena is closed (after which the callback instance can no longer be\ncalled).\n\nAdditionally, we can use the callback_t::invoke method invoke an instance of\ncallback_t that we get back from a call to a C function. Let's say we have a\ncouple of functions like this:\n\n    \n    \n    // mylib.c int mult(int x, int y) { return x * y; } callback_t get_callback(void) { return &mult; }\n\nThe get_callback function returns an instance of callback_t, which is a\nfunction pointer pointing to the native mult function. We can call the\ncallback_t instance that get_callback() returns in Java using the invoke\nmethod in the callback_t class that jextract generates for us:\n\n    \n    \n    // Main.java MemorySegment cb = get_callback(); int result = callback_t.invoke(cb, 1, 2); System.out.println(result); // prints: 2\n\nHere the callback_t instance we want to invoke is passed as the first argument\nto invoke, and then the 1 and 2 represent the arguments passed when calling\nthe callback_t instance.\n\nJextract generates function pointer classes like the callback_t class for\nfunction pointers found in function parameter or return types, typedefs, or\nthe types of variables (such as struct fields or global variables):\n\n    \n    \n    void func(void (*cb)(void)); // function parameter void (*func(void))(void); // function return type typedef void (*cb)(void); // typedef void (*cb)(void); // global variable struct Foo { void (*cb)(void); // struct field };\n\n### Variadic Functions\n\nJextract handles variadic functions differently from regular functions.\nVariadic functions in C behave more or less like a template, where the calling\nconvention changes based on the number and types of arguments passed to the\nfunction. Because of this, the FFM linker needs to know exactly which argument\ntypes are going to be passed to a variadic function when the function is\nlinked. This is described in greater detail in the javadoc of the\njava.lang.foreign.Linker class.\n\nTo make calling variadic functions easier, jextract introduces the concept of\nan invoker. An invoker represents a particular instantiation of a variadic\nfunction for a particular set of variadic parameter types. When the header\nfiles contain a variadic function like this:\n\n    \n    \n    // mylib.h void foo_variadic(int x, ...);\n\nJextract doesn't generate a regular method, but a class, which represents the\ninvoker:\n\n    \n    \n    // mylib.h public static class foo_variadic { public static MemorySegment address() { ... } public static foo_variadic makeInvoker(MemoryLayout... layouts) { ... } // not static! public MethodHandle handle() { ... } public FunctionDescriptor descriptor() { ... } public void apply(int x, Object... x1) { ... } }\n\nThis class has a static meta-data accessor for the function address, and a\nmakeInvoker factory method which can be used to create an instance on the\ninvoker class. The MemoryLayout... arguments passed to makeInvoker represent\nthe memory layouts of the variadic parameters that are to be passed to the\nfunction. The makeInvoker factory essentially instantiates the variadic\nfunction (like you would a template) for a particular set of parameter types.\n\nWe can then use the instance methods apply or handle if we want to invoke the\nfunction, as follows:\n\n    \n    \n    // Main.java foo_variadic invoker = foo_variadic.makeInvoker(C_INT, C_INT, C_INT); invoker.apply(3, 1, 2, 3); invoker.handle().invokeExact(3, 1, 2, 3);\n\nHere we instantiate foo_variadic for 3 parameter types of the C type int.\nThese parameter types essentially replace the ... ellipsis in the C function\ntype.\n\nWe can call the instantiated invoker either by calling apply, which will box\nthe arguments into an Object[], or through the method handle returned by\nhandle() which avoids the overhead of boxing.\n\n### Typedefs\n\nAs mentioned before, typedefs are either translated as a static final memory\nlayout fields in the main header class that jextract generates, or as a\nseparate class, depending on whether the typedef is for a primitive type or a\nstruct/union type respectively.\n\nTake for example the following typedef declarations:\n\n    \n    \n    // mylib.h typedef int MyInt; struct Point { int x; int y; }; typedef struct Point MyPoint;\n\nMyInt is a typedef of the primitive type int, so it is translated by jextract\nas a static final layout field in the main header class:\n\n    \n    \n    // mylib_h.java public static final OfInt MyInt = mylib_h.C_INT;\n\nThe MyPoint typedef, on the other hand, is a typedef for a struct, so it is\ntranslated as a separate class which extends the class that is generated for\nthe Point struct:\n\n    \n    \n    // MyPoint.java public class MyPoint extends Point { }\n\nThrough static inheritance, all the methods in the Point class are available\nthrough the MyPoint class as well.\n\n### Array Types\n\nJextract treats variables (global variables or struct/union fields) with an\narray type specially. For instance, if we have a header file with the\nfollowing declaration:\n\n    \n    \n    // mylib.h int FOO_ARRAY[3][5];\n\nJextract generates a few extra methods that are useful for working with\narrays:\n\n    \n    \n    // mylib_h.java public static MemorySegment FOO_ARRAY() { ... } // 1 public static void FOO_ARRAY(MemorySegment varValue) { ... } // 1 public static int FOO_ARRAY(long index0, long index1) { ... } // 2 public static void FOO_ARRAY(long index0, long index1, int varValue) { ... } // 2 public static SequenceLayout FOO_ARRAY$layout() { ... } // 3 public static long[] FOO_ARRAY$dimensions() { ... } // 4\n\nJextract generates:\n\n  1. a getter and setter pair for the array variable. Note that the getter replaces the usual XYZ$segment method that jextract generates for global variables, as the results of the two methods would be identical.\n  2. a pair of indexed getter and setter methods. These methods can be used to get or set a single element of the array. Each leading long parameter represents an index of one of the dimensions of the array.\n  3. a layout accessor, just like we have for a regular variable, but note that the return type is SequenceLayout.\n  4. a $dimensions meta-data accessor, which returns the dimensions of the array type. This method returns a long[] where each element represents the length of a dimension of the array type. For instance, in the example FOO_ARRAY has two dimensions - 3 and 5 respectively - so the FOO_ARRAY$dimensions method will return a long[] with two elements whose values are 3 and 5 in that order.\n\nFor struct and union fields, the generate methods are comparable, with an\nadditional leading MemorySegment parameter for the getters and setters,\nrepresenting the struct or union instance.\n\nUsing the generated methods, we can access the elements of FOO_ARRAY as\nfollows:\n\n    \n    \n    // Main.java for (long i = 0; i < FOO_ARRAY$dimensions()[0]; i++) { for (long j = 0; j < FOO_ARRAY$dimensions()[1]; j++) { // print out element at FOO_ARRAY[i][j] int e = FOO_ARRAY(i, j); System.out.println(\"FOO_ARRAY[\" + i + \"][\" + j + \"] = \" + e); } }\n\n### Nested Types\n\nC allows variable declarations to have an inline anonymous type. For instance,\nif we have a struct such as this:\n\n    \n    \n    // mylib.h struct Foo { struct { int baz; } bar; // field of Foo void (*cb)(void); };\n\nJextract generates a nested struct and function pointer class for the bar and\ncb fields inside of the class it generates for the Foo struct itself:\n\n    \n    \n    // mylib_h.java public class Foo { ... public static class bar { ... } public static final GroupLayout bar$layout() { ... } public static final long bar$offset() { ... } public static MemorySegment bar(MemorySegment struct) { ... } public static void bar(MemorySegment struct, MemorySegment fieldValue) { ... } ... public static class cb { ... } public static final AddressLayout cb$layout() { ... } public static final long cb$offset() { ... } public static MemorySegment cb(MemorySegment struct) { ... } public static void cb(MemorySegment struct, MemorySegment fieldValue) { ... } ... }\n\nIn both cases, the name of the nested class is the name of the field of the\nstruct.\n\nBoth fields also have the usual getter and setter, but note that the getter\nfor the struct field returns a reference to the memory inside the Foo struct\nthat corresponds to the bar field. This means that writes to the returned\nmemory segment will be visible in the enclosing struct instance as well:\n\n    \n    \n    // Main.java try (Arena arena = Arena.ofConfined()) { MemorySegment foo = Foo.allocate(arena); MemorySegment bar = Foo.bar(foo); // reference to bar inside foo System.out.println(Foo.bar.baz(bar)); // prints: 0 MemorySegment bar2 = Foo.bar.allocate(arena); Foo.bar.baz(bar2, 42); Foo.bar(foo, bar2); // copies bar2 into foo System.out.println(Foo.bar.baz(bar)); // prints: 42 }\n\nIn the above snippet, note that the load of the baz field value on the last\nline will see the update to the bar field of the foo instance on the line\nbefore.\n\n### Unsupported Features\n\nFinally, there are some features that jextract does not support, listed below:\n\n  * Certain C types bigger than 64 bits (e.g. long double on Linux).\n\n  * Function-like macros. Alternatives include re-writing the code inside the macro in Java, using the FFM API, or writing a small C library which wraps the function-like macro in a proper exported C function that can then be linked against through the FFM API.\n\n  * Bit fields. You will see a warning about bit fields being skipped, such as:\n    \n        WARNING: Skipping Foo.x (bitfields are not supported)\n\n  * Opaque types. When a struct or union type is declared but not defined, like:\n    \n        struct Foo;\n\nJextract is not able to generate the regular Foo class. You will see a warning\nabout these structs being skipped, such as:\n\n    \n        WARNING: Skipping Foo (type Declared(Foo) is not supported)\n\n  * Linker options. It is currently not possible to tell jextract to use linker options to link a particular function. Code will have to be edited manually to add them. (for instance, if the function sets errno, the Linker.Option.captureCallState option has to be added manually).\n\n  * It is not possible to specify the byte order of a struct field on the command line. Attributes that control the byte order, such as GCC's scalar_storage_order are currently ignored. Again, manual editing of the generated code is required to work around this.\n\n## Advanced\n\n### Preprocessor Definitions\n\nC header files are processed by a pre-processor before they are inspected\nfurther. It is possible for a header file to contain so-called 'compiler\nswitches', which can be used to conditionally generate code based on the value\nof a macro, for instance:\n\n    \n    \n    #ifdef MY_MACRO int x = 42; #else int x = 0; #endif\n\nThe value of these macros also affects the behavior of jextract. Therefore,\njextract supports setting macro values on the command line using the -D or\n--define-macro <macro>=<value> option. For instance, we can use -D MY_MACRO to\nset the value of MY_MACRO in the above snippet to 1, and trigger the first\nbranch of the compiler switch, thereby defining int x = 42.\n\nPlease note that other header files included by jextract may also define macro\nvalues using the #define pre-processor directive. It is therefore important to\nnotice the order in which header files are processed by a compiler, as feeding\nheader files to jextract in the wrong order may result in weird errors due to\nmissing macro definitions. A well-known example of this are Windows SDK\nheaders. Almost always, the main Windows.h header file should be passed to\njextract for things to work correctly. Please consult the documentation of the\nlibrary that you're trying to use to find out which header file should be\nincluded/passed to jextract.\n\n### Library Loading\n\nWhen using the --library <libspec> option, the generated code internally uses\nSymbolLookup::libraryLookup to load libraries specified by <libspec>. If\n<libspec> denotes a library name, the name is then mapped to a platform\ndependent name using System::mapLibraryName. This means, for instance, that on\nLinux, when specifying --library mylib, the bindings will try to load\nlibmylib.so using the OS-specific library loading mechanism on Linux, which is\ndlopen. This way of loading libraries also relies on OS-specific search\nmechanisms to find the library file. On Linux the search path can be amended\nusing the LD_LIBRARY_PATH environment variable (see the documentation of\ndlopen). On Mac the relevant environment variable is DYLD_LIBRARY_PATH, and on\nWindows the variable is PATH. Though, for the latter the overall library\nsearch mechanism is entirely different (described here). When using the\nHotSpot JVM, the -Xlog:library option can also be used to log where the JVM is\ntrying to load a library from, which can be useful to debug a failure to load\na library.\n\nThe <libspec> argument of the --library option can either be a library name,\nor a path to a library file (either relative or absolute) if <libspec> is\nprefixed with the : character, such as :mylib.dll.\n\nIt is important to understand how libraries are loaded on the platform that is\nbeing used, as the library search mechanisms differ between them.\nAlternatively, JNI's library loading and search mechanism can be used as well.\nWhen the --use-system-load-library option is specified to jextract, the\ngenerated bindings will try to load libraries specified using --library\nthrough System::loadLibrary. The library search path for System::loadLibrary\nis specified through the java.library.path system property instead of the OS-\nspecific environment variable. Though, please note that if the loaded library\nhas any dependencies, those dependencies will again be loaded through the OS-\nspecific library loading mechanism (this is outside of the JVM's control).\n\nWhen no --library option is specified, the generated bindings will try to load\nfunction from libraries loaded through System::loadLibrary and System::load,\nusing SymbolLookup::loaderLookup, with Linker::defaultLookup as a fallback.\nWhen --library is specified when generating the bindings, these 2 lookup modes\nwill be used as a fallback.\n\nIn both cases, the library is unloaded when the class loader that loads the\nbinding classes is garbage collected.\n\n### Filtering\n\nSome libraries are incredibly large (such as Windows.h), and we might not be\ninterested in letting jextract generate code for the entire library. In cases\nlike that, we can use jextract's --include-XXX command line options to only\ngenerate classes for the elements we specify.\n\nTo allow for symbol filtering, jextract can generate a dump of all the symbols\nencountered in an header file; this dump can be manipulated, and then used as\nan argument file (using the @argfile syntax also available in other JDK tools)\nto e.g., generate bindings only for a subset of symbols seen by jextract. For\ninstance, if we run jextract with as follows:\n\n    \n    \n    $ jextract --dump-includes includes.txt mylib.h\n\nWe obtain the following file (includes.txt):\n\n    \n    \n    #### Extracted from: /workspace/myproj/mylib.h --include-struct Foo # header: /workspace/myproj/mylib.h --include-struct Point # header: /workspace/myproj/mylib.h --include-typedef callback_t # header: /workspace/myproj/mylib.h --include-function call_me_back # header: /workspace/myproj/mylib.h ...\n\nThe include options in this file can then be edited down to a set of symbols\nthat is desired, for instance, using other command line tools such as grep or\nSelect-String, and passed back to jextract:\n\n    \n    \n    $ jextract --dump-includes includes.txt mylib.h $ grep Foo includes.txt > includes_filtered.txt $ jextract @includes_filtered.txt mylib.h\n\nUsers should exercise caution when filtering symbols, as it is relatively easy\nto filter out a declaration that is depended on by one or more declarations:\n\n    \n    \n    // test.h struct A { int x; } struct A aVar;\n\nHere, we could run jextract and filter out A, like so:\n\n    \n    \n    $ jextract --include-var aVar test.h\n\nHowever, doing so would lead to broken generated code, as the layout of the\nglobal variable aVar depends on the layout of the excluded struct A.\n\nIn such cases, jextract will report the missing dependency and terminate\nwithout generating any bindings:\n\n    \n    \n    ERROR: aVar depends on A which has been excluded\n\n### Tracing\n\nIt is sometimes useful to inspect the parameters passed to a native call,\nespecially when diagnosing application bugs and/or crashes. The code generated\nby the jextract tool supports tracing of native calls, that is, parameters\npassed to native calls can be printed on the standard output.\n\nTo enable the tracing support, just pass the -Djextract.trace.downcalls=true\nflag as a VM argument to the launcher used to start the application that uses\nthe generated bindings. Below we show an excerpt of the output when running\nthe OpenGL example with tracing support enabled:\n\n    \n    \n    glutInit(MemorySegment{ address: 0x7fa6b03d6400, byteSize: 4 }, MemorySegment{ address: 0x7fa6b03d6400, byteSize: 4 }) glutInitDisplayMode(18) glutInitWindowSize(900, 900) glutCreateWindow(MemorySegment{ address: 0x7fa6b03f8e70, byteSize: 14 }) glClearColor(0.0, 0.0, 0.0, 0.0) glShadeModel(7425) glLightfv(16384, 4611, MemorySegment{ address: 0x7fa6b03de8d0, byteSize: 16 }) glLightfv(16384, 4608, MemorySegment{ address: 0x7fa6b0634840, byteSize: 16 }) glLightfv(16384, 4609, MemorySegment{ address: 0x7fa6b0634840, byteSize: 16 }) glLightfv(16384, 4610, MemorySegment{ address: 0x7fa6b0634840, byteSize: 16 }) glMaterialfv(1028, 5633, MemorySegment{ address: 0x7fa6b0634860, byteSize: 4 }) glEnable(2896) glEnable(16384) glEnable(2929) glutDisplayFunc(MemorySegment{ address: 0x7fa6a002e820, byteSize: 0 }) glutIdleFunc(MemorySegment{ address: 0x7fa6a015a620, byteSize: 0 }) glutMainLoop() glClear(16640) glPushMatrix() glRotatef(-20.0, 1.0, 1.0, 0.0) glRotatef(0.0, 0.0, 1.0, 0.0) glutSolidTeapot(0.5)\n\n### Command Line Option Reference\n\nA complete list of all the supported command line options is given below:\n\nOption| Meaning  \n---|---  \n-D --define-macro <macro>=<value>| define <macro> to <value> (or 1 if <value> omitted)  \n\\--header-class-name <name>| name of the generated header class. If this\noption is not specified, then header class name is derived from the header\nfile name. For example, class \"foo_h\" for header \"foo.h\".  \n-t, --target-package <package>| target package name for the generated classes. If this option is not specified, then unnamed package is used.  \n-I, --include-dir <dir>| append directory to the include search paths. Include search paths are searched in order. For example, if -I foo -I bar is specified, header files will be searched in \"foo\" first, then (if nothing is found) in \"bar\".  \n-l, --library <name | path>| specify a shared library that should be loaded by the generated header class. If starts with :, then what follows is interpreted as a library path. Otherwise, <libspec> denotes a library name. Examples: -l GL -l :libGL.so.1 -l :/usr/lib/libGL.so.1  \n\\--use-system-load-library| libraries specified using -l are loaded in the\nloader symbol lookup (using either System::loadLibrary, or System::load).\nUseful if the libraries must be loaded from one of the paths in\njava.library.path.  \n\\--output <path>| specify where to place generated files  \n\\--dump-includes <String>| dump included symbols into specified file (see\nbelow)  \n\\--include-[function,constant,struct,union,typedef,var]<String>| Include a\nsymbol of the given name and kind in the generated bindings. When one of these\noptions is specified, any symbol that is not matched by any specified filters\nis omitted from the generated bindings.  \n\\--version| print version information and exit  \n  \n#### Additional clang options\n\nJextract uses an embedded clang compiler (through libclang) to parse header\nfiles. Users can also specify additional clang compiler options by creating a\nfile named compile_flags.txt in the current folder, as described here.\n\n### Other Languages\n\nAs noted in the introduction, jextract currently only supports C header files,\nbut many other languages also support C interop, and jextract/FFM can still be\nused to talk to libraries written in those language through an intermediate C\nlayer. The table below describes how to do this for various different\nlangauges:\n\nLanguage| Method of access  \n---|---  \nC++| C++ allows declaring C methods using extern \"C\", and many C++ libraries\nhave a C interface to go with them. Jextract can consume such a C interface,\nwhich can then be used to access the library in question.  \nRust| The Rust ecosystem has a tool called cbindgen which can be used to\ngenerate a C interface for a Rust library. Such a generated C interface can\nthen be consumed by jextract, and be used to access the library in question.  \n  \n## Footer\n\n\u00a9 2024 GitHub, Inc.\n\nYou can\u2019t perform that action at this time.\n\n", "frontpage": false}
