{"aid": "40245992", "title": "Ansible Is a Lisp", "url": "https://astrid.tech/2024/05/01/0/ansible-is-a-lisp/", "domain": "astrid.tech", "votes": 2, "user": "thunderbong", "posted_at": "2024-05-03 10:09:58", "comments": 0, "source_title": "Ansible is a Lisp", "source_text": "Ansible is a Lisp\n\n# astrid dot tech\n\n# Ansible is a Lisp\n\nMore specifically, Ansible is homoiconic and has syntactic macros\n\n2024-05-01 13:14\n\nansible lisp macros\n\nThe Lisp family of languages is unique because code and data have the exact\nsame form, and code is data, and data is code. This property is called\nhomoiconicity.\n\nConsider the following Racket program (from The Racket Guide):\n\n    \n    \n    (define (extract str) (substring str 4 7)) (extract \"the cat out of the bag\")\n\nWhen evaluated by Racket, it will output \u201ccat\u201d. However, you can also think of\nit as a pure piece of data \u2013 a nested list of strings and numbers and other\nobjects. If you aren\u2019t familiar with Lisp syntax, here\u2019s a JSON equivalent\n(though Racket has symbols and JSON doesn\u2019t so we\u2019ll turn symbols into\nstrings):\n\n    \n    \n    [[\"define\", [\"extract\", \"str\"], [\"substring\", \"str\", 4, 7]], [\"extract\", \"the cat out of the bag\"]]\n\nHowever, Ansible, the IaC automation tool, is also homoiconic. It executes\nYAML files, and can treat YAML as data. Here\u2019s an example playbook as a hello\nworld, pulled from Ansible\u2019s own introduction page:\n\n    \n    \n    - name: My first play hosts: myhosts tasks: - name: Ping my hosts ansible.builtin.ping: - name: Print message ansible.builtin.debug: msg: Hello world\n\nAnsible also has syntactic JSON templating, as seen in this StackOverflow\nanswer:\n\n    \n    \n    - copy: dest: kube-controller-manager-csr.json content: \"{{ certificate | to_json }}\" vars: certificate: CN: system:kube-controller-manager key: algo: rsa size: 2048 names: - C: US L: Portland O: system:kube-controller-manager OU: Kubernetes The Hard Way ST: Oregon\n\nThis writes the following file:\n\n    \n    \n    { \"CN\": \"system:kube-controller-manager\", \"key\": { \"algo\": \"rsa\", \"size\": 2048 }, \"names\": [ { \"C\": \"US\", \"L\": \"Portland\", \"O\": \"system:kube-controller-manager\", \"OU\": \"Kubernetes The Hard Way\", \"ST\": \"Oregon\" } ] }\n\n## Syntactic Macros\n\nOne of the killer features of Lisp is that it has syntactic macros. However,\nAnsible also has those. Consider the following playbook:\n\n    \n    \n    - name: ansible has syntactic macros ehe :3 hosts: ::1 connection: local tasks: - name: Run a shell command and register its output to foo_result ansible.builtin.shell: echo myfoo first register: foo_result - name: Syntactically generate some tasks copy: dest: intermediate.generated.yml content: \"{{ tasks | to_json }}\" vars: tasks: - name: Print something silly ansible.builtin.debug: msg: \"foo_result was templated in as: {{ foo_result.stdout }}\" - name: Set foo_result to something else to test scoping ansible.builtin.shell: echo myfoo second register: foo_result - name: Execute the generated tasks ansible.builtin.include_tasks: intermediate.generated.yml\n\nOutput:\n\n    \n    \n    $ ansible-playbook playbook.yml [WARNING]: No inventory was parsed, only implicit localhost is available [WARNING]: provided hosts list is empty, only localhost is available. Note that the implicit localhost does not match 'all' PLAY [ansible has syntactic macros ehe :3] ************************************* TASK [Gathering Facts] ********************************************************* ok: [::1] TASK [Run a shell command and register its output to foo_result] *************** changed: [::1] TASK [Syntactically generate some tasks] *************************************** ok: [::1] TASK [Set foo_result to something else to test scoping] ************************ changed: [::1] TASK [Execute the generated tasks] ********************************************* included: /home/astrid/Documents/lispible/intermediate.generated.yml for ::1 TASK [Print something silly] *************************************************** ok: [::1] => { \"msg\": \"foo_result was templated in as: myfoo first\" } PLAY RECAP ********************************************************************* ::1 : ok=6 changed=2 unreachable=0 failed=0 skipped=0 rescued=0 ignored=0\n\nWhat\u2019s going on here?\n\nHere\u2019s the part where we generate the syntax:\n\n    \n    \n    - name: Syntactically generate some tasks copy: dest: intermediate.generated.yml content: \"{{ tasks | to_yaml }}\" vars: tasks: - name: Print something silly ansible.builtin.debug: msg: \"foo_result was templated in as: {{ foo_result.stdout }}\"\n\nEssentially, we are syntactically constructing a task inside the copy task,\nand writing it to a file called intermediate.generated.yml. Here\u2019s what it\nlooks like:\n\n    \n    \n    - ansible.builtin.debug: { msg: \"foo_result was templated in as: myfoo first\" } name: Print something silly\n\nYou\u2019ll notice that we string-templated in the first evaluation of foo_result,\nso that\u2019s the one captured here\n\nHere\u2019s where we execute the generated syntax:\n\n    \n    \n    - name: Execute the generated tasks ansible.builtin.include_tasks: intermediate.generated.yml\n\nThis is actually done when the task is evaluated, rather than when the whole\nprogram is loaded, so this will be able to find the generated YAML file.\n\nUnfortunately, these macros are non-hygenic, so if we did something like this\ninstead:\n\n    \n    \n    - name: ansible has syntactic macros ehe :3 hosts: ::1 connection: local tasks: - name: Run a shell command and register its output to foo_result ansible.builtin.shell: echo myfoo first register: foo_result - name: Syntactically generate some tasks copy: dest: intermediate.generated.yml content: \"{{ tasks | to_yaml }}\" vars: tasks: - name: Print something silly ansible.builtin.debug: msg: # Note this line here! \"foo_result was templated in as: {{ '{{ foo_result.stdout }}' }}\" - name: Set foo_result to something else to test scoping ansible.builtin.shell: echo myfoo second register: foo_result - name: Execute the generated tasks ansible.builtin.include_tasks: intermediate.generated.yml\n\nwe would get the following intermediate file:\n\n    \n    \n    - ansible.builtin.debug: { msg: \"foo_result was templated in as: {{ foo_result.stdout }}\" } name: Print something silly\n\nwhich will capture the second evaluation of foo_result, as seen in this\noutput:\n\n    \n    \n    > ansible-playbook playbook2.yml [WARNING]: No inventory was parsed, only implicit localhost is available [WARNING]: provided hosts list is empty, only localhost is available. Note that the implicit localhost does not match 'all' PLAY [ansible has syntactic macros ehe :3] ***************************************************************** TASK [Gathering Facts] ************************************************************************************* ok: [::1] TASK [Run a shell command and register its output to foo_result] ******************************************* changed: [::1] TASK [Syntactically generate some tasks] ******************************************************************* ok: [::1] TASK [Set foo_result to something else to test scoping] **************************************************** changed: [::1] TASK [Execute the generated tasks] ************************************************************************* included: /home/astrid/Documents/lispible/intermediate.generated.yml for ::1 TASK [Print something silly] ******************************************************************************* ok: [::1] => { \"msg\": \"foo_result was templated in as: myfoo second\" } PLAY RECAP ************************************************************************************************* ::1 : ok=6 changed=2 unreachable=0 failed=0 skipped=0 rescued=0 ignored=0\n\n## Where are the parens, though?\n\n\u201cBut wait,\u201d you, the rhetorical Lisp purist, might ask. \u201cAnsible doesn\u2019t have\nall those funny parens that Lisp has! You can\u2019t call it a Lisp!\u201d\n\nBut it spiritually is a Lisp! In Ansible, code is literal YAML data, and\nliteral YAML data is interpreted as code. This is because Ansible is what\nhappens when you because you wanted to reduce the amount of code you write, so\nyou write YAML and pretend it isn\u2019t code, but then your YAML becomes so\nsufficiently complex that you accidentally horseshoe-theory yourself into Lisp\nagain.\n\nBut fine. If you really object to the lack of parens, I can turn it into a\n\u201cproper Lisp\u201d for you.\n\nI\u2019m too lazy to write my own json-to-sexp-to-json converter so I\u2019ll just use\nthis random one I found on the internet.\n\n    \n    \n    $ yq < ../playbook.yml > playbook.json $ python json_sexpr.py playbook.json -s (list (dict \"name\" \"ansible has syntactic macros ehe :3\" \"hosts\" \"::1\" \"connection\" \"local\" \"tasks\" (list (dict \"name\" \"Run a shell command and register its output to foo_result\" \"ansible.builtin.shell\" \"echo myfoo first\" \"register\" \"foo_result\") (dict \"name\" \"Syntactically generate some tasks\" \"copy\" (dict \"dest\" \"intermediate.generated.yml\" \"content\" \"{{ tasks | to_yaml }}\") \"vars\" (dict \"tasks\" (list (dict \"name\" \"Print something silly\" \"ansible.builtin.debug\" (dict \"msg\" \"foo_result was templated in as: {{ foo_result.stdout }}\"))))) (dict \"name\" \"Set foo_result to something else to test scoping\" \"ansible.builtin.shell\" \"echo myfoo second\" \"register\" \"foo_result\") (dict \"name\" \"Execute the generated tasks\" \"ansible.builtin.include_tasks\" \"intermediate.generated.yml\"))))\n\nBecause I love you so much, rhetorical Lisp purist, I even formatted it for\nyou! I\u2019ve made Lispible!\n\n    \n    \n    (list (dict \"name\" \"ansible has syntactic macros ehe :3\" \"hosts\" \"::1\" \"connection\" \"local\" \"tasks\" (list (dict \"name\" \"Run a shell command and register its output to foo_result\" \"ansible.builtin.shell\" \"echo myfoo first\" \"register\" \"foo_result\") (dict \"name\" \"Syntactically generate some tasks\" \"copy\" (dict \"dest\" \"intermediate.generated.yml\" \"content\" \"{{ tasks | to_yaml }}\") \"vars\" (dict \"tasks\" (list (dict \"name\" \"Print something silly\" \"ansible.builtin.debug\" (dict \"msg\" \"foo_result was templated in as: {{ foo_result.stdout }}\"))))) (dict \"name\" \"Set foo_result to something else to test scoping\" \"ansible.builtin.shell\" \"echo myfoo second\" \"register\" \"foo_result\") (dict \"name\" \"Execute the generated tasks\" \"ansible.builtin.include_tasks\" \"intermediate.generated.yml\"))))\n\nSo now, in order to execute, you just transpile it to YAML like this:\n\n    \n    \n    $ python json_sexpr.py playbook.sexp -j > playbook.yml $ ansible-playbook playbook.yml\n\nPlease don\u2019t do this in production.\n\n## Webrings\n\n\u2190 xxiivv \u2192\n\n\u2190 \ud83c\udff3\ufe0f\ud83c\udf08 bucket webring \ud83c\udff3\ufe0f\ud83c\udf08 \u2192\n\n\u00a9 2019-2024 Astrid Yu. Some rights reserved.\n\nastrid.tech v3 was generated by seams, the seamingly silly CMS. Seams, in\nturn, was made by Astrid Yu with a generous helping of tea and insomnia.\n\nSeams is licensed under AGPL-3.0-Only. The content of astrid.tech is licensed\nunder Creative Commons BY-SA 4.0.\n\n", "frontpage": false}
