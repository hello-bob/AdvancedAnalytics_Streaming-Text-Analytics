{"aid": "40090301", "title": "To abort or to return an error: why not both?", "url": "https://workdad.dev/posts/abort-error-why-not-both/", "domain": "workdad.dev", "votes": 1, "user": "iccananea", "posted_at": "2024-04-19 18:22:38", "comments": 0, "source_title": "To abort or to return an error: why not both?", "source_text": "To abort or to return an error: why not both? // Work Dad Dev\n\nWork Dad Dev\n\nRandom tech thoughts that seem to connect.\n\n# To abort or to return an error: why not both?\n\nApr 18, 2024\n\n6 min read\n\nWhen building fault-tolerant services, reliably and consistently handling\nerrors is a top priority. Errors will always happen in production, are usually\ntransient and your service should be able to survive an error spike; defining\nan SLO will give you the error budget you need to work with them.\n\nBut how should you handle errors, really? More specifically, in case a method\nin your code returns an error / throws an exception, what is the \u201ccorrect\u201d way\nto handle it? I\u2019ve worked in places where every error was logged and relied on\nalerts to get the developer\u2019s attention. Aborting (crashing) the service on\nstartup if any of the required dependencies aren\u2019t available is also a\npossibility, though in a job interview arguing for this was cited as a cause\nof me not getting an offer.\n\nShould you ever abort then? Isn\u2019t it better to just log errors and rely on\nalerts so that your service is always up? Well, the \u201csenior engineer\u201d answer\nis \u201cit depends\u201d. The actual answer is \u201cit depends, but here are some\nguidelines.\u201d\n\n### Abort if possible, return error otherwise.\n\nAborting a service is actually good. It gives a clear signal that something is\nwrong with the application and most teams will set alarms for any aborts,\nusually with detailed stack traces, bringing the dev\u2019s attention to it. But,\ncrashing a service means reduced availability and restart penalties: depending\non the service, it could take a while for it to go back to a usable state.\n\nErrors don\u2019t crash, also send a clear signal but can become invisible: if they\nonly occur on a specific code path with a specific traffic pattern, then they\nbecome blips in your error logs^1. If you eventually look at them, it might\nnot be possible to reproduce the scenario easily.\n\nAborting brings the problem to the forefront but brings your service down.\nErroring could mask it until it\u2019s too late. When should you use either?\n\nBefore that, let\u2019s make a few assumptions:\n\n  * You have at least 2 replicas of your service in production (pods for the k8s crowd)\n  * Updating a service will not remove the replica running the older version until the new replica is healthy.\n  * You have good test coverage and automated testing so any aborts / error paths are tested.\n  * You have alerts for any abort and for X% of errors (doesn\u2019t really matter which percentage as long as it is low, say less than 5%).\n\n    * Healthy, as described above, means that service is responding with less than the SLO error rate.\n\n### Abort on startup\n\nAny errors that occur at startup that would make any part of your service\nunusable should result in an abort. It could be argued that starting the\nservice with degraded performance is a better option and it may well be in\nyour case. But, that makes its maintenance and production troubleshooting\nharder.\n\nUnless you are a part of the team or the team has very good documentation on\nthe degraded scenario (and let\u2019s be real: most teams would not have documented\nit), it would at best be a distraction when trying to solve a real production\nissue and at worst could completely derail you from solving it.\n\n### Never abort on user input\n\nUser input is an obvious case where you should always return an error, even if\nit could stay invisible for a while. Aborting on user input is a denial of\nservice (DoS) attack vector, rendering your service unusable by anyone until\nyou fix the code. Returning an error would affect only that code path, giving\nyou a degraded but still available performance.\n\n### Abort on programming errors\n\nThis one is a bit more contentious, especially since it can be ambiguous\nwhether it is a programming error or not. If you are in doubt, then by all\nmeans return an error. But if you can confidently identify it as one, aborting\nis the correct strategy.\n\nTo illustrate, let me show you an example in Go. Go has a sync.Map type which\nis a concurrency safe hash table. It was created before generics so both the\nkey and value have the empty interface (any) as type. Callers are supposed to\nconvert to the correct types when needed.\n\nSuppose I use this map in a database sharding context: the key is the shard\nname and the value is that database connection (*sql.DB) for the shard.\nSuppose also that this map can only be updated by your team, through tolling\nyou built. There is no user input involved in deciding the shard name nor\ninupdating it, it is 100% under your control.\n\nIn this case, it is reasonable to write code like this:\n\n    \n    \n    // Conn returns the database connection for the given shard. func (s *Service) Conn(shard string) *sql.DB { value, ok := s.conns.Load(shard) if !ok { panic(\"invalid shard\") } return value.(*sql.DB) } // UpdateConn updates that shard's database connection to newConn. func (s *Service) UpdateConn(shard string, newConn *sql.DB) error { prev, existed := s.conns.Swap(shard, newConn) if existed { // Handle closing the connection in a safe way db := prev.(*sql.DB) ... } }\n\nIn both Conn and UpdateConn, value is being cast to *sql.DB. If the type cast\nis invalid, it would abort the service, To be safe, it should have actually\nbeen written as:\n\n    \n    \n    db, ok := value.(*sql.DB) if !ok { // This is a programming error, as it should always be an *sql.DB return fmt.Errorf(\"invalid database\") } ...\n\nBut that is not really needed because s.conn should always have *sql.DB values\nas types. If it doesn\u2019t then a programming error occurred at some point and\nthe service is no longer correct. The same goes for the shard name: if it is\n100% under the programmer\u2019s controll which shard to use, then panicing as in\nthe example is an acceptable solution.\n\nAborting in this case is actually the better option because it forces the\nserver to go back to startup mode. If the error was at startup, it will crash-\nloop. If the error was in some toolling that corrupted the map, chances are it\nwould be corrected on startup.\n\nAlso, the API for the two methods would have to change to return (*sql.DB,\nerror) instead of just *sql.DB, forcing callers to check for the error and\nmaking the API call more complex than really needed.\n\n### Aborting makes the API cleaner\n\nThis is a clear advantage of being able to abort: your API is simpler to use\nsince you don\u2019t need to check for an error or exceptions. In Go, for example,\nI wouldn\u2019t have been able to chain calls with Conn if it returned an error.\nInstead of writing\n\n    \n    \n    err := s.Conn(shard).Query(\"your database query\")\n\nI would have to write\n\n    \n    \n    db. err := s.Conn(shard) if err != nil { return err } if db == nil { return fmt.Errorf(\"invalid shard\") } err = db.Query(\"your database query\")\n\nWhich is clearly more verbose and, in this context, unnecessary.\n\nSo if you can, abort your service. There are both reliability and api\nadvantages to it. Otherwise, return an error and make sure you have good\nmonitoring and alerts in place.\n\n## Notes\n\n  1. Unless you define your error SLO to be 0.0% errors, which you should never do. \u21a9\ufe0e\n\n", "frontpage": false}
