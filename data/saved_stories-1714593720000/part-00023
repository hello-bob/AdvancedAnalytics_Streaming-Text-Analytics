{"aid": "40220954", "title": "Architecture Testing in Laravel with Pest", "url": "https://www.honeybadger.io/blog/laravel-pest-architecture-testing/", "domain": "honeybadger.io", "votes": 1, "user": "ashallendesign", "posted_at": "2024-05-01 08:48:32", "comments": 0, "source_title": "Architecture testing in Laravel with Pest", "source_text": "Architecture testing in Laravel with Pest - Honeybadger Developer Blog\n\n\ud83d\ude80 Ship your production logs to Honeybadger, get a free t-shirt. While supplies\nlast. See how \u2192\n\n# Architecture testing in Laravel with Pest\n\nStandards and consistency are an important part of any web application, but\nenforcing them can be boring and tedious. In this article, we'll look at how\nwe can automate this process using Pest to improve the quality of our Laravel\nprojects.\n\n  * By Ashley Allen\n  * #php #laravel #testing\n  * Apr 30, 2024\n\nMaintaining standards in an ever-growing codebase that multiple developers\ncontribute to can be difficult and tedious. Ensuring that the codebase follows\nbest practices and does not deviate from the standards is essential for any\nproject. But this is typically something that can only be enforced manually by\ncode reviews and other similar processes. As with any other manual task, this\ncan be time-consuming, tedious, and error-prone. That's where architecture\ntesting comes in.\n\nArchitecture testing allows you to automatically enforce code standards such\nas naming conventions, method usage, directory structure, and more.\n\nIn this article, we're going to learn about what architecture testing is and\nthe benefits of using it. We'll then look at how to write architecture tests\nfor our Laravel applications using the popular PHP testing framework, Pest. By\nthe end, you'll be confident to start writing architecture tests for your\nLaravel applications.\n\n## What is Pest?\n\nPest is an open-source PHP testing framework built on top of PHPUnit. At the\ntime of writing, it has over 9.4 million downloads and 7.9k stars on GitHub.\nIt uses a syntax and approach similar to Jest (a popular JavaScript testing\nframework) and Ruby's RSpec. If you're familiar with writing JavaScript tests\nusing Jest, you should feel at home using Pest for PHP tests.\n\nFor example, imagine you have a simple add function that adds two numbers\ntogether, and you want to ensure that it returns the correct value. You might\nwrite a test in Pest like this:\n\n    \n    \n    test('add function returns the correct value') ->expect(add(1, 2)) ->toBe(3);\n\nAs we can see, the tests use a fluent syntax that allows us to chain methods\ntogether. This results in tests that are simple, easy to read, and understand.\n\nA benefit to using Pest for testing your Laravel applications is that it\noffers several features that you can use to improve your testing experience.\nThese include:\n\n  * Architecture testing - This allows you to enforce code standards automatically, such as naming conventions, method usage, and directory structure. (That's what we're covering in this article.)\n  * Parallel testing - This allows you to run your tests in parallel, which can help to speed up your test suite.\n  * Snapshot testing - This allows you to test that values are the same as when the snapshot was created. Snapshot testing can help when testing API responses or when performing large refactors, and you want to ensure the output hasn't changed.\n  * Test profiling - This allows you to see how long each test takes to run and can be useful for identifying slow tests that you may want to refactor.\n  * Watch mode - This allows you to automatically re-run your tests whenever a file changes in your project.\n  * Code coverage - This allows you to see how much of your code is exercised by your tests to know which parts of your codebase need more tests. It can also provide insight into the type coverage of your codebase to identify any methods that aren't using return types and type hints.\n\nSince Pest is built on top of PHPUnit, you can also run your existing PHPUnit\ntests using Pest. That means that you don't need to worry about migrating your\ncurrent tests to the Pest syntax to be able to use it and start benefiting\nfrom the other features it offers.\n\n## What is architecture testing?\n\nArchitecture testing differs from the traditional tests you might normally\nwrite for your projects. Whereas your traditional tests test the functionality\nof your application, architecture tests test the structure of your\napplication. They allow you to enforce standards and consistency in your\nprojects.\n\nDepending on the type of project you're working on, you may have a set of\nstandards or guidelines set by your employer, client, or yourself. For\nexample, you might want to enforce things such as:\n\n  * Strict type-checking is used in all files.\n  * The app/Interfaces directory only contains interfaces.\n  * All classes in the app/Services directory are suffixed with Service (e.g., UserService, BillingService, etc.).\n  * All models in the app/Models directory extend the Illuminate\\Database\\Eloquent\\Model class.\n  * All action classes in the app/Actions directory are invokable (meaning they have an __invoke method).\n  * Controllers aren't used anywhere apart from the routes files in the application.\n  * Only traits exist in the app/Traits directory.\n  * All classes inside the app/DataTransferObjects directory are readonly.\n\nGenerally, you should enforce these things manually via code reviews and other\nsimilar processes. With architecture testing, you can enforce these standards\nautomatically and know for sure that they're followed.\n\nFor example, take this simple test that enforces that all interfaces exist\nwithin the App\\Interfaces namespace:\n\n    \n    \n    test('interfaces namespace only contains interfaces') ->expect('App\\Interfaces') ->toBeInterfaces();\n\nThe above test can be run like any other Pest test. The test will pass if all\nthe files in the App\\Interfaces namespace are interfaces. However, the test\nwill fail if any of the files in this namespace aren't interfaces.\n\n\u201cEveryone is in love with Honeybadger ... the UI is spot on.\u201d\n\nMolly Struve, Sr. Site Reliability Engineer, Netflix\n\nStart free trial\n\n## Benefits of architecture testing\n\nNow that we have a basic understanding of architecture testing let's look at\nits benefits in your projects.\n\n### Reduce code review time\n\nAs we've already mentioned, architecture testing is an excellent way of\nautomating the process of enforcing standards in your codebase.\n\nTo demonstrate this, let's look at an example workflow between two developers\nin a team that doesn't use architecture testing. We'll assume that one of the\ndevelopers has been working on a new feature and is making a pull request to\nmerge their changes into the main branch:\n\n  * Developer A writes the code for the feature.\n  * Developer A makes a pull request.\n  * Developer A asks for a review from Developer B.\n  * Developer B reviews the code and spots an architectural issue (for example, a file in the wrong directory).\n  * Developer B leaves a comment on the pull request and asks Developer A to fix the issue.\n  * Developer A fixes the issue and asks for another review.\n  * Developer B reviews the code again and approves the pull request (assuming no other errors).\n\nAs we can see, this process has the potential to be slow because it relies on\nother developers in the team. It also depends on the other developer to spot\nthe issue, which means it could still get through the approval process even if\nthere's an architectural issue.\n\nBy using an automated architecture testing strategy, the process could look\nlike this:\n\n  * Developer A writes the code for the feature.\n  * (Optional) Developer A runs the architecture tests locally. If they spot any issues, they fix them.\n  * Developer A makes a pull request.\n  * The CI pipeline runs the architecture tests.\n  * Developer fixes any architectural issues.\n  * Developer A asks for a review from Developer B.\n  * Developer B reviews the code and approves the pull request (assuming no other errors).\n\nAs we can see, by being able to run the architecture tests locally and in the\nCI pipeline, it can provide instant feedback that doesn't involve the other\ndeveloper. This means that Developer A can spot and fix the issues before\nDeveloper B is involved in the approval process. This speeds up the\ndevelopment process and reduces the time the other developer needs to spend\nreviewing the code and looking for architectural issues.\n\n### Improve code quality and consistency\n\nEnforcing standards and consistency early on in a project can help to improve\nthe overall code quality. It helps implement a sensible set of rules that\ndevelopers can follow to ensure they write code that other developers can\nunderstand.\n\nEvery developer has their own way of writing code. I'm sure you'll agree that\nonce you've worked on a project for a long enough time, you can usually tell\nwho wrote a particular piece of code by the variable and method names or how\nthe classes are structured. Minor differences like these aren't typically a\nbig deal as long as they follow the general standards of the project that the\nother developers are also following.\n\nHowever, the codebase may have some alarming differences if you don't enforce\nstandards. For example, you might have one developer who prefers to keep their\ninterfaces in an app/Interfaces directory. However, you might have another\ndeveloper who prefers to keep the interfaces in a folder related to the class.\nFor instance, they might put a UserServiceInterface interface inside an\napp/Services/User directory so it lives alongside the UserService class\ninstead of placing it in the app/Interfaces directory.\n\nThese types of differences can cause consistency issues and make it difficult\nfor other developers to understand and work on the codebase. Although\ninconsistencies such as these should have been caught during a manual code\nreview process, they may not have been. However, if you want to enforce that\nthere are no interfaces outside of the app/Interfaces directory, you could\nwrite some tests like this:\n\n    \n    \n    test('services namespace only includes classes') ->expect('App\\Services') ->toBeClasses(); test('interfaces namespace only contains interfaces') ->expect('App\\Interfaces') ->toBeInterfaces();\n\nNow, if there's an interface in the App\\Services namespace, the test will fail\nand must be fixed before merging the code into the main branch. As a result,\nit can help ensure that every developer uses the same approach.\n\n## Get started with architecture testing\n\nNow that we've learned about architecture testing and its benefits in your\nprojects, we'll learn how to install Pest and write our first architecture\ntests.\n\nYou'll need to install Pest in your Laravel project using Composer. You can do\nthis by running the following command in your project's root directory:\n\n    \n    \n    composer require pestphp/pest-plugin-laravel --dev\n\nPest should now be installed and ready to run.\n\nNext, we'll look at typical examples of architecture tests you might want to\nadd to your Laravel applications. We'll begin by creating a simple test that\nasserts that the App\\Models namespace contains only classes and that each\nclass extends the Illuminate\\Database\\Eloquent\\Model class.\n\nWhere you place your architecture tests is a personal preference, but I like\nto put mine in a tests/Architecture directory. Doing this allows me to keep my\narchitecture tests separate from my feature and unit tests. For our tests\ninside that directory to be detected and run, we'll need to update the\nphpunit.xml file to include it. We can do this by adding a new Architecture\ntestsuite to the <testsuites> section:\n\n    \n    \n    <testsuites> ... <testsuite name=\"Architecture\"> <directory>tests/Architecture</directory> </testsuite> </testsuites>\n\nIf you've not previously made any changes to the default phpunit.xml file that\nships with Laravel, this will result in the file looking something like this:\n\n    \n    \n    <?xml version=\"1.0\" encoding=\"UTF-8\"?> <phpunit xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:noNamespaceSchemaLocation=\"vendor/phpunit/phpunit/phpunit.xsd\" bootstrap=\"vendor/autoload.php\" colors=\"true\" > <testsuites> <testsuite name=\"Unit\"> <directory>tests/Unit</directory> </testsuite> <testsuite name=\"Feature\"> <directory>tests/Feature</directory> </testsuite> <testsuite name=\"Architecture\"> <directory>tests/Architecture</directory> </testsuite> </testsuites> <source> <include> <directory>app</directory> </include> </source> <php> <env name=\"APP_ENV\" value=\"testing\"/> <env name=\"BCRYPT_ROUNDS\" value=\"4\"/> <env name=\"CACHE_DRIVER\" value=\"array\"/> <env name=\"MAIL_MAILER\" value=\"array\"/> <env name=\"QUEUE_CONNECTION\" value=\"sync\"/> <env name=\"SESSION_DRIVER\" value=\"array\"/> <env name=\"TELESCOPE_ENABLED\" value=\"false\"/> </php> </phpunit>\n\nI like to structure my architecture tests in a way that's similar to my\napplication code's directory structure. By doing this, it makes it easier to\nfind the tests that are related to a particular part of the project. For\nexample, I place my architecture tests for models (found in app/Models) in a\ntests/Architecture/ModelsTest.php test file. I put my controller architecture\ntests (in app/Http/Controllers) in a\ntests/Architecture/Http/ControllersTest.php test file. And so on.\n\nSo we will create a tests/Architecture/ModelsTest.php file and add the\nfollowing code to it:\n\n    \n    \n    use Illuminate\\Database\\Eloquent\\Model; test('models extends base model') ->expect('App\\Models') ->toExtend(Model::class);\n\nWe can now run this test using the following command:\n\n    \n    \n    php artisan test\n\nIf you configured everything correctly, you should see an output like this\nwhen you run the test:\n\n    \n    \n    PASS Tests\\Architecture\\ModelsTest \u2713 models extends base model 0.06s Tests: 1 passed (2 assertions) Duration: 0.14s\n\nWe'll purposely break the tests to ensure your test is working correctly and\ndetecting any architectural issues. To do this, let's add an empty PHP class\nthat doesn't extend the Illuminate\\Database\\Eloquent\\Model class. The class\nmay look something like this:\n\n    \n    \n    namespace App\\Models; class UserService { }\n\nIf you re-run the tests, the tests should fail, and you will get an output\nthat looks like this:\n\n    \n    \n    FAIL Tests\\Architecture\\ModelsTest \u2a2f models extends base model 0.07s \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500---------------------------- FAILED Tests\\Architecture\\ModelsTest > models ArchExpectationFailedException Expecting 'app/Models/UserService.php' to extend 'Illuminate\\Database\\Eloquent\\Model'. at app/Models/UserService.php:5 1\u2595 <?php 2\u2595 3\u2595 namespace App\\Models; 4\u2595 \u279c 5\u2595 class UserService 6\u2595 { 7\u2595 8\u2595 } 9\u2595 1 app/Models/UserService.php:5 Tests: 1 failed (2 assertions) Duration: 0.18s\n\n## Common examples of architecture tests\n\nNow that we've looked at how to install Pest and write our first architecture\ntests let's look at some common examples of architecture tests you might want\nto add to your Laravel applications.\n\nHere are some of the common methods that you'll likely be using in your tests:\n\n  * toBeAbstract - Assert the classes in the given namespace are abstract (using the keyword abstract).\n  * toBeClasses - Assert the files in the given namespace are PHP classes.\n  * toBeEnums - Assert the files in the given namespace are PHP enums.\n  * toBeInterfaces - Assert the files in the given namespace are PHP interfaces.\n  * toBeTraits - Assert the files in the given namespace are PHP traits.\n  * toBeInvokable - Assert the classes in the given namespace are invokable (meaning they have an __invoke method).\n  * toBeFinal - Assert the classes in the given namespace are final (using the keyword final).\n  * toBeReadonly - Assert the classes in the given namespace are readonly (using the keyword readonly).\n  * toExtend - Assert the classes in the given namespace extend the given class.\n  * toImplement - Assert the classes in the given namespace implement the given interface.\n  * toHaveMethod - Assert the classes in the given namespace have the given method.\n  * toHavePrefix - Assert the classes in the given namespace start with the given string in their classnames.\n  * toHaveSuffix - Assert the classes in the given namespace end with the given string in their classnames.\n  * toUseStrictTypes - Assert the files in the given namespace use strict types (using the keywords declare(strict_types=1)).\n\nYou can check out the Pest documentation for a complete list of available\nassertions.\n\nNow, let's look at some common tests you may want to write. This is not an\nexhaustive list, but it should provide an insight into the different\nassertions you might want to use. You can also use these as a starting point\nfor your own tests and modify them to suit your needs.\n\n### Tests for commands\n\nYou may want to write a test for your Artisan commands to assert that the\nApp\\Console\\Commands namespace only contains valid command classes. To do\nthis, you may want to write a test like this:\n\n    \n    \n    declare(strict_types=1); use Illuminate\\Console\\Command; test('commands') ->expect('App\\Console\\Commands') ->toBeClasses() ->toUseStrictTypes() ->toExtend(Command::class) ->toHaveMethod('handle');\n\nIn this test, we're defining that we only expect classes in the\nApp\\Console\\Commands namespace. We're then asserting that each class uses\nstrict types (using declare(strict_types=1)), extends the\nIlluminate\\Console\\Command class, and has a handle method.\n\nIf we were to add any files in this namespace that don't meet these\nrequirements (such as adding a class that doesn't extend the\nIlluminate\\Console\\Command class), the test would fail.\n\nAre you using Sentry, Rollbar, Bugsnag, or Airbrake for your monitoring?\nHoneybadger includes error tracking with a whole suite of amazing monitoring\ntools \u2014 all for probably less than you're paying now. Discover why so many\ncompanies are switching to Honeybadger here.\n\nStart free trial\n\n### Tests for controllers\n\nYou may also want to write a test to assert that your controllers follow\nspecific standards. Let's take a look at an example test you could write, and\nthen we'll discuss what we're doing:\n\n    \n    \n    declare(strict_types=1); use Illuminate\\Routing\\Controller; test('controllers') ->expect('App\\Http\\Controllers') ->toBeClasses() ->toUseStrictTypes() ->toBeFinal() ->classes() ->toExtend(Controller::class);\n\nIn the test above, we assert that every PHP file in the App\\Http\\Controllers\nnamespace is a class. We then assert that each of the classes uses strict\ntypes (using declare(strict_types=1)) and are final (using the final keyword).\nFinally, we assert that each class extends the Illuminate\\Routing\\Controller\nclass.\n\nIf we were to add any other classes in this namespace that don't meet these\nrequirements (such as adding a class that doesn't extend the\nIlluminate\\Routing\\Controller class), the test would fail.\n\n### Tests for interfaces\n\nYou may also want to write a test to assert that your project's App\\Interfaces\nnamespace only contains interfaces. To do this, you may want to write a test\nlike this:\n\n    \n    \n    declare(strict_types=1); test('interfaces') ->expect('App\\Interfaces') ->toBeInterfaces();\n\nIf we were to add any files in this namespace that don't meet these\nrequirements (such as adding a class or trait), the test would fail.\n\n### Tests for global functions\n\nAs well as testing that PHP files follow specific standards, we can also test\nthat we don't use certain PHP global functions in our codebase. This can be a\nhandy way to ensure that we don't accidentally leave debugging statements\n(such as dd()) in the code, which could cause issues in production.\n\nYou may want to write a test like this:\n\n    \n    \n    declare(strict_types=1); test('globals') ->expect(['dd', 'ddd', 'die', 'dump', 'ray', 'sleep']) ->toBeUsedInNothing();\n\nIn the test above, we assert that the functions dd, ddd, die, dump, ray, and\nsleep aren't used anywhere in the application. If it finds one of them, the\ntest will fail.\n\nStop digging through chat logs to find the bug-fix someone mentioned last\nmonth. Honeybadger's built-in issue tracker keeps discussion central to each\nerror, so that if it pops up again you'll be able to pick up right where you\nleft off.\n\nStart free trial\n\n### Tests for jobs\n\nAnother helpful place you may want to write some architecture tests for is\nyour job classes. You may wish to assert that all of your job classes\nimplement the Illuminate\\Contracts\\Queue\\ShouldQueue interface and have a\nhandle method. To do this, you may want to write a test like this:\n\n    \n    \n    declare(strict_types=1); use Illuminate\\Contracts\\Queue\\ShouldQueue; test('jobs') ->expect('App\\Jobs') ->toBeClasses() ->toImplement(ShouldQueue::class) ->toHaveMethod('handle');\n\nIn the test above, we assert that the App\\Jobs namespace only includes classes\nthat implement the Illuminate\\Contracts\\Queue\\ShouldQueue interface and have a\nhandle method. If we were to add an invalid file (such as a class that didn't\nimplement the interface), the test would fail.\n\n### Tests for models\n\nLet's look at one of the modifiers that Pest allows us to use to make our\nassertions more specific. We'll take a look at the ignoring modifier.\n\nLet's imagine that we have an app/Models directory to demonstrate how we might\nuse the 'ignoring' modifier. Within this directory, we have a Traits directory\n(using the App\\Models\\Traits namespace). Imagine that this directory contains\ntraits used by our models and nowhere else in the codebase.\n\nWe may want to write three tests that look like this:\n\n    \n    \n    test('models') ->expect('App\\Models') ->toBeClasses() ->ignoring('App\\Models\\Traits'); test('models extends base model') ->expect('App\\Models') ->toExtend(Model::class) ->ignoring('App\\Models\\Traits'); test('model traits') ->expect('App\\Models\\Traits') ->toBeTraits() ->toOnlyBeUsedIn('App\\Models');\n\nIn the first test (named models), we assert that every PHP file within the\nApp\\Models namespace is a class. We then use the ignoring modifier to ignore\nthe App\\Models\\Traits namespace. That means that this test will ignore any\nfiles in this namespace.\n\nIn the second test (named models extends base model), we're asserting that\nevery class (except those in the App\\Models\\Traits namespace) extends the\nIlluminate\\Database\\Eloquent\\Model class, thus making it a valid model class.\n\nFinally, in the third test (named model traits), we assert that every PHP file\nwithin the App\\Models\\Traits namespace is a trait. We then assert that the\ntraits found in this namespace do not live outside of the App\\Models\nnamespace. This means that the test would fail if we used any of these traits\nin another part of the application (such as in a controller).\n\n## Conclusion\n\nIn this article, we've learned about what architecture testing is and the\nbenefits of using it. We've also looked at how to write architecture tests for\nour Laravel applications using the popular PHP testing framework, Pest.\n\nYou're now ready to start writing architecture tests for your Laravel\napplications.\n\nWhat to do next:\n\n  1. Try Honeybadger for FREE\n\nHoneybadger helps you find and fix errors before your users can even report\nthem. Get set up in minutes and check monitoring off your to-do list.\n\nStart free trial\n\nEasy 5-minute setup \u2014 No credit card required\n\n  2. Get the Honeybadger newsletter\n\nEach month we share news, best practices, and stories from the DevOps &\nmonitoring community\u2014exclusively for developers like you.\n\n#### Ashley Allen\n\nAshley is a freelance Laravel web developer who loves contributing to open-\nsource projects and building exciting systems to help businesses succeed.\n\n  * @AshAllenDesign Author Twitter\n\nMore articles by Ashley Allen\n\n## More PHP articles\n\n  * Mar 29, 2024 Working with DynamoDB in Laravel\n  * Mar 26, 2024 A comprehensive guide to PHP file operations\n  * Feb 13, 2024 Deploying serverless applications with Laravel Vapor\n  * Jan 23, 2024 Processes and Artisan commands in Laravel\n  * Nov 27, 2023 Securing Laravel forms using Cloudflare's Turnstile CAPTCHA\n  * Nov 13, 2023 A comprehensive guide to handling dates and times in PHP\n  * Nov 08, 2023 Declaring check-ins in PHP/Laravel config\n  * Oct 23, 2023 Using Markdown in Laravel\n  * Oct 02, 2023 A guide to feature flags in Laravel using Laravel Pennant\n  * Sep 07, 2023 A guide to soft deletes in Laravel\n\nStop wasting time manually checking logs for errors!\n\nTry the only application health monitoring tool that allows you to track\napplication errors, uptime, and cron jobs in one simple platform.\n\n  * Know when critical errors occur, and which customers are affected.\n  * Respond instantly when your systems go down.\n  * Improve the health of your systems over time.\n  * Fix problems before your customers can report them!\n\nAs developers ourselves, we hated wasting time tracking down errors\u2014so we\nbuilt the system we always wanted.\n\nHoneybadger tracks everything you need and nothing you don't, creating one\nsimple solution to keep your application running and error free so you can do\nwhat you do best\u2014release new code. Try it free and see for yourself.\n\nStart free trial\n\nSimple 5-minute setup \u2014 No credit card required\n\nLearn more\n\n\"We've looked at a lot of error management systems. Honeybadger is head and\nshoulders above the rest and somehow gets better with every new release.\" \u2014\nMichael Smith, Cofounder & CTO of YvesBlue\n\nHoneybadger is trusted by top companies like:\n\n\u201cEveryone is in love with Honeybadger ... the UI is spot on.\u201d\n\nMolly Struve, Sr. Site Reliability Engineer, Netflix\n\nStart free trial\n\nAre you using Sentry, Rollbar, Bugsnag, or Airbrake for your monitoring?\nHoneybadger includes error tracking with a whole suite of amazing monitoring\ntools \u2014 all for probably less than you're paying now. Discover why so many\ncompanies are switching to Honeybadger here.\n\nStart free trial\n\nStop digging through chat logs to find the bug-fix someone mentioned last\nmonth. Honeybadger's built-in issue tracker keeps discussion central to each\nerror, so that if it pops up again you'll be able to pick up right where you\nleft off.\n\nStart free trial\n\n\u201cWow \u2014 Customers are blown away that I email them so quickly after an error.\u201d\n\nChris Patton, Founder of Punchpass.com\n\nStart free trial\n\nProduct\n\nStacks\n\nCompany\n\nResources\n\n", "frontpage": false}
