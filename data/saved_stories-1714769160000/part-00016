{"aid": "40248021", "title": "MUDLink: A Modular UART Duplex Link", "url": "https://ekswhyzee.com/2024/03/09/mudlink.html", "domain": "ekswhyzee.com", "votes": 2, "user": "zdw", "posted_at": "2024-05-03 14:24:02", "comments": 0, "source_title": "Jake Robert Read", "source_text": "MUDLink: a Modular UART Duplex Link - Jake Robert Read\n\n# Jake Robert Read\n\nLog Machine Systems Stray Projects About RSS\n\n# MUDLink: a Modular UART Duplex Link\n\nMar 9, 2024\n\n### MUDLink on GitHub / Arduino\n\nI built a new library for Arduino that lets us promote any Serial port (UART)\ninto a competent link / transport layer with guaranteed delivery of framed\npackets.\n\n> MUDLink adds packet framing, delivery guarantees, and flow control to just\n> about any UART Port. It also records stats on the link\u2019s performance, to\n> enable a litle bit of feedback systems assembly.\n\nI have wanted to release something like this for a while since just about\nevery microcontroller has at least one UART port, and they are well understood\nin the OSHW community - making them a good candidate for link layers that\ncould help to enable a commons of interoperable hardware. In order to get from\nUART to Reliable Link Layer, though, we need to add a few things:\n\n### Packet Framing\n\nUARTs send bytes only, and have no native packet delineation as is the case in\ni.e. I2C, CANBus etc: this makes it difficult to frame and decode efficient\nbytecodes of any real complexity.\n\n### Bit and Byte Errors\n\nUARTs are not fault tolerant: each microcontroller simply sends bytes at\nwhatever configured baudrate, and recieves at the same. If bytes are lost or\nbits are flipped, but programmers don\u2019t anticipate or catch these errors,\nthings can go wrong. This means that folks are left either with unreliable\nsystems (throwing intermittent errors, the worst kind!), or are left re-\nbuilding fault tolerance when they might rather be finishing the interesting\nparts of their project.\n\n### Flow Control and Feedback\n\nSince UARTs are mostly used with only TX and RX lines (no CTS/RTS etc), they\nare not normally flow controlled. This can be troublesome in applications\nwhere i.e. one participant can write significantly faster than the other can\nread (leading to lost bytes).\n\nIt can also be difficult to tell what an appropriate baudrate is: lower rates\nare typically less prone to errors, but that stability comes at an obvious\nperformance loss. In some cases, we pick what seems like a stable baudrate\nonly to change our environment slightly, and find that it is actually quite\nerror prone... for example we might turn on a high-power motor (injecting a\nlot of noise) and have our comms break down.\n\nThese kinds of phenomena typically means that (as is the case in much systems\nassembly), we end up using lower performance parameters than we might be able\nto, i.e. opting for baudrates that never fail, even though they may be up to\none quarter the speed fo baudrates that fail only very occasionally.\n\n# Enter MUDLink, a Useful UART Link\n\nSo, the MUDLink is a software bolt-on that effectively promotes any Arduino-\nexposed Serial object from a PHY (layer one of the OSI model) into a simple\nTransport layer (although it roughly eschews Layer 3: since it only sends\ndatagrams between two devices, there is no addressing or routing... it also\nmisses segmentation which is meant to live in Layer 4).\n\nLonger discussion on any resemblance to the OSI model is mostly useless\nanyways, as many have stated (most recently, Nathan made this point in his\nMachine Class lecture) it is a good common understanding or theory of how we\nmight delayer networks, but is rarely followed carefully in practice.\n\n> In simple terms, MUDLink lets you quickly establish a packetized, reliable\n> and inspectable connection between two microcontrollers.\n\n## Packet Framing with COBS\n\nFirstly, we need to make streams of bytes into chunked packets. This is like\nnetworking 101: if we don\u2019t know where any given byte goes w/r/t any other\nbyte, we can\u2019t reliably do much (unless each of our messages is just one byte\nlong).\n\n> From the Wiki Page on COBS: COBS transforms an arbitrary string of bytes in\n> the range [0,255] into bytes in the range [1,255]. Having eliminated all\n> zero bytes from the data, a zero byte can now be used to unambiguously mark\n> the end of the transformed data.\n\nCOBS is Consistent Overhead Byte Stuffing and is already in most embedded\ndevelopers\u2019 toolbox. It has the excellent property that it requires only two\nextra bytes of transmitted data for any packet smaller than 254 bytes (and\nonly one more byte per chunk of 255 thereafter) - and requires those bytes\nconsistently, meaning that we can have more deterministic systems.\n\nCOBS is also simple and fast: about 64 lines of c code (with comments).\nMUDLink deploys the wikipedia page\u2019s implementation directly (unfortunately I\nwouldn\u2019t be able to tell you who wrote that, though - thanks to them!).\n\n## Error Catching with CRC16-CCITT\n\nOnce we have rx\u2019d a sequence of bytes, we need to check that they are valid,\nsince things may have gone awry while they were en route (flipped bits due to\nnoise or missed bytes due to slow interrupts being the most common culprits).\n\nFor this, MUDLink uses a Cyclic Redundancy Check, particularely the\nCRC16-CCITT polynomial. For a really well done explainer on CRCs, check out\nBen Eater\u2019s video on the topic.\n\nA CRC is like a really fancy checksum: we use a carefully selected function\nthat takes our packet (as a big number) and generates a smaller number that is\nguaranteed to change if some changes to the packet occur - for example the\nCRC16-CCITT sis guaranteed to change if there is a change to a single bit\nwithin a packet of 8000 bytes - so, pretty good. It\u2019s kindof like a hashing\nfunction but different in important ways. Real big brain math stuff going on\nin there. I would like to point out that I understand the topic only\nglancingly, and you should refer to others for more detailed and correct\nexplainers (i.e. Ben Eater above).\n\nCRCs are additionally designed to be quickly implemented: in theory they are\nbasically big long divisions but in practice they are calculated using bitwise\nXOR operations and bit-shifts.\n\n## Flow Control and Delivery Guarantees\n\nSo! We can catch packets and make sure they are legit. Now we want the real\nmagic: we want to know from our end (1) that our packet was successfully\nreceived and (2) that it has been consumed by our partner, so that they are\nclear and free to recieve the next message. We accomplish these goals together\nwith an ack-and-retransmit scheme not dissimilar from TCP itself, which is\nagain explained really well by Ben Eater.\n\n> The MUDLink code is essentially four tiny state machines that signal one\n> another, which I\u2019ve tried to represent here. The left side is application\n> facing states and actions: the programmer can tell if the port is open (not\n> in a failed state), and if it is clear to send or clear to read a packet. On\n> the right side we have, basically, hardware buffers. These send data out\n> into the world and are responsible for catching it. Either side can generate\n> and consume events from the others: for example when we finish RX\u2019ing a\n> packet that passes the CRC, it sets the user-facing CTR state. When they\n> finally read the packet, the CTR state transitions to EMPTY, and an ACK is\n> generated and written into the TX buffer. Keeping a clear separation of\n> these layers normally helps us separate ISR\u2019s from user code, but in this\n> case it just helps clarify the system operation.\n\nTCP is a lot more complex than this (MUDLink is only 350 lines of code as of\nthis post), but they use similar principles:\n\n  * We keep a rolling sequence number that increments when we generate a new message.\n\n    * We always transmit our most recent segment number, as well as the sequence number of the packet we have most recently read from our partner (as an ack).\n  * When we transmit a message, we wait until we have recevied an ack from our partner before we transmit any new data.\n\n    * We may, however, retransmit the same message if our timeout for that runs out.\n    * After each timeout, we increase the timeout interval exponentially.\n    * When we have retried the packet a number of times, we enter a failure state.\n  * When we recieve a new packet, we present the data to the application by setting Clear To Read (CTR) high. We generate an ack for our partner only when the user has consumed that data.\n  * When we recieve a re-transmitted packet (that we have already successfully caught and read) we generate a new ACK, because the sender likely missed the previous one (hence their attempt to retransmit).\n  * Finally, we run a keepalive timer: if we haven\u2019t transmitted anything in some interval, we ping our partner to make sure they know we\u2019re still open. Similarely, if we don\u2019t hear anything for a while, we consider the port to be closed.\n\n## Statistics Tracking\n\nSo, I had mentioned that it\u2019s often difficult to measure what\u2019s going on in\nour networks, which makes it difficult to design systems. It turns out this is\na bona-fide problem in industry, and especially in safety critical systems:\ngreat engineering bookeeping efforts are expended making sure that there will\nalways be enough network bandwidth available in, for example, a 747\u2019s avionics\nsystem.\n\nIn OSHW, which currently builds more ad-hoc projects, we rarely take on that\nlevel of bookkeeping, so we are left in the relative dark about how much\nbandwidth we are using in our networks, how fast they are really running, etc.\n\nMUDLink adds a little to ameliorate this in that it tracks some stats, we have\nthese (self describing) available:\n\n    \n    \n    typedef struct MUDLStats { uint32_t rxSuccessCount = 0; uint32_t rxFailureCount = 0; uint32_t txSuccessCount = 0; uint32_t txFailureCount = 0; uint32_t txTotalRetries = 0; // the longest timeout issued since startup uint32_t outgoingTimeoutLengthHighWaterMark = 0; // maybe the most important, average message trip time, float averageTotalTransmitTime = 0.0F; // comparable to the wire time (bits / baudrate) for most msgs float averageWireTime = 0.0F; // and the num of tx retries normally required float averageRetryCount = 0.0F; } MUDLStats;\n\nThese are available to the programmer, to assess their choice of baudrate,\nquality of underlying link, etc.\n\n## API and Protocol\n\nMUDLink ingests any Serial instance within the Arduino ecosystem, meaning it\ncan be deployed in just about any Arduino project. We instantiate it using a a\ntemplate like this:\n\n    \n    \n    // 2nd argument is the baudrate MUDL_Link<decltype(Serial1)> mudl(&Serial1, 2000000);\n\nIt has a pretty simple API, we can check if the link is clear to send or clear\nto read, and we can send and read packets.\n\n    \n    \n    uint8_t appRx[255]; uint8_t appTx[255]; void loop(void){ // MUDLink runs on an event loop, mudl.loop(); // check-then-read, if(mudl.clearToRead()){ mudl.read(appRx, 255); } // presuming we have stuffd appTx with a message: if(mudl.clearToSend()){ mudl.send(appTx, msgLen); } // and we can get those stats, MUDLStats stats = mudl.getStats(); }\n\nThe message spec is pretty simple as well, beneath our COBS encoded packets we\nhave this block:\n\nBytes 0 ... N-5| Byte Len-4| Byte Len-3| Byte Len-2| Byte Len-1  \n---|---|---|---|---  \n... Payload| ACKD_SEQ| TXD_SEQ| CRC:1| CRC:2  \n  \nSo, pretty small overhead, and the payload is simply missing when we send ack-\nonly or keepalive messages.\n\n## System Limits, Future Work, and What I Learned While I Did It\n\nMUDL has a pretty clear limit to performance, which is that it has an overhead\nfloor of 2x: we will always use roughly half (or less) of the available\nbandwidth in a duplex link, because we are always waiting for our partner\u2019s\nack before we can send another. So, on a scope (with TX and RX lines tapped)\nwe see this kind of pattern:\n\nThis is ameliorated in grown-up protocols with transmission windows - each\nannounces how long their receive buffer is, and then we can transmit as many\nmessages as are in the buffer before receiving an ack. TCP does this, and\nhopefully MUDL will in the future... I have written that protocol out before,\nbut it was a little shaky. Then again, it didn\u2019t have CRC at that time, so I\nshould bring my new learning back to that project.\n\nMUDL is also limited by the underlying performance of whichever block of\nArduino Core code is running the Serial implementation. In this case I was\nusing Earle the III\u2019d RP2040 Core, which is wonderful (thanks Earle!), but\nwhich doesn\u2019t seem to service the actual transmit interrupt fast enough. So,\nif we send 1MBaud of 0b01010101 we see this:\n\nBut if we config at 3MBaud:\n\nSo - what\u2019s up? Well, we are transmitting at a speedy baudrate, but every time\nthe RP2040\u2019s TX FIFO dries up, it takes too long to refill (hence the inter-\nbyte gap). Since a 3MBaud Byte (10 bits for UART framing) is only 3.3\nmicroseconds long (at 200MHz, 660 clock cycles), we can run out of ISR time if\nwe don\u2019t write tight enough code. In practice, this means that while the\nRP2040 can run a UART up to 3MBaud, we only ever effectively see about 1MBaud\nof real performance.\n\nThis kind of thing is why the pros use DMA, etc, and why I am thinking I aught\nto return to that practice. With DMA, our app writes a big TX buffer, and then\neach byte is ferried into the UART without the processor\u2019s intervention at all\n- normally triggering an interrupt when the transmit is totally complete.\n\nHigh-speed hardo embedded code trades off with portability though, of course.\nFor now, I like the flexible, code-only transport / link layer as it is, but I\ncan look forward to writing custom implementations for some of my favourite\nmicrocontrollers. One of the nice things of this scheme is that we can have a\nsloppy implementation still pair up with a high-speed implementation, and\neverything should still work.\n\n## Odds and Ends\n\nOne other thing I learned during this cycle is that the Arduino I2C library is\nblocking - so when we use these OLED displays (see the first picture here),\nwhich require a big chunk of data in the screenbuffer, we can get big blocking\ncalls in our Arduino code. In the pictured demo, the display write is over\n20ms.\n\nThis could also be ameliorated by some hardo embedded code, but it\u2019s actually\nbeen a good foil: MUDLink works despite the blocking call that hampers\nperformance servicing the transmit routine and also causes packets to be\nentirely missed (when the blocking call happens during a packet receive and we\ncan\u2019t run our loop, we miss bytes!).\n\n## What about Busses !\n\nOne last note is that I\u2019ve come up with a pinout that suits this protocol\n(over RS485) as well as a bus topology. I would love in future times to build\nthe protocol to service point-to-point as well as bus topologies, perhaps\ndynamically switching between the two.\n\nLast trick to add would be dynamic baudrate scaling, to make these ports truly\nplug and play across devices and without any config.\n\nPrevious Feb 9, 2024 \u00ab Delete Your '\\n' Delimited Firmware Interface!\n\n\u00a9 Jake Read 2024 | github.com/jakeread\n\nsite design: paper\n\n", "frontpage": false}
