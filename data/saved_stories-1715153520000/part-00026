{"aid": "40291525", "title": "Authenticate Your Git Checkouts", "url": "https://guix.gnu.org/en/blog/2024/authenticate-your-git-checkouts/", "domain": "guix.gnu.org", "votes": 2, "user": "mgd", "posted_at": "2024-05-07 21:10:15", "comments": 0, "source_title": "Guix", "source_text": "Authenticate your Git checkouts! \u2014 2024 \u2014 Blog \u2014 GNU Guix\n\n# Guix\n\n## Authenticate your Git checkouts!\n\nLudovic Court\u00e8s \u2014 May 7, 2024\n\nYou clone a Git repository, then pull from it. How can you tell its contents\nare \u201cauthentic\u201d\u2014i.e., coming from the \u201cgenuine\u201d project you think you\u2019re\npulling from, written by the fine human beings you\u2019ve been working with? With\ncommit signatures and \u201cverified\u201d badges \u2705 flourishing, you\u2019d think this has\nlong been solved\u2014but nope!\n\nFour years after Guix deployed its own tool to allow users to authenticate\nupdates fetched with guix pull (which uses Git under the hood), the situation\nhasn\u2019t changed all that much: the vast majority of developers using Git simply\ndo not authenticate the code they pull. That\u2019s pretty bad. It\u2019s the modern-day\nequivalent of sharing unsigned tarballs and packages like we\u2019d blissfully do\nin the past century.\n\nThe authentication mechanism Guix uses for channels is available to any Git\nuser through the guix git authenticate command. This post is a guide for Git\nusers who are not necessarily Guix users but are interested in using this\ncommand for their own repositories. Before looking into the command-line\ninterface and how we improved it to make it more convenient, let\u2019s dispel any\nmisunderstandings or misconceptions.\n\n# Why you should care\n\nWhen you run git pull, you\u2019re fetching a bunch of commits from a server. If\nit\u2019s over HTTPS, you\u2019re authenticating the server itself, which is nice, but\nthat does not tell you who the code actually comes from\u2014the server might be\ncompromised and an attacker pushed code to the repository. Not helpful. At\nall.\n\nBut hey, maybe you think you\u2019re good because everyone on your project is\nsigning commits and tags, and because you\u2019re disciplined, you routinely run\ngit log --show-signature and check those \u201cGood signature\u201d GPG messages. Maybe\nyou even have those fancy \u201c\u2705 verified\u201d badges as found on GitLab and on\nGitHub.\n\nSigning commits is part of the solution, but it\u2019s not enough to authenticate a\nset of commits that you pull; all it shows is that, well, those commits are\nsigned. Badges aren\u2019t much better: the presence of a \u201cverified\u201d badge only\nshows that the commit is signed by the OpenPGP key currently registered for\nthe corresponding GitLab/GitHub account. It\u2019s another source of lock-in and\nmakes the hosting platform a trusted third-party. Worse, there\u2019s no notion of\nauthorization (which keys are authorized), let alone tracking of the history\nof authorization changes (which keys were authorized at the time a given\ncommit was made). Not helpful either.\n\nBeing able to ensure that when you run git pull, you\u2019re getting code that\ngenuinely comes from authorized developers of the project is basic security\nhygiene. Obviously it cannot protect against efforts to infiltrate a project\nto eventually get commit access and insert malicious code\u2014the kind of multi-\nyear plot that led to the xz backdoor\u2014but if you don\u2019t even protect against\nunauthorized commits, then all bets are off.\n\nAuthentication is something we naturally expect from apt update, pip, guix\npull, and similar tools; why not treat git pull to the same standard?\n\n# Initial setup\n\nThe guix git authenticate command authenticates Git checkouts, unsurprisingly.\nIt\u2019s currently part of Guix because that\u2019s where it was brought to life, but\nit can be used on any Git repository. This section focuses on how to use it;\nyou can learn about the motivation, its design, and its implementation in the\n2020 blog post, in the 2022 peer-reviewed academic paper entitled Building a\nSecure Software Supply Chain with GNU Guix, or in this 20mn presentation.\n\nTo support authentication of your repository with guix git authenticate, you\nneed to follow these steps:\n\n  1. Enable commit signing on your repo: git config commit.gpgSign true. (Git now supports other signing methods but here we need OpenPGP signatures.)\n\n  2. Create a keyring branch containing all the OpenPGP keys of all the committers, along these lines:\n    \n        git checkout --orphan keyring git reset --hard gpg --export alice@example.org > alice.key gpg --export bob@example.org > bob.key ... git add *.key git commit -m \"Add committer keys.\"\n\nAll the files must end in .key. You must never remove keys from that branch:\nkeys of users who left the project are necessary to authenticate past commits.\n\n  3. Back to the main branch, add a .guix-authorizations file, listing the OpenPGP keys of authorized committers\u2014we\u2019ll get back to its format below.\n\n  4. Commit! This becomes the introductory commit from which authentication can proceed. The introduction of your repository is the ID of this commit and the OpenPGP fingerprint of the key used to sign it.\n\nThat\u2019s it. From now on, anyone who clones the repository can authenticate it.\nThe first time, run:\n\n    \n    \n    guix git authenticate COMMIT SIGNER\n\n... where COMMIT is the commit ID of the introductory commit, and SIGNER is\nthe OpenPGP fingerprint of the key used to sign that commit (make sure to\nenclose it in double quotes if there are spaces!). As a repo maintainer, you\nmust advertise this introductory commit ID and fingerprint on a web page or in\na README file so others know what to pass to guix git authenticate.\n\nThe commit and signer are now recorded on the first run in .git/config; next\ntime, you can run it without any arguments:\n\n    \n    \n    guix git authenticate\n\nThe other new feature is that the first time you run it, the command installs\npre-push and pre-merge hooks (unless preexisting hooks are found) such that\nyour repository is automatically authenticated from there on every time you\nrun git pull or git push.\n\nguix git authenticate exits with a non-zero code and an error message when it\nstumbles upon a commit that lacks a signature, that is signed by a key not in\nthe keyring branch, or that is signed by a key not listed in .guix-\nauthorizations.\n\n# Maintaining the list of authorized committers\n\nThe .guix-authorizations file in the repository is central: it lists the\nOpenPGP fingerprints of authorized committers. Any commit that is not signed\nby a key listed in the .guix-authorizations file of its parent commit(s) is\nconsidered inauthentic\u2014and an error is reported. The format of .guix-\nauthorizations is based on S-expressions and looks like this:\n\n    \n    \n    ;; Example \u2018.guix-authorizations\u2019 file. (authorizations (version 0) ;current file format version ((\"AD17 A21E F8AE D8F1 CC02 DBD9 F8AE D8F1 765C 61E3\" (name \"alice\")) (\"2A39 3FFF 68F4 EF7A 3D29 12AF 68F4 EF7A 22FB B2D5\" (name \"bob\")) (\"CABB A931 C0FF EEC6 900D 0CFB 090B 1199 3D9A EBB5\" (name \"charlie\"))))\n\nThe name bits are hints and do not have any effect; what matters is the\nfingerprints that are listed. You can obtain them with GnuPG by running\ncommands like:\n\n    \n    \n    gpg --fingerprint charlie@example.org\n\nAt any time you can add or remove keys from .guix-authorizations and commit\nthe changes; those changes take effect for child commits. For example, if we\nadd Billie\u2019s fingerprint to the file in commit A, then Billie becomes an\nauthorized committer in descendants of commit A (we must make sure to add\nBillie\u2019s key as a file in the keyring branch, too, as we saw above); Billie is\nstill unauthorized in branches that lack A. If we remove Charlie\u2019s key from\nthe file in commit B, then Charlie is no longer an authorized committer,\nexcept in branches that start before B. This should feel rather natural.\n\nThat\u2019s pretty much all you need to know to get started! Check the manual for\nmore info.\n\nAll the information needed to authenticate the repository is contained in the\nrepository itself\u2014it does not depend on a forge or key server. That\u2019s a good\nproperty to allow anyone to authenticate it, to ensure determinism and\ntransparency, and to avoid lock-in.\n\n# Interested? You can help!\n\nguix git authenticate is a great tool that you can start using today so you\nand fellow co-workers can be sure you\u2019re getting the right code! It solves an\nimportant problem that, to my knowledge, hasn\u2019t really been addressed by any\nother tool.\n\nMaybe you\u2019re interested but don\u2019t feel like installing Guix \u201cjust\u201d for this\ntool. Maybe you\u2019re not into Scheme and Lisp and would rather use a tool\nwritten in your favorite language. Or maybe you think\u2014and rightfully so\u2014that\nsuch a tool ought to be part of Git proper.\n\nThat\u2019s OK, we can talk! We\u2019re open to discussing with folks who\u2019d like to come\nup with alternative implementations\u2014check out the articles mentioned above if\nyou\u2019d like to take that route. And we\u2019re open to contributing to a\nstandardization effort. Let\u2019s get in touch!\n\n# Acknowledgments\n\nThanks to Florian Pelz and Simon Tournier for their insightful comments on an\nearlier draft of this post.\n\nRelated topics:\n\nSecurity Software development\n\nUnless otherwise stated, blog posts on this site are copyrighted by their\nrespective authors and published under the terms of the CC-BY-SA 4.0 license\nand those of the GNU Free Documentation License (version 1.3 or later, with no\nInvariant Sections, no Front-Cover Texts, and no Back-Cover Texts).\n\nMade with \u2665 by humans and powered by GNU Guile. Source code under the GNU\nAGPL.\n\n", "frontpage": false}
