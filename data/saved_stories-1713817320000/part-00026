{"aid": "40114626", "title": "Untangling Spaghetti: Debugging Non-Terminating Object Programs (2009)", "url": "https://tidyfirst.substack.com/p/untangling-spaghetti-debugging-non", "domain": "tidyfirst.substack.com", "votes": 6, "user": "rbanffy", "posted_at": "2024-04-22 14:17:49", "comments": 0, "source_title": "Untangling Spaghetti: Debugging Non-Terminating Object Programs", "source_text": "Untangling Spaghetti: Debugging Non-Terminating Object Programs\n\n# Software Design: Tidy First?\n\nShare this post\n\n#### Untangling Spaghetti: Debugging Non-Terminating Object Programs\n\ntidyfirst.substack.com\n\n#### Discover more from Software Design: Tidy First?\n\nSoftware design is an exercise in human relationships. So are all the other\ntechniques we use to develop software. How can we geeks get better at\ntechnique as one way of getting better at relationships?\n\nOver 81,000 subscribers\n\nContinue reading\n\nSign in\n\nFrom the Archives\n\n# Untangling Spaghetti: Debugging Non-Terminating Object Programs\n\n### Make an understandable mess, fix the bug, then make it easier to\nunderstand\n\nKent Beck\n\nApr 22, 2024\n\n16\n\nShare this post\n\n#### Untangling Spaghetti: Debugging Non-Terminating Object Programs\n\ntidyfirst.substack.com\n\nShare\n\n> Originally posted February 2009. This is a level of deeply geeky geeking\n> about the tactics & philosophy of programming that I don\u2019t often cover these\n> days. I\u2019m not sure why not. More to come.\n\nSummary: To debug non-terminating object programs, successively inline the\nmethods on the stack until you have a self-referencing method. Seeing the\nproblem in a single method helps you identify the source of the problem and\nidentify possible fixes.\n\n##\n\nIntroduction\n\nI had fun today debugging an infinite loop. Some of the techniques we used\nbuild on things I've talked about recently so I thought I'd reflect on the\nexperience a bit. There's no happy ending to my story, though: the defect\nremained at the end of the session. Still, the techniques are worth thinking\nabout because infinite loops in object programs can be difficult to debug. I\nwish you better luck with yours.\n\n##\n\nInfinite Iteration\n\nThe classic infinite loop is simple enough:\n\nwhile (true);\n\nNothing in the body of the loop affects the termination condition. All\ninfinite iterations can, I think, be reduced to this construct, even if they\nhave a lot of stuff going on in the conditional and loop body that turns out\nto be irrelevant to loop termination. Eliminate the irrelevant details and\nyou're left with:\n\nwhile (true);.\n\nTo cure infinite iteration you need to figure out what needs to happen in the\nloop body that will affect the termination condition. Do you need a\nconditional break:\n\nif (shouldStop) break;\n\nDo you need to iterate a counter? Advance a pointer? Timeout? Change the loop\ntermination condition? You need to find something that will bring the\nproceedings to a close.\n\n##\n\nInfinite Recursion\n\nRecursion adds a wrinkle to non-terminating computations. Spotting an infinite\niteration only requres looking at a single stack frame. Spotting infinite\nrecursion requires looking at the whole stack. The reduced infinite recursion:\n\nfoo() { foo(); }\n\nresults in a repeating stack:\n\nfoo() foo() foo() ...\n\nThe cure for infinite recursion is figuring out under what conditions the\nrecursive call should not be made\n\n(if (stop) return; else foo();)\n\nIt can be a challenge to figure out this condition, but you still only have to\nexamine a single procedure to do so.\n\n#\n\nMutual Recursion\n\nMutual recursion makes the story more interesting still. What happens when you\nhave\n\nfoo() { bar(); } bar() { foo(); }\n\nis that you have a repeating stack, but with period 2 instead of 1:\n\nfoo() bar() foo() bar() ...\n\nRepairing infinite mutual recursion is harder than repairing simple recursion\nbecause you have more options. The problem could be in foo(), in bar(), or in\nthe relationships between the two. Which one needs fixing? At what point does\nthe computation have the information needed to forgo yet another call?\n\n#\n\nObject Recursion\n\nIn The Saff Squeeze [ed: need to revive this post next] I started to explore\nthe joys of inlining code. I have the sense that there is a lot more to\ninlining than I have figured out so far. Nearly every day I program I find a\nnew use for it, now that I'm paying attention. It is an excellent tool for\nexploring, understanding, and manipulating complicated control flows. I'm not\nready to write the Grand Unified Theory of Inlining yet, but responding to\nnon-terminating object programs turned out to be a good application of\ninlining. Here's how it works.\n\nSpotting infinite recursion is relatively easy in the case of a single\nprocedure:\n\nfoo() { foo(); }\n\nInlining transmutes the mutual recursion case into simple recursion. If I\ninline bar() from above I get foo() { foo(); }. The source of the infinite\nrecursion is clearer. Once the code is working I can always re-extract\nsubprocedures that communicate clearly.\n\nInlining in the service of debugging applies the \"make it run, make it right,\nmake it fast\" mantra in reverse. If my code doesn't run, making the design\nworse through inlining isn't a sin if it helps me fix the defect [ed:\n@jessitron calls this \u201cun-tidying\u201d]. The additional insight I gain from making\nthe code work in more cases often helps me further improve the design when the\ntime comes to \"make it right\" again.\n\nObjects make spotting non-terminating computations even more exciting (by\nwhich I mean \"tedious and frustrating\"). The periodicity of the stack can be\nlong and is complicated by the potential presence of many different classes\nand objects as well as methods:\n\nA.b() C.d() E.f() A.b() C.d() E.f() ...\n\nSometimes the instances of A, C, and E are the same objects every time through\nthe loop, sometimes they are different but somehow equivalent instances (at\nleast as far as loop termination is concerned). The longest cycle I've seen is\nsix frames long, which makes spotting the pattern tough. Fortunately, since\nthe computation is infinite you can easily make as many frames as you need to\nprovide yourself data for identifying the loop :-)\n\nWhen I've run out of stack space and spotted the cycle, how do I figure out\nthe problem? Since inlining is my trick du jour I suggest inlining. Inlining\nworks across objects just as well as it does across procedures, although you\nmay have to temporarily make fields and methods public to keep everything\nworking. (Always take a snapshot of the state of the code before starting one\nof these sessions--you'll likely make lots of ugly changes that become\nirrelevant once you figure out how to fix the problem. I say this because we\ndidn't take a snapshot...)\n\nWe picked the entry point of the infinite cycle and started inlining.\nEventually we got a method that looked like A.b() {...b();...}. We could see\nexactly why the cycle wasn't terminating. What still wasn't clear to us was\nwhat to do about it. Just seeing the cycle clearly seemed like progress,\nthough, and worth writing up.\n\nIn fixing a non-terminating object program you have a couple of options: break\nthe cycle or don't get into the cycle in the first place. For our code, I\nsuspect not getting into the cycle in the first place was the right idea, but\nwe didn't have time to explore this option once we'd identified the problem\nlogic.\n\n##\n\nConclusion\n\nOne of the things that struck me while we were working was the connection\nbetween inlining and partial evaluation. I wonder if revisiting the literature\non partial evaluation would provide further ideas for the applying inlining or\ntools for making inlining more effective.\n\nAnother point that struck me was how infrequently this situation occurs. Is it\neven worth thinking/writing/learning about non-terminating object programs if\nthey only happen to you once a year? I think the answer is \"yes\" (obviously,\nand I suppose if you've gotten this far you likely agree). Multi-object\ninfinite loops are a hard problem to solve. It seems like there is always some\nugly hack available to break the cycle, but one that is unlikely to satisfy\nfuture conditions. Having a clear plan for understanding infinite cycles gives\nme a chance to step back and really understand the situation and what should\nbe done about it, to design, not just make an expedient coding change. That is\nhow I aspire to work, and if exploring situations that happen infrequently is\nthe cost of thoughtful development, I'll pay it.\n\nIf you try this inlining technique to understand an infinite cycle, please let\nme know how it goes. Happy debugging. And designing.\n\n### Subscribe to Software Design: Tidy First?\n\nBy Kent Beck \u00b7 Thousands of paid subscribers\n\nSoftware design is an exercise in human relationships. So are all the other\ntechniques we use to develop software. How can we geeks get better at\ntechnique as one way of getting better at relationships?\n\n16 Likes\n\n16\n\nShare this post\n\n#### Untangling Spaghetti: Debugging Non-Terminating Object Programs\n\ntidyfirst.substack.com\n\nShare\n\nComments\n\n90% of My Skills Are Now Worth $0\n\n...but the other 10% are worth 1000x\n\nApr 19, 2023 \u2022\n\nKent Beck\n\n151\n\nShare this post\n\n#### 90% of My Skills Are Now Worth $0\n\ntidyfirst.substack.com\n\n48\n\nMastering Programming\n\nFEBRUARY 5, 2016 \u00b7 FACEBOOK This was one of those posts that I threw together,\nthought nothing of, & then it blew up. Until recently this was my...\n\nFeb 9 \u2022\n\nKent Beck\n\n294\n\nShare this post\n\n#### Mastering Programming\n\ntidyfirst.substack.com\n\n3\n\nMeasuring developer productivity? A response to McKinsey\n\nPart 1 of 2\n\nAug 29, 2023 \u2022\n\nKent Beck\n\nand\n\nGergely Orosz\n\n281\n\nShare this post\n\n#### Measuring developer productivity? A response to McKinsey\n\ntidyfirst.substack.com\n\n47\n\nReady for more?\n\n\u00a9 2024 Kent Beck\n\nPrivacy \u2219 Terms \u2219 Collection notice\n\nStart WritingGet the app\n\nSubstack is the home for great culture\n\nShare\n\n## Create your profile\n\n## Only paid subscribers can comment on this post\n\nAlready a paid subscriber? Sign in\n\n#### Check your email\n\nFor your security, we need to re-authenticate you.\n\nClick the link we sent to , or click here to sign in.\n\n", "frontpage": true}
