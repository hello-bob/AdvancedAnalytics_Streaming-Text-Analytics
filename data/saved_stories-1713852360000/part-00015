{"aid": "40119961", "title": "Using calculated attributes to help users surface delivery risks", "url": "https://www.aha.io/engineering/articles/virtual-attributes", "domain": "aha.io", "votes": 5, "user": "FigurativeVoid", "posted_at": "2024-04-22 20:37:01", "comments": 2, "source_title": "Using calculated attributes to help users surface delivery risks | Aha! software", "source_text": "Using calculated attributes to help users surface delivery risks | Aha! software\n\n  * Articles\n  * Culture\n  * Careers\n\nAha! Develop is for healthy enterprise development teams \u2014 that use scrum,\nkanban, and SAFe frameworks\n\nLearn more\n\n2024-04-08\n\n# Using calculated attributes to help users surface delivery risks\n\nby Michel Shiel\n\nFeature delivery can be impacted by many factors. Some are readily visible,\nbut others are more nuanced \u2014 or buried in mountains of data.\n\nWhat if we could show developers and project managers the factors that would\naffect feature delivery in real time? And what if that information were part\nof the record itself? (So anyone looking at or running a report could see what\nto keep in mind to ensure the team's delivery stays on track.)\n\n## What are delivery risks?\n\nWe refer to these individual risk factors as delivery risks in Aha! software.\nDuring the design phase of this feature, we built up a list of the factors we\nfelt were most important to ensuring reliable delivery. These were based on\ncustomer feedback as well as our own internal experience.\n\nSome of the delivery risks we identified were:\n\n  * Not having a team assigned to a work item\n  * Dependencies not being started, and at least one linked record not having an In progress workflow status\n  * Workflow status not changing for a specific number of days\n\nAdditionally, you can customize which delivery risks are enabled on a per-\nworkspace level as well as fine-tune some of the values used in calculating\nwhether or not the risk is active (e.g., how many days is \"late\" to my team?).\n\n## Deciding on an approach\n\nWith our risks defined, we needed to figure out an approach for surfacing them\nto the user in a real-time and efficient manner. We knew we wanted to have\ndelivery risks visible in our record drawers for visibility. We also wanted\nthem to be in reports, which could mean large amounts of data and computation\nfor the more complex risk factors.\n\n### Data representation\n\nLet's start with a simple delivery risk: No team assigned. The data required\nto make the decision about whether this risk factor is active or not lives\nwith the record itself, so it's \"free\" to load and wouldn't need to be stored.\nLuckily for us, a majority of the delivery risks we identified fall into this\ncategory. They are trivial to implement and virtually free to load or\ncalculate.\n\n#### Complex risk factors\n\nFor a more complex risk factor, let's take a look at the Work stalled delivery\nrisk. Here, we're concerned with a fixed relationship structure within Aha! as\nwell as in epics, features, and requirements. Epics have features, and\nfeatures have requirements. We define the work as stalled when:\n\n  * The record's own workflow status hasn't changed in N days (unless it has child records in progress, in which case ... )\n  * Any of its child records that are in progress have workflow statuses that haven't changed in a specific number of days\n\nThese bubble up to their parent records. For example, an epic might be stalled\nbecause it has a feature that has a requirement whose status hasn't changed\nrecently.\n\n### The bottom-up approach\n\nThe approach that first sprung to mind was attempting to do the calculations\nat the point or event where the data changes. We could check for any parent\nrecords whenever our status changes and do the necessary work at that point in\ntime. That could work for some of our risk factor definitions. But the catch\nwe saw with Work stalled was that being time-based, it can become a risk\nwithout any changes in the underlying data.\n\nOne way we thought about solving this was by having some job scheduled to run\non a periodic frequency, let's say overnight or hourly. The downside to that\nis you're compromising to some degree on the real-time aspect. I have to wait\nfor this job to run to see the risk \u2014 that's not something I want to think\nabout as a user. We'd also be concentrating a large amount of work at one\npoint in time (for every record, check all of its children's statuses, and so\non). And that's just for this one risk factor.\n\n### The top-down approach\n\nWhat if we instead flipped the problem on its head, taking the perspective of\nlooking \"down\" from the place where we want to see the output of the risk\nfactor? That leads us to calculating each risk factor every time the record\nloads or the report runs. This definitely gives us the real-time\nresponsiveness we're looking for \u2014 but does come with some valid performance\nconcerns.\n\n## Generated columns and triggers\n\nWe use PostgreSQL as our database, and it comes with an amazing feature that\nallows you to define generated columns. Unfortunately for us, there was a\ncatch here: Some of the delivery risks we wanted to define have dependencies\non other records (e.g., other tables), and a generated column can only refer\nto the current row.\n\nAnother database-centric approach could be to leverage triggers to recalculate\na given risk factor whenever the record changes. However, this solution does\nnot allow recalculating based purely on time and without some kind of\nscheduled job.\n\n### Equations\n\nAha! already has a framework for calculating fields from equations and other\ndata in our reporting system. This was a promising avenue at first: The system\nautomatically tracks dependent records based on the formula used and only\nupdates when they change. Unfortunately, we also ended up ruling out this\napproach \u2014 the equation system has no concept of variables outside of the data\nitself, such as the current date or time. Because this system is driven purely\nby changes within other fields, having updates based on time would mean\nintroducing some kind of scheduling component to run on arbitrary granularity.\nThis would add additional complexity and computational overhead.\n\n### Our solution: Virtual attributes\n\nAha! has a calculated_attributes gem that we wrote and open-sourced to solve\nsimilar issues. And as a bonus, we already have it in place on many of our\nmodels. It works by patching ActiveRecord to include custom SQL statements as\npart of the normal model query process. By using the calculated(:calculated,\n:fields, :here) method on a relation, the fields would automatically be\nexecuted and added into the model data when it was loaded.\n\nPrior to this work, we were mostly using it for counts or relatively simple\ncalculations. But because it's driven by plain old SQL statements, there was\nno reason we couldn't use it to execute more complex queries.\n\nSome quick prototyping on the simpler fields showed promising results right\naway:\n\n    \n    \n    calculated :no_team, -> { arel_table[:team_id].eq(nil) } calculated ... def risk_factors slice(:no_team, ...) end\n\nThis would allow us to write arbitrary SQL to define all of the desired\ndelivery risks.\n\n#### Query complexity and performance\n\nCalculating all of these fields every time the record loads would inherently\nmake those queries more complex, so we set out to establish a baseline and see\njust how much more complex they would get. The queries below are simplified\nand only include risk factors related to a lack of assignee and scheduling.\n\nHere is loading one feature without risks:\n\n    \n    \n    SELECT \"features\".\"id\", ... FROM \"features\" LIMIT 1;\n\nAnd here is loading one feature, including the two risk factors mentioned\nabove:\n\n    \n    \n    SELECT \"features\".\"id\", ..., ( \"rf_features_prc\".\"no_assignee\" = TRUE AND \"features\".\"assigned_to_user_id\" IS NULL AND ( SELECT TRUE FROM workflow_statuses ws WHERE ws.id = features.workflow_status_id AND coalesce(ws.internal_meaning, 0) < 20 ) ) AS no_assignee, ( \"rf_features_prc\".\"not_scheduled\" = TRUE AND \"features\".\"start_date\" IS NULL AND \"features\".\"due_date\" IS NULL ... ) AS not_scheduled FROM \"features\" LEFT JOIN projects rf_features_projects ON rf_features_projects.id = features.project_id ... LIMIT 1;\n\nLet's say we've added two subselects and a few joins. This seems reasonable\nlooking at just the SQL, but let's also take a look at the query plans for\nthese to get deeper insights.\n\nFirst, here is the regular feature load:\n\n    \n    \n    Limit (cost=0.05..0.16 rows=1 width=279) (actual time=0.021..0.021 rows=1 loops=1) -> Seq Scan on features (cost=0.05..1001.00 rows=9003 width=279) (actual time=0.020..0.020 rows=1 loops=1) Filter: (project_id = ANY ('{...}'::bigint[])) Planning Time: 0.217 ms Execution Time: 0.052 ms (5 rows)\n\nThat's about as simple as it gets for a query. But what about including the\ncalculated risk factors?\n\n    \n    \n    Limit (cost=0.34..17.51 rows=1 width=281) (actual time=0.079..0.081 rows=1 loops=1) -> Nested Loop Left Join (cost=0.34..154647.50 rows=9003 width=281) (actual time=0.079..0.080 rows=1 loops=1) -> Nested Loop Left Join (cost=0.20..3807.43 rows=9003 width=282) (actual time=0.050..0.051 rows=1 loops=1) Join Filter: (rf_features_rr.riskable_id = features.id) Rows Removed by Join Filter: 8 -> Nested Loop Left Join (cost=0.20..2455.79 rows=9003 width=282) (actual time=0.034..0.034 rows=1 loops=1) -> Seq Scan on features (cost=0.05..1001.00 rows=9003 width=279) (actual time=0.026..0.026 rows=1 loops=1) Filter: (project_id = ANY ('{...}'::bigint[])) -> Index Scan using index_project_risks_configurations_on_project_id on project_risks_configurations rf_features_prc (cost=0.14..0.16 rows=1 width=11) (actual time=0.005..0.005 rows=1 loops=1) Index Cond: (project_id = features.project_id) Filter: enabled -> Materialize (cost=0.00..1.21 rows=10 width=8) (actual time=0.010..0.014 rows=9 loops=1) -> Seq Scan on record_risks rf_features_rr (cost=0.00..1.16 rows=10 width=8) (actual time=0.006..0.008 rows=9 loops=1) Filter: ((riskable_type)::text = 'Feature'::text) Rows Removed by Filter: 3 -> Index Scan using releases_pkey on releases rf_features_releases (cost=0.14..0.16 rows=1 width=9) (actual time=0.009..0.009 rows=1 loops=1) Index Cond: (id = features.release_id) SubPlan 1 -> Index Scan using workflow_statuses_pkey on workflow_statuses ws (cost=0.28..8.30 rows=1 width=1) (actual time=0.012..0.013 rows=1 loops=1) Index Cond: (id = features.workflow_status_id) Filter: (COALESCE(internal_meaning, 0) < 20) SubPlan 2 -> Index Scan using workflow_statuses_pkey on workflow_statuses ws_1 (cost=0.28..8.30 rows=1 width=1) (never executed) Index Cond: (id = features.workflow_status_id) Filter: (COALESCE(internal_meaning, 0) < 20) Planning Time: 1.554 ms Execution Time: 0.338 ms (27 rows)\n\nOK! We cranked up the complexity quite a bit there, but the execution time is\nstill well within reason (at least while running Postgres 14 on an M1 Pro\nlaptop). These experiments gave us the confidence to know that this was a\nviable approach \u2014 but that we should still be cautious about loading delivery\nrisks that are not strictly necessary.\n\n### When do risks load?\n\nThere are three places you can see delivery risks within Aha! software:\n\n  * In the drawer for a record (if the delivery risk item has been added to the layout)\n  * On the card for a record (if one of the delivery risk's fields has been added to the card layout)\n  * In a report (if you're filtering by delivery risk or if you've added a delivery risk column to the report)\n\nNotice that all of these places are conditional \u2014 they all have a component\nthat makes loading delivery risk information optional. We can use this to help\navoid paying the performance penalty when loading these views. Due to the way\nour drawer layouts are implemented, the data just naturally isn't loaded if\nthe delivery risks item isn't in the layout. So this would happen for free.\n\nSimilarly for the card data, when we're generating the query to load the data\nrequired to render the board, we have access to the card layout and can make\nthe decision on whether we need to include the risk factors or not.\n\nReporting is actually the most optimal case in that we have enough information\nto even know exactly which risk factors need to be loaded. When you select a\ndelivery risk in a filter or add a delivery risk column to the report, the SQL\nfor just that risk factor can be dynamically inserted into our query builder\nso performance is as optimal as possible.\n\n## The final implementation\n\nAfter reviewing the options available to us, the only solution that ticked all\nof our boxes was calculating the fields for each object as they load using the\ncalculated_attributes gem.\n\nWe were able to have proof of concepts for most of the other delivery risks\npretty quickly and started to abstract them into a concern and build a DSL to\nclean up their definitions.\n\nDefining a new risk is now as simple as calling risk_factor:\n\n    \n    \n    risk_factor :no_assignee, arel_table[:assigned_to_user_id].eq(nil) risk_factor :not_scheduled, arel_table[:start_date].eq(nil).and(arel_table[:due_date].eq(nil)), except: Requirement\n\nThe risk_factor method tracks the risk factors in an object\n(active_risk_factors) on the class, allowing us to build a pre-defined scope\nto handle calling calculated with all of the delivery risks automatically\npassed as a parameter:\n\n    \n    \n    scope :with_risk_factors, -> { HasRiskFactors.joins_for_class(klass).reduce(current_scope || self) do |acc, join| acc.joins(join) end.calculated(*active_risk_factors.keys) }\n\nNow, whenever we'd like to load a feature with the active risk factors, it's\nas simple as:\n\n    \n    \n    Feature.with_risk_factors.find(\"DEMO-123\").risk_factors => { :no_assignee => true, :not_scheduled => false }\n\n### Local benchmarking and performance\n\nHere are some benchmarks done on loading features with and without delivery\nrisks, performed on my MacBook Pro (M1 Pro CPU) using Postgres 14. The units\nare in seconds. All here means \"with no limit,\" and that is 8998 features on\nmy local database. Each row was run for 10,000 iterations and averaged. This\nalso includes all 17 of the available delivery risks in Aha! \u2014 so the query\nand plan are even more complex than the examples above.\n\n    \n    \n    user system total real 1 Feature 0.021903 0.000080 0.021983 ( 0.022046) 10 Features 0.019104 0.000032 0.019136 ( 0.019164) 100 Features 0.018840 0.000026 0.018866 ( 0.018901) 1000 Features 0.018174 0.000018 0.018192 ( 0.018203) All Features 0.017293 0.000034 0.017327 ( 0.017340) 1 Feature with risks 0.617923 0.000863 0.618786 ( 0.619724) 10 Feature with risks 0.601085 0.001258 0.602343 ( 0.603338) 100 Feature with risks 0.588217 0.000949 0.589166 ( 0.590493) 1000 Feature with risks 0.589340 0.000919 0.590259 ( 0.591504) All Feature with risks 0.589590 0.000745 0.590335 ( 0.591605)\n\nFrom this, we can see that loading the delivery risks is meaningfully slower.\nHowever, we should also take into account the complexity of the additional\ndata being requested. What is potentially the most interesting insight here is\nthat there doesn't appear to be any correlation between the number of records\nloaded and the query time: a testament to Postgres' raw performance. This\ninsight gives us confidence that we're going to have stable performance on\neven the largest workflow boards or reports.\n\nAha! is happy, healthy, and hiring. Join us!\n\nThis feature took a lot of tinkering and guidance from other engineers.\nWithout such a knowledgeable and helpful team, I would not have arrived at\nthis clean solution. If you want to build lovable software with this talented\nand growing team, apply for an open role.\n\n#### Michael Shiel\n\nMichael is a senior software engineer at Aha! \u2014 the world\u2019s #1 product\ndevelopment software. He is based in Calgary, Canada.\n\nBuild what matters. Try Aha! free for 30 days.\n\nFollow Aha!\n\nFollow Michael\n\n", "frontpage": false}
