{"aid": "40260768", "title": "Artifact Attestations\u2013now in public beta \u2013 The GitHub Blog", "url": "https://github.blog/2024-05-02-introducing-artifact-attestations-now-in-public-beta/", "domain": "github.blog", "votes": 1, "user": "WirelessGigabit", "posted_at": "2024-05-04 22:21:34", "comments": 0, "source_title": "Introducing Artifact Attestations\u2013now in public beta", "source_text": "Introducing Artifact Attestations\u2013now in public beta - The GitHub Blog\n\nSkip to content\n\n  * Security\n\n# Introducing Artifact Attestations\u2013now in public beta\n\nGenerate and verify signed attestations for anything you make with GitHub\nActions.\n\nAuthor\n\nTrevor Rosen\n\nMay 2, 2024\n\nThere\u2019s an increasing need across enterprises and the open source ecosystem to\nhave a verifiable way to link software artifacts back to their source code and\nbuild instructions. And with more than 100M developers building on GitHub, we\nwant to ensure developers have the tools needed to help protect the integrity\nof their software supply chain. Today, we\u2019re proud to announce the public beta\nof Artifact Attestations, a new feature that will pave the way for a cultural\nshift toward expecting to know where software comes from.\n\nArtifact Attestations allow project maintainers to effortlessly create a\ntamper-proof, unforgeable paper trail linking their software to the process\nwhich created it. Downstream consumers of that metadata can then use it as a\nfoundation for new security and validity checks through policy evaluation via\ntools like Rego and Cue. We\u2019re starting with verification support based on\nGitHub CLI, but will expand to bring these same controls to the Kubernetes\necosystem as well later this year.\n\nArtifact Attestations is powered by Sigstore, an open source project for\nsigning and verifying software artifacts. This means open source maintainers\ncan reduce their project\u2019s exposure to supply chain attacks and increase the\nsecurity of the broader software ecosystem\u2013no matter where maintainers host\ntheir code, or build their artifacts. Let\u2019s jump in.\n\n## An effortless user experience\n\nSecurity features need to be more than just powerful\u2014they have to be simple to\nadopt and easy to configure in order to be effective. Artifact Attestations\ncouldn\u2019t be easier to set up: all you need to do is add a bit of YAML to your\nGitHub Actions workflow to create an attestation and install the GitHub CLI\ntool to verify it.\n\n  1. Enable your GitHub Actions workflow to write to the attestations store:\n    \n        permissions: id-token: write attestations: write contents: read\n\n  2. Direct a workflow to create an attestation, making sure to place it after the artifact is generated:\n    \n        - name: Attest Build Provenance uses: actions/attest-build-provenance@897ed5eab6ed058a474202017ada7f40bfa52940 # v1.0.0 with: subject-path: \"bin/my-artifact.tar.gz\"\n\n  3. Once your build is finished and you have the artifact downloaded, use GitHub CLI (version 2.49.0 or greater) to verify it, providing the name of the organization that contains the repository where the action ran:\n    \n        gh attestation verify my-artifact.tar.gz -o my-organization\n\nIt\u2019s also easy to download the attestation document itself for storage or\noffline verification (for example, in an air-gapped environment), quickly look\nat certificate details, or extract verified attestation contents in a JSON\nform so you can pipe it to a policy engine like OPA.\n\n    \n    \n    package attestation.slsa1 import future.keywords.if approved_repos := [ \"https://github.com/sigstore/sigstore-js\", \"https://github.com/github/example\", ] # Fail closed default allow := false # Allow if the repository is in the approved_repos list and the predicateType matches allow { some i # Check if the predicateType matches the required type input[i].verificationResult.statement.predicateType == \"https://slsa.dev/provenance/v1\" # Attempt to safely assign the repo variable repo := input[i].verificationResult.statement.predicate.buildDefinition.externalParameters.workflow.repository repo == approved_repos[_] }\n\nYou can grab the attestation in JSON format and use the policy to verify\nmyfile.zip came from an allowed repository in the policy like so:\n\n    \n    \n    $ gh attestation verify -R github/example --format json myfile.zip | \\ opa eval --stdin-input -f raw \\ -d policy.rego \"data.attestation.slsa1.allow == true\" true\n\n## Can I attest other things in my build, like SBOM?\n\nIf you have an SBOM that you\u2019ve generated as part of your build, you can use\nthe new attest-sbom action to associate it with a final artifact. You simply\nprovide the path to that artifact and the action will take care of wrapping it\nin an in-toto attestation predicate, signing it with our internal Sigstore\ninstance, and sending it to our attestation store. If you don\u2019t already have\nan SBOM in your build and want a way to get started, the anchore/sbom-action\noffers support for container images and many language ecosystems.\n\nTo associate a build artifact with an attested SBOM, follow these steps:\n\n  1. First (just like for provenance) you need to grant write permission for the attestation store to your workflow:\n    \n        permissions: id-token: write attestations: write contents: read\n\n  2. Ensure that you actually have an SBOM that makes sense for your particular needs. Here\u2019s an example of using Anchore\u2019s Syft to scan a build directory:\n    \n        - uses: anchore/sbom-action@v0 with: path: ./build/ format: 'spdx-json' output-file: 'sbom.spdx.json'\n\n  3. Finally, use the attest-sbom action to wrap the generated SBOM file contents in an in-toto SBOM predicate, sign it, associate it with your built artifact, and send it to the attestation store:\n    \n        - uses: actions/attest-sbom@v1 with: subject-path: 'bin/my-artifact.tar.gz' sbom-path: 'sbom.spdx.json'\n\n## How it works\n\nArtifact Attestations help reduce the complexity of deploying and managing\npublic key infrastructure, instead placing trust in the security of your\nGitHub account. We accomplish this by signing a document with a temporary\nkeypair. The public key is attached to a certificate associated with a build\nsystem\u2019s workload identity, and the private key never leaves process memory\nand is discarded immediately after signing. This differs from other signing\napproaches that rely on human identities or long-lived keys. We believe that\ncertificate revocation lists are too problematic to use effectively, and that\nthe future of software provenance and signatures goes through workload\nidentity. Here\u2019s how:\n\n  * When an attestation action executes, our Sigstore client requests the GitHub Actions OIDC token associated with that workflow run. It then creates a key pair and sends the public half to Fulcio, a certificate authority, along with the OIDC token. In the case of a public repository, Sigstore Public Good Instance\u2019s Fulcio issues the cert. In the case of a private repository, the cert is issued by GitHub\u2019s internal instance of Fulcio, ensuring that no customer information leaves GitHub.\n  * When receiving the token, Fulcio validates the token\u2019s signature and mints a new short-lived X.509 certificate binding the public key to the workflow\u2019s OIDC identity.\n  * Fulcio returns the certificate to the client running in GitHub Actions, which calculates a SHA-256 digest of the subject artifact, and writes out an in-toto statement which binds the subject to a predicate containing data from the OIDC token\u2019s claims.\n  * The client uses the private key to seal the in-toto statement in a DSSE signing envelope. Then, it throws the private key away. The envelope\u2019s signature is sent to the TSA for a timestamp counter-signature, which proves that the signature was produced during the certificate\u2019s 10-minute validity window.\n  * Everything is wrapped up as a Sigstore bundle and persisted to GitHub\u2019s attestation store. In the case of a private repository, that\u2019s the end of the flow. In the case of a public repository, the attestation is additionally written to the Sigstore Public Good Instance and lands on Rekor, the project\u2019s immutable ledger.\n\nArtifact Attestations have been in an early access preview for the last\nseveral months, and we\u2019re thrilled by the early feedback we\u2019ve received.\n\n> GitHub is steadfast in its commitment to democratizing software attestations\n> and artifact integrity. Leveraging just six lines of code in GitHub\n> workflows marks a game-changer in build chain security\u2014an initiative I've\n> utilized, experienced, and enthusiastically embraced.\n\n\\- Victor Martinez Rubio // Principal Engineer, Elastic\n\n### GitHub is now a root certificate authority\n\nWhen we started designing the requirements for this feature, we realized\nquickly that we wanted users to be able to sign an artifact on GitHub Actions\nand then verify it anywhere, even offline. Public key infrastructure (PKI) is\ncomplex and high-stakes, and we heard from both customers and open source\nprojects that they wanted a way to sign things without having to build out PKI\nor manage secrets which can be leaked or lost. To do this, we first needed to\nestablish GitHub as a root certificate authority (CA) for signing software so\nthat we could own the entire certificate chain.\n\nIn October 2023, we went live with an X.509 certificate authority and RFC 3161\ntimestamp server, with a trust root managed via a quorum of hardware tokens\nheld by employees across a variety of geographies and roles. The trust root is\nmanaged with tooling from the TUF project (where we\u2019re contributors), and the\nCA and timestamp services are instances of Sigstore applications. Intermediate\ncertificates are housed in Azure KeyVault Managed HSMs, which are used to sign\nleaf certificates issued by Sigstore Fulcio and Sigstore Timestamp Authority.\nSigning certificates are valid for 10 minutes from the time of issuance, so\nthere is no need to manage the complexities of Certificate Revocation Lists\n(CRLs).\n\n### Sigstore, in public and in private\n\nIn keeping with our commitment to offering cutting-edge features to both\nenterprise customers and the open source community, Artifact Attestations\nsupports the same user experience offered in two basic modes depending on\nrepository visibility. For public repositories, attestations generated on\nGitHub Actions will be written to the Sigstore Public Good Instance for\nverification in public on an immutable ledger. For private repositories on\nGitHub Enterprise plans, the attestations are written to an internal,\ncompletely private database and no information is written to public ledgers or\nlogs.\n\n## A more secure future\n\nIt\u2019s important to note that provenance by itself doesn\u2019t make your artifact or\nyour build process secure. What it does do is create a tamper-proof guarantee\nthat the thing you\u2019re executing is definitely the thing that you built, which\ncan stop many attack vectors. It\u2019s still vital to maintain strong application\nsecurity processes like requiring code review for all patches, and applying\ndependency updates in a timely manner.\n\nIn other words: attestations provide you with a paper trail, which cannot be\nforged, tying a given artifact to a given GitHub Actions workflow run. We\nbelieve that this is a key piece of the modern trust model, and in addition we\nwant to help effect a cultural shift toward folks knowing where their software\ncomponents come from.\n\nArtifact Attestations will allow customers unprecedented visibility into the\ncomposition and usage of their built software artifact, and this is just the\nbeginning. We\u2019ll be offering the ability to attest other kinds of artifacts\nassociated with the build process, such as vulnerability reports and other\npieces of metadata supported by the in-toto project\u2019s defined predicate types.\nLook for exciting news around Kubernetes support, new guarantees for releases,\nand more later this year.\n\nWant to learn more about how GitHub can take the stress out of shipping secure\ncode?\n\nAt GitHub Universe 2024, we\u2019ll explore cutting-edge research and best\npractices in developer-first security\u2014so you can keep your code secure with\ntools you already know and love.\n\nOur Super Early Bird sale ends soon! Buy your tickets now.\n\nTags:\n\n  * CLI,\n  * GitHub Actions,\n  * supply chain security\n\n## We do newsletters, too\n\nGet tips, technical guides, and best practices right in your inbox.\n\nSubscribe\n\n## More on CLI\n\n### Release Radar \u00b7 Spring 2023 Edition\n\nIt's been a while since we've published our Release Radar. You can blame IRL\nconferences coming back, getting influenza, and being struck down by the\nweather. But those are just...\n\nMichelle Mannering\n\n### Release Radar \u00b7 November 2022 Edition\n\nWe promised we'd be back soon and here we are! There has been an incredible\namount of open source projects shipping major version releases before the year\nwraps up. I...\n\nMichelle Mannering\n\n### Best practices on rolling out code scanning at enterprise scale\n\nLearn best practices on how to roll out centrally managed, developer-centric\napplication security with a third party CI/CD system like Jenkins or ADO.\n\nKevin Alwell\n\n## More on GitHub Actions\n\n### Dependabot on GitHub Actions and self-hosted runners is now generally\navailable\n\nA quick guide on the advantages of Dependabot as a GitHub Actions workflow and\nthe benefits this unlocks, including self-hosted runner support.\n\nCarlin Cherry\n\n### Where does your software (really) come from?\n\nGitHub is working with the OSS community to bring new supply chain security\ncapabilities to the platform.\n\nTrevor Rosen\n\n### GitHub Actions, Arm64, and the future of automotive software development\n\nLearn how GitHub's Enterprise Cloud, GitHub Actions, and Arm's latest\nAutomotive Enhanced processors, work together to usher in a new era of\nefficient, scalable, and flexible automotive software creation.\n\nClay Nelson\n\n## Related posts\n\nSecurity\n\n## Where does your software (really) come from?\n\nGitHub is working with the OSS community to bring new supply chain security\ncapabilities to the platform.\n\nTrevor Rosen\n\nSecurity\n\n## CodeQL zero to hero part 3: Security research with CodeQL\n\nLearn how to use CodeQL for security research and improve your security\nresearch workflow.\n\nSylwia Budzynska\n\nSecurity\n\n## Securing millions of developers through 2FA\n\nWe\u2019ve dramatically increased 2FA adoption on GitHub as part of our\nresponsibility to make the software ecosystem more secure. Read on to learn\nhow we secured millions of developers and why we\u2019re urging more organizations\nto join us in these efforts.\n\nMike Hanley\n\n## Explore more from GitHub\n\n### Security\n\nSecure platform, secure data. Everything you need to make security your #1.\n\nLearn more\n\n### GitHub Universe 2024\n\nGet tickets to the 10th anniversary of our global developer event on AI,\nDevEx, and security.\n\nGet tickets\n\n### GitHub Copilot\n\nDon't fly solo. Try 30 days for free.\n\nLearn more\n\n### Work at GitHub!\n\nCheck out our current job openings.\n\nLearn more\n\n## Subscribe to our newsletter\n\nCode with confidence. Discover tips, technical guides, and best practices in\nour biweekly newsletter just for devs.\n\n## Product\n\n  * Features\n  * Security\n  * Enterprise\n  * Customer Stories\n  * Pricing\n  * Resources\n\n## Platform\n\n  * Developer API\n  * Partners\n  * Atom\n  * Electron\n  * GitHub Desktop\n\n## Support\n\n  * Docs\n  * Community Forum\n  * Training\n  * Status\n  * Contact\n\n## Company\n\n  * About\n  * Blog\n  * Careers\n  * Press\n  * Shop\n\n  * GitHub on X\n  * GitHub on Facebook\n  * GitHub on YouTube\n  * GitHub on Twitch\n  * GitHub on TikTok\n  * GitHub on LinkedIn\n  * GitHub\u2019s organization on GitHub\n\n  * \u00a9 2024 GitHub, Inc.\n  * Terms\n  * Privacy\n\nWe use optional cookies to improve your experience on our websites and to\ndisplay personalized advertising based on your online activity. If you reject\noptional cookies, only cookies necessary to provide you the services listed\nabove will be used. You may change your selection on which cookies to accept\nby clicking \"Manage Cookies\" at the bottom of the page to change your\nselection. This selection is maintained for 180 days. Please review your\nselections regularly.\n\nHow to manage cookie preferences | Privacy Statement | Third-Party Cookies.\n\n", "frontpage": false}
