{"aid": "40121868", "title": "For-Each Loops for Hare", "url": "https://harelang.org/blog/2024-04-01-introducing-for-each-loops-in-hare/", "domain": "harelang.org", "votes": 1, "user": "todsacerdoti", "posted_at": "2024-04-22 21:53:35", "comments": 0, "source_title": "Introducing for-each loops for Hare", "source_text": "Introducing for-each loops for Hare\n\n## Introducing for-each loops for Hare April 2, 2024 by Lorenz (xha)\n\nToday, for-each loops were merged into Hare\u2019s development branch! This\nincludes patches for the compiler, standard library, specification and\ntutorial. I want to give some background on how we designed for-each loops and\nwhat challenges are associated with implementing them.\n\n## What kind of for-each loops do we want?\n\nBefore for-each loops, you could iterate over an array/slice like so:\n\n    \n    \n    let array = [1, 2, 3]; for (let i = 0z; i < len(array); i += 1) { fmt::printfln(\"{}\", array[i])!; };\n\nHaving an index can be very powerful if you require it. However, in most\ncases, you will not, and I\u2019ve found that using indices makes code less\nreadable. This is how a for-each loop over an array/slice could look:\n\n    \n    \n    foreach (x in [1, 2, 3]) { fmt::printfln(\"{}\", x)!; };\n\nIn addition to for-each loops over arrays/slices, you might remember the\nconcept of iterators from languages such as Rust. The idea is very simple: you\nhave a function, typically called something like next(), that you call every\nloop iteration. This is useful when, for example, iterating over every line of\na file \u2014 you don\u2019t have to load the whole file in one go, but only ever read\nit line by line. This concept is also used extensively in the standard\nlibrary, but so far, it has been implemented using for (true) and match:\n\n    \n    \n    for (true) match (bufio::read_line(file)!) { case let line: []u8 => fmt::printfln(\"{}\", strings::fromutf8(line)!)!; case io::EOF => break; };\n\nWhile this works, it takes up a lot of lines and is not very readable. We can\ndo better. Here is what that could look like:\n\n    \n    \n    foreach (line = bufio::read_line(file)!) { fmt::printfln(\"{}\", strings::fromutf8(line)!)!; };\n\nWith these changes in mind, I wrote the first version of the RFC to discuss\nthese changes to the language.\n\n## How should these loops really look?\n\nThe purpose of the Hare RFC process is to discuss and reach consensus on\nbigger changes to Hare. This is especially important for new language features\nsuch as for-each. In the three revisions to the RFC, we found solutions for a\nnumber of challenges.\n\nFirst of all, there was the syntax question. Do we want foreach? Or should we\nintegrate it into for? We quickly reached the conclusion that it is best to\nintroduce a new syntax to for instead of foreach, because it should remain the\nonly statement that can loop, since there is no while statement in Hare.\n\n    \n    \n    // for-each value for (let x .. [1, 2, 3]) { // The type of x is int here fmt::printfln(\"{}\", x)!; }; // for-each reference for (let x &.. [1, 2, 3]) { // The type of x is *int here fmt::printfln(\"{}\", *x)!; };\n\nAs you can see, we\u2019ve also introduced another variant: for-each reference\nloops. Instead of assigning the value itself, we assign a pointer to the\nvalue. This is useful when you want to manipulate values in the slice/array\nitself or your values are too big for copying and it\u2019s unlikely that an\noptimizer would catch this.\n\nSpecifying the iterator loops was especially challenging. How should these\nkind of loops end, by the iterator returning a special type, or void? Do we\nuse a special method for every type or will it just be a function call? What\nkind of operator do we want to use? After lots of discussion, this is the\nsyntax we came up with:\n\n    \n    \n    for (let line => bufio::read_line(file)!) { fmt::printfln(\"{}\", strings::fromutf8(line)!)!; };\n\nThis \u201cfor-each iterator\u201d loop executes its binding initializer, bufio::read_line(file)!, at every start of the loop. This initializer returns a tagged union with a done type. In this case, the initializer returns ([]u8 | io::EOF). This is a tagged union, which is a type that can contain one of []u8 or io::EOF. Unlike a union in C, it also indicates what type it currently holds, using a tag.\n\nio::EOF is defined as a done type. This means that the for-each loop checks if\nbufio::read_line(file)! returns done and terminates the loop in this case.\nOtherwise, it will assign the value to the line variable and run the body of\nthe loop. The type of this variable is []u8, because that is the type that is\nleft in the tagged union when excluding the done type.\n\n## Closing thoughts\n\nThere is still a lot of Hare code that needs to be updated to use the new for-\neach loops. In particular, the extended libraries haven\u2019t received updates\nyet. We plan to go over this code during the regular course of our work.\n\nThe implementation of for-each proves that the Hare RFC process is working\nreally well. We were able to collectively come up with a for-each design that\nfits Hare really well and that everyone is fine with. I am, personally, very\nhappy with the end result.\n\nharelang.org\n\nHome \u00b7 Sitemap \u00b7 Source\n\n", "frontpage": false}
