{"aid": "40198119", "title": "A short story on proprietary serial protocols", "url": "https://sjaeckel.github.io/2024/04/23/Cressi-Nepto-for-Subsurface.html", "domain": "sjaeckel.github.io", "votes": 3, "user": "jaeckel", "posted_at": "2024-04-29 13:32:08", "comments": 0, "source_title": "Cressi Nepto for Subsurface \u2013", "source_text": "embedded software and other interesting stuff\n\nreasonably untitled\n\n  * Home\n  * About\n  * Projects\n  * RSS\n\n## Cressi Nepto for Subsurface\n\n23 Apr 2024\n\nor \u201cA short story on proprietary serial protocols\u201d.\n\nSo I\u2019ve bought myself a used Cressi Nepto on kleinanzeigen. As soon as I\ndiscovered that this diving computer (DC) can also sync the dive data to a PC,\nI had to get the required adapter as well. Luckily there was also a used one\non kleinanzeigen for half the regular price :)\n\nAfter a very painful trip for roughly 2 weeks with DHL, I finally had my hands\non the adapter.\n\nDid you know that Linus created other really useful software besides the Linux\nkernel and Git? Subsurface \u2013 the diving log software which is part of this\nstory \u2013 was also started by him.\n\nLet\u2019s install Subsurface! Btw. did I mention that I\u2019m using Arch? ... oh well\nthe packaged version in the AUR is super old, so let\u2019s create a new package\nfrom the AppImage subsurface-appimage.\n\nThe software provided by Cressi is the same as for the Cressi Goa, so this\nshould work with Subsurface, shouldn\u2019t it?\n\nBummer, it can\u2019t download the data.\n\nSo let\u2019s dive into some weird way to read data from a dive computer via some\nproprietary adapter! Sounds like fun ;)\n\nI know Jef, the maintainer of libdivecomputer, from a previous job and I\nthought it\u2019s nice to get back in contact with him and asked him for advice.\nJef promptly came back to me with his ideas and suggestions, thanks for that!\n\nFirst steps first: what does the vendor software do?\n\n## Windows VM inside VirtualBox\n\nLet\u2019s get a Windows 11 VM to install in VirtualBox. Apparently there\u2019s a \u201cfree\nof charge for some weeks\u201d VM of this Windows 11 \u201coperating system\u201d provided\ndirectly by Microsoft. At least I can run that without giving it a network\ninterface...\n\nPlease make sure to run the VM while being in the vboxusers group, otherwise\none can\u2019t forward USB devices to the VM. This can cause a lot of frustration\n\u201cwhy doesn\u2019t the DC show up in the app?\u201d.\n\nThe Cressi UCI (Underwater Computer Interface) software looks like it was last\nupdated a long time ago, but hey \u201cit works\u201d^TM.\n\nSo let\u2019s try this out.\n\nAlright, I can import all data, sync the time, set the units to metric or\nimperial.\n\nHow does UCI communicate with the DC? Via an FTDI serial converter that is\nconnected to an Infrared link, let\u2019s call it also IrDA as everyone else also\ndoes so.\n\nJef proposed to capture the data on the Windows VM, but I thought \u201cnaah, I\ndon\u2019t want to touch this Windows thing more than necessary. There\u2019s wireshark\nand it has USB support on Linux, this must work\u201d.\n\n## Capture USB traffic\n\nAnd it was indeed straight-forward.\n\nInstall wireshark. Make sure that you\u2019re in the wireshark group.\n\nRun sudo modprobe usbmon to load the USB probes.\n\nRun lsusb and check to which USB Host controller (indicated by the Bus) your\nserial adapter is connected to.\n\nOpen up wireshark and start capturing of usbmon<USB Host controller>, in my\ncase it was usbmon5.\n\nFilter on ftdi-ft.if_a_tx_payload || ftdi-ft.if_a_rx_payload to see only\ntransferred data between the devices.\n\nAlright! We have support for the Cressi Goa in libdivecomputer, the Cressi\nsoftware is the same for Nepto and Goa, so there can\u2019t be a huge difference in\nthe serial protocol of the two DCs.\n\nBut next, back to basics of how communication via a serial interface usually\nworks.\n\n## Basic frame format\n\nAs all good engineers should have done at least once in their life, Cressi (or\nI guess most likely some engineering shop) did invent their own serial\nprotocol.\n\nThere\u2019s a sync start-sequence, and end-octet, which defines some kind of fixed\nframe format. A length field and a CRC to make sure that transferred data is\nnot corrupted. Below are the basics in some notation I just came up with to\ndocument this hell while looking at raw octets...\n\nNB: All values are hex values, multi-octet types are little-endian.\n\n    \n    \n    SYNC_START = 0xaa aa aa SYNC_END = 0x55 LEN = u8 CMD = u8 PAYLOAD = LEN * u8 MESSAGE = LEN | CMD [ | PAYLOAD] CRC16 = crc16_ccitt(MESSAGE) FRAME = SYNC_START | MESSAGE | CRC16 | SYNC_END\n\n## CMD 0x00 - Identity\n\nTo get the DC\u2019s identity, the command 0x00 is sent and a reply is received,\nwhich contains the serial number, model, and firmware version of the DC.\n\n    \n    \n    # request CMD = 0x00 # response LEN = 0x0b => 11 CMD = 0x21 SERIAL = u32 MODEL = u8 FIRMWARE = u16 UNKNOWN_00 = 8 * u8 PAYLOAD = SERIAL | MODEL | FIRMWARE | UNKNOWN_0 # example data aaaaaa0b21b21100000acc00010004004a7855 # PAYLOAD b21100000acc0001000400 SERIAL = 0xb2110000 => 0x11b2 = 4530 MODEL = 0x0a => 10 FIRMWARE = 0xcc00 => 0x00cc = 204 UNKNOWN_00 = 0x01000400\n\nThose values are consistent to what is shown on the DC \u2013 Hooray!\n\nThe length that is sent by the Nepto is different to what is expected from the\nGoa.\n\nSo let\u2019s patch libdivecomputer to support the longer answer ... oh nice, that\nwas easy, now let\u2019s see what else differs ...\n\n## Bulk data retrieval\n\nLet\u2019s compare the capture with the sources of libdivecomputer and find out how\nthe \u201creal\u201d data transmission works.\n\nSo there\u2019s this request-response mechanism where each frame starts with\n0xAAAAAA, but there is another mechanism for bulk data transmission.\n\nThere are commands like the logbook retrieval, which trigger the DC to send\nbulk data afterwards. That\u2019s what libdivecomputer handles in\ncressi_goa_device_download()\n\nThat frame format looks as follows and it\u2019s always 512 octets data + 5 octets\nheader&footer.\n\n    \n    \n    ID = u8 FRAME_NO = u8 FRAME_NO_INV = u8 DATA = 512 * u8 CRC16 = crc16_ccitt(DATA)\n\nThe first frame, which starts with the header 0x0101fe, contains the real\nlength of the data in its first 2 DATA octets.\n\nIn case the real length in a frame is shorter than 512 octects, it will be\npadded with 0xff.\n\n    \n    \n    # an example with 10 octets payload ID = 0x01 FRAME_NO = 0x01 FRAME_NO_INV = 0xfe DATA = 0x0a00<10 octets data><500 * 0xff> CRC16 = crc16_ccitt(DATA)\n\nOnce the PC software received such a bulk data frame, it will send a single\nACK octet of the value 0x06 to the DC.\n\nThe DC will then either send more bulk data or send an END octet of the value\n0x04.\n\n## CMD 0x23 - Logbook\n\nWhile comparing the sources for the Goa and the Wireshark capture one can see\nthat the command code to read the logbook differs ... the Goa expects 0x21,\nbut the Nepto wants 0x23.\n\n*sigh*\n\nOK, it\u2019s not that straight forward as hoped ...\n\n... and there is also payload contained in the initial response now ... that\nwasn\u2019t the case before.\n\n    \n    \n    # request CMD = 0x23 ## example aaaaaa0023011455 # response LEN = 0x02 CMD = 0x21 PAYLOAD = u16(0x2000) => 0x0020 = 32 ## example aaaaaa02212000785a55\n\nHaving a look at the Goa implementation and what the DC shows on its display,\nthis indicates that we\u2019re told now how many logbook entries exist.\n\n## CMD 23 - Logbook (cont\u2019d)\n\nAfter having given the data a looong good stare we\u2019ll find patterns for sure!\n\n    \n    \n    # example data 0101fee001010005e5070c060d0901000e040000020005e5070c070b08010081060000030005e5070c080d26010014010000040005e5070c080d3601007c 000000050005e5070c080e04010083020000060005e5070c0a070b01007b040000070005e5070c0d10350100e2050000080005e5070c0d12220100fb0700 00090005e5070c1b121d0100cf0900000a0005e607010311230100be0c00000b0005e60704120a1601004d0000000c0005e6070502120801009b0500000d 0005e607050213220100980100000e0005e6070506111d0100e00500000f0005e607050b112a010051000000100005e607050b112c010067000000110005 e6070512123801003d000000120005e6070512123b01004a020000130005e607060f12190100840a0000140005e60706111222010064050000150005e607 061b11200100f7100000160005e607070612050100db0a0000170005e607070b112d0100d1040000180005e607070b12270100aa050000190005e6070716 121901004c0500001a0005e607080a122f0100990700001b0005e6070812112401008a0000001c0005e6070812112b0100d40000001d0005e60708131217 0100240a00001e0005e607081c0b2a01001d0500001f0005e607081c0e3601003b050000200005e8070409131a01002a040000ffffffffffffffffffffff ffffffffffffffffffffffffffffffffffffffa685\n\n### Header\n\nLet\u2019s apply what we\u2019ve learned before. It\u2019s a bulk data frame, so start to\nparse it like that ...\n\n    \n    \n    0101fee001 ID = 0x01 FRAME_NO = 0x01 FRAME_NO_INV = 0xfe LEN = u16(e001) => 0x1e0 = 480\n\n480 octets ... divided by 32 entries ... looks like each entry is 15 octets\nlong.\n\n### DATE format\n\nIn the next part of the payload seems to be a date included in the data.\n\nThe format is already implemented in libdivecomputer. For the sake of\ncompleteness, it looks as follows:\n\n    \n    \n    DATE_YEAR = u16 DATE_MONTH = u8 DATE_DAY = u8 DATE_HOUR = u8 DATE_MINUTE = u8 DATE = DATE_YEAR | DATE_MONTH | DATE_DAY | DATE_HOUR | DATE_MINUTE\n\n### Entries\n\n    \n    \n    LOG_ENTRY_ID = u16 DIVE_TYPE = u8 -- 0x05 = Freedive START = DATE UNKNOWN_DL_ENTRY_10 = u16 DIVELOG_SIZE = u32 LOG_ENTRY = LOG_ENTRY_ID | DIVE_TYPE | START | UNKNOWN_DL_ENTRY_10 | DIVELOG_SIZE 0100 05 e5070c060d09 0100 0e040000 [...] 2000 05 e8070409131a 0100 2a040000\n\n## CMD 0x22 - Dive\n\nAfter having a look at the capture again, the next request is for each\ndive/logbook entry.\n\n    \n    \n    # request CMD = 0x22 DIVE_ID = u16 PAYLOAD = DIVE_ID ## example aaaaaa02220100ff3655\n\nThe returned direct response contains no data and the DC starts sending bulk\ndata.\n\n    \n    \n    # start of the bulk data 0101fe 0e04 0100 ab01 e5070c060d09 02010c120c006700ab006e109e012900f5c4020085008940854089408940894081405d40594041402940c6052d002d BULK_HEADER = 0x0101fe LEN = u16(0e04) => 0x1e0 = 1038 -- nice, that's the same as last field in the logbook entry DIVE_ID = u16(0100) -- cool, that's the dive id we just requested UNKNOWN_22_07_U16 = u16(ab01) => 0x1ab = 427 -- ? UNKNOWN_22_07_U8 = u8(ab) => 0xab = 171 -- ? UNKNOWN_22_08_U8 = u8(01) => 0x01 = 1 -- ? START = DATE(e5070c060d09) -- also cool, that's the same date as in the logbook entry\n\nHow does libdivecomputer handle the returned dive for the Goa ... OK, those\nare 2 octet-wide sample values ... and we have 1038 - 2 - 2 - 6 = 1028\nremaining data octets.\n\nHow well does any of 427 or 171 and 2 octet-wide values play together with\n1028?\n\nThe long stare technique (LST) doesn\u2019t seem to help here, even after looking\nfor a long time and trying different things ... let\u2019s go back to UCI and check\nwhat it does and provides!\n\n## UCI internals\n\nUCI created a sqlite database (DB) with all the data it read from the DC.\n\nThere\u2019s a table AdvancedFreeProfilePoint with a column Sequence that goes from\n0 ... 426 ... that\u2019s 427 entries \u2013 cool! \u2013 (maybe those are the samples?)\n\nSo 427 * 2 = 854 ... 1028 - 854 = 174, what are those remaining 174 octects\nand where do the samples start? 174 octets for a header? Sounds a bit much!?\n\nEven with this information, the LST didn\u2019t help ... I also couldn\u2019t correlate\nany of the values in the DB to that data.\n\nWell, we have the installed application ... let\u2019s look a bit deeper into it!\n\nUCI is a .NET application based on Unity, which is ... a 3D gaming engine!?\n... hey I\u2019m not gonna judge, it\u2019s software and as long as you\u2019re comfortable\nwith it and it does the job, why not? ... at least that could maybe explain\nwhy I had to disable 3D acceleration for the VM, otherwise UCI wouldn\u2019t even\nstart.\n\nThere exist decompilers for .NET applications ... so let\u2019s fire up ILSpy,\nresp. its GUI version AvaloniaILSpy.\n\n## UCI decompiled\n\nOK, let\u2019s look into what got installed ... some DLL\u2019s ... there\u2019s\nCressi.Algo.dll, but decompiling that shows nothing of interest.\n\nAt one point while digging through the intertubes, some SO answer (which I\napparently can\u2019t find again) mentions that all Unity C# code goes into\nAssembly-CSharp.dll and *BOOM*.\n\nHere we go, with Cressi.IrdaApi, Cressi.IrdaApi.Data, IrdaApiV0 up to\nIrdaApiV4 and some other interesting stuff. No more LST required, let\u2019s just\nlook at the code.\n\nLuckily the staring without results and trying stuff out didn\u2019t take more than\n2 or 3 hours in total, otherwise I\u2019d feel even more stupid to not focus on\nthis earlier :-D\n\n## CMD 0x22 - Dive (cont\u2019d)\n\nSo the new IrdaApiV4 Dive data contains more data than the old version.\n\nThere\u2019s an extended header and also some advanced dip statistics. As the Nepto\nis a DC mainly for Freediving it already differentiates between a Dive \u2013 total\ntime spent in water \u2013 and a Dip \u2013 each time you go under water, usually\nmultiple times during one dive.\n\n### Header\n\nThe Dive data has the following header:\n\n    \n    \n    0100ab01e5070c060d0902010c120c006700ab006e109e012900f5c4 DIVE_ID = u16 -- 0100 SAMPLES = u16 -- ab01 => 0x1ab = 427 START = DATE -- e5070c060d09 RATE = u8 -- 02 TARAVANA_FACTOR = u8 -- 01 SESSIONTIME = u16 -- 0c12 DIPS = u8 -- 0c => 12 UNUSED = u8 -- 00 MAXDEPTH = u16 -- 6700 MINTEMP = u16 -- ab00 SURFTIME = u16 -- 6e10 DIVETIME = u16 -- 9e01 BESTDIP = u16 -- 2900 CRC = u16 -- f5c4\n\n### Sample points\n\nThe header is followed by the sample points, which are still in the same\nformat as with the Goa:\n\n    \n    \n    POINTS = SAMPLES * u16 020085008940...\n\n### Advanced dip statistics\n\nThe sample points are followed by the advanced dip statistics:\n\n    \n    \n    DIPTIME = u16 SPEED_DESC = u16 SPEED_ASC = u16 TARAVANA_VIOLATION = u8 DIP_DETAIL = SURFTIME | MAXDEPTH | DIPTIME | MINTEMP | SPEED_DESC | SPEED_ASC | TARAVANA_VIOLATION DIP_DETAILS = DIPS * DIP_DETAIL\n\nSubsurface doesn\u2019t know about such things as advanced statistics, so we simply\nhave to skip this data. There\u2019s no way to tell Subsurface about the max ascend\nor descend speed, which would be kind of interesting, but then it\u2019s also not\nthat important. ... yet ... ;)\n\n## CMD 0x13 - Sync time\n\nWhile trying out UCI and capturing the USB traffic there was also the option\nto synchronize the time on the DC with the PC.\n\nSubsurface also has the option to do that, so I\u2019d like to have that as well.\n\nThat one was straight-forward already from the dump.\n\n    \n    \n    LEN = 7 CMD = 0x13 SECONDS = u8 PAYLOAD = DATE | SECONDS\n\n## CMD 0x1D - Exit PC Link\n\nLooking at the decompiled UCI, then looking at libdivecomputer which missed\nthe close() API for the Goa, I decided to link close() to the \u201cExit PC Link\u201d\ncommand.\n\n    \n    \n    LEN = 0 CMD = 0x1D\n\n## Some other details\n\nSorry, some of the field names I only found out either after looking at the DB\nor the decompiled code, but I can\u2019t remember now which ones, so I just leave\nit as it is now :)\n\nE.g. the DIVE_TYPE in the logbook entry made only sense once I looked at the\nDB.\n\nOr the UNKNOWN_DL_ENTRY_10 should be called VERSION, but it also doesn\u2019t\nmatter, since it isn\u2019t used.\n\n## Conclusion\n\nRoughly two days after starting to dig into this topic I created\nlibdivecomputer/libdivecomputer#33\n\nLet\u2019s hope this gets merged soon, so it can be included in one of the next\nSubsurface releases.\n\nThe import to Subsurface works, so I\u2019m happy for now :)\n\nEOF\n\nTweet\n\n\u00a9 2024 whitepaper\n\n", "frontpage": false}
