{"aid": "40292485", "title": "Lethal Injection: How We Hacked Microsoft's Healthcare Chat Bot", "url": "https://www.breachproof.net/blog/lethal-injection-how-we-hacked-microsoft-ai-chat-bot", "domain": "breachproof.net", "votes": 1, "user": "882542F3884314B", "posted_at": "2024-05-07 22:56:26", "comments": 0, "source_title": "Lethal Injection: How We Hacked Microsoft's Healthcare Chat Bot", "source_text": "Lethal Injection: How We Hacked Microsoft's Healthcare Chat Bot\n\nbreachproof\n\n# Lethal Injection: How We Hacked Microsoft's Healthcare Chat Bot\n\nWe have discovered multiple security vulnerabilities in the Azure Health Bot\nservice, a patient-facing chatbot that handles medical information. The\nvulnerabilities, if exploited, could allow access to sensitive infrastructure\nand confidential medical data.\n\nAll vulnerabilities have been fixed quickly following our report to Microsoft.\nMicrosoft has not detected any sign of abuse of these vulnerabilities. We want\nto thank the people from Microsoft for their cooperation in remediating these\nissues: Dhawal, Kirupa, Gaurav, Madeline, and the engineering team behind the\nservice.\n\nThe first vulnerability allowed access to authentication credentials belonging\nto the customers. With continued research, we\u2019ve found vulnerabilities\nallowing us to take control of a backend server of the service. That server is\nshared across multiple customers and has access to several databases that\ncontain information belonging to multiple tenants.\n\nVulnerabilities Reported\n\n  * Multiple sandbox escapes, unrestricted code execution as root on the bot backend\n  * Unrestricted access to authentication secrets & integration auth providers\n  * Unrestricted memory read in the bot backend, exposing sensitive secrets & cross tenant data\n  * Unrestricted deletion of other tenants' public resources\n\n## The Discovery\n\nThe initial research started at the Azure Health Bot management portal\nwebsite. Skimming through the features available, we saw that it\u2019s possible to\nconnect your bot to remote data sources, and also provide authentication\ndetails.\n\nSince customers would likely connect their bot to 3rd party data, such as\npatient databases, appointment calendars, and so forth, it\u2019s a very\ninteresting target for an attacker. It\u2019s unlikely to imagine a scenario where\nthe customers wouldn\u2019t want to connect the bot to their data.\n\nAfter fiddling with this feature, we noticed something interesting in the\nrequest that retrieves our data connection details and auth secrets. This is\nwhat a regular request looks like:\n\n    \n    \n    https://portal-eastus.healthbot.microsoft.com/v4/test-301x6x6/integration/data-connections/1679070537717/\n\nIn this URL, \u201ctest-301x6x6\u201d is our unique health bot instance ID, and\n\u201c1679070537717\u201d is the ID of the unique data connection we created.\n\nThe response to this request was the following JSON:\n\n    \n    \n    { \"odata.metadata\": \"https://hbstenant2steausprod.table.core.windows.net/$metadata#test301x6x6/@Element\", \"etag\": \"W/\\\"datetime'2023-03-17T17%3A08%3A44.7784337Z'\\\"\", \"partitionKey\": \"DataConnection\", \"rowKey\": \"1679070537717\", \"timestamp\": \"2023-03-17T17:08:44.7784337Z\", \"type\": \"custom\", \"name\": \"test data connection\", \"description\": \"desc\", \"base_url\": \"https://website.com/a\", \"auth_provider\": \"\", \"static_parameters\": \"[{\\\"type\\\":\\\"header\\\",\\\"key\\\":\\\"Test\\\",\\\"value\\\":\\\"true\\\"}]\" }\n\nPeople familiar with Azure will recognize this as an Azure Table API response.\nAnd it makes sense, the service stores our connection data in the Azure Table\nservice, and it pulls that data directly from there.\n\nOur intuition was to start toying with the ID number of our data connection.\nWe believe that the data connections of all customers are in the same table,\nand if we can query whatever ID we want from the table, we can view the data\nconnections of other customers.\n\nPer the Azure Table API documentation, here\u2019s how a request to retrieve data\nfrom a table looks like:\n\n    \n    \n    https://myaccount.table.core.windows.net/tableName(PartitionKey='<partition-key>',RowKey='<row-key>')\n\nSo here we have 3 variables we must fill:\n\n  * table name\n  * partition key\n  * row key\n\nWe have all the required variables since the previous Table API response\ndiscloses all that information. Our guess was, that was the URL the backend\nserver uses to get the information behind the scenes:\n\n    \n    \n    https://hbstenant2steausprod.table.core.windows.net/test301x6x6(PartitionKey=\u2019DataConnection\u2019,RowKey=\u20191679070537717\u2019)\n\nHere you can see:\n\n  1. hbstenant2steausprod - the account name Microsoft used for storing the data.\n  2. test301x6x6 - our Azure health bot instance ID. This is not a secret.\n  3. (PartitionKey=\u2019DataConnection\u2019,RowKey=\u20191679070537717\u2019): Pulling DataConnection with the ID from the request.\n\nThe input in our control is the ID. The idea was to send an ID that would\nallow us to \u201cbreak out\u201d of our tenant and read other tenants' data. How do we\ndo that?\n\nSince it\u2019s all appended to a URL, the idea was to leverage URL traversal to\ncancel out the prepended information added by the server, and then add our\nown:\n\n    \n    \n    GET /v4/test-301x6x6/integration/data-connections/%2F..%2FotherTenant(PartitionKey='DataConnection',RowKey='1679126391688/\n\nAs you can see, we encoded the slashes (%2F) which were injected into the URL,\neffectively turning the request into:\n\n    \n    \n    https://hbstenant2steausprod.table.core.windows.net/test301x6x6(PartitionKey=\u2019DataConnection\u2019,RowKey=\u20191679070537717/../otherTenant(PartitionKey='DataConnection',RowKey='1679126391688')\n\nAnd voila! This request successfully returned the connection data of the other\ntenant.\n\n## Hacking The Bot Backend - 3 ways to pwn the Node.js vm2 sandbox\n\nExploring further into the service, we saw that you can execute your\nJavaScript code in an isolated environment. This feature lets you process data\ncoming from the chat as part of the conversation with the end customer.\n\nWe started by doing simple JS recon inside the sandbox - looking at global\nvariables, we figured we were running inside a vm2 sandbox, a popular Node.js\nsandboxing library that has since been discontinued due to multiple, unrelated\nsecurity flaws.\n\nThe goal was simple: to be able to execute shell commands and try to find a\nway to access cross-tenant data.\n\nHow do you usually execute shell commands with Node.js? Simple, you import the\nchild_process module and call exec/execSync:\n\n    \n    \n    require('child_process').execSync('id')\n\nBut you didn\u2019t think it\u2019d be that easy, did you? In general, require inside\nthe vm2 sandbox is a patched version that doesn\u2019t let you import anything\nharmful. However, Microsoft wanted to provide a few standard modules to make\nyour life easier. So what we have is a custom require function, which has a\nvery specific whitelist of boring modules.\n\nBut we wanted to understand what\u2019s going on under the hood. Lucky for us,\nJavascript lets you view the source code of any function. You call .toString()\non the function, and voila, you get the source code:\n\n    \n    \n    (packageName) => { // Do binary search in the allow list of packages if (packagesAllowedList && _.indexOf(packagesAllowedList, packageName, true) < 0) { throw new Error(`**Usage of the '${packageName}' package is not allowed. Please contact your system administrator**`); } return require(packageName); }\n\nLooks pretty harmless at first glance. It\u2019s a simple check if the required\nmodule is in the whitelisted array, and if it is, the original Node.js require\nfunction will be called.\n\nWell, if you look closer, they called _.indexOf() instead of the native array\nindexOf function for some reason. And _.indexOf() is a function from the\nunderscore module. Which is whitelisted. Can you see where we\u2019re going with\nthis?\n\nBypassing the whitelist and achieving remote code execution is no problem when\nyou can just override the indexOf function, which is conveniently already\npresent as a global, you don\u2019t even need to import it.\n\n    \n    \n    underscore.indexOf=function(){ return 10; }; // Always return 10 - bypass the if condition require('child_process').execSync('id') // Code executed!\n\nAnd then:\n\nSince that backend is shared, we were running as root inside a server that\nprocessed the chats of other customers. All research was done in the \u201cdebug\u201d\nenvironment and was done carefully to not expose any sensitive information.\n\nMicrosoft quickly patched the bug within 24 hours, but we\u2019re not done with\nthis sandbox yet.\n\n#### Underscore strikes again\n\nAfter Microsoft patched the require() flaw, we dove deeper into understanding\nthe mechanics of the vm2 sandbox. We knew that the modules that are\nwhitelisted are part of the unisolated Node.js root context, the idea was to\nlook into each module individually and try to find interesting functionalities\nthat can be abused.\n\nWe spent a few hours reading the documentation and code of all whitelisted\nmodules, most of them were just boring data parsing libraries that didn\u2019t\nhelp. But then something in Underscore.js caught our attention:\n\nHmm, a function that compiles JavaScript templates, with an arbitrary code\nexecution feature. We\u2019re sensing a pattern here.\n\nTo understand why it\u2019s interesting, you need to understand a simple concept of\nhow the vm2 sandboxing works. In simple terms, they create a \u201cbridge\u201d between\nthe sandbox and the host, and everything you execute inside the sandbox goes\nthrough proxy functions which restrict what you can do to a very limited set\nof features.\n\nFor example, if we try to access the Node.js global \u201cprocess\u201d variable from\nwithin the sandbox, the variable won\u2019t be found as it\u2019s not part of the\nsandboxed context.\n\nHowever, when you pass down functions from the root context to the sandbox,\nthe code is already \u201ccompiled\u201d. It\u2019s usually pretty dangerous since code\ninside the sandbox can tamper with the modules and cause unexpected behavior\noutside the sandbox.\n\nBack to the template function, since the underscore module was passed down\nfrom outside the sandbox, the code will be compiled in the non-sandboxed\ncontext, therefore, we can achieve code execution simply:\n\n    \n    \n    let foo = underscore.template(\"<% print(this.process.mainModule.require('child_process').execSync('id')) %>\")\n\nMicrosoft quickly patched this as well, and we move on to the final flaw.\n\n#### A Distant Memory\n\nThis time we had to think a little bit \u201coutside the box\u201d since we were running\nout of interesting features in the whitelisted modules. We looked into the\n\u201cbuffer\u201d module which is a built-in Node.js module.\n\nThe thing that caught our attention was \u201cBuffer.allocUnsafe\u201d. This function\nlets you allocate an uninitialized memory buffer. To explain what it means in\nsimple terms, let's compare Buffer.alloc and Buffer.allocUnsafe:\n\n  * Buffer.alloc: will provide a memory buffer that is zeroed out. If we try to read from the allocated buffer, we\u2019ll get a bunch of zeroes.\n  * Buffer.allocUnsafe: faster than alloc, will provide a memory buffer that hasn\u2019t been zeroed out. That means that if the memory allocated was previously used for an HTTP request for example, we will be able to see the HTTP request by reading from the newly allocated buffer.\n\nThis is pretty dangerous since if we can use allocUnsafe inside the sandbox,\nwe might be able to access sensitive info from the memory of the application.\nThe vm2 developers were aware of this and restricted the use of\nBuffer.allocUnsafe.\n\nSince the entire buffer module was whitelisted, we had access to SlowBuffer,\nwhich is the same as allocUnsafe. This one was not restricted by the sandbox,\nsince it\u2019s not supposed to be there by default:\n\n    \n    \n    buffer = require('buffer') p = new buffer.SlowBuffer(10024) p.toString() // returns \u201cdirty\u201d uninitialized memory previously used in other areas of the app\n\nRunning this code a few times yielded interesting data from the application,\nfor example, a few JWT secrets for internal Azure identities, Kubernetes API\ncalls, cross-tenant data, and more.\n\nAfter that, Microsoft made multiple important security changes:\n\n  * They had changed the service architecture to run a completely separate ACI instance per customer. Making any future sandbox breach irrelevant.\n  * They changed the sandboxing from vm2 to the isolated-vm library, which uses V8 isolates, a much better and more secure solution.\n\n#### Final Words\n\nThis marks the first publication from Breachproof. We aim to publish a lot of\nmore quality research that has real impact. Much more is coming.\n\nIf you're a company dealing with sensitive data and need help securing it -\nfeel free to contact us.\n\nAuthored by Yanir Tsarimi\n\n\u00a9 2024 Breachproof. All rights reserved\n\n", "frontpage": false}
