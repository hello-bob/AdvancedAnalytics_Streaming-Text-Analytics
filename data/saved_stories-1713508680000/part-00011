{"aid": "40079959", "title": "C++ chrono-compatible low-level date algorithms. (2022)", "url": "http://howardhinnant.github.io/date_algorithms.html", "domain": "howardhinnant.github.io", "votes": 2, "user": "fanf2", "posted_at": "2024-04-18 19:42:04", "comments": 0, "source_title": "chrono-Compatible Low-Level Date Algorithms", "source_text": "chrono-Compatible Low-Level Date Algorithms\n\nHoward Hinnant 2021-09-01\n\n# chrono-Compatible Low-Level Date Algorithms\n\n## Contents\n\n  * Introduction\n  * days_from_civil\n  * civil_from_days\n  * is_leap\n  * last_day_of_month_common_year\n  * last_day_of_month_leap_year\n  * last_day_of_month\n  * weekday_from_days\n  * weekday_difference\n  * next_weekday\n  * prev_weekday\n  * Yes, but how do you know this all really works?\n  * What can I do with that chrono compatibility?\n  * Example: Finding nth weekday of month\n  * Example: Converting between the civil calendar and the ISO week calendar\n  * Example: Converting between the civil calendar and the Julian calendar\n  * How can I confirm that your assertions about chrono compatibility are correct?\n  * Summary\n  * Acknowledgments\n\n## Introduction\n\nThe purpose of this paper is not to propose a date class. For an example date\nlibrary based on these algorithms see date v2.\n\nThis paper derives and documents key algorithms that enable one to write their\nown date class. The purpose of this paper is to allow everyone to easily write\ntheir own date class, using algorithms that are well documented, and easily\nmodified to meet individual needs. The algorithms presented are efficient.\nThey require no external tables. They do not require C++11 or C++1y features,\nthough if C++11 is available, the algorithms should be noexcept, and if C++1y\nis available, they can trivially be made constexpr.\n\nThis paper does not document a library. It is a how-to manual for writing the\nalgorithm part of your own date class. The syntax and some of the language\nfeatures come from C++11 and even C++1y. However the algorithms can be ported\nto any language.\n\nThe algorithms are interoperable with every known implementation of\nstd::chrono::system_clock, though that interoperability depends on an\nunspecified property of the system_clock: its epoch. Example code will be\nshown how these algorithms can take advantage of the common (but unspecified)\nsystem_clock epoch.\n\nThe algorithms implement a proleptic Gregorian calendar. That is, the rules\nwhich adopted the Julian calendar in 1582 in Rome are applied both backwards\nand forwards in time. This includes a year 0, and then negative years before\nthat, all following the rules for the Gregorian calendar. From hence forth\nthis paper will refer to this as the civil calendar. The accuracy of the\nalgorithms under these rules is exact, until overflow occurs. Using 32 bit\narithmetic, overflow occurs approximately at +/- 5.8 million years. Using 64\nbit arithmetic overflow occurs far beyond +/- the age of the universe. The\nintent is to make range checking superfluous.\n\nThe algorithms implement no validity checking. The intent is that any desired\nvalidity checking on the triple year/month/day can be added on top of these\nalgorithms if and where desired.\n\nTen low-level algorithms are presented:\n\n  1. Convert from a year/month/day triple to a serial day number.\n\n> >     template <class Int> constexpr Int days_from_civil(Int y, unsigned m,\n> unsigned d) noexcept;\n\n  2. Convert from a serial day number to a year/month/day triple.\n\n> >     template <class Int> constexpr std::tuple<Int, unsigned, unsigned>\n> civil_from_days(Int z) noexcept;\n\n  3. Determine if a year is a leap year.\n\n> >     template <class Int> constexpr bool is_leap(Int y) noexcept;\n\n  4. Given the month, return the last day of the month of a common year.\n\n> >     constexpr unsigned last_day_of_month_common_year(unsigned m) noexcept;\n\n  5. Given the month, return the last day of the month of a leap year.\n\n> >     constexpr unsigned last_day_of_month_leap_year(unsigned m) noexcept;\n\n  6. Given the year and month, return the last day of the month.\n\n> >     template <class Int> constexpr unsigned last_day_of_month(Int y,\n> unsigned m) noexcept;\n\n  7. Convert from a serial day number to a day of the week.\n\n> >     template <class Int> constexpr unsigned weekday_from_days(Int z)\n> noexcept;\n\n  8. Subtract one weekday from another (e.g. Sun - Sat is 1, and Sat - Sun is 6).\n\n> >     constexpr unsigned weekday_difference(unsigned x, unsigned y)\n> noexcept;\n\n  9. Get the weekday following a weekday (e.g. Mon follows Sun).\n\n> >     constexpr unsigned next_weekday(unsigned wd) noexcept;\n\n  10. Get the weekday prior to a weekday (e.g. Sat comes before Sun).\n\n> >     constexpr unsigned prev_weekday(unsigned wd) noexcept;\n\nThe algorithms are templated on year number type and serial day number type so\nthat you can easily vary the range (use int, long long, big_num, or whatever).\nFor those fields that are known to be unsigned and small (e.g. month) unsigned\nis used. Feel free to substitute any type you like. The use of unsigned is\njust to demonstrate that this particular field is constrained in the algorithm\nto always remain within a non-negative range.\n\nBuilding upon these low-level algorithms, higher-level algorithms can easily\nbe written, and this paper shows several examples of such higher-level\nalgorithms.\n\n## days_from_civil\n\nFirst the algorithm, and then the explanation:\n\n>\n>     // Returns number of days since civil 1970-01-01. Negative values\n> indicate // days prior to 1970-01-01. // Preconditions: y-m-d represents a\n> date in the civil (Gregorian) calendar // m is in [1, 12] // d is in [1,\n> last_day_of_month(y, m)] // y is \"approximately\" in //\n> [numeric_limits<Int>::min()/366, numeric_limits<Int>::max()/366] // Exact\n> range of validity is: // [civil_from_days(numeric_limits<Int>::min()), //\n> civil_from_days(numeric_limits<Int>::max()-719468)] template <class Int>\n> constexpr Int days_from_civil(Int y, unsigned m, unsigned d) noexcept {\n> static_assert(std::numeric_limits<unsigned>::digits >= 18, \"This algorithm\n> has not been ported to a 16 bit unsigned integer\");\n> static_assert(std::numeric_limits<Int>::digits >= 20, \"This algorithm has\n> not been ported to a 16 bit signed integer\"); y -= m <= 2; const Int era =\n> (y >= 0 ? y : y-399) / 400; const unsigned yoe = static_cast<unsigned>(y -\n> era * 400); // [0, 399] const unsigned doy = (153*(m > 2 ? m-3 : m+9) + 2)/5\n> + d-1; // [0, 365] const unsigned doe = yoe * 365 + yoe/4 - yoe/100 + doy;\n> // [0, 146096] return era * 146097 + static_cast<Int>(doe) - 719468; }  \n>  \n> ---  \n  \nAs explained in the introduction, the type of year is templated so that you\ncan easily set your own range based on your own needs. And if you dislike the\nuse of unsigned for month and day, please change them to whatever suits you.\nDoing so will not impact the correctness of the algorithm. And if you're not\ncompiling under C++1y constexpr rules, you will need to remove (or comment\nout) the constexpr. If you are compiling in C++98/03 you can substitute\nthrow() for noexcept, or remove the exception specification entirely.\n\nThe first two algorithms also do some static checking on the range of Int and\nunsigned. It is possible to port these algorithms to a 16 bit machine. It just\ninvolves being more careful with casts, and the use of integral types that are\nknown to be at least 32 bits in a few key places. For the purposes of\npresentation, and because it has been a long time since I've personally come\nin contact with a 16 bit machine, I've chosen to assume the machine is at\nleast 32 bits, but documented that assumption with static_assert. If you are\ninterested in porting these algorithms to a 16 bit machine, then you need to\npay attention to the lines which are commented with the ranges of the variable\nbeing computed.\n\nThese algorithms internally assume that March 1 is the first day of the year.\nThis is convenient because it puts the leap day, Feb. 29 as the last day of\nthe year, or actually the preceding year. That is, Feb. 15, 2000, is\nconsidered by this algorithm to be the 15th day of the last month of the year\n1999. Don't worry, this complication is securely encapsulated in this and the\nother algorithms. This detail is only important for understanding how the\nalgorithm works, and is not exposed to the client of these algorithms.\n\nAdditionally the first two algorithms make use of the concept of an era. This\nconcept is not exposed to the client, but is very handy in creating an\nalgorithm that is valid over extremely large ranges. In these algorithms, an\nera is a 400 year period. As it turns out, the civil calendar exactly repeats\nitself every 400 years. And so these algorithms will first compute the era of\na year/month/day triple, or the era of a serial date, and then factor the era\nout of the computation. The rest of the computation centers on concepts such\nas:\n\n  * What is the year of the era (yoe)? This is always in the range [0, 399].\n  * What is the day of the era (doe)? This is always in the range [0, 146096].\n\nThe wonderful thing about this approach is that you only need to debug a\nsingle era (146097 days), and the transformation to and from eras, and then\nyou have all time debugged. Below is a table of eras mapped to civil dates.\nNote that in this table the year number is the civil year number for Jan. and\nFeb., not the internal year number used within the algorithm.\n\n> era| start date| end date  \n> ---|---|---  \n> -2| -0800-03-01| -0400-02-29  \n> -1| -0400-03-01| 0000-02-29  \n> 0| 0000-03-01| 0400-02-29  \n> 1| 0400-03-01| 0800-02-29  \n> 2| 0800-03-01| 1200-02-29  \n> 3| 1200-03-01| 1600-02-29  \n> 4| 1600-03-01| 2000-02-29  \n> 5| 2000-03-01| 2400-02-29  \n  \nSo the first thing the days_from_civil algorithm does is transform the year\nnumber to the internal one for Jan. and Feb. And then the era is computed. For\nnon-negative years, the era is simply y/400. But for negative years one has to\nbe careful that years [-400, -1] map to era -1. By using floored or Euclidean\ndivision, negative years are correctly accounted for. Also note that in\nC++98/03 it is implementation defined whether integral division is implemented\nas truncated, floored or Euclidean. Only C++11 specifies truncated division.\nSo if you are using a C++98/03 compiler that implements floored or Euclidean\ndivision you can actually simplify the computation of the era to simply y /\n400. Again, once the algorithm takes negative years into account in this one\nplace, everything else can be done with unsigned arithmetic: everything else\nis non-negative.\n\nOnce the era is known (this is generally a signed number of unknown range),\nthe year-of-era can easily be computed by subtracting off the year from era *\n400. This is the same as the modulo operation, but assuming floored or\nEuclidean division, as opposed to the truncated division/modulo operation that\nC++11 specifies. This will result in an unsigned number in the range of [0,\n399], whether the era is negative or non-negative.\n\nAt the same time as the yoe computation is happening, we can also compute the\nday-of-year (doy) which is an unsigned number in the range of [0, 364] for a\nnon-leap year, and for leap years has a range of [0, 365]. A value of 0\ncorresponds to Mar 1, and a value of 364 corresponds to Feb. 28 of the\nfollowing (civil) year.\n\nThe doy computation is quite unintuitive and deserves an in-depth explanation.\n\n> ### Computing day-of-year from month and day-of-month\n>\n> We need a formula that maps Mar. 1 to 0, Mar. 2 to 1, etc. up to Feb. 29 of\n> the following year to 365. This computation can be broken down into several\n> parts:\n>\n>   * Map civil month number [1, 12] (Jan. - Dec.) into the internal month\n> numbering [0, 11] (Mar. - Feb.).\n>   * Compute the number of days between Mar. 1 and the first day of the\n> current month.\n>   * Add the number of days between the current day of the month and the\n> first day of the current month.\n>\n\n>\n> Let's start with the second bullet: Map a month number m' in the range [0,\n> 11] (Mar. - Feb.) into a range such that the first day of the month m' is x\n> number of days after Mar. 1.\n>\n> This can be exactly expressed as a table:\n>\n\n>> month| m'| days after m'-01  \n>> ---|---|---  \n>> Mar| 0| 0  \n>> Apr| 1| 31  \n>> May| 2| 61  \n>> Jun| 3| 92  \n>> Jul| 4| 122  \n>> Aug| 5| 153  \n>> Sep| 6| 184  \n>> Oct| 7| 214  \n>> Nov| 8| 245  \n>> Dec| 9| 275  \n>> Jan| 10| 306  \n>> Feb| 11| 337  \n>  \n> However we would like to translate this table into a linear polynomial.\n>\n\n>> a1 m' + a0\n\n>\n> Note that a beautiful property of this table is that it does not depend upon\n> whether or not the current year is a leap year. The leap day is either\n> applied to the end of the last month in the table or not, and can not impact\n> any rows in the table, not even the last row.\n>\n> The slope of this straight line can be easily computed by 337/11 ==\n> 30.63636363636364. However integral round off complicates this formula, and\n> the y-intercept of this linear equation can be manipulated to give the\n> desired results. Assume we have the following function but with known\n> constants for a1 and a0:\n>\n\n>>\n\n>>     int doy_from_month(int mp) { return a1 * mp + a0; }\n\n>\n> With this we can easily write a comprehensive unit test for doy_from_month:\n>\n\n>>\n\n>>     #include <cassert> // Returns day of year for 1st day of month mp, mp\n== 0 is Mar, mp == 11 is Feb. int doy_from_month(int mp) { return a1 * mp +\na0; } int main() { int a[12] = {0, 31, 61, 92, 122, 153, 184, 214, 245, 275,\n306, 337}; for (int mp = 0; mp < 12; ++mp) assert(doy_from_month(mp) ==\na[mp]); }\n\n>\n> If we make a1 == 30 or a1 == 31, there is no value for a0 we can assign to\n> make this unit test pass. However we can manipulate the y-intercept (a0) in\n> a very fine manner if we express the equation as:\n>\n\n>>\n\n>>     return (b1 * mp + b0) / a0;\n\n>\n> The first best guess is to make b1 == 337 and a0 == 11. However when doing\n> so there is no value of b0 that will pass the unit test. However if we make\n> b1 == 306 and a0 == 10 (i.e. 306/10 \u2248 30.63636363636364) then there are\n> actually two formulations that pass all unit tests:\n>\n>   * return (306 * mp + 4) / 10;\n>   * return (306 * mp + 5) / 10;\n>\n\n>\n> I first arbitrarily selected the second. However note that the first can be\n> simplified down to:\n>\n>   * return (153 * mp + 2) / 5;\n>\n\n>\n> For reasons I do not fully understand, this latter formula tests slightly\n> faster (about 2%) than the others.\n>\n> Now mp represents m' or the month number that starts with Mar == 0. We also\n> need to map the civil month number (Mar == 3) (m) to our internal month\n> number (mp). This can be done by adding 9 to m, and taking the modulus of\n> the result by 12:\n>\n\n>>\n\n>>     mp = (m + 9) % 12;\n\n>\n> This formula results in the following relationship:\n>\n\n>> m| 1| 2| 3| 4| 5| 6| 7| 8| 9| 10| 11| 12  \n>> ---|---|---|---|---|---|---|---|---|---|---|---|---  \n>> mp| 10| 11| 0| 1| 2| 3| 4| 5| 6| 7| 8| 9  \n>  \n> After some performance testing I discovered that replacing the % with a\n> branch was actually slightly faster, at least on the Core i5 I'm testing on:\n>\n\n>>\n\n>>     mp = m + (m > 2 ? -3 : 9);\n\n>\n> Putting this together we now have a formula for taking a civil month number\n> and computing the number of days between the first of that month, and Mar 1:\n>\n\n>>\n\n>>     (153*(m + (m > 2 ? -3 : 9)) + 2)/5\n\n>\n> Now to get the day-of-year from the double month/day one simply adds the\n> day-of-the-month, minus 1:\n>\n\n>>\n\n>>     const unsigned doy = (153*(m + (m > 2 ? -3 : 9)) + 2)/5 + d - 1;\n\n>\n> One can spot-check this formula in a few places:\n>\n\n>> m| 3| 2| 2  \n>> ---|---|---|---  \n>> d| 1| 29| 28  \n>> doy| 0| 365| 364  \n  \nNow given year-of-era (yoe) and day-of-year (doy), we can easily calculate the\nday-of-era (doe). This is simply 365 days for every year, plus another day for\nevery 4 years, minus a day for every hundred years, plus the day-of-year:\n\n>\n>     const unsigned doe = yoe * 365 + yoe / 4 - yoe / 100 + doy;\n\nThose familiar with this particular computation might question the lack of the\nterm:\n\n>\n>     + yoe / 400\n\nin the above formula. It would actually be correct to put it in. However note\nthat yoe is always in the range [0, 399], and so the contribution of this term\nis always 0.\n\nThe final computation in days_from_civil is computing the serial date from the\nera and from the day-of-era (doe). This is simply:\n\n>\n>     return era * 146097 + static_cast<Int>(doe)\n\nwhich gives the number of days, before, or after, 0000-03-01. However note\nthat I've also subtracted 719468 from this final computation in the actual\ndays_from_civil code. This is a shift which aligns this algorithm with all\nknown implementations of std::chrono::system_clock. It makes the serial date 0\nbe equivalent to 1970-01-01 instead of 0000-03-01.\n\nAll known implementations of std::chrono::system_clock count seconds from\n1970-01-01, neglecting leap seconds. This is known as unix time.\nImplementations are not required by the standard to use this measure. But it\ncan be handy to take advantage of it.\n\n## civil_from_days\n\nNow that we can use days_from_civil to convert a year/month/day triple into a\nserial date, it is really handy to be able to go the other way: convert a\nserial date into a year/month/day triple. And this is exactly what\ncivil_from_days does. First the algorithm, and then the explanation:\n\n>\n>     // Returns year/month/day triple in civil calendar // Preconditions: z\n> is number of days since 1970-01-01 and is in the range: //\n> [numeric_limits<Int>::min(), numeric_limits<Int>::max()-719468]. template\n> <class Int> constexpr std::tuple<Int, unsigned, unsigned>\n> civil_from_days(Int z) noexcept {\n> static_assert(std::numeric_limits<unsigned>::digits >= 18, \"This algorithm\n> has not been ported to a 16 bit unsigned integer\");\n> static_assert(std::numeric_limits<Int>::digits >= 20, \"This algorithm has\n> not been ported to a 16 bit signed integer\"); z += 719468; const Int era =\n> (z >= 0 ? z : z - 146096) / 146097; const unsigned doe =\n> static_cast<unsigned>(z - era * 146097); // [0, 146096] const unsigned yoe =\n> (doe - doe/1460 + doe/36524 - doe/146096) / 365; // [0, 399] const Int y =\n> static_cast<Int>(yoe) + era * 400; const unsigned doy = doe - (365*yoe +\n> yoe/4 - yoe/100); // [0, 365] const unsigned mp = (5*doy + 2)/153; // [0,\n> 11] const unsigned d = doy - (153*mp+2)/5 + 1; // [1, 31] const unsigned m =\n> mp < 10 ? mp+3 : mp-9; // [1, 12] return std::tuple<Int, unsigned,\n> unsigned>(y + (m <= 2), m, d); }  \n>  \n> ---  \n  \nMany of the same concepts used in developing days_from_civil are reused here.\nIf you've skipped that section because you're just interested in this\nalgorithm, you may want to go back and read it anyway, as the concepts will\nnot be re-explained here.\n\nThe first step in the computation is to shift the epoch from 1970-01-01 to\n0000-03-01:\n\n>\n>     z += 719468;\n\nNow we can compute the era from the serial date by simply dividing by the\nnumber of days in an era (146097). Again floored or Euclidean division must be\nused to correctly handle negative days.\n\n>\n>     const Int era = (z >= 0 ? z : z - 146096) / 146097;\n\nThe day-of-era (doe) can then be found by subtracting the era number times the\nnumber of days per era, from the serial date. This is the same as the modulo\noperation, but assuming floored or Euclidean division. This always results in\na doe in the range [0, 146096].\n\n>\n>     const unsigned doe = static_cast<unsigned>(z - era * 146097);\n\nFrom the day-of-era (doe), the year-of-era (yoe, range [0, 399]) can be\ncomputed. This formula can be derived one piece at a time. To start, the yoe\ncan be approximated by simply dividing doe by 365:\n\n>\n>     const unsigned yoe = doe / 365;\n\nThis is actually correct for doe in the range [0, 1459], yielding a yoe in the\nrange of [0, 3]. However 1460 / 365 is 4. But there are 1461 days in the first\n4 years of an era (4*365+1), which are labeled as years 0 thru 3. So we must\nalter the formula so that 1460 (the last day of year 3) results in 3, but 1461\n(the first day of year 4) results in 4:\n\n>\n>     const unsigned yoe = (doe - doe / 1460) / 365;\n\nNow the formula is accurate for doe in the range [0, 36523], yielding a yoe in\nthe range of [0, 99]. but the first hundred years of an era has 36524 days in\nit (365 * 100 + 100/4 - 1 == 36524). 36524 (the first day of year 100) should\nyield 100, but instead yields 99 in the above formula which is incorrect. To\ncorrect this the formula can be augmented again:\n\n>\n>     const unsigned yoe = (doe - doe/1460 + doe/36524) / 365;\n\nNow inputing 36524 yields 100. And indeed the formula is now correct up until\nthe very last day in an era, day number 146096. On this day, the last day of\nthe era, and the last day of year 399, the above formula yields 400 instead of\n399. The formula can be made exact for every day in the era with one more\nadjustment:\n\n>\n>     const unsigned yoe = (doe - doe/1460 + doe/36524 - doe/146096) / 365;\n\nGiven year-of-era, and era, one can now compute the year number:\n\n>\n>     const Int y = static_cast<Int>(yoe) + era * 400;\n\nNote though that this year number is still in terms of a year that begins on\nMar. 1, not Jan. 1.\n\nAlso the day-of-year, again with the year beginning on Mar. 1, can be computed\nfrom the day-of-era and year-of-era. One simply subtracts from the day-of-era\nthe days that have occurred in all prior years of this era:\n\n>\n>     const unsigned doy = doe - (365 * yoe + yoe / 4 - yoe / 100);\n\nAgain note the absence of the correct term + yoe / 400 because the\ncontribution of this term is always zero since 399 is the upper range of yoe.\n\n> ### Computing month from day-of-year\n>\n> When developing days_from_civil we had to develop a linear equation to\n> compute the day-of-year from the first day of month m' where m' is in the\n> range [0, 11] representing [Mar, Feb].\n>\n\n>>\n\n>>     int doy_from_month(int mp) { return (153 * mp + 2) / 5; }\n\n>\n> Now we need the inverse of this formula: Given day-of-year, we need to find\n> the month number. If integral arithmetic was exact, the derivation would be\n> straight forward algebra and we would get:\n>\n\n>>\n\n>>     int month_from_doy(int doy) { return (5 * doy - 2) / 153; }\n\n>\n> Before accepting this as the correct answer, it is wise to build a unit test\n> for this function. The one developed for doy_from_month can easily be\n> augmented to test both of these functions at the same time:\n>\n\n>>\n\n>>     int main() { int a[12][2] = { {0, 30}, {31, 60}, {61, 91}, {92, 121},\n{122, 152}, {153, 183}, {184, 213}, {214, 244}, {245, 274}, {275, 305}, {306,\n336}, {337, 365} }; for (int mp = 0; mp < 12; ++mp) {\nassert(doy_from_month(mp) == a[mp][0]); assert(month_from_doy(a[mp][0]) ==\nmp); assert(month_from_doy(a[mp][1]) == mp); } }\n\n>\n> The pair of numbers in a are the first and last numbers of the day-of-year\n> for each month in [0, 11]. We already have a function doy_from_month(mp)\n> which computes the starting day-of-year for each month, and tested by the\n> first assert in the program. And now two more asserts are added to test that\n> given both the first and last day of each month, month_from_doy can\n> transform that day-of-year into the correct month number mp.\n>\n> Running this test on the month_from_doy given above, we see that our first\n> attempt at derivation using simple algebra is incorrect. However it is\n> close. The slope of the linear equation is correct. We just need to\n> experiment with the y-intercept to discover the correct formula. There exist\n> three which will pass the above unit test:\n>\n>   * return (10*doy + 4) / 306;\n>   * return ( 5*doy + 2) / 153;\n>   * return (10*doy + 5) / 306;\n>\n\n>\n> I've chosen the second for use in civil_from_days because it appears to have\n> a slight performance advantage:\n\n>\n>     const unsigned mp = (5*doy + 2)/153;\n\nFrom day-of-year and month-of-year we can now easily compute day-of-month by\nreusing the doy_from_month formula developed for days_from_civil. One just\nsubtracts from the day-of-year all of the days that occurred in the previous\nmonths of this year. One is added to the result since the day count is 1-based\ninstead of 0-based.\n\n>\n>     const unsigned d = doy - (153*mp+2)/5 + 1;\n\nNext we need to transform the month number from the [0, 11] / [Mar, Feb]\nsystem to the civil system: [1, 12]. I've found that branching is faster than\nusing %:\n\n>\n>     const unsigned m = mp + (mp < 10 ? 3 : -9);\n\nNow the only thing left to do is to transform the year number from the\ninternal format (begins in Mar.) to the civil format (begins in Jan.). This is\ndone simply by adding 1 to the year if the month is Jan. or Feb. I've returned\nthis result in a std::tuple for no good reason at all. You should return the\ntriple year/month/day in whatever format is convenient for you.\n\n>\n>     return std::tuple<Int, unsigned, unsigned>(y + (m <= 2), m, d);\n\n## is_leap\n\nEven though the conversions between year/month/day and the serial date do not\nneed to compute whether or not a year is a leap year, it is still very handy\nto know whether or not a year is a leap year. This function answers that\nquestion. First the algorithm, and then the explanation:\n\n>\n>     // Returns: true if y is a leap year in the civil calendar, else false\n> template <class Int> constexpr bool is_leap(Int y) noexcept { return y % 4\n> == 0 && (y % 100 != 0 || y % 400 == 0); }  \n>  \n> ---  \n  \nThe formula is designed to return an answer as quickly as possible for a\nrandom year. 75.75% of all years are not leap years. We can find 99% of the\nnon-leap years with only one test: y % 4 != 0. If the year is not evenly\ndivisible by 4, then it is definitely not a leap year, and short circuiting\nwill cause a return at this point without evaluating the rest of the formula.\n\nOf the 25% of the years that are evenly divisibly by 4, these might be a leap\nyear. 96% of these 25% are and can be dispatched with a second test: y %100 !=\n0. If the year is evenly divisible by 4 and not evenly divisible by 100, then\nit is definitely a leap year, and short circuiting will return here for those\nyears. The remaining 4% of the 25% (or 1% of the total number of years)\nrequire one more test. These are years that are known to be divisible by 100.\nIf they are also evenly divisible by 400, then they are a leap year, else they\nare not.\n\nIn summary, given a uniformly distributed random year:\n\n> This percentage of the time| this will get executed  \n> ---|---  \n> 75%| y % 4 == 0, typically optimized to !(y & 0x3)  \n> 24%| (y % 4 == 0) && (y % 100 != 0)  \n> 1%| (y % 4 == 0) && (y % 100 != 0) && (y % 400 == 0)  \n  \n## last_day_of_month_common_year\n\nGiven a month, and with the assumption that this is a month in a common (non-\nleap) year, return the number of days in the month, or equivalently the day of\nthe last day of the month. First the algorithm, and then the explanation:\n\n>\n>     // Preconditions: m is in [1, 12] // Returns: The number of days in the\n> month m of common year // The result is always in the range [28, 31].\n> constexpr unsigned last_day_of_month_common_year(unsigned m) noexcept {\n> constexpr unsigned char a[] = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30,\n> 31}; return a[m-1]; }  \n>  \n> ---  \n  \nIf you know you have a common year, this is the fastest mapping I know of to\ntranslate the month into the last day of the month. unsigned char is used as\nthe table type as both a speed and size optimization.\n\n## last_day_of_month_leap_year\n\nGiven a month, and with the assumption that this is a month in a leap year,\nreturn the number of days in the month, or equivalently the day of the last\nday of the month. First the algorithm, and then the explanation:\n\n>\n>     // Preconditions: m is in [1, 12] // Returns: The number of days in the\n> month m of leap year // The result is always in the range [29, 31].\n> constexpr unsigned last_day_of_month_leap_year(unsigned m) noexcept {\n> constexpr unsigned char a[] = {31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30,\n> 31}; return a[m-1]; }  \n>  \n> ---  \n  \nIf you know you have a leap year, this is the fastest mapping I know of to\ntranslate the month into the last day of the month. unsigned char is used as\nthe table type as both a speed and size optimization.\n\n## last_day_of_month\n\nGiven a year and month, often one needs to quickly find out how many days are\nin the month. Or equivalently, what is the last day of the month. First the\nalgorithm, and then the explanation:\n\n>\n>     // Preconditions: m is in [1, 12] // Returns: The number of days in the\n> month m of year y // The result is always in the range [28, 31]. template\n> <class Int> constexpr unsigned last_day_of_month(Int y, unsigned m) noexcept\n> { return m != 2 || !is_leap(y) ? last_day_of_month_common_year(m) : 29u; }  \n>  \n> ---  \n  \nThe algorithm looks so simple that it hardly needs any explanation. However\nI'm going to bore you with one anyway. An early reviewer noted that sometimes\none already has the information that y is (or not) a leap year, and so taking\nadvantage of that information for performance reasons would be nice, instead\nof recomputing it within last_day_of_month. I found this argument compelling,\nand set off to measure how much time I could save.\n\nIt turns out that if one simply replaces Int y with bool is_leap in the above\nalgorithm, the savings is actually quite tiny. So tiny it is hard to measure.\nI was surprised by this result, however the basic concept that the reviewer\nhad: \"avoid is_leap(y) when possible,\" is sound. And this was the genesis of\nlast_day_of_month_common_year and last_day_of_month_leap_year.\n\n> First an analysis of the current implementation of last_day_of_month:\n>\n> Given a uniformly distributed y, and a uniformly distributed m in the range\n> [1, 12], the following table gives the odds of exactly what gets executed in\n> a call to last_day_of_month(y, m):\n>\n> This percentage of the time| this will get executed  \n> ---|---  \n> 912\u20443%| m != 2  \n> 61\u20444%| (m != 2) && (y % 4 == 0)  \n> 2%| (m != 2) && (y % 4 == 0) && (y % 100 != 0)  \n> ^1/_12%| (m != 2) && (y % 4 == 0) && (y % 100 != 0) && (y % 400 == 0)  \n>  \n> In English, over 91% of the time, neither the function is_leap(y), nor the\n> bool is_leap is even touched. Additionally in over 6% of the cases, the only\n> additional code is a % 4 which is typically optimized to a & 0x3. Bitwise-\n> ands are so fast they are practically free. So we're up to 97^11/_12% of the\n> time actually computing is_leap(y) is just as fast or very nearly just as\n> fast. In 2% of the cases, avoiding the is_leap(y) computation saves a %\n> operation. And in ^1/_12 of 1% of the cases, avoiding the is_leap(y)\n> computation saves two % operations. Although a % operation is a significant\n> expense, they happen so rarely in this code that this just isn't good enough\n> to justify another signature.\n\nHowever if one can remove all branches from an entire year's worth of calls to\nlast_day_of_month, then you've got a small but measurable performance\noptimization. For example if you're looping over all months in a year, then\nyou should be able to compute is_leap(y) exactly once, then branch exactly\nonce, and then get the number of days in each month with no further testing.\nAnd this is the reason last_day_of_month_common_year and\nlast_day_of_month_leap_year are introduced.\n\n## weekday_from_days\n\nThe day-of-the-week is most conveniently computed from the serial date. These\nformulas use the C and C++ convention that [0, 6] represents [Sun, Sat]. First\nthe algorithm, and then the explanation:\n\n>\n>     // Returns day of week in civil calendar [0, 6] -> [Sun, Sat] //\n> Preconditions: z is number of days since 1970-01-01 and is in the range: //\n> [numeric_limits<Int>::min(), numeric_limits<Int>::max()-4]. template <class\n> Int> constexpr unsigned weekday_from_days(Int z) noexcept { return\n> static_cast<unsigned>(z >= -4 ? (z+4) % 7 : (z+5) % 7 + 6); }  \n>  \n> ---  \n  \nThere are really two formulas, both based on doing % 7. When the lhs argument\nfor the % operator is not negative, then (z+4) % 7 has pleasing results.\nRecall that z == 0 corresponds to 1970-01-01. It is easily verified that this\nday was a Thursday. Thus weekday_from_days(0) should yield 4,\nweekday_from_days(1) should yield 5, and so on. (z+4) % 7 achieves this and it\nis easy to see will always be correct for all dates after 1970-01-01.\n\nGetting weekdays prior to 1970-01-01 requires a bit more work. But we can\nstart with weekday_from_days(-1) should yield 3 (the day before Thursday is\nWednesday). This actually works with (z+4) % 7, but stops working by the time\nwe get to weekday_from_days(-5), which should be 6 (Sat). Instead the formula\nyields -1. For these and all previous dates, after we % 7, giving a number in\nthe range [-6, 0], we need to add 6 to get the number back into the desired\nrange [0, 6]. And furthermore we need a new offset to ensure that\nweekday_from_days(-5) == 6. The formula (z+5) % 7 + 6 does the trick.\n\nThis is all equivalent to a modulo operation based on floored or Euclidean\ndivision. So if your C++98/03 compiler implements floored or Euclidean\ndivision (it may or may not), then you can simply return (z+4) % 7. If you are\nunsure, the unit tests below will detect the error if the code is inconsistent\nwith the compiler's definition of integral division.\n\n## weekday_difference\n\nIt turns out to be very handy to ask: Given two weekdays, how many days do you\nhave to increment to get from one to the other. This question has been cast in\nthe form of subtraction between two weekdays. First the algorithm, and then\nthe explanation:\n\n>\n>     // Preconditions: x <= 6 && y <= 6 // Returns: The number of days from\n> the weekday y to the weekday x. // The result is always in the range [0, 6].\n> constexpr unsigned weekday_difference(unsigned x, unsigned y) noexcept { x\n> -= y; return x <= 6 ? x : x + 7; }  \n>  \n> ---  \n  \nThis algorithm views the range [Sun, Sat] ([0, 6]) as a circular range. Once\nyou reach Sat, it is not the end of the range. Instead Sun is the next element\nin the range. And the cycle repeats. Given that, how many days do you need to\nadd to y to get x?\n\nThe algorithm takes advantage of the requirement that unsigned integers shall\nobey the laws of arithmetic modulo 2^n where n is the number of bits in the\nvalue representation of that particular size of integer. That is, if x -= y\n\"underflows\", it is brought back into range with + 7. Because this is unsigned\narithmetic, there is no undefined behavior.\n\nA higher-level library may choose to provide pre-condition checking prior to\ncalling this low-level algorithm.\n\nHere is a complete unit-test for this function:\n\n>\n>     #include <cassert> void test_weekday_difference() { constexpr unsigned\n> a[7][7] = {// - Sun Mon Tue Wed Thu Fri Sat /*Sun*/ {0, 6, 5, 4, 3, 2, 1},\n> /*Mon*/ {1, 0, 6, 5, 4, 3, 2}, /*Tue*/ {2, 1, 0, 6, 5, 4, 3}, /*Wed*/ {3, 2,\n> 1, 0, 6, 5, 4}, /*Thu*/ {4, 3, 2, 1, 0, 6, 5}, /*Fri*/ {5, 4, 3, 2, 1, 0,\n> 6}, /*Sat*/ {6, 5, 4, 3, 2, 1, 0} }; for (unsigned x = 0; x < 7; ++x) for\n> (unsigned y = 0; y < 7; ++y) assert(weekday_difference(x, y) == a[x][y]); }\n\n## next_weekday\n\nIt is convenient to find the next weekday in the circular range [Sun, Sat].\nFirst the algorithm, and then the explanation:\n\n>\n>     // Preconditions: wd <= 6 // Returns: The weekday following wd // The\n> result is always in the range [0, 6]. constexpr unsigned\n> next_weekday(unsigned wd) noexcept { return wd < 6 ? wd+1 : 0; }  \n>  \n> ---  \n  \nIf wd is not Sat, wd+1 is returned, else Sun is returned.\n\n## prev_weekday\n\nIt is convenient to find the previous weekday in the circular range [Sun,\nSat]. First the algorithm, and then the explanation:\n\n>\n>     // Preconditions: wd <= 6 // Returns: The weekday prior to wd // The\n> result is always in the range [0, 6]. inline constexpr unsigned\n> prev_weekday(unsigned wd) noexcept { return wd > 0 ? wd-1 : 6; }  \n>  \n> ---  \n  \nIf wd is not Sun, wd-1 is returned, else Sat is returned.\n\n## Yes, but how do you know this all really works?\n\nThese functions can and should be tested. Below is a very thorough unit test\nfor 7 of the ten functions:\n\n>\n>     #include <iostream> #include <chrono> #include <cassert>\n> static_assert(days_from_civil(1970, 1, 1) == 0, \"1970-01-01 is day 0\");\n> static_assert(civil_from_days(0) == std::make_tuple(1970, 1, 1), \"1970-01-01\n> is day 0\"); static_assert(weekday_from_days(days_from_civil(1970, 1, 1)) ==\n> 4, \"1970-01-01 is a Thursday\"); int main() { int ystart = -1000000; int\n> prev_z = days_from_civil(ystart, 1, 1) - 1; assert(prev_z < 0); int prev_wd\n> = weekday_from_days(prev_z); assert(0 <= prev_wd && prev_wd <= 6); auto t0 =\n> std::chrono::system_clock::now(); for (int y = ystart; y <= -ystart; ++y) {\n> for (unsigned m = 1; m <= 12; ++m) { unsigned e = last_day_of_month(y, m);\n> for (unsigned d = 1; d <= e; ++d) { int z = days_from_civil(y, m, d);\n> assert(prev_z < z); assert(z == prev_z+1); int yp; unsigned mp, dp;\n> std::tie(yp, mp, dp) = civil_from_days(z); assert(y == yp); assert(m == mp);\n> assert(d == dp); unsigned wd = weekday_from_days(z); assert(0 <= wd && wd <=\n> 6); assert(wd == next_weekday(prev_wd)); assert(prev_wd ==\n> prev_weekday(wd)); prev_z = z; prev_wd = wd; } } } auto t1 =\n> std::chrono::system_clock::now(); typedef std::chrono::duration<float> sec;\n> std::cout << sec(t1-t0).count() << '\\n'; std::cout <<\n> days_from_civil(1000000, 12, 31) - days_from_civil(-1000000, 1, 1) << '\\n';\n> }\n\nFirst some static_asserts are performed to nail down some basics. If your\ncompiler does not support the C++1y constexpr rules, you will need to verify\nthese at run time with assert instead. The static_asserts confirm that\n1970-01-01 is day 0, and that this day is a Thursday.\n\nIn main() I've chosen to test every day between -1,000,000-01-01 and\n1,000,000-12-31. This is a total of 730,485,366 days, spanning a range far\ngreater than the civil calendar is actually valid. So the test is overkill.\nHowever one of the goals of these formulas is to not burden the client with\nthe need to range check, or worry about the range of validity of the formulas.\nAll the user really has to worry about is if he really should be using the\ncivil calendar for the Jurassic period (certainly possible when these\nfunctions are instantiated with long long).\n\nThe test loops over each year, each month of each year, and each day of each\nmonth. It computes the serial date from each year/month/day triple and ensures\nthat this is 1 greater than the previous iteration. It then converts the\nserial date back to a year/month/day triple and ensures that this is the same\ntriple it started this iteration with. And finally the test ensures that the\nweekday for this date is one day later in the week than was the weekday for\nthe previous iteration.\n\nI've also timed the entire test. On my machine (2.8 GHz Intel Core i5 iMac)\nthis executes at -O3 in about 17.1 seconds which means it is testing each date\nin about 23.4 ns. These functions are not slow.\n\n## What can I do with that chrono compatibility?\n\nHere is a short program that prints out the current local date and time\nwithout going through the C interface:\n\n>\n>     #include <iomanip> #include <iostream> #include <chrono> int main() {\n> using namespace std; using namespace std::chrono; typedef duration<int,\n> ratio_multiply<hours::period, ratio<24>>> days; auto utc_offset = hours(-4);\n> // my current UTC offset // Get duration in local units auto now =\n> system_clock::now().time_since_epoch() + utc_offset; // Get duration in days\n> auto today = duration_cast<days>(now); int year; unsigned month; unsigned\n> day; // Convert days into year/month/day std::tie(year, month, day) =\n> civil_from_days(today.count()); // Subtract off days, leaving now containing\n> time since local midnight now -= today; auto h = duration_cast<hours>(now);\n> now -= h; auto m = duration_cast<minutes>(now); now -= m; auto s =\n> duration_cast<seconds>(now); now -= s; auto us =\n> duration_cast<microseconds>(now); cout.fill('0'); cout << \"Today is \" <<\n> year << '-' << setw(2) << month << '-' << setw(2) << day << \" at \" <<\n> setw(2) << h.count() << ':' << setw(2) << m.count() << ':' << setw(2) <<\n> s.count() << '.' << setw(6) << us.count() << '\\n'; }\n\nFor me this outputs:\n\n>\n>     Today is 2013-08-04 at 20:21:22.043095\n\nI've used civil_from_days to turn a chrono::duration obtained from\nsystem_clock::now() into a year/month/day triple. For grins I've also\nsubtracted off the days from the duration to get the hours, subtracted off the\nhours to get minutes, and subtracted off the minutes to get seconds, so I can\nprint out the current time along with the current date. On my system I can\neven print the current time with microsecond accuracy if I want (something not\neven possible with the C interface).\n\nOne can also go the other way: Specify a date in terms of a year/month/day\ntriple and then convert that into a system_clock::time_point:\n\n>\n>     int main() { using namespace std; using namespace std::chrono; typedef\n> duration<int, ratio_multiply<hours::period, ratio<24>>> days; auto\n> utc_offset = hours(-4); // Build a time point in local days::hours::minutes\n> and then convert to UTC auto wakeup_at =\n> system_clock::time_point(days(days_from_civil(2013, 8, 4)) + hours(20) +\n> minutes(59) - utc_offset); this_thread::sleep_until(wakeup_at);\n> print_current_date_time(); } Today is 2013-08-04 at 20:59:00.021702\n\n## Example: Finding nth weekday of month\n\nweekday_difference is handy for computing dates like the 4th Saturday in May,\nor the last Sunday of Jun. For an example of the former consider:\n\n>\n>     std::tuple<int, unsigned, unsigned> get_nth_dow_month_year(unsigned n,\n> unsigned wd, unsigned month, int year) { // Do validation here assert(n <=\n> 4); // We could possibly allow n == 5, but it would sometimes fail assert(wd\n> <= 6); assert(1 <= month && month <= 12); const unsigned wd_1st =\n> weekday_from_days(days_from_civil(year, month, 1)); const unsigned day =\n> weekday_difference(wd, wd_1st) + 1 + (n-1)*7; return std::tuple<int,\n> unsigned, unsigned>(year, month, day); }\n\nFirst compute the weekday of the first day of the month. Then add to the first\nday of the month the difference between the weekday you want and the weekday\nyou have. This will be some number between 0 and 6. And then add to that n-1\nweeks. Now you have a year/month/day triple. If instead you wanted to return a\nsystem_clock::time_point, that is just as easy:\n\n>\n>     std::chrono::system_clock::time_point get_nth_dow_month_year(unsigned n,\n> unsigned wd, unsigned month, int year) { // Do validation here // Don't\n> actually need to check n assert(wd <= 6); assert(1 <= month && month <= 12);\n> using namespace std; using namespace std::chrono; typedef duration<int,\n> ratio_multiply<hours::period, ratio<24>>> days; int d =\n> days_from_civil(year, month, 1); const unsigned wd_1st =\n> weekday_from_days(d); d += weekday_difference(wd, wd_1st) + (n-1)*7; return\n> system_clock::time_point(days(d)); }\n\nIf you are wanting to get the last weekday of a month, this is also very easy\nusing weekday_difference:\n\n>\n>     std::tuple<int, unsigned, unsigned> get_last_dow_month_year(unsigned wd,\n> unsigned month, int year) { // Do validation here assert(wd <= 6); assert(1\n> <= month && month <= 12); const unsigned last = last_day_of_month(year,\n> month); const unsigned wd_last = weekday_from_days(days_from_civil(year,\n> month, last)); const unsigned day = last - weekday_difference(wd_last, wd);\n> return std::tuple<int, unsigned, unsigned>(year, month, day); }\n\nYou simply compute the weekday of the last day of the month, and then use\nweekday_difference to find the number of days that need to be subtracted from\nthe last day of the month to get to the desired weekday.\n\nIn some circumstances you might want to find the next weekday, not counting\nthe \"current day\". For example you may need the next Thu from today, and if\ntoday is a Thu, you need a week from today, not today. In this use case,\ncombining weekday_difference with next_weekday is very handy:\n\n>\n>     int meeting_day = tomorrow + weekday_difference(desired_weekday,\n> next_weekday(todays_weekday));\n\nWhere tomorrow is just today+1 and todays_weekday is today's weekday.\n\n## Example: Converting between the civil calendar and the ISO week calendar\n\nThese algorithms can be used to easily convert between the civil calendar and\nthe ISO week-based calendar. The ISO rules for this calendar are:\n\n  1. The week starts with Monday, and ends with Sunday.\n  2. The first day of the year is the Monday that occurs on or before Jan. 4.\n  3. A date is specified by the week number [1 - 53], day of the week [Mon - Sun] and year number.\n  4. The year number is the same as the civil year number for the Thursday that follows the start of the week-based year.\n\n     * This makes it possible for a day in the week-based year to have a different year number than in the civil calendar for that day.\n\nISO 8601 gives two examples:\n\n  1. Sunday Jan. 1, 1995 is the Sunday of week 52 of the year 1994. (Week 1 of 1995 starts on Monday Jan. 2, 1995)\n  2. Tuesday Dec. 31, 1996 is the Tuesday of week 1 of the year 1997. (The first day of the week-based year 1997 begins on Monday Dec. 30, 1996, which is the first Monday on or before Jan. 4, 1997, a Saturday)\n\nHere are functions for converting from year/month/day to year/week/weekday and\nback. It is first convenient to create a function that finds the \"time_point\"\n(count of days since epoch) of the first day of the week-based year given the\nyear number. This year number is actually the week-based year number, not the\ncivil year number:\n\n>\n>     int iso_week_start_from_year(int y) { const unsigned Monday = 1; const\n> unsigned Jan = 1; const int tp = days_from_civil(y, Jan, 4); const unsigned\n> wd = weekday_from_days(tp); return tp -\n> static_cast<int>(weekday_difference(wd, Monday)); }\n\nTo ease confusion and allow reuse of the code we've developed, we continue to\nencode our days [Sun, Sat] as [0, 6], despite the fact that Sun/0 is now the\nlast day of the week instead of the first.\n\nGiven the tools in our toolbox, this function is remarkably easy to create\nfrom rule 2 above:\n\n  1. Turn y-01-04 into a serial date.\n  2. Get the weekday of y-01-04.\n  3. Subtract off the number of days the current weekday is past Monday.\n\nUsing the iso_week_start_from_year helper function, it is now easy to convert\nfrom year/month/day to year/week_number/week_day:\n\n>\n>     // year, week[1, 53], weekday[0, 6] std::tuple<int, unsigned, unsigned>\n> iso_week_from_civil(int y, unsigned m, unsigned d) { const unsigned Monday =\n> 1; const unsigned Thursday = 4; const int tp = days_from_civil(y, m, d); int\n> iso_week_start = iso_week_start_from_year(y); if (tp < iso_week_start)\n> iso_week_start = iso_week_start_from_year(y-1); else { const int\n> iso_week_next_year_start = iso_week_start_from_year(y+1); if (tp >=\n> iso_week_next_year_start) iso_week_start = iso_week_next_year_start; } const\n> unsigned weekday = weekday_from_days(tp); const unsigned week = (tp -\n> iso_week_start) / 7 + 1; int year; std::tie(year, std::ignore, std::ignore)\n> = civil_from_days(iso_week_start + int(Thursday - Monday)); return\n> std::tuple<int, unsigned, unsigned>(year, week, weekday); }\n\nWe're going to need to easily compare dates using less-than. To do that we\nneed to work in terms of serial dates, so we convert both the y/m/d and the\nstart of the ISO week-based year into serial dates (tp and iso_week_start).\n\nRecall that the input to iso_week_start_from_year is the week-based year\nnumber, not the civil year number. So it is possible that our year number is\none off, causing the current date to fall outside of the range of the ISO\nweek-based year we just computed. The ISO 8601 examples given above are both\ncases where this happens. So we test if tp is prior to iso_week_start. If it\nis, then we need to change the start of the ISO week to that of the previous\nyear. Otherwise we need to check if tp falls in the following ISO week-based\nyear, and if so change iso_week_start to the following year.\n\nOnce past the if-statement, iso_week_start is the correct beginning of the\nweek-based year that contains tp. We need the weekday of tp, easily computed\nwith weekday_from_days. We need the week number, easily computed by finding\nout how many weeks tp is beyond iso_week_start, and recalling that the week\nnumber is 1-based, not 0-based. And finally we need to implement ISO rule 4\nwhich says that the year number is that of the civil date for the Thursday\nthat follows the start of the ISO week-based year.\n\nThe reverse conversion, from year/week_number/week_day to year/month/day is\neven easier:\n\n>\n>     // year, month[1, 12], day[1, 31] std::tuple<int, unsigned, unsigned>\n> civil_from_iso_week(int y, unsigned w, unsigned wd) { int tp =\n> iso_week_start_from_year(y) + (w-1) * 7 + (wd == 0 ? 6 : wd - 1); return\n> civil_from_days(tp); }\n\nOne simply converts the week-based year into a serial date by using our helper\nfunction iso_week_start_from_year, the number of 1-based weeks, and the day of\nthe week. For the latter, recall that Sunday is the last day of the week, or\nday 6 of the week, and Monday is the first day of the week, or day 0 of the\nweek. Once we have a serial date, it is now trivial to convert that to a civil\ndate using civil_from_days.\n\nNote that in any of these formulas, the variable named tp is a serial date,\ncompatible with chrono::system_clock::time_point, and so you could just as\neasily be converting to or from a chrono::system_clock::time_point using:\n\n>\n>     typedef duration<int, ratio_multiply<hours::period, ratio<24>>> days; //\n> tp -> time_point system_clock::time_point time_point(days(tp)); //\n> time_point -> tp int tp2 =\n> duration_cast<days>(time_point.time_since_epoch()).count();\n\nAnd actually, if you anticipate converting negative system_clock::time_points\nyou should create yourself a round_down function and use that in place of\nduration_cast:\n\n>\n>     template <class To, class Rep, class Period> To round_down(const\n> std::chrono::duration<Rep, Period>& d) { To t =\n> std::chrono::duration_cast<To>(d); if (t > d) --t; return t; }\n\nFor example if your system_clock::time_point contains a duration of\nseconds(-1), and you convert that to days, you want days to be -1 (midnight\n1969-12-31), not 0 (midnight 1970-01-01).\n\n>\n>     // time_point -> tp int tp2 =\n> round_down<days>(time_point.time_since_epoch()).count();\n\n## Example: Converting between the civil calendar and the Julian calendar\n\nIt is relatively straight forward to derive days_from_julian from\ndays_from_civil by simply adjusting the constants in days_from_civil:\n\n>\n>     // Returns number of days since civil 1970-01-01. Negative values\n> indicate // days prior to 1970-01-01. // Preconditions: y-m-d represents a\n> date in the Julian calendar // m is in [1, 12] // d is in [1,\n> last_day_of_month_julian(y, m)] // y is \"approximately\" in //\n> [numeric_limits<Int>::min()/366, numeric_limits<Int>::max()/366] template\n> <class Int> constexpr Int days_from_julian(Int y, unsigned m, unsigned d)\n> noexcept { static_assert(std::numeric_limits<Int>::digits >= 20, \"This\n> algorithm has not been ported to a 16 bit signed integer\"); y -= m <= 2;\n> const Int era = (y >= 0 ? y : y-3) / 4; const unsigned yoe =\n> static_cast<unsigned>(y - era * 4); // [0, 3] const unsigned doy = (153*(m +\n> (m > 2 ? -3 : 9)) + 2)/5 + d-1; // [0, 365] const unsigned doe = yoe * 365 +\n> doy; // [0, 1460] return era * 1461 + static_cast<Int>(doe) - 719470; }\n\nIn the Julian calendar the era is only 4 years long instead of 400. This\ngreatly simplifies everything. Otherwise we still use the the same basic\ndesign and algorithms as developed for days_from_civil. The one tricky part is\nthat the constant to shift the epoch to the chrono-compatible civil\n1970-01-01, the constant 719468 needs to be adjusted. To find the right shift,\nit is handy to note that there is a well-documented equivalence between the\nJulian and civil calendars:\n\n>\n>     static_assert(days_from_julian(1582, 10, 5) == days_from_civil(1582, 10,\n> 15), \"Rome switches from Julian to Gregorian\");\n\nIf this equivalence does not hold true, then the epochs are not properly\naligned.\n\nSimilarly, julian_from_days is derived from civil_from_days by simply\nadjusting the constants:\n\n>\n>     // Returns year/month/day triple in Julian calendar // Preconditions: z\n> is number of days since 1970-01-01 (civil) and is not \"too close\" // to\n> numeric_limits<Int>::min() or numeric_limits<Int>::max(). template <class\n> Int> constexpr std::tuple<Int, unsigned, unsigned> julian_from_days(Int z)\n> noexcept { static_assert(std::numeric_limits<Int>::digits >= 20, \"This\n> algorithm has not been ported to a 16 bit signed integer\"); z += 719470;\n> const Int era = (z >= 0 ? z : z - 1460) / 1461; const unsigned doe =\n> static_cast<unsigned>(z - era * 1461); // [0, 1460] const unsigned yoe =\n> (doe - doe/1460) / 365; // [0, 3] const Int y = static_cast<Int>(yoe) + era\n> * 4; const unsigned doy = doe - 365 * yoe; // [0, 365] const unsigned mp =\n> (5*doy + 2)/153; // [0, 11] const unsigned d = doy - (153*mp+2)/5 + 1; //\n> [1, 31] const unsigned m = mp + (mp < 10 ? 3 : -9); // [1, 12] return\n> std::tuple<Int, unsigned, unsigned>(y + (m <= 2), m, d); }\n\nAnd now one can easily convert between the civil and Julian calendars by\nsimply converting to the serial calendar in between, for example:\n\n>\n>     std::tuple<int, unsigned, unsigned> julian_from_civil(int y, unsigned m,\n> unsigned d) { return julian_from_days(days_from_civil(y, m, d)); }\n\nIt is also interesting, and somewhat amusing, to note that the\nweekday_from_days function is just as valid for the Julian calendar as it is\nfor the civil calendar. Some things even the pope won't mess with! But note\nthat is_leap and last_day_of_month are not valid for the Julian calendar.\nThough it is certainly trivial to write Julian versions of these functions if\ndesired.\n\n## How can I confirm that your assertions about chrono compatibility are\ncorrect?\n\nGood question. I could be full of hot air.\n\nRun the following program while noting through an independent source what the\ncurrent time in the UTC timezone is:\n\n    \n    \n    #include <iostream> #include <chrono> #include <iomanip> void print_current_utc_date_time() { using namespace std; using namespace std::chrono; typedef duration<int, ratio_multiply<hours::period, ratio<24>>> days; auto now = system_clock::now().time_since_epoch(); auto today = duration_cast<days>(now); int year; unsigned month; unsigned day; std::tie(year, month, day) = civil_from_days(today.count()); now -= today; auto h = duration_cast<hours>(now); now -= h; auto m = duration_cast<minutes>(now); now -= m; auto s = duration_cast<seconds>(now); cout.fill('0'); cout << \"Today is \" << year << '-' << setw(2) << (unsigned)month << '-' << setw(2) << (unsigned)day << \" at \" << setw(2) << h.count() << ':' << setw(2) << m.count() << ':' << setw(2) << s.count() << \" UTC\\n\"; } int main() { print_current_utc_date_time(); }\n\nThe reported time through this program, and your independent source should be\nidentical down to the nearest second. If they are, then the assumptions about\nyour std::chrono::system_clock epoch are correct. If the two times disagree,\nyou can still fix it.\n\nIf the times differ by more than 86400 seconds, then you can alter the\nconstant 719468 in days_from_civil and civil_from_days to whatever it takes to\nbring the difference down below 86400 seconds.\n\nIf the times differ by less than 86400 seconds then you will need to\nadd/subtract that many seconds whenever you convert a days duration from\ndays_from_civil to/from a std::chrono::system_clock::time_point. One\npossibility is that the std::chrono::system_clock implementation is taking\nleap seconds into account.\n\nMy best guess is that you will never run into this problem. I have surveyed\nthe LLVM libc++, the GNU libstdc++, and MVC++. My personal experience with\nthis survey is only with libc++. I'm counting on reports from others for\nlibstdc++ and MVC++. But in all cases I'm seeing the use of unix time.\nImplementations will not easily change their epoch, even though the epoch is\nunspecified, as the epoch is detectible. I.e. the epoch is part of an\nimplementation's ABI.\n\n## Summary\n\nWe don't have a modern date class in the std::lib, and that is somewhat of a\npain. However these formulas are nice to have in your toolbox, and can be\nquite useful, even without a type-safe date class. Maybe they don't have quite\nthe right interface. Maybe the names aren't the best. But the formulas are\ngood. Consider these donated to the public domain. Perhaps you can use them to\ncreate the next great date class!\n\n## Acknowledgments\n\nI do not claim that any of these formulas are original. For example I've seen\nthe shift to March as the first month of the year many times before. I haven't\nseen the use of eras before, nor the use of the equation that transforms a\nday-of-era into a year-of-era before. However I would be surprised if this was\nthe first use of these formulations.\n\nThanks to Vicente J. Botet whose comments caused me to rethink several aspects\nof this paper.\n\nThanks to Jonathan Sauer who pointed out to me that C++98/03 compilers are\nallowed to implement truncated, floored or Euclidean integral division.\nHowever C++11 specifies truncated. I am unaware of any C++98/03 compiler that\ndoes not implement truncated division, which is probably why C++11 was able to\nchange from implementation defined to truncated.\n\n", "frontpage": false}
