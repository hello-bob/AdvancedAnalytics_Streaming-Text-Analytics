{"aid": "40056875", "title": "Pydantic: Simplifying Data Validation in Python \u2013 Real Python", "url": "https://realpython.com/python-pydantic/", "domain": "realpython.com", "votes": 1, "user": "rbanffy", "posted_at": "2024-04-16 20:37:40", "comments": 0, "source_title": "Pydantic: Simplifying Data Validation in Python \u2013 Real Python", "source_text": "Pydantic: Simplifying Data Validation in Python \u2013 Real Python\n\nBrowse Topics Guided Learning Paths Basics Intermediate Advanced\n\napi best-practices career community databases data-science data-structures\ndata-viz devops django docker editors flask front-end gamedev gui machine-\nlearning numpy projects python testing tools web-dev web-scraping\n\nTable of Contents\n\n  * Python\u2019s Pydantic Library\n\n    * Getting Familiar With Pydantic\n    * Installing Pydantic\n    * Adding Optional Dependencies\n  * Using Models\n\n    * Working With Pydantic BaseModels\n    * Using Fields for Customization and Metadata\n  * Working With Validators\n\n    * Validating Models and Fields\n    * Using Validation Decorators to Validate Functions\n  * Managing Settings\n\n    * Configuring Applications With BaseSettings\n    * Customizing Settings With SettingsConfigDict\n  * Conclusion\n\nShare Share Email\n\n# Pydantic: Simplifying Data Validation in Python\n\nby Harrison Hoffman Apr 10, 2024 0 Comments best-practices data-structures\nintermediate\n\nShare Share Email\n\nTable of Contents\n\n  * Python\u2019s Pydantic Library\n\n    * Getting Familiar With Pydantic\n    * Installing Pydantic\n    * Adding Optional Dependencies\n  * Using Models\n\n    * Working With Pydantic BaseModels\n    * Using Fields for Customization and Metadata\n  * Working With Validators\n\n    * Validating Models and Fields\n    * Using Validation Decorators to Validate Functions\n  * Managing Settings\n\n    * Configuring Applications With BaseSettings\n    * Customizing Settings With SettingsConfigDict\n  * Conclusion\n\nRemove ads\n\nPydantic is a powerful data validation and settings management library for\nPython, engineered to enhance the robustness and reliability of your codebase.\nFrom basic tasks, such as checking whether a variable is an integer, to more\ncomplex tasks, like ensuring highly-nested dictionary keys and values have the\ncorrect data types, Pydantic can handle just about any data validation\nscenario with minimal boilerplate code.\n\nIn this tutorial, you\u2019ll learn how to:\n\n  * Work with data schemas with Pydantic\u2019s BaseModel\n  * Write custom validators for complex use cases\n  * Validate function arguments with Pydantic\u2019s @validate_call\n  * Manage settings and configure applications with pydantic-settings\n\nThroughout this tutorial, you\u2019ll get hands-on examples of Pydantic\u2019s\nfunctionalities, and by the end you\u2019ll have a solid foundation for your own\nvalidation use cases. Before starting this tutorial, you\u2019ll benefit from\nhaving an intermediate understanding of Python and object-oriented\nprogramming.\n\nGet Your Code: Click here to download the free sample code that you\u2019ll use to\nhelp you learn how Pydantic can help you simplify data validation in Python.\n\n## Python\u2019s Pydantic Library\n\nOne of Python\u2019s main attractions is that it\u2019s a dynamically typed language.\nDynamic typing means that variable types are determined at runtime, unlike\nstatically typed languages where they are explicitly declared at compile time.\nWhile dynamic typing is great for rapid development and ease of use, you often\nneed more robust type checking and data validation for real-world\napplications. This is where Python\u2019s Pydantic library has you covered.\n\nPydantic has quickly gained popularity, and it\u2019s now the most widely used data\nvalidation library for Python. In this first section, you\u2019ll get an overview\nof Pydantic and a preview of the library\u2019s powerful features. You\u2019ll also\nlearn how to install Pydantic along with the additional dependencies you\u2019ll\nneed for this tutorial.\n\nRemove ads\n\n### Getting Familiar With Pydantic\n\nPydantic is a powerful Python library that leverages type hints to help you\neasily validate and serialize your data schemas. This makes your code more\nrobust, readable, concise, and easier to debug. Pydantic also integrates well\nwith many popular static typing tools and IDEs, which allows you to catch\nschema issues before running your code.\n\nSome of Pydantic\u2019s distinguishing features include:\n\n  * Customization: There\u2019s almost no limit to the kinds of data you can validate with Pydantic. From primitive Python types to highly nested data structures, Pydantic lets you validate and serialize nearly any Python object.\n\n  * Flexibility: Pydantic gives you control over how strict or lax you want to be when validating your data. In some cases, you might want to coerce incoming data to the correct type. For example, you could accept data that\u2019s intended to be a float but is received as an integer. In other cases, you might want to strictly enforce the data types you\u2019re receiving. Pydantic enables you to do either.\n\n  * Serialization: You can serialize and deserialize Pydantic objects as dictionaries and JSON strings. This means that you can seamlessly convert your Pydantic objects to and from JSON. This capability has led to self-documenting APIs and integration with just about any tool that supports JSON schemas.\n\n  * Performance: Thanks to its core validation logic written in Rust, Pydantic is exceptionally fast. This performance advantage gives you swift and reliable data processing, especially in high-throughput applications such as REST APIs that need to scale to a large number of requests.\n\n  * Ecosystem and Industry Adoption: Pydantic is a dependency of many popular Python libraries such as FastAPI, LangChain, and Polars. It\u2019s also used by most of the largest tech companies and throughout many other industries. This is a testament to Pydantic\u2019s community support, reliability, and resilience.\n\nThese are a few key features that make Pydantic an attractive data validation\nlibrary, and you\u2019ll get to see these in action throughout this tutorial. Up\nnext, you\u2019ll get an overview of how to install Pydantic along with its various\ndependencies.\n\n### Installing Pydantic\n\nPydantic is available on PyPI, and you can install it with pip. Open a\nterminal or command prompt, create a new virtual environment, and then run the\nfollowing command to install Pydantic:\n\nShell\n\n    \n    \n    (venv) $ python -m pip install pydantic\n\nThis command will install the latest version of Pydantic from PyPI onto your\nmachine. To verify that the installation was successful, start a Python REPL\nand import Pydantic:\n\nPython\n\n    \n    \n    >>> import pydantic\n\nIf the import runs without error, then you\u2019ve successfully installed Pydantic,\nand you now have the core of Pydantic installed on your system.\n\n### Adding Optional Dependencies\n\nYou can install optional dependencies with Pydantic as well. For example,\nyou\u2019ll be working with email validation in this tutorial, and you can include\nthese dependencies in your install:\n\nShell\n\n    \n    \n    (venv) $ python -m pip install \"pydantic[email]\"\n\nPydantic has a separate package for settings management, which you\u2019ll also\ncover in this tutorial. To install this, run the following command:\n\nShell\n\n    \n    \n    (venv) $ python -m pip install pydantic-settings\n\nWith that, you\u2019ve installed all the dependencies you\u2019ll need for this\ntutorial, and you\u2019re ready to start exploring Pydantic. You\u2019ll start by\ncovering models\u2014Pydantic\u2019s primary way of defining data schemas.\n\n## Using Models\n\nPydantic\u2019s primary way of defining data schemas is through models. A Pydantic\nmodel is an object, similar to a Python dataclass, that defines and stores\ndata about an entity with annotated fields. Unlike dataclasses, Pydantic\u2019s\nfocus is centered around automatic data parsing, validation, and\nserialization.\n\nThe best way to understand this is to create your own models, and that\u2019s what\nyou\u2019ll do next.\n\nRemove ads\n\n### Working With Pydantic BaseModels\n\nSuppose you\u2019re building an application used by a human resources department to\nmanage employee information, and you need a way to verify that new employee\ninformation is in the correct form. For example, each employee should have an\nID, name, email, date of birth, salary, department, and benefits selection.\nThis is a perfect use case for a Pydantic model!\n\nTo define your employee model, you create a class that inherits from\nPydantic\u2019s BaseModel:\n\nPython pydantic_models.py\n\n    \n    \n    from datetime import date from uuid import UUID, uuid4 from enum import Enum from pydantic import BaseModel, EmailStr class Department(Enum): HR = \"HR\" SALES = \"SALES\" IT = \"IT\" ENGINEERING = \"ENGINEERING\" class Employee(BaseModel): employee_id: UUID = uuid4() name: str email: EmailStr date_of_birth: date salary: float department: Department elected_benefits: bool\n\nFirst, you import the dependencies you need to define your employee model. You\nthen create an enum to represent the different departments in your company,\nand you\u2019ll use this to annotate the department field in your employee model.\n\nThen, you define your Pydantic model, Employee, which inherits from BaseModel\nand defines the names and expected types of your employee fields via\nannotations. Here\u2019s a breakdown of each field you\u2019ve defined in Employee and\nhow Pydantic validates it when an Employee object is instantiated:\n\n  * employee_id: This is the UUID for the employee you want to store information for. By using the UUID annotation, Pydantic ensures this field is always a valid UUID. Each instance of Employee will be assigned a UUID by default, as you specified by calling uuid4().\n  * name: The employee\u2019s name, which Pydantic expects to be a string.\n  * email: Pydantic will ensure that each employee email is valid by using Python\u2019s email-validator library under the hood.\n  * date_of_birth: Each employee\u2019s date of birth must be a valid date, as annotated by date from Python\u2019s datetime module. If you pass a string into date_of_birth, Pydantic will attempt to parse and convert it to a date object.\n  * salary: This is the employee\u2019s salary, and it\u2019s expected to be a float.\n  * department: Each employee\u2019s department must be one of HR, SALES, IT, or ENGINEERING, as defined in your Department enum.\n  * elected_benefits: This field stores whether the employee has elected benefits, and Pydantic expects it to be a Boolean.\n\nThe simplest way to create an Employee object is to instantiate it as you\nwould any other Python object. To do this, open a Python REPL and run the\nfollowing code:\n\nPython\n\n    \n    \n    >>> from pydantic_models import Employee >>> Employee( ... name=\"Chris DeTuma\", ... email=\"cdetuma@example.com\", ... date_of_birth=\"1998-04-02\", ... salary=123_000.00, ... department=\"IT\", ... elected_benefits=True, ... ) Employee( employee_id=UUID('73636d47-373b-40cd-a005-4819a84d9ea7'), name='Chris DeTuma', email='cdetuma@example.com', date_of_birth=datetime.date(1998, 4, 2), salary=123000.0, department=<Department.IT: 'IT'>, elected_benefits=True )\n\nIn this block, you import Employee and create an object with all of the\nrequired employee fields. Pydantic successfully validates and coerces the\nfields you passed in, and it creates a valid Employee object. Notice how\nPydantic automatically converts your date string into a date object and your\nIT string to its respective Department enum.\n\nNext, look at how Pydantic responds when you try to pass invalid data to an\nEmployee instance:\n\nPython\n\n    \n    \n    >>> Employee( ... employee_id=\"123\", ... name=False, ... email=\"cdetumaexamplecom\", ... date_of_birth=\"1939804-02\", ... salary=\"high paying\", ... department=\"PRODUCT\", ... elected_benefits=300, ... ) Traceback (most recent call last): pydantic_core._pydantic_core.ValidationError: 7 validation errors for Employee employee_id Input should be a valid UUID, invalid length: expected length 32 for simple format, found 3 [type=uuid_parsing, input_value='123', input_type=str] For further information visit https://errors.pydantic.dev/2.6/v/uuid_parsing name Input should be a valid string [type=string_type, input_value=False, input_type=bool] For further information visit https://errors.pydantic.dev/2.6/v/string_type email value is not a valid email address: The email address is not valid. It must have exactly one @-sign. [type=value_error, input_value='cdetumaexamplecom', input_type=str] date_of_birth Input should be a valid date or datetime, invalid date separator, expected `-` [type=date_from_datetime_parsing, input_value='1939804-02', input_type=str] For further information visit https://errors.pydantic.dev/2.6/v/date_from_datetime_parsing salary Input should be a valid number, unable to parse string as a number [type=float_parsing, input_value='high paying', input_type=str] For further information visit https://errors.pydantic.dev/2.6/v/float_parsing department Input should be 'HR', 'SALES', 'IT' or 'ENGINEERING' [type=enum, input_value='PRODUCT', input_type=str] elected_benefits Input should be a valid boolean, unable to interpret input [type=bool_parsing, input_value=300, input_type=int] For further information visit https://errors.pydantic.dev/2.6/v/bool_parsing\n\nIn this example, you created an Employee object with invalid data fields.\nPydantic gives you a detailed error message for each field, telling you what\nwas expected, what was received, and where you can go to learn more about the\nerror.\n\nThis detailed validation is powerful because it prevents you from storing\ninvalid data in Employee. This also gives you confidence that the Employee\nobjects you instantiate without errors contain the data you\u2019re expecting, and\nyou can trust this data downstream in your code or in other applications.\n\nPydantic\u2019s BaseModel is equipped with a suite of methods that make it easy to\ncreate models from other objects, such as dictionaries and JSON. For example,\nif you want to instantiate an Employee object from a dictionary, you can use\nthe .model_validate() class method:\n\nPython\n\n    \n    \n    >>> new_employee_dict = { ... \"name\": \"Chris DeTuma\", ... \"email\": \"cdetuma@example.com\", ... \"date_of_birth\": \"1998-04-02\", ... \"salary\": 123_000.00, ... \"department\": \"IT\", ... \"elected_benefits\": True, ... } >>> Employee.model_validate(new_employee_dict) Employee( employee_id=UUID('73636d47-373b-40cd-a005-4819a84d9ea7'), name='Chris DeTuma', email='cdetuma@example.com', date_of_birth=datetime.date(1998, 4, 2), salary=123000.0, department=<Department.IT: 'IT'>, elected_benefits=True )\n\nHere, you create new_employee_dict, a dictionary with your employee fields,\nand pass it into .model_validate() to create an Employee instance. Under the\nhood, Pydantic validates each dictionary entry to ensure it conforms with the\ndata you\u2019re expecting. If any of the data is invalid, Pydantic will throw an\nerror in the same way you saw previously. You\u2019ll also be notified if any\nfields are missing from the dictionary.\n\nYou can do the same thing with JSON objects using .model_validate_json():\n\nPython\n\n    \n    \n    >>> new_employee_json = \"\"\" ... {\"employee_id\":\"d2e7b773-926b-49df-939a-5e98cbb9c9eb\", ... \"name\":\"Eric Slogrenta\", ... \"email\":\"eslogrenta@example.com\", ... \"date_of_birth\":\"1990-01-02\", ... \"salary\":125000.0, ... \"department\":\"HR\", ... \"elected_benefits\":false} ... \"\"\" >>> new_employee = Employee.model_validate_json(new_employee_json) >>> new_employee Employee( employee_id=UUID('d2e7b773-926b-49df-939a-5e98cbb9c9eb'), name='Eric Slogrenta', email='eslogrenta@example.com', date_of_birth=datetime.date(1990, 1, 2), salary=125000.0, department=<Department.HR: 'HR'>, elected_benefits=False )\n\nIn this example, new_employee_json is a valid JSON string that stores your\nemployee fields, and you use .model_validate_json() to validate and create an\nEmployee object from new_employee_json. While it may seem subtle, the ability\nto create and validate Pydantic models from JSON is powerful because JSON is\none of the most popular ways to transfer data across the web. This is one of\nthe reasons why FastAPI relies on Pydantic to create REST APIs.\n\nYou can also serialize Pydantic models as dictionaries and JSON:\n\nPython\n\n    \n    \n    >>> new_employee.model_dump() { 'employee_id': UUID('d2e7b773-926b-49df-939a-5e98cbb9c9eb'), 'name': 'Eric Slogrenta', 'email': 'eslogrenta@example.com', 'date_of_birth': datetime.date(1990, 1, 2), 'salary': 125000.0, 'department': <Department.HR: 'HR'>, 'elected_benefits': False } >>> new_employee.model_dump_json() '{\"employee_id\":\"d2e7b773-926b-49df-939a-5e98cbb9c9eb\", \u2b91\"name\":\"Eric Slogrenta\", \u2b91\"email\":\"eslogrenta@example.com\", \u2b91\"date_of_birth\":\"1990-01-02\", \u2b91\"salary\":125000.0, \u2b91\"department\":\"HR\", \u2b91\"elected_benefits\":false}'\n\nHere, you use .model_dump() and .model_dump_json() to convert your\nnew_employee model to a dictionary and JSON string, respectively. Notice how\n.model_dump_json() returns a JSON object with date_of_birth and department\nstored as strings.\n\nWhile Pydantic already validated these fields and converted your model to\nJSON, whoever uses this JSON downstream won\u2019t know that date_of_birth needs to\nbe a valid date and department needs to be a category in your Department enum.\nTo solve this, you can create a JSON schema from your Employee model.\n\nJSON schemas tell you what fields are expected and what values are represented\nin a JSON object. You can think of this as the JSON version of your Employee\nclass definition. Here\u2019s how you generate a JSON schema for Employee:\n\nPython\n\n    \n    \n    >>> Employee.model_json_schema() { '$defs': { 'Department': { 'enum': ['HR', 'SALES', 'IT', 'ENGINEERING'], 'title': 'Department', 'type': 'string' } }, 'properties': { 'employee_id': { 'default': '73636d47-373b-40cd-a005-4819a84d9ea7', 'format': 'uuid', 'title': 'Employee Id', 'type': 'string' }, 'name': {'title': 'Name', 'type': 'string'}, 'email': { 'format': 'email', 'title': 'Email', 'type': 'string' }, 'date_of_birth': { 'format': 'date', 'title': 'Date Of Birth', 'type': 'string' }, 'salary': {'title': 'Salary', 'type': 'number'}, 'department': {'$ref': '#/$defs/Department'}, 'elected_benefits': {'title': 'Elected Benefits', 'type': 'boolean'} }, 'required': [ 'name', 'email', 'date_of_birth', 'salary', 'department', 'elected_benefits' ], 'title': 'Employee', 'type': 'object' }\n\nWhen you call .model_json_schema(), you get a dictionary representing your\nmodel\u2019s JSON schema. The first entry you see shows you the values that\ndepartment can take on. You also see information about how your fields should\nbe formatted. For instance, according to this JSON schema, employee_id is\nexpected to be a UUID and date_of_birth is expected to be a date.\n\nYou can convert your JSON schema to a JSON string using json.dumps(), which\nenables just about any programming language to validate JSON objects produced\nby your Employee model. In other words, not only can Pydantic validate\nincoming data and serialize it as JSON, but it also provides other programming\nlanguages with the information they need to validate your model\u2019s data via\nJSON schemas.\n\nWith that, you now understand how to use Pydantic\u2019s BaseModel to validate and\nserialize your data. Up next, you\u2019ll learn how to use fields to further\ncustomize your validation.\n\nRemove ads\n\n### Using Fields for Customization and Metadata\n\nSo far, your Employee model validates the data type of each field and ensures\nsome of the fields, such as email, date_of_birth, and department, take on\nvalid formats. However, let\u2019s say you also want to ensure that salary is a\npositive number, name isn\u2019t an empty string, and email contains your company\u2019s\ndomain name. You can use Pydantic\u2019s Field class to accomplish this.\n\nThe Field class allows you to customize and add metadata to your model\u2019s\nfields. To see how this works, take a look at this example:\n\nPython pydantic_models.py\n\n    \n    \n    from datetime import date from uuid import UUID, uuid4 from enum import Enum from pydantic import BaseModel, EmailStr, Field class Department(Enum): HR = \"HR\" SALES = \"SALES\" IT = \"IT\" ENGINEERING = \"ENGINEERING\" class Employee(BaseModel): employee_id: UUID = Field(default_factory=uuid4, frozen=True) name: str = Field(min_length=1, frozen=True) email: EmailStr = Field(pattern=r\".+@example\\.com$\") date_of_birth: date = Field(alias=\"birth_date\", repr=False, frozen=True) salary: float = Field(alias=\"compensation\", gt=0, repr=False) department: Department elected_benefits: bool\n\nHere, you import Field along with the other dependencies you used previously,\nand you assign default values to some of the Employee fields. Here\u2019s a\nbreakdown of the Field parameters you used to add additional validation and\nmetadata to your fields:\n\n  * default_factory: You use this to define a callable that generates default values. In the example above, you set default_factory to uuid4. This calls uuid4() to generate a random UUID for employee_id when needed. You can also use a lambda function for more flexibility.\n  * frozen: This is a Boolean parameter you can set to make your fields immutable. This means, when frozen is set to True, the corresponding field can\u2019t be changed after your model is instantiated. In this example, employee_id, name, and date_of_birth are made immutable using the frozen parameter.\n  * min_length: You can control the length of string fields with min_length and max_length. In the example above, you ensure that name is at least one character long.\n  * pattern: For string fields, you can set pattern to a regex expression to match whatever pattern you\u2019re expecting for that field. For instance, when you use the regex expression in the example above for email, Pydantic will ensure that every email ends with @example.com.\n  * alias: You can use this parameter when you want to assign an alias to your fields. For example, you can allow date_of_birth to be called birth_date or salary to be called compensation. You can use these aliases when instantiating or serializing a model.\n  * gt: This parameter, short for \u201cgreater than\u201d, is used for numeric fields to set minimum values. In this example, setting gt=0 ensures salary is always a positive number. Pydantic also has other numeric constraints, such as lt which is short for \u201cless than\u201d.\n  * repr: This Boolean parameter determines whether a field is displayed in the model\u2019s field representation. In this example, you won\u2019t see date_of_birth or salary when you print an Employee instance.\n\nTo see this extra validation in action, notice what happens when you try to\ncreate an Employee model with incorrect data:\n\nPython\n\n    \n    \n    >>> from pydantic_models import Employee >>> incorrect_employee_data = { ... \"name\": \"\", ... \"email\": \"cdetuma@fakedomain.com\", ... \"birth_date\": \"1998-04-02\", ... \"salary\": -10, ... \"department\": \"IT\", ... \"elected_benefits\": True, ... } >>> Employee.model_validate(incorrect_employee_data) Traceback (most recent call last): pydantic_core._pydantic_core.ValidationError: 3 validation errors for Employee name String should have at least 1 character [type=string_too_short, input_value='', input_type=str] For further information visit https://errors.pydantic.dev/2.6/v/string_too_short email String should match pattern '.+@example\\.com$' [type=string_pattern_mismatch, input_value='cdetuma@fakedomain.com', input_type=str] For further information visit https://errors.pydantic.dev/2.6/v/string_pattern_mismatch salary Input should be greater than 0 [type=greater_than, input_value=-10, input_type=int] For further information visit https://errors.pydantic.dev/2.6/v/greater_than\n\nHere, you import your updated Employee model and attempt to validate a\ndictionary with incorrect data. In response, Pydantic gives you three\nvalidation errors saying the name needs to be at least one character, email\nshould match your company\u2019s domain name, and salary should be greater than\nzero.\n\nNow notice the additional features you get when you validate correct Employee\ndata:\n\nPython\n\n    \n    \n    >>> employee_data = { ... \"name\": \"Clyde Harwell\", ... \"email\": \"charwell@example.com\", ... \"birth_date\": \"2000-06-12\", ... \"compensation\": 100_000, ... \"department\": \"ENGINEERING\", ... \"elected_benefits\": True, ... } >>> employee = Employee.model_validate(employee_data) >>> employee Employee( employee_id=UUID('614c6f75-8528-4272-9cfc-365ddfafebd9'), name='Clyde Harwell', email='charwell@example.com', department=<Department.ENGINEERING: 'ENGINEERING'>, elected_benefits=True) >>> employee.salary 100000.0 >>> employee.date_of_birth datetime.date(2000, 6, 12)\n\nIn this block, you create a dictionary and an Employee model with\n.model_validate(). In employee_data, notice how you used birth_date instead of\ndate_of_birth and compensation instead of salary. Pydantic recognizes these\naliases and assigns their values to the correct field name internally.\n\nBecause you set repr=False, you can see that salary and date_of_birth aren\u2019t\ndisplayed in the Employee representation. You have to explicitly access them\nas attributes to see their values. Lastly, notice what happens when you try to\nchange a frozen field:\n\nPython\n\n    \n    \n    >>> employee.department = \"HR\" >>> employee.name = \"Andrew TuGrendele\" Traceback (most recent call last): pydantic_core._pydantic_core.ValidationError: 1 validation error for Employee name Field is frozen [type=frozen_field, input_value='Andrew TuGrendele', input_type=str] For further information visit https://errors.pydantic.dev/2.6/v/frozen_field\n\nHere, you first change the value of department from IT to HR. This is\nperfectly acceptable because department isn\u2019t a frozen field. However, when\nyou try to change name, Pydantic gives you an error saying that name is a\nfrozen field.\n\nYou now have a solid grasp of Pydantic\u2019s BaseModel and Field classes. With\nthese alone, you can define many different validation rules and metadata on\nyour data schemas, but sometimes this isn\u2019t enough. Up next, you\u2019ll take your\nfield validation even further with Pydantic validators.\n\n## Working With Validators\n\nUp to this point, you\u2019ve used Pydantic\u2019s BaseModel to validate model fields\nwith predefined types, and you incorporated Field to further customize your\nvalidation. While you can get pretty far with BaseModel and Field alone, for\nmore complicated validation scenarios that require custom logic, you\u2019ll need\nto use Pydantic validators.\n\nWith validators, you can execute just about any validation logic that you can\nexpress in a function. You\u2019ll see how to do this next.\n\n### Validating Models and Fields\n\nContinuing with the employee example, suppose your company has a policy that\nthey only hire employees who are at least eighteen years old. Any time you\ncreate a new Employee object, you need to make sure the employee is older than\neighteen. To handle this, you could add an age field and use the Field class\nto enforce that the employee is at least eighteen. However, this seems\nredundant since you\u2019ve already stored the employee\u2019s birth date.\n\nA better solution is to use a Pydantic field validator. Field validators allow\nyou to apply custom validation logic to your BaseModel fields by adding class\nmethods to your model. To enforce that all employees are at least eighteen,\nyou can add the following Field validator to your Employee model:\n\nPython pydantic_models.py\n\n    \n    \n    from datetime import date from uuid import UUID, uuid4 from enum import Enum from pydantic import BaseModel, EmailStr, Field, field_validator class Department(Enum): HR = \"HR\" SALES = \"SALES\" IT = \"IT\" ENGINEERING = \"ENGINEERING\" class Employee(BaseModel): employee_id: UUID = Field(default_factory=uuid4, frozen=True) name: str = Field(min_length=1, frozen=True) email: EmailStr = Field(pattern=r\".+@example\\.com$\") date_of_birth: date = Field(alias=\"birth_date\", repr=False, frozen=True) salary: float = Field(alias=\"compensation\", gt=0, repr=False) department: Department elected_benefits: bool @field_validator(\"date_of_birth\") @classmethod def check_valid_age(cls, date_of_birth: date) -> date: today = date.today() eighteen_years_ago = date(today.year - 18, today.month, today.day) if date_of_birth > eighteen_years_ago: raise ValueError(\"Employees must be at least 18 years old.\") return date_of_birth\n\nIn this block, you import field_validator and use it to decorate a class\nmethod in Employee called .check_valid_age(). Field validators must be defined\na class methods. In .check_valid_age(), you calculate today\u2019s date but\neighteen years ago. If the employee\u2019s date_of_birth is after that date, an\nerror is raised.\n\nTo see how this validator works, check out this example:\n\nPython\n\n    \n    \n    >>> from pydantic_models import Employee >>> from datetime import date, timedelta >>> young_employee_data = { ... \"name\": \"Jake Bar\", ... \"email\": \"jbar@example.com\", ... \"birth_date\": date.today() - timedelta(days=365 * 17), ... \"compensation\": 90_000, ... \"department\": \"SALES\", ... \"elected_benefits\": True, ... } >>> Employee.model_validate(young_employee_data) Traceback (most recent call last): pydantic_core._pydantic_core.ValidationError: 1 validation error for Employee birth_date Value error, Employees must be at least 18 years old. [type=value_error, input_value=datetime.date(2007, 4, 10), input_type=date] For further information visit https://errors.pydantic.dev/2.6/v/value_error\n\nIn this example, you specify a birth_date that is seventeen years behind the\ncurrent date. When you call .model_validate() to validate young_employee_data,\nyou get an error saying employees must be at least eighteen years old.\n\nAs you can imagine, Pydantic\u2019s field_validator() enables you to arbitrarily\ncustomize field validation. However, field_validator() won\u2019t work if you want\nto compare multiple fields to one another or validate your model as a whole.\nFor this, you\u2019ll need to use model validators.\n\nAs an example, suppose your company only hires contract workers in the IT\ndepartment. Because of this, IT workers don\u2019t qualify for benefits and their\nelected_benefits field should be False. You can use Pydantic\u2019s\nmodel_validator() to enforce this constraint:\n\nPython pydantic_models.py\n\n    \n    \n    from typing import Self from datetime import date from uuid import UUID, uuid4 from enum import Enum from pydantic import ( BaseModel, EmailStr, Field, field_validator, model_validator, ) class Department(Enum): HR = \"HR\" SALES = \"SALES\" IT = \"IT\" ENGINEERING = \"ENGINEERING\" class Employee(BaseModel): employee_id: UUID = Field(default_factory=uuid4, frozen=True) name: str = Field(min_length=1, frozen=True) email: EmailStr = Field(pattern=r\".+@example\\.com$\") date_of_birth: date = Field(alias=\"birth_date\", repr=False, frozen=True) salary: float = Field(alias=\"compensation\", gt=0, repr=False) department: Department elected_benefits: bool @field_validator(\"date_of_birth\") @classmethod def check_valid_age(cls, date_of_birth: date) -> date: today = date.today() eighteen_years_ago = date(today.year - 18, today.month, today.day) if date_of_birth > eighteen_years_ago: raise ValueError(\"Employees must be at least 18 years old.\") return date_of_birth @model_validator(mode=\"after\") def check_it_benefits(self) -> Self: department = self.department elected_benefits = self.elected_benefits if department == Department.IT and elected_benefits: raise ValueError( \"IT employees are contractors and don't qualify for benefits\" ) return self\n\nHere, you add Python\u2019s Self type and Pydantic\u2019s model_validator() to your\nimports. You then create a method, .check_it_benefits(), that raises an error\nif the employee belongs to the IT department and the elected_benefits field is\nTrue. When you set mode to after in @model_validator, Pydantic waits until\nafter you\u2019ve instantiated your model to run .check_it_benefits().\n\nNote: You may have noticed that .check_it_benefits() is annotated with\nPython\u2019s Self type. This is because .check_it_benefits() returns the Employee\nclass instance, and the Self type is the preferred annotation for this. If\nyou\u2019re using a Python version less than 3.11, you\u2019ll have to import the Self\ntype from typing_extensions.\n\nTo see your new model validator in action, check out this example:\n\nPython\n\n    \n    \n    >>> from pydantic_models import Employee >>> new_employee = { ... \"name\": \"Alexis Tau\", ... \"email\": \"ataue@example.com\", ... \"birth_date\": \"2001-04-012\", ... \"compensation\": 100_000, ... \"department\": \"IT\", ... \"elected_benefits\": True, ... } >>> Employee.model_validate(new_employee) Traceback (most recent call last): pydantic_core._pydantic_core.ValidationError: 1 validation error for Employee Value error, IT employees are contractors and don't qualify for benefits. [type=value_error, input_value={'name': 'Alexis Tau', ...elected_benefits': True}, input_type=dict] For further information visit https://errors.pydantic.dev/2.6/v/value_error\n\nIn this example, you try to create an Employee model with an IT department and\nelected_benefits set to True. When you call .model_validate(), Pydantic throws\nan error letting you know that IT employees don\u2019t qualify for benefits because\nthey\u2019re contractors.\n\nWith model and field validators, you can implement just about any custom\nvalidation you can think of. You should now have a solid foundation to create\nPydantic models for your own use cases. Up next, you\u2019ll shift gears and look\nat how you can use Pydantic to validate arbitrary functions, not just\nBaseModel fields.\n\nRemove ads\n\n### Using Validation Decorators to Validate Functions\n\nWhile BaseModel is Pydantic\u2019s bread and butter class for validating data\nschemas, you can also use Pydantic to validate function arguments using the\n@validate_call decorator. This allows you to create robust functions with\ninformative type errors without having to manually implement validation logic.\n\nTo see how this works, suppose you\u2019re writing a function that sends invoices\nto clients after they\u2019ve made a purchase. Your function takes in the client\u2019s\nname, email, items purchased, and total billing amount, and it constructs and\nsends them an email. You need to validate all of these inputs because getting\nthem wrong could result in the email not being sent, being misformatted, or\nthe client being invoiced incorrectly.\n\nTo accomplish this, you write the following function:\n\nPython validate_functions.py\n\n    \n    \n    import time from typing import Annotated from pydantic import PositiveFloat, Field, EmailStr, validate_call @validate_call def send_invoice( client_name: Annotated[str, Field(min_length=1)], client_email: EmailStr, items_purchased: list[str], amount_owed: PositiveFloat, ) -> str: email_str = f\"\"\" Dear {client_name}, \\n Thank you for choosing xyz inc! You owe ${amount_owed:,.2f} for the following items: \\n {items_purchased} \"\"\" print(f\"Sending email to {client_email}...\") time.sleep(2) return email_str\n\nFirst, you import the dependencies needed to write and annotate\nsend_invoice(). You then create send_invoice() decorated with @validate_call.\nBefore executing send_invoice(), @validate_call ensures that each input\nconforms to your annotations. In this case, @validate_call checks whether\nclient_name has at least one character, client_email is properly formatted,\nitems_purchased is a list of strings, and amount_owed is a positive float.\n\nIf one of the inputs doesn\u2019t conform to your annotation, Pydantic will throw\nan error similar to what you\u2019ve seen already with BaseModel. If all the inputs\nare valid, send_invoice() creates a string and simulates sending it to your\nclient with time.sleep(2).\n\nNote: You might have noticed that client_name is annotated with Python\u2019s\nAnnotated type. In general, you can use Annotated when you want to provide\nmetadata about a function argument. Pydantic recommends using Annotated when\nyou need to validate a function argument that has metadata specified by Field.\n\nHowever, if you use default_factory to assign a default value to your function\nargument, you should assign the argument directly to a Field instance. You can\nsee an example of this in Pydantic\u2019s documentation.\n\nTo see @validate_call and send_invoice() in action, open a new Python REPL and\nrun the following code:\n\nPython\n\n    \n    \n    >>> from validate_functions import send_invoice >>> send_invoice( ... client_name=\"\", ... client_email=\"ajolawsonfakedomain.com\", ... items_purchased=[\"pie\", \"cookie\", 17], ... amount_owed=0, ... ) Traceback (most recent call last): pydantic_core._pydantic_core.ValidationError: 4 validation errors for send_invoice client_name String should have at least 1 character [type=string_too_short, input_value='', input_type=str] For further information visit https://errors.pydantic.dev/2.6/v/string_too_short client_email value is not a valid email address: The email address is not valid. It must have exactly one @-sign. [type=value_error, input_value='ajolawsonfakedomain.com', input_type=str] items_purchased.2 Input should be a valid string [type=string_type, input_value=17, input_type=int] For further information visit https://errors.pydantic.dev/2.6/v/string_type amount_owed Input should be greater than 0 [type=greater_than, input_value=0, input_type=int] For further information visit https://errors.pydantic.dev/2.6/v/greater_than\n\nIn this example, you import send_invoice() and pass in invalid function\narguments. Pydantic\u2019s @validate_call recognizes this and throws errors telling\nyou that client_name needs at least one character, client_email is invalid,\nitems_purchased should contain strings, and amount_owed should be greater than\nzero.\n\nWhen you pass in valid inputs, send_invoice() runs as expected:\n\nPython\n\n    \n    \n    >>> email_str = send_invoice( ... client_name=\"Andrew Jolawson\", ... client_email=\"ajolawson@fakedomain.com\", ... items_purchased=[\"pie\", \"cookie\", \"cake\"], ... amount_owed=20, ... ) Sending email to ajolawson@fakedomain.com... >>> print(email_str) Dear Andrew Jolawson, Thank you for choosing xyz inc! You owe $20.00 for the following items: ['pie', 'cookie', 'cake']\n\nWhile @validate_call isn\u2019t as flexible as BaseModel, you can still use it to\napply powerful validation to your function arguments. This saves you a lot of\ntime and lets you avoid writing boilerplate type checking and validation\nlogic. If you\u2019ve done this before, you know how cumbersome it can be to write\nassert statements for each of your function arguments. For many use cases,\n@validate_call takes care of this for you.\n\nIn the final section of this tutorial, you\u2019ll learn how you can use Pydantic\nfor settings management and configuration.\n\n## Managing Settings\n\nOne of the most popular ways to configure Python applications is with\nenvironment variables. An environment variable is a variable that lives in the\noperating system, outside of your Python code, but can be read by your code or\nother programs. Examples of data you\u2019d want to store as environment variables\ninclude secret keys, database credentials, API credentials, server addresses,\nand access tokens.\n\nEnvironment variables often change between development and production, and\nmany contain sensitive information. Because of this, you need a robust way to\nparse, validate, and integrate environment variables in your code. This is a\nperfect use case of pydantic-settings, and that\u2019s what you\u2019ll explore in this\nsection.\n\n### Configuring Applications With BaseSettings\n\npydantic-settings is one of the most powerful ways to manage environment\nvariables in Python, and it has been widely adopted and recommended by popular\nlibraries like FastAPI. You can use pydantic-settings to create models,\nsimilar to BaseModel, that parse and validate environment variables.\n\nThe main class in pydantic-settings is BaseSettings, and it has all of the\nsame functionalities as BaseModel. However, if you create a model that\ninherits from BaseSettings, the model initializer will try to read any fields\nnot passed as keyword arguments from environment variables.\n\nTo see how this works, suppose your application connects to a database and\nanother API service. Your database credentials and API key can change over\ntime and often change depending on which environment you\u2019re deploying in. To\nhandle this, you can create the following BaseSettings model:\n\nPython settings_management.py\n\n    \n    \n    from pydantic import HttpUrl, Field from pydantic_settings import BaseSettings class AppConfig(BaseSettings): database_host: HttpUrl database_user: str = Field(min_length=5) database_password: str = Field(min_length=10) api_key: str = Field(min_length=20)\n\nIn this script, you import the dependencies needed to create your BaseSettings\nmodel. Notice that you import BaseSettings from pydantic_settings with an\nunderscore instead of a dash. You then define a model, AppConfig, that\ninherits from BaseSettings and stores fields about your database and API key.\nIn this example, database_host has to be a valid HTTP URL, and the remaining\nfields have a minimum length constraint.\n\nNext, open a terminal and add the following environment variables. If you\u2019re\non Linux, macOS, or Windows Bash, you can do this with the export command:\n\nShell\n\n    \n    \n    (venv) $ export DATABASE_HOST=\"http://somedatabaseprovider.us-east-2.com\" (venv) $ export DATABASE_USER=\"username\" (venv) $ export DATABASE_PASSWORD=\"asdfjl348ghl@9fhsl4\" (venv) $ export API_KEY=\"ajfsdla48fsdal49fj94jf93-f9dsal\"\n\nYou can also set environment variables in Windows PowerShell. Then you can\nopen a new Python REPL and instantiate AppConfig:\n\nPython\n\n    \n    \n    >>> from settings_management import AppConfig >>> AppConfig() AppConfig( database_host=Url('http://somedatabaseprovider.us-east-2.com/'), database_user='username', database_password='asdfjl348ghl@9fhsl4', api_key='ajfsdla48fsdal49fj94jf93-f9dsal' )\n\nNotice how you don\u2019t specify any field names when you instantiate AppConfig.\nInstead, your BaseSettings model reads fields from the environment variables\nyou set. Also notice that you exported the environment variables in all\ncapital letters, yet AppConfig parsed and stored them successfully. This is\nbecause BaseSettings is not case-sensitive when matching environment variables\nto field names.\n\nNext, close your Python REPL and create invalid environment variables:\n\nShell\n\n    \n    \n    (venv) $ export DATABASE_HOST=\"somedatabaseprovider.us-east-2\" (venv) $ export DATABASE_USER=\"usee\" (venv) $ export DATABASE_PASSWORD=\"asdf\" (venv) $ export API_KEY=\"ajf\"\n\nNow open another Python REPL and reinstantiate AppConfig:\n\nPython\n\n    \n    \n    >>> from settings_management import AppConfig >>> AppConfig() Traceback (most recent call last): pydantic_core._pydantic_core.ValidationError: 4 validation errors for AppConfig database_host Input should be a valid URL, relative URL without a base [type=url_parsing, input_value='somedatabaseprovider.us-east-2', input_type=str] For further information visit https://errors.pydantic.dev/2.6/v/url_parsing database_user String should have at least 5 characters [type=string_too_short, input_value='usee', input_type=str] For further information visit https://errors.pydantic.dev/2.6/v/string_too_short database_password String should have at least 10 characters [type=string_too_short, input_value='asdf', input_type=str] For further information visit https://errors.pydantic.dev/2.6/v/string_too_short api_key String should have at least 20 characters [type=string_too_short, input_value='ajf', input_type=str] For further information visit https://errors.pydantic.dev/2.6/v/string_too_short\n\nThis time, when you try to instantiate AppConfig, pydantic-settings throws\nerrors saying that the database_host is not a valid URL, and the remaining\nfields don\u2019t meet the minimum length constraint.\n\nWhile this was a simplified configuration example, you can leverage\nBaseSettings to parse and validate just about anything you need from your\nenvironment variables. Any validation you can do with BaseModel you can also\ndo with BaseSettings, including custom validation with model and field\nvalidators.\n\nLastly, you\u2019ll learn how to further customize the behavior of BaseSettings\nwith SettingsConfigDict.\n\nRemove ads\n\n### Customizing Settings With SettingsConfigDict\n\nIn the previous example, you saw a barebones example of how to create a\nBaseSettings model that parses and validates environment variables. However,\nyou might want to further customize the behavior of your BaseSettings model,\nand you can accomplish this with SettingsConfigDict.\n\nSuppose you can\u2019t manually export each of your environment variables, which is\noften the case, and you need to read them from a .env file. You\u2019d want to make\nsure that BaseSettings is case-sensitive when parsing and that there are no\nadditional environment variables in your .env file aside from the ones you\nspecify in your model. Here\u2019s how you\u2019d do that with SettingsConfigDict:\n\nPython settings_management.py\n\n    \n    \n    from pydantic import HttpUrl, Field from pydantic_settings import BaseSettings, SettingsConfigDict class AppConfig(BaseSettings): model_config = SettingsConfigDict( env_file=\".env\", env_file_encoding=\"utf-8\", case_sensitive=True, extra=\"forbid\", ) database_host: HttpUrl database_user: str = Field(min_length=5) database_password: str = Field(min_length=10) api_key: str = Field(min_length=20)\n\nThis script is the same as in the previous example, except this time you\u2019ve\nimported SettingsConfigDict and initialized it within AppConfig. Within your\nSettingsConfigDict, you specify that environment variables should be read from\na .env file, case-sensitivity should be enforced, and that extra environment\nvariables are forbidden in the .env file.\n\nNext, create a file named .env in the same directory as\nsettings_management.py, and populate it with the following environment\nvariables:\n\n.env\n\n    \n    \n    database_host=http://somedatabaseprovider.us-east-2.com/ database_user=username database_password=asdfjfffffl348ghl@9fhsl4 api_key=ajfsdla48fsdal49fj94jf93-f9dsal\n\nNow, you can open a Python REPL and initialize your AppConfig model:\n\nPython\n\n    \n    \n    >>> from settings_management import AppConfig >>> AppConfig() AppConfig( database_host=Url('http://somedatabaseprovider.us-east-2.com/'), database_user='username', database_password='asdfjfffffl348ghl@9fhsl4', api_key='ajfsdla48fsdal49fj94jf93-f9dsal' )\n\nAs you can see, AppConfig successfully parsed and validated the environment\nvariables in your .env file.\n\nLastly, add some invalid variables to your .env file:\n\n.env\n\n    \n    \n    DATABASE_HOST=http://somedatabaseprovider.us-east-2.com/ database_user=username database_password=asdfjfffffl348ghl@9fhsl4 api_key=ajfsdla48fsdal49fj94jf93-f9dsal extra_var=shouldntbehere\n\nHere, you\u2019ve changed database_host to DATABASE_HOST, violating the case-\nsensitivity constraint, and you\u2019ve added extra environment variables that\nshouldn\u2019t be there. Here\u2019s how your model responds when it tries to validate\nthis:\n\nPython\n\n    \n    \n    >>> from settings_management import AppConfig >>> AppConfig() Traceback (most recent call last): pydantic_core._pydantic_core.ValidationError: 3 validation errors for AppConfig database_host Field required [type=missing, input_value={'database_user': 'userna..._var': 'shouldntbehere'}, input_type=dict] For further information visit https://errors.pydantic.dev/2.6/v/missing DATABASE_HOST Extra inputs are not permitted [type=extra_forbidden, input_value='http://somedatabaseprovider.us-east-2.com/', input_type=str] For further information visit https://errors.pydantic.dev/2.6/v/extra_forbidden extra_var Extra inputs are not permitted [type=extra_forbidden, input_value='shouldntbehere', input_type=str] For further information visit https://errors.pydantic.dev/2.6/v/extra_forbidden\n\nYou get a nice list of errors saying that database_host is missing and that\nyou have extra environment variables in your .env file. Notice that because of\nthe case-sensitivity constraint, your model thinks that DATABASE_HOST is an\nextra variable along with extra_var.\n\nThere\u2019s a lot more you can do with SettingsConfigDict and BaseSettings more\ngenerally, but these examples should give you an idea of how you can use\npydantic-settings to manage your environment variables for your own use case.\n\n## Conclusion\n\nPydantic is an easy-to-use, fast, and widely-trusted data validation library\nin Python. You\u2019ve gotten a broad overview of Pydantic, and now you have the\nknowledge and resources necessary to start using Pydantic in your own\nprojects.\n\nIn this tutorial, you\u2019ve learned:\n\n  * What Pydantic is and why it\u2019s been so widely adopted\n  * How to install Pydantic\n  * How to parse, validate, and serialize data schemas with BaseModel and validators\n  * How to write custom validation logic for functions using @validate_call\n  * How to parse and validate environment variables with pydantic-settings\n\nPydantic makes your code more robust and trustworthy, and it partially bridges\nthe gap between Python\u2019s ease of use and the built-in data validation of\nstatically typed languages. For just about any data parsing, validation, and\nserialization use case you might have, Pydantic has an elegant solution.\n\nGet Your Code: Click here to download the free sample code that you\u2019ll use to\nhelp you learn how Pydantic can help you simplify data validation in Python.\n\n\ud83d\udc0d Python Tricks \ud83d\udc8c\n\nGet a short & sweet Python Trick delivered to your inbox every couple of days.\nNo spam ever. Unsubscribe any time. Curated by the Real Python team.\n\nAbout Harrison Hoffman\n\nHarrison is an avid Pythonista, Data Scientist, and Real Python contributor.\nHe has a background in mathematics, machine learning, and software\ndevelopment. Harrison lives in Texas with his wife, identical twin daughters,\nand two dogs.\n\n\u00bb More about Harrison\n\nEach tutorial at Real Python is created by a team of developers so that it\nmeets our high quality standards. The team members who worked on this tutorial\nare:\n\nAldren\n\nBrenda\n\nGeir Arne\n\nPhilipp\n\nMaster Real-World Python Skills With Unlimited Access to Real Python\n\nJoin us and get access to thousands of tutorials, hands-on video courses, and\na community of expert Pythonistas:\n\nLevel Up Your Python Skills \u00bb\n\nMaster Real-World Python Skills With Unlimited Access to Real Python\n\nJoin us and get access to thousands of tutorials, hands-on video courses, and\na community of expert Pythonistas:\n\nLevel Up Your Python Skills \u00bb\n\nWhat Do You Think?\n\nRate this article:\n\nLinkedIn Twitter Facebook Email\n\nWhat\u2019s your #1 takeaway or favorite thing you learned? How are you going to\nput your newfound skills to use? Leave a comment below and let us know.\n\nCommenting Tips: The most useful comments are those written with the goal of\nlearning from or helping out other students. Get tips for asking good\nquestions and get answers to common questions in our support portal.\n\nLooking for a real-time conversation? Visit the Real Python Community Chat or\njoin the next \u201cOffice Hours\u201d Live Q&A Session. Happy Pythoning!\n\nKeep Learning\n\nRelated Tutorial Categories: best-practices data-structures intermediate\n\n## Keep reading Real Python by creating a free account or signing in:\n\nContinue \u00bb\n\nAlready have an account? Sign-In\n\nAlmost there! Complete this form and click the button below to gain instant\naccess:\n\nPydantic: Simplifying Data Validation in Python (Sample Code)\n\nRemove ads\n\n\u00a9 2012\u20132024 Real Python \u22c5 Newsletter \u22c5 Podcast \u22c5 YouTube \u22c5 Twitter \u22c5 Facebook\n\u22c5 Instagram \u22c5 Python Tutorials \u22c5 Search \u22c5 Privacy Policy \u22c5 Energy Policy \u22c5\nAdvertise \u22c5 Contact Happy Pythoning!\n\n", "frontpage": false}
