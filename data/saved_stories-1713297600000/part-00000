{"aid": "40051939", "title": "Getting Started with Perlimports", "url": "https://www.olafalders.com/2024/04/15/getting-started-with-perlimports/", "domain": "olafalders.com", "votes": 2, "user": "oalders", "posted_at": "2024-04-16 13:58:26", "comments": 0, "source_title": "Getting Started with perlimports", "source_text": "Getting Started with perlimports \u00b7 olafalders.com\n\n\u2193Skip to main content\n\n# Getting Started with perlimports\n\nApril 15, 2024\u00b73104 words\u00b715 mins\u00b7\n\nlinting perliports precious tidying\n\n\u2764\ufe0f It's great to see you here! I'm currently available on evenings and\nweekends for consulting and freelance work. Let's chat about how I can help\nyou achieve your goals.\n\nA version of this post was previously published in the 2023 Perl Advent\nCalendar. I have significantly revised it for publication here.\n\n##\n\nWhat\u2019s in a Package, Anyway?\n\n#\n\nPerl, like many other languages, exposes the functionality to export functions\n(and other things) from one package into another. The functions that are\nexported by package A are the same functions that are imported into package B.\nConsider the following code:\n\n    \n    \n    package WhereAmI; use 5.38.0; use Git::Helpers qw( checkout_root ); say checkout_root(); # or WhereAmI::checkout_root()\n\nIn this example, Git::Helpers is exporting the checkout_root function into\nWhereAmI. Conversely, WhereAmI is importing the checkout_root function from\nGit::Helpers. Importing and exporting are two sides of the same coin. The\nimportant thing to note is we now have a new function available in the\nWhereAmI package.\n\nToday we\u2019ll mostly be referring to imports, but in many cases we could just as\nwell be framing our discussion in terms of exports instead.\n\n##\n\nWhat is perlimports?\n\n#\n\nI have been interested in code quality for many years. This is something I\ntouched on in Find and Fix More Typos and Finding Unused Perl Variables. As\npart of that interest, I wrote a tool to help automate cleaning up cases where\ncode is being imported. This tool is called perlimports. perlimports is a\ntidier, which means it can rewrite our code for us. It\u2019s also a linter, so we\ncan use it to report on problems without rewriting our code. With this power\ncomes great responsibility. perlimports tries to be responsible.\n\nInspired by goimports, perlimports is an opinionated tool which tries to force\nits opinions onto our code. What we get in return is a tool which takes much\nof the burden of managing imports out of our hands.\n\nIf you\u2019re interested in a more thorough discussion of how perlimports and\nPerl\u2019s use and require work, I spoke about this in depth at The Perl\nConference in 2021: perlimports or \u201cWhere did that symbol come from?\u201d.\n\n##\n\nWhy Tidy Imports at all?\n\n#\n\nYou may quite correctly be asking yourself if perlimports is worth the bother.\nWhy even bother? After having used this tool in anger for about 3 years now,\nI\u2019ll try to sum up the best points.\n\n###\n\nConsistent Style\n\n#\n\nJust like any other tidier, using perlimports will automate and enforce a\nconsistent style for your imports. This has the following advantages:\n\n####\n\nCode is Easier to Read\n\n#\n\nWhen your imports are laid out in a consistent manner, your code can become\neasier to scan. You\u2019ll have consistent spacing, the imports for a given module\nwill be alpha-sorted and you\u2019ll have a standard quoting style. This should\nreduce the cognitive load when you\u2019re looking at the first few lines of your\nfiles.\n\n####\n\nDiffs Become Easier to Read\n\n#\n\nOnce code layout is consistent, code changes can become easier to read, since\nyou\u2019re less likely to be confronted with formatting changes. This can also\nreduce the size of your diffs, which also reduces cognitive load.\n\n####\n\nCode Reviews are Easier\n\n#\n\nHopefully code reviewers will no longer have to comment on how someone used\nthe wrong quotes or how they imported something they\u2019re not actually using. If\nyour linting and tidying is automated, code contributors can now also stop\nworrying about these little things.\n\n####\n\nWriting Code is Less Onerous\n\n#\n\nOnce you have a tidier to do the work for you, you can be a fair bit sloppier\nwhen writing code. Write it quickly, get it out of your system and then tidy\nthe file and watch the magic happen. Not having to worry about the mundane\nfrees up mental energy for other things.\n\n###\n\nImproved Dependency Management\n\n#\n\nOnce you start automatically removing from your code the imports (and even the\nmodules) which you are not using, it should be easier for you to evaluate\nwhich dependencies you actually need. You may find that you\u2019ve been installing\nmodules which you don\u2019t actually use. Fewer dependencies leads to a better\nsecurity posture (since you\u2019ve reduced your attack surface), faster setup time\n(because you now have fewer things to install) and fewer headaches around not\nbeing to install this or that module in a certain environment. Dependencies\nare great when you need them, but limiting your dependencies can also have\nsome real benefits. Unfortunately, linting Perl\u2019s imports is not always as\neasy as we\u2019d like. Let\u2019s try to contextualize the problem by taking a quick\nlook at the tools module authors might use to export code into yours.\n\n##\n\nThere\u2019s More Than One Way to Do It\n\n#\n\nIf you\u2019ll allow a small digression, Perl\u2019s import() is an incredibly powerful\ntool that does little in the way of imposing restrictions on the implementor\nwhen it is run. This means that over the years CPAN authors have allowed\nthemselves to be very creative when it comes to what may or may not get\nimported into our code.\n\nThis liberal approach to code import has also allowed for the proliferation of\nmodules which authors can use to manage what their code exports into ours.\n\n  * https://metacpan.org/pod/Exporter\n  * https://metacpan.org/pod/Sub::Exporter\n  * https://metacpan.org/pod/Exporter::Tiny\n  * https://metacpan.org/pod/Export::Declare\n  * https://metacpan.org/pod/Exporter::Auto\n  * https://metacpan.org/pod/Exporter::Easy\n  * https://metacpan.org/pod/Exporter::Lite\n\nThis is not an exhaustive list, but it\u2019s also the kind of TIMTOWDI that might\nleave a Perl newbie scratching their head in confusion and wonder.\n\nThe upshot of all of these different methods of exporting is that a static\ncode analysis is not an effective way of discovering what is being imported\ninto your code. perlimports needs to eval the package imports and then (in\nmany cases) see what actually changed in the symbol table. This means two\nthings:\n\n  * We need to install dependencies and be able to eval them in order to see what\u2019s going on\n  * A speed penalty is imposed on perlimports for this approach\n\n##\n\nStrategy\n\n#\n\nAs we saw above, there is an embarrassment of riches when it comes to modules\nto manage code exports. Some of these exporters work in very different ways,\nwhich makes the job of perlimports tricky. If we accept that it can be\ndifficult to predict what some code is actually importing, we will probably\nwant to be very careful when rewriting imports. The more \u201cimportant\u201d the code\nis, the more careful we\u2019ll want to be. perlimports makes a best effort, but it\nsimply cannot be correct in every case.\n\nI find that a good approach is to start with lower impact code and move on\nfrom there, once we\u2019ve established that we\u2019re on a good path. For example, we\ncould first run perlimports as a linter, just to see what it might change. Or\nwe could get some code which is under version control and run perlimports as a\ntidier on it and just diff the code to see what has changed.\n\nI would probably start by applying perltidy to the test suite (assuming it\nexists) and then running the tests to see what the impact is. From there I\nmight move to some code which has good test coverage. Eventually I would make\nmy over to other code which is lacking in coverage and/or is harder to unit\ntest. Working from lower to higher impact code allows for a gentle\nintroduction of our new linting and tidying tool. We\u2019ll explore this approach\nin more detail below, after we cover installation.\n\n##\n\nInstallation\n\n#\n\nLet\u2019s take a look at a typical getting started workflow. First we\u2019ll install\nthe package from CPAN. I like to use https://metacpan.org/pod/App::cpm, but\nfeel free to use your CPAN installer of choice:\n\n    \n    \n    cpm install -g App::perlimports\n\n(If you\u2019re using https://github.com/tokuhirom/plenv to manage your Perl\ninstallations, don\u2019t forget to run plenv rehash after cpm install.)\n\nOnce that is done, we are ready to try perlimports. The quick way to run it on\na new repository might look something like this:\n\n##\n\nGetting Started\n\n#\n\n  * Clone a repo\n  * Install *all* of the repository\u2019s dependencies (including recommended)\n  * Run the test suite\n  * Ensure all of the tests are passing. If there are test failures, fix those first\n  * Run perlimports with the --lint flag to see what changes it might make\n  * Tweak the configuration until we\u2019re happy with the linting results\n  * Apply perlimports to the tests. We can do this via perlimports -i t\n  * Ensure all of the tests are still passing\n  * Commit the changes\n  * Move on to other parts of the code, e.g.: perlimports -i lib\n\nIn a best case scenario, this \u201cjust works\u201d. Let\u2019s try it on a really old\nrepository of mine.\n\n    \n    \n    $ git clone https://github.com/oalders/acme-odometer.git $ cd acme-odometer/ $ cpm install -g --with-recommends --cpanfile cpanfile $ yath t $ perlimports --lint t\n\nI\u2019m not including the command output, but I ran this locally and all of the\nsteps \u201cjust worked\u201d. I ran the test(s) via yath and they passed. Why did I use\nyath rather than make test or prove? I certainly could have done either of\nthose things, but I\u2019m trying to get in the habit of using more modern tools.\nyath comes bundled with Test2::Harness. If you\u2019d like to learn more about some\nof the features which Test2 provides, please see Santa\u2019s Workshop Secrets: The\nMagical Test2 Suite (Part 1) and Santa\u2019s Workshop Secrets: The Magical Test2\nSuite (Part 2).\n\nNow, let\u2019s see what the linting looks like:\n\n    \n    \n    $ perlimports --lint t \u274c Test::Most (import arguments need tidying) at t/load.t line 1 @@ -1 +1 @@ -use Test::Most; +use Test::Most import => [ qw( done_testing ok ) ]; \u274c Acme::Odometer (import arguments need tidying) at t/load.t line 3 @@ -3 +3 @@ -use Acme::Odometer; +use Acme::Odometer (); \u274c Path::Class (import arguments need tidying) at t/load.t line 4 @@ -4 +4 @@ -use Path::Class qw(file); +use Path::Class qw( file );\n\nWe can see three suggestions have been made. In the first suggestion,\nperlimports has detected that done_testing and ok are the only functions\nexported by Test::Most which the test is using, so it has made this explicit.\n\nIn the second suggestion perlimports has detected that the test is not\nimporting any symbols from Acme::Odometer, so it has made this explicit by\nadding the empty round parens following the use statement.\n\nIn the third suggestion we see that some whitespace padding has been added to\nthe Path::Class import.\n\nIf we don\u2019t like these changes, we can tweak the configuration. To tell\nperlimports to ignore Test::Most, we can change our incantation:\n\n    \n    \n    perlimports --lint --ignore-modules Test::Most t\n\nIf we also don\u2019t like the additional padding, we can turn that off:\n\n    \n    \n    perlimports --lint --ignore-modules Test::Most --no-padding t\n\nApplying these settings we now get:\n\n    \n    \n    $ perlimports --lint --ignore-modules Test::Most --no-padding t \u274c Acme::Odometer (import arguments need tidying) at t/load.t line 3 @@ -3 +3 @@ -use Acme::Odometer; +use Acme::Odometer ();\n\nIt\u2019s time to update the actual file. We\u2019ll use -i for an inplace edit:\n\n    \n    \n    perlimports -i --ignore-modules Test::Most --no-padding t\n\nThe result is:\n\n    \n    \n    git --no-pager diff t diff --git a/t/load.t b/t/load.t index 503d560..d19688f 100644 --- a/t/load.t +++ b/t/load.t @@ -1,6 +1,6 @@ use Test::Most; -use Acme::Odometer; +use Acme::Odometer (); use Path::Class qw(file); my $path = file( 'assets', 'odometer' )->stringify;\n\nAre the tests still passing?\n\n    \n    \n    yath t ** Defaulting to the 'test' command ** ( PASSED ) job 1 t/load.t Yath Result Summary ----------------------------------------------------------------------------------- File Count: 1 Assertion Count: 3 Wall Time: 1.00 seconds CPU Time: 1.42 seconds (usr: 0.32s | sys: 0.09s | cusr: 0.77s | csys: 0.24s) CPU Usage: 142% --> Result: PASSED <--\n\nExcellent. Let\u2019s add the changes via git and commit them. After that, let\u2019s\nturn to the lib directory.\n\n    \n    \n    $ perlimports --lint --ignore-modules Test::Most --no-padding lib \u274c namespace::clean (appears to be unused and should be removed) at lib/Acme/Odometer.pm line 9 @@ -9 +8,0 @@ -use namespace::clean; \u274c GD (import arguments need tidying) at lib/Acme/Odometer.pm line 11 @@ -11 +11 @@ -use GD; +use GD (); \u274c Memoize (import arguments need tidying) at lib/Acme/Odometer.pm line 12 @@ -12 +12 @@ -use Memoize; +use Memoize qw(memoize); \u274c Path::Class (import arguments need tidying) at lib/Acme/Odometer.pm line 14 @@ -14 +14 @@ -use Path::Class qw( file ); +use Path::Class qw(file);\n\nNow, we already see some issues. First off, perlimports doesn\u2019t seem to know\nabout namespace::clean. That\u2019s ok. We can ignore it.\n\n    \n    \n    perlimports --lint --ignore-modules namespace::clean,Test::Most \\ --no-padding lib\n\nAs an aside, we could also update the code to use namespace::autoclean while\nwe\u2019re poking around, but we\u2019re trying to make minimal changes in this first\niteration.\n\nThe last suggestion is to remove the padding from the Path::Class imports.\nIt\u2019s good to be consistent. The second and third suggestions look to be solid.\nLet\u2019s make this change.\n\n    \n    \n    perlimports -i --ignore-modules namespace::clean,Test::Most --no-padding lib\n\nThat gives us:\n\n    \n    \n    $ git --no-pager diff lib diff --git a/lib/Acme/Odometer.pm b/lib/Acme/Odometer.pm index 7fee773..cb1734e 100644 --- a/lib/Acme/Odometer.pm +++ b/lib/Acme/Odometer.pm @@ -8,10 +8,10 @@ package Acme::Odometer; use Moo 1.001; use namespace::clean; -use GD; -use Memoize; +use GD (); +use Memoize qw(memoize); use MooX::Types::MooseLike::Numeric qw(PositiveInt PositiveOrZeroInt); -use Path::Class qw( file ); +use Path::Class qw(file);\n\nThat\u2019s pretty good. Do the tests still pass? Yes, they do. So, we can commit\nthis change as well. Not every introduction of perlimports will be this easy,\nbut it\u2019s nice to start off with a win. Can we improve our experience? I think\nso. Paring down our use of the command line switches would be a good start. We\ncan do that via a config file.\n\n##\n\nA Configuration File\n\n#\n\nAside from just running perlimports with fewer switches at the command line,\nwhat if we wanted to run perlimports via the Perl Navigator Language Server?\nIt would be better if we didn\u2019t have to worry about the custom command line\nswitches there as well. This sounds like a good time to create a config file.\n\n    \n    \n    perlimports --create-config-file perlimports.toml\n\nNice! We have a stub configuration file. Let\u2019s see what\u2019s inside\nperlimports.toml\n\n    \n    \n    # Valid log levels are: # debug, info, notice, warning, error, critical, alert, emergency # critical, alert and emergency are not currently used. # # Please use boolean values in this config file. Negated options (--no-*) are # not permitted here. Explicitly set options to true or false. # # Some of these values deviate from the regular perlimports defaults. In # particular, you're encouraged to leave preserve_duplicates and # preserve_unused disabled. cache = false # setting this to true is currently discouraged ignore_modules = [] ignore_modules_filename = \"\" ignore_modules_pattern = \"\" # regex like \"^(Foo|Foo::Bar)\" ignore_modules_pattern_filename = \"\" libs = [\"lib\", \"t/lib\"] log_filename = \"\" log_level = \"warn\" never_export_modules = [] never_export_modules_filename = \"\" padding = true preserve_duplicates = false preserve_unused = false tidy_whitespace = true\n\nLet\u2019s commit the stub file to git and then let\u2019s move our command line\nswitches to the config file. The diff should look something like this:\n\n    \n    \n    $ git --no-pager diff perlimports.toml diff --git a/perlimports.toml b/perlimports.toml index d631998..1e54c9e 100644 --- a/perlimports.toml +++ b/perlimports.toml @@ -10,7 +10,7 @@ # preserve_unused disabled. cache = false # setting this to true is currently discouraged -ignore_modules = [] +ignore_modules = [\"namespace::clean\", \"Test::Most\"] ignore_modules_filename = \"\" ignore_modules_pattern = \"\" # regex like \"^(Foo|Foo::Bar)\" ignore_modules_pattern_filename = \"\" @@ -19,7 +19,7 @@ log_filename = \"\" log_level = \"warn\" never_export_modules = [] never_export_modules_filename = \"\" -padding = true +padding = false preserve_duplicates = false preserve_unused = false tidy_whitespace = true\n\nWe can iterate on this config file as we start tidying more of our code, but\nthis is already an excellent start. Now we\u2019re ready to start setting up editor\nintegrations.\n\n##\n\nNeovim\n\n#\n\n###\n\nnvim-lint\n\n#\n\nUsers of Neovim can enable perlimports linting via\nhttps://github.com/mfussenegger/nvim-lint\n\n##\n\nLanguage Server Protocol (LSP)\n\n#\n\n###\n\nPerl Navigator\n\n#\n\nIf you\u2019re using an editor with LSP support (like Neovim or VS Code), you can\nhopefully get perlimports running via the Perl Navigator Language Server. This\nlanguage server has perlimports disabled by default, so we\u2019ll need to switch\nit on in the configuration and also make sure that we have the perlimports\nbinary installed and in our $PATH.\n\n    \n    \n    { perlimportsProfile = 'perlimports.toml', perlimportsLintEnabled = true, perlimportsTidyEnabled = true, }\n\nIn addition to editor configuration, we can now think about adding perlimports\nto our Continuous Integration and pre-commit hooks as well, so that we\nmaintain the changes we\u2019ve just imposed. We could do this via precious.\n\n##\n\nThe Power of precious\n\n#\n\nI talked about using Code::TidyAll in How Santa\u2019s Elves Keep their Workshop\nTidy. tidyall is a wonderful tool that solves a lot of problems, but its\ndesign was not perfect and it\u2019s looking for a new maintainer. In the meantime,\nprecious has drawn inspiration from tidyall and can be regarded as its\nspiritual successor, even if it\u2019s written in Rust. If we want to run\nperlimports along with other fixing and linting tools, we can use precious for\nthis.\n\nWe won\u2019t cover installation here, but after installing precious we can\ngenerate a stub config file:\n\n    \n    \n    $ precious config init --component perl Writing precious.toml The generated precious.toml requires the following tools to be installed: https://metacpan.org/dist/Perl-Critic https://metacpan.org/dist/Perl-Tidy https://metacpan.org/dist/App-perlimports https://metacpan.org/dist/Pod-Checker https://metacpan.org/dist/Pod-Tidy\n\nLet\u2019s have a look at the created file:\n\n    \n    \n    excludes = [ \".build/**\", \"blib/**\", ] [commands.perlcritic] type = \"lint\" include = [ \"**/*.{pl,pm,t,psgi}\" ] cmd = [ \"perlcritic\", \"--profile=$PRECIOUS_ROOT/perlcriticrc\" ] ok_exit_codes = 0 lint_failure_exit_codes = 2 [commands.perltidy] type = \"both\" include = [ \"**/*.{pl,pm,t,psgi}\" ] cmd = [ \"perltidy\", \"--profile=$PRECIOUS_ROOT/perltidyrc\" ] lint_flags = [ \"--assert-tidy\", \"--no-standard-output\", \"--outfile=/dev/null\" ] tidy_flags = [ \"--backup-and-modify-in-place\", \"--backup-file-extension=/\" ] ok_exit_codes = 0 lint_failure_exit_codes = 2 ignore_stderr = \"Begin Error Output Stream\" [commands.perlimports] type = \"both\" include = [ \"**/*.{pl,pm,t,psgi}\" ] cmd = [ \"perlimports\" ] lint_flags = [\"--lint\" ] tidy_flags = [\"-i\" ] ok_exit_codes = 0 expect_stderr = true [commands.podchecker] type = \"lint\" include = [ \"**/*.{pl,pm,pod}\" ] cmd = [ \"podchecker\", \"--warnings\", \"--warnings\" ] ok_exit_codes = [ 0, 2 ] lint_failure_exit_codes = 1 ignore_stderr = [ \".+ pod syntax OK\", \".+ does not contain any pod commands\", ] [commands.podtidy] type = \"tidy\" include = [ \"**/*.{pl,pm,pod}\" ] cmd = [ \"podtidy\", \"--columns\", \"80\", \"--inplace\", \"--nobackup\" ] ok_exit_codes = 0 lint_failure_exit_codes = 1\n\nWe can see that the config already includes a linting and tidying\nconfiguration for lots of helpful Perl linters and tidiers, including\nperlimports. Now, we can run precious tidy --all or precious lint --all to run\nall sorts of checks in pre-commit hooks and other places where code quality\nneeds to be ensured.\n\nprecious is a powerful tool and it merits its own blog post, but let\u2019s leave\nthis as a quick introduction. Perhaps you\u2019ll feel inspired to try it out.\n\n##\n\nThat\u2019s a Wrap\n\n#\n\nI currently have some capacity in my schedule for client work. If you or your\nteam need help with Perl dependency management and/or integrating perlimports,\nprecious and other code quality tools into your environment, I\u2019m available for\nhire.\n\nWe\u2019ve covered a lot of ground here today. If you have any comments or\nsuggestions for improvements, please do reach out to me. I\u2019d love to hear from\nyou.\n\n# Subscribe for Updates\n\nI'll send occasional emails about my blog posts and other things I think are\ninteresting.\n\nPowered by EmailOctopus\n\n## Related\n\nFind and Fix More Typos\n\nFebruary 6, 2024\u00b71402 words\u00b77 mins\n\nfzf linting Neovim precious tidying typos VS Code\n\nFinding Unused Perl Variables\n\nFebruary 22, 2022\u00b7342 words\u00b72 mins\n\nperl linting\n\nGitHub Copilot Chat: First Impressions\n\nFebruary 29, 2024\u00b73087 words\u00b715 mins\n\nAI GitHub GitHub Copilot\n\n\u2190 \u2192 GitHub Copilot Chat: First Impressions February 29, 2024\n\nBash ^2 Bat ^2 Browser Detection ^2 CPAN ^38 Elasticsearch ^2 Fd ^3 Fzf ^4 Git\n^3 GitHub ^6 Go ^4 Google Summer of Code ^3 HTTP ^4 ICPAN ^5 IPad ^2 IPhone ^4\nLinting ^3 LWP::ConsoleLogger ^3 LWP::UserAgent ^3 MetaCPAN ^45 Objective-C ^4\nOPfW ^3 Perl ^78 Perl Mongers ^3 Perl Toolchain Summit ^9 Perlimports ^2 Plack\n^3 Precious ^2 Prettygoodping ^4 Programming ^27 Prove ^3 Qa Hackathon ^2\nSponsor ^3 Tab Completion ^3 Testing ^3 Tidying ^2 Toronto ^2 UserAgent ^3\n\n\u2191\n\n\u00a9 2024 Olaf Alders\n\nPowered by Hugo & Blowfish\n\n", "frontpage": false}
