{"aid": "40152353", "title": "The Importance of Maybe", "url": "https://zephyrtronium.github.io/articles/lang-maybe.html", "domain": "zephyrtronium.github.io", "votes": 1, "user": "Madxmike", "posted_at": "2024-04-25 01:44:44", "comments": 0, "source_title": "The Importance of Maybe", "source_text": "The Importance of Maybe | zephyrtronium\n\n### zephyrtronium\n\n# The Importance of Maybe\n\nin Thoughts on a Programming Language\n\non Wed, 24 Apr 2024\n\n## 1 + T\n\nThe Maybe or Option type is the simplest parametric sum type. For any given\ntype, it adds exactly one additional value. Hence, 1 + T for some arbitrary\ntype T.\n\nThe usual interpretation is that there is either Some value of type T, or\nNone; or Just a value or Nothing. The particular names depend on your\nheritage. I learned Haskell before Rust or any ML, so I tend to prefer the\nMaybe/Just/Nothing trio. (But I've also written more Rust than Haskell, so I\nsometimes switch to Option/Some/None, or annoyingly mix Just and None. Oh\nwell. All of it means the same thing.)\n\nUsing the sum type (and unit type) syntax we established in the exposition, we\ncan define ligma lang's Maybe type roughly as follows:\n\n    \n    \n    type .Maybe(T: type) = / .Nothing: ** / .Some: T\n\nBut I think this approach is a mistake. The idea of \"possibly absent value\" is\nincredibly prevalent in computing. It's something that programmers should do\nvery often. So, it should be very easy to do.\n\nThe syntax I like happens to be almost exactly what Zig has. For any type T,\nwe can create a Maybe T by writing ?T. A single character as a prefix operator\nfor arguably the most important type constructor.\n\nThere are some things I'd like ?T to do that Zig doesn't provide, though. A\nvery important insight from the land of functional programming is that Maybe T\nis a monad. It's a wrapper around some context that allows us to perform\ncomputations that change with the context.\n\nIn essentially all functional programming languages, one can bind functions\nthat take a T and return a U onto a Maybe T. If the Maybe is Some x, then x\ngoes into the function as an input, and the result of type U is lifted back\ninto the world of Maybes to become a Maybe U. If it's Nothing instead, then\nthe function is ignored and the result remains Nothing.\n\nI want that binding capability for ligma lang, but again, it's something too\nimportant not to have extremely simple syntax. Zig wants you to explicitly\ninspect the optional using if (m) |someValue| (or correspondingly while).\nHaskell lets you use do syntax, which gives the programmer a \"procedural\"\nsublanguage that is really just repeated binding on each result.\n\nWhat I want in ligma lang is this rule:\n\n> If T has a property x of type U, then ?T has a property x of type ?U.\n\nThat is, I want monadic binding on the optional type to be implicit. As usual,\nI'm using \"property\" to mean \"field or method\" (assuming we have methods). In\nthe latter case, this would also imply that optional closures bind application\nas well.\n\nI still haven't actually landed on syntax for Just x and Nothing. Those terms\nI think are still a bit long-winded for how frequent they should be. A cute\nidea would be to write <x> and ><. Maybe (hehe) that's a bit too unusual, but\nI'll roll with it for now.\n\nThere also should be some sense of narrowing, i.e. the ability to recover the\nx in <x> in bound code. In most languages with Maybe or Option, you'd use\npattern matching to do that. No specific ideas for ligma lang yet, considering\nI'm not even sure what functions should look like.\n\n## 1 + 1\n\nNow for a much less certain idea.\n\nThe unit type, which in ligma lang we write as **, has exactly one value.\n(Think \"unit\" as in \"unity\".) The Maybe type constructor takes an arbitrary\ntype and adds exactly one additional value to it. That means that ?**, the\noptional unit type, has exactly two values.\n\nThere's another extremely important type that has exactly two values: bool,\nbeing either true or false. That means we could define type bool = ?**, along\nwith making false mean (>< as ?**) (or whatever syntax) and true mean <**>.\n\nIn combination with implicit binding of function application, we get an\ninteresting property from using this definition. Applying a function to true\nexecutes that function, and applying it to false doesn't. We've uncovered\nlambda calculus, kind of! We do need some syntax for the \"else\" part of\nconditional execution, though.\n\nNote that defining bool this way implies that we need a special definition of\nequality for ?** separate from the implicitly promoted equality on **.\nOtherwise we'd have false == false evaluate to false and true == true evaluate\nto <true>. And the fact that we need special equality for ?** suggests that we\nshould have it for ?T wherever T has equality. And the fact that we should\nhave it for ?T suggests that if we have type constructors then we should have\nthe ability to do it for any type constructor. And now we're basically at type\nclasses.\n\nI'm not sure whether ligma lang will have general type constructors. (I\nstrongly want to avoid allowing recursion in types in consideration of\ncompilation speed, but my understanding is that System F_\u03c9 is fine in that\nregard.) This will be a topic to revisit when that decision is made.\n\nClick here to comment on GitHub!\n\nTagged: programming language, types My blog uses sakura, a classless CSS\nframework. Except as otherwise indicated, all content is Copyright 2023\nBranden J Brown and is licensed under a Creative Commons Attribution-\nNoDerivatives 4.0 International License.\n\n", "frontpage": false}
