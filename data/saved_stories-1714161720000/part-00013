{"aid": "40167057", "title": "Database Migration Systems: An Overview (2021)", "url": "https://bruceoutdoors.wordpress.com/2021/06/28/database-migration-systems-an-overview/", "domain": "bruceoutdoors.wordpress.com", "votes": 1, "user": "todsacerdoti", "posted_at": "2024-04-26 08:25:40", "comments": 0, "source_title": "Database Migration Systems: An Overview", "source_text": "Database Migration Systems: An Overview | Bruceoutdoors Blog of Blots\n\n# Bruceoutdoors Blog of Blots\n\n## Yet another blog of technical ramblings!\n\n# Database Migration Systems: An Overview\n\nPosted on June 28, 2021 by Lee Zhen Yong\n\nI have spent a lot more time than I should be looking into solutions on\ndatabase migrations for RDBMS. Sure, on the surface, there may seem only a few\nways to hammer a nail, but dig a little more and it is an endless rabbit hole.\nI figured in this writeup I will put together all the various techniques and\nideas on handling database migrations.\n\nThese ideas are mainly assembled from 7 different database migration systems :\n\n  1. Flyway \u2013 SQL file-based database migration system\n  2. Liquibase \u2013 flexible migration system with a monitoring dashboard\n  3. Django \u2013 Web framework for Python\n  4. Active Record \u2013 ORM for Ruby on Rails\n  5. Entity Framework \u2013 ORM for .NET\n  6. Alembic \u2013 database migration tool for SQLAlchemy (Python).\n  7. Skeema \u2013 pure-SQL schema management utility.\n\nNow, just because I didn\u2019t mention them here doesn\u2019t mean they are not good.\nThere are simply too many, and I\u2019ve only looked into these 7 in detail. You\nare welcome to comment your favourite below and how it stacks up against the\ncompetition.\n\n## Introduction: The Evolving Database Problem\n\nIn production systems, there is typically no such thing as a final database\nschema. Similar to your app releases, this \u201cfinal\u201d database is a moving\ntarget, and we only develop with the most recent database version (or state).\nNew tables, columns are added, dropped, renamed over time; data gets shuffled\nto different places \u2013 a database tends to evolve from one version to another.\nIt gets messy real quick with a team of developers, so a database migration\nsystem eventually gets introduced, and it is not uncommon that companies will\nopt to build theirs in-house.\n\n> There is a great article by Martin Fowler introducing evolutionary database\n> design, as well as techniques and best practices.\n\n## Essential Components\n\nAlthough database migration systems may have a plethora of ideas of how to go\nsolve the evolving database problem, practically all of them shares 4\nessential components:\n\n  * Migration/revision/changeset\n  * Rollback\n  * Repeatable migration\n  * Version tracking\n\n### Migration\n\nA migration (flyway) or revision (alembic) or changeset (liquibase) is a\nsingle unit of change that brings a database from one version to another. One\nkey problem database migration systems need to address during a migration run\nis execution order. I will go through 4 strategies on how to solve this:\n\n  * Filename\n  * Appearance order\n  * Relative revision\n  * Topological order\n\nFilename. This is the simplest and most intuitive strategy. Chances are if you\nimplement a migration system yourself this would be the first approach you\nwould consider. In flyway, you would organise your migrations as such ('V'\nhere stands for versioned migrations):\n\n    \n    \n    migrations/ \u251c\u2500\u2500 V1__create_table_foo.sql \u251c\u2500\u2500 V1.1__add_column_bar.sql \u2514\u2500\u2500 V2__create_audit_tables.sql\n\nWhen you execute flyway migrate, the files will be executed in numeric order.\nNote that by default, flyway does not execute migrations that are slipped in\nbetween executed migrations (e.g. if V1 and V2 have already been executed and\nyou add V1.1 later, V1.1 does not get executed). This can be changed via the\n-outOfOrder parameter.\n\nAdvertisement\n\nPrivacy Settings\n\nOne problem with this approach is nothing stopping multiple developers from\nsubmitting the same version more than once; flyway will not accept ambiguity\nin versioning. A common solution for this is to have a CI run flyway migrate\nin pull requests. Combine this with only merging pull requests that are up to\ndate with master, and you prevent these conflicts from entering your source\ncode in the first place.\n\nA simpler solution to solve duplicate versioning is using a timestamp. This is\nthe most hassle-free way to resolve this and is the approach that Rails Active\nRecord and .NET Entity Framework uses. After all, what are the odds of\nmultiple developers creating a migration at precisely the same second right??\n\nHere\u2019s an example of Active Record migration folder:\n\n    \n    \n    sample_rails_app/db/migrate/ \u251c\u2500\u2500 20190822013911_create_users.rb \u251c\u2500\u2500 20190822021835_add_index_to_users_email.rb \u2514\u2500\u2500 20190827030205_create_relationships.rb\n\nNote that you could also do this in flyway (e.g.\nV20210617115301__create_table_foo.sql) \u2013 but unlike flyway, both the migration\nfilename and contents in Active Record and Entity are generated, where the\nprefix is the timestamp of migration creation. I will elaborate more on this\nlater.\n\nAppearance Order. A migration in liquibase is referred to as a changeset.\nMultiple changesets are stored in changelog file. When you first configure\nLiquibase you need to specify a single master changelog file. In addition to\nchangesets, a changelog file can reference multiple changelog files. Liquibase\nthen executes all changesets and referenced changelogs in order of appearance\nwithin the master changelog file, from top to bottom. This makes changing\nexecution order trivial as compared to changing around filenames.\n\nLiquibase recommends the following directory structure, where the changelog is\nnamed after the app release version (not the migration version):\n\n    \n    \n    com/example/db/changelog/ \u251c\u2500\u2500 db.changelog-master.xml \u251c\u2500\u2500 db.changelog-1.0.xml \u251c\u2500\u2500 db.changelog-1.1.xml \u2514\u2500\u2500 db.changelog-2.0.xml\n\nThe order of execution is then dictated by the master file db.changelog-\nmaster.xml:\n\n<?xml version=\"1.0\"\nencoding=\"UTF-8\"?><databaseChangeLogxmlns=\"http://www.liquibase.org/xml/ns/dbchangelog\"xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-\ninstance\"xsi:schemaLocation=\"http://www.liquibase.org/xml/ns/dbchangeloghttp://www.liquibase.org/xml/ns/dbchangelog/dbchangelog-3.8.xsd\"><include\nfile=\"com/example/db/changelog/db.changelog-1.0.xml\"/><include\nfile=\"com/example/db/changelog/db.changelog-1.1.xml\"/><include\nfile=\"com/example/db/changelog/db.changelog-2.0.xml\"/></databaseChangeLog>  \n---  \n  \nYou can check out how this is used in practice in keycloak\u2019s github repo (the\nmaster file is called jpa-changelog-master.xml, which is referenced here).\n\n> Note: It\u2019s a pervasive misunderstanding that liquibase only supports XML.\n> Hardcore DBAs can rejoice to know that you can also write your changesets in\n> SQL. Doing so would deprive you of magical features, but liquibase does\n> allow you to use both file types in the same project!\n\nAs with using filenames, conflicts do exist when multiple developers write to\nthe same file, but liquibase claims that this is much simpler to deal with\nusing version control systems like git.\n\nAdvertisement\n\nPrivacy Settings\n\nRelative Revision. This is used in Alembic, where migrations are called\nrevisions. The idea is that execution order is not dictated by appearance or\nfilename, but relative from one revision to another, beginning from the\ninitial revision. This can be confusing at first, for example when you see the\nmigration folder in Apache Airflow it looks like this unordered mess:\n\n    \n    \n    airflow/airflow/migrations/versions/ \u251c\u2500\u2500 004c1210f153_increase_queue_name_size_limit.py \u251c\u2500\u2500 03afc6b6f902_increase_length_of_fab_ab_view_menu_.py \u251c\u2500\u2500 ... \u251c\u2500\u2500 f2ca10b85618_add_dag_stats_table.py \u2514\u2500\u2500 fe461863935f_increase_length_for_connection_password.py\n\nThe first 12 characters prefixed to every migration file is its hash, this is\ncalled a \u201crevision ID\u201d \u2013 it identifies a migration, but tells nothing about\nthe execution order. To query the past execution order, you need to run\nalembic history.\n\nAlembic determines ordering from 2 attributes in every revision file. Consider\nan initial revision 1975ea83b712_create_account_table.py that is generated by\nthe alembic generate command:\n\n# 1975ea83b712_create_account_table.pyrevision = '1975ea83b712'down_revision =\nNone  \n---  \n  \nThe revision attribute is the same as the migration\u2019s revision ID. Where\ndown_revision is None, we know that this is a root node; the first revision\nthat gets executed. Say another revision ae1027a6acf_add_some_column.py gets\nadded (also generated by alembic generate):\n\n# ae1027a6acf_add_some_column.pyrevision = 'ae1027a6acf'down_revision =\n'1975ea83b712'  \n---  \n  \nThis declares that revision ae1027a6acf revises 1975ea83b712, and therefore\nrequires 1975ea83b712 to be executed first. So each subsequent revision from\nthe root knows which revision it modifies, and from there you can build an\nexecution order 1975ea83b712 \u2192 ae1027a6acf.\n\nTo run migrations, we use alembic upgrade head, where head will point to the\nmost recent revision.\n\nThough we would be tempted to think of this as a linked list, where each node\nhas a reference to another node, in cases where there are multiple developers\nit is more like a tree. This is because Alembic allows multiple revisions to\n\u201cbranch\u201d from a shared parent (i.e. there is more than one revision file that\nhas the same down_revision). In such cases, alembic upgrade head will fail as\nthere are multiple head\u2018s. To resolve this, a developer would use alembic\nmerge to merge all heads into one. The Alembic branch docs have a nice ASCII\nart to illustrate this:\n\nThe merge command will create another revision file that fuses more than one\nrevision to a single timeline. This is simply a revision file with multiple\ndown_revision:\n\nrevision = '53fffde5ad5'down_revision = ('ae1027a6acf', '27c6a30d7c24')  \n---  \n  \nAs you might be able to tell, these concepts on branching, merging, and head\nrevision is very similar to git. And similar to git, you don\u2019t have to create\na merge commit; another strategy is \u201crebase\u201d, which means you change the\nparent revision (i.e. down_revision). Assuming there are no conflicts, you can\ndo away with the merge revision and get a clean timeline with no branches.\n\nAdvertisement\n\nPrivacy Settings\n\nIn the case of our above example, we would change the down_revision of\n27c6a30d7c24 from 1975ea83b712 to ae1027a6acf (notice that we also removed\n53fffde5ad5):\n\nTopological order. This idea is unique in that it does not see migrations as a\nlinear path with a start and end, but a directed acyclic graph (DAG) where the\nnodes are migrations and the edges are dependencies. An example of a\ndependency would be if you have a foreign key constraint, the table it points\nto must first exist. Now you can run migrations in any order you like, as long\nas dependencies are met; the execution order is thus defined by its\ntopological order, and there can be many viable paths.\n\nIn Django, every model has its own migration folder. Take this example from\nThinkster\u2018s Django Realworld Example App (simplified for brevity):\n\n    \n    \n    django-realworld-example-app/conduit/apps \u251c\u2500\u2500 articles \u2502 \u2514\u2500\u2500 migrations \u2502 \u251c\u2500\u2500 0001_initial.py \u2502 \u251c\u2500\u2500 0002_comment.py \u2502 \u2514\u2500\u2500 0003_auto_20160828_1656.py \u2514\u2500\u2500 profiles \u2514\u2500\u2500 migrations \u251c\u2500\u2500 0001_initial.py \u251c\u2500\u2500 0002_profile_follows.py \u2514\u2500\u2500 0003_profile_favorites.py\n\nEvery migration file has a dependencies attribute, which may contain zero or\nmore dependencies. If a migration has no dependencies, it can be executed\nprior to other migrations. For example in 0003_profile_favorites.py:\n\ndependencies = [('articles', '0002_comment'),('profiles',\n'0002_profile_follows'),]  \n---  \n  \nTo make the concept more visually apparent, here is its DAG along with a\nviable topological order (from 1 to 6):\n\nBlue nodes are profile model, yellow nodes are article model. The directional\nedges can be viewed as \u201c\u2014required by \u2192\u201d. Red circles on the corners of each\nnode mark execution order.\n\n> Read Django\u2019s official documentation on this in \u201cControlling the order of\n> migrations\u201c\n\nAs pointed out earlier, there can be multiple viable execution orders for as\nlong as the dependency conditions are satisfied. For the above example, the\nfollowing is also a valid execution order:\n\n  1. profiles:0001_initial.py\n  2. articles:0001_initial.py\n  3. articles:0002_comment.py\n  4. profiles:0002_profile_follows.py\n  5. articles:0003_auto_20160828_1656.py\n  6. profiles:0003_profile_favorites.py\n\nThis seems complex, but it provides a lot of flexibility for developers, and\ngreatly reduce the chance of conflicts. Also, developers working with Django\nare usually insulated from migration implementation details as it is generated\nvia django-admin makemigrations command.\n\n### Rollback\n\nA rollback reverts a specific migration. A simple case is when you add a\ncolumn in a migration, its corresponding rollback would be to drop the column.\nTypically rollbacks are added within the same migration file, where a migrate\nfunction has a corresponding rollback function, as is the case for Entity\nFramework (Up and Down), and Alembic (upgrade and downgrade).\n\nAdvertisement\n\nPrivacy Settings\n\nSome implementations (e.g. Django, Active Record) decide to go a step further\nby not even requiring an explicit rollback function; the migration tool\nautomagically figures it out for you ! In Liquibase, if you use their\nXML/YAML/JSON syntax, it can also automatically figure out how to rollback a\nchangeset.\n\nIn flyway, rollbacks are called undo migrations; these are just SQL files that\nmap to a corresponding migration (e.g. a V23__add_column_bar.sql is reverted\nby U23__drop_column_bar.sql). In addition, undo migrations are a paid feature\nin flyway; not only do you have to write them out by hand, but you also had to\npay for a license to do it.\n\nThis is not all bad, since you may not always be able to generate or write a\nrollback. For example, although you can reverse adding a column, you can\u2019t\nundrop a table or a column, and you can\u2019t undelete rows; once data is gone, it\nis gone for real. In practice, DBAs tend to only go forward. If you regret\nsome design decision in the past and want to revert it, you write another\nmigration. However, rollbacks are still handy as a plan B in situations where\ndeployments go horribly wrong despite meticulous planning.\n\n### Repeatable Migration\n\nThere are special cases where you would want to run a migration more than\nonce. These are often stored procedures, and views \u2013 and in cases where\nbusiness logic is part of the database, they are often changed.\n\nTypically repeatable migration work by comparing the checksum of migration of\npast execution and current execution. Flyway prefixes repeatable migrations\nwith R__, and they are always executed last in any migrate run. Liquibase\nsupports a runOnChange changeset attribute that reruns the changeset when\nchanges are detected.\n\nORM focused migration tools like Active Record, Entity Framework, Alembic,\nDjango would presume you will never need repeatable migrations. In fact, if\nyou come from ORM land, stored procedures and views are a foreign concept, if\nnot frowned upon (as the rails purists would say, \u201cIt is not the rails way!\u201d\n).\n\nAlthough Alembic does not support repeatable migrations out of the box, there\nis a community contribution Alembic Utils that adds support for it... for\nPostgres only. Otherwise, you are left with implementing it yourself via this\nReplaceableObject recipe in the Alembic cookbook.\n\n### Version Tracking\n\nVersion tracking is a technique to guarantee that migrations only execute\nonce, or in the case of repeatable migrations \u2013 only when the migration has\nbeen modified.\n\nPractically every database migration system will implement this as a tracking\ntable in your database. Storing tracking information in your database\nguarantees atomicity during a migration run (i.e. if a migration fails the\nversion is never tracked). Migration systems may also place a table-level\nwrite-lock on a migration table to assert such that only one migration run can\nhappen at any given moment; this is particularly useful when you have multiple\ncopies of your app connecting to the same database in parallel.\n\nAdvertisement\n\nPrivacy Settings\n\nVersion tracking tables go by many names: alembic_version (Alembic),\n__eFMigrationsHistory (Entity Framework), schema_migrations (Active Record),\nflyway_schema_history (Flyway), DATABASECHANGELOG + DATABASECHANGELOGLOCK\n(Liquibase), and django_migrations (Django).\n\nTypically, tracking tables store only the migration version, identifier, or\nfilename. Execution timestamp may also be stored, allowing developers to roll\nback to a specific point in time. In some implementations like Flyway and\nLiquibase, tracking tables also store checksums. These are used for 2 things:\n\n  1. For normal migrations, checksum asserts that an executed migration has not been tampered with.\n  2. For repeatable migrations, checksums are used to determine if migration needs to be re-executed.\n\n## Workflows\n\nAlthough database migration systems share a lot of essential components, their\nworkflows tend to differentiate them from the rest.\n\n  1. Revision based workflow\n  2. Code first workflow\n\nFor each workflow, there are 2 paradigms: either you write SQL that the\ndatabase directly runs, or rely on source-code generation. In source-code\ngeneration, you write your migration in some other language than SQL (XML, C#,\nRuby DSL,.. etc) that generates SQL code. It\u2019s an extra step \u2013 yes, but\ndevelopers love this approach with religious vigour. There are a few key\nreasons:\n\n  1. It can support different database vendors\n  2. Can do automatic rollbacks\n  3. Allows developers to write in their favourite programming language\n\nAlright, let us walk through the different workflows.\n\n### Revision Based Workflow\n\nIn a revision based workflow, you write your migration script first, and that\ndetermines the next database state. Then continue to add subsequent migration\nscripts continue to evolve the database over time.\n\nIn Flyway, you write raw SQL files the follows a specific naming convention.\nIn Liquibase, you typically use XML, and that enables vendor-independent\nmigrations as well as automatic rollbacks. Active Record takes this a step\nfurther with a command that generates migrations for you; use rails generate\nmodel command to create a migration file. For example:\n\n    \n    \n    rails generate model Post title:string link:string upvotes:integer\n\nThis creates db/migrate/20210627134448_create_posts.rb, written in Ruby DSL\n(Domain Specific Language):\n\nclass CreatePosts < ActiveRecord::Migration[5.2]def changecreate_table :posts\ndo |t|t.string :titlet.string :linkt.integer :upvotest.timestampsendendend  \n---  \n  \nTo make changes to a model you use rails generate migration. For example to\nadd a downvotes column to the posts table do:\n\n    \n    \n    rails generate migration AddDownvotesToPost downvotes:int\n\nMore than just being descriptive, the migration name you provide in the\ngenerate migration command is used to create the migration itself (i.e. it\nfigures out you want to add a column to the posts table from the name\nAddDownvotesToPost).\n\n### Code First Workflow\n\nA code first workflow can also be thought of as a declarative workflow: you\nfirst model out how you want your database to be, and let the migration system\ngenerate a migration.\n\nAdvertisement\n\nPrivacy Settings\n\nTake this Entity Framework model (C#) from their getting started guide:\n\nnamespace ContosoUniversity.Models{public class Student{public int ID { get;\nset; }public string LastName { get; set; }public string FirstMidName { get;\nset; }public DateTime EnrollmentDate { get; set; }public virtual\nICollection<Enrollment> Enrollments { get; set; }}}  \n---  \n  \nThen you execute add-migration <DescriptionMigrationName> and a migration file\n(also in C#) is automagically generated. When you make changes to your\nclasses, simply run add-migration to create a new migration file. In short,\nyour C# classes determine the current state of your database. In Entity\nFramework lingo, this is known as \u201cCode First Migrations\u201c, and when I first\nsaw this as a young developer 4 years ago, it blew my mind.\n\nAs I eluded to earlier, Django also generates its migration files from its\nmodels with its makemigrations command. Alembic supports this as well via an\nadditional --autogenerate flag to the alembic revision command.\n\nFor folks that disdain source-code generation, Skeema allows you to declare\nthe final schema in SQL, and it generates a SQL diff that changes the target\ndatabase state to the declared state. In fact, it is so confident in this\napproach it does not even do version tracking. There are no replaying\nhistorical migration files; whether it be a new development instance or\nproduction database, we are always one migration away from the declared\nschema.\n\nEven though it uses plain SQL, Skeema does not parse SQL code itself; it runs\nthe SQL code in a temporary location called a workspace and compares it with\nthe schema of your target database. The generated SQL can be reviewed via\nskeema diff, and deployed via skeema push.\n\nSome caveats: as cool as code first workflows may sound, they would not cater\nto ambiguous cases. For example, did you rename column color to colour, or did\nyou drop column color and added a new column colour? The simple answer is that\nthere is no way to tell apart renames. Skeema details this drawback in its\nproduct announcement, but assures that renames rarely happen .\n\n## Closing Thoughts\n\nFinding the right approach is more than just performance or features. You need\nto think about developers in your team whether they want to work with some\ncustom migration solution you found in a comment in Hackernews, that points to\nsome GitHub repository with barely any activity or stars. Rarely would\ndevelopers want to learn something just for one project. Any database\nmigration system you introduce puts a learning curve for your team. Most\nlikely those developers would know little SQL and would hardly have any\ninterest in being good at it. Typically the database migration system they\nwould opt to use is simply the one that comes bundled to the chosen web\nframework.\n\nAdvertisement\n\nPrivacy Settings\n\nDatabase migration is a messy conundrum without perfect solutions. As I would\ncome to learn \u2013 we simply need to decide what is best on a case by case basis.\n\n### Share this:\n\n  * Click to print (Opens in new window)\n  * Click to email a link to a friend (Opens in new window)\n  * Click to share on Reddit (Opens in new window)\n  * Click to share on WhatsApp (Opens in new window)\n  * Click to share on Telegram (Opens in new window)\n  * Click to share on Twitter (Opens in new window)\n  * Click to share on LinkedIn (Opens in new window)\n  * Click to share on Facebook (Opens in new window)\n\nLike Loading...\n\n### Related\n\n#### Generic Java GUI Netbeans Project with Embedded Database\n\nSo your team just wants to create a java GUI project that requires a database.\nHow do you minimize the hassle of configuring a database? For this reason I\ncreated this simple generic Micropost project to serve as a template to start\nout. Link to Project: https://github.com/bruceoutdoors/MicropostsExample This\nguide requires that...\n\nDecember 4, 2015\n\nIn \"derbydb\"\n\n#### Ninja Framework Tutorial \u2013 PART 3: Connect and Migrate a Database (H2,\nMySQL)\n\nThis a part of a series of tutorials on Ninja Framework. You can click here to\nsee the full set. Abstract I'll talk a bit about the built-in embedded H2\ndatabase, followed by how to setup and connect to a MySQL database. Though\nthis guide is specific to MySQL, you...\n\nApril 24, 2015\n\nIn \"Ninja Framework Tutorials\"\n\n#### Converting a Java Project to Use JPA\n\nIn this post I walk through some of the gotchas when converting a java\napplication that works with raw SQL strings to one using ORM (Object\nRelational Mapping) via JPA (Java Persistence API). I will be converting a\nsimple application from \"Generic Java GUI Netbeans Project with Embedded\nDatabase\" that only has...\n\nJanuary 10, 2016\n\nIn \"Java\"\n\nThis entry was posted in Uncategorized and tagged Alembic, Database Migration,\nDjango, Entity Framework, Flyway, Liquibase, RDBMS, Ruby on Rails, Skeema,\nSQL. Bookmark the permalink.\n\n### Leave a comment Cancel reply\n\nThis site uses Akismet to reduce spam. Learn how your comment data is\nprocessed.\n\n# Public Profile\n\n#### Lee Zhen Yong\n\nMastery oriented, tenacious learning spirit; motivated by challenge and\nhealthy rivalry.\n\nView Full Profile \u2192\n\n# Recent Posts\n\n  * How to Build a WireGuard VPN February 1, 2023\n  * Secure by Design: Cybersecurity is Important for Developers December 9, 2022\n  * Setting Up Phan in VSCode July 22, 2022\n  * Database Migration Systems: An Overview June 28, 2021\n  * Testing PubSub Locally with Python + Docker June 10, 2020\n\n# Top Posts & Pages\n\n  * Database Migration Systems: An Overview\n  * How to Setup LUKS2 encrypted Ubuntu 20.04 With Dual Boot\n  * VB.NET to Access: Tutorial + Example\n  * Using std::unique_ptr as a class member (C++11)\n  * CS231n Tutorials\n\nJoin 49 other subscribers\n\n# Categories\n\n# Tag Cloud\n\nAI algorithms C++ C++11 CodeForces CS231n dfs dft dynamic programming fft\nGraph Theory Hashicorp Atlas Java Javascript JPA longest increasing\nsubsequence Machine Learning Netbeans Ninja Framework OGLMan python Qt Creator\nRuby on Rails SPOJ Tutorial Ubuntu UVa Vagrant VirtualBox XML\n\n# Archives\n\n# Hit Counter\n\n  * 156,331 hits\n\nBlog at WordPress.com.\n\n  * Comment\n  * Reblog\n  * Subscribe Subscribed\n\n    * Bruceoutdoors Blog of Blots\n    * Already have a WordPress.com account? Log in now.\n\n  * Privacy\n  *     * Bruceoutdoors Blog of Blots\n    * Customize\n    * Subscribe Subscribed\n    * Sign up\n    * Log in\n    * Copy shortlink\n    * Report this content\n    * View post in Reader\n    * Manage subscriptions\n    * Collapse this bar\n\nLoading Comments...\n\n%d\n\n", "frontpage": false}
