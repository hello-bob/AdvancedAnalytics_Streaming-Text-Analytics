{"aid": "40131721", "title": "Show HN: Kilo \u2013 Lightweight REST for Java", "url": "https://github.com/HTTP-RPC/Kilo", "domain": "github.com/http-rpc", "votes": 2, "user": "gk_brown", "posted_at": "2024-04-23 13:27:03", "comments": 0, "source_title": "GitHub - HTTP-RPC/Kilo: Lightweight REST for Java", "source_text": "GitHub - HTTP-RPC/Kilo: Lightweight REST for Java\n\n## Navigation Menu\n\nSkip to content\n\nSign in\n\n# Search code, repositories, users, issues, pull requests...\n\nSearch syntax tips\n\nSign in\n\nSign up\n\nYou signed in with another tab or window. Reload to refresh your session. You\nsigned out in another tab or window. Reload to refresh your session. You\nswitched accounts on another tab or window. Reload to refresh your session.\nDismiss alert\n\nHTTP-RPC / Kilo Public\n\n  * Notifications\n  * Fork 63\n  * Star 321\n\nLightweight REST for Java\n\n### License\n\nApache-2.0 license\n\n321 stars 63 forks Branches Tags Activity\n\nStar\n\nNotifications\n\n# HTTP-RPC/Kilo\n\nThis commit does not belong to any branch on this repository, and may belong\nto a fork outside of the repository.\n\n1 Branch\n\n103 Tags\n\n## Folders and files\n\nName| Name| Last commit message| Last commit date  \n---|---|---|---  \n  \n## Latest commit\n\ngk-brownUpdate documentation.Apr 23, 2024c409223 \u00b7 Apr 23, 2024Apr 23, 2024\n\n## History\n\n2,288 Commits  \n  \n### .idea\n\n|\n\n### .idea\n\n| Update BeanAdapter.| Apr 19, 2024  \n  \n### README\n\n|\n\n### README\n\n| Update README.md.| Mar 14, 2024  \n  \n### docs\n\n|\n\n### docs\n\n| Correct project URL.| Jul 9, 2022  \n  \n### gradle/wrapper\n\n|\n\n### gradle/wrapper\n\n| Update BeanAdapter.| Apr 19, 2024  \n  \n### kilo-client\n\n|\n\n### kilo-client\n\n| Update documentation.| Apr 23, 2024  \n  \n### kilo-server\n\n|\n\n### kilo-server\n\n| Update WebService.| Apr 20, 2024  \n  \n### kilo-test\n\n|\n\n### kilo-test\n\n| Update QueryBuilder.| Apr 22, 2024  \n  \n### .gitignore\n\n|\n\n### .gitignore\n\n| Update project files.| Dec 7, 2023  \n  \n### LICENSE\n\n|\n\n### LICENSE\n\n| Initial commit| Jun 9, 2015  \n  \n### README.md\n\n|\n\n### README.md\n\n| Update QueryBuilder.| Apr 22, 2024  \n  \n### build.gradle\n\n|\n\n### build.gradle\n\n| Update QueryBuilder.| Apr 21, 2024  \n  \n### db.sql\n\n|\n\n### db.sql\n\n| Add JSON support to QueryBuilder.| Apr 21, 2024  \n  \n### gradle.properties\n\n|\n\n### gradle.properties\n\n| Update BeanAdapter.| Apr 19, 2024  \n  \n### gradlew\n\n|\n\n### gradlew\n\n| Update BeanAdapter.| Apr 19, 2024  \n  \n### gradlew.bat\n\n|\n\n### gradlew.bat\n\n| Update BeanAdapter.| Apr 19, 2024  \n  \n### kilo.png\n\n|\n\n### kilo.png\n\n| Update README.md.| May 10, 2022  \n  \n### publish.gradle\n\n|\n\n### publish.gradle\n\n| Use Gradle 8.4.| Oct 23, 2023  \n  \n### settings.gradle\n\n|\n\n### settings.gradle\n\n| Remove extra whitespace.| Dec 13, 2022  \n  \n### template-reference.md\n\n|\n\n### template-reference.md\n\n| Drop support for \"url\" modifier.| Nov 3, 2023  \n  \n## Repository files navigation\n\n# Introduction\n\nKilo is an open-source framework for creating and consuming RESTful and REST-\nlike web services in Java. It is extremely lightweight and requires only a\nJava runtime environment and a servlet container. The entire framework is less\nthan 150KB in size, making it an ideal choice for applications where a minimal\nfootprint is desired.\n\nThe project's name comes from the nautical K or Kilo flag, which means \"I wish\nto communicate with you\":\n\nThis guide introduces the Kilo framework and provides an overview of its key\nfeatures.\n\n# Contents\n\n  * Getting Kilo\n  * Kilo Classes\n  * Kotlin Support\n  * Additional Information\n\n# Getting Kilo\n\nKilo is distributed via Maven Central:\n\n  * org.httprpc:kilo-client - includes support for consuming web services, interacting with relational databases, and working with common file formats (Java 17 or later required)\n  * org.httprpc:kilo-server - depends on client; includes support for creating web services (Jakarta Servlet specification 5.0 or later required)\n\n# Kilo Classes\n\nClasses provided by the Kilo framework include:\n\n  * WebService\n  * WebServiceProxy\n  * JSONEncoder and JSONDecoder\n  * CSVEncoder and CSVDecoder\n  * TextEncoder and TextDecoder\n  * TemplateEncoder\n  * BeanAdapter\n  * QueryBuilder and ResultSetAdapter\n  * ElementAdapter\n  * ResourceBundleAdapter\n  * Pipe\n  * Collections and Optionals\n\nEach is discussed in more detail below.\n\n## WebService\n\nWebService is an abstract base class for web services. It extends HttpServlet\nand provides a thin, REST-oriented layer on top of the standard servlet API.\n\nService operations are defined by adding public methods to a concrete service\nimplementation. Methods are invoked by submitting an HTTP request for a path\nassociated with a service instance. Arguments may be provided via the query\nstring, resource path, or request body. WebService converts the values to the\nexpected types, invokes the method, and writes the return value (if any) to\nthe output stream as JSON.\n\nThe RequestMethod annotation is used to associate a service method with an\nHTTP verb such as GET or POST. The optional ResourcePath annotation can be\nused to associate the method with a specific path relative to the servlet. If\nunspecified, the method is associated with the servlet itself.\n\nMultiple methods may be associated with the same verb and path. WebService\nselects the best method to execute based on the provided argument values. For\nexample, the following service class implements some simple mathematical\noperations:\n\n    \n    \n    @WebServlet(urlPatterns = {\"/math/*\"}, loadOnStartup = 1) @Description(\"Math example service.\") public class MathService extends WebService { @RequestMethod(\"GET\") @ResourcePath(\"sum\") @Description(\"Calculates the sum of two numbers.\") public double getSum( @Description(\"The first number.\") double a, @Description(\"The second number.\") double b ) { return a + b; } @RequestMethod(\"GET\") @ResourcePath(\"sum\") @Description(\"Calculates the sum of a list of numbers.\") public double getSum( @Description(\"The numbers to add.\") List<Double> values ) { double total = 0; for (double value : values) { total += value; } return total; } }\n\nThis request would cause the first method to be invoked:\n\n    \n    \n    GET /math/sum?a=2&b=4\n\nwhile this request would invoke the second method:\n\n    \n    \n    GET /math/sum?values=1&values=2&values=3\n\nIn either case, the service would return the value 6 in response.\n\nArguments may also be submitted as form data. If no matching handler method is\nfound for a given request, the default handler (e.g. doGet()) will be called.\n\nAt least one URL pattern is required, and it must be a path mapping (i.e.\nbegin with a leading slash and end with a trailing slash and asterisk). It is\nrecommended that services be configured to load automatically on startup. This\nensures that they will be immediately available to other services and included\nin the generated documentation.\n\n### Method Parameters\n\nMethod parameters may be any of the following types:\n\n  * Byte/byte\n  * Short/short\n  * Integer/int\n  * Long/long\n  * Float/float\n  * Double/double\n  * Boolean/boolean\n  * Character/char\n  * String\n  * java.util.Date\n  * java.time.Instant\n  * java.time.LocalDate\n  * java.time.LocalTime\n  * java.time.LocalDateTime\n  * java.time.Duration\n  * java.time.Period\n  * java.util.UUID\n  * java.util.List, java.util.Set, array/varargs\n  * java.net.URL\n\nAdditionally, java.util.Map, bean, and record types are supported for body\ncontent.\n\nUnspecified values are automatically converted to 0, false, or the null\ncharacter for primitive types. Date values are parsed from a long value\nrepresenting epoch time in milliseconds. Other values are parsed from their\nstring representations.\n\nList, Set, and array elements are automatically converted to their declared\ntypes. If no values are provided for a list, set, or array parameter, an empty\nvalue (not null) will be passed to the method.\n\nURL parameters represent file uploads. They may be used only with POST\nrequests submitted using the multi-part form data encoding. See the file\nupload example for more information.\n\nIf a provided value cannot be coerced to the expected type, an HTTP 403\n(forbidden) response will be returned. If no method is found that matches the\nprovided arguments, HTTP 405 (method not allowed) will be returned.\n\nNote that service classes must be compiled with the -parameters flag so that\nparameter names are available at runtime.\n\n#### Required Parameters\n\nParameters that must be provided by the caller can be indicated by the\nRequired annotation. For example, the following service method accepts a\nsingle required file argument:\n\n    \n    \n    @RequestMethod(\"POST\") @Description(\"Uploads a single file.\") @Empty public long uploadFile( @Description(\"The file to upload.\") @Required URL file ) throws IOException { ... }\n\nList, Set, and array parameters are implicitly required, since these values\nwill never be null (though they may be empty). For all other parameter types,\nHTTP 403 will be returned if a required value is not provided.\n\nThe Empty annotation indicates that the method does not accept a body and is\ndiscussed in more detail later.\n\n#### Custom Parameter Names\n\nThe Name annotation can be used to associate a custom name with a method\nparameter. For example:\n\n    \n    \n    @WebServlet(urlPatterns = {\"/members/*\"}, loadOnStartup = 1) public class MemberService extends WebService { @RequestMethod(\"GET\") public List<Person> getMembers( @Name(\"first_name\") String firstName, @Name(\"last_name\") String lastName ) { ... } }\n\nThis method could be invoked as follows:\n\n    \n    \n    GET /members?first_name=foo*&last_name=bar*\n\n### Path Variables\n\nPath variables (or \"keys\") are specified by a \"?\" character in an endpoint's\nresource path. For example, the itemID argument in the method below is\nprovided by a path variable:\n\n    \n    \n    @RequestMethod(\"GET\") @ResourcePath(\"items/?\") @Description(\"Returns detailed information about a specific item.\") public ItemDetail getItem( @Description(\"The item ID.\") Integer itemID ) throws SQLException { ... }\n\nPath parameters must precede query parameters in the method signature and are\nimplicitly required. Values are mapped to method arguments in declaration\norder.\n\n### Body Content\n\nBody content may be declared as the final parameter in a POST or PUT handler.\nFor example, this method accepts an item ID as a path variable and an instance\nof ItemDetail as a body argument:\n\n    \n    \n    @RequestMethod(\"PUT\") @ResourcePath(\"items/?\") @Description(\"Updates an item.\") public void updateItem( @Description(\"The item ID.\") Integer itemID, @Description(\"The updated item.\") ItemDetail item ) throws SQLException { ... }\n\nLike path parameters, body parameters are implicitly required. By default,\ncontent is assumed to be JSON and is automatically converted to the specified\ntype. However, subclasses can override the decodeBody() method to perform\ncustom conversions.\n\nThe Empty annotation can be used to indicate that a service method does not\naccept a body. It is only required for empty POST or PUT requests (GET and\nDELETE requests are inherently empty). Handlers for POST requests submitted as\nform data must include this annotation.\n\n### Return Values\n\nReturn values are converted to JSON as follows:\n\n  * String: string\n  * Number/numeric primitive: number\n  * Boolean/boolean: boolean\n  * java.util.Date: number representing epoch time in milliseconds\n  * Iterable: array\n  * java.util.Map: object\n\nAdditionally, instances of the following types are automatically converted to\ntheir string representations:\n\n  * Character/char\n  * Enum\n  * java.time.TemporalAccessor\n  * java.time.TemporalAmount\n  * java.util.UUID\n  * java.net.URL\n\nAll other values are assumed to be beans and are serialized as objects.\n\nBy default, an HTTP 200 (OK) response is returned when a service method\ncompletes successfully. However, if the handler method is annotated with\nCreates, HTTP 201 (created) will be returned instead. If the handler's return\ntype is void or Void, HTTP 204 (no content) will be returned.\n\nIf a service method returns null, an HTTP 404 (not found) response will be\nreturned.\n\n#### Custom Result Encodings\n\nAlthough return values are encoded as JSON by default, subclasses can override\nthe encodeResult() method of the WebService class to support alternative\nrepresentations. See the method documentation for more information.\n\n### Request and Repsonse Properties\n\nThe following methods provide access to the request and response objects\nassociated with the current invocation:\n\n    \n    \n    protected HttpServletRequest getRequest() { ... } protected HttpServletResponse getResponse() { ... }\n\nFor example, a service might use the request to get the name of the current\nuser, or use the response to return a custom header.\n\nThe response object can also be used to produce a custom result. If a service\nmethod commits the response by writing to the output stream, the method's\nreturn value (if any) will be ignored by WebService. This allows a service to\nreturn content that cannot be easily represented as JSON, such as image data.\n\n### Exceptions\n\nIf an exception is thrown by a service method and the response has not yet\nbeen committed, the exception message (if any) will be returned as plain text\nin the response body. Error status is returned as shown below:\n\n  * IllegalArgumentException or UnsupportedOperationException - HTTP 403 (forbidden)\n  * NoSuchElementException - HTTP 404 (not found)\n  * IllegalStateException - HTTP 409 (conflict)\n  * Any other exception - HTTP 500 (internal server error)\n\nSubclasses can override the reportError() method to perform custom error\nhandling.\n\n### Inter-Service Communication\n\nA reference to any active service can be obtained via the getInstance() method\nof the WebService class. This can be useful when the implementation of one\nservice depends on functionality provided by another service, for example.\n\n### API Documentation\n\nAn index of all active services can be found at the application's context\nroot:\n\n    \n    \n    GET http://localhost:8080/kilo-test/\n\nDocumentation for a specific service can be viewed by appending \"?api\" to the\nservice's base URL:\n\n    \n    \n    GET http://localhost:8080/kilo-test/catalog?api\n\nEndpoints are grouped by resource path. Implementations can provide additional\ninformation about service types and operations using the Description\nannotation. For example:\n\n    \n    \n    @WebServlet(urlPatterns = {\"/catalog/*\"}, loadOnStartup = 1) @Description(\"Catalog example service.\") public class CatalogService extends AbstractDatabaseService { @RequestMethod(\"GET\") @ResourcePath(\"items\") @Description(\"Returns a list of all items in the catalog.\") public List<Item> getItems() throws SQLException { ... } ... }\n\nDescriptions can also be associated with bean types, enums, and records:\n\n    \n    \n    @Table(\"item\") @Description(\"Represents an item in the catalog.\") public interface Item { @Name(\"id\") @Column(\"id\") @PrimaryKey @Description(\"The item's ID.\") Integer getID(); void setID(Integer id); @Column(\"description\") @Index @Description(\"The item's description.\") @Required String getDescription(); void setDescription(String description); @Column(\"price\") @Description(\"The item's price.\") @Required Double getPrice(); void setPrice(Double price); }\n    \n    \n    @Description(\"Represents a size option.\") public enum Size { @Description(\"A small size.\") SMALL, @Description(\"A medium size.\") MEDIUM, @Description(\"A large size.\") LARGE }\n    \n    \n    @Description(\"Represents an x/y coordinate pair.\") public record Coordinates( @Description(\"The x-coordinate.\") @Required int x, @Description(\"The y-coordinate.\") @Required int y ) { }\n\nTypes or methods tagged with the Deprecated annotation will be identified as\nsuch in the output.\n\n#### JSON Documentation\n\nA JSON version of the generated documentation can be obtained by specifying an\n\"Accept\" type of \"application/json\" in the request headers. The response can\nbe used to process an API definition programatically; for example, to generate\nclient-side stub code.\n\n## WebServiceProxy\n\nThe WebServiceProxy class is used to submit API requests to a server. It\nprovides the following two constructors:\n\n    \n    \n    public WebServiceProxy(String method, URL url) { ... } public WebServiceProxy(String method, URL baseURL, String path, Object... arguments) throws MalformedURLException { ... }\n\nThe first version accepts a string representing the HTTP method to execute and\nthe URL of the requested resource. The second accepts the HTTP method, a base\nURL, and a relative path (as a format string, to which the optional trailing\narguments are applied).\n\nRequest arguments are specified via a map passed to the setArguments() method.\nArgument values for GET, PUT, and DELETE requests are always sent in the query\nstring. POST arguments are typically sent in the request body, and may be\nsubmitted as either \"application/x-www-form-urlencoded\" or \"multipart/form-\ndata\" (specified via the proxy's setEncoding() method).\n\nAny value may be used as an argument and will generally be encoded using its\nstring representation. However, Date instances are automatically converted to\na long value representing epoch time in milliseconds. Additionally, Collection\nor array instances represent multi-value parameters and behave similarly to\n<select multiple> tags in HTML. When using the multi-part encoding, instances\nof URL represent file uploads and behave similarly to <input type=\"file\"> tags\nin HTML forms.\n\nBody content can be provided via the setBody() method. By default, it will be\nserialized as JSON; however, the setRequestHandler() method can be used to\nfacilitate arbitrary encodings:\n\n    \n    \n    public interface RequestHandler { String getContentType(); void encodeRequest(OutputStream outputStream) throws IOException; }\n\nService operations are invoked via one of the following methods:\n\n    \n    \n    public Object invoke() throws IOException { ... } public <T> T invoke(Function<Object, ? extends T> resultHandler) throws IOException { ... } public <T> T invoke(ResponseHandler<T> responseHandler) throws IOException { ... }\n\nThe first version deserializes a successful JSON response (if any). The second\napplies a result handler to the deserialized response. The third version\nallows a caller to provide a custom response handler:\n\n    \n    \n    public interface ResponseHandler<T> { T decodeResponse(InputStream inputStream, String contentType) throws IOException; }\n\nIf a service returns an error response, the default error handler will throw a\nWebServiceException (a subclass of IOException). If the content type of the\nerror response is \"text/*\", the deserialized response body will be provided in\nthe exception message. A custom error handler can be supplied via\nsetErrorHandler():\n\n    \n    \n    public interface ErrorHandler { void handleResponse(InputStream errorStream, String contentType, int statusCode) throws IOException; }\n\nThe following code demonstrates how WebServiceProxy might be used to access\nthe operations of the simple math service discussed earlier:\n\n    \n    \n    // GET /math/sum?a=2&b=4 var webServiceProxy = new WebServiceProxy(\"GET\", new URL(\"http://localhost:8080/kilo-test/math/sum\")); webServiceProxy.setArguments(mapOf( entry(\"a\", 4), entry(\"b\", 2) )); System.out.println(webServiceProxy.invoke()); // 6.0\n    \n    \n    // GET /math/sum?values=1&values=2&values=3 var webServiceProxy = new WebServiceProxy(\"GET\", new URL(\"http://localhost:8080/kilo-test/math/sum\")); webServiceProxy.setArguments(mapOf( entry(\"values\", listOf(1, 2, 3)) )); System.out.println(webServiceProxy.invoke()); // 6.0\n\nPOST, PUT, and DELETE operations are also supported. The listOf() and mapOf()\nmethods are discussed in more detail later.\n\n### Typed Invocation\n\nWebServiceProxy additionally provides the following methods to facilitate\nconvenient, type-safe access to web APIs:\n\n    \n    \n    public static <T> T of(Class<T> type, URL baseURL) { ... } public static <T> T of(Class<T> type, URL baseURL, Consumer<WebServiceProxy> initializer) { ... }\n\nBoth versions return an implementation of a given interface that submits\nrequests to the provided URL. An optional initializer accepted by the second\nversion will be called prior to each service invocation; for example, to apply\ncommon request headers.\n\nThe RequestMethod and ResourcePath annotations are used as described earlier\nfor WebService. Proxy methods must include a throws clause that declares\nIOException, so that callers can handle unexpected failures. For example:\n\n    \n    \n    public interface MathServiceProxy { @RequestMethod(\"GET\") @ResourcePath(\"sum\") double getSum(double a, double b) throws IOException; @RequestMethod(\"GET\") @ResourcePath(\"sum\") double getSum(List<Double> values) throws IOException; }\n    \n    \n    var mathServiceProxy = WebServiceProxy.of(MathServiceProxy.class, new URL(\"http://localhost:8080/kilo-test/math/\")); System.out.println(mathServiceProxy.getSum(4, 2)); // 6.0 System.out.println(mathServiceProxy.getSum(listOf(1.0, 2.0, 3.0))); // 6.0\n\nThe Name and Required annotations may also be applied to proxy method\nparameters. Path variables and body content are handled as described for\nWebService. The FormData annotation can be used in conjunction with Empty to\nsubmit POST requests using either the URL or multi-part form encoding.\n\nNote that proxy types must be compiled with the -parameters flag so their\nmethod parameter names are available at runtime.\n\n## JSONEncoder and JSONDecoder\n\nThe JSONEncoder class is used internally by WebService and WebServiceProxy to\nserialize request and response data. However, it can also be used directly by\napplication logic. For example:\n\n    \n    \n    var map = mapOf( entry(\"vegetables\", listOf( \"carrots\", \"peas\", \"potatoes\" )), entry(\"desserts\", listOf( \"cookies\", \"cake\", \"ice cream\" )) ); var jsonEncoder = new JSONEncoder(); jsonEncoder.write(map, System.out);\n\nThis code would produce the following output:\n\n    \n    \n    { \"vegetables\": [ \"carrots\", \"peas\", \"potatoes\" ], \"desserts\": [ \"cookies\", \"cake\", \"ice cream\" ] }\n\nValues are converted to their JSON equivalents as described earlier. Note that\nJava bean values must first be wrapped in an instance of BeanAdapter, which is\ndiscussed in more detail later. BeanAdapter implements the Map interface,\nwhich allows JSONEncoder to serialize the values as JSON objects.\nResultSetAdapter (also discussed later) provides a similar capability for JDBC\nresult sets.\n\nJSONDecoder deserializes a JSON document into an object hierarchy. JSON values\nare mapped to their Java equivalents as follows:\n\n  * string: String\n  * number: Number\n  * boolean: Boolean\n  * array: java.util.List\n  * object: java.util.Map\n\nFor example, given the following document:\n\n    \n    \n    [ { \"name\": \"January\", \"days\": 31 }, { \"name\": \"February\", \"days\": 28 }, { \"name\": \"March\", \"days\": 31 }, ... ]\n\nJSONDecoder could be used to parse the data into a list of maps as shown\nbelow:\n\n    \n    \n    var jsonDecoder = new JSONDecoder(); var months = (List<Map<String, Object>>)jsonDecoder.read(inputStream); for (var month : months) { System.out.println(String.format(\"%s has %s days\", month.get(\"name\"), month.get(\"days\"))); }\n\n## CSVEncoder and CSVDecoder\n\nThe CSVEncoder class can be used to serialize a sequence of map values to CSV.\nFor example, the month/day-count list from the previous section could be\nexported to CSV as shown below. The string values passed to the constructor\nrepresent both the columns in the output document and the map keys to which\nthose columns correspond:\n\n    \n    \n    var csvEncoder = new CSVEncoder(listOf(\"name\", \"days\")); csvEncoder.write(months, System.out);\n\nThis code would produce the following output:\n\n    \n    \n    \"name\",\"days\" \"January\",31 \"February\",28 \"March\",31 ...\n\nString values are automatically wrapped in double-quotes and escaped.\nInstances of java.util.Date are encoded as a long value representing epoch\ntime in milliseconds. All other values are encoded via toString().\n\nCSVDecoder deserializes a CSV document into a list of map values. For example,\ngiven the preceding document as input, this code would produce the same output\nas the JSONDecoder example:\n\n    \n    \n    var csvDecoder = new CSVDecoder(); var months = csvDecoder.read(inputStream); for (var month : months) { System.out.println(String.format(\"%s has %s days\", month.get(\"name\"), month.get(\"days\"))); }\n\n## TextEncoder and TextDecoder\n\nThe TextEncoder and TextDecoder classes can be used to serialize and\ndeserialize plain text content, respectively. For example:\n\n    \n    \n    try (var outputStream = new FileOutputStream(file)) { var textEncoder = new TextEncoder(); textEncoder.write(\"Hello, World!\", outputStream); } String text; try (var inputStream = new FileInputStream(file)) { var textDecoder = new TextDecoder(); text = textDecoder.read(inputStream); } System.out.println(text); // Hello, World!\n\n## TemplateEncoder\n\nThe TemplateEncoder class transforms an object hierarchy into an output format\nusing a template document. Template syntax is based loosely on the Mustache\nspecification and supports most Mustache features.\n\nTemplateEncoder provides the following constructors:\n\n    \n    \n    public TemplateEncoder(URL url) { ... } public TemplateEncoder(URL url, ResourceBundle resourceBundle) { ... }\n\nBoth versions accept an argument specifying the location of the template\ndocument (typically as a resource on the application's classpath). The second\nversion additionally accepts an optional resource bundle that, when present,\nis used to resolve resource markers.\n\nTemplates are applied via one of the following methods:\n\n    \n    \n    public void write(Object value, OutputStream outputStream) { ... } public void write(Object value, OutputStream outputStream, Locale locale) { ... } public void write(Object value, OutputStream outputStream, Locale locale, TimeZone timeZone) { ... } public void write(Object value, Writer writer) { ... } public void write(Object value, Writer writer, Locale locale) { ... } public void write(Object value, Writer writer, Locale locale, TimeZone timeZone) { ... }\n\nThe first argument represents the value to write (i.e. the \"data dictionary\"),\nand the second the output destination. The optional third and fourth arguments\nrepresent the target locale and time zone, respectively. If unspecified,\nsystem defaults are used.\n\nFor example, this code applies a template named \"example.html\" to a map\ninstance:\n\n    \n    \n    var map = mapOf( entry(\"a\", \"hello\"), entry(\"b\", 123), entry(\"c\", true) ); var templateEncoder = new TemplateEncoder(getClass().getResource(\"example.html\")); templateEncoder.write(map, System.out);\n\n### Custom Modifiers\n\nCustom modifiers can be associated with a template encoder instance via the\nbind() method:\n\n    \n    \n    public void bind(String name, Modifier modifier) { ... }\n\nThis method accepts a name for the modifier and an implementation of the\nTemplateEncoder.Modifer interface:\n\n    \n    \n    public interface Modifier { Object apply(Object value, String argument, Locale locale, TimeZone timeZone); }\n\nThe first argument to the apply() method represents the value to be modified.\nThe second is the optional argument text that follows the \"=\" character in the\nmodifier string. If an argument is not specified, this value will be null. The\nthird argument contains the encoder's locale.\n\nFor example, this code creates a modifier named \"upper\" that converts values\nto uppercase:\n\n    \n    \n    templateEncoder.bind(\"upper\", (value, argument, locale, timeZone) -> value.toString().toUpperCase(locale));\n\nThe modifier can be applied as shown below:\n\n    \n    \n    {{.:upper}}\n\n## BeanAdapter\n\nThe BeanAdapter class provides access to Java bean properties via the Map\ninterface. For example, the following class might be used to represent a node\nin a hierarchical object graph:\n\n    \n    \n    public class TreeNode { private String name; private List<TreeNode> children; public TreeNode() { this(null, null); } public TreeNode(String name, List<TreeNode> children) { this.name = name; this.children = children; } public String getName() { return name; } public void setName(String name) { this.name = name; } public List<TreeNode> getChildren() { return children; } public void setChildren(List<TreeNode> children) { this.children = children; } }\n\nA simple tree structure could be created and serialized to JSON as shown\nbelow:\n\n    \n    \n    var root = new TreeNode(\"Seasons\", listOf( new TreeNode(\"Winter\", listOf( new TreeNode(\"January\", null), new TreeNode(\"February\", null), new TreeNode(\"March\", null) )), new TreeNode(\"Spring\", listOf( new TreeNode(\"April\", null), new TreeNode(\"May\", null), new TreeNode(\"June\", null) )), new TreeNode(\"Summer\", listOf( new TreeNode(\"July\", null), new TreeNode(\"August\", null), new TreeNode(\"September\", null) )), new TreeNode(\"Fall\", listOf( new TreeNode(\"October\", null), new TreeNode(\"November\", null), new TreeNode(\"December\", null) )) )); var jsonEncoder = new JSONEncoder(); jsonEncoder.write(new BeanAdapter(root), writer);\n\nThe resulting output would look something like this (BeanAdapter traverses\nproperties in alphabetical order):\n\n    \n    \n    { \"children\": [ { \"children\": [ { \"children\": null, \"name\": \"January\" }, { \"children\": null, \"name\": \"February\" }, { \"children\": null, \"name\": \"March\" } ], \"name\": \"Winter\" }, ... ], \"name\": \"Seasons\" }\n\n### Type Coercion\n\nBeanAdapter can also be used to facilitate type-safe access to loosely typed\ndata structures, such as decoded JSON objects:\n\n    \n    \n    public static <T> T coerce(Object value, Class<T> type) { ... }\n\nFor example, the following code could be used to deserialize the JSON produced\nby the previous example back into a collection of TreeNode instances:\n\n    \n    \n    var jsonDecoder = new JSONDecoder(); var root = BeanAdapter.coerce(jsonDecoder.read(reader), TreeNode.class); System.out.println(root.getName()); // Seasons System.out.println(root.getChildren().get(0).getName()); // Winter System.out.println(root.getChildren().get(0).getChildren().get(0).getName()); // January\n\nNote that an interface can be used instead of a class to provide a strongly\ntyped \"view\" of the underlying map data. For example:\n\n    \n    \n    public interface AssetPricing { Instant getDate(); double getOpen(); double getHigh(); double getLow(); double getClose(); long getVolume(); }\n    \n    \n    var map = mapOf( entry(\"date\", \"2024-04-08T00:00:00Z\"), entry(\"open\", 169.03), entry(\"close\", 168.45), entry(\"high\", 169.20), entry(\"low\", 168.24), entry(\"volume\", 37216858) ); var assetPricing = BeanAdapter.coerce(map, AssetPricing.class); System.out.println(assetPricing.getDate()); // 2024-04-08T00:00:00Z System.out.println(assetPricing.getOpen()); // 169.03 System.out.println(assetPricing.getClose()); // 168.45 System.out.println(assetPricing.getHigh()); // 169.2 System.out.println(assetPricing.getLow()); // 168.24 System.out.println(assetPricing.getVolume()); // 37216858\n\nMutator methods are also supported.\n\n### Required Properties\n\nThe Required annotation introduced previously can also be used to indicate\nthat a property must contain a value. For example:\n\n    \n    \n    public class Vehicle { private String manufacturer; private Integer year; @Required public String getManufacturer() { return manufacturer; } public void setManufacturer(String manufacturer) { this.manufacturer = manufacturer; } @Required public Integer getYear() { return year; } public void setYear(Integer year) { this.year = year; } }\n\nBecause both \"manufacturer\" and \"year\" are required, an attempt to coerce an\nempty map to a Vehicle instance would produce an IllegalArgumentException:\n\n    \n    \n    var vehicle = BeanAdapter.coerce(mapOf(), Vehicle.class); // throws\n\nAdditionally, although the annotation will not prevent a caller from\nprogrammatically assigning a null value to either property, attempting to\ndynamically set an invalid value will generate an IllegalArgumentException:\n\n    \n    \n    var vehicle = new Vehicle(); var vehicleAdapter = new BeanAdapter(vehicle); vehicleAdapter.put(\"manufacturer\", null); // throws\n\nSimilarly, attempting to dynamically access an invalid value will result in an\nUnsupportedOperationException:\n\n    \n    \n    vehicleAdapter.get(\"manufacturer\"); // throws\n\n### Custom Property Names\n\nThe Name annotation introduced previously can also be used with properties.\nFor example:\n\n    \n    \n    public class Person { private String firstName = null; private String lastName = null; @Name(\"first_name\") public String getFirstName() { return firstName; } public void setFirstName(String firstName) { this.firstName = firstName; } @Name(\"last_name\") public String getLastName() { return lastName; } public void setLastName(String lastName) { this.lastName = lastName; } }\n\nThe preceding class would be serialized to JSON like this:\n\n    \n    \n    { \"first_name\": \"John\", \"last_name\": \"Smith\" }\n\nrather than this:\n\n    \n    \n    { \"firstName\": \"John\", \"lastName\": \"Smith\" }\n\n## QueryBuilder and ResultSetAdapter\n\nThe QueryBuilder class provides support for programmatically constructing and\nexecuting SQL queries. For example, given the following table from the MySQL\nsample database:\n\n    \n    \n    create table pet ( name varchar(20), owner varchar(20), species varchar(20), sex char(1), birth date, death date );\n\nthis code could be used to create a query that returns all rows associated\nwith a particular owner:\n\n    \n    \n    var queryBuilder = new QueryBuilder(); queryBuilder.appendLine(\"select * from pet where owner = :owner\");\n\nThe colon character identifies \"owner\" as a parameter, or variable. Parameter\nvalues, or arguments, can be passed to QueryBuilder's executeQuery() method as\nshown below:\n\n    \n    \n    try (var statement = queryBuilder.prepare(getConnection()); var results = queryBuilder.executeQuery(statement, mapOf( entry(\"owner\", owner) ))) { ... }\n\nThe ResultSetAdapter type returned by executeQuery() provides access to the\ncontents of a JDBC result set via the Iterable interface. Individual rows are\nrepresented by Map instances produced by the adapter's iterator. The results\ncould be coerced to a list of Pet instances and returned to the caller, or\nused as the data dictionary for a template document:\n\n    \n    \n    return results.stream().map(result -> BeanAdapter.coerce(result, Pet.class)).toList();\n    \n    \n    var templateEncoder = new TemplateEncoder(getClass().getResource(\"pets.html\"), resourceBundle); templateEncoder.write(results, response.getOutputStream());\n\n### Schema Annotations\n\nQueryBuilder also offers a simplified approach to query construction using\n\"schema annotations\". For example, given this type definition:\n\n    \n    \n    @Table(\"pets\") public interface Pet { @Column(\"name\") String getName(); @Column(\"owner\") String getOwner(); @Column(\"species\") String getSpecies(); @Column(\"sex\") String getSex(); @Column(\"birth\") Date getBirth(); @Column(\"death\") Date getDeath(); }\n\nthe preceding query could be written as follows:\n\n    \n    \n    var queryBuilder = QueryBuilder.select(Pet.class); queryBuilder.appendLine(\"where owner = :owner\");\n\nAdditional QueryBuilder methods can be used in conjunction with the\nPrimaryKey, ForeignKey, and Index annotations to filter or sort the returned\nrows.\n\nInsert, update, and delete operations are also supported. See the pet and\ncatalog service examples for more information.\n\n## ElementAdapter\n\nThe ElementAdapter class provides access to the contents of an XML DOM Element\nvia the Map interface. For example, the following markup might be used to\nrepresent the status of a bank account:\n\n    \n    \n    <account id=\"101\"> <holder> <firstName>John</firstName> <lastName>Smith</lastName> </holder> <transactions> <credit> <amount>100.00</amount> <date>10/5/2020</date> </credit> <credit> <amount>50.00</amount> <date>10/12/2020</date> </credit> <debit> <amount>25.00</amount> <date>10/14/2020</date> </debit> <credit> <amount>75.00</amount> <date>10/19/2020</date> </credit> </transactions> </account>\n\nThis code could be used to load the document and adapt the root element:\n\n    \n    \n    var documentBuilderFactory = DocumentBuilderFactory.newInstance(); documentBuilderFactory.setExpandEntityReferences(false); documentBuilderFactory.setIgnoringComments(true); var documentBuilder = documentBuilderFactory.newDocumentBuilder(); Document document; try (var inputStream = getClass().getResourceAsStream(\"account.xml\")) { document = documentBuilder.parse(inputStream); } var accountAdapter = new ElementAdapter(document.getDocumentElement());\n\nAttribute values can be obtained by prepending an \"@\" symbol to the attribute\nname:\n\n    \n    \n    var id = accountAdapter.get(\"@id\"); System.out.println(id); // 101\n\nIndividual sub-elements can be accessed by name. The text content of an\nelement can be obtained by calling toString() on the returned adapter\ninstance; for example:\n\n    \n    \n    var holder = (Map<String, Object>)accountAdapter.get(\"holder\"); var firstName = holder.get(\"firstName\"); var lastName = holder.get(\"lastName\"); System.out.println(String.format(\"%s, %s\", lastName, firstName)); // Smith, John\n\nAn element's text content can also be accessed via the reserved \".\" key.\n\nMultiple sub-elements can be obtained by appending an asterisk to the element\nname:\n\n    \n    \n    var transactions = (Map<String, Object>)accountAdapter.get(\"transactions\"); var credits = (List<Map<String, Object>>)transactions.get(\"credit*\"); for (var credit : credits) { System.out.println(credit.get(\"amount\")); System.out.println(credit.get(\"date\")); }\n\nElementAdapter also supports put() and remove() for modifying an element's\ncontents.\n\n## ResourceBundleAdapter\n\nThe ResourceBundleAdapter class provides access to the contents of a resource\nbundle via the Map interface. It can be used to localize the headings in a CSV\ndocument, for example:\n\n    \n    \n    name = Name description = Description quantity = Quantity\n    \n    \n    var csvEncoder = new CSVEncoder(listOf(\"name\", \"description\", \"quantity\")); var resourceBundle = ResourceBundle.getBundle(getClass().getPackageName() + \".labels\"); csvEncoder.setLabels(new ResourceBundleAdapter(resourceBundle)); csvEncoder.write(listOf( mapOf( entry(\"name\", \"Item 1\"), entry(\"description\", \"Item number 1\"), entry(\"quantity\", 3) ), mapOf( entry(\"name\", \"Item 2\"), entry(\"description\", \"Item number 2\"), entry(\"quantity\", 5) ), mapOf( entry(\"name\", \"Item 3\"), entry(\"description\", \"Item number 3\"), entry(\"quantity\", 7) ) ), System.out);\n\nThis code would produce the following output:\n\n    \n    \n    \"Name\",\"Description\",\"Quantity\" \"Item 1\",\"Item number 1\",3 \"Item 2\",\"Item number 2\",5 \"Item 3\",\"Item number 3\",7\n\n## Pipe\n\nThe Pipe class provides a vehicle by which a producer thread can submit a\nsequence of elements for retrieval by a consumer thread. It implements the\nIterable interface and returns values as they become available, blocking if\nnecessary.\n\nFor example, the following code executes a SQL query that retrieves all rows\nfrom an employees table:\n\n    \n    \n    @Table(\"employees\") public interface Employee { @Column(\"emp_no\") @PrimaryKey Integer getEmployeeNumber(); @Column(\"first_name\") String getFirstName(); @Column(\"last_name\") String getLastName(); @Column(\"gender\") String getGender(); @Column(\"birth_date\") LocalDate getBirthDate(); @Column(\"hire_date\") LocalDate getHireDate(); }\n    \n    \n    var queryBuilder = QueryBuilder.select(Employee.class); try (var connection = getConnection(); var statement = queryBuilder.prepare(connection); var results = queryBuilder.executeQuery(statement)) { return results.stream().map(result -> BeanAdapter.coerce(result, Employee.class)).toList(); }\n\nAll rows are processed and added to the list before anything is returned to\nthe caller. For small result sets, the latency and memory implications\nassociated with this approach might be acceptable. However, for larger data\nvolumes the following alternative may be preferable. The query is executed on\na background thread, and the transformed results are streamed back to the\ncaller via a pipe:\n\n    \n    \n    var pipe = new Pipe<Employee>(4096, 15000); executorService.submit(() -> { var queryBuilder = QueryBuilder.select(Employee.class); try (var connection = getConnection(); var statement = queryBuilder.prepare(connection); var results = queryBuilder.executeQuery(statement)) { pipe.accept(results.stream().map(result -> BeanAdapter.coerce(result, Employee.class))); } catch (SQLException exception) { throw new RuntimeException(exception); } }); return pipe;\n\nThe pipe is configured with a capacity of 4K elements and a timeout of 15s.\nLimiting the capacity ensures that the producer does not do more work than\nnecessary if the consumer fails to retrieve all of the data. Similarly,\nspecifying a timeout ensures that the consumer does not wait indefinitely if\nthe producer stops submitting data.\n\nThis implementation is slightly more verbose than the first one. However,\nbecause no intermediate buffering is required, results are available to the\ncaller sooner, and CPU and memory load is reduced.\n\nFor more information, see the employee service example.\n\n## Collections and Optionals\n\nThe Collections class provides a set of static utility methods for\ndeclaratively instantiating list, map, and set values:\n\n    \n    \n    public static <E> List<E> listOf(E... elements) { ... } public static <K, V> Map<K, V> mapOf(Map.Entry<K, V>... entries) { ... } public static <K, V> Map.Entry<K, V> entry(K key, V value) { ... } public static <E> Set<E> setOf(E... elements) { ... }\n\nThey offer an alternative to similar methods defined by the List, Map, and Set\ninterfaces, which produce immutable instances and do not permit null values.\nThe following immutable variants are also provided:\n\n    \n    \n    public static <E> List<E> immutableListOf(E... elements) { ... } public static <K, V> Map<K, V> immutableMapOf(Map.Entry<K, V>... entries) { ... } public static <E> Set<E> immutableSetOf(E... elements) { ... }\n\nAdditionally, Collections includes the following methods for creating empty\nlists and maps:\n\n    \n    \n    public static <E> List<E> emptyListOf(Class<E> elementType) { ... } public static <K, V> Map<K, V> emptyMapOf(Class<K> keyType, Class<V> valueType) { ... } public static <E> Set<E> emptySetOf(Class<E> elementType) { ... }\n\nThese provide a slightly more readable alternative to\njava.util.Collections#emptyList() and java.util.Collections#emptyMap(),\nrespectively:\n\n    \n    \n    var list1 = java.util.Collections.<Integer>emptyList(); var list2 = emptyListOf(Integer.class); var map1 = java.util.Collections.<String, Integer>emptyMap(); var map2 = emptyMapOf(String.class, Integer.class); var set1 = java.util.Collections.<Integer>emptySet(); var set2 = emptySetOf(Integer.class);\n\nThe following methods can be used to identify the index of the first or last\nelement in a list that matches a given predicate:\n\n    \n    \n    public static <E> int firstIndexWhere(List<E> list, Predicate<E> predicate) { ... } public static <E> int lastIndexWhere(List<E> list, Predicate<E> predicate) { ... }\n\nFor example:\n\n    \n    \n    var list = listOf(\"a\", \"b\", \"c\", \"b\", \"d\"); var i = Collections.firstIndexWhere(list, element -> element.equals(\"b\")); // 1 var j = Collections.lastIndexWhere(list, element -> element.equals(\"e\")); // -1\n\nFinally, the valueAt() method can be used to access nested values in an object\nhierarchy. For example:\n\n    \n    \n    var map = mapOf( entry(\"a\", mapOf( entry(\"b\", mapOf( entry(\"c\", listOf(1, 2, 3)) )) )) ); var value = Collections.valueAt(map, \"a\", \"b\", \"c\", 1); // 2\n\nThe Optionals class contains methods for working with optional (or \"nullable\")\nvalues:\n\n    \n    \n    public static <T> T coalesce(T... values) { ... } public static <T, U> U map(T value, Function<? super T, ? extends U> transform) { ... } public static <T, U> U map(T value, Function<? super T, ? extends U> transform, U defaultValue) { ... } public static <T> void perform(T value, Consumer<? super T> action) { ... } public static <T> void perform(T value, Consumer<? super T> action, Runnable defaultAction) { ... }\n\nThese methods are provided as a less verbose alternative to similar methods\ndefined by the java.util.Optional class. For example:\n\n    \n    \n    var value = \"xyz\"; var a = Optional.ofNullable(null).orElse(Optional.ofNullable(null).orElse(value)); // xyz var b = Optionals.coalesce(null, null, value); // xyz\n    \n    \n    var value = \"hello\"; var a = Optional.ofNullable(value).map(String::length).orElse(null); // 5 var b = Optionals.map(value, String::length); // 5\n    \n    \n    var value = new AtomicInteger(0); Optional.ofNullable(value).ifPresent(AtomicInteger::incrementAndGet); Optionals.perform(value, AtomicInteger::incrementAndGet);\n\n# Kotlin Support\n\nKilo-based web services and consumers can be also implemented using the Kotlin\nprogramming language. For example, the following is a simple web service\nwritten in Kotlin:\n\n    \n    \n    @WebServlet(urlPatterns = [\"/*\"], loadOnStartup = 1) @Description(\"Greeting example service.\") class GreetingService: WebService() { @RequestMethod(\"GET\") @Description(\"Returns a friendly greeting.\") fun getGreeting(): String { return \"Hello, World!\" } }\n\nAn example of a typed invocation proxy implemented in Kotlin can be found\nhere.\n\nNote that Kotlin code should be compiled with the -java-parameters flag so\nthat method parameter names are available at runtime.\n\n# Additional Information\n\nThis guide introduced the Kilo framework and provided an overview of its key\nfeatures. For additional information, see the examples.\n\n## About\n\nLightweight REST for Java\n\n### Topics\n\njava json template-engine csv rest xml jdbc servlet web-service\n\n### Resources\n\nReadme\n\n### License\n\nApache-2.0 license\n\nActivity\n\nCustom properties\n\n### Stars\n\n321 stars\n\n### Watchers\n\n34 watching\n\n### Forks\n\n63 forks\n\nReport repository\n\n## Releases 1\n\nKilo 3.8 Latest\n\nApr 23, 2024\n\n## Contributors 2\n\n  * gk-brown Greg Brown\n  * nabrown Nora Brown\n\n## Languages\n\n  * Java 96.6%\n  * HTML 1.9%\n  * Kotlin 1.3%\n  * XSLT 0.2%\n\n## Footer\n\n\u00a9 2024 GitHub, Inc.\n\nYou can\u2019t perform that action at this time.\n\n", "frontpage": false}
