{"aid": "40141416", "title": "Composability: Designing a Visual Programming Language", "url": "https://johnaustin.io/articles/2024/composability-designing-a-visual-programming-language", "domain": "johnaustin.io", "votes": 1, "user": "Kleptine", "posted_at": "2024-04-24 06:47:41", "comments": 0, "source_title": "Composability: Designing a Visual Programming Language", "source_text": "Composability: Designing a Visual Programming Language \u2014 John Austin\n\nJohn Austin\n\nBlog - Email List Blog - RSS Mastodon Twitter Contact\n\nJohn Austin\n\nprogramming, game tech, and game design\n\n# Composability: Designing a Visual Programming Language\n\nLattice is a high-performance visual scripting system targeting Unity ECS.\nRead more here.\n\nI wanted to write a few posts on the design of Lattice as a language. Today,\nlet's focus on \u201ccomposability\u201d. This is intuitively something we desire in\nprogramming languages. Some systems feel like they are effortlessly\nreconfigurable, recombinable, and then others.. just don\u2019t. Some languages\nseem to actively reject our efforts at organization.\n\nSo what makes a system composable? I see two major properties:\n\n  1. Self-Similarity \u2014 Composable systems usually have a simple primitive that is self-similar. Think of a game grid, tetris pieces, repeating tessellations, etc. Self-similarity means most things can plug into other things. They may not do something useful, but they can be infinitely re-arranged.\n\n  2. Merging / Splitting \u2014 Two groups of primitives can be merged into a single primitive, and that 'merged primitive' acts just like any other primitive. Similarly, a primitive can be split into several 'pieces' and each of those pieces acts like any other primitive.\n\nTake Legos, perhaps the most composable system in existence. So composable, in\nfact, that talking about them is almost reductive. But they follow these rules\ndeeply:\n\nNotice how not only can Legos be split into separate pieces, but they can be\nsplit in many different ways. Put another way, Legos have lots of seams:\nplaces where they can be split apart into component chunks.\n\nLego chunks can be split along many different seams.\n\nA system with many seams is indicative of a very composable system: new\nbehavior is built purely through composition, not by defining new primitives.\n\nI think about composability a lot in my game design work, why do some game\nmechanics have so much emergent behavior? We can see splitting/merging at work\nthere too. Factorio, with its endlessly recombinable and splittable factory\ntiles. Or a roguelike deck-builders with their infinitely splittable/mergeable\ndecks. Or an action game with 20 different abilities giving you an incredible\nnumber of seams to rip apart builds and reconfigure them.\n\n## Blueprints are not composable.\n\nLet's get back to Lattice, and visual programming language design. Unreal\nEngine\u2019s Blueprints are a common design for visual programming, roughly\nmirroring code. But despite how easy it is to sketch something out, they seem\nto reject organization.(1)1 Common wisdom from large teams in UE is \u201cdesign in\nblueprints, then rewrite in C++\u201d. It's shockingly tough to split a messy graph\ninto reusable, smaller nodes. It's also pretty tough to merge several nodes\ninto a single multi-purpose node. Why is that?\n\nIn my opinion, the problem is execution wires.\n\nExecution wires don't have a trivial merge operation. Let's say I have two\nnodes I want to combine into a single node:\n\nWhat do you do about the execution wires? It's illegal to split or merge an\nexecution wire. Doing so would require a fundamentally parallel execution\nenvironment.(2)2 It\u2019s fun to muse on a language where splitting an execution\nwire means \u201crun these operations in parallel\u201d. It\u2019s a bit of a can of worms,\nthough, that PL folks have been attempting for decades. You must manually\norder them, instead. But which one should execute first? Even if it doesn\u2019t\nactually matter, the semantics of the language require you to pick an option.\n\nDoes thing 2 or thing 1 happen first? Does it matter?\n\nIn this situation, Blueprints just gives up, exposing two execution wire\ninputs \u2014 the worst of all worlds. The issue here isn't Blueprints, itself.\nExecution wires are just a fundamentally non-composable primitive.(3)3 Foot\nnote: Why does code work better?\n\nIt's interesting to ask why text code doesn't seem to have this problem. After\nall, C++ has 'execution wires', so to speak, between each line, but doesn't\nhave these compositional issues. However, the execution wires in text code are\n'implicit' -- it's based on the linear order of the text in the file. Every\ntime you make an edit, you're answering the ordering question.\n\nWith a visual programming language lifted to a 2D plane, we can't rely on that\nluxury because there is no implicit linear order of nodes. Of course, we can\nimplicitly order nodes in other ways.\n\nBefore merging.\n\nAfter merging.\n\n## A Better Option - Value Graphs\n\nWhat happens if we design a language without execution wires? Actually,\nthere's plenty of precedent for this already:\n\n  * Houdini / Blender Geometry Nodes (Mesh Manipulation Tools)\n\n  * VVVV, TouchDesigner, Cables (Live Effects Tools)\n\n  * MaxMSP, Pure Data (Audio Synthesizers)\n\n  * ShaderGraph, Animation Blueprints (Shaders, Animations)\n\nAll of these languages are value-based expression graphs under the hood.\nYou're applying operations to input values, to produce certain output values,\nsometimes with some additional side effects.\n\nIf there's no execution wires, how do you control the ordering of execution?\nUsually, you don't have to. When a node precisely defines the data it\nrequires, the order of execution is implicit. When does a node run? After all\nits inputs have finished.\n\nBlueprints actually has this in the form of Pure nodes. No surprise, these\nnodes are much easier to combine and reuse throughout your graphs. (4)4 Sadly,\nmost BP nodes are not pure, so the functionality is limited in its usefulness.\n\nThese are fundamentally composable! It's perfectly valid to split an incoming\nvalue wire (it's just a copy of the same value on either end).\n\nSomething else to notice: in a value graph, any cut of the graph is a valid\nway of creating a sub-graph. The edges that that cross the 'cut' are precisely\nyour inputs and outputs. Here we\u2019ve selected a group of sub-nodes with 1 input\ncrossing, and 1 output crossing:\n\nBefore\n\nAfter\n\nHere\u2019s another (more invasive) cut, with 1 input edge and 3 output edges:\n\nBefore\n\nAfter\n\nPut another way, value graphs have lots of seams. We can cut them up any way\nwe like, simplify nodes, apply general transformations, and the graph stays\nvalid. There are no \u2018edge cases\u2019. The same cannot be said for execution wires.\n\nSo, Lattice borrows from this lineage of programming languages. That get us an\nincredibly composable computation model, however we need a few super-powers to\ngive us a more expressive language as a whole. I'll chat more about that next\ntime.\n\nUntil then.\n\nTechnicalJohn AustinApril 20, 2024Lattice, Game Engine, Unity\n\nTwitter Reddit 0 Likes\n\nYou can now subscribe to this blog via Email or RSS. You can find me on\nMastodon, Bluesky, or Twitter.\n\n", "frontpage": false}
