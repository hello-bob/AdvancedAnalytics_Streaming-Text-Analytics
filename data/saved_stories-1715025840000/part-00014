{"aid": "40272514", "title": "How to Use the Foreign Function API in Java 22 to Call C Libraries", "url": "https://ifesunmola.com/how-to-use-the-foreign-function-api-in-java-22-to-call-c-libraries/", "domain": "ifesunmola.com", "votes": 1, "user": "pjmlp", "posted_at": "2024-05-06 08:40:02", "comments": 0, "source_title": "How to use the Foreign Function API in Java 22 to Call C Libraries | Ife Sunmola", "source_text": "How to use the Foreign Function API in Java 22 to Call C Libraries | Ife Sunmola\n\nJava\n\n# How to use the Foreign Function API in Java 22 to Call C Libraries\n\nThis article explains how to call C libraries like fopen, fgets, and fclose\nfrom Java.\n\nWritten 19 hours ago\n\n## Table of Contents\n\n## Introduction\n\nBefore the release of Java 22, the usual way to call foreign functions was\nwith the Java Native Interface (JNI). Anyone who has used (or tried to use)\nJNI would agree that it was very easy to shoot yourself in the foot and\naccidentally shoot someone else in the foot while the first shooting was still\nhappening.\n\nI\u2019m not going to dive into how easy it is to mess up, but I will say this: To\nuse JNI, you have to write C code. Let me rephrase that: for developers that\nhave been pampered with garbage collection and safety to use JNI, they had to\nwrite C code. What could go wrong? There are other solutions built on JNI\nwhere you don\u2019t have to write the C bindings manually, but ... meh.\n\nI\u2019ll admit that JNI is very powerful. But what if we didn\u2019t have to write C\ncode, like the way it\u2019s done in other languages? Enter the star of today\u2019s\nwriting: Foreign Function and Memory (FFM) API from the java.lang.foreign\npackage.\n\nThis article will review how to read the contents of a file using fopen,\nfclose and fgets from the C standard library. This might get long and\ntechnical, so buckle up!\n\n> Using the FFM API to call regular functions that already exist in the Java\n> standard library makes no sense because there will always be an overhead.\n> The API is best used for libraries that cannot be rewritten in Java. I chose\n> functions from the C standard library because it\u2019s available to almost\n> everyone.\n\n## Setting up LibC class and fopen\n\nThe Java language architects made the API as open as possible. Aside from the\ncode that relates to foreign functions, there\u2019s almost no abstraction. So, a\nlittle bit of setup is required to get going. My guess is that they didn\u2019t\nwant to constrain developers too much.\n\nIn a file named LibC.java:\n\n    \n    \n    import java.lang.foreign.*; class LibC { private final Arena allocator; Linker linker = Linker.nativeLinker(); SymbolLookup lib = linker.defaultLookup(); LibC(Arena arena) { this.allocator = arena; } }\n\n  1. Think of an Arena as an allocator. It is how memory is allocated and freed. If the arena is closed, all the memory allocated through it is freed. You\u2019ll see more of it when we get the main method.\n\n  2. Linker.nativeLinker() simply ... gets the native linker.\n\n  3. linker.defaultLookup() implicitly loads all the common libraries that are typically present on PCs. libc - the C standard library is one of them.\n\nTo set up fopen, add the following below SymbolLookup lib =\nlinker.defaultLookup();:\n\n    \n    \n    // Required Imports import static java.lang.foreign.ValueLayout.*; import java.lang.invoke.MethodHandle; // End imports MemorySegment fopenAddress = lib.find(\"fopen\").orElseThrow(); //FILE *fopen(const char *filename, const char *mode) FunctionDescriptor fopenDesc = FunctionDescriptor.of(ADDRESS, ADDRESS, ADDRESS); MethodHandle fopen = linker.downcallHandle(fopenAddress, fopenDesc);\n\n> The above code perfectly shows my love/hate relationship with Java. It\u2019s\n> verbose, lots of typing, I even had to skip the use of private final because\n> it would get too long. But sometimes, it also makes sense. I mean ... could\n> it get any more descriptive than naming something FunctionDescriptor? Sure\n> you could use FuncDescriptor or FuncDesc or be like go programmers and name\n> it fd (please don\u2019t fight me).\n\nI don\u2019t know about you but that looks scary. Let\u2019s break it down:\n\n  1. MemorySegment\n\n     * Think of this as the equivalent of a C pointer. Anytime a C function returns a pointer, or takes in a pointer argument MemorySegment is used to represent it in java code.\n  2. lib.find(\"fopen\").orElseThrow():\n\n     * Recall that lib contains all the common libraries that are typically found on a PC, and the C standard library is one of them.\n     * The code finds the address (pointer) of where fopen is stored, and returns it, or throws an exception if it wasn\u2019t found.\n  3. FunctionDescriptor.of(ADDRESS, ADDRESS, ADDRESS):\n\n     * The code is exactly what it sounds like. It describes the signature of fopen\n     * The first argument is the return type of fopen - A memory address\n     * The 2nd and 3rd (and subsequent) arguments are the parameters. They\u2019re all memory addresses.\n     * There\u2019s also a FunctionDescriptor.ofVoid() that only allows parameters, and returns void\n  4. MethodHandle fopen = linker.downcallHandle(fopenAddress, fopenDesc)\n\n     * This basically creates a way to actually call the function.\n     * In general, it is used to call a foreign function in any language.\n\nAny bindings you create will typically follow the same pattern: Find the\nlibrary, describe the function, create a way to call it from java.\n\nWith that, we can create method to publicly access it. Below the LibC\nconstructor:\n\n    \n    \n    MemorySegment fopen(String filePath, String mode) { MemorySegment pathPtr = allocator.allocateFrom(filePath); MemorySegment modePtr = allocator.allocateFrom(mode); try { return (MemorySegment) fopen.invoke(pathPtr, modePtr); } catch (Throwable e) { return MemorySegment.NULL; } }\n\n> Note that type inference (kinda) has been around since Java 10. I\u2019m\n> explicitly using the types for clarity.\n\nThere are some new things, let\u2019s address them:\n\n  1. MemorySegment pathPtr = allocator.allocateFrom(filePath):\n\n     * We\u2019ve seen MemorySegment before. It\u2019s a pointer.\n     * allocator.allocateFrom(filePath) creates a pointer from the file path string\n     * modePtr also follows the same pattern\n  2. return (MemorySegment) fopen.invoke(pathPtr, modePtr);\n\n     * Recall the signature (and FunctionDescriptor) of fopen: FILE *fopen(const char *filename, const char *mode). It returns a pointer, and takes in 2 pointers as its parameter.\n     * fopen.invoke() comes from the MethodHandle we created above. It invokes the foreign function, and returns an Object, so we need to cast to the described return type - an address i.e a MemorySegment\n     * There are several things that could go wrong, so .invoke() throws a Throwable - the super class of all errors and exceptions.\n     * Returning NULL is not the best way to handle an exception like this, but let\u2019s keep it simple.\n\n## More on Arenas\n\nAs mentioned earlier, an arena is like an allocator.\n\nThere are some edge cases but most of the time, every memory you create in C\nhas to be linked to an arena in Java. Even if you use malloc to allocate\nmemory and get a MemorySegment back, before you use it, you have to link it to\nan arena, and in that same process of linking, you have to pass a Consumer\nthat would free the memory segment. If you really need the memory without a\nConsumer to free it (not sure why), there\u2019s a way to do that too.\n\nHere\u2019s a really simple example:\n\n    \n    \n    // Assume we've setup a LibC class that that DOESN'T take an // Arena as a constructor parameter. It contains both malloc and // free methods. In a main method: var libc = new LibC(); MemorySegment mallocedMem = libc.malloc(20); // allocate 20 bytes // outputs 0, we can't use it yet! An exception will be thrown // if we work with it. System.out.println(mallocedMem.byteSize()); mallocedMem.getString(0); // IndexOutOfBoundsException\n\nTo be able to actually use it, we need something like this:\n\n    \n    \n    try (Arena allocator = Arena.ofConfined()) { // We could use the arena in the malloc call method but for // demonstration purposes, our library still doesn't have access to it. var libc = new LibCTest(); // Size will be allocated later. For now, just get a reference MemorySegment mallocedMem = libc.malloc(); System.out.println(\"Address: \" + mallocedMem); Consumer<MemorySegment> cleanup = libc::free; // cleanup is called after the allocator is closed mallocedMem = mallocedMem.reinterpret(20, allocator, cleanup); // Same address as above, but with different size System.out.println(\"Address \" + mallocedMem); System.out.println(mallocedMem.getString(0)); // prints empty string } // allocator closed here, mallocedMem is freed\n\nI think it\u2019s a nice way to make sure we can use C and not inherit the memory\nissues.\n\n## Main/Runner class\n\nCreate a file named file.txt and put some text in it. I\u2019m not saying you\nshould use this text, but it\u2019ll be cool if you did:\n\n    \n    \n    What is that thing? This is Appa, my flying bison. Right, and this is Katara, my flying sister.\n\nIn a file named Runner.java:\n\n    \n    \n    import java.lang.foreign.*; // we have to run with java 22 so we might as well use the // unnamed classes preview feature. Your IDE might yell at // you and ask to enable preview features. void main() { try (Arena allocator = Arena.ofConfined()) { var libc = new LibC(allocator); MemorySegment filePtr = libc.fopen(\"file.txt\", \"r\"); if (filePtr.equals(MemorySegment.NULL)) { System.out.println(\"File could not be opened or invoke call failed\"); return; } System.out.println(\"File opened successfully\"); } }\n\nIf you run with java --enable-preview --source 22 Runner.java You should see\nthe success message or an error message if you change to a file that doesn\u2019t\nexist ... and some warnings. Those warnings are there to remind you that you\nare using methods that might cause the JVM to crash.\n\n## Adding fgets and fclose\n\nAs mentioned earlier, the steps to add more libraries are the same, so I won\u2019t\ngo over already discussed terminologies. Just after the MethodHandle for\nfopen, add the following:\n\n    \n    \n    //char *fgets(char *str, int n, FILE *stream) MemorySegment fgetsAddress = lib.find(\"fgets\").orElseThrow(); FunctionDescriptor fgetsDesc = FunctionDescriptor.of(ADDRESS, ADDRESS, JAVA_INT, ADDRESS); MethodHandle fgets = linker.downcallHandle(fgetsAddress, fgetsDesc); //int fclose(FILE *stream) MemorySegment fcloseAddress = lib.find(\"fclose\").orElseThrow(); FunctionDescriptor fcloseDesc = FunctionDescriptor.of(JAVA_INT, ADDRESS); MethodHandle fclose = linker.downcallHandle(fcloseAddress, fcloseDesc);\n\nThe only unfamiliar code above should be the FunctionDescriptor. For\nfgetsDesc, we\u2019re saying fgets returns an (address) pointer, takes a pointer,\nan int, and another pointer.\n\nFor fcloseDesc, we\u2019re saying fclose returns an int, and takes an address\n\n> To be safer, you could use interfaces to differentiate between a C FILE* and\n> a generic MemorySegment\n\nAnd for the methods to publicly access them, add the following below\nMemorySegment fopen(String, String):\n\n    \n    \n    MemorySegment fgets(MemorySegment buffer, int size, MemorySegment filePtr) { try { return (MemorySegment) fgets.invoke(buffer, size, filePtr); } catch (Throwable e) { return MemorySegment.NULL; } } int fclose(MemorySegment filePtr) { try { return (int) fclose.invoke(filePtr); } catch (Throwable e) { return -1; } }\n\nNothing unfamiliar here either. In fclose, instead of casting to a\nMemorySegment, we cast to an int because in the FunctionDescriptor, we said we\nexpect an int as a result.\n\nAnd finally, in the main method, replace System.out.println(\"File opened ...\nwith:\n\n    \n    \n    MemorySegment buffer = allocator.allocate(100); // allocate 100 bytes MemorySegment result; for (; ; ) { result = libc.fgets(buffer, 100, filePtr); if (result.equals(MemorySegment.NULL)) break; System.out.print(buffer.getString(0)); } if (libc.fclose(filePtr) != 0) { System.out.println(\"File was not closed\"); }\n\nAgain, nothing too unfamiliar here either. It\u2019s like a java flavoured version\nof how you read a file in plain C. The buffer.getString returns the string\nstored in the buffer at offset 0. So, if we wanted to print from the 5th\ncharacter, we would use 5 instead.\n\nIf you run again with java --enable-preview --source 22 Runner.java, you\nshould see the file contents printed out (and the warnings).\n\n## Wrapping up\n\nWhat are your thoughts on this compared to JNI? It\u2019s a lot of code but also a\nmuch safer alternative. I\u2019m also curious as to how it compares performance\nwise.\n\nThere\u2019s a tool called jextract (linked below) that can generate foreign\nfunction bindings from header files, and we won\u2019t have to do all the work we\ndid above so the lots of code issue isn\u2019t really an issue. I decided not to\nuse jextract at all in this article because it\u2019ll be like learning java\nmultithreading without learning Java.\n\nMaybe I\u2019ll write on how to use jextract with something like SDL2 or LLVM? Or a\nmachine learning library? It most likely won\u2019t be as straightforward as simply\ncalling jextract with some header files, but we\u2019ll see \ud83d\ude42\n\n## References\n\n  * https://docs.oracle.com/en/java/javase/21/core/foreign-function-and-memory-api.html\n  * https://github.com/openjdk/jextract\n  * https://jdk.java.net/jextract/\n  * https://www.youtube.com/watch?v=iwmVbeiA42E&t=1613s\n  * https://news.ycombinator.com/item?id=34580907#34586552\n\n## Source Code\n\nRun with java 22+ : java --enable-preview --source 22 Runner.java\n\n  * LibC.java\n  * Runner.java\n  * file.txt\n\nRead next: Sum types in Java\n\n## Tags\n\nJava\n\n\u00a92024 Ife Sunmola\n\n", "frontpage": false}
