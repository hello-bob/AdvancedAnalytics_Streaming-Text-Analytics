{"aid": "40185065", "title": "How to improve the RISC-V specification", "url": "https://alastairreid.github.io/riscv-spec-issues/", "domain": "alastairreid.github.io", "votes": 10, "user": "todsacerdoti", "posted_at": "2024-04-28 01:05:37", "comments": 0, "source_title": "How to improve the RISC-V specification", "source_text": "How to improve the RISC-V specification \u2013 Alastair Reid \u2013 Researcher at Intel\n\n# Alastair Reid\n\nResearcher at Intel\n\n# How to improve the RISC-V specification\n\nMy main project is to create an executable spec of the Intel Architecture but,\nevery now and then, I get to take a broader look at ISA specifications and\nthink about the strengths and weaknesses of other ISA specs: what makes them\nwork well; and what techniques they could borrow from other specifications.\nEarlier this month, someone asked me for my thoughts on the RISC-V\nspecification and I thought that it would be useful to share what I found out.\n\nThis post is about the RISC-V specification. This specification effectively\nconsists of several different parts each an essential part of defining the\nRISC-V architecture. The most obvious part of the specification are RISC-V\nInstruction Set Manual, volume 1 and RISC-V Instruction Set Manual, volume 2:\nPDF documents that describe the unprivileged and privileged parts of the\narchitecture. If you are developing a RISC-V processor, you will probably make\nheavy use of the RISC-V Test Suites to check that your processor correctly\nimplements the architecture. And you will probably be using the Spike RISC-V\nISA Simulator as a \u201cgolden reference model\u201d to compare the behavior of your\nprocessor against. And, finally, you might be using the SAIL RISC-V model as a\nformal specification of the architecture. (Although, I think this has mostly\nused to reason about software, rather than hardware.)\n\n## What\u2019s wrong with this picture?\n\nOverall, the specification is not in a very healthy state.\n\nThe two PDF documents rely heavily on natural language text in the\nspecification with the result that the description is not always very precise\nand it is impossible to test the descriptions to determine whether they match\nthe other artifacts.\n\nA common complaint about the test suites is that the RISC-V architecture is\nvery highly configurable with many subsets and implementation choices allowed\nbut the test suites is not easily configured to check the full envelope of\nallowed behaviors. Some of these issues stems from the challenge of creating a\nmachine-readable description of which particular configuration you intended to\nbuild. (This also limits the ability to use Spike as a golden reference\nmodel.) If you intend to build something outside the range of configurations\nthat Spike and the test suite support, you will end up with a large number of\n\u201cwaivers\u201d documenting the places where your processor is expected to fail the\ntests.\n\nFinally, there is the SAIL model written in the SAIL ISA specification\nlanguage. This is a precise, executable, formal specification of the\narchitecture but it is not used as much as it should be. Ideally, parts of the\nSAIL specification would be included in the official PDF documents so that the\nSAIL code can add the precision that the natural language spec lacks and the\nnatural language specification can make up for the almost total absence of\ncomments in the SAIL specification.\n\nA complaint that I often hear about the SAIL specification is that it is a bit\ninaccessible for normal users. The SAIL language design builds on a number of\npopular academic languages and programming language research ideas such as the\nOCaml Functional Programming Language, Liquid types, Monads, and Effect\nSystems. The challenge with drawing on these different sources is that the\nprimary audience for the specification is not programming language researchers\nbut people who work on hardware design, hardware validation, OS developers,\ncompiler developers, etc. \u2014 many of whom are not familiar with the academic\nprogramming language literature and are confused and put off by the syntax of\nSAIL. To illustrate this, consider the following SAIL example from early in\nthe SAIL reference manual:\n\n    \n    \n    val my_replicate_bits : forall 'n 'm, 'm >= 1 & 'n >= 1. (int('n), bits('m)) -> bits('n * 'm)\n\nIf you are not familiar with OCaml and liquid types, some questions that you\nmight ask are \u201cWhat are the quote marks for in 'm and 'n?\u201d and \u201cWhat does\nforall 'n 'm mean?\u201d\n\n## Connecting the pieces: machine-readable formats\n\nThe most important problem is that these four artifacts seem to be completely\ndisconnected from each other. They are maintained as four separate codebases\nin four separate repositories and no part of one artifact is generated from\npart of any other artifact. If you are writing an architecture extension, you\nhave to write the same thing four times in four separate formats and then you\nhave to use testing and review to check that all four copies are the same.\n\nBut worse than this, there is a whole ecosystem around RISC-V who will also be\nwriting code in response to your architecture extension. There are hardware\ndesigners, hardware validation teams, developers of software tools (such as\nassemblers, compilers and JITs), OS hackers and debugger developers, etc. that\nare all going to have to write some code to support or benefit from any\narchitecture extension. They also have to write all this code by hand and then\nreview and test the code to make it consistent with the official spec.\n\nIt is worth noting that most architecture extensions evolve between the first\ndesign and the final, ratified design: evaluating that design requires tool\nsupport; socializing and reviewing the design requires documentation. So each\nextension is typically implemented many times and each revision requires\nupdates in many places.\n\nThe easiest way to improve this would be to capture as much of the\narchitecture as possible in formats that are easy to read and manipulate. In\nparticular, instruction encodings and control/status registers are easily\ndescribed by simple JSON/YAML/XML/... formats. It doesn\u2019t take long to figure\nout what data you need to include to support generation of many different\nartifacts from such files:\n\n  * The name and a short description (for generating documentaton).\n  * The size, bitfields, fixed bits, etc.\n  * For registers, there will be a numeric id that is used to identify the register.\n  * What constraints are there on using the instruction or register? Is it usable in hypervisor mode? supervisor mode? usermode?\n  * For register fields, is the field readable? is it writable? what is its reset value? what is the meaning of different values that this field can have?\n  * For instructions, what is the assembly syntax? (See Bidirectional ARM Assembly Syntax Specifications)\n  * Which configurations support each entry, field or value?\n\nI\u2019ve probably missed a few important pieces of information but you get the\nidea.\n\nOf course, creating this easy-to-use, highly-reusable machine readable spec is\njust the first part. To make a difference, you have to modify the architecture\nreference manual, the Spike simulator, the testsuite and the SAIL\nspecification to use this data. You have to find every part of these artifacts\nthat currently contains information about instructions or CSRs and refactor\nthem around code that is automatically generated from the json/yaml/xml file.\nDoing this is critical to making it equally possible to auto-generate code for\nany new architecture extensions.\n\nAnd, as that is being done, people should be looking at the extended ecosystem\nof build tools, libraries, OSes, etc. to autogenerate as much of them as\npossible from the machine readable data files.\n\n## Making SAIL usable in documentation\n\nI have already touched on the problems for readers from a broad range of\nbackgrounds reading SAIL specifications. There are a range of improvements\nthat can be made here from changing the syntax to applying sensible defaults\nto reduce the amount of clutter from the type system. (Ideally, this would be\ndone by adopting some of the syntax of the ASL-1.0 ISA specification language\nwhich has many of the same features but was designed with more focus on use in\ndocumentation.)\n\nBut there is another issue that is both more fundamental and also easier to\nsolve: the SAIL specification is currently a large, monolithic specification.\nThere is no easy way to extract an individual instruction specification or\nfunction definition to include in a particular place in the documentation. The\neasiest option to include the SAIL spec into the current spec would be to\ninclude the entire spec as a giant appendix at the back of the architecture\nmanual. But it is much better to put each part of the SAIL spec on the same\npage as the natural language description of the same feature so that the SAIL\nspec can amplify your understanding of the natural language spec and the\nnatural language spec can help you understand the SAIL spec.\n\nFortunately, the fix is easy: either split the SAIL spec into smaller pieces\n(e.g., one definition per file) or write a tool to do it for you. This makes\nit easy to include the relevant part of the SAIL spec into the the\ndocumentation.\n\n[Note that there has been some work in the direction of using the SAIL specs\nin documentation such as the SAIL-to-ASCIIdoc tool.]\n\n## Using SAIL in tools\n\nWhy do we have two executable parts to the specification: the SAIL\nspecification and the Spike golden reference simulator? The historical reasons\nfor this are clear but it would be good if Spike support for future extensions\nwas generated from their SAIL specification.\n\nThis will take a bit of work to do. Mostly, this will consist of defining the\ninterface that code generated from the SAIL specs uses to access parts of the\nstate that are represented in Spike.\n\n## Conclusion\n\nThe RISC-V architecture was developed in classic startup/academic style:\ninnovating quickly and avoiding too much investment in long-term engineering.\nThis has resulted in the current situation where the architecture\nspecification is, in effect, scattered over four different artifacts and each\ndownstream tool/library/application has to transcribe information from those\nsources instead of being able to use architect-provided machine-readable\nformats to generate the code instead.\n\nThis was not too big a problem for the original base architecture of just 47\ninstructions and 32 registers but there have been many RISC-V ISA extensions\nadded since then.\n\n### Related posts and papers\n\n  * Goals of a modern ISA specification (presented at PLARCH 2023)\n  * What can you do with an ISA specification?\n  * Machine readable specifications at scale\n  * Bidirectional ARM Assembly Syntax Specifications\n\nWritten on April 27, 2024. The opinions expressed are my own views and not my\nemployer's.\n\n", "frontpage": true}
