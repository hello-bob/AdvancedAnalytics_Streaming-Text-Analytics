{"aid": "40284659", "title": "Purposefully Render-Blocking", "url": "https://fullystacked.net/render-blocking-on-purpose/", "domain": "fullystacked.net", "votes": 1, "user": "o-t-w", "posted_at": "2024-05-07 12:26:27", "comments": 0, "source_title": "Render-blocking on purpose", "source_text": "Render-blocking on purpose\n\nMay 2, 2024\n\n# Render-blocking on purpose\n\nRender blocking is something you usually want to avoid. Enter the term into\nGoogle and you\u2019ll be met with a great many articles about eliminating render-\nblocking. Perhaps somewhat surprisingly then, there\u2019s a new HTML blocking\nattribute to purposefully block rendering until a particular resource is\ndownloaded.\n\nA regular <script> tag, when lacking an async or defer attribute, will pause\nthe parsing of HTML and block rendering until the script is downloaded,\nparsed, and executed.\n\nThe following script is both parser-blocking and render-blocking:\n\n    \n    \n    <head> <script src=\"/script.js\"></script> </head>\n\nWhy do we need a new attribute?\n\n  * It makes the blocking behaviour explicit and conveys intent (your colleague will not accidentally refactor the code to be non-blocking).\n  * It makes it possible to block rendering without blocking the HTML parser when used in conjunction with the defer or async attribute.\n  * Unlike classic scripts, module scripts defer by default. <script type=\"module\"> can now block rendering by using the blocking attribute.\n  * <script>, <link> and <style> elements added to the <head> dynamically with JavaScript are not render blocking. You now have the flexibility to make them blocking.\n\n## How does it work?\n\nThe blocking attribute can be added to <script>, <link> and <style> elements\nin the <head>. As of today, the only thing that can be blocked is rendering\n(we might be able to block more operations using this attribute in the\nfuture).\n\nblocking=\"render\" is a way to mark a resource as required before anything is\nvisually shown to the user. Not a single pixel will be painted in the viewport\nuntil the resource has loaded.\n\n    \n    \n    <script blocking=\"render\" src=\"important.js\" defer></script>\n\nThe browser should assign a high priority to any render-blocking resource by\ndefault. As not all browsers support the blocking attribute, its worth adding\nfetchpriority=\"high\":\n\n    \n    \n    <script blocking=\"render\" fetchpriority=\"high\" src=\"important.js\" defer></script>\n\nThe attribute also works on inline scripts. A classic inline script is\nblocking by default (and the defer and async attributes aren\u2019t used on classic\ninline scripts). However, a script with a type=\"module\" attribute will be\ndeferred, even when its inline.\n\n    \n    \n    <script type=\"module\" async blocking=\"render\"> // vital JavaScript code... </script>\n\nThe async attribute on an inline module script will cause it to execute as\nsoon as possible.\n\nLet\u2019s look at a basic visual demonstration. ChromaCheck is a simple website\nthat display\u2019s which font formats a browser supports. To do this it uses\nclient-side JavaScript, without render-blocking:\n\nBefore the JavaScript has a chance to update the DOM, it briefly shows all\nformats as unsupported. It would be better to start with a neutral color in\ncase JavaScript fails, but you\u2019d still get a flash of changing styles as the\npage loads. The sites entire raison d\u2019etre relies on JavaScript. The\nJavaScript-dependent elements are displayed at the top of the page. The script\nis small. Render-blocking would be an improvement in this case. The user would\nwait slightly longer for the first paint, but that\u2019s a worthwhile tradeoff.\nThe critical content can be rendered fully-formed with no awkard or\ndisorientating stylistic changes. Here\u2019s the same site with render-blocking\n(with slow 3G throttling):\n\nThese sort of last-minute JavaScript DOM updates that effect above the fold\ncontent can sometimes justify render-blocking to prevent the discordant and\njarring herky-jerky of content updating and rearranging (although layout\nshifts caused by dynamic content can often be solved simply by reserving space\nwith min-height).\n\n## blocking=\"render\" on <link>\n\nYou can also use the blocking attribute on <link> elements. However, if you\nare using the <link> to preload resources with rel=\"preload\" or to preload\nJavaScript modules with rel=\"modulepreload\" then the blocking attribute will\nhave no effect.\n\nStylesheets are blocking by default \u2014 and for good reason. This avoids a Flash\nof Unstyled Content (FOUC). Without render-blocking, the user would see the\nHTML displayed using only the browsers basic default visual styles: black\nTimes New Roman on a white background, etc. Then, once the stylesheet loads,\nthe view of the page would change drastically, which is not a good user\nexperience. Here\u2019s what the theverge.com looks like without any CSS, to take\none random example:\n\nBecause stylesheets block by default, adding the blocking attribute to a\n<link> or <style> tag is almost always unnecessary. The exception is a\nstylesheet loaded via JavaScript.\n\nThe following stylesheet would not block rendering:\n\n    \n    \n    const link = document.createElement('link'); link.rel = 'stylesheet'; link.href = './styles.css'; document.head.appendChild(link);\n\nDevelopers tend to take advantage of this behaviour to purposefully defer non-\ncritical CSS. If, however, you need to load critical CSS (styles that change\nthe layout of the entire page or effect something above the fold) in this way,\nyou can make use of the blocking attribute:\n\n    \n    \n    const link = document.createElement('link'); link.rel = 'stylesheet'; link.href = './styles.css'; link.setAttribute('blocking', 'render'); document.head.appendChild(link);\n\n## The Performance API\n\nTo validate that the attribute worked, you can run the following code in the\nbrowser devtools console to see a list of render-blocking resources:\n\n    \n    \n    window.performance.getEntriesByType(\"resource\") .filter(resource => resource.renderBlockingStatus === \"blocking\") .forEach(resource => console.log(resource.name));\n\n## Render-blocking DOM nodes\n\nHTML renders progressively/incrementally:\n\nImage borrowed from Philip Walton at web.dev\n\nRendering can start before the entire HTML document is fetched and parsed.\n\nThere\u2019s a way to block rendering based on whether a particular HTML element\nhas been parsed.\n\nPlace a <link> in the <head> with a href attribute referencing the id of the\nelement in question:\n\n    \n    \n    <!DOCTYPE html> <html> <head> <link rel=\"expect\" href=\"#visually-critical-content\" blocking=\"render\"> </head> <body> <header>...</header> <div id=\"visually-critical-content\">...</div> </body> </html>\n\nThis gives developers more control over what\u2019s included in the First\nContentful Paint. It should only be used for elements that are above the fold\n\u2014 otherwise you\u2019ll be needlessly delaying the first paint. Once the element\nhas been parsed, the page will be made visible to the user. If the expected\nelement is not found, rendering will be unblocked when the entire HTML\ndocument has finished parsing.\n\nThis feature was added to the web primarily with cross-document view\ntransitions in mind.\n\n## The pagereveal event and View Transitions\n\nThe initial implementation of view transitions only worked with client-side\nnavigation. One primary use case for blocking=\"render\" is cross-document view\ntransitions. With this in mind, Chrome/Edge recently implemented a new\npagereveal event:\n\n    \n    \n    window.addEventListener('pagereveal', function(event) { console.log(event.viewTransition); });\n\nThis event listener needs to be registered in a render-blocking script.\nOtherwise, by the time JavaScript has added the event listener, the event will\nlikely have already taken place so won\u2019t trigger your callback function.\npagereveal takes place immediately before the first rendering opportunity.\nThat means after any render-blocking CSS or JavaScript has loaded, but it\ncould fire before all the HTML has been parsed. However, if you have <link\nrel=\"expect\" href=\"#thing\" blocking=\"render\"> in the <head>, for example, you\ncan query that element with document.getElementById('thing') without the risk\nof it being null.\n\nRead View Transitions Break Incremental Rendering by Eric Portis for an\ninteresting perspective on this topic and the response from browser engineer\nNoam Rosenthal.\n\n## What does the user actually see?\n\nRender-blocking delays drawing pixels to the screen, so you might assume this\ninvolves staring at a blank page. On fast connections, that is rarely the\ncase. When navigating the web, it used to be common to see a flash of white\nbetween pages. To solve this, browsers started utilising paint holding. Paint\nholding keeps the user on the previous page and shows a loading indicator\nuntil the First Contentful Paint (FCP) of the new page is ready. If you delay\nFCP, the user will be kept looking at the previous page for slightly longer.\nPaint holding only lasts for a short amount of time. If you delay FCP for too\nlong, an empty white page will be displayed. For a slow site on slow 3G, this\n\u201cflash\u201d of white nothingness could potentially last for a significant amount\nof time.\n\n## Browser support\n\nThe blocking attribute has been available in Chrome and Edge since version\n105. It is also available in Samsung Internet. See MDN for the most up-to-date\nbrowser compatibility data.\n\nBlocking via the id of a HTML element is supported in Chrome 124.\n\nIt should go without saying that this attribute should be used with some\namount of care as it will negatively impact First Contentful Paint (FCP),\nwhich is an important performance metric. The fact that browsers purposefully\nblock rendering until stylesheets have loaded speaks to the fact that render-\nblocking is the right tradeoff for certain critical resources.\n\n\u00a9 2024 Ollie Williams. All rights reserved.\n\nFollow Ollie Williams on Twitter Go to Ollie Williams's GitHub repo\n\n", "frontpage": false}
