{"aid": "40224053", "title": "Developing Embedded Applications with Swift", "url": "https://fatbobman.com/en/posts/developing-embedded-applications-with-swift/", "domain": "fatbobman.com", "votes": 2, "user": "madmachine", "posted_at": "2024-05-01 14:49:36", "comments": 0, "source_title": "Developing Embedded Applications with Swift | Fatbobman's Blog", "source_text": "Developing Embedded Applications with Swift | Fatbobman's Blog\n\n\u8098\u5b50\u7684 Swift \u8bb0\u4e8b\u672c\n\n  * English\n\n  * \u4e2d\u6587\n\n#Swift #Dev Tools #\u4e2d\u6587\u7248\n\n# Developing Embedded Applications with Swift\n\nFatbobman\n\nPublished on May 1, 2024\n\nGet weekly handpicked updates on Swift and SwiftUI!\n\nIn recent years, Swift has gradually shown its potential for cross-platform\ndevelopment. In this article, I will share some of my experiences and attempts\nat using the Swift language for embedded development on the SwiftIO\ndevelopment board.\n\n> Special Note: This article specifically discusses embedded development on\n> MCU (Microcontroller Unit) hardware that does not have a Memory Management\n> Unit (MMU), and does not cover devices like the Raspberry Pi that possess\n> full general-purpose computing capabilities.\n\nApp\n\nHEALTH NOTES\n\nHealth Notes is an iOS/iPad/macOS app that offers robust custom data types,\ncatering to the diverse needs of recording health-related information in your\nlife. Download on the App Store\n\n## Swift is Not Just for the Apple Ecosystem\n\nWhile the majority of Swift developers primarily use the language within the\nApple ecosystem, Swift was designed from its inception as a modern, cross-\nplatform system programming language. This indicates that the Swift\ndevelopment team intends for the language to run on a broader range of\nplatforms and systems, meeting diverse development needs from the lower levels\nto the user interface.\n\nIn the #026 issue of Fatbobman\u2019s Swift Weekly, we discussed the development of\nSwift on Linux, Windows, and embedded platforms, as well as the open-sourcing\nand cross-platform development progress of some key frameworks and projects.\nThese trends show that Swift is accelerating its expansion beyond the Apple\necosystem to fulfill its original vision of universal platform applicability.\n\n## Why Use High-Level Languages for Embedded Development\n\nOur daily lives are filled with the use of embedded devices, involving a wide\nrange of equipment such as home appliances, access control systems,\nsurveillance systems, and POS machines. Traditionally, many have believed that\nembedded systems have limited hardware capabilities, suited only for\napplications that are simple in function yet demand high stability.\n\nHowever, with advancements in technology and increasing demands, low-\nperformance embedded devices can no longer meet the needs of complex\nscenarios. Take the rapidly proliferating smart cars as an example; to ensure\nreliability, the dashboard behind the steering wheel is not controlled and\ndisplayed directly through the car\u2019s system but relies on a microcontroller\nunit (MCU) with sufficient performance to support complex display effects.\nThis setup ensures that the dashboard remains functional even if the main car\nsystem fails.\n\nAs the complexity of embedded applications multiplies, failing to use high-\nlevel programming languages can severely impact development efficiency and the\noverall performance of applications.\n\n## SwiftIO Playground Kit\n\nSeveral years ago, developers began to explore the application of Swift in the\nembedded domain, achieving initial progress. I became aware of the Mad Machine\nteam two years ago. Due to the pandemic, their first-generation products faced\nchallenges in chip supply. In March this year, they launched a new generation\nproduct: the SwiftIO Playground Kit. Upon receiving the development kit, I\nimmediately tested it and experienced the joys and challenges of using Swift\nfor embedded development.\n\nThe SwiftIO Playground Kit includes the SwiftIO Micro core board and various\ninput/output devices. As the complexity of embedded devices increases, Mad\nMachine has chosen the Zephyr real-time operating system and a core library\nbuilt on Swift to handle the underlying complexity. This approach frees\ndevelopers from worrying about hardware details while ensuring compatibility\nwith future hardware changes. The SwiftIO Micro is equipped with a 600MHz MCU,\n32MB RAM, and 16MB Flash, offering powerful performance that ensures\ndevelopers need not worry about the size of the Swift standard library post-\ncompilation, which currently stands at 2MB.\n\n> The Swift community has designated specialists to address some of the\n> challenges faced by Swift in the domain of embedded development, primarily\n> concerning the size of the standard library.\n\n## Initial Development Experience\n\nThanks to the comprehensive documentation provided by the official team,\nsetting up the development environment went smoothly. The specific steps\nincluded:\n\n  * Installing the necessary drivers (currently supports macOS and Linux).\n  * Downloading the mm-sdk, which includes Swift 5.9 customized for embedded development and related tools.\n  * Installing plugins in VSCode and setting the SDK path to point to the newly downloaded mm-sdk.\n\nAfter completing these setups, we can see the MADMACHINE panel in VSCode and\nstart creating projects.\n\n> My VSCode configuration includes Swift for Visual Studio Code developed by\n> the Swift Server Workgroup, as well as SwiftLint and SwiftFormat plugins.\n> For detailed instructions on setting up a Swift development environment on\n> Linux, please see this guide.\n\nNext, we introduced the necessary third-party libraries and wrote the\nfollowing code to make a blue LED blink every second:\n\nSwift\n\n    \n    \n    import SwiftIO import MadBoard let led = DigitalOut(Id.BLUE) while true { led.write(true) sleep(ms: 1000) led.write(false) sleep(ms: 1000) }\n\nThe official team also provides many interesting demos, such as the falling\nsand simulation below. A detailed algorithm explanation can be found on their\nwebsite. Users can adjust the potentiometer to change the position from which\nthe sand is ejected and press a button to release new grains of sand.\n\nAlthough the development process went generally smoothly, after the initial\nexcitement, I began to notice some shortcomings compared to my usual\ndevelopment with Swift. First, in VSCode, even though I had installed plugins,\nthere were limitations in code declaration jumps and deep dives into third-\nparty libraries. Additionally, due to the data transfer rate limitations of\nthe development board, each compilation required a wait time to transfer data\nto the board and debug (for example, the sand project took about 14 seconds).\nFor someone accustomed to the development process of Xcode + SwiftUI +\nPreview, this experience had noticeable gaps. Especially in the development of\nmore complex and UI-inclusive applications, the time consumed by compilation\nand data transfer could significantly affect development efficiency.\n\nSo, can we improve these issues under the current conditions using familiar\ntools and processes?\n\n## Developing Embedded Applications with Familiar Tools\n\n> In this chapter, I will use the \u201cSand\u201d project as an example to demonstrate\n> how to build my ideal development process. You can view the modified project\n> here.\n\n### Analysis\n\nThe \u201cSand\u201d project consists mainly of two Swift files. Sand.swift contains the\ncore logic of the project, defining a Sand class responsible for adjusting the\nposition of the ejection port based on input from a potentiometer, and\nmanaging the falling, collision, and animation of the sand particles.\nmain.swift primarily handles the initialization of hardware and cyclically\ncalls the sand.update() method to refresh the display.\n\nDelving into the Sand class, we can identify the following parts that directly\ninteract with the hardware:\n\n  * Using the ST7789 controller to render images.\n  * Reading data from a potentiometer through AnalogIn.\n  * Using the getSystemUptimeInMilliseconds function to change the color of the sand based on time intervals.\n\nIf we can abstract these hardware interaction logics, we can make the Sand\nclass (i.e., the core logic of the application) independent of specific\nhardware, enabling it to run on other platforms.\n\nFortunately, Mad Machine uses pure Swift code to control these hardware\ncomponents, and we can meet our development needs by abstracting their\nimplementations into protocols.\n\n### Declaring Protocols\n\nTo achieve hardware abstraction, I created a new package called MadBoardBase,\nwhich defines two key interface protocols.\n\n> Note: The declarations of these protocols only include the methods and\n> properties actually used in the current code, primarily for the purpose of\n> concept validation.\n\nSwift\n\n    \n    \n    public protocol ST7789Base { func writePixel(x: Int, y: Int, color: UInt16) func writeBitmap(x: Int, y: Int, width w: Int, height h: Int, data: UnsafeRawBufferPointer) var width: Int { get } var height: Int { get } } public protocol AnalogInBase { func readPercentage() -> Float }\n\nThese protocols allow us to simulate and control hardware behavior without\ndirectly relying on specific hardware implementations, enabling the Sand\nclass\u2019s application logic to operate across platforms.\n\n### Decoupling from Hardware\n\nTo further abstract, I created a new package called Sand, specifically\ndesigned to encapsulate declarations related to the Sand class. By integrating\nthe MadBoardBase package, we made significant adjustments to the Sand.swift\nfile to ensure its independence from hardware.\n\nSwift\n\n    \n    \n    public final class Sand<S, A> where S: ST7789Base, A: AnalogInBase { ... // Time fetching code is also abstracted public init(screen: S, cursor: A, getSystemUptimeInMilliseconds: @escaping () -> Int64) { ... } ... }\n\nWith these adjustments, the Sand class can now be compatible with any hardware\nor simulated module that implements the ST7789Base and AnalogInBase protocols,\nallowing it to be tested and debugged across platforms.\n\n> View the code changes: Before and After adjustments.\n\n### Building View Components\n\nAlthough the Sand class has achieved independence from hardware, we need\nappropriate view components to use it in different environments.\n\nFor this purpose, we created a new package named MadBoardViewComponents, which\ndefines view components that conform to the ST7789Base and AnalogInBase\nprotocols. These components can be used to debug the Sand code within a\nSwiftUI plus Preview environment.\n\nFirst, we use SwiftUI\u2019s Slider to simulate the behavior of a potentiometer:\n\nSwift\n\n    \n    \n    public final class AnalogInModel: AnalogInBase, ObservableObject { @Published public var value: Float = .zero public init() {} public func readPercentage() -> Float { return value } } public struct AnalogInComponent: View { @ObservedObject private var model: AnalogInModel public init(model: AnalogInModel) { this.model = model } public var body: some View { Slider(value: $model.value, in: 0...1) } }\n\nNext, we create a component that simulates the ST7789 LCD screen:\n\nSwift\n\n    \n    \n    public final class ST7789Model: ST7789Base, ObservableObject { public var width: Int public var height: Int var pixels: [UInt16] // Array to store pixel data public init(width: Int = 240, height: Int = 240) { this.width = width this.height = height pixels = Array(repeating: 0x0000, count: width * height) } public func writePixel(x: Int, y: Int, color: UInt16) { if x >= 0 && y >= 0 && x < width && y < height { pixels[y * width + x] = color } } public func writeBitmap(x: Int, y: Int, width w: Int, height h: Int, data: UnsafeRawBufferPointer) { if x >= 0 && y >= 0 && x + w <= width && y + h <= height { let srcData = data.bindMemory(to: UInt16.self) for row in 0..<h { let srcRowStart = row * w let dstRowStart = (y + row) * width + x for col in 0..<w { pixels[dstRowStart + col] = srcData[srcRowStart + col] } } } } } public class ST7789UIView: UIView { // Additional implementation details } public struct ST7789UIComponent: UIViewRepresentable { var model: ST7789Model var scale: CGFloat public init(model: ST7789Model, scale: CGFloat = 1.0) { this.model = model this.scale = scale } public func makeUIView(context: Context) -> ST7789UIView { let view = ST7789UIView(frame: CGRect(x: 0, y: 0, width: CGFloat(model.width), height: CGFloat(model.height)), model: model) return view } public func updateUIView(_ view: ST7789UIView, context: Context) { // Update logic } public func sizeThatFits(_ proposedSize: ProposedViewSize, in view: ST7789UIView, context: Context) -> CGSize? { .init(width: CGFloat(model.width), height: CGFloat(model.height)) } }\n\n> The complete code for ST7789UIView can be viewed at this link. Initially, I\n> tried building the component with SwiftUI\u2019s Canvas, but due to insufficient\n> performance, I have since switched to an implementation based on UIKit. To\n> further enhance performance, consideration should be given to using Metal in\n> the future. Additionally, to reduce the impact on the main thread,\n> alternative input methods, such as game controllers, could be considered.\n\n### Creating a SwiftUI Project\n\nAfter completing all the preparatory work, we are now ready to begin\ndeveloping the \u201cSand\u201d demo project using familiar methods. First, create a\nSwiftUI project named DropSand in the root directory and integrate the\nMadBoardViewComponents and Sand libraries.\n\nSimilar to how we handle the main.swift file, we simply need to declare the\nview components according to the standard SwiftUI application process and\ninvoke an instance of the Sand class. This will allow the demo project to run\nsmoothly in the SwiftUI environment.\n\n### Writing Hardware-Related Code\n\nAfter completing cross-platform debugging of the Sand class, we can begin\napplying this code to actual embedded projects.\n\nIn VSCode, use the MADMACHINE panel to create a new project named\nSandPlayground. Copy the main.swift code from the original project and make\nthe following necessary adjustments to adapt it to the embedded environment:\n\nSwift\n\n    \n    \n    import Sand extension ST7789: ST7789Base {} extension AnalogIn: AnalogInBase {} // Add function for fetching time var sand = Sand(screen: screen, cursor: cursor, getSystemUptimeInMilliseconds: getSystemUptimeInMilliseconds)\n\nWith these adjustments, the modified Sand code can now run seamlessly on both\nApple devices and embedded platforms, achieving true code reuse.\n\n### Review\n\nSome might think my method overcomplicates simple things. However, if we\ncarefully review the ideal development process, we can clearly see the\nadvantages these adjustments bring. Developing SwiftIO applications typically\nfollows these steps:\n\n  * Create a SwiftUI project: Start a new project and introduce simulation components developed by Mad Machine or the community.\n  * Develop and test the core package: Write core code based on hardware protocols in a separate package and conduct unit testing.\n  * Integration and interactive testing: Integrate the core code into the SwiftUI project and complete interactive testing.\n  * Implementation in an embedded environment: Integrate the core code into an embedded project, perform hardware debugging, and ultimately complete the application development.\n\nThis approach allows developers to spend most of their time using familiar\ntools in a familiar environment, greatly enhancing the development efficiency\nof SwiftIO projects.\n\nApp\n\nHEALTH NOTES\n\nHealth Notes is an iOS/iPad/macOS app that offers robust custom data types,\ncatering to the diverse needs of recording health-related information in your\nlife. Download on the App Store\n\n## Outlook\n\nFor many Swift developers, embedded development is an unfamiliar field.\nHowever, with the emergence of hardware and SDKs like SwiftIO, we now have the\nopportunity to explore this domain. Even if not for professional needs, using\nthese tools to implement personal creative ideas and bring joy to oneself,\nfamily, and friends is a very meaningful activity.\n\nLooking ahead, if Mad Machine can further abstract the hardware and build more\nsimulation components, children and students could complete most of the\nembedded development work on an iPad. This not only lowers the technical\nthreshold for entry but also greatly stimulates their interest in learning and\nusing Swift, opening up more possibilities.\n\nLink copied\n\nI'm really looking forward to hearing your thoughts! Please Leave Your\nComments Below to share your views and insights.\n\n#### Fatbobman(\u4e1c\u5761\u8098\u5b50)\n\nI'm passionate about life and sharing knowledge. My blog focuses on Swift,\nSwiftUI, Core Data, and Swift Data. Follow my social media for the latest\nupdates.\n\nYou can support me in the following ways\n\n### Related Posts\n\nRelated Posts\n\n### Weekly #1 - New Beginning, New Weekly, Two Languages\n\n### Setting Up a Swift Development and Debugging Environment on Linux\n\n### Swift Playgrounds 4: Entertainment or Productivity\n\n### Exploring Xcode Playground (Part 1)\n\n### Unified Resource Management in Multi-package Projects\n\n### Pair Programming with AI\n\n### Blog Update Chronicle: Welcoming 2024 with a New Blog\n\n1 comment\n\nAnonymous\n\nMarkdown is supported\n\nandy0808commentedabout 1 hour ago\n\nWow! It's really a genius way to simulate hardware-related code on a Mac. Very\nimpressive!\n\n  * Swift is Not Just for the Apple Ecosystem\n\n  * Why Use High-Level Languages for Embedded Development\n\n  * SwiftIO Playground Kit\n\n  * Initial Development Experience\n\n  * Developing Embedded Applications with Familiar Tools\n\n  * Analysis\n\n  * Declaring Protocols\n\n  * Decoupling from Hardware\n\n  * Building View Components\n\n  * Creating a SwiftUI Project\n\n  * Writing Hardware-Related Code\n\n  * Review\n\n  * Outlook\n\nIn-Depth Exploration of Overlay and Background Modifiers in SwiftUI\n\nFacebook page Twitter page\n\nSince 2020\n\n", "frontpage": false}
