{"aid": "40130934", "title": "Floating Point Visually Explained", "url": "https://fabiensanglard.net/floating_point_visually_explained/", "domain": "fabiensanglard.net", "votes": 1, "user": "JoachimS", "posted_at": "2024-04-23 12:02:00", "comments": 0, "source_title": "Floating Point Visually Explained", "source_text": "Floating Point Visually Explained\n\nFABIEN SANGLARD'S WEBSITE\n\nABOUT CONTACT RSS $$$\n\nAugust 29, 2017\n\nFloating Point Visually Explained\n\nWhile I was writing the Wolfenstein 3D book^[1], I wanted to demonstrate how\nmuch of a handicap it was to work without floating points. My attempts at\nunderstanding floating points using canonical^[2] articles^[3] were met with\nresistance from my brain.\n\nI tried to find a different way. Something far from (\u22121)S\u22171.M\u22172(E\u2212127) and its\nmysterious exponent/mantissa. Possibly a drawing since they seem to flow\nthrough my brain better.\n\nI ended up with what follows and I decided to include it in the book. I am not\nclaiming this is my invention but I have never seen floating points explained\nthis way so far. I hope it will helps a few people like me who are a bit\nallergic to mathematic notations.\n\nHow Floating Point are usually explained\n\nIn the C language, floats are 32-bit container following the IEEE 754\nstandard. Their purpose is to store and allow operations on approximation of\nreal numbers. The way I have seen them explained so far is as follow. The 32\nbits are divided in three sections:\n\n  * 1 bit S for the sign\n  * 8 bits E for the exponent\n  * 23 bits for the mantissa\n\nFloating Point internals. The three sections of a floating point number. So\nfar, so good. Now, how numbers are interpreted is usually explained with the\nformula:\n\n(\u22121)S\u22171.M\u22172(E\u2212127)\n\nHow everybody hates floating point to be explained to them.\n\nThis is usually where I flip the table. Maybe I am allergic to mathematic\nnotation but something just doesn't click when I read it. It feels like\nlearning to draw a owl.\n\n> Floating-point arithmetic is considered an esoteric subject by many people.\n>\n> \\- David Goldberg\n\nA different way to explain...\n\nAlthough correct, this way of explaining floating point will leaves some of us\ncompletely clueless. Fortunately, there is a different way to explain it.\nInstead of Exponent, think of a Window between two consecutive power of two\nintegers. Instead of a Mantissa, think of an Offset within that window.\n\nThe three sections of a floating Point number. The window tells within which\ntwo consecutive power-of-two the number will be: [0.5,1], [1,2], [2,4], [4,8]\nand so on (up to [2127,2128]). The offset divides the window in 223=8388608\nbuckets. With the window and the offset you can approximate a number. The\nwindow is an excellent mechanism to protect from overflowing. Once you have\nreached the maximum in a window (e.g [2,4]), you can \"float\" it right and\nrepresent the number within the next window (e.g [4,8]). It only costs a\nlittle bit of precision since the window becomes twice as large.\n\nThe next figure illustrates how the number 6.1 would be encoded. The window\nmust start at 4 and span to next power of two, 8. The offset is about half way\ndown the window.\n\nValue 6.1 approximated with floating point.\n\nPrecision\n\nHow much precision is lost when the window covers a wider range? Let's take an\nexample with window [1,2] where the 8388608 offsets cover a range of 1 which\ngives a precision of (2\u22121)8388608=0.00000011920929. In the window [2048,4096]\nthe 8388608 offsets cover a range of 4096\u22122048=2048 which gives a precision of\n4096\u221220488388608=0.0002.\n\nAn other example\n\nLet's take an other example with the detailed calculations of the floating\npoint representation of a number we all know well: 3.14.\n\n  * The number 3.14 is positive \u2192S=0.\n  * The number 3.14 is between the power of two 2 and 4 so the floating window must start at 21 \u2192E=128 (see formula where window is 2(E\u2212127)).\n  * Finally there are 223 offsets available to express where 3.14 falls within the interval [2-4]. It is at 3.14\u221224\u22122=0.57 within the interval which makes the offset M=223\u22170.57=4781507\n\nWhich in binary translates to:\n\n  * S = 0 = 0b\n  * E = 128 = 10000000b\n  * M = 4781507 = 10010001111010111000011b\n\n3.14 floating point binary representation. The value 3.14 is therefore\napproximated to 3.1400001049041748046875. The corresponding value with the\nugly formula:\n\n3.14=(\u22121)0\u22171.57\u22172(128\u2212127)\n\nAnd finally the graphic representation with window and offset:\n\n3.14 window and offset.\n\nI hope that helped :) !\n\nReferences\n\n^| [1]| Game Engine Black Book: Wolfenstein 3D  \n---|---|---  \n^| [2]| Wikipedia, Floating-point arithmetic  \n^| [3]| What Every Computer Scientist Should Know About Floating-Point\nArithmetic  \n  \n*\n\n", "frontpage": false}
