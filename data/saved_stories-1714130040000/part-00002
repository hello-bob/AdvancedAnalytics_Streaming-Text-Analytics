{"aid": "40166116", "title": "React 19 Beta", "url": "https://react.dev/blog/2024/04/25/react-19", "domain": "react.dev", "votes": 1, "user": "DustinBrett", "posted_at": "2024-04-26 05:08:33", "comments": 0, "source_title": "React 19 Beta \u2013 React", "source_text": "React 19 Beta \u2013 React\n\nStream React Conf on May 15-16.\n\nLearn more.\n\nBlog\n\n# React 19 Beta\n\nApril 25, 2024 by The React Team\n\n### Note\n\nThis beta release is for libraries to prepare for React 19. App developers\nshould upgrade to 18.3.0 and wait for React 19 stable as we work with\nlibraries and make changes based on feedback.\n\nReact 19 Beta is now available on npm!\n\nIn our React 19 Beta Upgrade Guide, we shared step-by-step instructions for\nupgrading your app to React 19 Beta. In this post, we\u2019ll give an overview of\nthe new features in React 19, and how you can adopt them.\n\n  * What\u2019s new in React 19\n  * Improvements in React 19\n  * How to upgrade\n\nFor a list of breaking changes, see the Upgrade Guide.\n\n## What\u2019s new in React 19\n\n### Actions\n\nA common use case in React apps is to perform a data mutation and then update\nstate in response. For example, when a user submits a form to change their\nname, you will make an API request, and then handle the response. In the past,\nyou would need to handle pending states, errors, optimistic updates, and\nsequential requests manually.\n\nFor example, you could handle the pending and error state in useState:\n\n    \n    \n    // Before Actions\n    \n    function UpdateName({}) {\n    \n    const [name, setName] = useState(\"\");\n    \n    const [error, setError] = useState(null);\n    \n    const [isPending, setIsPending] = useState(false);\n    \n    const handleSubmit = async () => {\n    \n    setIsPending(true);\n    \n    const error = await updateName(name);\n    \n    setIsPending(false);\n    \n    if (error) {\n    \n    setError(error);\n    \n    return;\n    \n    }\n    \n    redirect(\"/path\");\n    \n    };\n    \n    return (\n    \n    <div>\n    \n    <input value={name} onChange={(event) => setName(event.target.value)} />\n    \n    <button onClick={handleSubmit} disabled={isPending}>\n    \n    Update\n    \n    </button>\n    \n    {error && <p>{error}</p>}\n    \n    </div>\n    \n    );\n    \n    }\n\nIn React 19, we\u2019re adding support for using async functions in transitions to\nhandle pending states, errors, forms, and optimistic updates automatically.\n\nFor example, you can use useTransition to handle the pending state for you:\n\n    \n    \n    // Using pending state from Actions\n    \n    function UpdateName({}) {\n    \n    const [name, setName] = useState(\"\");\n    \n    const [error, setError] = useState(null);\n    \n    const [isPending, startTransition] = useTransition();\n    \n    const handleSubmit = async () => {\n    \n    startTransition(async () => {\n    \n    const error = await updateName(name);\n    \n    if (error) {\n    \n    setError(error);\n    \n    return;\n    \n    }\n    \n    redirect(\"/path\");\n    \n    })\n    \n    };\n    \n    return (\n    \n    <div>\n    \n    <input value={name} onChange={(event) => setName(event.target.value)} />\n    \n    <button onClick={handleSubmit} disabled={isPending}>\n    \n    Update\n    \n    </button>\n    \n    {error && <p>{error}</p>}\n    \n    </div>\n    \n    );\n    \n    }\n\nThe async transition will immediately set the isPending state to true, make\nthe async request(s), and switch isPending to false after any transitions.\nThis allows you to keep the current UI responsive and interactive while the\ndata is changing.\n\n### Note\n\n#### By convention, functions that use async transitions are called \u201cActions\u201d.\n\nActions automatically manage submitting data for you:\n\n  * Pending state: Actions provide a pending state that starts at the beginning of a request and automatically resets when the final state update is committed.\n  * Optimistic updates: Actions support the new useOptimistic hook so you can show users instant feedback while the requests are submitting.\n  * Error handling: Actions provide error handling so you can display Error Boundaries when a request fails, and revert optimistic updates to their original value automatically.\n  * Forms: <form> elements now support passing functions to the action and formAction props. Passing functions to the action props use Actions by default and reset the form automatically after submission.\n\nBuilding on top of Actions, React 19 introduces useOptimistic to manage\noptimistic updates, and a new hook React.useActionState to handle common cases\nfor Actions. In react-dom we\u2019re adding <form> Actions to manage forms\nautomatically and useFormStatus to support the common cases for Actions in\nforms.\n\nIn React 19, the above example can be simplified to:\n\n    \n    \n    // Using <form> Actions and useActionState\n    \n    function ChangeName({ name, setName }) {\n    \n    const [error, submitAction, isPending] = useActionState(\n    \n    async (previousState, formData) => {\n    \n    const error = await updateName(formData.get(\"name\"));\n    \n    if (error) {\n    \n    return error;\n    \n    }\n    \n    redirect(\"/path\");\n    \n    }\n    \n    );\n    \n    return (\n    \n    <form action={submitAction}>\n    \n    <input type=\"text\" name=\"name\" />\n    \n    <button type=\"submit\" disabled={isPending}>Update</button>\n    \n    {error && <p>{error}</p>}\n    \n    </form>\n    \n    );\n    \n    }\n\nIn the next section, we\u2019ll break down each of the new Action features in React\n19.\n\n### New hook: useActionState\n\nTo make the common cases easier for Actions, we\u2019ve added a new hook called\nuseActionState:\n\n    \n    \n    const [error, submitAction, isPending] = useActionState(async (previousState, newName) => {\n    \n    const {error} = await updateName(newName);\n    \n    if (!error) {\n    \n    // You can return any result of the action.\n    \n    // Here, we return only the error.\n    \n    return error;\n    \n    }\n    \n    // handle success\n    \n    });\n\nuseActionState accepts a function (the \u201cAction\u201d), and returns a wrapped Action\nto call. This works because Actions compose. When the wrapped Action is\ncalled, useActionState will return the last result of the Action as data, and\nthe pending state of the Action as pending.\n\n### Note\n\nReact.useActionState was previously called ReactDOM.useFormState in the Canary\nreleases, but we\u2019ve renamed it and deprecated useFormState.\n\nSee #28491 for more info.\n\nFor more information, see the docs for useActionState.\n\n### React DOM: <form> Actions\n\nActions are also integrated with React 19\u2019s new <form> features for react-dom.\nWe\u2019ve added support for passing functions as the action and formAction props\nof <form>, <input>, and <button> elements to automatically submit forms with\nActions:\n\n    \n    \n    <form action={actionFunction}>\n\nWhen a <form> Action succeeds, React will automatically reset the form for\nuncontrolled components. If you need to reset the <form> manually, you can\ncall the new requestFormReset React DOM API.\n\nFor more information, see the react-dom docs for <form>, <input>, and\n<button>.\n\n### React DOM: New hook: useFormStatus\n\nIn design systems, it\u2019s common to write design components that need access to\ninformation about the <form> they\u2019re in, without drilling props down to the\ncomponent. This can be done via Context, but to make the common case easier,\nwe\u2019ve added a new hook useFormStatus:\n\n    \n    \n    import {useFormStatus} from 'react-dom';\n    \n    function DesignButton() {\n    \n    const {pending} = useFormStatus();\n    \n    return <button type=\"submit\" disabled={pending} />\n    \n    }\n\nuseFormStatus reads the status of the parent <form> as if the form was a\nContext provider.\n\nFor more information, see the react-dom docs for useFormStatus.\n\n### New hook: useOptimistic\n\nAnother common UI pattern when performing a data mutation is to show the final\nstate optimistically while the async request is underway. In React 19, we\u2019re\nadding a new hook called useOptimistic to make this easier:\n\n    \n    \n    function ChangeName({currentName, onUpdateName}) {\n    \n    const [optimisticName, setOptimisticName] = useOptimistic(currentName);\n    \n    const submitAction = async formData => {\n    \n    const newName = formData.get(\"name\");\n    \n    setOptimisticName(newName);\n    \n    const updatedName = await updateName(newName);\n    \n    onUpdateName(updatedName);\n    \n    };\n    \n    return (\n    \n    <form action={submitAction}>\n    \n    <p>Your name is: {optimisticName}</p>\n    \n    <p>\n    \n    <label>Change Name:</label>\n    \n    <input\n    \n    type=\"text\"\n    \n    name=\"name\"\n    \n    disabled={currentName !== optimisticName}\n    \n    />\n    \n    </p>\n    \n    </form>\n    \n    );\n    \n    }\n\nThe useOptimistic hook will immediately render the optimisticName while the\nupdateName request is in progress. When the update finishes or errors, React\nwill automatically switch back to the currentName value.\n\nFor more information, see the docs for useOptimistic.\n\n### New API: use\n\nIn React 19 we\u2019re introducing a new API to read resources in render: use.\n\nFor example, you can read a promise with use, and React will Suspend until the\npromise resolves:\n\n    \n    \n    import {use} from 'react';\n    \n    function Comments({commentsPromise}) {\n    \n    // `use` will suspend until the promise resolves.\n    \n    const comments = use(commentsPromise);\n    \n    return comments.map(comment => <p key={comment.id}>{comment}</p>);\n    \n    }\n    \n    function Page({commentsPromise}) {\n    \n    // When `use` suspends in Comments,\n    \n    // this Suspense boundary will be shown.\n    \n    return (\n    \n    <Suspense fallback={<div>Loading...</div>}>\n    \n    <Comments commentsPromise={commentsPromise} />\n    \n    </Suspense>\n    \n    )\n    \n    }\n\n### Note\n\n#### use does not support promises created in render.\n\nIf you try to pass a promise created in render to use, React will warn:\n\nConsole\n\nA component was suspended by an uncached promise. Creating promises inside a\nClient Component or hook is not yet supported, except via a Suspense-\ncompatible library or framework.\n\nTo fix, you need to pass a promise from a suspense powered library or\nframework that supports caching for promises. In the future we plan to ship\nfeatures to make it easier to cache promises in render.\n\nYou can also read context with use, allowing you to read Context conditionally\nsuch as after early returns:\n\n    \n    \n    import {use} from 'react';\n    \n    import ThemeContext from './ThemeContext'\n    \n    function Heading({children}) {\n    \n    if (children == null) {\n    \n    return null;\n    \n    }\n    \n    // This would not work with useContext\n    \n    // because of the early return.\n    \n    const theme = use(ThemeContext);\n    \n    return (\n    \n    <h1 style={{color: theme.color}}>\n    \n    {children}\n    \n    </h1>\n    \n    );\n    \n    }\n\nThe use API can only be called in render, similar to hooks. Unlike hooks, use\ncan be called conditionally. In the future we plan to support more ways to\nconsume resources in render with use.\n\nFor more information, see the docs for use.\n\n## React Server Components\n\n### Server Components\n\nServer Components are a new option that allows rendering components ahead of\ntime, before bundling, in an environment separate from your client application\nor SSR server. This separate environment is the \u201cserver\u201d in React Server\nComponents. Server Components can run once at build time on your CI server, or\nthey can be run for each request using a web server.\n\nReact 19 includes all of the React Server Components features included from\nthe Canary channel. This means libraries that ship with Server Components can\nnow target React 19 as a peer dependency with a react-server export condition\nfor use in frameworks that support the Full-stack React Architecture.\n\n### Note\n\n#### How do I build support for Server Components?\n\nWhile React Server Components in React 19 are stable and will not break\nbetween major versions, the underlying APIs used to implement a React Server\nComponents bundler or framework do not follow semver and may break between\nminors in React 19.x.\n\nTo support React Server Components as a bundler or framework, we recommend\npinning to a specific React version, or using the Canary release. We will\ncontinue working with bundlers and frameworks to stabilize the APIs used to\nimplement React Server Components in the future.\n\nFor more, see the docs for React Server Components.\n\n### Server Actions\n\nServer Actions allow Client Components to call async functions executed on the\nserver.\n\nWhen a Server Action is defined with the \"use server\" directive, your\nframework will automatically create a reference to the server function, and\npass that reference to the Client Component. When that function is called on\nthe client, React will send a request to the server to execute the function,\nand return the result.\n\n### Note\n\n#### There is no directive for Server Components.\n\nA common misunderstanding is that Server Components are denoted by \"use\nserver\", but there is no directive for Server Components. The \"use server\"\ndirective is used for Server Actions.\n\nFor more info, see the docs for Directives.\n\nServer Actions can be created in Server Components and passed as props to\nClient Components, or they can be imported and used in Client Components.\n\nFor more, see the docs for React Server Actions.\n\n## Improvements in React 19\n\n### ref as a prop\n\nStarting in React 19, you can now access ref as a prop for function\ncomponents:\n\n    \n    \n    function MyInput({placeholder, ref}) {\n    \n    return <input placeholder={placeholder} ref={ref} />\n    \n    }\n    \n    //...\n    \n    <MyInput ref={ref} />\n\nNew function components will no longer need forwardRef, and we will be\npublishing a codemod to automatically update your components to use the new\nref prop. In future versions we will deprecate and remove forwardRef.\n\n### Note\n\nrefs passed to classes are not passed as props since they reference the\ncomponent instance.\n\n### Diffs for hydration errors\n\nWe also improved error reporting for hydration errors in react-dom. For\nexample, instead of logging multiple errors in DEV without any information\nabout the mismatch:\n\nConsole\n\nWarning: Text content did not match. Server: \u201cServer\u201d Client: \u201cClient\u201d at span\nat App\n\nWarning: An error occurred during hydration. The server HTML was replaced with\nclient content in <div>.\n\nWarning: Text content did not match. Server: \u201cServer\u201d Client: \u201cClient\u201d at span\nat App\n\nWarning: An error occurred during hydration. The server HTML was replaced with\nclient content in <div>.\n\nUncaught Error: Text content does not match server-rendered HTML. at\ncheckForUnmatchedText ...\n\nWe now log a single message with a diff of the mismatch:\n\nConsole\n\nUncaught Error: Hydration failed because the server rendered HTML didn\u2019t match\nthe client. As a result this tree will be regenerated on the client. This can\nhappen if an SSR-ed Client Component used: - A server/client branch if (typeof\nwindow !== 'undefined'). - Variable input such as Date.now() or Math.random()\nwhich changes each time it\u2019s called. - Date formatting in a user\u2019s locale\nwhich doesn\u2019t match the server. - External changing data without sending a\nsnapshot of it along with the HTML. - Invalid HTML tag nesting. It can also\nhappen if the client has a browser extension installed which messes with the\nHTML before React loaded. https://react.dev/link/hydration-mismatch <App>\n<span> \\+ Client - Server at throwOnHydrationMismatch ...\n\n### <Context> as a provider\n\nIn React 19, you can render <Context> as a provider instead of\n<Context.Provider>:\n\n    \n    \n    const ThemeContext = createContext('');\n    \n    function App({children}) {\n    \n    return (\n    \n    <ThemeContext value=\"dark\">\n    \n    {children}\n    \n    </ThemeContext>\n    \n    );\n    \n    }\n\nNew Context providers can use <Context> and we will be publishing a codemod to\nconvert existing providers. In future versions we will deprecate\n<Context.Provider>.\n\n### Cleanup functions for refs\n\nWe now support returning a cleanup function from ref callbacks:\n\n    \n    \n    <input\n    \n    ref={(ref) => {\n    \n    // ref created\n    \n    // NEW: return a cleanup function to reset\n    \n    // the ref when element is removed from DOM.\n    \n    return () => {\n    \n    // ref cleanup\n    \n    };\n    \n    }}\n    \n    />\n\nWhen the component unmounts, React will call the cleanup function returned\nfrom the ref callback. This works for DOM refs, refs to class components, and\nuseImperativeHandle.\n\n### Note\n\nPreviously, React would call ref functions with null when unmounting the\ncomponent. If your ref returns a cleanup function, React will now skip this\nstep.\n\nIn future versions, we will deprecate calling refs with null when unmounting\ncomponents.\n\nDue to the introduction of ref cleanup functions, returning anything else from\na ref callback will now be rejected by TypeScript. The fix is usually to stop\nusing implicit returns, for example:\n\n    \n    \n    - <div ref={current => (instance = current)} />\n    \n    + <div ref={current => {instance = current}} />\n\nThe original code returned the instance of the HTMLDivElement and TypeScript\nwouldn\u2019t know if this was supposed to be a cleanup function or if you didn\u2019t\nwant to return a cleanup function.\n\nYou can codemod this pattern with no-implicit-ref-callback-return .\n\n### useDeferredValue initial value\n\nWe\u2019ve added an initialValue option to useDeferredValue:\n\n    \n    \n    function Search({deferredValue}) {\n    \n    // On initial render the value is ''.\n    \n    // Then a re-render is scheduled with the deferredValue.\n    \n    const value = useDeferredValue(deferredValue, '');\n    \n    return (\n    \n    <Results query={value} />\n    \n    );\n    \n    }\n\nWhen initialValue is provided, useDeferredValue will return it as value for\nthe initial render of the component, and schedules a re-render in the\nbackground with the deferredValue returned.\n\nFor more, see useDeferredValue.\n\n### Support for Document Metadata\n\nIn HTML, document metadata tags like <title>, <link>, and <meta> are reserved\nfor placement in the <head> section of the document. In React, the component\nthat decides what metadata is appropriate for the app may be very far from the\nplace where you render the <head> or React does not render the <head> at all.\nIn the past, these elements would need to be inserted manually in an effect,\nor by libraries like react-helmet, and required careful handling when server\nrendering a React application.\n\nIn React 19, we\u2019re adding support for rendering document metadata tags in\ncomponents natively:\n\n    \n    \n    function BlogPost({post}) {\n    \n    return (\n    \n    <article>\n    \n    <h1>{post.title}</h1>\n    \n    <title>{post.title}</title>\n    \n    <meta name=\"author\" content=\"Josh\" />\n    \n    <link rel=\"author\" href=\"https://twitter.com/joshcstory/\" />\n    \n    <meta name=\"keywords\" content={post.keywords} />\n    \n    <p>\n    \n    Eee equals em-see-squared...\n    \n    </p>\n    \n    </article>\n    \n    );\n    \n    }\n\nWhen React renders this component, it will see the <title> <link> and <meta>\ntags, and automatically hoist them to the <head> section of document. By\nsupporting these metadata tags natively, we\u2019re able to ensure they work with\nclient-only apps, streaming SSR, and Server Components.\n\n### Note\n\n#### You may still want a Metadata library\n\nFor simple use cases rendering Document Metadata as tags may be suitable, but\nlibraries can offer more powerful features like overriding generic metadata\nwith specific metadata based on the current route. So these feature make it\neasier for frameworks and libraries like react-helmet to support metadata\ntags, rather than replace them.\n\nFor more info, see the docs for <title>, <link>, and <meta>.\n\n### Support for stylesheets\n\nStylesheets, both externally linked (<link rel=\"stylesheet\" href=\"...\">) and\ninline (<style>...</style>), require careful positioning in the DOM due to\nstyle precedence rules. Building a stylesheet capability that allows for\ncomposability within components is hard, so users often end up either loading\nall of their styles far from the components that may depend on them, or they\nuse a style library which encapsulates this complexity.\n\nIn React 19, we\u2019re addressing this complexity and providing even deeper\nintegration into Concurrent Rendering on the Client and Streaming Rendering on\nthe Server with built in support for stylesheets. If you tell React the\nprecedence of your stylesheet it will manage the insertion order of the\nstylesheet in the DOM and ensure that the stylesheet (if external) is loaded\nbefore revealing content that depends on those style rules.\n\n    \n    \n    function ComponentOne() {\n    \n    return (\n    \n    <Suspense fallback=\"loading...\">\n    \n    <link rel=\"stylesheet\" href=\"foo\" precedence=\"default\" />\n    \n    <link rel=\"stylesheet\" href=\"bar\" precedence=\"high\" />\n    \n    <article class=\"foo-class bar-class\">\n    \n    {...}\n    \n    </article>\n    \n    </Suspense>\n    \n    )\n    \n    }\n    \n    function ComponentTwo() {\n    \n    return (\n    \n    <div>\n    \n    <p>{...}</p>\n    \n    <link rel=\"stylesheet\" href=\"baz\" precedence=\"default\" /> <-- will be inserted between foo & bar\n    \n    </div>\n    \n    )\n    \n    }\n\nDuring Server Side Rendering React will include the stylesheet in the <head>,\nwhich ensures that the browser will not paint until it has loaded. If the\nstylesheet is discovered late after we\u2019ve already started streaming, React\nwill ensure that the stylesheet is inserted into the <head> on the client\nbefore revealing the content of a Suspense boundary that depends on that\nstylesheet.\n\nDuring Client Side Rendering React will wait for newly rendered stylesheets to\nload before committing the render. If you render this component from multiple\nplaces within your application React will only include the stylesheet once in\nthe document:\n\n    \n    \n    function App() {\n    \n    return <>\n    \n    <ComponentOne />\n    \n    ...\n    \n    <ComponentOne /> // won't lead to a duplicate stylesheet link in the DOM\n    \n    </>\n    \n    }\n\nFor users accustomed to loading stylesheets manually this is an opportunity to\nlocate those stylesheets alongside the components that depend on them allowing\nfor better local reasoning and an easier time ensuring you only load the\nstylesheets that you actually depend on.\n\nStyle libraries and style integrations with bundlers can also adopt this new\ncapability so even if you don\u2019t directly render your own stylesheets, you can\nstill benefit as your tools are upgraded to use this feature.\n\nFor more details, read the docs for <link> and <style>.\n\n### Support for async scripts\n\nIn HTML normal scripts (<script src=\"...\">) and deferred scripts (<script\ndefer=\"\" src=\"...\">) load in document order which makes rendering these kinds\nof scripts deep within your component tree challenging. Async scripts (<script\nasync=\"\" src=\"...\">) however will load in arbitrary order.\n\nIn React 19 we\u2019ve included better support for async scripts by allowing you to\nrender them anywhere in your component tree, inside the components that\nactually depend on the script, without having to manage relocating and\ndeduplicating script instances.\n\n    \n    \n    function MyComponent() {\n    \n    return (\n    \n    <div>\n    \n    <script async={true} src=\"...\" />\n    \n    Hello World\n    \n    </div>\n    \n    )\n    \n    }\n    \n    function App() {\n    \n    <html>\n    \n    <body>\n    \n    <MyComponent>\n    \n    ...\n    \n    <MyComponent> // won't lead to duplicate script in the DOM\n    \n    </body>\n    \n    </html>\n    \n    }\n\nIn all rendering environments, async scripts will be deduplicated so that\nReact will only load and execute the script once even if it is rendered by\nmultiple different components.\n\nIn Server Side Rendering, async scripts will be included in the <head> and\nprioritized behind more critical resources that block paint such as\nstylesheets, fonts, and image preloads.\n\nFor more details, read the docs for <script>.\n\n### Support for preloading resources\n\nDuring initial document load and on client side updates, telling the Browser\nabout resources that it will likely need to load as early as possible can have\na dramatic effect on page performance.\n\nReact 19 includes a number of new APIs for loading and preloading Browser\nresources to make it as easy as possible to build great experiences that\naren\u2019t held back by inefficient resource loading.\n\n    \n    \n    import { prefetchDNS, preconnect, preload, preinit } from 'react-dom'\n    \n    function MyComponent() {\n    \n    preinit('https://.../path/to/some/script.js', {as: 'script' }) // loads and executes this script eagerly\n    \n    preload('https://.../path/to/font.woff', { as: 'font' }) // preloads this font\n    \n    preload('https://.../path/to/stylesheet.css', { as: 'style' }) // preloads this stylesheet\n    \n    prefetchDNS('https://...') // when you may not actually request anything from this host\n    \n    preconnect('https://...') // when you will request something but aren't sure what\n    \n    }\n    \n    \n    <!-- the above would result in the following DOM/HTML -->\n    \n    <html>\n    \n    <head>\n    \n    <!-- links/scripts are prioritized by their utility to early loading, not call order -->\n    \n    <link rel=\"prefetch-dns\" href=\"https://...\">\n    \n    <link rel=\"preconnect\" href=\"https://...\">\n    \n    <link rel=\"preload\" as=\"font\" href=\"https://.../path/to/font.woff\">\n    \n    <link rel=\"preload\" as=\"style\" href=\"https://.../path/to/stylesheet.css\">\n    \n    <script async=\"\" src=\"https://.../path/to/some/script.js\"></script>\n    \n    </head>\n    \n    <body>\n    \n    ...\n    \n    </body>\n    \n    </html>\n\nThese APIs can be used to optimize initial page loads by moving discovery of\nadditional resources like fonts out of stylesheet loading. They can also make\nclient updates faster by prefetching a list of resources used by an\nanticipated navigation and then eagerly preloading those resources on click or\neven on hover.\n\nFor more details see Resource Preloading APIs.\n\n### Compatibility with third-party scripts and extensions\n\nWe\u2019ve improved hydration to account for third-party scripts and browser\nextensions.\n\nWhen hydrating, if an element that renders on the client doesn\u2019t match the\nelement found in the HTML from the server, React will force a client re-render\nto fix up the content. Previously, if an element was inserted by third-party\nscripts or browser extensions, it would trigger a mismatch error and client\nrender.\n\nIn React 19, unexpected tags in the <head> and <body> will be skipped over,\navoiding the mismatch errors. If React needs to re-render the entire document\ndue to an unrelated hydration mismatch, it will leave in place stylesheets\ninserted by third-party scripts and browser extensions.\n\n### Better error reporting\n\nWe improved error handling in React 19 to remove duplication and provide\noptions for handling caught and uncaught errors. For example, when there\u2019s an\nerror in render caught by an Error Boundary, previously React would throw the\nerror twice (once for the original error, then again after failing to\nautomatically recover), and then call console.error with info about where the\nerror occurred.\n\nThis resulted in three errors for every caught error:\n\nConsole\n\nUncaught Error: hit at Throws at renderWithHooks ...\n\nUncaught Error: hit <\\-- Duplicate at Throws at renderWithHooks ...\n\nThe above error occurred in the Throws component: at Throws at ErrorBoundary\nat App React will try to recreate this component tree from scratch using the\nerror boundary you provided, ErrorBoundary.\n\nIn React 19, we log a single error with all the error information included:\n\nConsole\n\nError: hit at Throws at renderWithHooks ... The above error occurred in the\nThrows component: at Throws at ErrorBoundary at App React will try to recreate\nthis component tree from scratch using the error boundary you provided,\nErrorBoundary. at ErrorBoundary at App\n\nAdditionally, we\u2019ve added two new root options to complement\nonRecoverableError:\n\n  * onCaughtError: called when React catches an error in an Error Boundary.\n  * onUncaughtError: called when an error is thrown and not caught by an Error Boundary.\n  * onRecoverableError: called when an error is thrown and automatically recovered.\n\nFor more info and examples, see the docs for createRoot and hydrateRoot.\n\n### Support for Custom Elements\n\nReact 19 adds full support for custom elements and passes all tests on Custom\nElements Everywhere.\n\nIn past versions, using Custom Elements in React has been difficult because\nReact treated unrecognized props as attributes rather than properties. In\nReact 19, we\u2019ve added support for properties that works on the client and\nduring SSR with the following strategy:\n\n  * Server Side Rendering: props passed to a custom element will render as attributes if their type is a primitive value like string, number, or the value is true. Props with non-primitive types like object, symbol, function, or value false will be omitted.\n  * Client Side Rendering: props that match a property on the Custom Element instance will be assigned as properties, otherwise they will be assigned as attributes.\n\nThanks to Joey Arhar for driving the design and implementation of Custom\nElement support in React.\n\n#### How to upgrade\n\nSee the React 19 Upgrade Guide for step-by-step instructions and a full list\nof breaking and notable changes.\n\nPreviousBlog\n\nNextReact 19 Beta Upgrade Guide\n\nHow do you like these docs?\n\nTake our survey!\n\n\u00a92024\n\nLearn React\n\nQuick Start\n\nInstallation\n\nDescribing the UI\n\nAdding Interactivity\n\nManaging State\n\nEscape Hatches\n\nAPI Reference\n\nReact APIs\n\nReact DOM APIs\n\nCommunity\n\nCode of Conduct\n\nMeet the Team\n\nDocs Contributors\n\nAcknowledgements\n\nMore\n\nBlog\n\nReact Native\n\nPrivacy\n\nTerms\n\n", "frontpage": false}
{"aid": "40166131", "title": "Show HN: I made og image generator and embeddable dynamic for website using SDK", "url": "https://ogcool.vercel.app/", "domain": "ogcool.vercel.app", "votes": 1, "user": "anduc", "posted_at": "2024-04-26 05:12:10", "comments": 0, "source_title": "A Scientist Says He Has the Evidence That We Live in a Simulation", "source_text": "A Scientist Says He Has the Evidence That We Live in a Simulation\n\nSkip to Content\n\n# A Scientist Says He Has the Evidence That We Live in a Simulation\n\nThe \u201cSecond Law of Infodynamics\u201d could prove it.\n\nBy Darren OrfPublished: Apr 24, 2024 8:00 AM EST\n\nAndriy Onufriyenko//Getty Images\n\nGear-obsessed editors choose every product we review. We may earn commission\nif you buy from a link. Why Trust Us?\n\n  * Many philosophers and scientists have pondered if we live in a simulated universe, and University of Portsmouth scientist Melvin Vopson believes he has evidence.\n  * Using his previously formulated Second Law of Infodynamics, Vopson claims that the decrease of entropy in information systems over time could prove that the universe has a built-in \u201cdata optimization and compression,\u201d which speaks to its digital nature.\n  * While these claims warrant investigation, they\u2019re far from a discovery themselves, and would likely need rigorous proof for the scientific community at large to seriously consider this theory.\n\nIn the 1999 film The Matrix, Thomas Anderson (a.k.a. Neo) discovers a truth to\nend all truths\u2014the universe is a simulation. While this premise provides\nfantastic sci-fi fodder (and explains how Neo can learn kung-fu in about five\nseconds), the idea isn\u2019t quite as carefully relegated to the fiction section\nas one might expect.\n\nUniversity of Portsmouth scientist Melvin Vopson, who studies the possibility\nthat the universe might indeed be a digital facsimile, leans into the\ncinematic comparison. In an article published on website The Conversation this\npast October, Vopson invoked the Wachowskis\u2019 sci-fi masterpiece, and around\nthe same time, he published a book on the subject\u2014Reality Reloaded, a subtle\nhat tip to the title of the less successful Matrix sequel. While he is just\none among many who\u2019ve contemplated the idea, Vopson claims to have one thing\nthat those before him lacked: evidence.\n\n###### Related Story\n\n  * Scientist Reveals How to Escape Our Simulation\n\n\u201cIn physics, there are laws that govern everything that happens in the\nuniverse, for example how objects move, how energy flows, and so on.\nEverything is based on the laws of physics,\u201d Vopson said back in 2022. \u201cOne of\nthe most powerful laws is the second law of thermodynamics, which establishes\nthat entropy\u2014a measure of disorder in an isolated system \u2013 can only increase\nor stay the same, but it will never decrease.\u201d\n\nBased on this famous law, Vopson similarly expected that entropy in\ninformation systems\u2014which his previous research defined as a \u201cfifth state of\nmatter\u201d\u2014should similarly increase over time. But it doesn\u2019t. Instead, it\nremains constant, or even decreases to a minimum value at equilibrium. This is\nin direct contrast to the second law of thermodynamics, which inspired Vopson\nto adopt the Second Law of Information Dynamics (or Infodynamics).\n\n\u201cWe know the universe is expanding without the loss or gain of heat, which\nrequires the total entropy of the universe to be constant,\u201d Vopson wrote in\nThe Conversation. \u201cHowever we also know from thermodynamics that entropy is\nalways rising. I argue this shows that there must be another\nentropy\u2014information entropy\u2014to balance the increase.\u201d\n\nVopson argues that this law plays a role in atomic physics (electron\narrangement), cosmology (see above), and biological systems. This last one is\nwhere Vopson makes a big claim: contrary to Charles Darwin\u2019s idea that\nmutations occur randomly, mutations actually occur so that information entropy\nis minimized. Vopson analyzed the constantly-mutating SARS-CoV-2 (a.k.a.\nCOVID-19) virus, and his paper on that investigation\u2014published this past\nOctober in the journal AIP Advances\u2014shows a \u201ca unique correlation between the\ninformation and the dynamics of the genetic mutations.\u201d\n\n###### Related Story\n\n  * Mathematician Trying to Hack Earth's Simulation\n\nWhat this all adds up to, in Vospon\u2019s estimation, is that the Second Law of\nInfodynamics could also be used to prove that we live in a simulation.\n\n\u201cA super complex universe like ours, if it were a simulation, would require a\nbuilt-in data optimization and compression in order to reduce the\ncomputational power and the data storage requirements to run the simulation,\u201d\nVopson wrote in The Conversation. \u201cThis is exactly what we are observing all\naround us, including in digital data, biological systems, mathematical\nsymmetries and the entire universe.\u201d\n\nAll of these claims require significant further testing and verification\nbefore even being considered plausible, and as IFLScience notes, there are as\nmany research papers refuting our digital existence as there are promoting its\nscientific inevitability. It\u2019s possible that Vopson\u2019s Second Law of\nInfodynamics could lead to some interesting discoveries, but the question\nfirst pondered by Plato remains unanswered.\n\nDarren Orf\n\nDarren lives in Portland, has a cat, and writes/edits about sci-fi and how our\nworld works. You can find his previous stuff at Gizmodo and Paste if you look\nhard enough.\n\n###### Watch Next\n\nAdvertisement - Continue Reading Below\n\n## Our Planet\n\nCovering Fields in Concrete Could be a Good Thing\n\nThe Overlooked, Powerful Role of Inorganic Carbon\n\nPyrite Isn\u2019t Looking So Foolish in the Lithium Age\n\nCloud Brightening May Be Our White Knight\n\nAdvertisement - Continue Reading Below\n\nA Section of the San Andreas Fault Is Waking Up\n\nClimate Change Can Wreck a Tree\u2019s Circadian Rhythm\n\nWhy the Northeast Earthquake Was So Shocking\n\nAncient Chunks of Earth Were Hiding in Crystals\n\nHow the Ross Ice Shelf Lurches At Least Once a Day\n\nGlobal Warming Is Slowing Earth\u2019s Rotation\n\nWhat To Know About the 2024 U.S. Solar Eclipse\n\nThe Polar Vortex Is Spinning Backwards\n\nAdvertisement - Continue Reading Below\n\nA Part of Hearst Digital Media\n\nWe may earn commission from links on this page, but we only recommend products\nwe back.\n\n\u00a92024 Hearst Magazine Media, Inc. All Rights Reserved.\n\nPrivacy NoticeCA Notice at CollectionYour CA Privacy Rights/Shine the LightDAA\nIndustry Opt OutTerms of UseSite Map\n\nCookie Choices\n\nHearst and third parties use cookies and similar technologies (\u201cCookies\u201d) on\nthis site. Some Cookies are necessary to make this site and our content\navailable to you; these Cookies fire automatically and are not subject to your\npreference settings. If you click \u201cAccept\u201d, you consent to Hearst and our\nadvertisers, ad-tech providers, including 140 IAB TCF Framework vendors, and\nothers (collectively \u201cVendors\u201d) using additional Cookies and processing your\npersonal data (such as unique identifiers) and other information stored and/or\naccessed from your device or browser for the purposes described below. Click\non \u201cManage Settings\u201d for more information about these purposes and where we\nprocess your personal data based on legitimate interests. See also our Privacy\nNotice. If you do not consent to these Cookies and the processing of your\npersonal data for these purposes, click \u201cDecline\u201d.\n\nYou can adjust your Cookies preferences, object to legitimate interests, or\nrevoke your consent at any time by clicking on the \u201cCookies Choices\u201d link at\nthe bottom of this site. Your preferences will apply to this site only and are\nbrowser and device-specific.\n\n### We and our Vendors process data obtained through the use of Cookies for\nthe following purposes:\n\nActively scan device characteristics for identification. Store and/or access\ninformation on a device. Use limited data to select content. Create profiles\nto personalise content. Use profiles to select personalised advertising.\nCreate profiles for personalised advertising. Use profiles to select\npersonalised content. Measure advertising performance. Understand audiences\nthrough statistics or combinations of data from different sources. Develop and\nimprove services. Use limited data to select advertising. Measure content\nperformance.\n\n", "frontpage": false}
