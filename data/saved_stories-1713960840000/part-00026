{"aid": "40141037", "title": "The Reasons I Prefer Passing Struct Pointers Around in Go", "url": "https://preslav.me/2024/04/23/two-reasons-to-prefer-struct-pointers-in-golang/", "domain": "preslav.me", "votes": 1, "user": "ingve", "posted_at": "2024-04-24 05:47:40", "comments": 0, "source_title": "The Two Reasons I Prefer Passing Struct Pointers Around", "source_text": "The Two Reasons I Prefer Passing Struct Pointers Around \u00b7 Preslav Rachev\n\n\u2193Skip to main content\n\nPreslav Rachev\n\n  1. Preslav Rachev /Going with Go /\n  2. My Writings /Going with Go /\n  3. The Two Reasons I Prefer Passing Struct Pointers Around /Going with Go /\n\n# The Two Reasons I Prefer Passing Struct Pointers Around\n\n23 April 2024\u00b79 mins\n\nSpoiler: I am not talking about CPU performance or memory. This is a long post\nand a re-evaluation of my thoughts about struct pointers from last year.\nBuckle up!\n\nIdentical gophers pointing at one another. Source: Midjourney\n\nWhen it comes to struct values in Go, one of the people\u2019s common points of\ntension is whether to pass those around via pointers or just copy the value.\nBecause pointers come with some overhead, the natural reaction is to avoid\nthem at all costs and resort to passing struct value copies wherever possible.\n\nI am here to challenge that thought a little. Too much of the discourse around\nwhether to use a certain Go construct becomes deeply technical too quickly.\nThis may be justified when developing low-level system components with zero\nfriction or massively scalable Web services.\n\nNeither is the case for most people. Suffice it to say, the chances of you\ngiving up on your idea or your business going bankrupt are way higher than you\never need to worry about the performance of your Go app. When building regular\nsoftware applications, I think it is far more important to focus on growing a\ncodebase that is easy to build upon and maintain by multiple people over time.\nTherefore, rather than performance, the two reasons I would usually choose\nusing pointer structs are identity and consistency.\n\n## Consistency #\n\nOne of my first clashes with reality as a software engineer was when I came to\nterms with the fact that real software engineering has much more to do with\nmaking the code easy to follow and modify than simply making the computer\nhappy. Every feature a language offers comes with a cognitive burden and has\ntrade-offs. Even in the case of a language as simple as Go, there are many\nplaces where a programming decision must be justified:\n\n  * When and why do we use an if-else or a switch-case?\n  * When do we create a struct method vs a package-level function?\n  * When and why do we choose a channel over a WaitGroup and some Mutex.\n  * When is it OK to panic?\n  * When and why do we use an interface over referring to the type directly?\n  * When and why do we pass a struct by pointer rather than copy the struct\u2019s value?\n\nThe naive answer to the last question would be to decide based on the concrete\nsituation. Is your struct small, copy its values around. Do you need mutable\naccess to one of its values, use a pointer? Has your struct grown too much,\nuse a pointer. Wait, what do you mean by you copied its value around in a\nthousand places and now need to refactor them all?\n\nI hope that with this simple anecdote, I was able to make my point that the\ncurrent situation is not something set in stone but changes all the time.\nSometimes, multiple times a day even. At some point, it may become\nprohibitively expensive to go with the flow.\n\nFor my projects, I would rather go with semantics. I look at what a struct\ntype is supposed to represent and decide up-front if I am going to use pointer\nor value-copy semantic for it. Once I decide on that, the decision almost\nalways sticks for the duration of the project.\n\nTo draw the line between pointer and value-copy semantics, I have chosen\ncriteria partially inspired by domain-driven design (DDD) and partially by\nthis Ardan Labs post. It all has to do with the type\u2019s identity.\n\nUsing Pointers In Go\n\nOur Blog is a great source of insights about Go, also referred as \"golang\".\nOur main contributor Bill Kennedy is a renowned Go Trainer, consultant, and\nauthor.\n\nhttps://www.ardanlabs.com |\n\n## Identity #\n\nDDD distinguishes entities from value objects. The simplest possible way to\nexplain the difference between the two is to ask myself the question:\n\n> If all the attributes of two values of the same struct type are equal, are\n> the two values identical?\n\nThe same question, modified slightly.\n\n> If I change one of the attributes\u2019 values, does it break the identity of the\n> struct value?\n\nAnd last but not least, this one:\n\n> Is the zero value of that struct type useful?\n\n### Value Objects #\n\nIf the answer to all questions is Yes, you have a classical value object and\ncan freely use value-copy semantics. Why? Well, value objects are meant to be\nimmutable. If you change one of the attributes\u2019 values, you are essentially\ncreating an entirely new value. The best example from the Go standard library\nis time.Time. The time.Time struct represents an instant in time with\nnanosecond precision. Essentially, a time.Time value is a wrapper over two\nuint64s. If you change any of those two values, we get a completely different\ntime.Time value. In other words, its identity is a product of its attributes\u2019\nequality. Also, an empty time.Time is its logical zero value:\n\n    \n    \n    var t, tt time.Time fmt.Println(t == tt) // true fmt.Println(t.IsZero()) // true\n\nCan you use time.Time using a pointer semantic? Of course, you can - a pointer\nis simply a reference to a known value in memory. You can address any value,\nregardless of its type. But in this case, you will get no real benefit, which\nis why most of the time, time instances will be passed around as value copies.\nSomeone might object that the use of *time.Time might be useful in situations\nwhere the value may not exist at all (optionality). A good example is a struct\nwith a DeletedAt attribute that only gets set, if the data has been deleted\n(e.g., from a database):\n\n    \n    \n    type DBRow { // Other attrs .. DeletedAt *time.Time }\n\nI\u2019d argue that this can be solved one level above, by introducing a separate\nstruct type where DeletedAt is always valid:\n\n    \n    \n    type DBRow { // Other attrs .. } type DeletedDBRow { DBRow // nicely brings in all the attributes of the row DeletedAt time.Time // we assume that the value is always valid }\n\n### Entities #\n\nNaturally, this brings us to the second type, namely entities. Using the above\nthree questions as criteria, we can define any struct type as an entity if it\neither has no reasonable zero value or the change of any of its attributes\ndoes not imply a new value. In the case of time.Time, an instance of time\n(e.g., Jan 1st, 2024) is always the same, no matter how many identical\ntime.Time copies of it we might have. The identity of a time instance is\ninferred from its internal state.\n\nWith more complex types, we may not be in a position to say that because even\nif they may have the same internal state, those are different copies that will\nevolve differently over time, and that will bring undesired consequences.\nThink of a file reference or a database connection. If you have more than one\ncopy referring to the same resource, you run the risk of reading an mutating a\nfile from two different locations, or not closing a database transaction\nproperly (or worse, exhausting your maximum available DB connections), for\nexample.\n\nIf we cannot reasonably determine the identity of an object, we need a form of\nreference to it that says, \u201cregardless of how many copies of this reference we\nhave, they all point to the same source.\u201d This role is played perfectly by\npointers.\n\nLet\u2019s illustrate that with a less obvious custom-type example. Suppose we are\nbuilding a project management system, and Project along with Person are two of\nthe core data models in it. A Project must have a title, and an associated\nOwner of type Person.\n\nFor a second let\u2019s use the value-copy semantic when working with Project. A\nfew interesting questions will pop up right away. First, what exactly is the\nzero value of a Project - is a project without an owner, and with an empty\ntitle a useful zero value? What about a project that has an owner but no\ntitle? Or, the other way around? Perhaps, a generic nil value is the better\noption here?\n\nEven if we disagree on that, how common is it that we may end up having\nmultiple projects with identical titles owned by the same person? It is\ndefinitely legal and possible. If we follow the value-copy semantic, how can\nwe be sure that Project A is different from Project B if they have the same\nowner and the same title?\n\n    \n    \n    me := Person{Name: \"John\"} a := Project{Title: \"ToDos\", Owner: me} b := Project{Title: \"ToDos\", Owner: me} fmt.Println(a == b) // true, which is logically wrong\n\nOne would say that this is what IDs are for. Fine, we would add unique IDs to\neach, so we can distinguish on the basis of those being different:\n\n    \n    \n    me := Person{Name: \"John\"} a := Project{ID: 1, Title: \"ToDos\", Owner: me} b := Project{ID: 2, Title: \"ToDos\", Owner: me} fmt.Println(a == b) // false\n\nBut then again, what if those IDs are both zeroes, or someone forgets to set\nthem? Then, the two values will be equal again, which is logically wrong. But\nthere is something else, too. If we now take project A, pass a copy of it to\nthe function, and modify it inside the function, we\u2019ll now have two copies\nreferring to the same ID but with different titles. According to the\npostulates above, the only reasonable way to identify a project\u2019s identity is\nto use pointer semantics for that type. The same applies for the type Person,\nbtw.\n\n    \n    \n    me := Person{Name: \"John\"} a := Project{Title: \"ToDos\", Owner: &me} b := Project{Title: \"ToDos\", Owner: &me} fmt.Println(&a == &b) // false, as it should be\n\n## Wrapping Things Up #\n\nIf you\u2019ve made it this far, well done! I appreciate your patience as a reader.\nI hope my explanations have been clear enough to show you the value of pointer\nsemantics. In reality pointers are far more versatile than copying values\naround. In fact, I am not afraid to go with pointer struct types in most\nsituations, resorting to value copies where it really makes sense, and I can\nguarantee that I won\u2019t have to pay the price of changing the semantic at a\nlater point. Pointers are not bad, they don\u2019t bite, they are not a code smell,\nand really, they are a normal part of programming. It is far more important to\nhave a consistent codebase where every types is referred to using sound\nreasoning, than optimizing for the case that may (and will likely) never\nhappen.\n\nHave something to say? Join the discussion below \ud83d\udc47\n\nWant to explore instead? Fly with the time capsule \ud83d\udef8\n\n## You may also find these interesting\n\n##\n\nUser or *User - Do We Need Struct Pointers Everywhere?\n\n6 February 2023\u00b78 mins\n\nA bit of up-front thinking can help make our Go code cleaner and more\nperformant.\n\nRead article\n\n##\n\nInterfaces Are Not Meant for That\n\n15 December 2023\u00b77 mins\n\nIt\u2019s time to ask ourselves how much abstraction in our Go code really makes\nsense.\n\nRead article\n\n##\n\nAn Open Plea to the Quarkus Team\n\n8 April 2024\u00b72 mins\n\nRethink the way the Java community sees the framework.\n\nRead article\n\n##\n\nWhy should I use Go over Rust, Java, or Python?\n\n23 December 2023\u00b72 mins\n\nGo is an 80%-language. That\u2019s why.\n\nRead article\n\n##\n\nPython is Easy. Go is Simple. Simple != Easy.\n\n27 November 2023\u00b77 mins\n\nPython and Go have distinct qualities that can complement each other.\n\nRead article\n\nAuthor\n\nPreslav Rachev\n\nI am a software engineer with a decade-long experience developing software in\nPython, Go, and Java.\n\n\u2190 \u2192 An Open Plea to the Quarkus Team 8 April 2024\n\n\u2191\n\n\u00a9 2023 Preslav Rachev\n\nPowered by Hugo & Congo\n\n## Thank you for stopping by \ud83e\udd17\n\nI hope my writing has been helpful to you and you will likely come back again.\n\nYou may not remember this blog, so please spend a second of your time and\nbookmark this page.\n\nIf you like to get my latest blog posts, you can also consider subscribing\n(totally free, and I support both RSS and email. No spam, I promise.) You can\nalso follow me on Mastodon or get in touch via email.\n\nSee you soon! \ud83d\udc4b\n\n", "frontpage": false}
