{"aid": "40080724", "title": "Prisma and the Naivety of Crowds", "url": "http://www.stephen-cresswell.com/2024/04/17/prisma-and-the-naivety-of-crowds.html", "domain": "stephen-cresswell.com", "votes": 1, "user": "scresswell", "posted_at": "2024-04-18 21:06:44", "comments": 0, "source_title": "Prisma and the Naivety of Crowds", "source_text": "Prisma and the Naivety of Crowds | blog\n\nblog\n\n# Prisma and the Naivety of Crowds\n\nApr 17, 2024\n\nA friend recently drew my attention to a dangerous issue with Prisma. For the\nunfamiliar, Prisma is a popular Object Relational Mapper (ORM) for Node.js\nwith excellent TypeScript support and great documentation. The issue, which\nthe developers say is by design, is that Prisma will delete all rows in a\ntable if you specify a where clause attribute with an undefined value, e.g.\n\n    \n    \n    await prisma.theme.deleteMany({ where: { shop: undefined, } });\n\nGiven the likelihood of accidentally undefined values in Node.js applications,\neven with the compile time protection of TypeScript, the potential consequence\nof this design decision is terrifying. The issue was reported in July 2023 and\nPrisma\u2019s developers agree the behaviour is dangerous, but have no plans to\naddress it. Prisma\u2019s updateMany suffers from the same problem.\n\nThis is not the first time a Prisma design decision has surprised me. When I\nfirst evaluated Prisma I was surprised that transactions appeared to be an\nafterthought. Instead of beginning a transaction, executing some code, and\ncommitting or rolling back the transaction, Prisma took a batch query approach\nlike the Redis MULTI command. Batch queries have the major limitation that all\nstatements must be determined in advance and cannot be dynamically constructed\nor conditionally performed based on the result of a previous query. Prisma\nadded a transaction API by way of a preview feature in v2.29.0, which has been\ngenerally available since v4.7.0 but I still find it bewildering that\ntransactions were not better supported from the start. Prisma also lacks\nsupport for transparent transaction management, which other ORMs achieve\nthrough AsyncLocalStorage and cls. Based on this discussion I am unsure if the\nPrisma\u2019s developers understand the concept of transparent transaction\nmanagement and its benefits.\n\nThen there was this damning article posted in April 2023 by Mehul Mohan of\nCodedamn, highlighting Prisma\u2019s poor performance, largely but not exclusively\ndue to its reliance on application-level joins. Prisma added a preview feature\nin February 2024 allowing the choice of application-level or database-level\njoins, but once again, I find the original design decision to eschew database-\nlevel joins in favour of application-level ones bizarre.\n\nIn summary, Prisma has a history of surprising, limiting and sometimes\ndangerous design decisions that make it unfit for typical enterprise\napplications. So why is it popular? I can only imagine that Prisma\u2019s excellent\nTypeScript support, a pleasing website and use of Rust, enamours it to\nsoftware engineers who care about those things, but\n\n(i) don\u2019t use Prisma in typical enterprise applications, or (ii) don\u2019t\nunderstand what features are most important for such applications, or (iii)\ndon\u2019t check whether Prisma adequately supports such features\n\nPrisma\u2019s popularity, combined with its claims of simplicity and a great\ndeveloper experience will ensure those in the second and third categories keep\nchoosing it, putting them and their customers at risk of massive data loss.\nThe problem is not restricted to Prisma. While we in the software industry\ncontinue to trust the misguided wisdom of uninformed crowds, the software we\nproduce will continue to depend on libraries that are unfit for purpose.\n\nWhen the consequence of a poor choice is severe, more rigour is called for.\nInstead of selecting a library by popularism alone, I recommend identifying\nkey screening and ranking criteria by reviewing the documentation of\nmainstream candidates. Screening criteria are essential features, which for an\nORM might include transactions and adequate performance. If a candidate fails\na single screening criteria it must be rejected immediately. In contrast,\nranking criteria is desirable, but not essential, and helps you find the best\nchoice from a shortlist of screened candidates. An example might be\nTypeScript, support for which could be excellent, good, fair, poor or\nterrible.\n\nScreening is usually simpler than ranking, and since it removes candidates,\nshould be done first. Ranking is easier when using a consistent rating scale\nand when the criteria are of equal importance. If the criteria are not equally\nimportant, you can weight them, but this increases complexity. Instead, I\nprefer to start with the most important ranking criteria, and only consider\nless important ones in the event of a tie. Criteria may be both screening and\nranking, since you may exclude candidates that don\u2019t meet a minimum threshold,\nand prefer those that excel.\n\n### Screening Example\n\nCandidate A| Candidate B| Candidate C  \n---|---|---  \nCRUD Operations| \u2713| \u2713| \u2713  \nDocumentation| \u2713| \u2713| \u2713  \nMaintained| \u2713| \u2713| \u2713  \nPostgreSQL| \u2713| \u2713| \u2713  \nShowstoppers| \u2717| \u2713| \u2713  \nTest Coverage| \u2713| \u2713  \nTransactions| \u2713| \u2713  \nPerformance| \u2713| \u2713  \n  \nCandidate A was rejected due to showstopping issues. Screening criteria that\nis hard to measure (e.g. Performance) should be evaluated last to minimise the\ncandidates it needs to be done for.\n\n### Ranking Example\n\nCandidate B| Candidate C  \n---|---  \nModel Definition| Excellent| Excellent  \nSchema Definition| Excellent| Excellent  \nCRUD Operations| Good| Excellent  \nRaw Query Support| Fair| Good  \nTransactions| Good| Good  \nMaintenance| Excellent| Fair  \nTypeScript Support| Excellent| Poor  \n  \nCandidate B has far better TypeScript support and is significantly better\nmaintained, so assuming the criteria are of equal importance, is the best\nchoice. When the decision is closer, extend the table to include less\nimportant criteria.\n\nFor my screening criteria, I always include a review of a candidate\u2019s GitHub\nissues (both open and closed), paying particular attention to any that cause\nsurprise. Finally, I suggest actively looking for articles that are\nobjectively critical of the library, as well as those that advocate for it. If\nduring your evaluation, you encounter bizarre or reckless design decisions,\nsuch as an ORM that doesn\u2019t support transactions, struggles with production\nloads, or worse, has a laissez-faire attitude to protecting data, then I\nrecommend rejecting that candidate and looking elsewhere.\n\n## blog\n\n  * Stephen Cresswell\n\n", "frontpage": false}
