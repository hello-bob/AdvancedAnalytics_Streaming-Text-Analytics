{"aid": "40049131", "title": "Writing Your Own Sudo", "url": "https://rtpg.co/2022/02/13/your-own-sudo.html", "domain": "rtpg.co", "votes": 1, "user": "eric_khun", "posted_at": "2024-04-16 07:07:55", "comments": 0, "source_title": "Writing Your Own Sudo", "source_text": "Writing Your Own Sudo\n\n  * Home\n  * About\n  * Subscribe (RSS/Email)\n\n# Writing Your Own Sudo\n\n2022-02-13\n\nWhat does sudo do? Most people have a basic understanding: it lets you\ntemporarily run a command as root (or some other user, based on the options\npassed in).\n\nPeople will discuss sudo as nice from a security perspective relative to\nlogging in as root, because you are scoping your usage of the root account to\nwhat really needs it. And with the default sudo setup you aren't handing out\nthe root password, but instead giving permission to certain users to use sudo\nfor privilege escalation.\n\nOne might think that sudo is actually some binary deeply integrated into the\nkernel, relying on a special purpose-built system call to achieve its\nfunctionality. After all, it lets you use root without even providing the\npassword for that account! But thanks to one bit inside file permissions, sudo\ncan exist without any of this.\n\nLet's write our own version of sudo to prove this point. First, let's make a\nprogram that serves as our test bed:\n\n    \n    \n    #!/usr/bin/env python3 # say_hello.py import sys import os import pwd user_id = os.getuid() # usernames exist in mappings to the password file username = pwd.getpwuid(user_id).pw_name print(f\"Called with: {sys.argv}\") print(f\"Hello, {username}\")\n\n(aside: file permissions store the user ID, not the username. So taking your\nhard drive of files and sticking it into another machine might leave you with\na lot of files inaccessible to \"your user\" on that machine!)\n\nLet's sanity check that this program at least does what we think it does:\n\n    \n    \n    >>> chmod +x say_hello.py >>> ./say_hello.py Called with: ['./say_hello.py'] Hello, rtpg >>> sudo ./say_hello.py Called with: ['./say_hello.py'] Hello, root\n\nThis looks to be working correctly!\n\nNow we will work on building our own sudo variant.\n\nLet's first just make a program that will run whatever is provided to it,\nusing exec:\n\n    \n    \n    #!/usr/bin/env python3 # mysudo.py import os import sys if sys.argv[0].split(\"/\")[-1] != \"mysudo.py\": raise ValueError(\"This program must be called directly\") if len(sys.argv) < 2: raise ValueError(\"Missing progam to call\") # call sys.argv[1], and pass the arguments to the program # (you need to pass in argv[1] in the argument list # as well, it is not prepended) os.execvp(sys.argv[1], sys.argv[1:])\n\nthis is a good enough approximation of what we want.\n\nexecvp is part of the exec family of Unix functions. Unlike spinning up a new\nsubprocess or starting a thread, exec lets you replace the existing program\nrunning in a process with a new one.\n\nIn practice what that means is that you will run your indicated program but\nmaintain the existing process ID, user ID, etc. There are a loooooot of\nasterisks involved here. (Check out man execve for a lot of details). The\ngeneral idea is that the program you were running is replaced with another\none, and that , but with many of the OS-level properties of the process\n(namely, permissions) retained. Except for the properties that don't stick\naround, of course!\n\nRunning this on our test program will give:\n\n    \n    \n    >>> ./mysudo.py ./say_hello.py foo bar Called with: ['./say_hello.py', 'foo', 'bar'] Hello, rtpg\n\nNow for the part we actually want to do: privilege escalation.\n\nWe had os.getuid. There is os.setuid. But of course just adding os.setuid(0)\ngets us:\n\n    \n    \n    Traceback (most recent call last): File \".../mysudo.py\", line 14, in <module> os.setuid(0) PermissionError: [Errno 1] Operation not permitted\n\nIt feels obvious that you can't just give yourself more privileges. But in\nthat case... what would setuid even exist for?\n\nThere are three important user IDs:\n\n  * the real user ID\n  * the effective user ID\n  * the saved set-user-ID\n\nThe real user ID is meant to track the \"real\" user, in essence who is logged\ninto the machine.\n\nThe effective user ID is used to determine file permissions. This is what\nallows a process run by root to run \"as another user\" (for example when using\nprocess coordination programs like Supervisor), and for files written by those\nprocesses to have the expected permissions and owners.\n\nWith just the real user ID and the effective user ID, it feels like we can do\na lot! If you have the root effective user ID, calling setuid(user) will set\nthe process' real user ID, effective user ID, and saved set-user-ID to this\nnew ID.\n\nsetuid lets root \"become\" any user, but for a non-privileged user you only\nhave two choices: you can do setuid(real_user_id) or\nsetuid(saved_set_user_id).\n\nSo you can write programs like:\n\n    \n    \n    data = read_files_as_root() os.setuid(unprivileged_user_id) write_files_as_unprivileged_user(data)\n\nand have your expected results. The problem, though, is that this is\neffectively a one-shot operation. After the setuid call, you no longer have\nthe permissions to return to your root privileges. So something like:\n\n    \n    \n    for uid in all_users: data = fetch_user_data_as_root(uid) os.setuid(uid) write_user_data(data) os.setuid(0) # try to go back to root\n\nbecomes impossible, as the second setuid call will fail. You could fork off\nseparate processes before your setuid call, but it's not fun.\n\nThis is where seteuid comes in. seteuid only changes the effective user ID,\nwithout touching the real user ID. This means that we can still hold onto the\ntruth that we are still root, change to an unprivileged user, and then call\nseteuid(real_user_id) to become root again.\n\n    \n    \n    data = fetch_user_data_as_root(uid) os.seteuid(uid) # file permissions now with uid write_user_data(data) # real user ID still 0, so following is allowed os.seteuid(0) # real user ID\n\nWe can thus see that there's a lot of flexibility for programs that are being\nrun as root. But sudo is being run without root! Our real user ID is not 0 so\nwe can't do this toggling forward and backwards.\n\nThis is where the saved set-user-ID comes into play.\n\nWhen calling exec on a program (for example by running a program in your\nshell), by default all three user IDs are set as:\n\n  * real user ID: unchanged\n  * effective user ID: unchanged\n  * saved set-user-ID: copy the current effective user ID\n\nBut, if your program has the setuid flag set on the program file, instead your\nprogram will load in the following way:\n\n  * real user ID: unchanged\n  * effective user ID: the user ID of the program owner (the file owner)\n  * saved set-user-ID copy the current effective user ID\n\nWhat this means is that if you have a program that is owned by root, and has\nthe setuid flag set on the program (through chmod +s) then when exec-ing the\nprogram, it will run with the permissions of the program file owner.\n\nsudo is owned by root, but the binary has the setuid permission set, so when I\nrun it as a non-privileged user, sudo has its effective user ID set to 0, and\ncan do whatever it wants. But it will set up the right effective user ID\nbefore running the program the user asked for.\n\nBecause we have the real user ID and the effective one, I've edited my test\nprogram a bit to also display the effective user ID\n\n    \n    \n    #!/usr/bin/env python3 import sys import os import pwd user_id = os.getuid() e_uid = os.geteuid() # usernames exist in mappings to the password file username = pwd.getpwuid(user_id).pw_name effective_username = pwd.getpwuid(e_uid).pw_name print(f\"Called with: {sys.argv}\") print(f\"Hello, {username}\") print(f\"(Effective user is {effective_username})\")\n\nAfter setting the set-user-ID bit, I call this and...\n\n    \n    \n    >>> ./say_hello.py Called with: ['./say_hello.py'] Hello, rtpg (Effective user is rtpg) >>> sudo ./say_hello.py Called with: ['./say_hello.py'] Hello, root (Effective user is root)\n\nAfter a bit of searching around I figured out that the set-user-ID bit is\nignored on Linux for interpreter scripts (programs that rely on the #!, called\n\"shebang\", to execute), and I'm on Ubuntu so....\n\nHere is a port of my test program in C:\n\n    \n    \n    // say_hello.c #include <unistd.h> #include <pwd.h> #include <stdio.h> void print_username(uid_t uid){ struct passwd* p = getpwuid(uid); if (p == NULL){ printf(\"(Unknown, user ID %d)\", uid); } else { printf(\"%s\", p->pw_name); } } int main(int argc, char** argv){ int uid = getuid(); int euid = geteuid(); printf(\"Real user: \"); print_username(uid); printf(\"\\nEffective user: \"); print_username(euid); printf(\"\\n\"); return 0; }\n\nThen I compiled and ran this, to at least confirm I really understood how the\nsetuid bit worked\n\n    \n    \n    >>> gcc -o say_hello say_hello.c >>> chmod +s say_hello >>> ./say_hello Real user: rtpg Effective user: rtpg >>> sudo ./say_hello [sudo] password for rtpg: Real user: root Effective user: rtpg\n\nEven when running with sudo, because the binary has the setuid bit, our\neffective user is set to the file owner.\n\nSo in order to write our own sudo with this bit, I opted for just writing some\nC instead of Python\n\n    \n    \n    #include <unistd.h> #include <stdio.h> #include <stdlib.h> int main(int argc, char** argv){ if(argc<2){ fprintf(stderr, \"Need to be provided arguments!\\n\"); exit(EXIT_FAILURE); } int euid = geteuid(); if(euid !=0){ fprintf(stderr, \"Not root! Does mysudo have the setuid bit set?\\n\"); exit(EXIT_FAILURE); } // our effective uid is already root, //let's also set the real user ID setreuid(0, -1); // argc is at least 2... execvp(argv[1], argv + 1); }\n\nThen I tried it out:\n\n    \n    \n    >>> gcc -o mysudo mysudo.c >>> sudo chown root:root ./mysudo >>> >>> sudo chmod +s mysudo >>> ./mysudo ./say_hello.py foo bar Called with: ['./say_hello.py', 'foo', 'bar'] Hello, root (Effective user is root)\n\n(I called my original say_hello.py script, whose setuid bit is not respected).\n\nThis was successful! An unprivileged user can run a program \"as root\" thanks\nto this binary.\n\nWell, it seems like a bad idea to have a binary on our system that lets any\nunprivileged user get root access. This is where sudo does stuff like the\nsudoers file, where only specific users have permissions, and perhaps only\nhave permissions to do very specific things.\n\nThis is why people deal with sudo or doas rather than write their own 10-line\nscripts to do this, of course.\n\nLet's add some really basic checks: only my user (user ID 1000, found by\nrunning id -u in a shell) should be allowed to use this:\n\n    \n    \n    if(argc<2){ fprintf(stderr, \"Need to be provided arguments!\\n\"); exit(EXIT_FAILURE); } // added extra security! int uid = getuid(); if(uid != 1000){ fprintf(stderr, \"Only user 1000 has these powers!\\n\"); exit(EXIT_FAILURE); }\n\nWith this even root can't use our binary!\n\n    \n    \n    >>> sudo ./mysudo ./say_hello.py foo bar Only user 1000 has these powers!\n\nThere's a lot more stuff that sudo does (including auditing of commands\nthrough audit plugins, or password prompts with timestamped files to avoid\nhaving to type your password over and over). The codebase is actually\nrelatively flat C, and looking through it helped me to understand a couple\nthings about how it works.\n\nBut really the challenge is in trying to figure out all the ways in which\nthings can be made insecure unintentionally. There are a lot of ways you might\ntry to scope down the security features, but things like user ID checks are\nnot the end-all, especially if your security model goes a bit beyond \"root and\neveryone else\".\n\n## Further Reading\n\nFor people interested in Unix stuff in general, \"Advanced Programming In The\nUnix Environment\" is a must-have book. It might look old, but it covers more\nthan enough ground to be a valuable read for any programmer. Ostensibly a\nreference book, you can basically read it front to back and find out a lot of\nlittle bits of information about how Unix works. It might feel costly for\nsomething that doesn't feel up to date (especially when we have man pages for\neverything covered), but the organization of the material is key.\n\nFor me it has been essential in cleaning up my mental model of what the OS is\ndoing, and reduces bad surprises when I'm doing operational work.\n\nThe sudo codebase is some legible C, and kinda fun to scroll through. The main\nfunction is very straightforward, and you can jump to various files to see a\nlot of engineering to try and solve many different edge cases from the\nmillions of sudo calls happening every hour.\n\nThis very old email thread discussing set-user-ID as a feature and its history\nis very revelatory to how Unix today exists as a combination of a lot of\npragmatism, much more than some perfect design from the outset.\n\nPreviously:\n\n  * Precision In Technical Discussions\n  * A Conjecture About Adversarial Wordle\n  * Advice for myself on how to avoid verbose Rust code\n\nLater:\n\n  * A Couple Lines To Improve Print-Based Debugging In Loops\n  * Augmenting Existing Struct APIs with Rust Traits\n  * Ideas For A Javascript Stricter Mode\n\nSubcribe to get an e-mail when I post something new:\n\n", "frontpage": false}
