{"aid": "40217512", "title": "JavaScript Language Design and Implementation in Tandem", "url": "https://dl.acm.org/doi/10.1145/3624723", "domain": "acm.org", "votes": 1, "user": "chrisaycock", "posted_at": "2024-04-30 22:59:33", "comments": 0, "source_title": "JavaScript Language Design and Implementation in Tandem | Communications of the ACM", "source_text": "JavaScript Language Design and Implementation in Tandem | Communications of the ACM\n\n## This website uses cookies\n\nWe occasionally run membership recruitment campaigns on social media channels\nand use cookies to track post-clicks. We also share information about your use\nof our site with our social media, advertising and analytics partners who may\ncombine it with other information that you\u2019ve provided to them or that they\u2019ve\ncollected from your use of their services. Use the check boxes below to choose\nthe types of cookies you consent to have stored on your device.\n\nUse necessary cookies only Allow all cookies Show details\n\nOK\n\nUse necessary cookies only Allow selected cookies Allow all cookies\n\nShow details\n\nCookie declaration [#IABV2SETTINGS#] About\n\nNecessary (7) Preferences (5) Statistics (16) Marketing (24) Unclassified (0)\n\nNecessary cookies help make a website usable by enabling basic functions like\npage navigation and access to secure areas of the website. The website cannot\nfunction properly without these cookies. These cookies do not gather\ninformation about you that could be used for marketing purposes and do not\nremember where you have been on the internet.\n\nName| Provider| Purpose| Expiry| Type  \n---|---|---|---|---  \n__jid| c.disquscdn.com| Used to add comments to the website and remember the\nuser's Disqus login credentials across websites that use said service.|\nSession| HTTP  \ndisqusauth| c.disquscdn.com| Registers whether the user is logged in. This\nallows the website owner to make parts of the website inaccessible, based on\nthe user's log-in status.| Session| HTTP  \n__cf_bm| ACM| This cookie is used to distinguish between humans and bots. This\nis beneficial for the website, in order to make valid reports on the use of\ntheir website.| 1 day| HTTP  \n_cfuvid| ACM| This cookie is a part of the services provided by Cloudflare -\nIncluding load-balancing, deliverance of website content and serving DNS\nconnection for website operators.| Session| HTTP  \nCookieConsent| Cookiebot| Stores the user's cookie consent state for the\ncurrent domain| 1 year| HTTP  \n1.gif| Cookiebot| Used to count the number of sessions to the website,\nnecessary for optimizing CMP product delivery.| Session| Pixel  \nVISITOR_PRIVACY_METADATA| YouTube| Stores the user's cookie consent state for\nthe current domain| 180 days| HTTP  \n  \nPreference cookies enable a website to remember information that changes the\nway the website behaves or looks, like your preferred language or the region\nthat you are in.\n\nName| Provider| Purpose| Expiry| Type  \n---|---|---|---|---  \naet-dismiss| c.disquscdn.com| Necessary for the functionality of the website's\ncomment-system.| Persistent| HTML  \ndrafts.queue| c.disquscdn.com| Necessary for the functionality of the\nwebsite's comment-system.| Persistent| HTML  \nsubmitted_posts_cache| c.disquscdn.com| Necessary for the functionality of the\nwebsite's comment-system.| Persistent| HTML  \nmopDeploy| Mopinion| Pending| Session| HTML  \nMACHINE_LAST_SEEN| ACM| Pending| 300 days| HTTP  \n  \nStatistic cookies help website owners understand how visitors interact with\nwebsites by collecting and reporting information anonymously.\n\nName| Provider| Purpose| Expiry| Type  \n---|---|---|---|---  \n_ga| Google| Registers a unique ID that is used to generate statistical data\non how the visitor uses the website.| 2 years| HTTP  \n_ga_#| Google| Used by Google Analytics to collect data on the number of times\na user has visited the website as well as dates for the first and most recent\nvisit.| 2 years| HTTP  \n_gat| Google| Used by Google Analytics to throttle request rate| 1 day| HTTP  \n_gid| Google| Registers a unique ID that is used to generate statistical data\non how the visitor uses the website.| 1 day| HTTP  \n_hjSession_#| Hotjar| Collects statistics on the visitor's visits to the\nwebsite, such as the number of visits, average time spent on the website and\nwhat pages have been read.| 1 day| HTTP  \n_hjSessionUser_#| Hotjar| Collects statistics on the visitor's visits to the\nwebsite, such as the number of visits, average time spent on the website and\nwhat pages have been read.| 1 year| HTTP  \n_hjTLDTest| Hotjar| Registers statistical data on users' behaviour on the\nwebsite. Used for internal analytics by the website operator.| Session| HTTP  \n_hp2_#| Heap Analytics| Collects data on the user\u2019s navigation and behavior on\nthe website. This is used to compile statistical reports and heatmaps for the\nwebsite owner.| 1 day| HTTP  \n_hp2_hld#.#| Heap Analytics| Collects data on the user\u2019s navigation and\nbehavior on the website. This is used to compile statistical reports and\nheatmaps for the website owner.| 1 day| HTTP  \n_hp2_id.#| Heap Analytics| Collects data on the user\u2019s navigation and behavior\non the website. This is used to compile statistical reports and heatmaps for\nthe website owner.| 1 year| HTTP  \n_hp2_ses_props.#| Heap Analytics| Collects data on the user\u2019s navigation and\nbehavior on the website. This is used to compile statistical reports and\nheatmaps for the website owner.| 1 day| HTTP  \ndisqus_unique| c.disquscdn.com| Collects statistics related to the user's\nvisits to the website, such as number of visits, average time spent on the\nwebsite and loaded pages.| Session| HTTP  \ncollect| Google| Used to send data to Google Analytics about the visitor's\ndevice and behavior. Tracks the visitor across devices and marketing\nchannels.| Session| Pixel  \nhjActiveViewportIds| Hotjar| This cookie contains an ID string on the current\nsession. This contains non-personal information on what subpages the visitor\nenters \u2013 this information is used to optimize the visitor's experience.|\nPersistent| HTML  \nhjViewportId| Hotjar| Saves the user's screen size in order to adjust the size\nof images on the website.| Session| HTML  \ntd| Google| Registers statistical data on users' behaviour on the website.\nUsed for internal analytics by the website operator.| Session| Pixel  \n  \nMarketing cookies are used to track visitors across websites. The intention is\nto display ads that are relevant and engaging for the individual user and\nthereby more valuable for publishers and third party advertisers.\n\nName| Provider| Purpose| Expiry| Type  \n---|---|---|---|---  \nbadges-message| c.disquscdn.com| Collects data on the visitor\u2019s use of the\ncomment system on the website, and what blogs/articles the visitor has read.\nThis can be used for marketing purposes.| Persistent| HTML  \napi/telemetry| Heap Analytics| Collects data on user behaviour and interaction\nin order to optimize the website and make advertisement on the website more\nrelevant.| Session| Pixel  \nh| Heap Analytics| Collects data on user behaviour and interaction in order to\noptimize the website and make advertisement on the website more relevant.|\nSession| Pixel  \n#-#| YouTube| Pending| Session| HTML  \niU5q-!O9@$| YouTube| Registers a unique ID to keep statistics of what videos\nfrom YouTube the user has seen.| Session| HTML  \nLAST_RESULT_ENTRY_KEY| YouTube| Used to track user\u2019s interaction with embedded\ncontent.| Session| HTTP  \nLogsDatabaseV2:V#||LogsRequestsStore| YouTube| Pending| Persistent| IDB  \nnextId| YouTube| Used to track user\u2019s interaction with embedded content.|\nSession| HTTP  \nremote_sid| YouTube| Necessary for the implementation and functionality of\nYouTube video-content on the website.| Session| HTTP  \nrequests| YouTube| Used to track user\u2019s interaction with embedded content.|\nSession| HTTP  \nServiceWorkerLogsDatabase#SWHealthLog| YouTube| Necessary for the\nimplementation and functionality of YouTube video-content on the website.|\nPersistent| IDB  \nTESTCOOKIESENABLED| YouTube| Used to track user\u2019s interaction with embedded\ncontent.| 1 day| HTTP  \nVISITOR_INFO1_LIVE| YouTube| Pending| 180 days| HTTP  \nYSC| YouTube| Pending| Session| HTTP  \nyt.innertube::nextId| YouTube| Registers a unique ID to keep statistics of\nwhat videos from YouTube the user has seen.| Persistent| HTML  \nytidb::LAST_RESULT_ENTRY_KEY| YouTube| Used to track user\u2019s interaction with\nembedded content.| Persistent| HTML  \nYtIdbMeta#databases| YouTube| Used to track user\u2019s interaction with embedded\ncontent.| Persistent| IDB  \nyt-remote-cast-available| YouTube| Stores the user's video player preferences\nusing embedded YouTube video| Session| HTML  \nyt-remote-cast-installed| YouTube| Stores the user's video player preferences\nusing embedded YouTube video| Session| HTML  \nyt-remote-connected-devices| YouTube| Stores the user's video player\npreferences using embedded YouTube video| Persistent| HTML  \nyt-remote-device-id| YouTube| Stores the user's video player preferences using\nembedded YouTube video| Persistent| HTML  \nyt-remote-fast-check-period| YouTube| Stores the user's video player\npreferences using embedded YouTube video| Session| HTML  \nyt-remote-session-app| YouTube| Stores the user's video player preferences\nusing embedded YouTube video| Session| HTML  \nyt-remote-session-name| YouTube| Stores the user's video player preferences\nusing embedded YouTube video| Session| HTML  \n  \nUnclassified cookies are cookies that we are in the process of classifying,\ntogether with the providers of individual cookies.\n\nWe do not use cookies of this type.  \n---  \n  \n[#IABV2_LABEL_PURPOSES#] [#IABV2_LABEL_FEATURES#] [#IABV2_LABEL_PARTNERS#]\n\n[#IABV2_BODY_PURPOSES#]\n\n[#IABV2_BODY_FEATURES#]\n\n[#IABV2_BODY_PARTNERS#]\n\nCookies are small text files that can be used by websites to make a user's\nexperience more efficient. Other than those strictly necessary for the\noperation of the site, we need your permission to store any type of cookies on\nyour device. Learn more about ACM, how you can contact us, and how we process\npersonal data in our Privacy Policy. Also please consult our Cookie Notice.\n\nYou can change or withdraw your consent from the Cookie Declaration on our\nwebsite at any time by visiting the Cookie Declaration page. If contacting us\nregarding your consent, please state your consent ID and date from that page.\n\nYour consent applies to the following domains: dl.acm.org\n\nCookie declaration last updated on 3/31/24 by Cookiebot\n\nskip to main content\n\n  * Advanced Search\n  * Browse\n  * About\n  *     * Sign in\n    * Register\n\nAdvanced Search\n\nCommunications of the ACM\n\nresearch-article\n\nOpen Access\n\nShare on\n\nOnline First\n\n# JavaScript Language Design and Implementation in Tandem\n\n  * Authors:\n  * Sukyoung Ryu\n\nKAIST, Daejeon, Daejeon, Korea (the Republic of)\n\nKAIST, Daejeon, Daejeon, Korea (the Republic of)\n\nSearch about this author\n\n,\n\n  * Jihyeok Park\n\nKorea University, Seoul, Seoul, Korea (the Republic of)\n\nKorea University, Seoul, Seoul, Korea (the Republic of)\n\nSearch about this author\n\nAuthors Info & Claims\n\nCommunications of the ACMOnline Firsthttps://doi.org/10.1145/3624723\n\nPublished:19 April 2024Publication History\n\n  * 0citation\n  * 188\n  * Downloads\n\nMetrics\n\nTotal Citations0\n\nTotal Downloads188\n\nLast 12 Months188\n\nLast 6 weeks188\n\n  * Get Citation Alerts\n\n## New Citation Alert added!\n\nThis alert has been successfully added and will be sent to:\n\nYou will be notified whenever a record that you have chosen has been cited.\n\nTo manage your alert preferences, click on the button below.\n\nManage my Alerts\n\n## New Citation Alert!\n\nPlease log in to your account\n\n  * Publisher Site\n\n  * eReader\n  * PDF\n\n## Communications of the ACM\n\nOnline First\n\nPreviousArticleNextArticle\n\n  * JavaScript is the first programming language for which each change to its prose language specification is both \u201ctype checked\u201d and \u201ctested\u201d to identify bugs and inconsistencies.\n\n  * The primary enabler is the automatic extraction of a \u201cmechanized specification\u201d from a language specification written in prose, which allows the generation of a reference implementation of the language from the specification.\n\n  * In addition to reference implementations, mechanized specifications can be used to detect conformance bugs between language specifications and existing JavaScript engines in major Web browsers, and generate more special-purpose JavaScript implementations, such as static analyzers, in a correct-by-construction manner.\n\n  * A promising approach to programming language development is to first design the language in a mechanized specification and then generate both human-friendly specifications written in a variety of natural languages and correct-by-construction implementations from the mechanized specification.\n\nProgramming languages have been specified using a wide variety of approaches.\nMost programming language specifications are written in unstructured prose,\nbut some are written rigorously to help developers build correct language\nimplementations. For example, Standard ML (SML) was first designed with a\nformal specification that defined the language syntax and semantics in\nmathematical notation, followed by a reference implementation of the\nspecification. JavaScript is well known for its language specification, which\nis written in highly structured prose at the level of pseudocode algorithms.\nFinally, the specification of WebAssembly provides the syntax and semantics of\nthe language in both highly structured prose and mathematical notation.\n\nUnfortunately, rigorous language specifications do not prevent bugs in\nlanguage implementations. SML maintains a list of reported bugs, and different\nimplementations have different sets of bugs. JavaScript has many\nimplementation bugs in the JavaScript engines of various Web browsers.\n\n> Rigorous language specifications do not prevent bugs in language\n> implementations.\n\nMore importantly, it is difficult to get a rigorous language specification\nright. Despite its complete formal semantics, the WebAssembly 1.0\nspecification had bugs detected by mechanized proofs of Conrad Watt.^35 The\ndevelopers of the Verse programming language^2 described the language\nsemantics in rewriting rules and opened a call for participation to the PL\ncommunity for confluence proofs.\n\nIn this article, we present how to automatically extract a mechanized\nspecification from a prose specification and how useful it can be in practice.\nUsing the example of JavaScript, we show how mechanized specifications can be\nused to (1) detect conformance bugs between language specifications and\nexisting JavaScript engines in major Web browsers, and (2) generate more\nspecial-purpose JavaScript implementations, such as static analyzers, in a\ncorrect-by-construction manner. We propose a new approach to programming\nlanguage development as a promising direction for the future: first design the\nlanguage in a mechanized specification and then generate both human-friendly\nspecifications written in diverse natural languages and correct-by-\nconstruction implementations and tools from the mechanized specification.\n\n> We propose a new approach to programming language development: design the\n> language in a mechanized specification, then generate both human-friendly\n> specifications written in diverse natural languages and correct-by-\n> construction implementations and tools from the mechanized specification.\n\nSkip History of JavaScript Section\n\n## History of JavaScript\n\nJavaScript is the most actively used programming language on GitHub.^17 All\nWeb browsers include a JavaScript engine. It was initially designed and\nimplemented by Brendan Eich in May 1995 as a simple dynamic language that\nallowed code snippets to be interpreted by Web browsers. In early 1996,\ncompanies including Netscape and Microsoft were frequently releasing browser\ntechnology, but language standardization was slow and often contentious. To\nensure interoperability between different browsers, TC39, the Ecma Technical\nCommittee responsible for standardizing JavaScript, had meetings to create the\nJavaScript language specification.\n\nUnlike programming languages that \u201cgrow up\u201d via a single implementation,\nJavaScript began with multiple implementations, which guided its\nspecification:^36\n\n> Richard Gabriel, who attended some of the working group meetings, recalled\n> in a personal communication a not uncommon interaction during these\n> meetings. Guy Steele would ask a question about some edge-case feature\n> behavior. Sometimes Brendan Eich would say \u201cI don't know,\u201d and sometimes\n> Eich and Shon Katzenberger would be unsure or disagree; in such cases, they\n> would each turn to their respective implementation and try a test case. If\n> they got the same answer, that became the specified behavior. If there were\n> a difference, they would discuss the issue until they reached an agreement.\n\nThe history of JavaScript is described in great detail in Wirfs-Brock and\nEich.^36 The first edition of its language specification ECMA-262, abbreviated\nES1, was released in 1997, edited by Guy L. Steele, Jr, in 95 pages.\nJavaScript developers continued to demand more advanced language features, so\nES2 and ES3 were released in 1998 and 1999, respectively. However, attempts to\ndefine a fourth edition were eventually abandoned due to the radical changes\nin a single update that included a variety of new language features, and ES5\nwas finally released in 2009. Starting with the sixth edition, TC39 adopted\nthe practice of using the year of publication as an abbreviation. Thus, both\n\u201cES6\u201d and \u201cES2015\u201d are informal abbreviations for \u201cECMA-262, 6th edition.\u201d\nTC39 also decided to release ECMA-262 annually, starting with ES2015 to ensure\nrapid adoption of new language features. The latest ECMA-262^10 is a much\nlarger specification at 827 pages.\n\nNow, ECMA-262 is maintained as an open source project^11 and follows the TC39\nprocess^14 for handling proposals for new language features. JavaScript\ncontributors propose new features along with specification changes and tests,\nwhich are maintained in a separate repository^6 over six stages. Since 2015,\nTC39 has successfully published an updated edition of the ECMAScript\nspecification every June, following the TC39 process.\n\nAs with the language specification, various companies, including Microsoft and\nGoogle, have released their own open source test suites for JavaScript. In\n2010, TC39 decided to maintain Test262,^15 an open source JavaScript\nimplementation conformance test suite. After working through many policy and\nlicensing issues, Test262 is now an integral part of TC39\u2019s development\nprocess. Every new ECMAScript feature must be accompanied by its tests before\nit is incorporated into the ECMAScript standard. At the time of writing,\nTest262 consists of 48,854 tests.\n\nSkip Correctness and Conformance of the Specification and Implementations\nSection\n\n## Correctness and Conformance of the Specification and Implementations\n\nAlong with its reputation as the most widely used language, JavaScript is also\nwell-known for its unintuitive semantics due to its highly dynamic nature and\nextensive use of implicit type conversion. As a result, there are many\nsophisticated JavaScript examples. Consider the following JavaScript code:\n\n    \n    \n    function f(x) { return x == !x; }\n\nEven for this simple function, it is not easy to understand exactly what its\nbehavior is: the function f simply compares the given argument x with its\nnegation, so it looks like it returns false. However, when an empty array is\ngiven as an argument, it returns true due to a number of implicit conversions\nfor the negation and equality operators. More specifically, when f([])\nevaluates [] == ![], the negation of the empty array ![] evaluates to false\nbecause any object represents true. The operands [] and false of the equality\noperator are then both converted to values of the same type according to the\nimplicit conversion rules defined in ECMA-262. In this example, they both get\nconverted into the same Number type value, 0, so the final result becomes\ntrue.\n\nSuch counterintuitive semantics often leads to various bugs and security\nvulnerabilities in implementations. Experienced JavaScript developers often\nintroduce bugs that are difficult to catch due to the extremely dynamic nature\nof JavaScript. Mainstream JavaScript engines like V8, JavaScriptCore,\nSpiderMonkey, and Chakra had various bugs that were more harmful than bugs in\nJavaScript programs.^34 They also had security vulnerabilities that could lead\nto remote attacks. For example, a high-severity bug in V8, tracked as\nCVE-2021-21224, was widely exploited in April 2021.^33 Besides, it is more\nchallenging to correctly develop special-purpose JavaScript implementations\nthat require a deeper understanding of the specification for specialized\nlanguage semantics. For example, most existing JavaScript static\nanalyzers^19^,^20^,^23 require a sound abstraction of the language semantics\nto guarantee the soundness of their analysis. However, because they need to\nconsider not only concrete semantics but also how to abstract them soundly,\nthey have been plagued by soundness bugs^25 for unusual edge cases in language\nsemantics.\n\nECMA-262 also had a number of bugs. Consider the following Math.round built-in\nlibrary function (specified in Section 20.3.2.28 of an ECMA-262 internal\nversion):^7\n\n20.3.2.28 Math.round (x)\n\n  1. Let be ? ToNumber .\n\n  2. If is an integral Number, return .\n\n  3. If and , return .\n\n  4. If and , return .\n\n  5. Return the integral Number closest to , preferring the Number closer to in the case of a tie.\n\nIt first converts the given parameter x to its numeric value n using ToNumber.\nThe remaining steps should be performed using n, but the specification writer\nof this section mistakenly used x instead of n in steps 3 and 4. This bug was\nintroduced in ECMA-262 on September 11, 2020 and was later fixed by another\ncontributor.\n\nIn addition, keeping a rapidly evolving language specification up to date and\nmanaging the many different language implementations that conform to the\nspecification is challenging even with a large test suite. The three editors\nof ECMA-262 had to manually review new proposals and changes to the\nspecification. In addition to Test262, various browsers maintain their own\ntest suites, but they may still behave differently. Therefore, Ficarra,^16 an\neditor of ECMA-262, said, \u201cone of my primary goals has been to make the\nspecification easier to consume for automated analysis tools.\u201d\n\nSkip Academic Research into the CI Systems Section\n\n## Academic Research into the CI Systems\n\nWe helped Ficarra achieve his goal in November 2022: each ECMA-262 pull\nrequest (PR) runs a type checker against the prose specification, and all new\nor changed tests in Test262 PRs are run using an interpreter extracted\ndirectly from the text of ECMA-262. For example, if one sends a PR of the\nMath.round function, the type checker will detect a bug and reject the PR.\nFirst, note that the parameter x can accept any JavaScript value: string,\nboolean, number, object, and so on. Applying ToNumber to x in step 1 converts\nx to a number or an exception. Exception cases are filtered out using the\nquestion mark operator, so n always points to a number. Because x is compared\nto several numbers with inequality operators on lines 3 and 4, the type\nchecker reports them as type mismatch bugs because non-numeric values are not\nvalid arguments for inequality operators. Whenever a language feature is added\nto ECMA-262, it must be accompanied by its corresponding tests in Test262,\nwhich now leverage interpreters extracted from ECMA-262, always checking for\nconformance to ECMA-262. These automated tools, heavily used in the continuous\nintegration (CI) system of ECMA-262 and Test262, are based on a series of\nacademic papers.\n\nHow have ideas from academia been integrated into real-world industry? How did\nresearchers convince the TC39 committee to use their ideas?\n\nThe KAIST Programming Language Research Group (PLRG) has been researching\nJavaScript since 2011. Initially, we mainly formalized the semantics of the\nJavaScript language with various features, but now our research focuses on\nprogram analysis and bug finding in JavaScript applications. Our research\nproblems are often motivated by real-world customers in companies such as\nSamsung Electronics and IBM. This work had been challenging, interesting,\nrewarding, and fun until TC39 decided in 2015 to release ECMA-262 annually. As\nthe JavaScript language has evolved more rapidly, developing and maintaining\nJavaScript analysis tools has become increasingly difficult.\n\n> As the JavaScript language has evolved, developing and maintaining\n> JavaScript analysis tools has become increasingly difficult.\n\nIn March 2019, Ph.D. candidate Jihyeok Park cautiously shared an outlandish\nidea. ECMA-262 had been released annually since 2015, but existing JavaScript\nanalyzers, including our own, were still based on ES5, which was released in\n2009. It is impossible to manually keep up with the changes in an 800-page\nspecification every year. Then he realized something: the English phrases in\nthe specification had common patterns. It might be possible to \u201cparse\u201d the\nEnglish sentences and \u201ccompile\u201d them into abstract algorithms in an\nintermediate language. We considered this a clever engineering hack, which\ncould help us generate more tests for features of ECMA-262 that Test262 does\nnot cover.\n\nIn essence, it was the primary enabler; the direct extraction of \u201cmechanized\nspecifications\u201d from prose-written language specifications has opened the door\nto the automatic generation of language-manipulating tools. To bridge the gap\nbetween ECMA-262 and its implementations, ESMeta^21 extracts mechanized\nspecifications to automatically generate a variety of language-based tools\nfrom a given version of ECMA-262. It is based on several papers. JISET^28\nextracts a mechanized specification from ECMA-262. A mechanized specification\nconsists of two parts: a JavaScript parser constructed from the syntax written\nin a variant of the extended BNF (EBNF) notation, and functions in an\nintermediate representation (IR) compiled from abstract algorithms written in\nEnglish for the language semantics. JEST^27 synthesizes conformance test\nprograms and checks discrepancies between JavaScript engines and the\nspecification. Using this tool, we detected 44 bugs in four engines (V8,\nGraalJS, QuickJS, and Moddable XS) and 27 bugs in ES2020. JSTAR^26 analyzed\nthe types of English sentences in ECMA-262 and detected 93 type-related\nspecification bugs, which were confirmed by TC39. JSAVER^25 automatically\ngenerates a JavaScript static analyzer from ECMA-262, which outperforms the\nstate-of-the-art JavaScript static analyzers that were manually developed. The\nnext section offers a description of the technical details behind them.\n\n> The direct extraction of \u201cmechanized specifications\u201d from prose-written\n> language specifications has opened the door to the automatic generation of\n> language-manipulating tools.\n\nBecause the papers presented various new techniques using mechanized\nspecifications, we used their bug-finding capabilities to evaluate the\neffectiveness of the techniques. Thus, we submitted many bug reports to\nmainstream JavaScript engine developers and the TC39 committee for\nconfirmation. They kindly confirmed the bugs and expressed a lot of curiosity.\nThen, the ECMA-262 editors invited us to a TC39 meeting.\n\nThe presentation was very well received. All the excitement from the TC39\ncommittee and the detailed discussion can be found in the meeting note.^13\nAfter mutually exciting meetings with the TC39 committee, we decided to\nintegrate JSTAR and JISET into the CI systems of ECMA-262 and Test262,\nrespectively. Since these tools were prototype implementations to see their\nfeasibility in academic publications, we reimplemented all the tools and\nrebranded them as ESMeta to make them practically available to all PRs in the\nECMA-262 and Test262 repositories.\n\nAfter the first meeting with ECMA-262 editors on Nov. 24, 2021, we gave a\npresentation at the TC39 meeting on Jan. 27, 2022. ESMeta was then integrated\ninto ECMA-262's CI system on Nov. 3, 2022^12 and Test262's CI system on Nov.\n25, 2022.^9 This was about a year after the first meeting with the TC39\ncommittee. This is how the initial outlandish idea and subsequent academic\npapers were integrated into real-world programming language development.\n\nSkip Technical Details Section\n\n## Technical Details\n\nResearchers have proposed various approaches to help developers build correct\nJavaScript applications.^1^,^32\n\nOne approach is to formalize the JavaScript language semantics described in\nECMA-262. Because ECMA-262 defines semantics in prose, it is sometimes\nambiguous and contains bugs and infeasible behavior. Researchers have proposed\nformal specifications for JavaScript semantics to provide a solid foundation\nfor JavaScript research. Maffeis et al.^22 proposed a small-step operational\nsemantics for ES3; Guha et al.^18 used a desugaring process to develop \u03bb_JS, a\ncore calculus of ES3; and Park et al.^24 defined ES5 using the K framework.^30\n\nAnother approach is to analyze JavaScript programs to reason about their\nbehavior or detect bugs and security vulnerabilities. WALA^19 was initially\ndeveloped for Java pointer analysis and has been extended to support more\nlanguages, including Android Java and JavaScript. TAJS^23 is a dataflow\nanalysis for JavaScript that uses a model of ES3 and a partial model of ES5.\nIt provides partial support for the latest ECMAScript language features with\nBabel,^3 which compiles the latest features down to lower versions. SAFE^20 is\na general analysis framework for JavaScript web applications. These are all\nopen source projects for static analysis of JavaScript. In contrast,\nJalangi^31 is a general framework for JavaScript dynamic analyzers such as\nmemory profilers and dynamic JIT-unfriendly code snippet detectors.\n\nWhile most of the research on JavaScript is for ES3 and ES5, ECMA-262 has been\nreleased every year since 2015. Thus, manually updating the semantic\nformalizations and analysis implementations is tedious, labor-intensive, and\nerror-prone.\n\nTo bridge the gap between the rapidly evolving ECMA-262 and its\nimplementations, ESMeta generates various tools directly from ECMA-262. Figure\n1 illustrates the overall structure of ESMeta. The first step is to extract a\nmechanized specification from an input ECMA-262 via JISET. Once a mechanized\nspecification is available, it can be used to check the validity of ECMA-262.\nWe can use JEST to synthesize new kinds of conformance tests and JSTAR to\nanalyze the types of English phrases in the specification. Finally, we can use\nJSAVER to derive a static analyzer for a given version of ECMA-262. We will\ndescribe them in order.\n\nFigure 1.\n\nView Figure\n\nFigure 1. Overall structure of ESMeta.\n\n### Extraction of Mechanized Specifications\n\nECMA-262 defines the language syntax using a variant of EBNF and the semantics\nusing abstract algorithms in a clear and structured manner. For example, the\nfollowing production shows the syntax of ArrayLiteral in ES2022:\n\nArrayLiteral _[Yield, Await] :\n\n  * [ Elision_opt ]\n\n  * [ ElementList_[?Yield, ?Await] ]\n\n  * [ ElementList_[?Yield, ?Await] , Elision_opt]\n\nIt takes two boolean parameters Yield and Await, and has three alternatives.\nThe following abstract algorithm defines the semantics of the third\nalternative:\n\nArrayLiteral : [ ElementList , Elision_opt ]\n\n  1. Let array be ! ArrayCreate(0).\n\n  2. Let nextIndex be ? ArrayAccumulation of ElementList with arguments array and 0.\n\n  3. If Elision is present then:\n\n     * Perform ? ArrayAccumulation of Elision with arguments array and nextIndex.\n\n  4. Return array.\n\nIt has four steps. In the HTML files describing ECMA-262, each nonterminal,\nsuch as ElementList, or local variable, such as array, has a <nt> or <var>\ntag, respectively. From the above production, the lookahead parsing\ntechnique^28 generates a parser in Scala code as follows:\n\n    \n    \n    val ArrayLiteral: List[Boolean] => LAParser[T] = memo { case List(Yield, Await) => \"[\" ~ opt(Elision) ~ \"]\" ^^ ArrayLiteral0 | \"[\" ~ ElementList(Yield,Await) ~ \"]\" ^^ ArrayLiteral1 | \"[\" ~ ElementList(Yield,Await) ~ \",\" ~ opt(Elision) ~ \"]\" ^^ ArrayLiteral2 }\n\nEach parser has the List[Boolean] => LAParser[T] type because each production\nis parametric with boolean values. Similarly, the algorithm compiler^28\ntranslates the above abstract algorithm to the following function in a domain-\nspecific intermediate representation, IR_ES:\n\n    \n    \n    syntax def ArrayLiteral[2].Evaluation( this, ElementList, Elision ) { let array = [! (ArrayCreate 0)] let nextIndex = [? (ElementList.ArrayAccumulation array 0)] if (! (= Elision absent)) [? (Elision.ArrayAccumulation array nextIndex)] return array }\n\nWe evaluated the correctness of the semantics extracted from ES2019^5 by\nrunning Test262. It took about three hours to evaluate 18,064 applicable\ntests; 1,709 tests failed due to nine specification bugs in ES2019. Four of\nthese bugs were newly reported and confirmed by TC39.\n\n### Synthesis of Conformance Tests\n\nIn addition to the annual updates to ECMA-262, the various JavaScript engines\ncontinue to provide various extensions to the specification to meet rapidly\nchanging user needs. Unfortunately, these updates, both in the specification\nand in implementations, make synchronization difficult, leading to unexpected\nbehavior.\n\nInspired by the ECMA-262 bugs detected by the extracted semantics, we devised\nan N +1-version differential testing.^27 Traditional differential testing runs\nN implementations of a specification simultaneously for each input and detects\nproblems when the outputs do not match. N +1-version differential testing also\ntests the specification using a mechanized specification extracted from the\nspecification.\n\nIt consists of four steps:\n\n  1. Automatically synthesize programs according to the syntax and semantics from a given language specification.\n\n  2. generate conformance tests by injecting assertions into the synthesized programs to check their final program states.\n\n  3. Run the conformance tests against multiple implementations to detect bugs in the specification and implementations\n\n  4. Use statistical information to localize bugs in the specification.\n\nWe evaluated the effectiveness of the synthesized tests with ES2020 and four\nJavaScript engines that fully support modern JavaScript features in ES2020:\nV8, GraalJS, QuickJS, and Moddable XS. For evaluation, we injected seven kinds\nof assertions: exception, abort, variable value, object value, object\nproperty, property key, and internal method and slot. For example, to check\nwhether a final program state has the correct value for each object property,\nwe implemented a helper $verifyProperty, which checks the attributes of each\nproperty for each object. Thus, the following code checks the attributes of\nthe property of x.p:\n\n    \n    \n    var x = { p: 42 }; $verifyProperty(x, \"p\", { value: 42.0, writable: true, enumerable: true, configurable: true });\n\nThe bug detection and localization phase then uses the results of running\ngiven conformance tests on multiple JavaScript engines. If a small number of\nengines fail in each test, it reports a potential bug in the engines that\nfailed the test. If a large number of engines fail, it reports a potential bug\nin the specification. It uses spectrum-based fault localization (SBFL),^37 a\nlocalization technique that leverages the coverage of test cases and pass/fail\nresults, to localize potential bugs. We detected 44 bugs in the engines and 27\nbugs in ES2020. One of the ES2020 bugs was a newly detected bug confirmed by\nTC39, caused by not handling abrupt completions in property definitions of\nobject literals.\n\n### Type Analysis of Specifications\n\nManually reviewing every specification update is inherently labor-intensive\nand error-prone, making ECMAScript vulnerable to specification bugs. Because\nthe average number of updated steps of abstract algorithms between consecutive\nreleases from ECMAScript 2016 to 2019 was 9,645.5,^28 manually checking for\nevery update is a daunting task. Thus, TC39 pushed to add various manual\nannotations to the abstract algorithms to reduce specification bugs. First, it\nintroduced two kinds of annotations: assertions, which indicate assumptions at\nspecific points in abstract algorithms, and the prefixes ? and !, which\nindicate whether the execution of an abstract algorithm completes abruptly.\nFor example, \u201cAssert: Type(O) is Object\u201d denotes that the variable O always\nhas an Object value at the point of the assertion, and \u201c? GetV(V , P)\u201d denotes\nthat the execution of GetV(V , P) can complete abruptly. These annotations\nhelp readers understand specifications clearly. Second, the committee decided\nto support type annotations for variables, parameters, and return values of\nabstract algorithms. However, manual annotations of any kind are laborious,\nprone to mistakes, and do not provide an automatic mechanism for detecting\nspecification bugs.\n\n> Manual annotations of any kind are laborious, prone to mistakes, and do not\n> provide an automatic mechanism for detecting specification bugs.\n\nTo alleviate this problem, we developed JSTAR,^26 which takes a mechanized\nJavaScript specification from JISET and performs type analysis of compiled\nfunctions using the specification types defined in ECMA-262. ECMA-262 contains\nnot only JavaScript language types, but also specification types such as\nabstract syntax trees (ASTs), internal list-like structures, and internal\nrecords including environments, completions, and property descriptors. For\nrecords and AST types, we also defined their fields. We defined their type\nhierarchies based on subtype relations. The subtype relation between types is\nshown in Figure 2; a directed edge from \u03c4\u2032 to \u03c4 denotes a subtype relation\n(that is, \u03c4\u2032 <: \u03c4), and the relation is reflexive and transitive. The subtype\nrelation depends on the nominal types defined in ECMAScript. We extract the\nsubtype relation for AST types from the JavaScript syntax. For example,\nconsider the following syntax:\n\nFormalParameter _[?Yield, ?Await] ] : BindingElement_[?Yield, ?Await] ]\n\nBecause the nonterminal BindingElement is the unique alternative of the\nproduction FormalParameter, we automatically extract the subtype relation:\nBindingElement <: FormalParameter. Using the subtype relation, the expression\ne : \u03c4 checks whether the evaluation result of e has type \u03c4\u2032 satisfying \u03c4\u2032 <:\n\u03c4. These subtype relations help enhance the precision of type analysis by\nkeeping track of the precise types of variables and expressions.\n\nFigure 2.\n\nView Figure\n\nFigure 2. Subtype relation <:\n\nUsing such type information, JSTAR performs type analysis and detects\nspecification bugs using a bug detector consisting of four checkers: 1)\nreference checker, 2) arity checker, 3) assertion checker, and 4) operand\nchecker. JSTAR also uses condition-based refinement for type analysis, which\nimproves the precision of type analysis by using conditions on assertions and\nbranches to eliminate infeasible parts. We evaluated JSTAR with all 864\nversions in the official ECMAScript repository from 2018 to 2021. The\nevaluation showed that the refinement technique can reduce the number of\nfalse-positive bugs due to spurious types inferred by imprecise type analysis.\nJSTAR detected 14 type-related bugs in ES2021,^8 which were confirmed by TC39.\n\n### Derivation of Static Analyzers\n\nFinally, we developed JSAVER,^25 which automatically generates a JavaScript\nstatic analyzer from ECMA-262. First, JSAVER extracts definitional\ninterpreters^29 from ECMA-262. A definitional interpreter provides a way to\nrepresent the language semantics of a defined language using its interpreter\nwritten in a defining language. We extract a JavaScript definitional\ninterpreter from JISET. In the extracted definitional interpreter, the defined\nlanguage is JavaScript, and the defining language is IR_ES. We then present\nmeta-level static analysis, which uses the extracted interpreter to indirectly\nanalyze JavaScript programs. Meta-level static analysis is an interpreter-\nbased approach for static analysis of a defined language L_1 using the static\nanalyzer of a defining-language L_2, as depicted in Figure 3. Since an L_1\ninterpreter is an L_2 program, we can indirectly analyze an L_1 program by\ntaking the L_1 program as input and using the static analyzer of L_2 to\nanalyze the interpreter. Thus, we developed a static analyzer of IR_ES for a\nmeta-level static analysis of JavaScript and showed that it can indirectly\nanalyze JavaScript programs effectively. We also presented ways to indirectly\nconfigure abstract domains and analysis sensitivities for JavaScript in the\nstatic analysis of IR_ES. First, we provide a method to configure abstract\ndomains for JavaScript values and structures. Second, we present AST\nsensitivities to express analysis sensitivities for JavaScript, such as flow-\nsensitivity and k-callsite-sensitivity.\n\nFigure 3.\n\nView Figure\n\nFigure 3. Interpreter-based static analysis approach.\n\nFigure 4 shows the analysis results of existing static analyzers (TAJS and\nSAFE) without and with Babel, and JSA_ES2021, the JavaScript static analyzer\nderived from ES2021 via JSAVER, for the applicable tests. In each chart, the\nx-axis represents the point in time when the tests were generated and the\ny-axis represents the number of tests generated before that point in time. The\nmark sound (green, filled) denotes a sound analysis, unsound (red, striped)\ndenotes an unsound analysis, and error (white, blank) denotes an unexpected\nerror. Figures 4(a) and 4(b) show that TAJS and SAFE analyzed most tests\ngenerated before 2015 in a sound way. However, the number of tests that cannot\nbe soundly analyzed has been steadily increasing since 2015. As shown in\nFigures 4(d) and 4(e), Babel transpiles ES2015+ features to ES5.1 to mitigate\nthis issue and increase the number of programs that TAJS and SAFE analyze\nsoundly. However, TAJS and SAFE still failed to soundly analyze more than half\nof the Test262 test programs, while JSA_ES2021 succeeded in soundly analyzing\nall applicable test programs without the need for Babel. The figures show that\nJSAVER can reduce the burden of defining the abstract semantics of ES2015+\nfeatures for static analysis.\n\nFigure 4.\n\nView Figure\n\nFigure 4. Analysis results of TAJS and SAFE without and with Babel and\nJSAES2021 for applicable tests\n\nSkip A Promising New Approach to Programming Language Development Section\n\n## A Promising New Approach to Programming Language Development\n\nDesigning and implementing real-world programming languages is challenging.\nThe ability to reason about program behavior often comes from a formal\nspecification of the language's semantics, but the time-consuming effort of\nformalizing the semantics often falls behind actual implementation. For\nexample, Rust is actively developed by a large and diverse community of\ncontributors and is used in real-world software such as the Linux kernel and\nMozilla Firefox. However, it has not resolved soundness bugs reported years\nago^4 because its strong, static type system does not yet cover various\nlanguage features and APIs. Applying the ESMeta approach to Rust can help\nefficiently generate machine-checkable proof sketches, especially with\nmechanized semantics extracted from mechanized specifications.\n\nAlong with formalizing the semantics of the language, it would be helpful to\nperform extensive testing of the semantics using implementations extracted\nfrom the mechanized specification. Watt et al.^35 presented two mechanizations\nof WebAssembly 1.0 and found bugs in it, but mechanization of WebAssembly 2.0\nwill still be quite time-consuming because the entire mechanization process is\ndone manually. Applying the ESMeta approach to WebAssembly can reduce the\nburden of such manual mechanization.\n\nA promising new approach to programming language development is to design\nlanguages with mechanized specifications from the beginning. For developers,\nmechanized specifications can be easier to understand than specifications in\nnatural language because they are unambiguous and always executable. For non-\ndevelopers, mechanized specifications can be translated into diverse, human-\nfriendly natural languages. Furthermore, implementations and tools that are\nextracted directly from mechanized specifications are correct by construction.\n\n> A promising new approach to programming language development is to design\n> languages with mechanized specifications from the beginning.\n\nDesigning a new programming language by writing a mechanized specification\nthat correctly describes the language's intended behavior can seem daunting,\nbut it is possible because mechanized specifications allow us to create a\nvariety of tools. For example, one can run the specification interactively.\nFigure 5 shows another ESMeta tool, the ECMAScript Double Debugger.^21 This\ntool extends the interpreter extracted from ECMA-262 to help users understand\nhow JavaScript programs are executed according to ECMA-262. It supports step-\nby-step execution of ECMA-262 abstract algorithms, line-by-line execution of\nJavaScript code, breakpoints by abstract algorithm name in ECMA-262, and\nvisualization of ECMA-262 internal states. Language designers can use the\ndebugger to run example code to debug their mechanized specifications. For\ninstance, Verse introduced new features such as logical variables, equality\nconstraints between variables, and choice that allows multiple alternatives.\nDescribing the intended behavior precisely is cumbersome, but a double\ndebugger can ease the burden on language designers.\n\nFigure 5.\n\nView Figure\n\nFigure 5. ECMAScript double debugger.\n\nSkip Conclusion Section\n\n## Conclusion\n\nJavaScript is the first programming language for which each change to its\nprose language specification is both \u201ctype checked\u201d and also \u201ctested\u201d to\nidentify bugs and inconsistencies. In this article, we presented our story of\napplying various ideas from academic papers to the continuous design and\nimplementation process of the real-world programming language in the wild. As\none of the reviewers of the JISET paper suggested, we believe that:\n\n> This is the right order to design and document languages: first the\n> semantics, then the implementation and documentation, ideally generated from\n> the semantics.\n\nSkip Acknowledgments Section\n\n## Acknowledgments\n\nWe would like to thank all members of the KAIST Programming Language Research\nGroup (PLRG) for their collaboration, especially Jaemin Hong for his\ninsightful feedback. This research was supported by National Research\nFoundation of Korea (NRF) (2022R1A2C200366011 and 2021R1A5A1021944), Institute\nfor Information & communications Technology Promotion (IITP) grant funded by\nthe Korea government (MSIT) (2022-0-00460 and 2023-2020-0-01819), and Samsung\nElectronics Co., Ltd (G01210570).\n\nSukyoung Ryu is a professor at KAIST, Daejeon, Republic of Korea.\n\nJihyeok Park is an assistant professor at Korea University, Seoul, Republic of\nKorea.\n\n## References\n\n  1. 1\\. Andreasen E.et al.. A survey of dynamic analysis and test generation for JavaScript. Comput. Surveys 50, 5 (2017), 66:1\u201366:36.Google Scholar\n\nReference\n\n  2. 2\\. Augustsson L., Breitner J.et al.. The Verse calculus: A core calculus for deterministic functional logic programming. In Proceedings of ACM Program. Lang. 7, ICFP, Article 203 (Aug. 2023), 31; Google ScholarDigital Library\n\nReference\n\n  3. 3\\. Babel Team. Babel is a Javascript compiler. Babel Community, 2022; https://babeljs.io/Google Scholar\n\nReference\n\n  4. 4\\. Ben-Yehuda A. Coherence Can Be Bypassed by an Indirect Impl for a Trait Object(2019); https://bit.ly/4bqvoAB.Google Scholar\n\nReference\n\n  5. 5\\. Ecma International. ECMA-262, 10^th Edition, ECMAScript\u00ae2019 Language Specification (June 2019); https://bit.ly/488c9J9Google Scholar\n\nReference\n\n  6. 6\\. Ecma International. Github Repository for ECMAScript Proposals (2019); https://bit.ly/48az6M1Google Scholar\n\nReference\n\n  7. 7\\. Ecma International. Github Repository for an Internal Version of ECMA-262 (2020); https://bit.ly/3Uzf8Y1.Google Scholar\n\nReference\n\n  8. 8\\. Ecma International. ECMA-262, 12^th Edition, ECMAScript\u00ae2021 Language Specification; https://bit.ly/3OzoHCoGoogle Scholar\n\nReference\n\n  9. 9\\. Ecma International. CI: Integrate ESMeta #3730 (2022); https://bit.ly/3HQcLJ1.Google Scholar\n\nReference\n\n  10. 10\\. Ecma International. ECMA-262, 14^th Edition, ECMAScript\u00ae2023 Language Specification; https://bit.ly/3ODWNVXGoogle Scholar\n\nReference\n\n  11. 11\\. Ecma International. ECMAScript Repository (2022); https://bit.ly/49sM88xGoogle Scholar\n\nReference\n\n  12. 12\\. Ecma International. Meta: Integrate ESMeta Type Checker into CI #2926 (2022); https://bit.ly/3Us6smm.Google Scholar\n\nReference\n\n  13. 13\\. Ecma International. Tc39: 26 January 2022 Meeting Notes; https://bit.ly/489mGnu.Google Scholar\n\nReference\n\n  14. 14\\. Ecma International. The Tc39 Process (2022); https://bit.ly/42BnEYKGoogle Scholar\n\nReference\n\n  15. 15\\. Ecma International. Test262: ECMAScript Test Suite (2022); https://bit.ly/3w9BQfjGoogle Scholar\n\nReference\n\n  16. 16\\. Ficarra M. Personal Communication (2021).Google Scholar\n\nReference\n\n  17. 17\\. GitHub. The Top Programming Languages (2022); https://bit.ly/3utUMF1.Google Scholar\n\nReference\n\n  18. 18\\. Guha A., Saftoiu C., and Krishnamurthi S. The essence of JavaScript. In Proceedings of the European Conf. on Object-Oriented Programming. Springer Berlin Heidelberg (2010), 126\u2013150.Google ScholarCross Ref\n\nReference\n\n  19. 19\\. IBM Research. T.J. Watson Libraries for Analysis (WALA), 2006; http://wala.sf.net.Google Scholar\n\nReference 1Reference 2\n\n  20. 20\\. KAIST PLRG. SAFE: Javascript Analysis Framework, 2012; http://safe.kaist.ac.kr.Google Scholar\n\nReference 1Reference 2\n\n  21. 21\\. KAIST PLRG. ESMeta (2022); https://bit.ly/48YjA77.Google Scholar\n\nReference 1Reference 2\n\n  22. 22\\. Maffeis S., Mitchell J.C., and Taly A. An operational semantics for JavaScript. In Proceedings of the Asian Symp. on Programming Languages and Systems. Springer Berlin Heidelberg (2008), 307\u2013325.Google ScholarDigital Library\n\nReference\n\n  23. 23\\. M\u00f8ller A.et al.. TAJS: Type Analyzer for JavaScript (2012); https://bit.ly/3HRyMHb.Google Scholar\n\nReference 1Reference 2\n\n  24. 24\\. Park D., Stef\u0103nescu A., and Ro\u015fu G. KJS: A complete formal semantics of JavaScript. In Proceedings of the 36^th ACM SIGPLAN Conf. on Programming Language Design and Implementation. Association for Computing Machinery (2015), 346\u2013356.Google ScholarDigital Library\n\nReference\n\n  25. 25\\. Park J., An S., and Ryu S. Automatically deriving JavaScript static analyzers from specifications using meta-level static analysis. In Proceedings of the 30^th ACM Joint European Software Engineering Conf. and Symp. on the Foundations of Software Engineering. Association for Computing Machinery (2022), 1022\u20131034.Google ScholarDigital Library\n\nReference 1Reference 2Reference 3\n\n  26. 26\\. Park J.et al.. JSTAR: JavaScript specification type analyzer using refinement. In Proceedings of the 36^th IEEE/ACM Intern. Conf. on Automated Software Engineering. Association for Computing Machinery (2021), 606\u2013616.Google ScholarDigital Library\n\nReference 1Reference 2\n\n  27. 27\\. Park J.et al.. JEST: N+1-version differential testing of both JavaScript engines and specification. In Proceedings of IEEE/ACM 43^rd Intern. Conf. on Software Engineering. IEEE, Association for Computing Machinery (2021), 13\u201324.Google Scholar\n\nReference 1Reference 2\n\n  28. 28\\. Park J., Park J., An S., and Ryu S. JISET: JavaScript IR-based semantics extraction toolchain. In Proceedings of the 35^th IEEE/ACM Intern. Conf. on Automated Software Engineering. IEEE, Association for Computing Machinery, (2020), 647\u2013658.Google ScholarDigital Library\n\nNavigate to\n\n     * Reference 1\n     * Reference 2\n     * Reference 3\n     * Reference 4\n\n  29. 29\\. Reynolds J.C. Definitional interpreters for higher-order programming languages. In Proceedings of the ACM Annual Conf. 2. Association for Computing Machinery (1972), 717\u2013740.Google ScholarDigital Library\n\nReference\n\n  30. 30\\. Ro\u015fu G. and \u015eerb\u0103nu\u0163\u0103 T.F. K overview and SIMPLE case study. In Proceedings of the 2^nd Intern. Workshop on the K Framework and Its Applications 304. Elsevier (2014), 3\u201356.Google Scholar\n\nReference\n\n  31. 31\\. Sen K., Kalasapur S., Brutch T., and Gibbs S. Jalangi: A tool framework for concolic testing, selective record-replay, and dynamic analysis of JavaScript. In Proceedings of the 30^th ACM Joint European Software Engineering Conf. and Symp. on the Foundations of Software Engineering, Association for Computing Machinery (2013), 615\u2013618.Google ScholarDigital Library\n\nReference\n\n  32. 32\\. Sun K. and Ryu S. Analysis of JavaScript programs: Challenges and research trends. ACM Computing Survvey 50, 4 (Aug. 2017), 34.Google Scholar\n\nReference\n\n  33. 33\\. Tung L. Bugs in Chrome\u2019s Javascript Engine Can Lead to Powerful Exploits (2021); https://zd.net/3HS2lbJGoogle Scholar\n\nReference\n\n  34. 34\\. Wang Z.et al.. An empirical study on bugs in JavaScript engines. Information and Software Technology 155 (2023), 107105.Google ScholarDigital Library\n\nReference\n\n  35. 35\\. Watt C.et al.. Two mechanisations of WebAssembly 1.0. In Formal Methods. Huisman M., P\u0103s\u0103reanu C., and Zhan N. (eds). Springer Intern. Publishing, Cham, (2021), 61\u201379.Google ScholarDigital Library\n\nReference 1Reference 2\n\n  36. 36\\. Wirfs-Brock A. and Eich B. JavaScript: The first 20 years. Proceedings of the ACM on Programming Languages 4, HOPL, Article 77 (June 2020), 189.Google Scholar\n\nReference 1Reference 2\n\n  37. 37\\. Wong W.et al.. A survey on software fault localization. IEEE Transactions on Software Engineering 42, 8 (2016), 707\u2013740.Google ScholarDigital Library\n\nReference\n\n## Cited By\n\nView all\n\n## Index Terms\n\n  1. JavaScript Language Design and Implementation in Tandem\n\n    1. Human-centered computing\n\n      1. Human computer interaction (HCI)\n\n        1. Interaction paradigms\n\n          1. Web-based interaction\n\n    2. Information systems\n\n      1. World Wide Web\n\n        1. Web data description languages\n\n    3. Software and its engineering\n\n      1. Software notations and tools\n\n        1. Context specific languages\n\n          1. Scripting languages\n\n        2. General programming languages\n\n      2. Software organization and properties\n\n        1. Software system structures\n\n          1. Distributed systems organizing principles\n\n            1. Organizing principles for web applications\n\n## Recommendations\n\n  * ##### The cyclic queue and the tandem queue\n\nWe consider a closed queueing network, consisting of two FCFS single server\nqueues in series: a queue with general service times and a queue with\nexponential service times. A fixed number $$N$$ N of customers cycle through\nthis network. We determine the joint ...\n\nRead More\n\n  * ##### Work-Conserving Tandem Queues\n\nConsider a tandem queue of two single-server stations with only one server for\nboth stations, who may allocate a fraction of the service capacity to station\n1 and 1 to station 2 when both are busy. A recent paper treats this model\nunder classical ...\n\nRead More\n\n  * ##### Tandem stochastic systems: Jackson networks, asymmetric exclusion processes, asymmetric inclusion processes and Catalan numbers\n\nVALUETOOLS 2019: Proceedings of the 12th EAI International Conference on\nPerformance Evaluation Methodologies and Tools\n\nA tandem stochastic system is a network of n sites (queues) in series, where\nparticles (customers, jobs, packets, etc.) move unidirectionally from one site\nto the next until they leave the system. When each site is an M/M/1 queue,\ni.e., where the buffer ...\n\nRead More\n\n## Comments\n\n### Login options\n\nCheck if you have access through your login credentials or your institution to\nget full access on this article.\n\nSign in\n\n### Full Access\n\nGet this Article\n\n  * Information\n  * Contributors\n\n  * ### Published in\n\nCommunications of the ACM Online First\n\nISSN:0001-0782\n\nEISSN:1557-7317\n\nDOI:10.1145/CACM.ahead-of-print\n\nIssue\u2019s Table of Contents\n\nCopyright \u00a9 2023 ACM\n\n### Sponsors\n\n### In-Cooperation\n\n### Publisher\n\nAssociation for Computing Machinery\n\nNew York, NY, United States\n\n### Publication History\n\n    * Online First: 19 April 2024\n    * Revised: 20 June 2023\n    * Received: 16 February 2023\n\n### Check for updates\n\n### Qualifiers\n\n    * research-article\n\n### Conference\n\n### Funding Sources\n\n  * ### Other Metrics\n\nView Article Metrics\n\n  * Bibliometrics\n  * Citations0\n\n  * ### Article Metrics\n\n    * 0\n\nTotal Citations\n\nView Citations\n\n    * 188\n\nTotal Downloads\n\n    * Downloads (Last 12 months)188\n    * Downloads (Last 6 weeks)188\n\n### Other Metrics\n\nView Author Metrics\n\n  * ### Cited By\n\nThis publication has not been cited yet\n\n### PDF Format\n\nView or Download as a PDF file.\n\nPDF\n\n### eReader\n\nView online with eReader.\n\neReader\n\n### Digital Edition\n\nView this article in digital edition.\n\nView Digital Edition\n\n  * Figures\n  * Other\n\n### Share this Publication link\n\n### Share on Social Media\n\nShare on\n\nClose Figure Viewer\n\nBrowse AllReturn\n\n### Caption\n\n## Export Citations\n\n## Footer\n\n### Categories\n\n  * Journals\n  * Magazines\n  * Books\n  * Proceedings\n  * SIGs\n  * Conferences\n  * Collections\n  * People\n\n### About\n\n  * About ACM Digital Library\n  * ACM Digital Library Board\n  * Subscription Information\n  * Author Guidelines\n  * Using ACM Digital Library\n  * All Holdings within the ACM Digital Library\n  * ACM Computing Classification System\n  * Digital Library Accessibility\n\n### Join\n\n  * Join ACM\n  * Join SIGs\n  * Subscribe to Publications\n  * Institutions and Libraries\n\n### Connect\n\n  * Contact\n  * Facebook\n  * X\n  * Linkedin\n  * Feedback\n  * Bug Report\n\nThe ACM Digital Library is published by the Association for Computing\nMachinery. Copyright \u00a9 2024 ACM, Inc.\n\n  * Terms of Usage\n  * Privacy Policy\n  * Code of Ethics\n\nYour Search Results Download Request\n\nWe are preparing your search results for download ...\n\nWe will inform you here when the file is ready.\n\nDownload now!\n\nYour Search Results Download Request\n\nYour file of search results citations is now ready.\n\nDownload now!\n\nYour Search Results Download Request\n\nYour search export query has expired. Please try again.\n\n", "frontpage": false}
