{"aid": "40246694", "title": "Designing a Swift library with data-race safety", "url": "https://rhonabwy.com/2024/04/29/designing-a-swift-library-with-data-race-safety/", "domain": "rhonabwy.com", "votes": 1, "user": "ingve", "posted_at": "2024-05-03 12:01:28", "comments": 0, "source_title": "Designing a Swift library with data-race safety", "source_text": "Designing a Swift library with data-race safety \u2013 Rhonabwy\n\nSkip to content\n\nRhonabwy\n\nSoftware development and daily life in Seattle\n\n# Designing a Swift library with data-race safety\n\nPosted byheckjApril 29, 2024Posted inGeekstuff, mac, Ranting and Reflections,\nswiftTags:automerge, concurrency, swift\n\nI cut an initial release (0.1.0-alpha) of the library automerge-repo-swift. A\nsupplemental library to Automerge swift, it adds background networking for\nsync and storage capabilities. The library extends code I initially created in\nthe Automerge demo app (MeetingNotes), and was common enough to warrant its\nown library. While I was extracting those pieces, I leaned into the same\ngeneral pattern that was used in the Javascript library automerge-repo. That\nlibrary provides largely the same functionality for Automerge in javascript. I\nborrowed the public API structure, as well as compatibility and implementation\ndetails for the Automerge sync protocol. One of my goals while assembling this\nnew library was to build it fully compliant with Swift\u2019s data-race safety.\nMeaning that it compiles without warnings when I use the Swift compiler\u2019s\nstrict-concurrency mode.\n\nThere were some notable challenges in coming up to speed with the concepts of\nisolation and sendability. In addition to learning the concepts, how to apply\nthem is an open question. Not many Swift developers have embraced strict\nconcurrency and talked about the trade-offs or implications for choices.\nBecause of that, I feel that there\u2019s relatively little available knowledge to\nunderstand the trade-offs to make when you protect mutable state. This post\nshares some of the stumbling blocks I hit, choices I made, and lessons I\u2019ve\nlearned. My hope is that it helps other developers facing a similar challenge.\n\n## Framing the problem\n\nThe way I try to learn and apply new knowledge to solve these kinds of \u201cnew\nfangled\u201d problems is first working out how to think about the problem. I\u2019ve\nnot come up with a good way to ask other people how to do that. I think when I\nframe the problem with good first-principles in mind, trade-offs in solutions\nbecome easier to understand. Sometimes the answers are even self-obvious.\n\nThe foremost principle in strict-concurrency is \u201cprotect your mutable state\u201d.\nThe compiler warnings give you feedback about potential hazards and data-\nraces. In Swift, protecting the state uses a concept of an \u201cisolation domain\u201d.\nMy layman\u2019s take on isolation is \u201cHow can the compiler verify that only one\nthread is accessing this bit of data at a time\u201d. There are some places where\nthe compiler infers the state of isolation, and some of them still changing as\nwe progress towards Swift 6. When you\u2019re writing code, the compiler knows what\nis isolated (and non-isolated) \u2013 either by itself or based on what you\nannotated. When the compiler infers an isolation domain, that detail is not\n(yet?) easily exposed to developers. It really only shows up when there\u2019s a\nmismatch in your assumptions vs. what the compiler thinks and it issues a\nstrict-concurrency warning.\n\nSendability is the second key concept. In my layman\u2019s terms again, something\nthat is sendable is safe to cross over thread boundaries. With Swift 5.10, the\ncompiler has enough knowledge of types to be able to make guarantees about\nwhat is safe, and what isn\u2019t.\n\nThe first thing I did was lean heavily into making anything and everything\nSendable. In hindsight, that was a bit of a mistake. Not disastrous, but I\nmade a lot more work for myself. Not everything needs to be sendable. Taking\nadvantage of isolation, it is fine \u2013 sometimes notably more efficient and\neasier to reason about \u2013 to have and use non-sendable types within an\nisolation domain. More on that in a bit.\n\nMy key to framing up the problem was to think in terms of making explicit\nchoices about what data should be in an isolation region along with how I want\nto pass information from one isolation domain to another. Any types I pass\n(generally) need to be Sendable, and anything that stays within an isolation\ndomain doesn\u2019t. For this library, I have a lot of mutable state: networking\nconnections, updates from users, and a state machines coordinating it all. All\nof it needed so a repository can store and synchronize Automerge documents.\nAutomerge documents themselves are Sendable (I had that in place well before\nstarting this work). I made the Automerge documents sendable by wrapping\naccess and updates to anything mutable within a serial dispatch queue. (This\nwas also needed because the core Automerge library \u2013 a Rust library accessed\nthrough FFI \u2013 was not safe for multi-threaded use).\n\n## Choosing Isolation\n\nI knew I wanted to make at least one explicit isolation domain, so the first\nquestion was \u201cActor or isolated class?\u201d Honestly, I\u2019m still not sure I\nunderstand all the tradeoffs. Without knowing what the effect would be to\nstart off with, I decided to pick \u201clet\u2019s use actors everywhere\u201d and see how it\ngoes. Some of the method calls in the design of the Automerge repository were\neasily and obviously async, so that seemed like a good first cut. I made the\ntop-level repo an actor, and then I kept making any internal type that had\nmutable state also be it\u2019s own actor. That included a storage subsystem and a\nnetwork subsystem, both of which I built to let someone else provide the\nnetwork or storage provider external to this project. To support external\nplugins that work with this library, I created protocols for the storage and\nnetwork provider, as well as one that the network providers use to talk back\nto the repository.\n\nThe downside of that choice was two-fold \u2013 first setting things up, then\ninteracting with it from within a SwiftUI app. Because I made every-darn-thing\nan actor, I hade to await a response, which meant a lot of potential\nsuspension points in my code. That also propagated to imply even setup needed\nto be done within an async context. Sometimes that\u2019s easy to arrange, but\nother times it ends up being a complete pain in the butt. More specifically,\nquite a few of the current Apple-provided frameworks don\u2019t have or provide a\nclear path to integrate async setup hooks. The server-side Swift world has a\nlovely \u201cset up and run\u201d mechanism (swift-service-lifecycle) it is adopting,\nbut Apple hasn\u2019t provided a similar concept the frameworks it provides. The\none that bites me most frequently is the SwiftUI app and document-based app\nlifecycle, which are all synchronous.\n\n## Initialization Challenges\n\nMaking the individual actors \u2013 Repo and the two network providers I created \u2013\ninitializable with synchronous calls wasn\u2019t too bad. The stumbling block I hit\n(that I still don\u2019t have a great solution to) was when I wanted to add and\nactivate the network providers to a repository. To arrange that, I\u2019m currently\nusing a detached Task that I kick off in the SwiftUI App\u2019s initializer:\n\n    \n    \n    public let repo = Repo(sharePolicy: .agreeable) public let websocket = WebSocketProvider() public let peerToPeer = PeerToPeerProvider( PeerToPeerProviderConfiguration( passcode: \"AutomergeMeetingNotes\", reconnectOnError: true, autoconnect: false ) ) @main struct MeetingNotesApp: App { var body: some Scene { DocumentGroup { MeetingNotesDocument() } editor: { file in MeetingNotesDocumentView(document: file.document) } .commands { CommandGroup(replacing: CommandGroupPlacement.toolbar) { } } } init() { Task { await repo.addNetworkAdapter(adapter: websocket) await repo.addNetworkAdapter(adapter: peerToPeer) } } }\n\n## Swift Async Algorithms\n\nOne of the lessons I\u2019ve learned is that if you find yourself stashing a number\nof actors into an array, and you\u2019re used to interacting with them using\nfunctional methods (filter, compactMap, etc), you need to deal with the\nasynchronous access. The standard library built-in functional methods are all\nsynchronous. Because of that, you can only access non-isolated properties on\nthe actors. For me, that meant working with non-mutable state that I set up\nduring actor initialization.\n\nThe second path (and I went there) was to take on a dependency to swift-async-\nalgorithms, and use its async variations of the functional methods. They let\nyou \u201cawait\u201d results for anything that needs to cross isolation boundaries. And\nbecause it took me an embarrasingly long time to figure it out: If you have an\narray of actors, the way to get to an AsyncSequence of them is to use the\nasync property on the array after you\u2019ve imported swift-async-algorithms. For\nexample, something like the following snippet:\n\n    \n    \n    let arrayOfActors: [YourActorType] = [] let filteredResults = arrayOfActors.async.filter(...)\n\n## Rethinking the isolation choice\n\nThat is my first version of this library. I got it functional, then turned\naround and tore it apart again. In making everything an actor, I was making\nLOTS of little isolation regions that the code had to hop between. With all\nthe suspension points, that meant a lot of possible re-ordering of what was\nrunning. I had to be extrodinarily careful not to assume a copy of some state\nI\u2019d nabbed earlier was still the same after the await. (I still have to be,\nbut it was a more prominent issue with lots of actors.) All of this boils down\nto being aware of actor re-entrancy, and when it might invalidate something.\n\nI knew that I wanted at least one isolation region (the repository). I also\nwant to keep mutable state in separate types to preserve an isolation of\nduties. One particular class highlighted my problems \u2013 a wrapper around\nNWConnection that tracks additional state with it and handles the Automerge\nsync protocol. It was getting really darned inconvenient with the large number\nof await suspension points.\n\nI slowly clued in that it would be a lot easier if that were all synchronous \u2013\nand there was no reason it couldn\u2019t be. In my ideal world, I\u2019d have the type\nRepo (my top-level repository) as an non-global actor, and isolate any classes\nit used to the same isolation zone as that one, non-global, actor. I think\nthat\u2019s a capability that\u2019s coming, or at least I wasn\u2019t sure how to arrange\nthat today with Swift 5.10. Instead I opted to make a single global actor for\nthe library and switch what I previously set up as actors to classes isolated\nto that global actor.\n\nThat let me simplify quite a bit, notably when dealing with the state of\nconnections within a network adapter. What surprised me was that when I\nswitched from Actor to isolated class, there were few warnings from the\nchange. The changes were mostly warnings that calls dropped back to\nsynchronous, and no longer needed await. That was quick to fix up; the change\nto isolated classes was much faster and easier than I anticipated. After I\nmade the initial changes, I went through the various initializers and\nassociated configuration calls to make more of it explicitly synchronous. The\nend result was more code that could be set up (initialized) without an async\ncontext. And finally, I updated how I handled the networking so that as I\nneeded to track state, I didn\u2019t absolutely have to use the async algorithsm\nlibrary.\n\n### A single global actor?\n\nA bit of a side note: I thought about making Repo a global actor, but I prefer\nto not demand a singleton style library for it\u2019s usage. That choice made it\nmuch easier to host multiple repositories when it came time to run functional\ntests with a mock In-Memory network, or integration tests with the actual\nproviders. I\u2019m still a slight bit concerned that I might be adding to a long-\nterm potential proliferation of global actors from libraries \u2013 but it seems\nlike the best solution at the moment. I\u2019d love it if I could do something that\nindicated \u201cAll these things need a single isolation domain, and you \u2013\ndeveloper \u2013 are responsible for providing one that fits your needs\u201d. I\u2019m not\nsure that kind of concept is even on the table for future work.\n\n## Recipes for solving these problems\n\nIf you weren\u2019t already aware of it, Matt Massicotte created a GitHub\nrepository called ConcurrencyRecipes. This is a gemstone of knowledge, hints,\nand possible solutions. I leaned into it again and again while building (and\nrebuilding) this library. One of the \u201cconvert it to async\u201d challenges I\nencountered was providing an async interface to my own peer-to-peer network\nprotocol. I built the protocol using the Network framework based (partially on\nApple\u2019s sample code), which is all synchronous code and callbacks. A high\nlevel, I wanted it to act similarly URLSessionWebSocketTask. This gist being a\nconnection has an async send() and an async receive() for sending and\nreceiving messages on the connection. With an async send and receive, you can\nreadily assemble several different patterns of access.\n\nTo get there, I used a combination of CheckedContinuation (both the throwing\nand non-throwing variations) to work with what NWConnection provided. I wish\nthat was better documented. How to properly use those APIs is opaque, but that\nis a digression for another time. I\u2019m particular happy with how my code worked\nout, including adding a method on the PeerConnection class that used\nstructured concurrency to handle a timeout mechanism.\n\n## Racing tasks with structured concurrency\n\nOne of the harder warnings for me to understand was related to racing\nconcurrent tasks in order to create an async method with a \u201ctimeout\u201d. I\nstashed a pattern for how to do this in my notebook with references to Beyond\nthe basics of structured concurrency from WWDC23.\n\nIf the async task returns a value, you can set it up something like this (this\nis from PeerToPeerConnection.swift):\n\n    \n    \n    let msg = try await withThrowingTaskGroup(of: SyncV1Msg.self) { group in group.addTask { // retrieve the next message try await self.receiveSingleMessage() } group.addTask { // Race against the receive call with a continuous timer try await Task.sleep(for: explicitTimeout) throw SyncV1Msg.Errors.Timeout() } guard let msg = try await group.next() else { throw CancellationError() } // cancel all ongoing tasks (the websocket receive request, in this case) group.cancelAll() return msg }\n\nThere\u2019s a niftier version available in Swift 5.9 (which I didn\u2019t use) for when\nyou don\u2019t care about the return value:\n\n    \n    \n    func run() async throws { try await withThrowingDiscardingTaskGroup { group in for cook in staff.keys { group.addTask { try await cook.handleShift() } } group.addTask { // keep the restaurant going until closing time try await Task.sleep(for: shiftDuration) throw TimeToCloseError() } } }\n\nWith Swift 5.10 compiler, my direct use of this displayed a warning:\n\n    \n    \n    warning: passing argument of non-sendable type 'inout ThrowingTaskGroup<SyncV1Msg, any Error>' outside of global actor 'AutomergeRepo'-isolated context may introduce data races guard let msg = try await group.next() else { ^\n\nI didn\u2019t really understand the core of this warning, so I asked on the Swift\nforums. VNS (on the forums) had run into the same issue and helped explain it:\n\n> It\u2019s because withTaskGroup accepts a non-Sendable closure, which means the\n> closure has to be isolated to whatever context it was formed in. If your\n> test() function is nonisolated, it means the closure is nonisolated, so\n> calling group.waitForAll() doesn\u2019t cross an isolation boundary.\n\nThe workaround to handle the combination of non-sendable closures and\nTaskGroup is to make the async method that runs this code nonisolated. In the\ncontext I was using it, the class that contains this method is isolated to a\nglobal actor, so it\u2019s inheriting that context. By switching the method to be\nexplicitly non-isolated, the compiler doesn\u2019t complain about group being\nisolated to that global actor.\n\n## Sharing information back to SwiftUI\n\nThese components have all sorts of interesting internal state, some of which I\nwanted to export. For example, to provide information from the network\nproviders to make a user interface (in SwiftUI). I want to be able to choose\nto connect to endpoints, to share what endpoints might be available (from the\nNWBrowser embedded in the peer to peer network provider), and so forth.\n\nI first tried to lean into AsyncStreams. While they make a great local queue\nfor a single point to point connection, I found they were far less useful to\ngenerally make a firehouse of data that SwiftUI knows how to read and react\nto. While I tried to use all the latest techniques, to handle this part I went\nto my old friend Combine. Some people are effusing that Combine is dead and\ndying \u2013 but boy it works. And most delightfully, you can have any number of\nendpoints pick up and subscribe to a shared publisher, which was perfect for\nmy use case. Top that off with SwiftUI having great support to receive streams\nof data from Combine, and it was an easy choice.\n\nI ended up using Combine publishers to make a a few feeds of data from the\nPeerToPeerProvider. They share information about what other peers were\navailable, the current state of the listener (that accepts connections) and\nthe browser (that looks for peers), and last a publisher that provides\ninformation about active peer to peer connctions. I feel that worked out\nextremely well. It worked so well that I made an internal publisher (not\nexposed via the public API) for tests to get events and state updates from\nwithin a repository.\n\n## Integration Testing\n\nIt\u2019s remarkably hard to usefully unit test network providers. Instead of unit\ntesting, I made a separate Swift project for the purposes of running\nintegration tests. It sits in it\u2019s own directory in the git repository and\nreferences automerge-repo-swift as a local dependency. A side effect is that\nit let me add in all sorts of wacky dependencies that were handy for the\nintegration testing, but that I really didn\u2019t want exposed and transitive for\nthe main package. I wish that Swift Packages had a means to identify test-only\ndependencies that didn\u2019t propagate to other packages for situations like this.\nAh well, my solution was a separate sub-project.\n\nTesting using the Combine publisher worked well. Although it took a little\ndigging to figure out the correct way to set up and use expectations with\nasync XCTests. It feels a bit exhausting to assemble the expectations and\nfulfillment calls, but its quite possible to get working. If you want to see\nthis in operation, take a look at P2P+explicitConnect.swift. I started to look\nat potentially using the upcoming swift-testing, but with limited Swift 5.10\nsupport, I decided to hold off for now. If it makes asynchronous testing\neasier down the road, I may well adopt it quickly after it\u2019s initial release.\n\nThe one quirky place that I ran into with that API setup was that\nexpectation.fulfill() gets cranky with you if you call it more than once. My\npublisher wasn\u2019t quite so constrained with state updates, so I ended up\ncobbling a boolean latch variable in a sink when I didn\u2019t have a sufficiently\nconstrained closure.\n\nThe other quirk in integration testing is that while it works beautifully on a\nlocal machine, I had a trouble getting it to work in CI (using GitHub\nActions). Part of the issue is that the current swift test defaults to running\nall possible tests at once, in parallel. Especially for integration testing of\npeer to peer networking, that meant a lot of network listeners, and browsers,\ngetting shoved together at once on the local network. I wrote a script to list\nout the tests and run them one at a time. Even breaking it down like that\ndidn\u2019t consistently get through CI. I also tried higher wait times (120\nseconds) on the expectations. When I run them locally, most of those tests\ntake about 5 seconds each.\n\nThe test that was a real challenge was the cross-platform one. Automerge-repo\nhas a sample sync server (NodeJS, using Automerge through WASM). I created a\ndocker container for it, and my cross-platform integration test pushes and\npulls documents to an instance that I can run in Docker. Well... Docker isn\u2019t\navailable for macOS runners, so that\u2019s out for GitHub Actions. I have a script\nthat spins up a local docker instance, and I added a check into the WebSocket\nnetwork provider test \u2013 if it couldn\u2019t find a local instance to work against,\nit skips the test.\n\n## Final Takeaways\n\nStarting with a plan for isolating state made the choices of how and what I\nused a bit easier, and reaching for global-actor constrained classes made\nsynchronous use of those classes much easier. For me, this mostly played out\nin better (synchronous) intializers and dealing with collections using\nfunctional programming patterns.\n\nI hope there\u2019s some planning/thinking in SwiftUI to update or extend the app\nstructure to accomodate async hooks for things like setup and initialization\n(FB9221398). That should make it easier for a developer to run an async\ninitializer and verify that it didn\u2019t fail, before continuing into the normal\napp lifecycle. Likewise, I hope that the Document-based APIs gain an async-\ncontext to work with documents to likewise handle asynchronous tasks\n(FB12243722). Both of these spots are very awkward places for me.\n\nOnce you shift to using asynchronous calls, it can have a ripple effect in\nyour code. If you\u2019re looking at converting existing code, start at the \u201ctop\u201d\nand work down. That helped me to make sure there weren\u2019t secondary\ncomplications with that choice (such as a a need for an async initializer).\n\nBetter yet, step back and take the time to identify where mutable state\nexists. Group it together as best you can, and review how you\u2019re interacting\nit, and in what isolation region. In the case of things that need to be\navailable to SwiftUI, you can likely isolate methods appropriately (*cough*\nMainActor *cough*). Then make the parts you need to pass between isolation\ndomains Sendable. Recognize that in some cases, it may be fine to do the\nequivalent of \u201cHere was the state at some recent moment, if you might want to\nreact to that\u201d. There are several places where I pass back a summary snapshot\nof mutable state to SwiftUI to use in UI elements.\n\nAnd do yourself a favor and keep Matt\u2019s Concurrency Recipes on speed-dial.\n\n> Before I finished this post, I listened to episode 43 of the Swift Package\n> Index podcast. It\u2019s a great episode, with Holly Bora, compiler geek and\n> manager of the Swift language team, on as a guest to talk about the Swift 6.\n> A tidbit she shared was that they are creating a Swift 6 migration guide, to\n> be published on the swift.org website. Something to look forward to, in\n> addition to Matt\u2019s collection of recipes!\n\n### Share this:\n\n  * Twitter\n  * Facebook\n  * Email\n  * LinkedIn\n  * Reddit\n  * More\n\n  * Print\n  * Tumblr\n\nLike Loading...\n\n### Related\n\nAutomerge for SwiftOctober 21, 2023In \"Geekstuff\"\n\nCRDT workFebruary 19, 2023In \"Geekstuff\"\n\nHosting your Swift Library Docs on Github PagesJanuary 28, 2022In \"Geekstuff\"\n\nPosted byheckjApril 29, 2024Posted inGeekstuff, mac, Ranting and Reflections,\nswiftTags:automerge, concurrency, swift\n\n## Published by heckj\n\nDeveloper, author, and life-long student. Writes online at\nhttps://rhonabwy.com/. View more posts\n\n### Leave a comment Cancel reply\n\n#### heckj\n\nDeveloper, author, and life-long student. Writes online at\nhttps://rhonabwy.com/.\n\n#### Personal Links\n\n  * Rhonabwy\n\n#### Verified Services\n\nView Full Profile \u2192\n\n## Micro.blog\n\nMicro.blog\n\n## Archives\n\nRhonabwy, Blog at WordPress.com.\n\n  * Comment\n  * Reblog\n  * Subscribe Subscribed\n\n    * Rhonabwy\n    * Already have a WordPress.com account? Log in now.\n\n  * Privacy\n  *     * Rhonabwy\n    * Customize\n    * Subscribe Subscribed\n    * Sign up\n    * Log in\n    * Copy shortlink\n    * Report this content\n    * View post in Reader\n    * Manage subscriptions\n    * Collapse this bar\n\n%d\n\n", "frontpage": false}
