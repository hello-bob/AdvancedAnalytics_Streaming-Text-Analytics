{"aid": "40273571", "title": "Bob Reads a Text File", "url": "https://tastycode.dev/bob-reads-a-text-file/", "domain": "tastycode.dev", "votes": 1, "user": "gituliar", "posted_at": "2024-05-06 11:57:55", "comments": 0, "source_title": "Bob Reads a Text File", "source_text": "Bob Reads a Text File\n\nTastyCode\n\nSign in Subscribe\n\ncpp\n\n# Bob Reads a Text File\n\n#### Oleksandr Gituliar\n\nMay 1, 2024 \u2014 6 min read\n\nOne day Bob got a task to process a text file line by line. He decides to use\nC++, as he knows that not many languages out there can compete with its speed.\nAs C++ is still an uncouth beast for Bob, he decides to ask Google ChatGPT\nabout the most popular approach to read a file line by line in C++, to have\nsome initial code for start and avoid fluttering through the endless pages of\nC++ Standard Library documentation.\n\nBob is a junior developer with big ambitions. He is serious about his craft\nand reputation, so he really wants to make sure that his code is tasty \u2013 fast,\nelegant, and the best of its kind.\n\n\ud83d\udca1\n\nBob is happy to share his final code on GitHub in TextFileReader.h, which you\ncan use in your projects.\n\n## Read Lines \u2013 ChatGPT Solution\n\nWhen Bob asked Google ChatGPT for the most popular approach to read a file\nline by line in C++, the solution was based on std::getline() function from\nthe Standard Library.\n\nHere is exactly how proposed solution looked like:\n\n    \n    \n    #include <iostream> #include <fstream> #include <string> int main() { std::ifstream file(\"example.txt\"); // Open the file if (file.is_open()) { // Check if the file is opened successfully std::string line; while (std::getline(file, line)) { // Read each line of the file std::cout << line << std::endl; // Print the line } file.close(); // Close the file when done } else { // Print error message if file cannot be opened std::cerr << \"Unable to open the file.\" << std::endl; } return 0; }\n\nChatGPT's take on \"How to read a file line by line in C++ ?\"\n\nBob knows that ChatGPT solution is slow, because every line in this solution\nis returned by copy. Bob is going to fix this and find more optimal approach.\n\n## Read Lines \u2013 Tasty Solution\n\nBob found out that in C++, instead of a constant std::string object, that he\nhas no intention to modify, he can return std::string_view \u2014 a lightweight\nobject that was introduced in C++17 to avoid copying of constant strings.\nInternally, a std::string_view occupies only 16 bytes and contains two member\nfields:\n\n  * a pointer to the string\n  * a size of the string\n\nNext morning, after thinking before falling asleep, Bob has a concrete plan in\nhis mind that goes as following:\n\n0:00\n\n/0:37\n\nNotice how carefully Bob treats incomplete lines at the end of the buffer,\nwhich require special attention. He postpones these peculiarities for later.\nFor now, Bob is more concerned about how his class is supposed to be used by\nhis peers.\n\n### Usage Workflow\n\nBob knows that user experience and convenient public interface is as important\nas fast and safe code. Before starting to code, he wants to decide on how his\ncode will be used or how people call it \u2013 public interface.\n\nInstead of inventing a wheel Bob decides to follow a common usage pattern\nsuggested by ChatGPT, which goes along the following lines:\n\n    \n    \n    TextFileReader src; if (Error err = 1\ufe0f\u20e3 src.open(\"stocks_20240310.csv\"); !err.empty()) return err; Error err; while (2\ufe0f\u20e3 src.readline(err)) { // Process 3\ufe0f\u20e3 src.line() } if (!err.empty()) return err;\n\nProcess a text file by lines in C++\n\n1\ufe0f\u20e3 open() Usually, we start with opening the file given its path. This step\nmight fail for various reasons, hence Bob wants to indicate this. If an issue\noccurs he will return a string that describes it, for example \"File doesn't\nexist\" or \"Too many open files\". This is not the perfect way to indicate an\nerror, but he's fine with it for now.\n\n2\ufe0f\u20e3 readline() loop is identical to std::getline() except that we access a\ncurrent line with3\ufe0f\u20e3line(), which returns std::string_view to the internal\nbuffer. It's efficient as no copying happens.\n\nBob also finds it useful if his users can read a file in fixed-sized chunks,\nwithout splitting by a newline. Hence, he offers an alternative for steps 2\ufe0f\u20e3\nand 3\ufe0f\u20e3 that looks like this:\n\n    \n    \n    Error err; while (4\ufe0f\u20e3 src.read(err)) { // process 5\ufe0f\u20e3 src.buf(); }\n\nProcess a text file by fixed-size blocks in C++\n\n4\ufe0f\u20e3 read() takes next chunk of data into the internal buffer. We can read this\nbuffer with 5\ufe0f\u20e3TextFileReader::buf() method, which returns a lightweight\nstring view without copying.\n\n## Sign up for TastyCode\n\nReflections on Programming\n\nDon't miss new stories. No spam. Unsubscribe anytime.\n\n## TextFileReader in Depth\n\nFinally, as Bob has a more clear vision for his solution, it's now time to\nstart coding.\n\n### Core Methods\n\nreadline() method is a central point of the entire class. It defines what\nother methods and data members should the class contain. Intuitively, Bob\nknows that any other method is useless unless he has readline() ready.\n\nAfter about an hour of prototyping, he wraps everything into the following\nfive-step function:\n\n    \n    \n    bool TextFileReader::readline(Error& err) { do { // 1\ufe0f\u20e3 Find next \\n char if (const auto p = (c8*)memchr(m_buf + m_cursor, '\\n', m_size - m_cursor); p) { m_line = string_view(m_buf + m_cursor, p - (m_buf + m_cursor)); m_cursor = p - m_buf + 1; return true; } // 2\ufe0f\u20e3 No \\n found if (std::feof(m_src)) { m_line = string_view(m_buf + m_cursor, m_size - m_cursor); return m_cursor < m_size; } // 3\ufe0f\u20e3 Copy tail to the beginning if (m_cursor < m_size) { std::memcpy(m_buf, m_buf + m_cursor, m_size - m_cursor); } // 4\ufe0f\u20e3 Consume more data (do not update m_cursor) if (err = read(m_size - m_cursor); !err.empty()) { err = \"TextFileReader::readline : \" + err; return false; } } while (m_size); // 5\ufe0f\u20e3 We should have already returned false in \u2777 (indicating EOF) err = \"TextFileReader::readline : EOF\"; return false; };\n\nread() is a helper method that reads chunks of the text file into the internal\nbuffer. Bob implements it as following:\n\n    \n    \n    bool TextFileReader::read(Error& err, u64 pos = 0) { if (m_size = std::fread(m_buf + pos, 1, m_capacity - pos, m_src); !m_size) { if (std::ferror(m_src)) { err = \"Fail to read : errno = \" + std::to_string(m_size); return false } } m_size += pos; m_cursor = 0; return true; };\n\nBob believes that his users will find this feature useful. He exposes it as a\npublic method. However, simultaneously reading a file by chunks and by line\nbreaks internal state of his class. He makes sure to warn users about this in\nthe documentation:\n\n\ud83d\udca1\n\nMixed usage of read() and readline() is prohibited. You should call only one\nof them after the TextFileReader has been initialized.\n\n### Auxiliary Methods\n\nRemaining methods are responsible for managing resources: the FILE object and\nthe internal memory buffer, which should be allocated and deallocated. This is\nwhat open() and close() methods do.\n\nclose() call is optional. It will be called automatically by the destructor or\nopen() method, which reuses already allocated buffer to read a new file. This\nimproves usability and makes our class safer. It's a good example of the RAII\nidiom in action.\n\nAlice, Bob's more experienced colleague, suggest Bob to disable a default copy\nconstructor (or implement a custom one, but she believes this is an overkill\nfor this task). She says that a default copy constructor duplicates pointers\nto the internal buffer, but not the buffer itself. This eventually corrupts\ninternal state of the class when duplicated readers fill internal buffers from\nthe same FILE object.\n\n## Benchmarks\n\nBob is curious to compare his code against the std::getline approach proposed\nby ChatGPT. He creates a bunch of files with line length from 10 to 1'000 and\nnumber of lines from 1'000 to 1'000'000.\n\nSurprisingly, his code is at least 20x faster than std::getline, sometimes\nit's even 180x faster. \"Not bad for an amateur!\" \u2013 he shouts, proud of\nhimself.\n\n\"This is a good example of how important it is to benchmark your code and\noperate with concrete measurements when designing a final solution\" \u2013 he says\nto Alice.\n\n## Final Word\n\nI'm in a mood to write a philosophical summary. Given the context it might be\ninappropriate, but this is my blog after all, so if I can't be open here, how\ncan I expect the same from you and other readers ?\n\nThe moral of this story is not that we can read files 100x faster. (Of course\nthis is an important takeaway too.) The main point is to engineer your own\nsolutions even for very simple tasks, at least to think about a possible\nsolution. This is the most efficient way to learn \u2013 learn by doing. You can\nlearn C++ Standard by heart, but you'll never learn by heart how to engineer.\nThis is a practical skill and is earned by engineering your own way, even if\nthis is not the most efficient way with at first. Eventually, you'll improve,\nyour thinking will improve, and your code will improve.\n\nHave fun with code!\ud83d\ude0f\n\nTastyCode\n\nPowered by Ghost\n\n## TastyCode\n\nReflections on Programming\n\n", "frontpage": false}
