{"aid": "40094403", "title": "8 Months of Ruby", "url": "https://www.onoffswitch.net/p/8-months-of-ruby", "domain": "onoffswitch.net", "votes": 3, "user": "thunderbong", "posted_at": "2024-04-20 03:07:28", "comments": 0, "source_title": "8 months of Ruby", "source_text": "8 months of Ruby - by Anton Kropp - onoffswitch.net\n\n# onoffswitch.net\n\nShare this post\n\n#### 8 months of Ruby\n\nwww.onoffswitch.net\n\n#### Discover more from onoffswitch.net\n\nRamblings, musings, seg faults, and type systems. 10+ years of (mostly) tech\nmumbo jumbo\n\nContinue reading\n\nSign in\n\n# 8 months of Ruby\n\nAnton Kropp\n\nApr 15, 2024\n\n1\n\nShare this post\n\n#### 8 months of Ruby\n\nwww.onoffswitch.net\n\nShare\n\nFollowing in the vein of my last language retrospective, 8 months of Go, I\nwanted to share my experiences of working in Ruby for the last 8 months.\nDisclaimer: Ruby has never been my first choice of language, but like Go, I\u2019ve\ngone into this with an open mind.\n\nI\u2019ve played with Ruby on and off for 20 years (I wrote a rudimentary early\nversion of instagram back in 2003 in Ruby for friends and I really regret not\npursuing that more ha). Most often though I use Ruby for CI scripts because\nit\u2019s installed on machines by default and is better than shell scripting when\nit comes to slightly non trivial tooling.\n\nonoffswitch.net is a reader-supported publication. To receive new posts and\nsupport my work, consider becoming a free or paid subscriber.\n\nFor many years I shied away from taking jobs that used Ruby because... well\n... I like types! Why work in a language without them? My entire blog is\nbasically a paean of types. However, I don\u2019t like being afraid of something\nand I made a very conscious choice to work in an untyped language, be it\nPython or Ruby, for my next main job.\n\nI\u2019ll be honest, I don\u2019t hate it as much as I thought I would. There are some\nthings I really like about it actually and just much as that I don\u2019t like -\nsome expected and some new and unexpected!\n\nLet\u2019s start with the things I like.\n\n#\n\nPros\n\n###\n\nterse and expressive\n\nThis is Ruby\u2019s biggest sell - the fact that the language is terse, concise,\nand extremely expressive. In the hands of a power user it\u2019s actually fun. I\nlove the simple module and class syntax, writing abstractions feels almost\nlike when I\u2019m sketching code out... but it\u2019s runnable! This reminds me a lot\nof F#. I wrote an F# example once that read like like a sentence and a co-\nworker of mine was amazed that it wasn\u2019t just pseudocode, it was actual code\nthat did what the sentence said.\n\nI recently had to write some AST processing to transform a higher level DSL\ninto an elasticsearch query and Ruby made it extremely easy to build a nice\nlittle API to model boolean and query logic. It felt joyful!\n\n    \n    \n    def build(schema = nil) case @tree when And operator = @tree.not ? :must_not : :must { bool: { operator => @tree.terms.map do |term| QueryBuilder.new(term).build(schema) end, }, } when Or { bool: { should: @tree.terms.map do |term| QueryBuilder.new(term).build(schema) end, }, } ...\n\n###\n\ntransforming data is easy\n\nRuby comes with a lot of modern collection tooling. Dealing with maps, arrays,\nlazy iterators, it\u2019s all built in and easy to use. I love that you can make\nany class enumerable just by implementing the each function. Most of my day to\nday involves mapping, filtering, and slicing of collections - simple but\nobvious tasks that not every language makes easy to do. It\u2019s quite nice to\njust have it available, and I remember why Ruby made a big splash in the tech\nworld in the early 2000\u2019s and 2010\u2019s. It was a language that embraced\nmodernity and gave you the boilerplate free tooling to do what you need to do\nwithout a lot of overhead.\n\n###\n\nmeta programming is wildly powerful\n\nMessage passing is a concept that a lot of people struggle with, but I find it\nmakes more sense when you imagine it as an actor model of delegation. You can\ncall class A with method \u201cfoo\u201d and if it decides \u201cI don\u2019t want to handle this\u201d\nit can capture that and re-invoke something else instead for you. Neat. But\nwhy would you want to do this?\n\nWell, imagine you want to proxy all methods that start with elastic_ to the\nElastic processor and all methods that start with rds_ to the rds handler but\nhave it be composed and auto updated anytime anyone adds new methods? This is\nreally easy now\n\n    \n    \n    class Proxy def initialize(elastic, rds) @elastic = elastic @rds = rds end def method_missing(method_name, *args) case method_name when /elastic_.*/ @elastic.send(method_name, args) when /rds_.*/ @rds.send(method_name, args) end end end\n\nWild! You get basically a method invocation for any missing method and can do\nwhatever you want there.\n\nIn the right hands this is crazy powerful and allows for very expressive and\ninteresting code.\n\n###\n\nzeitwerk and rails\n\nI really like in the zeitwerk and rails model of not having to include\nimports. The forced naming convention of module namespaces map to directories\nand classes map to file names (all snake case) makes it really easy to find\nwhere things should be. Granted this isn\u2019t a problem in literally any other\nlanguage because IDE\u2019s manage all the imports and lots of languages require\nconvention based file locations, but its still nice in Ruby too.\n\nRails also has a lot of great extensions and utilities that I sort of don\u2019t\neven think about. I honestly don\u2019t know sometimes if methods I\u2019m calling are\nbecause of rails monkey patching or not, and to a certain extent I\u2019m not sure\nI care. Rails mostly just works and stays out of the way and that\u2019s fine with\nme.\n\n###\n\npry and the REPL\n\nNormally I prefer to do all my debugging in my IDE using attached breakpoints.\nI\u2019m a sucker for gutter icons and right clicking on a test to step into it.\nBut my work has moved to a model where we run all code in k8s remotely. This\nis kind of cool cause they can set up a bunch of pre-baked infra, and ensure\nconsistent runtime environments. However, remote debugging is often complex\nhere and in other languages this might be more frustrating. In Ruby though we\ncan just debug... via Ruby! You can drop into an effective debugger via the\npry shell by putting a binding.pry statement where you want the debugger to\npop up.\n\nYou can customize actions and script things as well, because it\u2019s all just\nRuby. The debugger is fully fledged, you can inspect locals, step into\nclasses, add more breakpoints, etc. I\u2019ve found it to be a pleasant, albeit\ndifferent, experience to what I\u2019m used to.\n\n###\n\nlibrary ecosystem\n\nRuby is like stefon - it\u2019s got everything. There seems to be a Gem that does\njust about anything you want, which is kind of nice. It reminds me a bit of\nthe Node ecosystem where there\u2019s a zillion packages to do a zillion things.\nRuby\u2019s seems a bit more slimmed down and curated, and the packages themselves\nseem to be higher quality than a majority of Node packages. I haven\u2019t wanted\nfor packages that do what I need in Ruby and it\u2019s been easy and painless to\nconsume them.\n\n###\n\nsorbet\n\nI couldn\u2019t help myself, I needed types anyways. Thankfully sorbet (from\nStripe) adds a meta layer of runtime and static checking to ruby projects. I\nremember when they were working on this back when I was at Stripe and I\u2019m glad\nthat it\u2019s been open sourced and is pretty widely used. Chime, Spotify, Stripe,\nand many others use Sorbet in production.\n\nSorbet is a pretty weak guarantee, and all things the same a bad type engine,\nbut for a language with zero types... sorbet is a life saver. Teams that\nembrace sorbet gain a lot of benefit if anything not having to do manual\nruntime checks of input arguments is a big time saver anyways.\n\n###\n\nrubocop\n\nI love linters. I used ESLint aggressive in the past and Rubocop is reasonably\nrobust for what it does. It has quite a few false positives though, but\noverall it\u2019s better than nothing. Also being able to format code with the\nlinter settings is a huge win, as I hate having formatting arguments. Just\nautomate it and be done.\n\n###\n\ndelegation for composition\n\nThis is just such a cool language feature, to be able to compose objects\ntogether and automatically proxy methods from one to another via\n\n    \n    \n    delegate :<the method to expose>, to: <some other object>\n\nWhich replaces writing\n\n    \n    \n    def proxy_method @some_object.proxy_method end\n\nIt\u2019s a small touch but this kind of composition is really effective as you can\nstart with a proxy and then later implement the method yourself and it\u2019s drop\nin compatible. Creating composition layering like this is super easy and\navoids a lot of the noisy boilerplate that other languages might have.\n\n###\n\nrspec\n\nRSpec is a test runner tool for Ruby and it reminds me a lot of Jest. For the\nmost part it\u2019s just easy and stays out of the way which is why I like it. I\u2019ve\nhad to write custom matchers a few times and it was trivial to extend RSpec\n(much simpler than Jest was) and overall does what I want with aplomb.\n\n#\n\nCons\n\nFair warning, there is a lot I don\u2019t like. \u0304\\\\_(\u30c4)_/ \u0304\n\n###\n\nno types\n\nI knew this one going in, so I can\u2019t really blame Ruby. But types are just so\nimportant to software it still hurts my brain to think that actual languages\ndon\u2019t have it. I get why Ruby happened, if you time travel to the last 90\u2019s\nthe prevailing languages were Java and C/C++. Talk about verbose monsters!\nGetting even a basic \u201chello world\u201d required tons of files, compilation, etc.\nThen forget about modern utilities like map or filter. Hell Java didn\u2019t have\nanything like that till their streams release with Java 8 till 2014!\n\nBut in the modern world this is a huge travesty to be missing types. Types are\na part of the meta information about the problem domain you are solving. They\nare information, and to wantonly discard it is short sighted. I could probably\nwrite a whole novel about why types are good, but I will just say that missing\ntypes (and bolting it on with Sorbet) makes for a very painful experience in\nthe real world, especially with larger projects, multiple developers, and\nactual real money at stake.\n\n###\n\nhash obsessed\n\nBack to the lack of types, Ruby loves its untyped hash bag. So much so that\nthere are tons of collection utilities to deal with it. I worked in Node for\nyears and the amount of times I used an untyped bag of object I could count on\none hand. It really just shouldn\u2019t need to be done. Granted Ruby has structs\nwhich allow you to create immutable paired data but a lot of people just don\u2019t\nuse them. But there are multiple flavors of structs - sorbet, dry-struct, ruby\nData object, and they all ... are slightly different!\n\nThis leads to people passing around untyped mutable object bags everywhere\nthat has god knows what in it, sometimes adding fields (or even worse removing\nfields!) through a call chain.\n\nReasoning about systems that overuse hashes is an exercise in futility. I\u2019m\njust too stupid to be a compiler, and so you have to step through code via\nunit tests which eats up endless amounts of limited time.\n\nHashes are fine when they are used as an informal object pairing inside of a\nfunction, or closed inside of a class (maybe) but exposing them as contract\nresults of an API bleeds more and more loose shenanigans through the system\nwhich begets brittle systems that are hard to maintain.\n\n###\n\nfractured type system (rbs vs sorbet/rbi)\n\nBut there is hope! In Ruby 3 they introduced type annotations via the RBS\nsyntax, similar to .h files in the C world. While this apparently isn\u2019t meant\nto be user-generated (it\u2019s supposed to be machine used) it\u2019s the start of the\nruby world moving to a place where types can at least be opt-in.\n\nHowever, this now creates a fractured world where a lot of the big players are\nusing sorbet but the language is moving to rbs. This isn\u2019t great for\nunification of things, and in fact I find that this fracturing is endemic in\nthe ruby world. There\u2019s 500 versions of things and everyone does stuff their\nown way.\n\n###\n\ndynamic exploration\n\nDue to the dynamic nature of Ruby (see some of the things I listed in pros)\nthe language service is not that great. Discovery of what methods or fields\nare available via just hitting the .<tab> in your IDE is often non-existent.\nGranted you sort of learn the fields and methods you use on the regular, but\nself discovery doesn\u2019t exist. You instead have to do a lot of reading of\nsource code, poking around in a REPL, and hoping that the human managed\ndocumentation is correct (often it\u2019s not).\n\nSince there\u2019s no compiler and there\u2019s no way to validate that anything you\nwrite is correct or not, the only way forward it to demand 100% code coverage.\nAny line not covered is a line that could blow up. This is a very stark\ncontrast to type checked languages where enforcing 100% coverage is a fools\nerrand - you end up writing tests that are mostly garbage just to satisfy the\nrequirement... oh wait, that happens in Ruby too! In fact, because you can\nliterally mock out the .new method on a class object people tend to skirt\ninversion of control and often mock (needlessly) just to get the coverage to\npass.\n\nUnfortunately this creates a false sense of security. Either you trust your\ntests or you don\u2019t, and if you don\u2019t then you end up afraid to make changes.\nTeams that are afraid to make changes won\u2019t be incentivized to make\nimprovements and the whole thing is self fulfilling.\n\n###\n\nimpossible to require contract adherence\n\nA lot of my complaints about Ruby are about contracts because contracts, and\nenforcement of contracts, is how you can support large scale teams and\nprojects with grace. Without being able to explicitly say \u201cyou cannot call me\nwithout filling this stuff in\u201d you end up in a world where people have to fail\nto explore (either tests failing or production failing). I would much rather\nlead people to water by not allowing their code to be valid until the\ncontracts are satisfied (compilers are great!). Just because something looks\nlike a duck and quacks like a duck doesn\u2019t make it a duck.\n\nNot being able to adhere to contracts also cripples semantic refactoring via\ntooling like in an IDE. If the IDE can\u2019t figure out that xyz uses abc then it\ncan\u2019t refactor things for you. This means that refactoring now all has to\nhappen by hand, which de-incentivizes the activity. That then means that doing\nthe organic cleanup that has to happen in a codebase often goes without, and\nas with all organic things code rots. If you make doing the right thing hard\nand time consuming, people won\u2019t do it. The easy thing has to be the right\nthing.\n\n###\n\nsorbet (generics, tapioca)\n\nI keep coming back to this because I want to believe so badly that sorbet is\ngoing to provide the guard rails and safety that I want but I have to accept\nthat it\u2019s a very poor mechanism and frankly not that robust. Unlike typescript\nwhich allowed libraries to bundle type definitions out of band sorbet has no\nway to bundle that data with a library. You end up having to use another tool\nfrom Shopify called tapioca to re-compile and scan the type annotations from\nall your Gems.\n\nThis means anytime you update a gem, you have to manually run some tooling. It\nalso forces your repo to house all the generated type information which\nfrankly should be hidden away in a Gem and not versioned in my repository.\n\nOn top of that sorbet has no way to validate any kind of generic or higher\nkinded type, so even trying to do basic signatures like\n\n    \n    \n    sig { params(data: T::Array[String]).void }\n\nis mostly useless because all sorbet can guarantee to you is that data is an\narray, but not an array of String.\n\nShapes is a nice thing of sorbet, allowing you to structurally type object\nbags, but it doesn\u2019t allow you to model missing fields and there is no concept\nof type narrowing (like with typescript). The end result is a lackluster\nexperience, especially having come from the insane powers of typescript.\n\nAt this point I have resigned that sorbet is yardoc++ with some runtime\nchecks. I still use it, because a large part of the time it is able to\nvalidate types but it really misses the mark on being actually fully fledged.\n\n###\n\nrails conventions outside of MVC\n\nI\u2019m on board with auto loading, and directory conventions with rails. What I\nfind to be particularly annoying though is that top level folders of rails\nprojects are automatically in the root namespace. What this means is you can\nhave logical data of a module split across mulitple disparate locations. For\nexample, this class\n\n    \n    \n    module Foo class Bar end end\n\ncan live anywhere in the following format /<root folder>/foo/bar.rb.\n\nWhy is this an issue? Well imagine you want to co-locate a module\u2019s\nread/write/entities/logic/etc. The rails folder structure with model,\ncontroller, etc is very much tied to an old school MVC idea.\n\nI find this makes it hard to properly organize your code because not\neverything slots in so neatly in the real world. Code is less organized by\nfunction and more by domain. I want to co-locate top level entrypoints like\nAPI handlers, but otherwise have things delegated to domain function. For\nexample:\n\n    \n    \n    /core /foo .. all the things foo needs /bar .. all the things bar needs /api .. calls things in core /db .. shared db things /common .. stuff everyone uses\n\nI know you can get this with rails but the fact that it forces a convention\nthat doesn\u2019t encourage your own folder modeling is frustrating. So you end up\nwith code in folders that doesn\u2019t quite make sense, and its split across\nunclear lines. Maybe this is a reflection of my personal experiences, but I\nhaven\u2019t ever dealt with this level of disorganization in other languages.\n\n###\n\nsymbols vs strings inconsistencies\n\nRuby in the old days didn\u2019t inter strings, so every instance of a hardcoded\nstring was a new allocation. Instead they had the concept of symbols, the\nfunky stuff with a leading colon: :this_is_a_symbol and is meant to basically\nact as a single instance of that \u201cstringlike\u201d object. Every where you see that\nsame symbol it\u2019s the same memory representation. That\u2019s fine, a nice clear\ndistinction! Use symbols as object keys/etc and strings to be strings.\n\nWell later Ruby decided that this was dumb, and now strings are automatically\nfrozen so that this distinction no longer matters. But what we are left with\nis inconsistent usages of when things are symbols and when things are strings.\nYou now often have hashes that intermix the two\n\n    \n    \n    { :symbol => { \"string\" => {} }, \"string2\" => {} }\n\nWhich makes your object pattern access wildly inconsistent. To work around\nthis people often deep_stringify_keys or deep_symbolize_keys and then sprinkle\non .to_s or .to_sym to access keys and get results. This just adds more feed\nfor the fodder about ruby being slow since we\u2019re iterating on objects and\nconverting things to work around shape nuisances.\n\nI\u2019ve seen so many failed instances in production due to string/symbol\ninconsistencies its amazing this is something a language allows you to do.\n\nI\u2019m sure that the argument is \u201cif you know what you are doing you you can\ncreate nice API\u2019s and be consistent\u201d but in the real world most people don\u2019t\nknow what they are doing and need guardrails to make sure they do the right\nthing.\n\n###\n\nslow\n\nRuby is just slow. Time and time again I\u2019m shocked at how slow it is when you\nstart to throw real data at it. If you have to process a few thousand items\nbut loop over them a couple of times (really trivial honestly) the time can\nstart to creep up.\n\nI recently had a situation where we had to process 10k items, which included\nmapping them once, running each item item through a string template, and then\nserializing it all to JSON. This process took over 20 seconds. After doing\nbenchmarking I found that all the time was just spent in ruby iteration time,\nso there was very little I could do to speed this process up.\n\nUsually I don\u2019t care that things are slow, but this was... hilariously slow.\nDoing the same thing in node, or go, or java, would have taken milliseconds.\n\n###\n\nprocs and lambda gotchas\n\nI don\u2019t know if I\u2019m missing something or if this is due to a side effect of\nimplementation, but requiring to .call a lambda or a proc really makes it\nannoying to pass around. This forces a distinction between a function, method,\nor proc/lambda and that nuance isn\u2019t necessary in any other language or\necosystem. I\u2019m not sure what the reasoning there is.\n\nOn top of that the various return semantics of procs vs lambdas is convoluted\nwhere in one model it returns from the lambda itself (like every other\nlanguage in the world) and in another it forces a return call of the\npattern... which is weird. This variance continues to illustrate the lack of\nconsistency in the Ruby world where there\u2019s a nuanced flavor of everything but\nno coherence in language design. It\u2019s almost like they did it because they\ncould.\n\n###\n\ncase when pattern matching... sort of\n\nThe case statement is pretty cool allowing you to do some basic pattern\nmatching in ruby as I illustrated earlier in the method missing example. But\ndeep down inside this works by abusing a triple equals operator, which makes\nthe case statement both powerful (in that you can customize this behavior) and\ninsane (in that it\u2019s not discoverable at all that this is what drives the\nbehavior). Often I reach for a case statement but find that the triple equals\nof the thing I\u2019m comparing doesn\u2019t work and I\u2019m forced to do an ugly if tree.\n\n#\n\nConclusion\n\nGiven the choice would I choose Ruby to build anything on my own? Definitely\nnot. But would I accept a job where they work in Ruby? If the bar was high,\nthe team philosophies matched mine, and the product (and compensation) was\nstellar I would. But all things being equal I think I\u2019ll stick to typed\nlanguages - kotlin, typescript, java, go, c#, etc.\n\nRuby was an extremely attractive, modern, option in 2015 but now feels like a\npoorly curated frankenstien and I keep bumping up into these rough edges which\ntakes the joy out of the things that are joyful in Ruby.\n\nonoffswitch.net is a reader-supported publication. To receive new posts and\nsupport my work, consider becoming a free or paid subscriber.\n\n1 Like\n\n1\n\nShare this post\n\n#### 8 months of Ruby\n\nwww.onoffswitch.net\n\nShare\n\nComments\n\nChallenges with data\n\nModeling is hard\n\nJan 30 \u2022\n\nAnton Kropp\n\n1\n\nShare this post\n\n#### Challenges with data\n\nwww.onoffswitch.net\n\nMusings about \"On Call\"\n\nIn the cloud enabled world where everything runs 24/7 someone behind the\nscenes is usually on the hook to make sure that when things break off hours...\n\nFeb 19\n\n2\n\nShare this post\n\n#### Musings about \"On Call\"\n\nwww.onoffswitch.net\n\nTyped pubsub\n\nDealing with circular dependencies\n\nMar 18 \u2022\n\nAnton Kropp\n\nShare this post\n\n#### Typed pubsub\n\nwww.onoffswitch.net\n\nReady for more?\n\n\u00a9 2024 Anton Kropp\n\nPrivacy \u2219 Terms \u2219 Collection notice\n\nStart WritingGet the app\n\nSubstack is the home for great culture\n\nShare\n\n## Create your profile\n\n## Only paid subscribers can comment on this post\n\nAlready a paid subscriber? Sign in\n\n#### Check your email\n\nFor your security, we need to re-authenticate you.\n\nClick the link we sent to , or click here to sign in.\n\n", "frontpage": false}
