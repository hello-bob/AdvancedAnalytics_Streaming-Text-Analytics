{"aid": "40186919", "title": "Three ways of handling user input (2022)", "url": "https://dubroy.com/blog/three-ways-of-handling-user-input/", "domain": "dubroy.com", "votes": 1, "user": "stcucufa", "posted_at": "2024-04-28 08:06:46", "comments": 0, "source_title": "Three ways of handling user input", "source_text": "Three ways of handling user input\n\nPatrick Dubroy\n\n# Three ways of handling user input\n\nJanuary 5, 2022\n\n> Although there has been important progress in models and packages for the\n> output of graphics to computer screens, there has been little change in the\n> way that input from the mouse, keyboard, and other input devices is handled.\n> New graphics standards are still using a fifteen-year-old model even though\n> it is widely accepted as inadequate.\n\n\u2014 Brad Myers, A New Model for Handling Input, 1990.\n\nIt\u2019s 2022 and things are pretty much the same: the dominant way of handling\nuser input is still based on events and \u2014 in some form or another \u2014 callbacks.\nThey come in slightly different forms (addEventListener, responder objects,\netc.) but the core idea is the same.\n\nIt\u2019s still going strong more than 40 years later, so the event-and-callback-\nbased approach clearly has something going for it. But in nearly every code\nbase I\u2019ve worked in, the hairiest, most difficult-to-modify logic is in the\nevent handling code. Handling user input is \u2014 to borrow a phrase from Laurence\nTratt \u2014 a solved problem that isn\u2019t.\n\nTo help me understand the pros and cons of the events-and-callbacks model and\nto experiment with some other approaches, I decided to write up a simple\nexample in a three different styles.\n\n## A toy problem\n\nThe goal is to implement a square that you can either drag and drop, or click.\nThe code should distinguish between the two gestures: a click shouldn\u2019t just\nbe treated as a drop with no drag. Finally, when you\u2019re dragging, pressing\nescape should abort the drag and reset the object back to its original\nposition.\n\nHere\u2019s an interactive demo. There are at least two bugs here \u2014 see if you can\nfind them! \ud83d\ude01\n\n## Approach #1: Event listeners\n\nAs a baseline, let\u2019s start with the standard approach based on event\nlisteners.\n\n    \n    \n    const draggable = document.getElementById(\"myObject\"); const setStatus = (str) => (document.getElementById(\"status\").textContent = str); let didDrag = false; let dragOrigin; let origPos; draggable.addEventListener(\"pointerdown\", (evt) => { evt.target.setPointerCapture(evt.pointerId); dragOrigin = { x: evt.clientX, y: evt.clientY }; const { left, top } = draggable.getBoundingClientRect(); origPos = { left, top }; didDrag = false; }); draggable.addEventListener(\"pointermove\", (evt) => { if (dragOrigin) { didDrag = true; const deltaX = evt.clientX - dragOrigin.x; const deltaY = evt.clientY - dragOrigin.y; draggable.style.left = `${origPos.left + deltaX}px`; draggable.style.top = `${origPos.top + deltaY}px`; setStatus(\"dragging...\"); } }); draggable.addEventListener(\"pointerup\", (evt) => { dragOrigin = undefined; if (didDrag) { setStatus(\"Dropped!\"); } else { setStatus(\"Clicked!\"); } }); window.addEventListener(\"keydown\", (evt) => { if (evt.key === \"Escape\") { dragOrigin = undefined; draggable.style.left = `${origPos.left}px`; draggable.style.top = `${origPos.top}px`; setStatus(\"Cancelled!\"); } });\n\nThere are slightly nicer/cleaner ways to implement this, but I think this is\npretty good as a representative example. Note that I\u2019m using the pointerdown\nrather than mousedown so that I can take advantage of pointer capture.\n\nTaking a look at it with a critical eye, the first thing that sticks out is\nthe shared state that\u2019s used by all of the event handlers:\n\n  * didDrag keeps track of whether any pointermove event occurred, so we can distinguish between a drag and a click\n  * dragOrigin records the position where the drag gesture started, and doubles as a way of checking whether the mouse is currently down.\n  * origPos holds the original position of the target object, so we can reset it if the drag is canceled.\n\nOne thing I dislike a bit about the callback-based approach is how the control\nflow is mostly implicit. You can \u201cjump into\u201d control at many parts of the\ncode, and the order of the handlers is purely determined by the order that the\nevents arrive.\n\nCan you spot the problem with the pointerup handler, that causes the bugs that\nI mentioned above?\n\n## Approach #2: Polling\n\nAnother way to handle user input is polling, or periodically checking the\nstate of the hardware. The original Smalltalk MVC used this approach, and it\u2019s\nstill used in game programming.^1 I don\u2019t think I\u2019ve ever written any code\nthat used polling for handling user input, so I wanted to at least give it a\ntry.\n\nBelow is a polling-based version of the same example from above. I\u2019ve left out\nthe helper code that takes care of updating the mouse and keyboard variables\nusing the standard DOM events.\n\n    \n    \n    let didDrag = false; let didHandlePointerDown = false; let dragOrigin; let origPos; const rectContains = ({ top, right, bottom, left }, x, y) => left <= x && x <= right && top <= y && y <= bottom; (function handleFrame() { if (mouse.buttons[0].pressed) { const { clientX, clientY } = mouse.location; const draggableRect = draggable.getBoundingClientRect(); if ( !didHandlePointerDown && rectContains(draggableRect, clientX, clientY) ) { // Handle pointerdown dragOrigin = { x: clientX, y: clientY }; origPos = { left: draggableRect.left, top: draggableRect.top, }; didDrag = false; } // Ensure that we only act on pointerdown action in the // first frame that we detect that the button is pressed. didHandlePointerDown = true; if ( dragOrigin && (clientX !== dragOrigin.x || clientY !== dragOrigin.y) ) { // Handle pointermove didDrag = true; const deltaX = clientX - dragOrigin.x; const deltaY = clientY - dragOrigin.y; draggable.style.left = `${origPos.left + deltaX}px`; draggable.style.top = `${origPos.top + deltaY}px`; setStatus(\"dragging...\"); } } else if (dragOrigin) { // Handle pointerup dragOrigin = undefined; if (didDrag) { setStatus(\"Dropped!\"); } else { setStatus(\"Clicked!\"); } } else { didHandlePointerDown = false; } if (dragOrigin && keyboard.keys[\"Escape\"].pressed) { // Handle keypress dragOrigin = undefined; draggable.style.left = `${origPos.left}px`; draggable.style.top = `${origPos.top}px`; setStatus(\"Cancelled!\"); } requestAnimationFrame(handleFrame); })();\n\nConceptually, polling is a pretty simple approach, but it imposes a fair bit\nof extra complexity on the handling code. For one thing, I needed\ndidHandlePointerDown so that it only reacts once when the mouse button is\npressed, rather than on every frame. I also needed to do my own hit testing\nwith rectContains. This is one downside of polling \u2014 you need to implement\nextra bookkeeping for some things that you get for free in an event-based\nmodel.\n\nOf course, the major drawback of polling is that you always need to be\nchecking for state changes. This consumes CPU cycles, and if it\u2019s not frequent\nenough, you can miss some user input. That\u2019s why it\u2019s not seen much anymore\noutside game programming, where you typically have an active rendering loop\nanyways.\n\nOn the plus side, the control flow is more explicit when compared to the event\nlistener approach. For example, the code that handles cancellation will always\nrun after any other other handler in the same frame. We do still need to be\ncareful not process a pointerup without a corresponding pointerdown, as those\nwould always be handled in separate frames.\n\nAnother thing that\u2019s nice here is that you basically have unrestricted access\nto the current state of the input devices, whereas in the callback-based\nmodel, it\u2019s less convenient to do something like looking at the current mouse\nposition inside the keydown handler. DOM events hack around this limitation by\nincluding some keyboard state in the MouseEvent instances (altKey,ctrlKey,\netc.), but that only addresses the most common cases.\n\nWith polling, not only do you have more flexibility in where you examine the\ninput state, but also when you examine it. With events, there\u2019s an inversion\nof control: the event dispatch mechanism determines when (and if) each\ncomponent observes the state change. This can be limiting, but it\u2019s also a\nhuge benefit for composability, as it enables loosely-coupled coordination\nbetween parent and child components (e.g. event delegation). I don\u2019t know how\nyou could achieve the something similar in polling-based model.\n\n### Hybrid models\n\nAfter reading the first draft of this post, a few people mentioned event-based\napproaches that feel somewhat similar to the polling approach. For example,\nyou could have a single callback that handles all the events, rather than a\nseparate callback for each event.\n\nThis gives you all the advantages of events, while making the control flow a\nbit more explicit (as with the polling approach), and making it easier to\nshare state and code between the different paths.\n\n## Approach #3: Process-oriented\n\nThe third approach I wanted to try is inspired by Squeak: a Language for\nCommunicating with Mice, by Luca Cardelli and Rob Pike. The core idea is that\nconcurrent, communicating processes are a good way to model user interaction.\nNote that process here doesn\u2019t mean an OS-level process; it means a\nlightweight, sequential thread of control, like a goroutine or a Ruby fiber.\n\nTo experiment with these ideas in JS, I built a tiny library called Abro.js^2\nwhich provides some slightly higher-level abstractions on top of async and\nawait. The result looks a lot more like the Esterel language than Squeak.\n(Esterel was also an inspiration for Cardelli and Pike.)\n\nHere\u2019s a working implementation based on Abro:\n\n    \n    \n    const draggable = document.getElementById(\"myObject\"); const setStatus = (str) => (document.getElementById(\"status\").textContent = str); const events = new abro.EventSource(draggable); const windowEvents = new abro.EventSource(window); abro.loop(async () => { // Control will block on this line until pointerdown happens. const downEvent = await events.pointerdown; \ud83d\udc48 1\ufe0f\u20e3 downEvent.target.setPointerCapture(downEvent.pointerId); const { left, top } = draggable.getBoundingClientRect(); const origPos = { left, top }; let didDrag = false; // `abro.or` starts multiple fibers, and completes as soon as *one* // of them completes (the others are terminated). await abro.or( \ud83d\udc48 2\ufe0f\u20e3 async function handleDrag() { // An infinite loop? Abro will terminate this fiber when either // `handlePointerUp` or `handleEscape` is done. while (true) { \ud83d\udc48 3\ufe0f\u20e3 const { clientX, clientY } = await events.pointermove; didDrag = true; const deltaX = clientX - downEvent.x; const deltaY = clientY - downEvent.y; draggable.style.left = `${origPos.left + deltaX}px`; draggable.style.top = `${origPos.top + deltaY}px`; setStatus(\"dragging...\"); } }, async function handlePointerUp() { await events.pointerup; if (didDrag) { setStatus(\"Dropped!\"); } else { setStatus(\"Clicked!\"); } }, async function handleEscape() { let key; while (key !== \"Escape\") { ({ key } = await windowEvents.keydown); } draggable.style.left = `${origPos.left}px`; draggable.style.top = `${origPos.top}px`; setStatus(\"Cancelled!\"); } ); });\n\nYou can also try this version out:\n\nBefore getting into the details, let me explain the basics of Abro:\n\n  * Each process (or fiber) is an async function that can block until an event arrives from an EventSource. For example, control will block at 1\ufe0f\u20e3 \u21a9 until a pointerdown occurs.\n  * Unlike regular async functions, Abro fibers can be cleanly terminated from the outside. I do this by keeping track of the promise that each fiber is blocked on, so it can be terminated by rejecting that promise.\n  * abro.or (see 2\ufe0f\u20e3 \u21a9) starts multiple fibers, and as soon as one of them completes, the others are terminated. It\u2019s based on the par/or construct in C\u00e9u, another Esterel-inspired language.\n  * The ability to terminate fibers from the outside makes it possible to write loops with no explicit exit condition (see 3\ufe0f\u20e3 \u21a9), as long as they block somewhere within the loop.\n\nIf you\u2019re interested, you can take a look at Abro on GitHub, but be warned \u2014\nit\u2019s very much a work in progress.\n\nThis first thing to notice with this approach is the clear, explicit\nsequencing between the different states. The first line of the loop blocks on\na pointerdown event; the other handlers aren\u2019t even active until control\nproceeds past that point^3.\n\nThe other thing I really like is the separation of concerns that\u2019s enabled by\nthe or construct along with the ability to abort individual threads of\ncontrol. Take a close look at handleDrag \u2014 it\u2019s just an infinite loop that\nprocesses pointermove events. It doesn\u2019t need to be concerned with\ncancellation, that happens automatically when the handleEscape task completes.\nAlso, since this is built on top of events, we can still take advantage of\nevent bubbling and other forms of coordination between a container and its\ndescendants.\n\nOverall, I find the process-oriented approach to be pretty compelling. It\nseems to retain all the advantages of the event-driven model (e.g., in\ncomparison to polling), while improving on some of the issues that callbacks\nhave. I\u2019m definitely interested to try it out in some more realistic use\ncases.\n\nI found it really useful to work through a toy problem with a few different\napproaches. Comparing event listeners to polling made it much easier for me to\nsee the pros and cons of each style. The advantages of events (and event\ndispatch) are much more obvious to me now, and I realized that polling isn\u2019t\nreally as simple as it sounds.\n\nOf course, the three styles I\u2019ve presented here are just a starting point, and\nthere are many other approaches that I haven\u2019t touched on. There are two in\nparticular that I want to briefly mention:\n\n  * Statecharts are closely related to the process-oriented model I\u2019ve explored here. The original statecharts paper references Esterel, saying: \u201cIt is motivated by concerns very similar to our own, and many of the resulting decisions taken there are strikingly similar to those present in statecharts.\u201d There\u2019s enough to unpack there that I decided to leave it for a follow-up post.\n  * Functional reactive programming (FRP), and related approaches like RxJS. I don\u2019t have much experience with FRP, but I really should give it a try. Maybe another topic for a future post!\n\nCheck out Part II, where I dig into the implementation details of Abro.js, and\nexplore the process-oriented approach a bit more deeply.\n\n\ud83d\udcac Want to leave feedback? Send me an email or respond on on Twitter.\n\nThanks to Mariano Guerra, Sarah GHP, and Kevin Lynagh for providing feedback\non my drafts.\n\n  1. While researching this post, I discovered that the web platform Gamepad API is designed around polling. \u21a9\n\n  2. ABRO is the standard \u201chello world\u201d example for Esterel. \u21a9\n\n  3. This could also be accomplished with event listeners, by only adding the pointermove and pointerup listeners after the pointerdown event occurred. However, this adds complexity: we\u2019d need to be sure to remove the listeners no matter how the gesture ended (cancelation, or successful drop/click). It also results in tightly coupled logic between the handlers. \u21a9\n\nPssst! I'm working on a book called WebAssembly from the Ground Up. It takes\nyou from hand crafting bytecodes to writing a real compiler for a simple\nprogramming language. If you're interested in WebAssembly, you should\ndefinitely check it out.\n\n\u00a9 2006\u20132024 Patrick Dubroy \u00b7 Powered by Butterbrezn and Augustiner.\n\nSubscribe: RSS \u00b7 email\n\n", "frontpage": false}
