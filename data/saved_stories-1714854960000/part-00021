{"aid": "40257276", "title": "Glue: The Dark Matter of Software (2021)", "url": "https://blog.metaobject.com/2021/06/glue-dark-matter-of-software.html", "domain": "metaobject.com", "votes": 1, "user": "mpweiher", "posted_at": "2024-05-04 12:49:00", "comments": 0, "source_title": "Glue: the Dark Matter of Software", "source_text": "metablog: Glue: the Dark Matter of Software\n\nskip to main | skip to sidebar\n\n# metablog\n\n## Wednesday, June 9, 2021\n\n### Glue: the Dark Matter of Software\n\n\"Software seems 'large' and 'complicated' for what it does\". I keep coming\nback to this quote by Alan Kay.\n\nThe same feeling has been nagging me pretty me much ever since I started\nwriting software. On the one hand, there is the magic, almost literally: we\nwrite some text (spells) and the machine does things in the real world. On the\nother hand, it seems just way too much work to make the machine do anything\nmore complex than:\n\n> 10 PRINT \"Hello\" 20 GOTO 10\n\nAlmost like threading a needle with boxing gloves. And that's even if we are\ncareful, if we avoid unnecessary complexity.\n\nAnd the numbers appear to back that up, Alan Kay mentions Microsoft office at\nseveral hundred million lines of code. From my personal experience, the\nWunderlist iOS client was not quite 200 KLOC. For the latter, I can attest to\nthe attention given by the team to not introduce unnecessary bloat, and even\nto actively reduce it. (For example, we cut our core code by around 30KLOC\nthanks to some of the architectural mechanisms such as Storage Combinators). I\nam fairly sure I am not the only one with this experience.\n\n> hexagonal architecture has enabled me to extract the business logic in the\n> product i\u2019m building and currently it\u2019s less than 5% of all code\n>\n> \u2014 3. life out of balance (@infinitary) November 25, 2017\n\nSo why so much code? After all Wunderlist was just a To Do List, albeit a\nreally nice one. I can't really say much about Office, I don't think anyone\ncan, because 400 MLOC is just way too much code to comprehend. I think the\nanswer is:\n\nGlue Code.\n\nIt's the unglamorous, invisible code that connects two pieces of software,\nmakes sure that data that's in location A reaches location B unscathed (from\nthe datbase to the UI, from the UI to the model, from the model to the backend\nand so on...). And like Dark Matter, it is invisible and massive.\n\nWhy do I say it is \"invisible\"? After all, the code is right there, isn't it?\nAs far as I can tell, there are several related reasons:\n\n  1. Glue code is deemed not important. It's just a couple of lines here, and another couple of lines over there ... and soon enough you're talking real MLOCs!\n  2. We cannot directly express glue code. Most of our languages are what I call \"DSLs for Algorithms\" (See ALGOL, the ALGOrithmic Language), so glue can not be expressed intentionally, but only by describing algorithms for implementing the glue.\n\nThat's why it is invisible, and also partly why it is massive: not being able\nto express it directly means we cannot abstract and encapsulate it, we keep\nrepeating slight variations of that glue. There is another reason why it's\nmassive:\n\n  3. Glue is quadratic. If you have N features that interact with each other, you have O(N2) pieces of glue to get them to talk to each other.\n\nThis last point was illustrated quite nicely by Kevin Greer in a video\ncomparing Multics and Unix development, with the crucial insight being that\nyou need to \"program the perimeter, not the area\":\n\nFor him, the key difference is that Unix had the pipe, and I would agree. The\npipe is one-character glue: \"|\". This is absolutely crucial.\n\nIf you have to write even a little custom code every time you connect two\nmodules, you will be in quadratic complexity, meaning that as your features\ngrow your glue code will overwhelm the core functionality. And you will only\nnotice this when it's far too late to do anything about it, because the\ninitial growth rate will be low.\n\nSo what can we do about it? I think we need to make glue first class so we can\nactually write down the glue itself, and not the algorithms that implement the\nglue. Once we have that, we can and hopefully will create better kinds of\nglue, ones like the Unix pipe in that they can connect components generically,\nwithout requiring custom glue per component pair.\n\nUPDATE\n\nThere were some questions as to what to do about this. Well, I am working on\nit, with Objective-S, and I write fairly frequently on this blog (and\noccasionally submit my writing to scientific conferences), one post that would\nbe immediately relevant is: Why Architecture Oriented Programming Matters.\n\nI also don't see Unix Pipes and Filters as The AnswerTM, they just demonstrate\nthe concept of minimized and constant glue. Expanding on this, and as I wrote\nin Why Architecture Oriented Programming Matters, I also don't see any one\nsingle connector as \"the\" solution. We need different kinds of connectors, and\nwe need to write them down, to abstract over them and use them natively. Not\nsimulate everything by calling procedures, methods or functions. See also\nFoxes vs. Hedgehogs.\n\nPosted by\n\nMarcel Weiher at\n\n10:43 AM\n\nEmail ThisBlogThis!Share to TwitterShare to FacebookShare to Pinterest\n\n#### 14 comments:\n\nS\u00eenic\u0103 said...\n\n    \n\nThere ideas like executable choreographies (swarm communication) intended to\nbe glue code at the integration level of the systems. Unfortunatly systems\nstart small and dont need choroegraphies and when they become big is too\nlate...\n\n    June 9, 2021 at 7:41 PM\n\noblinger said...\n\n    \n\nsounds promising.\n\nI have thought alot about this issue, and come to believe that a core aspect\nof the problem is need for \"impedence matching\" that so often is the complex\npart of the glue code. If there are multiple ways of encoding a thing, then\nglue code is often used to convert between. but if the components themselves\nwere constructed of common representations/implementations of common concepts,\nthen the logic of conversion would be quite small or non-existent.\n\n    June 13, 2021 at 8:40 AM\n\nMarcel Weiher said...\n\n    \n\n@oblinger: Yes, absolutely. This is generally referred to as Architectural\nmismatch. Paper from 1994. In 2009, they penned a follow-up: Architectural\nMismatch: Why Reuse is Still So Hard. Essentially nothing had changed, and I\nwould say the same is true now.\n\nOne particularly pernicious form of mismatch is the one between the systems we\nwant/need to build and the languages we build them with. For GUI systems, this\nwas described in-depth by Chatty: Programs = Programs = Data + Algorithms +\nArchitecture: consequences for interactive software engineering\n\nMore generally, I call it The Gentle Tyranny of Call/Return\n\n    June 13, 2021 at 11:08 AM\n\nKevin G. R. Greer said...\n\n    \n\nI think I've created the modern equivalent of the pipe:\nhttps://www.youtube.com/watch?v=S4LbUv5FsGQ\n\n    June 13, 2021 at 2:24 PM\n\nbeders said...\n\n    \n\nAre you aware of Lisp?\n\n    June 13, 2021 at 8:46 PM\n\nUnknown said...\n\n    \n\nIn 2002, as part of my IEEE Internet Computing column called \"Toward\nIntegration\", which was generally about distributed systems and distributed\nmiddleware glue, I published a column about a very similar notion of software\ndark matter:\n\nhttps://steve.vinoski.net/pdf/IEEE-Middleware_Dark_Matter.pdf\n\nand again in 2004:\n\nhttp://steve.vinoski.net/pdf/IEEE-Dark_Matter_Revisited.pdf\n\nI agree with you that \"dark matter\" is a great term for this sort of code.\n\n    June 14, 2021 at 4:37 PM\n\nMarcel Weiher said...\n\n    \n\n@Keving Greer:\n\nHi Kevin,\n\nthanks for stopping by, big fan!\n\nFOAM is neat, but I don't actually think it, or \"modeling\" in general is\neither (a) equivalent to a connector or (b) a long term solution.\n\nExplaining why this is the case will probably take at least another blog post\n(which I do have lined up somewhere), but briefly the benefits of modelling,\nhaving a representation that you can act on intellegently (the \"model\" is\ndata) is just an artefact of current practice that isn't necessary and can be\novercome.\n\nAfter all, for the compiler the program syntax is also just data. And with\nforms of metaprogramming other than code generation, you can achieve the same\nkind of benefits, without the significant drawbacks of code generation.\n\nPractice bears this out. I've encountered some systems that were modelled to a\nsignificant degree. They all suffered tremendously from it.\n\nBut there are obviously some good and important ideas there. Longer discussion\n:-)\n\n    June 14, 2021 at 4:44 PM\n\nMarcel Weiher said...\n\n    \n\n@beders:\n\nYes.\n\nLonger answer: you might have noticed the domain of this blog\n\"metaobject.com\". That's actually a homage to the book The Art of Metaobject\nProtocol. So no, I don't think LISP fundamentally solves these problems,\ndespite having some useful features.\n\n    June 14, 2021 at 4:47 PM\n\nDan O said...\n\n    \n\n@beders:\n\nLISP was also my first thought. After all Marcel did say the issue was making\nglue code a 'first class' object. And we all know that lisp makes all code\nfirst class objects.\n\nBut this does not go to (my understanding) of the issue he is aiming at:\n\nThe languages we presently have, are not designed specifically for the\nconstruction of glue, yet (it seems to me) glue is a particular kind of code\n(and there is alot of it), thus it could be amenable to designing a language\nthat make such code very compact.\n\n    June 14, 2021 at 6:11 PM\n\nMarcel Weiher said...\n\n    \n\n@Steven:\n\nThanks for pointing me to your articles, I hadn't seen them before...and\ncertainly would have referenced had I been aware. Very interesting, and\nstraight up my alley, if more specific to distributed programming. I guess my\npoint would be that many of the same issues actually apply to local\nprogramming as well.\n\nI really like the following quote from one of your other articles: \"We have a\ngeneral-purpose imperative programming-language hammer, so we treat\ndistributed computing as just another nail to bend to fit the programming\nmodels.\"\n\nThat, in spades. And extended to all call/return languages. Erlang's \"a ! Pid\"\nsyntax for async messaging is certainly is one escape from the Gentle Tyranny\nof Call/Return, but I think we need to be able to define our own. Which we\ntypically can with procedures/functions, but not with non-procedural\nmechanisms, when those are even provided.\n\n    June 15, 2021 at 9:35 AM\n\nDan O said...\n\n    \n\n@marcel:\n\nThanks for the pointer. I read the referenced article ``arch mismatch is still\nhard''. I agree. I see value (in the abstract) in developing a language that\nis adapted toward being 'glue code' I wonder if there is a universal language\nfor such, or if it will be glue-code for X and a different one for domain Y?\n\nI have a complementary approach. If all components within an ecosystem were\nbuilt from components that were so simple, they could not be simpler, then\nthey would tend towards compatibility since they used the same sub components\nwhen doing similar things.\n\nMy thought is to have a collection of paradigms in a dependency DAG of\nparadigms. This way each new API within the ecosystems naturally ends up\nreusing many common sub paradigms.\n\nIt is analogous to the way that JSON became so ubiquitous.. it was just a very\nparsimonious way of encoding structured data. It seems one could build a web\n(DAG) of components which each were as simple as possible given the rest of\nthe DAG.\n\nHard to articulate in a comment... but it seems quite relevant to your quest\nof simplifying glue code.\n\n    June 16, 2021 at 11:27 AM\n\nMarcel Weiher said...\n\n    \n\nSounds interesting, would love to hear more! Do you have a link?\n\nAnd yes, connectors and components are very much complementary. Of course the\ntricky part is the \"could not be simpler\". :-)\n\nAnd yes, this conversation is probably a bit tricky to have in comments...you\ncan reach me at marcel (at) metaobject.com, or Twitter (link is in the\nsidebar), LinkedIn, etc.\n\n    June 16, 2021 at 4:29 PM\n\nWJHau said...\n\n    \n\nI think the only way to solve this is via standardisation (which happens 100\nyears ago during the industrial revolution), we are probably at the same kind\nof period back then, where every mechanical manufacturer has their own nuts\nand bolts, sockets etc.\n\nWhat we need to do now is to standardise semantical data, especially for data\nthat keeps recurring in almost any field, for example\nauthentication/authorisation related data.\n\nAnd slowly the more we standardise, the less glue code (back then, adapters)\nwe will need to build.\n\n    July 20, 2021 at 6:07 PM\n\nUnknown said...\n\n    \n\nNice article speaking about the \"glue code\" and comparing it to the dark\nmatter.\n\nFor me it is not the necessity for avoiding this \"glue code\". I don't even\nthink that is good to search for an abstract definition language.\n\nWhat is important to distinguis always between business/algorithm code and\nwhat is glue code.\n\nGlue code should be understandable easily.\n\nIt should be possible to throw away glue code without loosing business rules.\n\nIf always the same or similar glue code is used, then it is necessary to think\non abstracting this glue code. But this does not immediately happen with the\nthird occurence as usual for duplicating code. If I have an interface class\nwith for example 50 methods and each containing 20 lines of code, then we have\n1000 lines of glue code and this is ok as long as it is code simply to\nunderstand.\n\nArne\n\n    September 10, 2021 at 9:36 AM\n\nPost a Comment\n\nNewer Post Older Post Home\n\nSubscribe to: Post Comments (Atom)\n\n## Also read\n\n## Followers\n\n## Blog Archive\n\n  * \u25ba 2024 (1)\n\n    * \u25ba January (1)\n\n  * \u25ba 2023 (3)\n\n    * \u25ba June (1)\n    * \u25ba May (1)\n    * \u25ba January (1)\n\n  * \u25ba 2022 (2)\n\n    * \u25ba August (1)\n    * \u25ba June (1)\n\n  * \u25bc 2021 (12)\n\n    * \u25ba July (3)\n    * \u25bc June (6)\n\n      * Don't Generate Glue...Exterminate!!\n      * Generating ARM Assembly: First Steps\n      * if let it be\n      * Asynchronous Sequences and Polymorphic Streams\n      * Glue: the Dark Matter of Software\n      * Towards a ToDoMVC Backend in Objective-S\n    * \u25ba May (3)\n\n  * \u25ba 2020 (18)\n\n    * \u25ba November (1)\n    * \u25ba September (1)\n    * \u25ba June (3)\n    * \u25ba May (2)\n    * \u25ba April (11)\n\n  * \u25ba 2019 (16)\n\n    * \u25ba December (1)\n    * \u25ba November (3)\n    * \u25ba April (2)\n    * \u25ba March (3)\n    * \u25ba February (5)\n    * \u25ba January (2)\n\n  * \u25ba 2018 (8)\n\n    * \u25ba December (2)\n    * \u25ba November (1)\n    * \u25ba October (2)\n    * \u25ba July (1)\n    * \u25ba April (2)\n\n  * \u25ba 2017 (4)\n\n    * \u25ba August (1)\n    * \u25ba March (2)\n    * \u25ba February (1)\n\n  * \u25ba 2016 (2)\n\n    * \u25ba May (1)\n    * \u25ba March (1)\n\n  * \u25ba 2015 (14)\n\n    * \u25ba October (2)\n    * \u25ba September (2)\n    * \u25ba August (1)\n    * \u25ba July (2)\n    * \u25ba June (3)\n    * \u25ba May (1)\n    * \u25ba April (2)\n    * \u25ba March (1)\n\n  * \u25ba 2014 (20)\n\n    * \u25ba September (3)\n    * \u25ba August (1)\n    * \u25ba July (1)\n    * \u25ba June (4)\n    * \u25ba May (4)\n    * \u25ba April (2)\n    * \u25ba March (3)\n    * \u25ba January (2)\n\n  * \u25ba 2013 (11)\n\n    * \u25ba December (1)\n    * \u25ba October (1)\n    * \u25ba July (2)\n    * \u25ba June (2)\n    * \u25ba May (1)\n    * \u25ba January (4)\n\n  * \u25ba 2012 (18)\n\n    * \u25ba December (1)\n    * \u25ba November (2)\n    * \u25ba October (3)\n    * \u25ba June (1)\n    * \u25ba May (1)\n    * \u25ba April (1)\n    * \u25ba March (6)\n    * \u25ba February (1)\n    * \u25ba January (2)\n\n  * \u25ba 2011 (13)\n\n    * \u25ba December (1)\n    * \u25ba July (1)\n    * \u25ba April (1)\n    * \u25ba March (1)\n    * \u25ba February (6)\n    * \u25ba January (3)\n\n  * \u25ba 2010 (5)\n\n    * \u25ba December (1)\n    * \u25ba May (2)\n    * \u25ba April (1)\n    * \u25ba January (1)\n\n  * \u25ba 2009 (15)\n\n    * \u25ba December (3)\n    * \u25ba November (4)\n    * \u25ba September (1)\n    * \u25ba February (1)\n    * \u25ba January (6)\n\n  * \u25ba 2008 (6)\n\n    * \u25ba December (2)\n    * \u25ba October (1)\n    * \u25ba August (1)\n    * \u25ba April (2)\n\n  * \u25ba 2007 (8)\n\n    * \u25ba November (1)\n    * \u25ba October (2)\n    * \u25ba September (3)\n    * \u25ba August (1)\n    * \u25ba May (1)\n\n## About Me\n\nMarcel Weiher\n\nView my complete profile\n\n## Main Site\n\n## Objective-Smalltalk\n\n## Github Projects\n\n## My Book\n\niOS and macOS Performance Tuning: Cocoa, Cocoa Touch, Objective-C, and Swift.\n\nDiese Website verwendet Cookies von Google, um Dienste anzubieten und Zugriffe\nzu analysieren. Deine IP-Adresse und dein User-Agent werden zusammen mit\nMesswerten zur Leistung und Sicherheit f\u00fcr Google freigegeben. So k\u00f6nnen\nNutzungsstatistiken generiert, Missbrauchsf\u00e4lle erkannt und behoben und die\nQualit\u00e4t des Dienstes gew\u00e4hrleistet werden.Weitere InformationenOk\n\n", "frontpage": false}
