{"aid": "40138325", "title": "Tracking Down a UEFI Quirk on the Fujitsu Lifebook AH532", "url": "https://blog.timschumi.net/2024/04/23/ah532-bios-workaround.html", "domain": "timschumi.net", "votes": 3, "user": "timschumi", "posted_at": "2024-04-23 22:58:45", "comments": 0, "source_title": "Tracking down a UEFI quirk on the Fujitsu LIFEBOOK AH532", "source_text": "Tracking down a UEFI quirk on the Fujitsu LIFEBOOK AH532 | timschumi\u2019s low-traffic blog\n\ntimschumi's low-traffic blog\n\n# Tracking down a UEFI quirk on the Fujitsu LIFEBOOK AH532\n\nApr 23, 2024\n\nLast time, we figured out why not being able to retrieve EFI variables while\ninstalling Linux results in an empty UEFI boot menu and an inaccessible BIOS\nsetup menu. Now, we want to discover what is going wrong and what we can do\nabout it.\n\n## Errata: Hardcoded boot menu keys\n\nIn the last post, I mentioned that Fujitsu supposedly hardcoded the F2 and F12\nboot keys to invoke specific Boot slots. This is a stupid idea because\noverwriting the Boot slots that the keys refer to will render those keypresses\nuseless.\n\nHowever, UEFI specified a variable-based way to override boot key mappings\n(KeyXXXX), and Fujitsu used that to provide the default key mappings for F2\nand F12. Of course, if Boot0000 gets overwritten erroneously, that doesn\u2019t\nmean that the respective Key entry gets updated, which resulted in the issues\nwe have seen.\n\nThis does not make the issue any less stupid, but at least it\u2019s specification-\nsupported stupidity.\n\n## Excursion: UEFI variable iteration\n\nUEFI provides a limited set of interfaces for accessing variables, with\noperations that essentially amount to \u201citerate variable names\u201d\n(GetNextVariableName), \u201cget variable contents\u201d (GetVariable), and \u201cset\nvariable contents\u201d (SetVariable).\n\nVariable iteration works by providing a buffer for the variable GUID (a rough\nclassification/namespacing feature), a buffer for the variable name, and the\nmatching size of the buffer for the variable name.\n\nFor the first iteration, the interface user fills in a string of size 0 into\nthe variable name buffer to indicate that the iteration should start from the\nbeginning of the list. The GUID and name are then copied to the respective\nbuffers. On subsequent iterations, the contents must be kept as-is to allow\nthe UEFI implementation to retrieve the following variable successfully.\n\nOn a successful iteration, the call to GetNextVariableName returns\nEFI_SUCCESS. If the following variable is not found, the function returns\nEFI_NOT_FOUND. If the name buffer is too small to hold the full variable name,\nthe function returns EFI_BUFFER_TOO_SMALL, the passed buffer size is updated\nwith the required buffer size, and the user is meant to resize the buffer to\nfit the name and try again. If any of the involved pointers are a null-\npointer, the specification mandates a return value of EFI_INVALID_PARAMETER.\n\n## How not to do error handling\n\nTracking back to where the issues started, I inspected the kernel log for any\nEFI-related lines and soon found what I was looking for:\n\n    \n    \n    [ 5.215411] efivars: get_next_variable: status=8000000000000002\n\nSearching for this line in the Linux kernel source code, an error handling\nswitch in the efivarfs implementation can be found:\n\n    \n    \n    do { variable_name_size = 1024; status = efivar_get_next_variable(&variable_name_size, variable_name, &vendor_guid); switch (status) { case EFI_SUCCESS: // [...] break; // [omitted cases for EFI_UNSUPPORTED and EFI_NOT_FOUND] default: printk(KERN_WARNING \"efivars: get_next_variable: status=%lx\\n\", status); status = EFI_NOT_FOUND; break; } } while (status != EFI_NOT_FOUND);\n\nThis code is part of a function responsible for retrieving the list of EFI\nvariables, adding entries to a list if successful, and stopping iteration if\nnot.\n\nHowever, iteration also stops when an unexpected error is encountered and\n(relatively) silently pretends we hit the normal exit case. No attempts are\nmade to mitigate an error that, in theory, shouldn\u2019t exist in this case. This\nevidently isn\u2019t great since it allowed the bug to persist for the last ten\nyears.\n\n## Down the UEFI rabbit hole\n\nWhenever there is an unexpected error code, there usually is a place where\nthat error code is returned. The first step is to check whether this is\nsomewhere within the kernel, so I got started with printk-debugging:\n\n    \n    \n    [ 5.229441] Starting efivar_init! [ 5.229446] pre efivarfs efivar_get_next_variable(0xffffc90000043c68, 0xffff88810bc8f400, 0xffffc90000043c70) [ 5.229448] enter drv/fw efivar_get_next_variable(0xffffc90000043c68, 0xffff88810bc8f400, 0xffffc90000043c70) [ 5.229449] enter runtime-wrapper virt_eft_get_next_variable(0xffffc90000043c68, 0xffff88810bc8f400, 0xffffc90000043c70) [ 5.229460] pre runtime-wrapper efi_call_virt(get_next_variable, 0xffffc90000043c68, 0xffff88810bc8f400, 0xffffc90000043c70) [ 5.229467] post runtime-wrapper efi_call_virt(get_next_variable, ...) -> 0x8000000000000002 [ 5.229473] leave runtime-wrapper virt_eft_get_next_variable() -> 0x8000000000000002 [ 5.229475] leave drv/fw efivar_get_next_variable() -> 0x8000000000000002 [ 5.229476] post efivarfs efivar_get_next_variable() -> 0x8000000000000002 [ 5.229478] efivars: get_next_variable: status=8000000000000002\n\nUnfortunately, all that this confirmed to me is that the error code is coming\nfrom the UEFI implementation itself. The purpose of efi_call_virt is to switch\nto a memory management and interrupt context where accessing UEFI services is\nallowed, which makes easy debugging beyond this point next to impossible.\n\nAfter a quick (unfruitful) detour into unpacking and reverse engineering the\nUEFI image, I was out of options to try and posted the first part of my\ninvestigation online. In the Hacker News discussion, Matthew Garrett suggested\nrunning both Linux and Windows under a debug build of EDK II (the de-facto\nUEFI reference implementation) to track down the difference in how the\nrespective system calls the involved UEFI functions.\n\n## Instrumenting UEFI\n\nIt\u2019s not immediately obvious how to build OVMF images based on EDK II since\nthey appear to have supported at least three different build systems in the\npast, but I managed to cobble together a set of commands that successfully\nbuilds a bootable image from source:\n\n    \n    \n    make -C BaseTools . edksetup.sh build -p OvmfPkg/OvmfPkgX64.dsc -a X64 -b DEBUG -n 6 -t GCC5\n\nThe resulting image will not be affected by the same bug the actual hardware\nhas. Still, it allowed me to continue printf-debugging until I found the\nspecific detail that Fujitsu\u2019s UEFI implementation cannot handle since this\nbuild of UEFI will output DEBUG log lines via the debug console. To make them\naccessible under QEMU, I had to add a few additional options to my VM\ninvocation:\n\n    \n    \n    qemu-system-x86_64 -drive if=pflash,file=./Build/OvmfX64/DEBUG_GCC5/FV/OVMF.fd,format=raw -net none -s -debugcon file:debug.log -global isa-debugcon.iobase=0x402\n\nIn the meantime, I also ensured that FreeBSD can successfully retrieve the\nlist of UEFI variables on real hardware since an open-source operating system\nis generally more pleasant to debug than a closed-source operating system.\n\nA few log lines and two VM startups later, I successfully captured UEFI logs\nof both Linux and FreeBSD, and I was ready to check their calls to\nGetNextVariableName for differences. Since I\u2019m not well-versed in printf\nspecifiers, I only logged all three involved pointers, as well as the value of\nthe VariableNameSize parameter.\n\n    \n    \n    [Linux] AH532: VariableServiceGetNextVariableName(0xFFFFC9000076FDA8 <0x400>, 0xFFFF88800261A400, 0xFFFFC9000076FDB0) AH532: VariableServiceGetNextVariableName(0xFFFFC9000076FDA8 <0x400>, 0xFFFF88800261A400, 0xFFFFC9000076FDB0) AH532: VariableServiceGetNextVariableName(0xFFFFC9000076FDA8 <0x400>, 0xFFFF88800261A400, 0xFFFFC9000076FDB0) [FreeBSD] AH532: VariableServiceGetNextVariableName(0xFFFFFE004917AD58 <0x200>, 0xFFFFF80001187800, 0xFFFFFE004917AD60) AH532: VariableServiceGetNextVariableName(0xFFFFFE004917AD58 <0x200>, 0xFFFFF80001187800, 0xFFFFFE004917AD60) AH532: VariableServiceGetNextVariableName(0xFFFFFE004917AD58 <0x200>, 0xFFFFF80001187800, 0xFFFFFE004917AD60)\n\nAssuming that something as simple as memory mapping wouldn\u2019t be messed up, and\nsince all the pointer alignments are otherwise unchanged, that really only\nleaves the value of VariableNameSize as the cause for issues, but surely, this\ncan\u2019t be what UEFI is actually getting stuck on, right?\n\nWell, at least I was thinking wrong because one tiny patch to the kernel\nlater, retrieving the UEFI variable name list on real hardware worked like a\ncharm:\n\n    \n    \n    diff --git a/fs/efivarfs/vars.c b/fs/efivarfs/vars.c index 9e4f47808bd5a..297e2b2120b6b 100644 --- a/fs/efivarfs/vars.c +++ b/fs/efivarfs/vars.c @@ -394,7 +394,7 @@ int efivar_init(int (*func)(efi_char16_t *, efi_guid_t, unsigned long, void *), */ do { - variable_name_size = 1024; + variable_name_size = 512; status = efivar_get_next_variable(&variable_name_size, variable_name,\n    \n    \n    # ls -al /sys/firmware/efi/efivars/ total 0 drwxr-xr-x 2 root root 0 23. Apr 02:54 . drwxr-xr-x 4 root root 0 23. Apr 02:54 .. -rw-r--r-- 1 root root 51 23. Apr 02:54 AbsoluteVar-69d88529-db90-4e0f-839b-bfc1b89ea989 -rw-r--r-- 1 root root 12 23. Apr 02:54 AcpiGlobalVariable-af9ffd67-ec10-488a-9dfc-6cbf5ee22c2e -rw-r--r-- 1 root root 64 23. Apr 02:54 AdvancedPage-397faf4e-893e-468f-992d-9acf30c52142 [...]\n\nGreat, another issue that looks like the universe really hates this particular\nfamily of laptops. I haven\u2019t managed to track down the exact place in the\nbinary where things start to go wrong (nor have I spent much time trying to do\nso), but this seems substantial enough to submit a workaround patch to the\nLinux kernel anyway.\n\n## A Mad Patch-Party\n\nThe first revision of the patch tried to stay mindful of the fact that simply\nlowering the limit down to 512 may break some existing setups, but (in\nhindsight) ended up too complicated for what it was trying to achieve since it\ntried to minimize the number of memory allocations for setups that need no\nmore than 1024 bytes.\n\nThe second revision went for a slightly more straightforward approach, where\nthe loop would start off with the old limit of 1024 and continuously halve the\nadvertised buffer size until the first successful response was received.\nExcluding the fourth revision of the patch (which never made it to the mailing\nlist), this would have been my favorite approach of all available options\nsince hardware with a similar quirk (but at a lower buffer length) would have\nbeen covered as well.\n\nI originally only sent the third revision to satisfy a request for the\nsimplest patch that would solve the problem (which is to decrease the buffer\nsize to 512 bytes). Despite my concerns regarding regressions (and\nintermediary confusion on whether Linux would even support file names longer\nthan 256 characters, which take up 512 bytes when encoded in UTF-16), this\npatch version was merged into the mainline kernel. I\u2019m not sure how to feel\nthat a justification that I explicitly rejected beforehand ended up being\nedited into the patch before it was applied (and, worst of all, including a\ntypo), but at least the issue is fixed now.\n\nThis patch has since landed in all currently supported stable branches of the\nLinux kernel. It has even made it in time to be included in the beta\ninstallation images of Ubuntu 24.04 (and presumably all Ubuntu installation\nimages going forward).\n\n## Postmortem\n\nLooking back at the chain of events, seeing how many things needed to be in\nplace for the bug to be as destructive as it was is interesting:\n\n  * Fujitsu/Phoenix messed up their implementation of GetNextVariableName.\n  * Linux doesn\u2019t care that the function is not implemented entirely to specification, ignoring the error.\n  * Linux does not fall back to GetVariable when accessing a variable directly (and doesn\u2019t manually use it to populate specification-required variables such as BootOrder).\n  * efibootmgr does not care that something is obviously wrong (because it can\u2019t find mandated variables) and tries to create a new boot menu configuration anyway.\n  * Fujitsu/Phoenix did not put their default boot entries into any of the slots that aren\u2019t the first ones that would be used.\n  * Fujitsu/Phoenix did not use the variable hooking mechanisms they have to protect Boot0000 and Boot0001.\n\n## Acknowledgements\n\nMany thanks to...\n\n  * ... Hacker News and Lobsters for discussing and linking many related issues and potential leads for me to follow up on\n  * ... Matthew Garrett for hinting at a debug build of EDK II\n  * ... Ard Biesheuvel for helping with massaging my patches into a state where they are actually kernel-ready (despite me being very stubborn at times)\n  * ... Ubuntu Forums moderators for offering to update twelve-year-old forum threads (so that other users may unbrick their laptops)\n  * ... various fellow university students for proofreading things before I post them on the internet\n\n## timschumi's low-traffic blog\n\n  * Tim Schumacher\n  * blog@timschumi.net\n\n  * timschumi\n  * timschumi\n  * t1mschumi\n\nPosting one blog post about random technical topics a year on average.\n\n", "frontpage": false}
