{"aid": "40131873", "title": "Dumping and extracting the SpaceX Starlink user terminal firmware. (2021)", "url": "https://www.esat.kuleuven.be/cosic/blog/dumping-and-extracting-the-spacex-starlink-user-terminal-firmware/", "domain": "esat.kuleuven.be", "votes": 1, "user": "fanf2", "posted_at": "2024-04-23 13:42:04", "comments": 0, "source_title": "Dumping and extracting the SpaceX Starlink User Terminal firmware", "source_text": "Dumping and extracting the SpaceX Starlink User Terminal firmware - COSIC\n\n# Dumping and extracting the SpaceX Starlink User Terminal firmware\n\nTowards the end of May 2021 Starlink launched in Belgium so we were finally\nable to get our hands on a Dishy McFlatface. In this blog post we will cover\nsome initial exploration of the hardware and we will explain how we dumped and\nextracted the firmware. Note that this blog post does not discuss any specific\nvulnerabilities, we merely document techniques that can be used by others to\nresearch the Starlink User Terminal (UT). Towards the end of this blog post we\nwill include some interesting findings from the firmware. Note that SpaceX\nactively encourages people to find and report security issues through their\nbug bounty program: https://bugcrowd.com/spacex\n\nWe first set up our UT on a flat section of our university building\u2019s roof and\nplayed around with it for a few hours, giving the UT and router the chance to\nperform a firmware update. We did run a few mandatory speed tests and were\nseeing as much as 268 Mbps download and 49 Mbps upload.\n\n## Teardown: Level 1\n\nAfter a few hours of playing around it was time to get our hands dirty and\ndisassemble the UT.\n\nThere have been a few teardown videos of the UT but none of them went into the\ndetails we were interested in: the main SoC and firmware. Nevertheless, these\nprior teardowns ([1, 2, 3]) of the dish contain a lot of useful information\nthat allowed us to disassemble our dish without too much damage. It appears\nthat there a few hardware revisions of the UT out there by now, certain parts\nof the teardown process can differ depending on the revision, something we\nlearned the hard way. One of the aforementioned teardown videos shows the\nEthernet and motor control cables to be detached from the main board before\nthe white plastic cover is removed. On our UT, a tug on the motor control\ncables pulled the entire connector from the PCB; luckily it appears we can\nrepair the damage. In other words, do not pull on those cables but first\nremove the back plastic cover, for those of you in the same boat: JST\nBM05B-ZESS-TBT.\n\nAfter removing the back plastic cover we can see a metal shield covering the\nPCB, with the exception of a small cut-out containing the connectors for the\nEthernet cable and motor control cable. There is one additional, unpopulated\nconnector (4 pin JST SH 1.0mm), that we assumed would contain a UART debug\ninterface as was shown in [4]. Note that the early teardown videos had an\nadditional connector that is no longer present on our UT.\n\n### The UART interface\n\nAfter hooking up a USB to serial converter we could get some information on\nthe UT\u2019s boot process. The output contains information regarding the early\nstage bootloaders before showing the following output.\n\nWe can see that the UT is using the U-Boot bootloader, and that typing\n\u2018falcon\u2019 may interrupt the boot process. While this may give us access to a\nU-Boot CLI we can also see that the serial input is configured as \u2018nulldev\u2019.\nUnsurprising, spamming the serial interface with \u2018falcon\u2019 during boot did not\nyield any result.\n\nU-Boot 2020.04-gddb7afb (Apr 16 2021 - 21:10:45 +0000)Model: CatsonDRAM: 1004\nMiBMMC: Fast boot:eMMC: 8xbit - div2stm-sdhci0: 0In: nulldevOut: serialErr:\nserialCPU ID: 0x00020100 0x87082425 0xb9ca4b91Detected Board rev:\n#rev2_proto2sdhci_set_clock: Timeout to wait cmd & data inhibitFIP1: 3 FIP2:\n3BOOT SLOT BNet: Net Initialization SkippedNo ethernet found.*+\\+ +\\+ +\\+ +\\+\n+ + + + + +\\+ + + +\\+ + + +\\+ + +\\+ + +\\+ + +\\+ + + +\\+ + + +\\+ + + + + + + +\n+ +Board: SPACEX CATSON UTERM======================================= Type\n'falcon' to stop boot process =======================================  \n---  \n  \nContinuing through the boot process we can see that U-Boot loads a kernel,\nramdisk and Flattened Device Tree (FDT) from a Flattened uImage Tree (FIT)\nimage that is stored on an embedded MultiMediaCard (eMMC). We can also see\nthat the integrity (SHA256) and authenticity (RSA 2048) of the kernel, ramdisk\nand FDT is being checked. While we would have to perform some more tests it\nappears that a full trusted boot chain (TF-A) is implemented from the early\nstage ROM bootloader all the way down to the Linux operating system.\n\nswitch to partitions #0, OKmmc0(part 0) is current deviceMMC read: dev # 0,\nblock # 98304, count 49152 ... 49152 blocks read: OK## Loading kernel from FIT\nImage at a2000000 ...Using 'rev2_proto2@1' configurationVerifying Hash\nIntegrity ... sha256,rsa2048:dev+ OKTrying 'kernel@1' kernel\nsubimageDescription: compressed kernelCreated: 2021-04-16 21:10:45 UTCType:\nKernel ImageCompression: lzma compressedData Start: 0xa20000dcData Size:\n3520634 Bytes = 3.4 MiBArchitecture: AArch64OS: LinuxLoad Address:\n0x80080000Load Size: unavailableEntry Point: 0x80080000Hash algo: sha256Hash\nvalue:\n5efc55925a69298638157156bf118357e01435c9f9299743954af25a2638adc2Verifying Hash\nIntegrity ... sha256+ OK## Loading ramdisk from FIT Image at a2000000 ...Using\n'rev2_proto2@1' configurationVerifying Hash Integrity ... sha256,rsa2048:dev+\nOKTrying 'ramdisk@1' ramdisk subimageDescription: compressed ramdiskCreated:\n2021-04-16 21:10:45 UTCType: RAMDisk ImageCompression: lzma compressedData\nStart: 0xa2427f38Data Size: 8093203 Bytes = 7.7 MiBArchitecture: AArch64OS:\nLinuxLoad Address: 0xb0000000Load Size: unavailableEntry Point: 0xb0000000Hash\nalgo: sha256Hash value:\n57020a8dbff20b861a4623cd73ac881e852d257b7dda3fc29ea8d795fac722aaVerifying Hash\nIntegrity ... sha256+ OKLoading ramdisk from 0xa2427f38 to 0xb0000000WARNING:\n'compression' nodes for ramdisks are deprecated, please fix your .its file!##\nLoading fdt from FIT Image at a2000000 ...Using 'rev2_proto2@1'\nconfigurationVerifying Hash Integrity ... sha256,rsa2048:dev+ OKTrying\n'rev2_proto2_fdt@1' fdt subimageDescription: rev2 proto 2 device treeCreated:\n2021-04-16 21:10:45 UTCType: Flat Device TreeCompression: uncompressedData\nStart: 0xa23fc674Data Size: 59720 Bytes = 58.3 KiBArchitecture: AArch64Load\nAddress: 0x8f000000Hash algo: sha256Hash value:\ncca3af2e3bbaa1ef915d474eb9034a770b01d780ace925c6e82efa579334dea8Verifying Hash\nIntegrity ... sha256+ OKLoading fdt from 0xa23fc674 to 0x8f000000Booting using\nthe fdt blob at 0x8f000000Uncompressing Kernel ImageLoading Ramdisk to\n8f848000, end 8ffffe13 ... OKERROR: reserving fdt memory region failed\n(addr=b0000000 size=10000000)Loading Device Tree to 000000008f836000, end\n000000008f847947 ... OKWARNING: ethact is not set. Not including ethprime in\n/chosen.Starting kernel ...  \n---  \n  \nThe remainder of the boot process contains some other interesting pieces of\ninformation. For example, we can see the kernel command line arguments and\nwith that the starting addresses and lengths of some partitions. Additionally,\nwe can see that the SoC contains 4 CPU cores.\n\n12345678910111213141516171819202122232425262728293031323334353637383940| [\n0.000000] 000: Detected VIPT I-cache on CPU0[ 0.000000] 000: Built 1\nzonelists, mobility grouping on. Total pages: 193536[ 0.000000] 000: Kernel\ncommand line: rdinit=/usr/sbin/sxruntime_start mtdoops.mtddev=mtdoops\nconsole=ttyAS0,115200 quiet alloc_snapshot trace_buf_size=5M\nrcutree.kthread_prio=80 earlycon=stasc,mmio32,0x8850000,115200n8\nuio_pdrv_genirq.of_id=generic-uio audit=1 SXRUNTIME_EXPECT_SUCCESS=true\nblkdevparts=mmcblk0:0x00100000@0x00000000(BOOTFIP_0),0x00100000@0x00100000(BOOTFIP_1),0x00100000@0x00200000(BOOTFIP_2),0x00100000@0x00300000(BOOTFIP_3),0x00080000@0x00400000(BOOTTERM1),0x00080000@0x00500000(BOOTTERM2),0x00100000@0x00600000(BOOT_A_0),0x00100000@0x00700000(BOOT_B_0),0x00100000@0x00800000(BOOT_A_1),0x00100000@0x00900000(BOOT_B_1),0x00100000@0x00A00000(UBOOT_TERM1),0x00100000@0x00B00000(UBOOT_TERM2),0x00050000@0x00FB0000(SXID),0x01800000@0x01000000(KERNEL_A),0x00800000@0x02800000(CONFIG_A),0x01800000@0x03000000(KERNEL_B),0x00800000@0x04800000(CONFIG_B),0x01800000@0x05000000(SX_A),0x01800000@0x06800000(SX_B),0x00020000@0x00F30000(VERSION_INFO_A),0x00020000@0x00F50000(VERSION_INFO_B),0x00020000[\n0.000000] 000: audit: enabled (after initialization)[ 0.000000] 000: Dentry\ncache hash table entries: 131072 (order: 9, 2097152 bytes, linear)[ 0.000000]\n000: Inode-cache hash table entries: 65536 (order: 7, 524288 bytes, linear)[\n0.000000] 000: mem auto-init: stack:off, heap alloc:off, heap free:off[\n0.000000] 000: Memory: 746884K/786432K available (6718K kernel code, 854K\nrwdata, 1648K rodata, 704K init, 329K bss, 39548K reserved, 0K cma-reserved)[\n0.000000] 000: SLUB: HWalign=64, Order=0-3, MinObjects=0, CPUs=4, Nodes=1[\n0.000000] 000: ftrace: allocating 23664 entries in 93 pages[ 0.000000] 000:\nrcu: Preemptible hierarchical RCU implementation.[ 0.000000] 000: rcu: RCU\nevent tracing is enabled.[ 0.000000] 000: rcu: RCU restricting CPUs from\nNR_CPUS=8 to nr_cpu_ids=4.[ 0.000000] 000: rcu: RCU priority boosting:\npriority 80 delay 500 ms.[ 0.000000] 000: rcu: RCU_SOFTIRQ processing moved to\nrcuc kthreads.[ 0.000000] 000: No expedited grace period\n(rcu_normal_after_boot).[ 0.000000] 000: Tasks RCU enabled.[ 0.000000] 000:\nrcu: RCU calculated value of scheduler-enlistment delay is 100 jiffies.[\n0.000000] 000: rcu: Adjusting geometry for rcu_fanout_leaf=16, nr_cpu_ids=4[\n0.000000] 000: NR_IRQS: 64, nr_irqs: 64, preallocated irqs: 0[ 0.000000] 000:\nrandom: get_random_bytes called from start_kernel+0x33c/0x4b0 with\ncrng_init=0[ 0.000000] 000: arch_timer: cp15 timer(s) running at 60.00MHz\n(virt).[ 0.000000] 000: clocksource: arch_sys_counter: mask: 0xffffffffffffff\nmax_cycles: 0x1bacf917bf, max_idle_ns: 881590412290 ns[ 0.000000] 000:\nsched_clock: 56 bits at 60MHz, resolution 16ns, wraps every 4398046511098ns[\n0.008552] 000: Calibrating delay loop (skipped), value calculated using timer\nfrequency..[ 0.016871] 000: 120.00 BogoMIPS (lpj=60000)[ 0.021129] 000:\npid_max: default: 32768 minimum: 301[ 0.026307] 000: Mount-cache hash table\nentries: 2048 (order: 2, 16384 bytes, linear)[ 0.034005] 000: Mountpoint-cache\nhash table entries: 2048 (order: 2, 16384 bytes, linear)[ 0.048359] 000: ASID\nallocator initialised with 32768 entries[ 0.050341] 000: rcu: Hierarchical\nSRCU implementation.[ 0.061390] 000: smp: Bringing up secondary CPUs ...[\n0.078677] 001: Detected VIPT I-cache on CPU1[ 0.078755] 001: CPU1: Booted\nsecondary processor 0x0000000001 [0x410fd034][ 0.095799] 002: Detected VIPT\nI-cache on CPU2[ 0.095858] 002: CPU2: Booted secondary processor 0x0000000002\n[0x410fd034][ 0.112970] 003: Detected VIPT I-cache on CPU3[ 0.113025] 003:\nCPU3: Booted secondary processor 0x0000000003 [0x410fd034][ 0.113160] 000:\nsmp: Brought up 1 node, 4 CPUs[ 0.113184] 000: SMP: Total of 4 processors\nactivated.  \n---|---  \n  \nFinally, when the UT completes its boot process we are greeted with a login\nprompt:\n\nDevelopment login enabled: noSpaceX User Terminal.user1 login:  \n---  \n  \nWhile making a few attempts at guessing valid login credentials we started\nrealising that this UART interface would be unlikely to result in an easy win.\nWe had to go deeper.\n\n## Teardown: Level 2\n\nThe back metal cover of the UT is glued to the assembly around the outer edge\nand additional glue is applied between the ribs in the metal cover and the\nunderlying PCB. To loosen the glue at the edge of the metal cover we used a\nheat gun, prying tools, isopropyl alcohol and a lot of patience. Specifically,\nwe first applied heat to a small section, used a prying tool to loosen that\nsection, added IPA to help dissolve the glue and another round of the prying\ntool. Having removed the metal cover we are greeted by an enormous PCB\nmeasuring approximately 55 cm in diameter.\n\nThe parts of interest to us are shown in the picture below. The flip-chip BGA\npackage with the metal lid is the main SoC on this board (marking: ST\nGLLCCOCA6BF). Unsurprisingly the SoC is connected to some volatile DRAM\nstorage and non-volatile flash storage in the form of an eMMC chip.\n\n### Identifying eMMC test points\n\nAn embedded MultiMediaCard (eMMC) contains flash storage and a controller and\nis quite similar to an SD-card. The UT contains a Micron eMMC chip with\npackage marking JY976, Micron offers a convenient tool to decode these package\nmarkings to the actual part number: https://www.micron.com/support/tools-and-\nutilities/fbga. The eMMC chip in question has part number MTFC4GACAJCN-1M and\ncontains 4GB of flash storage in a BGA-153 package. In most scenarios we would\ndesolder such an eMMC chip, reball it and dump it using a BGA socket. However,\nin this case we first attempted to dump the eMMC in-circuit to minimize the\nodds of damaging our UT and the eMMC chip.\n\neMMC chips are similar to SD cards in that they share a similar interface; the\neMMC chip does support up to 8 data lines whereas SD-cards support up to 4\ndata lines. Both eMMC chips and SD-Cards support the use of only a single data\nline at the cost of lower read/write speeds.\n\nTo read the eMMC chip in-circuit we have to identify the clock (CLK), command\n(CMD) and data 0 (D0) signals. The 10 test points above the main SoC drew our\nattention, as 10 test points could be a CMD, CLK and 8 data lines.\nAdditionally, all of these test points have a 30 Ohm series resistor connected\nto them which is relatively common for eMMC connections. We soldered a short\nwire to each test point, allowing us to create a logic analyser capture during\nthe UT boot process. Using such a capture it is relatively straightforward to\nidentify the required signals. The CLK signal will be the only repetitive\nsignal, CMD is the signal that is first active after the clock starts toggling\nand D0 is the first data line to send out data. Determining the remaining 7\ndata lines is luckily unnecessary to dump the eMMC contents.\n\n### Dumping the eMMC in-circuit\n\nTo dump the eMMC chip we can connect a reader (that supports 1.8V IO) to the\nidentified test points. Commercial readers that are mostly aimed at phone\nrepair exist and should work well for this purpose (e.g. easy-JTAG and Medusa\nPro). Alternatively you can use a regular USB SD-card reader (one that\nsupports 1-bit mode) with an SD-card breakout with integrated level-shifters\n(e.g. https://shop.exploitee.rs/shop/p/low-voltage-emmc-adapter ). You can\nalso whip something up yourself if you have some parts laying around. The\npicture below shows a standard USB SD-card reader connected to a TI TXS0202EVM\nlevel-shifter breakout board.\n\nWe only provide power to the eMMC to prevent the main SoC from interfering.\nThe eMMC can be powered through two nearby decoupling capacitors, 3.3V is\nprovided by the SD card reader and 1.8V is provided using a lab power supply.\nOnce everything is hooked up properly we can create a disk image for later\nanalysis.\n\nNote that reading eMMC in circuit is not always an easy task; wires that are\nslightly too long can already prevent reading from succeeding. In this case it\nwas rather straightforward and the system appears to function normally even\nwith these relatively long wires attached.\n\n## Unpacking the raw eMMC dump\n\nUnfortunately, Binwalk was not able to extract the full filesystem hence a\nmanual analysis was required.\n\nFrom the boot log it was clear that U-Boot was loading 49152 blocks of data\nstarting at block 98304. Meaning that U-Boot is reading 0x1800000 bytes\n(blocksize of 512 (0x200) bytes) starting from address 0x3000000. We also know\nfrom the U-Boot output that this chunk of data is a FIT image. However, when\ntrying to read the FIT image header information using the dumpimage tool (part\nof the u-boot-tools package) we weren\u2019t getting any useful information.\n\nLuckily SpaceX released their modifications to U-Boot on Github for GPL\ncompliance: https://github.com/SpaceExplorationTechnologies By looking at this\ncode it became clear that certain parts of the firmware are stored in a custom\nformat that contains Error Correcting Code (ECC) data.\n\n### Stripping Reed-Solomon ECC words\n\nThe file spacex_catson_boot.h contains interesting information related to how\nthe device boots. The following snippets show how data is being read from eMMC\n(mmc read8) and the definition for startkernel.\n\n1234567891011121314151617181920| #define SPACEX_CATSON_COMMON_BOOT_SETTINGS\n\\\"kernel_boot_addr=\" __stringify(CATS_KERNEL_BOOT_ADDR) \"\\0\"\n\\\"kernel_load_addr=\" __stringify(CATS_KERNEL_LOAD_ADDR) \"\\0\"\n\\\"kernel_offset_a=\" __stringify(CATS_KERNEL_A_OFFSET) \"\\0\" \\\"kernel_offset_b=\"\n__stringify(CATS_KERNEL_B_OFFSET) \"\\0\" \\\"kernel_size=\"\n__stringify(CATS_KERNEL_A_SIZE) \"\\0\" \\\"setup_burn_memory=mw.q \"\n__stringify(CATS_TERM_SCRATCH_ADDR) \" 0x12345678aa640001 && \" \\\"mw.l \"\n__stringify(CATS_TERM_LOAD_ADDR) \" 0xffffffff \"\n__stringify(CATS_BOOTTERM1_SIZE) \" && \" \\\"mw.l \"\n__stringify(CATS_TERM_TOC_SER_ADDR) \" \" __stringify(CATS_TERM_TOC_SER_VAL)\n\"\\0\" \\\"startkernel=unecc $kernel_load_addr $kernel_boot_addr && bootm\n$kernel_boot_addr${boot_type}\\0\" \\\"stdin=nulldev\\0\"#define\nSPACEX_CATSON_BOOT_SETTINGS \\SPACEX_CATSON_COMMON_BOOT_SETTINGS\n\\\"_emmcboot=mmc dev \" __stringify(CATS_MMC_BOOT_DEV) \" \"\n__stringify(CATS_MMC_BOOT_PART) \" && \" \\\"mmc read8 $kernel_load_addr\n${_kernel_offset} $kernel_size && \" \\\"run startkernel\\0\" \\\"emmcboot_a=setenv\n_kernel_offset $kernel_offset_a && run _emmcboot\\0\" \\\"emmcboot_b=setenv\n_kernel_offset $kernel_offset_b && run _emmcboot\\0\"  \n---|---  \n  \nThe definition of startkernel is particularly interesting as it shows how the\naddress where the kernel was loaded is being passed to a command called unecc.\nFrom the unecc command definition it is quite clear that this functionality is\nperforming error correction on the data read from the eMMC.\n\n12345678910| U_BOOT_CMD(unecc, 3, 0, do_unecc,\"Unpacks an ECC volume;\nincrements internal ECC error counter on error\",\"<source>\n<target>\\n\"\"\\tReturns successfully if the given source was\nsuccessfully\\n\"\"\\tunpacked to the target. This will fail if the given\nsource\\n\"\"\\tis not an ECC volume. It will succeed if bit errors\nwere\\n\"\"\\tsuccessfully fixed.\\n\"\"\\t<source> and <target> should both be in\nhexadecimal.\\n\");  \n---|---  \n  \nThe unecc command calls the do_unecc function implemented in unecc.c.\nEventually this will result in calling the ecc_decode_one_pass function\ndefined in ecc.c.\n\n123456789101112131415161718192021222324252627| /*** Decodes an ECC protected\nblock of memory. If the enable_correction* parameter is zero, it will use the\nMD5 checksum to detect errors and will* ignore the ECC bits. Otherwise, it\nwill use the ECC bits to correct any* errors and still use the MD5 checksum to\ndetect remaining problems.** @data: Pointer to the input data.* @size: The\nlength of the input data, or 0 to read until the* end of the ECC stream.*\n@dest: The destination for the decoded data.* @decoded[out]: An optional\npointer to store the length of the decoded* data.* @silent: Whether to call\nprint routines or not.* @enable_correction: Indicates that the ECC data should\nbe used* to correct errors. Otherwise the MD5 checksum* will be used to check\nfor an error.* @error_count[out]: Pointer to an integer that will be\nincremented* by the number of errors found. May be NULL.* Unused if\n!enable_correction.** Return: 1 if the block was successfully decoded, 0 if we\nhad a* failure, -1 if the very first block didn't decode (i.e. probably* not\nan ECC file)*/static int ecc_decode_one_pass(const void *data, unsigned long\nsize, void *dest,unsigned long *decoded, int silent,int enable_correction,\nunsigned int *error_count)  \n---|---  \n  \necc.h contains several relevant definitions:\n\n123456789101112131415161718192021| #else /* !NPAR */#define NPAR 32#endif /*\nNPAR *//** These options must be synchronized with the userspace \"ecc\"*\nutility's configuration options. See ecc/trunk/include/ecc.h in the* \"util\"\nsubmodule of the platform.*/#define ECC_BLOCK_SIZE 255#define ECC_MD5_LEN\n16#define ECC_EXTENSION \"ecc\"#define ECC_FILE_MAGIC \"SXECCv\"#define\nECC_FILE_VERSION '1'#define ECC_FILE_MAGIC_LEN (sizeof(ECC_FILE_MAGIC) -\n1)#define ECC_FILE_FOOTER_LEN sizeof(file_footer_t)#define ECC_DAT_SIZE\n(ECC_BLOCK_SIZE - NPAR - 1)#define ECC_BLOCK_TYPE_DATA '*'#define\nECC_BLOCK_TYPE_LAST '$'#define ECC_BLOCK_TYPE_FOOTER '!'  \n---|---  \n  \nIn the end what it boils down to is that, in this implementation, an ECC\nprotected block of memory starts with the magic header value SXECCv followed\nby a version byte (1). This magic value marks the start of the ECC protected\ndata, but also the start of the header block. The header block itself contains\n(in addition to the magic value and version byte), 215 bytes of data, an\nasterisk (*), and 32 bytes of ECC code words.\n\nThe header block is followed by multiple data blocks. Each of these data\nblocks is 255 bytes long and contains 222 bytes of data followed by an\nasterisk symbol (*) and 32 bytes of ECC code words. The last data block\ncontains a dollar sign ($) instead of the asterisk and is followed by a final\nfooter block. This footer block starts with and exclamation mark (!) that is\nfollowed by the number of data bytes in the ECC protected block of memory\n(4-bytes) and MD5 digest over those data bytes.\n\nAt this point it should be clear why Binwalk did not succeed in extracting the\nkernel, initramfs and FDT. Binwalk is able to pick up on the magic values that\nindicate the start of a particular file, but each block of the file had\nadditional data that prevented Binwalk from extracting it. We used a simple\nPython scrip to remove the extra ECC data before using Binwalk to extract the\nimage. Similarly, we can now also use dumpimage to get more information on the\nFIT image.\n\n## The FIT image and board revisions\n\nThe following snippet contains some of the dumpimage output. The FIT image\ncontains 13 boot configurations, all configurations use the same kernel and\ninitramfs images but a different Flattened Device Tree (FDT).\n\nFIT description: Signed dev image for catson platformsCreated: Fri Apr 16\n23:10:45 2021Image 0 (kernel@1)Description: compressed kernelCreated: Fri Apr\n16 23:10:45 2021Type: Kernel ImageCompression: lzma compressedData Size:\n3520634 Bytes = 3438.12 KiB = 3.36 MiBArchitecture: AArch64OS: LinuxLoad\nAddress: 0x80080000Entry Point: 0x80080000Hash algo: sha256Hash value:\n5efc55925a69298638157156bf118357e01435c9f9299743954af25a2638adc2Image 12\n(rev2_proto2_fdt@1)Description: rev2 proto 2 device treeCreated: Fri Apr 16\n23:10:45 2021Type: Flat Device TreeCompression: uncompressedData Size: 59720\nBytes = 58.32 KiB = 0.06 MiBArchitecture: AArch64Load Address: 0x8f000000Hash\nalgo: sha256Hash value:\ncca3af2e3bbaa1ef915d474eb9034a770b01d780ace925c6e82efa579334dea8Image 15\n(ramdisk@1)Description: compressed ramdiskCreated: Fri Apr 16 23:10:45\n2021Type: RAMDisk ImageCompression: lzma compressedData Size: 8093203 Bytes =\n7903.52 KiB = 7.72 MiBArchitecture: AArch64OS: LinuxLoad Address:\n0xb0000000Entry Point: 0xb0000000Hash algo: sha256Hash value:\n57020a8dbff20b861a4623cd73ac881e852d257b7dda3fc29ea8d795fac722aaDefault\nConfiguration: 'rev2_proto2@1'Configuration 0 (utdev@1)Description:\ndefaultKernel: kernel@1Init Ramdisk: ramdisk@1FDT: utdev3@1Sign algo:\nsha256,rsa2048:devSign value:\nbb34cc2512d5cd3b5ffeb5acace0c1b3dd4d960be3839c88df57c7aeb793ad73a74e87006efece4e9f1e31edbb671e2c63dc4cdcb1a2f55388d83a11f1074f21a1e48d81884a288909eb0c9015054213e5e74cbcc6a6d2617a720949dcac3166f1d01e3c2465d8e7461d14288f1a0abef22f80e2745e7f8499af46e8c007b825d72ab494f104df57433850f381be793bfe06302473269d2f45ce2ff2e8e4439017c0a94c5e7c6981b126a2768da555c86b2be136d4f5785b83193d39c9469bd24177be6ed3450b62d891a30e96d86eee33c2cbfc549d3826e6add36843f0933ced7c8e23085ee6106e3cc2af1e04d2153af5f371712854e91c8f33a4ea434269  \n---  \n  \nFrom the U-Boot code (spacex_catson_uterm.c) it becomes clear that the boot\nconfiguration is decided based on the state of 5 GPIO pins.\n\n142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193|\n/*** Check board ID GPIOs to find board revision.* The board IDs are mapped as\nfollows* id_b0:pio12[2]* id_b1:pio12[3]* id_b2:pio12[0]* id_b3:pio12[1]*\nid_b4:pio20[4]*/u32 pio12 = readl(BACKBONE_PIO_A_PIO2_PIN);u32 pio20 =\nreadl(BACKBONE_PIO_B_PIO0_PIN);u32 board_id = (((pio12 >> 2) & 1) << 0)\n|(((pio12 >> 3) & 1) << 1) |(((pio12 >> 0) & 1) << 2) |(((pio12 >> 1) & 1) <<\n3) |(((pio20 >> 4) & 1) << 4);/**\nhttps://confluence/display/satellites/User+Terminal%3A+Catson+ID+Bits*/switch\n(board_id){case 0b11111:board_rev_string = BOARD_REV_1_1P3;break;case\n0b11100:board_rev_string = BOARD_REV_1_2P1;break;case 0b11000:board_rev_string\n= BOARD_REV_1_2P2;break;case 0b10100:board_rev_string =\nBOARD_REV_1_3P0;break;case 0b10000: /* rev1 pre-production */board_rev_string\n= BOARD_REV_1_PRE_PROD;break;case 0b11110: /* rev1 production\n*/board_rev_string = BOARD_REV_1_PROD;break;case 0b00001:board_rev_string =\nBOARD_REV_2_0P0;break;case 0b00010:board_rev_string =\nBOARD_REV_2_1P0;break;case 0b00011:board_rev_string =\nBOARD_REV_2_2P0;break;}}printf(\"Detected Board rev: %s\\n\", board_rev_string);  \n---|---  \n  \nThe following picture shows where these pins are being pulled high/low to\nindicate the board revision. Note from the earlier serial bootlog that our UT\nboots using the rev2_proto2 configuration (case 0b00011). In a recent video\nColin O\u2019Flynn pulled some of these pins high/low and could observe that the UT\ntried booting using a different FIT configuration and thus different\ndevicetree [5]. We compared some of the FDTs but did not spot any differences\nthat would be interesting from a security perspective.\n\n## A first look at the firmware\n\n### The login prompt\n\nRecall that after the boot process has completed we are greeted with a login\nprompt. For further research it would be useful to gain the ability to log in,\nallowing us to interact with the live system. However, by looking at the\nshadow file it becomes clear that none of the users are allowed to log in.\nDuring boot the UT does read a fuse to determine if it is development hardware\nor not. If the UT is unfused it will set a password for the root user,\nallowing log in. Starlink UTs that are sold to consumers are of course\nproduction fused, disabling the login prompt.\n\n12345678910|\nroot:*:10933:0:99999:7:::bin:*:10933:0:99999:7:::daemon:*:10933:0:99999:7:::sync:*:10933:0:99999:7:::halt:*:10933:0:99999:7:::uucp:*:10933:0:99999:7:::operator:*:10933:0:99999:7:::ftp:*:10933:0:99999:7:::nobody:*:10933:0:99999:7:::sshd:*:::::::  \n---|---  \n  \n### Development hardware\n\nDevelopment hardware often finds its way into the wrong hands [6, 7]. The\nengineers at SpaceX considered this scenario and appear to try to actively\ndetect unfused development hardware that is no longer under their control.\nDevelopment hardware is geofenced to only work in certain predefined areas,\nmost of which are clearly SpaceX locations. SpaceX is likely notified if\ndevelopment hardware is used outside these predefined geofences.\n\nInterestingly, some of these geofences do not seem to have a clear connection\nto SpaceX. While we will not disclose these locations here, I will say that\nthe SNOW_RANCH looks like a nice location to play with development hardware.\n\n### Secure element\n\nFrom references in the firmware it became clear that (our revision of) the UT\ncontains a STMicroelectronics STSAFE secure element. The purpose of the secure\nelement is not entirely clear yet, but it may be used to remotely authenticate\nthe UT.\n\n### The SoC\n\nSome people have asked which processor is being used: the answer is a Quad-\nCore Cortex-A53 and each core has been assigned a specific task.\n\n1234567891011121314| ############################# System\nInformation############################## The user terminal phased-array\ncomputers are Catson SoCs with a quad-core# Cortex-A53.## We dedicate one core\nto control, while leaving the other three to handle# interrupts and auxiliary\nprocesses.## CPU 0: Control process.# CPU 1: Lower-MAC RX process.# CPU 2:\nLower-MAC TX process.# CPU 3: PhyFW and utility core - interrupts, auxiliary\nprocesses, miscellaneous  \n---|---  \n  \n## What\u2019s next\n\nThat\u2019s it for now. We will likely continue looking into the Starlink UT and\nprovide more details in future blog posts if there is interest. At the time of\nwriting we were able to obtain a root shell on the UT, but it\u2019s too early to\npublicly share more information on that matter.\n\n## References\n\n[1] MikeOnSpace \u2013 Starlink Dish TEARDOWN! \u2013 Part 1 \u2013\nhttps://youtu.be/QudtSo5tpLk [2] Ken Keiter \u2013 Starlink Teardown: DISHY\nDESTROYED! \u2013 https://youtu.be/iOmdQnIlnRo [3] The Signal Path \u2013 Starlink Dish\nPhased Array Design, Architecture & RF In-depth Analysis \u2013\nhttps://youtu.be/h6MfM8EFkGg [4] MikeOnSpace \u2013 Starlink Dish TEARDOWN! \u2013 Part\n2 \u2013 https://youtu.be/38_KTq8j0Nw [5] Colin O\u2019Flynn \u2013 Starlink Dishy (Rev2 HW)\nTeardown Part 1 \u2013 UART, Reset, Boot Glitches \u2013 https://youtu.be/omScudUro3s\n[6] Brendan I. Koerner \u2013 The Teens Who Hacked Microsoft\u2019s Xbox Empire \u2013\nhttps://www.wired.com/story/xbox-underground-videogame-hackers/ [7] Jack\nRhysider \u2013 Darknet Diaries EP 45: XBOX UNDERGROUND (PART 1) \u2013\nhttps://darknetdiaries.com/episode/45/\n\n##### SHARE\n\nTwitterFacebookLinkedIn\n\nPosted in COSIC Cryptography BlogTagged Lennert Wouters, Level: Advanced,\nResearch blogging, SpaceX, Starlink\n\nPosted on 06/07/202109/06/2022 by Lennert Wouters in COSIC Cryptography Blog\n\n## Follow us\n\n  * X @CosicBe\n  * Bluesky @cosic.bsky.social\n  * Mastodon @CosicBe\n  * LinkedIn\n  * YouTube\n\n## Most used tags\n\nAlice Pellet-Mary Asiacrypt Asiacrypt2019 Aysajan Abidin Bart Preneel Carl\nBootland Cathedral CCS CCS2019 Claudia Diaz Co6GC COED Conference blogging\nCosic Guide To Crypto Crypto2022 Daniele Cozzo EC22 Enrique Argones R\u00faa ERC\nErik Pohle EuroCrypt FHE H2020 Ilaria Chillotti Ilia Iliashenko IMACC Ingrid\nVerbauwhede Karim Baghery Kelong Cong Lennert Wouters Level: Advanced Level:\nEasy MPC Mustafa A. Mustafa Privacy Prizes & Awards Research blogging Roel\nPeeters RWC 2022 Thomas Decru Titouan Tanguy Vincent Rijmen Ward Beullens\nWouter Castryck Younes Talibi Alaoui\n\n## Advanced Master Cybersecurity\n\nCOSIC and DistriNet organize a 60-ECTS Advanced Master Cybersecurity programme\ntogether, aimed at graduates from electrical engineering, computer science and\nmathematics. The English-taught programme can be completed on a one-year full-\ntime basis.\n\n## Spotlight projects\n\n  * ERC ISOCRYPT\n  * ERC Belfort\n\n## Upcoming Events\n\nMay 23\n\nMay 23 - May 24\n\n### Leuven Hardware Summit for Computing on Encrypted Data\n\nJun 3\n\nJune 3 - June 7\n\n### SecAppDev 2024\n\nView Calendar\n\n## Search this site\n\n## Recent blog posts\n\n  * CHES 2023 blog: Protecting your future credit card! (Fault attacks on SPHINCS+) 22/01/2024\n  * PoPETs 2024.2 Paper: \u201cMixMatch: Flow Matching for Mixnet Traffic\u201d 12/01/2024\n  * ACM CCS 2023: \u201cAttack Some while Protecting Others: Selective Attack Strategies for Attacking and Protecting Multiple Concepts\u201d 18/12/2023\n\n  * 2024 \u00a9 KU Leuven\n  * Disclaimer\n  * Cookiebeleid\n  * Privacybeleid\n  * COSIC webmaster\n\nFollow COSIC\n\n", "frontpage": false}
