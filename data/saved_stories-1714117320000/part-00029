{"aid": "40163495", "title": "Building a Multi-Tenant Web App in 2024", "url": "https://egoist.dev/multi-tenant-web-app-2024", "domain": "egoist.dev", "votes": 2, "user": "0x142857", "posted_at": "2024-04-25 21:49:10", "comments": 0, "source_title": "Building a Multi-Tenant Web App in 2024 - EGOIST", "source_text": "Building a Multi-Tenant Web App in 2024 - EGOIST\n\nhome about donate\n\n#### Table of Contents\n\n  * Next.js\n  * SvelteKit\n  * Remix\n  * Solid Start\n  * Nuxt\n  * Conclusion\n\n## Building a Multi-Tenant Web App in 2024\n\n2024-04-26\n\nIn a similar post I wrote 2 years ago, I mentioned that only Next.js has\nbuilt-in support for multi-tenancy, but that\u2019s not true anymore, SvelteKit has\ncaught up to the competition and now offers a way to build multi-tenant apps.\n\nIn this post I\u2019ll revisit the topic and add a few more frameworks to compare.\nLet\u2019s start with the OG.\n\n## Next.js\n\nNext.js has largely remained the same in terms of multi-tenancy support, you\nuse Next.js middleware to reroute requests based on the host header. It\u2019s\npretty straightforward:\n\nsrc/middleware.ts\n\n    \n    \n    import { NextRequest, NextResponse } from \"next/server\"\n    \n    const OUR_DOMAIN =\n    \n    process.env.NODE_ENV === \"production\" ? \"acme.com\" : \"localhost:3000\"\n    \n    export default function middleware(req: NextRequest) {\n    \n    const host = req.headers.get(\"host\")\n    \n    if (host !== OUR_DOMAIN) {\n    \n    // tenant is a subdomain or a custom domain\n    \n    const tenant = host.replace(`.${OUR_DOMAIN}`, \"\")\n    \n    const url = req.nextUrl.clone()\n    \n    url.pathname = `_tenant/${tenant}${url.pathname}`\n    \n    return NextResponse.rewrite(url)\n    \n    }\n    \n    return NextResponse.next()\n    \n    }\n\nWhat the code above does:\n\n  1. Check if host is equal to OUR_DOMAIN, if not it belongs to a tenant, the value of tenant is the subdomain or custom domain\n  2. Rewrite to _tenant/$subdomain/$originalPath if it is\n\n## SvelteKit\n\nSvelteKit has a concept of hooks that will be called in response to specific\nevents, now there\u2019s a reroute hook that allows you to reroute requests based\non incoming URL.\n\nHere\u2019s how you can use it for multi-tenancy:\n\nsrc/hooks.ts\n\n    \n    \n    export const reroute: Reroute = ({ url }) => {\n    \n    if (url.host !== OUR_DOMAIN) {\n    \n    const tenant = url.host.replace(`.${OUR_DOMAIN}`, \"\")\n    \n    // maps to `src/routes/tenant/[tenant]/...`\n    \n    return `/tenant/${tenant}${url.pathname}`\n    \n    }\n    \n    }\n\nThe Next.js version is all done in a server-side middleware, I didn\u2019t read\ntheir code but for sure there\u2019s some magic going on behind the scenes to pass\nthe new URL to the client, so that the client-side router can pick it up.\nSvelteKit is more explicit about it, reroute is a universal hook which means\nit also runs in the browser, so the client-side router can use it to get the\ndesired URL.\n\n## Remix\n\nUnfortunately, Remix still doesn\u2019t have built-in support for multi-tenancy as\nof writing, they have some proposals though like Lazy Route Discovery and\nRoute Segment Constraints which could help implement this feature.\n\nUntil then you can either split your main app and user app into different\nprojects inside a monorepo, or conditionally render different components in\nthe same route based on the host header using loader function:\n\nsrc/routes/index.tsx\n\n    \n    \n    export const loader = ({ request }) => {\n    \n    const host = request.headers.get(\"host\")\n    \n    const tenant = host === OUR_DOMAIN ? null : host.replace(`.${OUR_DOMAIN}`, \"\")\n    \n    return { tenant }\n    \n    }\n    \n    export default function Page() {\n    \n    const { tenant } = useLoaderData()\n    \n    return <div>{tenant ? <UserApp tenant={tenant} /> : <MainApp />}</div>\n    \n    }\n\nIt\u2019s kinda verbose since you have to do this in every route, I personally\nwould rather split it into different projects instead.\n\n## Solid Start\n\nSolid Start is the new kid on the block, it\u2019s so new that I didn\u2019t expect it\nto have this kind of flexibility for multi-tenancy, but it does! And\nsurprisingly you can do it within a Solid component.\n\nLet\u2019s take a look at the root layout component in Solid Start:\n\nsrc/app.tsx\n\n    \n    \n    import { FileRoutes } from \"@solidjs/start/router\"\n    \n    export default function App() {\n    \n    return (\n    \n    <Router\n    \n    root={(props) => (\n    \n    <MetaProvider>\n    \n    <Title>SolidStart - Basic</Title>\n    \n    <Suspense>{props.children}</Suspense>\n    \n    </MetaProvider>\n    \n    )}\n    \n    >\n    \n    <FileRoutes />\n    \n    </Router>\n    \n    )\n    \n    }\n\nThe FileRoutes component caught my eyes immediately, I\u2019m sure it caught yours\ntoo because I highlighted it for you. After reading the source code I found\nout that it returns the generated routes as an array. This means we can\nmanipulate the routes before passing them to the Router component as children.\n\nNow here\u2019s another problem, I need the host header or the request URL on both\nserver-side and client-side to determine the tenant, how do I do that in a\ncomponent?\n\nThanks to Node.js AsyncLocalStorage API, Solid Start uses it to provide the\ngetRequestEvent function which you can use in any component to get the host\nheader:\n\n    \n    \n    import { getRequestEvent } from \"solid-js/web\"\n    \n    const getTenant = () => {\n    \n    const event = getRequestEvent()\n    \n    // `event` is null on the client-side\n    \n    const host = event ? event.request.headers.get(\"host\") : location.host\n    \n    if (host === OUR_DOMAIN) {\n    \n    return null\n    \n    }\n    \n    return host.replace(`.${OUR_DOMAIN}`, \"\")\n    \n    }\n\nNow you\u2019ve got the tenant value, you can use it to map different routes to\nyour main app and tenant app. I also chose to put them under different folder\nin src/routes:\n\n  * src/routes/app for the main app routes\n  * src/routes/tenant for the tenant app routes\n\nWithout midifying the FileRoutes component, your website will have /app/* and\n/tenant/* routes which is obviously not what you want. So you have to filter\nthe routes and modify route path in a custom FileRoutes component:\n\n    \n    \n    const CustomFileRoutes = () => {\n    \n    const routes = FileRoutes()\n    \n    const tenant = getTenant()\n    \n    return FileRoutes()\n    \n    .filter((route) => {\n    \n    return tenant ? isTenantRoute(route) : !isTenantRoute(route)\n    \n    })\n    \n    .map(normalizeRoute)\n    \n    }\n    \n    const isTenantRoute = (route) => route.path.match(/^\\/tenant\\/?/)\n    \n    // Remove the `/tenant` and `/app` prefix from the path\n    \n    const normalizeRoute = (route) => {\n    \n    return {\n    \n    ...route,\n    \n    path: route.path.replace(/^\\/(tenant|app)\\/?/, \"/\"),\n    \n    }\n    \n    }\n\nNow just replace the FileRoutes component in the App component with\nCustomFileRoutes and you got a solid multi-tenant app!\n\n## Nuxt\n\nLast but not least, Nuxt, famous for its flexibility and rich plugin\necosystem. So of course there\u2019s a plugin for multi-tenancy, and yes I found\none https://github.com/hieuhani/nuxt-multi-tenancy.\n\nHowever this plugin is only useful if it\u2019s a limited set of subdomains or\ncustom domains known at build time, meaning it won\u2019t work for your SaaS app\nwhere users can add their own custom domain. But you can have your own\nimplementation quite easily since Nuxt allows to modify the routes at runtime.\n\nFirst, you can get request host in Nuxt using useRequestURL to determine the\ntenant:\n\n    \n    \n    import { useRequestURL } from \"nuxt/app\"\n    \n    const getTenant = () => {\n    \n    const { hostname } = useRequestURL()\n    \n    if (hostname === OUR_DOMAIN) {\n    \n    return null\n    \n    }\n    \n    return hostname.replace(`.${OUR_DOMAIN}`, \"\")\n    \n    }\n\nThen in the router.options.ts file, you can normalize the routes based on the\ntenant, similarily I have pages/app/ folder the main app and pages/tenant/ for\ntenant app routes:\n\napp/router.options.ts\n\n    \n    \n    import type { RouterConfig } from \"@nuxt/schema\"\n    \n    export default <RouterConfig>{\n    \n    routes(routes) {\n    \n    const tenant = getTenant()\n    \n    return routes\n    \n    .filter((route) => {\n    \n    return tenant ? isTenantRoute(route) : !isTenantRoute(route)\n    \n    })\n    \n    .map(normalizeRoute)\n    \n    },\n    \n    }\n    \n    const isTenantRoute = (route) => route.path.match(/^\\/tenant\\/?/)\n    \n    const normalizeRoute = (route) => {\n    \n    return {\n    \n    ...route,\n    \n    path: route.path.replace(/^\\/(tenant|app)\\/?/, \"/\"),\n    \n    }\n    \n    }\n\n## Conclusion\n\nThe easiest solution to multi-tenacy is to have the framework handle it for\nyou through a reroute mechanism, like Next.js and SvelteKit, in that way you\ncan also map the tenant value to a route parameter [tenant].\n\nNuxt and Solid Start require a bit more work, since you need to modify the\nroutes yourself.\n\n", "frontpage": false}
