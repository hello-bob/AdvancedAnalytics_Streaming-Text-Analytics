{"aid": "40055931", "title": "Selling Lisp by the Pound", "url": "https://gist.github.com/no-defun-allowed/4f0a06e17b3ce74c6aeac514281f350f", "domain": "gist.github.com", "votes": 4, "user": "mepian", "posted_at": "2024-04-16 19:04:20", "comments": 0, "source_title": "Selling Lisp by the pound", "source_text": "Selling Lisp by the pound \u00b7 GitHub\n\nSkip to content\n\nSign in Sign up\n\nYou signed in with another tab or window. Reload to refresh your session. You\nsigned out in another tab or window. Reload to refresh your session. You\nswitched accounts on another tab or window. Reload to refresh your session.\nDismiss alert\n\nInstantly share code, notes, and snippets.\n\n# no-defun-allowed/selling-lisp-by-the-pound.org\n\nLast active March 22, 2024 19:10\n\nShow Gist options\n\n  * Download ZIP\n\n  * Star 12 You must be signed in to star a gist\n  * Fork 0 You must be signed in to fork a gist\n\n  *     * Learn more about clone URLs\n\n  * Save no-defun-allowed/4f0a06e17b3ce74c6aeac514281f350f to your computer and use it in GitHub Desktop.\n\n  * Learn more about clone URLs\n\nSave no-defun-allowed/4f0a06e17b3ce74c6aeac514281f350f to your computer and\nuse it in GitHub Desktop.\n\nDownload ZIP\n\nSelling Lisp by the pound\n\nRaw\n\nselling-lisp-by-the-pound.org\n\n# Selling Lisp by the Pound\n\n> \u201cPaper late!\u201d cried a voice in the crowd,\n>\n> \u201cOld man dies!\u201d The note he left was signed,\n>\n> \u2018Old Kiczales\u2019 - it seems he\u2019s drowned!\n>\n> Selling Lisp by the pound.\n\n# The myth of the Lisp \u201clanguage\u201d\n\nSome people attempting to sell \u201cLisp\u201d would characterise Lisp by the same\nthings as the average r/programmerhumor reader: copious numbers of\nparentheses, and nothing else. Before a Lisp game jam, I asked borodust if I\ncould use a COBOL code generator to write a game, and presented a mockup of a\n\u201cHello world\u201d program, a la:\n\n    \n    \n    (identification-division (program-id :hello-world)) (procedure-division (main (display \"Hello, world!\") (stop run)))\n\nMaybe he was in on the joke, but he said I could use that. This seems to be\nwhat we call Lisp. I have done nothing to the syntax or semantics of COBOL,\nother than to explicate the \u201cstructure\u201d of the syntax with parentheses. It\nappears only Lispers call, say, C, Lua, JavaScript, etc, etc \u201cALGOL family\u201d -\nanyone else would consider those languages\u2019 semantics to be too far out. What\nkind of \u201cLisp family\u201d do we have? Are these even \u201cdialects\u201d?\n\nThere is no common ground between them. We have none. There is no \u201cLisp\nfamily\u201d, there are no \u201cdialects\u201d. All these languages are mutually\nincomprehensible, and almost all terrible. The latter part cannot be provided\nwithout context, so I will provide some. It suffices to say that, by this\ndefinition of what \u201cLisp\u201d is, it\u2019s surely as painful to use as any other\n\u201cpopular\u201d language.\n\n# The simplification of the environment\n\nCommon Lisp is a programming system, not just a language: Stuff is updateable,\ninspectable, etc, etc - large parts of Common Lisp are designed to support\ninteraction and introspection. Almost all type, function and variable bindings\ncan be replaced, there is an interactive debugger, and the way in which this\nis handled is part of the Common Lisp standard. By this standard alone, it\nseems that Common Lisp has more in common with Smalltalk, Self or Erlang, than\nwith Racket, Clojure, Fennel and so on.\n\nSo, saying the environment is unimportant, like the Awesome Lisp Languages\nlist says, is a big fucking lie, and hosting a Lisp system on another\nenvironment, which does not provide such features, can\u2019t be seriously\nconsidered a net positive! The experience of the programmer is bounded by the\nworst parts of the system - which is always going to be the \u201chost\u201d environment\nin such a situation. Thus, Lisp only really provides an advantage when the\nhost environment is also Lisp.\n\nAccording to the introduction to that list, we learn that \u201cif we translate the\nlanguages to a common syntax, the similarities are more apparent\u201d, and the\nsimilarities are that they are mere programming languages, not programming\nsystems, and thus they have poor support for interactive programming and\ndebugging, rarely late bind, and so on. In short, they stink. What I mean by a\n\u201cprogramming system\u201d is one of the subjects of Richard P Gabriel\u2019s paper The\nStructure of a Programming Language Revolution, and in short, a programming\nsystem is defined in terms of the running environment, not in terms of\nfeatures in source code, and there are tools to make conventions easy to\nfollow. Both features are directly dependent on an environment; one does not\nhave the same programming system, if the environment is pulled from under its\nfeet.\n\nAnd there is rarely an engineering advantage to the \u201ctwo language\u201d design,\nwhere we design fast parts of a program in one language, say C, and then the\nslow parts in another language, say, Python or Lisp. As far as I know, this is\nbasically only seriously considered in Python, where the reference\nimplementation is some magnitudes slower than even SBCL. But it is socially\nacceptable to FFI out to C or Java for basically anything, and it\u2019s fine to\nuse Lisp either as a scripting language or driver for some other core logic in\nthose languages.\n\n> Well, Lisp is a jealous god. You want productivity, and [... if] that means\n> not cluttering up your system with 25 languages, then you won\u2019t do it if you\n> want productivity. You start falling prey to a \u2018productivity\u2019 form of\n> Amdahl\u2019s Law: If you are programming in Lisp and another language (C++,\n> say), and about 50% of the system is written in each, then even if Lisp has\n> infinite productivity, you\u2019ve only speeded things up by a factor of 2. Thus,\n> even a little bit of a non-Lisp language can really throw a monkey wrench\n> into the system, given that Lisp is so much more productive than non-Lisp.\n>\n> \u2013 Henry Baker\n> https://groups.google.com/g/comp.lang.functional/c/xLNt2BU34SA/m/UJdY51y7SZYJ\n\n# Taking it all\n\nWhen a problem appears, it should not be necessary to solve the problem by\nmaking other problems harder. One nice thing to model is \u201cidentity\u201d of data,\ni.e. that two structures with the same values are different somehow. Object-\noriented languages (and procedural languages with some effort) provide\nintrinsic \u201cidentity\u201d by using references to structures; the memory address is\nused to form identity. Some functional programmers, particuarly Clojure\nprogrammers, said the equivalent of \u201cfuck it, we don\u2019t need identity, cause\nthat doesn\u2019t model time. With pure functions, one can model time.\u201d The book\n\u201cThe Joy of Clojure\u201d calls it a \u201cflip book\u201d model, where one flips through\nmultiple values; but there is no flip book, only pictures and stepping that\none has to glue themselves. The book is provided by the user, for better or\nworse. (Definitely for the worse.)\n\nSo how do we achieve both identity and time? Worlds provide STM-like control\nover side effects http://www.vpri.org/pdf/tr2011001_final_worlds.pdf; they\u2019re\na better flipbook, as you have defined pages (worlds), and they give you\nobject identity too. The user only has to provide an ordering of worlds,\nbinding the metaphorical flipbook. Such a design is easily achieved using the\nmeta-object protocol (gasp!) Common Lisp provides, and I did it long ago for\nkicks. So when I hear that object-oriented languages don\u2019t model \u201ctime\u201d, I am\nmore than aware that the exact opposite is true. If someone made a Lisp with a\n\u201cflip book\u201d time model, and a Lisp with a worlds model, I would be more likely\nto use the latter, because it does not make problems with object identity\nharder.\n\n# Optimisations\n\nPareto principle your code: if nice-looking fast code isn\u2019t possible, then\nlocalise the ugly fast code, and keep an acceptable model for the rest. It\nshould never be an aim to design a language that makes everything ugly and\nfast, and such a language should never be used by anyone.\n\nBut I lied about \u201cugly and fast\u201d - they won\u2019t be fast, because you\u2019re up\nshit\u2019s creek for debugging, and have no room to test out optimisations. I had\ncobbled up an \u201cinteractive\u201d environment for OpenCL for a simulation project,\nallowing me to rebuild some GPU code quite quickly, and check what the GPU\nreturns before I post-process it on the CPU. With this environment, I was more\nthan able to change some of the code, then observe what it would generate with\nsmaller batches, and check that it looked correct. Provided with this\nenvironment (and spare minds provided by ##symbolics2), a 56\u00d7 speedup in a\nmere few days of work was achieved. Such a feat would not be possible without\nlive testing and debugging, and it would not be made easier by using\nparenthesized-prefix syntax to interact with a much less interactive\nenvironment.\n\nFollowing the previous two points, it follows that optimising code should\nresult in still nice-looking code, and no loss of interaction and other\nqualities. Robert Strandh wrote a letter (published in #sicl) about ideas for\na new Common Lisp \u201cstandard\u201d, of which the part on block compilation is\ninteresting:\n\n> Block compilation is a way to make the code faster by making assumptions\n> that can\u2019t change in the future. But what if there are techniques for making\n> the code as fast anyway, without any particular new feature (I am working on\n> it). Should we then force people to include block compilation anyway in\n> their systems, even though it is not necessary, just so that others who are\n> not that good with their implementations can continue using inferior\n> technology?\n\nEven in the strange world of Scheme, Abelson and Sussman have reminded us that\n\u201cprograms must be written for people to read, and only incidentally for\nmachines to execute.\u201d And this is not at odds with writing high-performance\ncode. To repeat a theme in the introduction, people who write unnecessarily\nlow-level Lisp code are about as ignorant of compiler improvements in the last\nfew decades as people who complain that Lisp must be a slow and interpreted\nlanguage.\n\n# What\u2019s Lisp then?\n\nWhat\u2019s in a name? discusses how the terms \u201cobject-oriented programming\u201d and\n\u201cincremental compilation\u201d have been abused. The article is interesting in\nitself, but the most striking part is Pitman\u2019s statement that \u201cobject-oriented\nprogramming is best characterized as a philosophy, a methodology, a style\u201d and\nnot exactly a set of features.\n\nIn a similar fashion, I have attempted to illustrate a style of Common Lisp,\nin which the \u201clanguage\u201d is in fact an interactive programming system, features\nsubsume multiple programming paradigms, occasionally \u201cbeating them at their\nown game\u201d, and provides excellent efficiency for high-level, readable\nprograms. Such a style is why one sticks around with a language; there is not\nanother language with the described design strategies.\n\nAnd when a language designer attempts to \u201cinnovate\u201d Lisp, by imitating the\ndesign strategies of a more mundane language like C++ or Rust, and\ndisregarding the strategies that made it successful in its niches, they are\nsurely selling Lisp by the pound. The attempts to \u201csell\u201d Lisp, by dropping out\nits qualities in favour for more familiar ones, are as misguided as marketing\nanchovies by selling cans of tuna and calling them anchovies. It is also\nunlikely that one who falls for this trick would move onto a \u201creal\u201d Lisp,\nwould one make the distinction for marketing purposes, because such properties\ndon\u2019t exist in those languages.\n\nIt is for these reasons that I don\u2019t care for Lisp by itself - I am more\ninterested in optimizing compilers which work their magic while also providing\nlate binding, updatable instances, etc, and environments which support\nefficient execution of high-level programs; so trying to sell Lisp by the\npound, and market it by ripping out the actually interesting techniques, is a\nterrible, terrible idea.\n\nOne final thing I should say: it is absolutely possible to sell Common Lisp by\nthe pound. People write libraries which completely break these properties of\nthe language, say by requiring you put all your behaviour into some event loop\nfunction, which you can\u2019t change the body of without having to restarting\neverything. Again, people write CL libraries which are no more than mere\naggregations of C interfaces.\n\nSo what is one to do? One is to run. If I am to take what I wrote seriously,\nthen I am sure that I am made incredibly powerful with these facilities for\nprogram design and optimization. Granted, there are large codebases that are\nstill large even if you can drop the time to program by some two-digit factor,\nbut generally one should seriously consider a reimplementation and perhaps a\nredesign of any code written without these facilities. It is quasi-common\nknowledge that the software industry needs a kick up the arse, and taking\nthese features seriously would leave a serious imprint on people who already\nsold themselves out to inferior programming environments.\n\n###\n\nborodust commented Oct 15, 2021\n\nThe Only Lisp for me personally is Common Lisp - everything else is not\nenough. But for LGJ we use lousy definition of what acceptable Lisp dialect\nis.\n\nAlso I'm always on the joke about what Lisp actually is.\n\nSign up for free to join this conversation on GitHub. Already have an account?\nSign in to comment\n\n## Footer\n\n\u00a9 2024 GitHub, Inc.\n\nYou can\u2019t perform that action at this time.\n\n", "frontpage": false}
