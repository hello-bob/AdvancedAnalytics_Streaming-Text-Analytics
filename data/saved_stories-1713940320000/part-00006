{"aid": "40135511", "title": "Complex zero-downtime schema migrations in Postgres", "url": "https://fabianlindfors.se/blog/complex-schema-migrations-with-reshape/", "domain": "fabianlindfors.se", "votes": 2, "user": "jfrisks", "posted_at": "2024-04-23 18:36:59", "comments": 0, "source_title": "Fabian Lindfors", "source_text": "Complex zero-downtime schema migrations in Postgres \u2013 Fabian Lindfors\n\n## Fabian Lindfors\n\n# Complex zero-downtime schema migrations in Postgres\n\n\u2190 All posts \u00b7 21 Jan 2024\n\nI recently released a new version of Reshape, a tool for automating zero-\ndowntime schema migrations in Postgres. I\u2019m quite excited about this new\nversion as it automates schema migrations that require changes across multiple\ntables, all whilst ensuring zero downtime for both your application and\ndatabase. I\u2019ll lay out an example of such a complex, multi-table migration\nhere but you might also like to read the introductory blog post for Reshape\nfirst.\n\nUntil now, Reshape supported a quite wide variety of migrations but they were\nall limited to a single table. With the latest version, Reshape can now make\nschema migrations that span multiple tables, including backfilling data in new\ntables and changing the structure of data that is spread out across tables.\nLet\u2019s go through an example of where this can be useful: going from a 1:N\nrelationship to N:M!\n\nSay we have an application where users can sign in and access data tied to an\naccount, and multiple users can have access to one account. In our database\nschema, we are representing this with two tables, users and accounts, where\nusers has a column that references the account it belongs to and it also\ncontains a column that tells us which role this user has for the account.\n\nThis database schema is serving us well but now we have a new feature we want\nto implement, a single user should be able to have access to several accounts,\nwith potentially different roles for each. To make this feature a reality, we\nwould have to change database schema to support a many-to-many relationship\nbetween users and accounts. Preferably, our database schema should look\nsomething like this:\n\nMaking this change without breaking our application or bringing it down is not\neasy. To ensure zero downtime, we would have to go through these steps\nmanually:\n\n  1. Add the new account_users table and update application to write both to the new table as well as the existing columns on users (deploy)\n  2. Write and run a script that backfills account_users based on the existing data in users\n  3. Update application to read from the account_users table (deploy)\n  4. Update application to stop writing to the columns on users (deploy)\n  5. Remove account_id and account_role columns on users\n\nThat\u2019s a lot of manual work! Several pull requests and deploys and a lot of\nwaiting, with plenty of room for human errors. What would the process look\nlike with Reshape?\n\n  1. Write a migration and update your application to read and write to account_users instead (deploy it all in one go)\n\nThe magic here of course lies in how you write that migration. You define how\nto translate between the new and old schema, and Reshape takes care of the\nrest. More specifically, here\u2019s what the Reshape migration definition could\nlook like:\n\n    \n    \n    # Add `account_users` as a junction table [[actions]] type = \"create_table\" name = \"account_users\" primary_key = [\"account_id\", \"user_id\"] [[actions.columns]] name = \"account_id\" type = \"INTEGER\" [[actions.columns]] name = \"user_id\" type = \"INTEGER\" # `role` is currently stored directly on the `users` table but is part of the relationship [[actions.columns]] name = \"role\" type = \"TEXT\" nullable = false # Tell Reshape how to backfill the new table from `users` # In `values`, we map a `users` row to a row in this new `account_users` table # `where` tells Reshape how to match rows in `users` with the new table [actions.up] table = \"users\" values = { user_id = \"id\", account_id = \"account_id\", role = \"account_role\" } where = \"account_users.user_id = users.id\" # Remove `account_id` from `users` as this relation is now handled by the new `account_users` table [[actions]] type = \"remove_column\" table = \"users\" column = \"account_id\" # When `account_users` is updated, we write the `account_id` back to `users` [actions.down] table = \"account_users\" value = \"account_users.account_id\" where = \"users.id = account_users.user_id\" # Remove `account_role` from `users` as this is now tracked for each account in the `account_users` table [[actions]] type = \"remove_column\" table = \"users\" column = \"account_role\" # When `account_users` is updated, we write the role back to `users` [actions.down] table = \"account_users\" value = \"account_users.role\" where = \"users.id = account_users.user_id\"\n\nDuring your deploy of this migration and your application changes, Reshape\nwill set up triggers and views to make sure both the old and new schema are\naccessible simultaneously. This is important because during the deploy of your\nnew application, there will be some time where both the old and new\napplication version are running and interacting with the database at the same\ntime. When your old application makes a write to the old account_id and\naccount_role columns, Reshape will automatically make the corresponding\nchanges to account_users, and vice versa if your new application makes\nchanges. On top of that, Reshape will automatically run a backfill to ensure\naccount_users is fully populated, so once your new application rolls out, it\ncan read from the table and be certain all the data it expects will be there.\n\nI\u2019d be remiss not to mention that many application don\u2019t need zero-downtime\nschema migrations. In many cases, it\u2019s completely fine to bring your\napplication down fully to make schema changes, in which case you wouldn\u2019t need\nsomething like Reshape! I do believe Reshape becomes even more powerful for\nmore complex migrations like the one above though. Making simple changes to\nyour database might only take a few seconds of downtime, but running a\nbackfill can take much longer depending on the size of your data.\n\nIf you\u2019d like to chat about Reshape or schema migrations in general, please\nreach out! You might also be interested in a new project I\u2019m working on which\ntakes these ideas to the next level: ReshapeDB, an all new database built from\nthe ground up to make complex schema and data migrations simple and safe.\nReach out if you\u2019d like to know more about that!\n\n", "frontpage": false}
