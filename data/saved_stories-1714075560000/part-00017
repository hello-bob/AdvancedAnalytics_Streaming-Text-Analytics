{"aid": "40155473", "title": "Re-implementing the Nix protocol in Rust", "url": "https://www.tweag.io/blog/2024-04-25-nix-protocol-in-rust/", "domain": "tweag.io", "votes": 1, "user": "ingve", "posted_at": "2024-04-25 09:55:43", "comments": 0, "source_title": "Re-implementing the Nix protocol in Rust", "source_text": "Re-implementing the Nix protocol in Rust - Tweag\n\nTechnical groups\n\nOpen source\n\nCareers\n\nResearch\n\nBlog\n\nContact\n\nConsulting services\n\nTechnical groups\n\nOpen source\n\nCareers\n\nResearch\n\nBlog\n\nContact\n\nConsulting services\n\n## Re-implementing the Nix protocol in Rust\n\n25 April 2024 \u2014 by Joe Neeman\n\nThe Nix daemon uses a custom binary protocol \u2014 the nix daemon protocol \u2014 to\ncommunicate with just about everything. When you run nix build on your\nmachine, the Nix binary opens up a Unix socket to the Nix daemon and talks to\nit using the Nix protocol^1. When you administer a Nix server remotely using\nnix build --store ssh-ng://example.com [...], the Nix binary opens up an SSH\nconnection to a remote machine and tunnels the Nix protocol over SSH. When you\nuse remote builders to speed up your Nix builds, the local and remote Nix\ndaemons speak the Nix protocol to one another.\n\nDespite its importance in the Nix world, the Nix protocol has no specification\nor reference documentation. Besides the original implementation in the Nix\nproject itself, the hnix-store project contains a re-implementation of the\nclient end of the protocol. The gorgon project contains a partial re-\nimplementation of the protocol in Rust, but we didn\u2019t know about it when we\nstarted. We do not know of any other implementations. (The Tvix project\ncreated its own gRPC-based protocol instead of re-implementing a Nix-\ncompatible one.)\n\nSo we re-implemented the Nix protocol, in Rust. We started it mainly as a\nlearning exercise, but we\u2019re hoping to do some useful things along the way:\n\n  * Document and demystify the protocol. (That\u2019s why we wrote this blog post! \ud83d\udc4b)\n  * Enable new kinds of debugging and observability. (We tested our implementation with a little Nix proxy that transparently forwards the Nix protocol while also writing a log.)\n  * Empower other third-party Nix clients and servers. (We wrote an experimental tool that acts as a Nix remote builder, but proxies the actual build over the Bazel Remote Execution protocol.)\n\nUnlike the hnix-store re-implementation, we\u2019ve implemented both ends of the\nprotocol. This was really helpful for testing, because it allowed our\ndebugging proxy to verify that a serialization/deserialization round-trip gave\nus something byte-for-byte identical to the original. And thanks to Rust\u2019s\nprocedural macros and the serde crate, our implementation is declarative,\nmeaning that it also serves as concise documentation of the protocol.\n\n## Structure of the Nix protocol\n\nA Nix communication starts with the exchange of a few magic bytes, followed by\nsome version negotiation. Both the client and server maintain compatibility\nwith older versions of the protocol, and they always agree to speak the newest\nversion supported by both.\n\nThe main protocol loop is initiated by the client, which sends a \u201cworker op\u201d\nconsisting of an opcode and some data. The server gets to work on carrying out\nthe requested operation. While it does so, it enters a \u201cstderr streaming\u201d mode\nin which it sends a stream of logging or tracing messages back to the client\n(which is how Nix\u2019s progress messages make their way to your terminal when you\nrun a nix build). The stream of stderr messages is terminated by a special\nSTDERR_LAST message. After that, the server sends the operation\u2019s result back\nto the client (if there is one), and waits for the next worker op to come\nalong.\n\n## The Nix wire format\n\nNix\u2019s wire format starts out simple. It has two basic types:\n\n  * unsigned 64-bit integers, encoded in little-endian order; and\n  * byte buffers, written as a length (a 64-bit integer) followed by the bytes in the buffer. If the length of the buffer is not a multiple of 8, it is zero-padded to a multiple of 8 bytes. Strings on the wire are just byte buffers, with no specific encoding.\n\nCompound types are built up in terms of these two pieces:\n\n  * Variable-length collections like lists, sets, or maps are represented by the number of elements they contain (as a 64-bit integer) followed by their contents.\n  * Product types (i.e. structs) are represented by listing out their fields one-by-one.\n  * Sum types (i.e. unions) are serialized with a tag followed by the contents.\n\nFor example, a \u201cvalid path info\u201d consists of a deriver (a byte buffer), a hash\n(a byte buffer), a set of references (a sequence of byte buffers), a\nregistration time (an integer), a nar size (an integer), a boolean\n(represented as an integer in the protocol), a set of signatures (a sequence\nof byte buffers), and finally a content address (a byte buffer). On the wire,\nit looks like:\n\n    \n    \n    3c 00 00 00 00 00 00 00 2f 6e 69 78 2f 73 74 6f 72 65 ... 2e 64 72 76 00 00 00 00 <- deriver \u2570\u2500\u2500\u2500\u2500 length (60) \u2500\u2500\u2500\u2500\u256f \u2570\u2500\u2500\u2500 /nix/store/c3fh...-hello-2.12.1.drv \u2500\u2500\u2500\u256f \u2570 padding \u256f 40 00 00 00 00 00 00 00 66 39 39 31 35 63 38 37 36 32 ... 30 33 38 32 39 30 38 66 <- hash \u2570\u2500\u2500\u2500\u2500 length (64) \u2500\u2500\u2500\u2500\u256f \u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 sha256 hash \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f 02 00 00 00 00 00 00 00 \u256e \u2570\u2500\u2500 # elements (2) \u2500\u2500\u2500\u256f \u2502 \u2502 39 00 00 00 00 00 00 00 2f 6e 69 78 ... 2d 32 2e 33 38 2d 32 37 00 00 .. 00 00 \u2502 \u2570\u2500\u2500\u2500\u2500 length (57) \u2500\u2500\u2500\u2500\u256f \u2570\u2500\u2500 /nix/store/9y8p...glibc-2.38-27 \u2500\u2500\u256f \u2570\u2500 padding \u2500\u2500\u256f \u2502 references \u2502 38 00 00 00 00 00 00 00 2f 6e 69 78 ... 2d 68 65 6c 6c 6f 2d 32 2e 31 32 2e 31 \u2502 \u2570\u2500\u2500\u2500\u2500 length (56) \u2500\u2500\u2500\u2500\u256f \u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 /nix/store/zhl0...hello-2.12.1 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f \u256f 1c db e8 65 00 00 00 00 f8 74 03 00 00 00 00 00 00 00 00 00 00 00 00 00 <- numbers \u2570 2024-03-06 21:07:40 \u256f \u2570\u2500 226552 (nar size) \u2500\u256f \u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500 false \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f 01 00 00 00 00 00 00 00 \u256e \u2570\u2500\u2500 # elements (1) \u2500\u2500\u2500\u256f \u2502 \u2502 signatures 6a 00 00 00 00 00 00 00 63 61 63 68 65 2e 6e 69 ... 51 3d 3d 00 00 00 00 00 00 \u2502 \u2570\u2500\u2500\u2500\u2500 length (106) \u2500\u2500\u2500\u256f \u2570\u2500\u2500\u2500 cache.nixos.org-1:a7...oBQ== \u2500\u2500\u2500\u2500\u256f \u2570\u2500 padding \u2500\u2500\u256f \u256f 00 00 00 00 00 00 00 00 <- content address \u2570\u2500\u2500\u2500\u2500 length (0) \u2500\u2500\u2500\u2500\u2500\u256f\n\nThis wire format is not self-describing: in order to read it, you need to know\nin advance which data-type you\u2019re expecting. If you get confused or misaligned\nsomehow, you\u2019ll end up reading complete garbage. In my experience, this\nusually leads to reading a \u201clength\u201d field that isn\u2019t actually a length,\nfollowed by an attempt to allocate exabytes of memory. For example, suppose we\nwere trying to read the \u201cvalid path info\u201d written above, but we were expecting\nit to be a \u201cvalid path info with path,\u201d which is the same as a valid path info\nexcept that it has an extra path at the beginning. We\u2019d misinterpret\n/nix/store/c3f-...-hello-2.12.1.drv as the path, we\u2019d misinterpret the hash as\nthe deriver, we\u2019d misinterpret the number of references (2) as the number of\nbytes in the hash, and we\u2019d misinterpret the length of the first reference as\nthe hash\u2019s data. Finally, we\u2019d interpret /nix/sto as a 64-bit integer and\npromptly crash as we allocate space for more than 8\u00d71018 references.\n\nThere\u2019s one important exception to the main wire format: \u201cframed data\u201d. Some\nworker ops need to transfer source trees or build artifacts that are too large\nto comfortably fit in memory; these large chunks of data need to be handled\ndifferently than the rest of the protocol. Specifically, they\u2019re transmitted\nas a sequence of length-delimited byte buffers, the idea being that you can\nread one buffer at a time, and stream it back out or write it to disk before\nreading the next one. Two features make this framed data unusual: the sequence\nof buffers are terminated by an empty buffer instead of being length-delimited\nlike most of the protocol, and the individual buffers are not padded out to a\nmultiple of 8 bytes.\n\n## Serde\n\nSerde is the de-facto standard for serialization and deserialization in Rust.\nIt defines an interface between serialization formats (like JSON, or the Nix\nwire protocol) on the one hand and serializable data types on the other. This\ndivides our work into two parts: first, we implement the serialization format,\nby specifying the correspondence between Serde\u2019s data model and the Nix wire\nformat we described above. Then we describe how the Nix protocol\u2019s messages\nmap to the Serde data model.\n\nThe best part about using Serde for this task is that the second step becomes\nstraightforward and completely declarative. For example, the AddToStore worker\nop is implemented like\n\n    \n    \n    #[derive(serde::Deserialize, serde::Serialize)] pub struct AddToStore { pub name: StorePath, pub cam_str: StorePath, pub refs: StorePathSet, pub repair: bool, pub data: FramedData, }\n\nThese few lines handle both serialization and deserialization of the\nAddToStore worker op, while ensuring that they remain in-sync.\n\n## Mismatches with the Serde data model\n\nWhile Serde gives us some useful tools and shortcuts, it isn\u2019t a perfect fit\nfor our case. For a start, we don\u2019t benefit much from one of Serde\u2019s most\nimportant benefits: the decoupling between serialization formats and\nserializable data types. We\u2019re interested in a specific serialization format\n(the Nix wire format) and a specific collection of data types (the ones used\nin the Nix protocol); we don\u2019t gain much by being able to, say, serialize the\nNix protocol to JSON.\n\nThe main disadvantage of using Serde is that we need to match the Nix protocol\nto Serde\u2019s data model. Most things match fairly well; Serde has native support\nfor integers, byte buffers, sequences, and structs. But there were a few\nmismatches that we had to work around:\n\n  * Different kinds of sequences: Serde has native support for sequences, and it can support sequences that are either length-delimited or not. However, Serde does not make it easy to support length-delimited and non-length-delimited sequences in the same serialization format. And although most sequences in the Nix format are length-delimited, the sequence of chunks in a framed source are not. We hacked around this restriction by treating a framed source not as a sequence but as a tuple with 264 elements, relying on the fact that Serde doesn\u2019t care if you terminate a tuple early.\n  * The Serde data model is larger than the Nix protocol needs; for example, it supports floating point numbers, and integers of different sizes and signedness. Our Serde de/serializer raises an error at runtime if it encounters any of these data types. Our Nix protocol implementation avoids these forbidden data types, but the Serde abstraction between the serializer and the data types means that any mistakes will not be caught at compile time.\n  * Sum types tagged with integers: Serde has native support for tagged unions, but it assumes that they\u2019re tagged with either the variant name (i.e. a string) or the variant\u2019s index within a list of all possible variants. The Nix protocol uses numeric tags, but we can\u2019t just use the variant\u2019s index: we need to specify specific tags for specific variants, to match the ones used by Nix. We solved this by using our own derive macro for tagged unions. Instead of using Serde\u2019s native unions, we map a union to a Serde tuple consisting of a tag followed by its payload.\n\nBut with these mismatches resolved, our final definition of the Nix protocol\nis fully declarative and pretty straightforward:\n\n    \n    \n    #[derive(TaggedSerde)] // ^^ our custom procedural macro for unions tagged with integers pub enum WorkerOp { #[tagged_serde = 1] // ^^ this op has opcode 1 IsValidPath(StorePath, Resp<bool>), // ^^ ^^ the op's response type // || the op's payload #[tagged_serde = 6] QueryReferrers(StorePath, Resp<StorePathSet>), #[tagged_serde = 7] AddToStore(AddToStore, Resp<ValidPathInfoWithPath>), #[tagged_serde = 9] BuildPaths(BuildPaths, Resp<u64>), #[tagged_serde = 10] EnsurePath(StorePath, Resp<u64>), #[tagged_serde = 11] AddTempRoot(StorePath, Resp<u64>), #[tagged_serde = 14] FindRoots((), Resp<FindRootsResponse>), // ... another dozen or so ops }\n\n## Next steps\n\nOur implementation is still a work in progress; most notably the API needs a\nlot of polish. It also only supports protocol version 34, meaning it cannot\ninteract with old Nix implementations (before 2.8.0, which was released in\n2022) and will lack support for features introduced in newer versions of the\nprotocol.\n\nSince in its current state our Nix protocol implementation can already do some\nuseful things, we\u2019ve made the crate available on crates.io. If you have a use-\ncase that isn\u2019t supported yet, let us know! We\u2019re still trying to figure out\nwhat can be done with this.\n\nIn the meantime, now that we can handle the Nix remote protocol itself we\u2019ve\nshifted our experimental hacking over to integrating with Bazel remote\nexecution. We\u2019re writing a program that presents itself as a Nix remote\nbuilder, but instead of executing the builds itself it sends them via the\nBazel Remote Execution API to some other build infrastructure. And then when\nthe build is done, our program sends it back to the requester as though it\nwere just a normal Nix remote builder.\n\nBut that\u2019s just our plan, and we think there must be more applications of\nthis. If you could speak the Nix remote protocol, what would you do with it?\n\n  1. Unless you\u2019re running as a user that has read/write access to the nix store, in which case nix build will just modify the store directly instead of talking to the Nix daemon.\u21a9\n\nAbout the authors\n\nJoe NeemanJoe is a programmer and a mathematician. He loves getting lost in\nnew topics and is a fervent believer in clear documentation.\n\nIf you enjoyed this article, you might be interested in joining the Tweag\nteam.\n\nThis article is licensed under a Creative Commons Attribution 4.0\nInternational license.\n\n\u2190 Cloud Native Computing in 2024\u2014feeling the pulse at Kubecon\n\nCompany\n\nAboutOpen SourceCareersContact Us\n\nWhat we do\n\nStrategyProduct DevelopmentPlatform ModernizationDigital OperationsWork\n\nInsights\n\nModus BlogOspo BlogResearchInnovation podcast\n\nConnect with us\n\n\u00a9 2024 Modus Create, LLC\n\nPrivacy PolicySitemap\n\nBy clicking \u201cAccept All Cookies\u201d, you agree to the storing of cookies on your\ndevice to enhance site navigation, analyze site usage, and assist in our\nmarketing efforts. Privacy Policy\n\n## Privacy Preference Center\n\nWhen you visit any website, it may store or retrieve information on your\nbrowser, mostly in the form of cookies. This information might be about you,\nyour preferences or your device and is mostly used to make the site work as\nyou expect it to. The information does not usually directly identify you, but\nit can give you a more personalized web experience. Because we respect your\nright to privacy, you can choose not to allow some types of cookies. Click on\nthe different category headings to find out more and change our default\nsettings. However, blocking some types of cookies may impact your experience\nof the site and the services we are able to offer. More information\n\n### Manage Consent Preferences\n\n#### Strictly Necessary Cookies\n\nAlways Active\n\nThese cookies are necessary for the website to function and cannot be switched\noff in our systems. They are usually only set in response to actions made by\nyou which amount to a request for services, such as setting your privacy\npreferences, logging in or filling in forms. You can set your browser to block\nor alert you about these cookies, but some parts of the site will not then\nwork. These cookies do not store any personally identifiable information.\n\n#### Performance Cookies\n\nThese cookies allow us to count visits and traffic sources so we can measure\nand improve the performance of our site. They help us to know which pages are\nthe most and least popular and see how visitors move around the site. All\ninformation these cookies collect is aggregated and therefore anonymous. If\nyou do not allow these cookies we will not know when you have visited our\nsite, and will not be able to monitor its performance.\n\n### Performance Cookies\n\nlabel\n\nConsent Leg.Interest\n\nlabel\n\nlabel\n\nlabel\n\n", "frontpage": false}
