{"aid": "40204713", "title": "Here Document", "url": "https://en.wikipedia.org/wiki/Here_document", "domain": "wikipedia.org", "votes": 1, "user": "thunderbong", "posted_at": "2024-04-29 22:10:59", "comments": 0, "source_title": "Here document", "source_text": "Here document - Wikipedia\n\nJump to content\n\nSearch\n\n# Here document\n\n  * \u0627\u0644\u0639\u0631\u0628\u064a\u0629\n  * Deutsch\n  * Espa\u00f1ol\n  * Fran\u00e7ais\n  * \ud55c\uad6d\uc5b4\n  * \u05e2\u05d1\u05e8\u05d9\u05ea\n  * \u65e5\u672c\u8a9e\n  * Norsk bokm\u00e5l\n  * Portugu\u00eas\n  * \u0420\u0443\u0441\u0441\u043a\u0438\u0439\n  * \u0423\u043a\u0440\u0430\u0457\u043d\u0441\u044c\u043a\u0430\n  * \u4e2d\u6587\n\nEdit links\n\nFrom Wikipedia, the free encyclopedia\n\nSection of a source code file that is treated as if it were a separate file\n\nIn computing, a here document (here-document, here-text, heredoc, hereis,\nhere-string or here-script) is a file literal or input stream literal: it is a\nsection of a source code file that is treated as if it were a separate file.\nThe term is also used for a form of multiline string literals that use similar\nsyntax, preserving line breaks and other whitespace (including indentation) in\nthe text.\n\nHere documents originate in the Unix shell,^[1] and are found in the Bourne\nshell (sh), C shell (csh),^[2] tcsh (tcsh),^[3] KornShell (ksh), Bourne Again\nShell (bash), and Z shell (zsh), among others. Here document-style string\nliterals are found in various high-level languages, notably the Perl\nprogramming language (syntax inspired by Unix shell) and languages influenced\nby Perl, such as PHP and Ruby. JavaScript also supports this functionality via\ntemplate literals, a feature added in its 6th revision (ES6). Other high-level\nlanguages such as Python, Julia and Tcl have other facilities for multiline\nstrings.\n\nHere documents can be treated either as files or strings. Some shells treat\nthem as a format string literal, allowing variable substitution and command\nsubstitution inside the literal.\n\n## Overview[edit]\n\nThe most common syntax for here documents, originating in Unix shells, is <<\nfollowed by a delimiting identifier (often the word EOF or END^[4]), followed,\nstarting on the next line, by the text to be quoted, and then closed by the\nsame delimiting identifier on its own line. This syntax is because here\ndocuments are formally stream literals, and the content of the here document\nis often redirected to stdin (standard input) of the preceding command or\ncurrent shell script/executable.\n\nThe here document syntax analogous to the shell syntax for input redirection,\nwhich is < followed by the name of the file to be used as input.\n\nOther languages often use substantially similar syntax, but details of syntax\nand actual functionality can vary significantly. When used simply for string\nliterals, the << does not indicate indirection, but is simply a starting\ndelimiter convention. In some languages, such as Ruby, << is also used for\ninput redirection, thus resulting in << being used twice if one wishes to\nredirect from a here document string literal.\n\n## File literals[edit]\n\nNarrowly speaking, here documents are file literals or stream literals. These\noriginate in the Unix shell, though similar facilities are available in some\nother languages.\n\n### Unix shells[edit]\n\nHere documents are available in many Unix shells.^[1] In the following\nexample, text is passed to the tr command (transliterating lower to upper-\ncase) using a here document. This could be in a shell file, or entered\ninteractively at a prompt.\n\n    \n    \n    $ LANG=C tr a-z A-Z << END > one two three > four five six > END ONE TWO THREE FOUR FIVE SIX\n\nIn this case END was used as the delimiting identifier. It specified the start\nand end of the here document. The redirect and the delimiting identifier do\nnot need to be separated by a space: <<END or << END both work equally well.\n\nBy default, behavior is largely identical to the contents of double quotes:\nvariable names are replaced by their values, commands within backticks are\nevaluated, etc.^[a]\n\n    \n    \n    $ cat << EOF > \\$ Working dir \"$PWD\" `pwd` > EOF $ Working dir \"/home/user\" /home/user\n\nThis can be disabled by quoting any part of the label, which is then ended by\nthe unquoted value;^[b] the behavior is essentially identical to that if the\ncontents were enclosed in single quotes. Thus for example by setting it in\nsingle quotes:\n\n    \n    \n    $ cat << 'EOF' > \\$ Working dir \"$PWD\" `pwd` > EOF \\$ Working dir \"$PWD\" `pwd`\n\nDouble quotes may also be used, but this is subject to confusion, because\nexpansion does occur in a double-quoted string, but does not occur in a here\ndocument with double-quoted delimiter.^[5] Single- and double-quoted\ndelimiters are distinguished in some other languages, notably Perl (see\nbelow), where behavior parallels the corresponding string quoting.\n\nIn POSIX shell but not csh/tcsh, appending a minus sign to the << (i.e. <<-)\nhas the effect that leading tabs are ignored.^[3] This allows indenting here\ndocuments in shell scripts (primarily for alignment with existing indentation)\nwithout changing their value:^[c]\n\nA script containing:\n\n    \n    \n    LANG=C tr a-z A-Z <<- END_TEXT Here doc with <<- A single space character (i.e. 0x20 ) is at the beginning of this line This line begins with a single TAB character i.e 0x09 as does the next line END_TEXT echo The intended end was before this line echo and these were not processed by tr echo +++++++++++++++ LANG=C tr a-z A-Z << END_TEXT Here doc with << A single space character (i.e. 0x20 ) is at the beginning of this line This line begins with a single TAB character i.e 0x09 as does the next line END_TEXT echo The intended end was before this line, echo but because the line with the delimiting Identifier began with a TAB it was NOT recognized and echo the tr command continued processing.\n\nproduces:\n\n    \n    \n    HERE DOC WITH <<- A SINGLE SPACE CHARACTER (I.E. 0X20 ) IS AT THE BEGINNING OF THIS LINE THIS LINE BEGINS WITH A SINGLE TAB CHARACTER I.E 0X09 AS DOES THE NEXT LINE The intended end was before this line and these were not processed by tr +++++++++++++++ HERE DOC WITH << A SINGLE SPACE CHARACTER (I.E. 0X20 ) IS AT THE BEGINNING OF THIS LINE THIS LINE BEGINS WITH A SINGLE TAB CHARACTER I.E 0X09 AS DOES THE NEXT LINE END_TEXT ECHO THE INTENDED END WAS BEFORE THIS LINE, ECHO BUT BECAUSE THE LINE WITH THE DELIMITING IDENTIFIER BEGAN WITH A TAB IT WAS NOT RECOGNIZED AND ECHO THE TR COMMAND CONTINUED PROCESSING.\n\nAnother use is to output to a file:\n\n    \n    \n    $ cat << EOF > ~/testFile001 > 3 spaces precede this text. > A single tab character is at the beginning of this line. >Nothing precedes this text EOF\n\n#### Here strings[edit]\n\nA here string (available in bash, ksh, or zsh) is syntactically similar,\nconsisting of <<<, and effects input redirection from a word (a sequence\ntreated as a unit by the shell, in this context generally a string literal).\nIn this case the usual shell syntax is used for the word (\u201chere string\nsyntax\u201d), with the only syntax being the redirection: a here string is an\nordinary string used for input redirection, not a special kind of string.\n\nA single word need not be quoted:\n\n    \n    \n    $ LANG=C tr a-z A-Z <<< one ONE\n\nIn case of a string with spaces, it must be quoted:\n\n    \n    \n    $ LANG=C tr a-z A-Z <<< 'one two three' ONE TWO THREE\n\nThis could also be written as:\n\n    \n    \n    $ foo='one two three' $ LANG=C tr a-z A-Z <<< \"$foo\" ONE TWO THREE\n\nMultiline strings are acceptable, yielding:\n\n    \n    \n    $ LANG=C tr a-z A-Z <<< 'one > two three' ONE TWO THREE\n\nNote that leading and trailing newlines, if present, are included:\n\n    \n    \n    $ LANG=C tr a-z A-Z <<< ' > one > two three > ' ONE TWO THREE $\n\nThe key difference from here documents is that, in here documents, the\ndelimiters are on separate lines; the leading and trailing newlines are\nstripped. Unlike here documents, here strings do not use delimiters.\n\nHere strings are particularly useful for commands that often take short input,\nsuch as the calculator bc:\n\n    \n    \n    $ bc <<< 2^10 1024\n\nNote that here string behavior can also be accomplished (reversing the order)\nvia piping and the echo command, as in:\n\n    \n    \n    $ echo 'one two three' | LANG=C tr a-z A-Z ONE TWO THREE\n\nhowever here strings are particularly useful when the last command needs to\nrun in the current process, as is the case with the read builtin:\n\n    \n    \n    $ echo 'one two three' | read -r a b c $ echo \"$a $b $c\"\n\nyields nothing, while\n\n    \n    \n    $ read -r a b c <<< 'one two three' $ echo \"$a $b $c\" one two three\n\nThis happens because in the previous example piping causes read to run in a\nsubprocess, and as such cannot affect the environment of the parent process.\n\n### Microsoft NMAKE[edit]\n\nIn Microsoft NMAKE, here documents are referred to as inline files. Inline\nfiles are referenced as << or <<pathname: the first notation creates a\ntemporary file, the second notation creates (or overwrites) the file with the\nspecified pathname. An inline file is terminated with << on a line by itself,\noptionally followed by the (case-insensitive) keyword KEEP or NOKEEP to\nindicate whether the created file should be kept.\n\n    \n    \n    target0: dependent0 command0 << temporary inline file ... << target1: dependent1 command1 << temporary, but preserved inline file ... <<KEEP target2: dependent2 command2 <<filename2 named, but discarded inline file ... <<NOKEEP target3: dependent3 command3 <<filename3 named inline file ... <<KEEP\n\n### R[edit]\n\nR does not have file literals, but provides equivalent functionality by\ncombining string literals with a string-to-file function. R allows arbitrary\nwhitespace, including newlines, in strings. A string then can be turned into a\nfile descriptor using the textConnection() function. For example, the\nfollowing turns a data table embedded in the source code into a data-frame\nvariable:\n\n    \n    \n    str <- \"State Population Income Illiteracy Life.Exp Murder HS.Grad Frost Alabama 3615 3624 2.1 69.05 15.1 41.3 20 Alaska 365 6315 1.5 69.31 11.3 66.7 152 Arizona 2212 4530 1.8 70.55 7.8 58.1 15 Arkansas 2110 3378 1.9 70.66 10.1 39.9 65\" x <- read.table(textConnection(str), header=TRUE, row.names=1)\n\n### Data segment[edit]\n\nPerl^[6] and Ruby^[7] have a form of file literal, which can be considered a\nform of data segment. In these languages, including the line __DATA__ (Perl)\nor __END__ (Ruby, old Perl) marks the end of the code segment and the start of\nthe data segment. Only the contents prior to this line are executed, and the\ncontents of the source file after this line are available as a file object:\nPACKAGE::DATA in Perl (e.g., main::DATA) and DATA in Ruby. As an inline file,\nthese are semantically similar to here documents, though there can be only one\nper script. However, in these languages the term \"here document\" instead\nrefers to multiline string literals, as discussed below.\n\n### Data URI Scheme[edit]\n\nAs further explained in Data URI scheme, all major web browsers understand\nURIs that start with data: as here document.\n\n## Multiline string literals[edit]\n\nThe term \"here document\" or \"here string\" is also used for multiline string\nliterals in various programming languages, notably Perl (syntax influenced by\nUnix shell), and languages influenced by Perl, notably PHP and Ruby. The\nshell-style << syntax is often retained, despite not being used for input\nredirection.\n\n### Perl-influenced[edit]\n\n#### Perl[edit]\n\nIn Perl there are several different ways to invoke here docs.^[8] The\ndelimiters around the tag have the same effect within the here doc as they\nwould in a regular string literal: For example, using double quotes around the\ntag allows variables to be interpolated, but using single quotes doesn't, and\nusing the tag without either behaves like double quotes. Using backticks as\nthe delimiters around the tag runs the contents of the heredoc as a shell\nscript. It is necessary to make sure that the end tag is at the beginning of\nthe line or the tag will not be recognized by the interpreter.\n\nNote that the here doc does not start at the tag\u2014but rather starts on the next\nline. So the statement containing the tag continues on after the tag.\n\nHere is an example with double quotes:\n\n    \n    \n    my $sender = \"Buffy the Vampire Slayer\"; my $recipient = \"Spike\"; print <<\"END\"; Dear $recipient, I wish you to leave Sunnydale and never return. Not Quite Love, $sender END\n\nOutput:\n\n    \n    \n    Dear Spike, I wish you to leave Sunnydale and never return. Not Quite Love, Buffy the Vampire Slayer\n\nHere is an example with single quotes:\n\n    \n    \n    print <<'END'; Dear $recipient, I wish you to leave Sunnydale and never return. Not Quite Love, $sender END\n\nOutput:\n\n    \n    \n    Dear $recipient, I wish you to leave Sunnydale and never return. Not Quite Love, $sender\n\nAnd an example with backticks (may not be portable):\n\n    \n    \n    my $shell_script_stdout = <<`END`; echo foo echo bar END\n\nIt is possible to start multiple heredocs on the same line:\n\n    \n    \n    say(<<BEGIN . \"this is the middle\\n\" . <<END); This is the beginning: BEGIN And now it is over! END # this is equivalent to: say(\"This is the beginning:\\nthis is the middle\\nAnd now it is over!\\n\");\n\nThe tag itself may contain whitespace, which may allow heredocs to be used\nwithout breaking indentation.\n\n    \n    \n    say <<' END'; Hello World END\n\nAlthough since Perl version 5.26,^[9] heredocs can include indention:\n\n    \n    \n    #prints \"Hello there\\n\" with no leading whitespace. if (1) { print <<~EOF; Hello there EOF }\n\nIn addition to these strings, Perl also features file literals, namely the\ncontents of the file following __DATA__ (formerly __END__) on a line by\nitself. This is accessible as the file object PACKAGE::DATA such as\nmain::DATA, and can be viewed as a form of data segment.\n\n#### PHP[edit]\n\nIn PHP, here documents are referred to as heredocs. In PHP heredocs are not\nstring literals. Heredoc text behaves just like a double-quoted string, but\nwithout the double quotes. For example, meaning `$` will be parsed as a\nvariable start, and `${` or `{$` as a complex variable start.\n\n    \n    \n    <?php $name = \"Joe Smith\"; $occupation = \"Programmer\"; echo <<<EOF This is a heredoc section. For more information talk to $name, your local $occupation. Thanks! EOF; $toprint = <<<EOF Hey $name! You can actually assign the heredoc section to a variable! EOF; echo $toprint; ?>\n\nOutputs\n\n    \n    \n    This is a heredoc section. For more information talk to Joe Smith, your local Programmer. Thanks! Hey Joe Smith! You can actually assign the heredoc section to a variable!\n\nIn PHP versions prior to 7.3, the line containing the closing identifier must\nnot contain any other characters, except an optional ending semicolon.\nOtherwise, it will not be considered to be a closing identifier, and PHP will\ncontinue looking for one. If a proper closing identifier is not found, a parse\nerror will result at the last line of the script. However, from version 7.3,\nit is no longer required that the closing identifier be followed by a\nsemicolon or newline. Additionally the closing identifier may be indented, in\nwhich case the indentation will be stripped from all lines in the doc\nstring.^[10]\n\nIn PHP 5.3 and later, like Perl, it is possible to not interpolate variables\nby surrounding the tag with single quotes; this is called a nowdoc:^[11]\n\n    \n    \n    $x = <<<'END' Dear $recipient, I wish you to leave Sunnydale and never return. Not Quite Love, $sender END;\n\nIn PHP 5.3+ it is also possible to surround the tag with double quotes, which\nlike Perl has the same effect as not surrounding the tag with anything at all.\n\n#### Ruby[edit]\n\nThe following Ruby code displays a grocery list by using a here document.\n\n    \n    \n    puts <<GROCERY_LIST Grocery list ---- 1. Salad mix. 2. Strawberries.* 3. Cereal. 4. Milk.* * Organic GROCERY_LIST\n\nThe result:\n\n    \n    \n    $ ruby grocery-list.rb Grocery list ------------ 1. Salad mix. 2. Strawberries.* 3. Cereal. 4. Milk.* * Organic\n\nThe << in a here document does not indicate input redirection, but Ruby also\nuses << for input redirection, so redirecting to a file from a here document\ninvolves using << twice, in different senses:\n\n    \n    \n    File::open(\"grocery-list\", \"w\") do |f| f << <<GROCERY_LIST Grocery list ---- 1. Salad mix. 2. Strawberries.* 3. Cereal. 4. Milk.* * Organic GROCERY_LIST end\n\nAs with Unix shells, Ruby also allows for the delimiting identifier not to\nstart on the first column of a line, if the start of the here document is\nmarked with the slightly different starter <<-. Besides, Ruby treats here\ndocuments as a double-quoted string, and as such, it is possible to use the\n#{} construct to interpolate code. The following example illustrates both of\nthese features:\n\n    \n    \n    now = Time.now puts <<-EOF It's #{now.hour} o'clock John, where are your kids? EOF\n\nRuby expands on this by providing the \"<<~\" syntax for omitting indentation on\nthe here document:\n\n    \n    \n    puts <<~EOF This line is indented two spaces. This line is indented four spaces. This line is indented six spaces. EOF\n\nThe common indentation of two spaces is omitted from all lines:\n\n    \n    \n    $ ruby indented-heredoc.rb This line is indented two spaces. This line is indented four spaces. This line is indented six spaces.\n\nLike Perl, Ruby allows for starting multiple here documents in one line:\n\n    \n    \n    puts <<BEGIN + \"<--- middle --->\\n\" + <<END This is the beginning: BEGIN And now it is over! END # this equals this expression: puts \"This is the beginning:\\n<--- middle --->\\nAnd now it is over!\"\n\nAs with Perl, Ruby features file literals, namely the contents of the file\nfollowing __END__ on a line by itself. This is accessible as the file object\nDATA and can be viewed as a form of data segment.\n\n### Python[edit]\n\nPython supports multi-line strings as a \"verbatim\" string. They may be\nenclosed in 3 single (') or double (\") quotation marks, the latter is shown in\nthe examples below.\n\n    \n    \n    print(\"\"\" Customer: Not much of a cheese shop is it? Shopkeeper: Finest in the district , sir. \"\"\")\n\nFrom Python 3.6 onwards, verbatim f-strings support variable and expression\ninterpolation.\n\n    \n    \n    shop_type = \"CHEESE\" accolade = \"finest\" print(f\"\"\" Customer: Not much of a {shop_type.lower()} shop is it? Shopkeeper: {accolade.capitalize()} in the district , sir. \"\"\")\n\n### C++[edit]\n\nSee also: C++11 \u00a7 New string literals\n\nSince C++11, C++ supports string literals with custom delimiter\n(\"my_delimiter\" in this example):\n\n    \n    \n    #include <ostream> const char* str = R\"my_delimiter(Start of string. New line slash \\ quote \" ' parens ) ( End of string)my_delimiter\"; std::cout << str << std::endl;\n\nwill print out\n\n    \n    \n    Start of string. New line slash \\ quote \" ' parens ) ( End of string\n\n### D[edit]\n\nSince version 2.0, D has support for here document-style strings using the 'q'\nprefix character. These strings begin with q\"IDENT followed immediately by a\nnewline (for an arbitrary identifier IDENT), and end with IDENT\" at the start\nof a line.\n\n    \n    \n    int main() { string list = q\"IDENT 1. Item One 2. Item Two 3. Item Three IDENT\"; writef( list ); }\n\nD also supports a few quoting delimiters, with similar syntax, with such\nstrings starting with q\"[ and ending with ]\" or similarly for other delimiter\ncharacter (any of () <> {} or []).\n\n### OS/JCL[edit]\n\nOn IBM's Job Control Language (JCL) used on its earlier MVS and current z/OS\noperating systems, data which is inline to a job stream can be identified by\nan * on a DD statement, such as //SYSIN DD * or //SYSIN DD *,DLM=text In the\nfirst case, the lines of text follow and are combined into a pseudo file with\nthe DD name SYSIN. All records following the command are combined until either\nanother OS/JCL command occurs (any line beginning with //), the default EOF\nsequence (/*) is found, or the physical end of data occurs. In the second\ncase, the conditions are the same, except the DLM= operand is used to specify\nthe text string signalling end of data, which can be used if a data stream\ncontains JCL (again, any line beginning with //), or the /* sequence (such as\ncomments in C or C++ source code). The following compiles and executes an\nassembly language program, supplied as in-line data to the assembler.\n\n    \n    \n    //AHAR JOB ('ALEX HARRIS') // EXEC ASMLG //SYSIN DD * APROG START XR 15,15 BR 14 END /* //* JOB ENDS\n\nThe //SYSIN DD * statement is the functional equivalent of <</* Indicating s\nstream of data follows, terminated by /*.\n\n### Racket[edit]\n\nRacket's here strings start with #<< followed by characters that define a\nterminator for the string.^[12] The content of the string includes all\ncharacters between the #<< line and a line whose only content is the specified\nterminator. More precisely, the content of the string starts after a newline\nfollowing #<<, and it ends before a newline that is followed by the\nterminator.\n\n    \n    \n    #lang racket (displayln #<<HERESTRING This is a simple here string in Racket. * One * Two * Three HERESTRING )\n\nOutputs:\n\n    \n    \n    This is a simple here string in Racket. * One * Two * Three\n\nNo escape sequences are recognized between the starting and terminating lines;\nall characters are included in the string (and terminator) literally.\n\n    \n    \n    #lang racket (displayln #<<A here string in Racket \u263a This string spans for multiple lines and can contain any Unicode symbol. So things like \u03bb, \u2620, \u03b1, \u03b2, are all fine. In the next line comes the terminator. It can contain any Unicode symbol as well, even spaces and smileys! A here string in Racket \u263a )\n\nOutputs:\n\n    \n    \n    This string spans for multiple lines and can contain any Unicode symbol. So things like \u03bb, \u2620, \u03b1, \u03b2, are all fine. In the next line comes the terminator. It can contain any Unicode symbol as well, even spaces and smileys!\n\nHere strings can be used normally in contexts where normal strings would:\n\n    \n    \n    #lang racket (printf #<<END Dear ~a, Thanks for the insightful conversation ~a. ~a END \"Isaac\" \"yesterday\" \"Carl\")\n\nOutputs:\n\n    \n    \n    Dear Isaac, Thanks for the insightful conversation yesterday. Carl\n\nAn interesting alternative is to use the language extension at-exp to write\n@-expressions.^[13] They look like this:\n\n    \n    \n    #lang at-exp racket (displayln @string-append{ This is a long string, very convenient when a long chunk of text is needed. No worries about escaping \"quotes\" or \\escapes. It's also okay to have \u03bb, \u03b3, \u03b8, ... Embed code: @(number->string (+ 3 4)) })\n\nOutputs:\n\n    \n    \n    This is a long string, very convenient when a long chunk of text is needed. No worries about escaping \"quotes\" or \\escapes. It's also okay to have \u03bb, \u03b3, \u03b8, ... Embed code: 7\n\nAn @-expression is not specific nor restricted to strings, it is a syntax form\nthat can be composed with the rest of the language.\n\n### Windows PowerShell[edit]\n\nIn PowerShell, here documents are referred to as here-strings. A here-string is a string which starts with an open delimiter (@\" or @') and ends with a close delimiter (\"@ or '@) on a line by itself, which terminates the string. All characters between the open and close delimiter are considered the string literal. Using a here-string with double quotes allows variables to be interpreted, using single quotes doesn't. Variable interpolation occurs with simple variables (e.g. $x but NOT $x.y or $x[0]). You can execute a set of statements by putting them in $() (e.g. $($x.y) or $(Get-Process | Out-String)).\n\nIn the following PowerShell code, text is passed to a function using a here-\nstring. The function ConvertTo-UpperCase is defined as follows:\n\n    \n    \n    PS > function ConvertTo-UpperCase($string) { $string.ToUpper() } PS > ConvertTo-UpperCase @' >> one two three >> eins zwei drei >> '@ ONE TWO THREE EINS ZWEI DREI\n\nHere is an example that demonstrates variable interpolation and statement\nexecution using a here-string with double quotes:\n\n    \n    \n    PS > $doc, $marty = 'Dr. Emmett Brown', 'Marty McFly' PS > $time = [DateTime]'Friday, October 25, 1985 8:00:00 AM' PS > $diff = New-TimeSpan -Minutes 25 PS > @\" >> $doc : Are those my clocks I hear? >> $marty : Yeah! Uh, it's $($time.Hour) o'clock! >> $doc : Perfect! My experiment worked! They're all exactly $($diff.Minutes) minutes slow. >> $marty : Wait a minute. Wait a minute. Doc... Are you telling me that it's $(($time + $diff).ToShortTimeString())? >> $doc : Precisely. >> $marty : Damn! I'm late for school! >> \"@ Dr. Emmett Brown : Are those my clocks I hear? Marty McFly : Yeah! Uh, it's 8 o'clock! Dr. Emmett Brown : Perfect! My experiment worked! They're all exactly 25 minutes slow. Marty McFly : Wait a minute. Wait a minute. Doc... Are you telling me that it's 08:25? Dr. Emmett Brown : Precisely. Marty McFly : Damn! I'm late for school!\n\nUsing a here-string with single quotes instead, the output would look like\nthis:\n\n    \n    \n    PS > @' >> $doc : Are those my clocks I hear? >> $marty : Yeah! Uh, it's $($time.Hour) o'clock! >> $doc : Perfect! My experiment worked! They're all exactly $($diff.Minutes) minutes slow. >> $marty : Wait a minute. Wait a minute. Doc... Are you telling me that it's $(($time + $diff).ToShortTimeString())? >> $doc : Precisely. >> $marty : Damn! I'm late for school! >> '@ $doc : Are those my clocks I hear? $marty : Yeah! Uh, it's $($time.Hour) o'clock! $doc : Perfect! My experiment worked! They're all exactly $($diff.Minutes) minutes slow. $marty : Wait a minute. Wait a minute. Doc... Are you telling me that it's $(($time + $diff).ToShortTimeString())? $doc : Precisely. $marty : Damn! I'm late for school!\n\n### DIGITAL Command Language (DCL)[edit]\n\nIn DCL scripts, any input line which does not begin with a $ symbol is\nimplicitly treated as input to the preceding command - all lines which do not\nbegin with $ are here-documents. The input is either passed to the program, or\ncan be explicitly referenced by the logical name SYS$INPUT (analogous to the\nUnix concept of stdin).\n\nFor instance, explicitly referencing the input as SYS$INPUT:\n\n    \n    \n    $ TYPE SYS$INPUT This text will be directly echoed to the screen by the TYPE command. $! other commands ...\n\nproduces:\n\n    \n    \n    This text will be directly echoed to the screen by the TYPE command.\n\nAdditionally, the DECK command, initially intended for punched card support\n(hence its name: it signified the beginning of a data deck) can be used to\nsupply input to the preceding command.^[14] The input deck is ended either by\nthe command $ EOD, or the character pattern specified by the /DOLLARS\nparameter to DECK.\n\nExample of a program totalling up monetary values:\n\n    \n    \n    $ RUN ADD_SUMS.EXE $ DECK $13.53 $3.33 $2.33 $ EOD\n\nWould produce the following output (presuming ADD_SUMS was written to read the\nvalues and add them):\n\n    \n    \n    $19.19\n\nExample of using DECK /DOLLARS to create one command file from another:\n\n    \n    \n    $ COPY SYS$INPUT SYS$SCRATCH:TEMP.COM $ DECK /DOLLARS=$$$$ $ TYPE SYS$INPUT This is an example of using DECK to create a command file from within a command file $$$$ $! other commands follow ...\n\n### YAML[edit]\n\nYAML primarily relies on whitespace indentation for structure, making it\nresistant to delimiter collision and capable representing multi-line strings\nwith folded string literals:\n\n    \n    \n    --- caption: \"Example of heredoc-style functionality using YAML\" date: \"2007-06-01\" example: > HTML goes into YAML without modification message: | <blockquote style=\"font: italic 12pt Times\"> <p>\"Three is always greater than two, even for large values of two\"</p> <p>--Author Unknown</p> </blockquote>\n\n## See also[edit]\n\n  * CDATA\n  * Pipeline (Unix)\n\n## References[edit]\n\n  1. ^ Jump up to: ^a ^b \"Here-Document description in the POSIX/SUS standard\". Archived from the original on 2014-04-27. Retrieved 2018-04-20.\n  2. ^ \"Here document - Rosetta Code\". rosettacode.org. Retrieved 2017-02-20.\n  3. ^ Jump up to: ^a ^b Darwin tcsh man page\n  4. ^ Wayne Pollock. \"Shell Here Document Overview\". hccfl.edu. Archived from the original on 2014-05-29. Retrieved 2014-05-28.\n  5. ^ See for example Using variables inside a bash heredoc\n  6. ^ perldata: Special Literals\n  7. ^ Ruby: Object: __END__\n  8. ^ Perl operators and precedence\n  9. ^ \"Perl5260delta - what is new for perl v5.26.0 - Perldoc Browser\".\n  10. ^ \"Heredoc in PHP manual\". php.net.\n  11. ^ \"PHP: Strings - Manual\". php.net.\n  12. ^ Here string in Racket Documentation\n  13. ^ @ Syntax in Racket Documentation\n  14. ^ \"HP OpenVMS DCL Dictionary\". Archived from the original on 2016-03-04. Retrieved 2015-04-21.\n\n### General[edit]\n\n  * Bash Reference Manual\n\n    * 3.6.6 Here Documents\n    * 3.6.7 Here Strings\n  * Advanced Bash-Scripting Guide, Mendel Cooper\n\n    * Chapter 19. Here Documents\n    * 19.1. Here Strings\n\n  1. ^ In more detail, in bash: \u201call lines of the here-document are subjected to parameter expansion, command substitution, and arithmetic expansion. In the latter case, the character sequence \\newline is ignored, and \u2018\\\u2019 must be used to quote the characters \u2018\\\u2019, \u2018$\u2019, and \u2018`\u2019.\u201d, per 3.6.6 Here Documents. Note that \" has no special meaning in a here document and does not need to be escaped, unlike in a double-quoted string; otherwise they are essentially identical.\n  2. ^ \u201cQuoting\u201d includes escaping, so if \\EOF is used, this is quoted, so variable interpolation does not occur, and it ends with EOF, while if \\\\\\EOF is used, this is quoted and ends with \\EOF. This perhaps surprising behavior is however easily implemented in a shell, by the tokenizer simply recording a token was quoted (during the evaluation phase of lexical analysis), without needing to preserve the original, quoted value. One application is to use \\' as the starting delimiter, and thus ' as the ending delimiter, which is similar to a multiline string literal but stripping starting and ending linebreaks.\n  3. ^ Note that while tabs can typically be entered in editors, at the command line they are typically entered by Ctrl+V + Tab \u21b9 instead, due to tab completion, and in the example they are actual tabs, so the example can be copy and pasted.\n\n## External links[edit]\n\n  * Here document. Link to Rosetta Code task with examples of here documents in over 15 languages.\n\nRetrieved from\n\"https://en.wikipedia.org/w/index.php?title=Here_document&oldid=1220445031\"\n\nCategories:\n\n  * Programming constructs\n  * String (computer science)\n\nHidden categories:\n\n  * Articles with short description\n  * Short description is different from Wikidata\n  * Articles with example C++ code\n  * Articles with example D code\n  * Articles with example Perl code\n  * Articles with example PHP code\n  * Articles with example Python (programming language) code\n  * Articles with example Ruby code\n\n  * This page was last edited on 23 April 2024, at 20:28 (UTC).\n  * Text is available under the Creative Commons Attribution-ShareAlike License 4.0; additional terms may apply. By using this site, you agree to the Terms of Use and Privacy Policy. Wikipedia\u00ae is a registered trademark of the Wikimedia Foundation, Inc., a non-profit organization.\n\n  * Privacy policy\n  * About Wikipedia\n  * Disclaimers\n  * Contact Wikipedia\n  * Code of Conduct\n  * Developers\n  * Statistics\n  * Cookie statement\n  * Mobile view\n  * Edit preview settings\n\n", "frontpage": false}
