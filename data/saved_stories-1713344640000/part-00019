{"aid": "40059648", "title": "Linux: Easy Keylogger with eBPF (2018)", "url": "http://arighi.blogspot.com/2018/12/linux-easy-keylogger-with-ebpf.html", "domain": "arighi.blogspot.com", "votes": 1, "user": "mooreds", "posted_at": "2024-04-17 02:04:02", "comments": 0, "source_title": "Linux: easy keylogger with eBPF", "source_text": "arighi's blog: Linux: easy keylogger with eBPF\n\n# arighi's blog\n\nAndrea Righi - Linux Kernel Engineer at Canonical\n\n## Wednesday, December 12, 2018\n\n### Linux: easy keylogger with eBPF\n\nIn this article I'd like to show you how we can use eBPF as a tool to learn\nthe kernel.\n\n### Introduction\n\neBPF is a virtual machine implemented inside the kernel. It gives user-space\nprograms the possibility to inject kernel code that runs in a safe environment\n(sandbox). The injected code has access to kernel structures like any regular\nkernel code, but it can't harm or break the system (an in-kernel verifier does\na static analysis of the code, if the check doesn't pass the code is not\naccepted and you get an error, before running any code at all).\n\nBCC (BPF Compiler Collection) is a front-end to eBPF, it provides a set of\nvery useful tools on top of eBPF that allow to do amazing things (tracing,\nprofiling, code inspection, etc.).\n\n### The problem\n\nLet's pretend we don't know anything about the kernel and we want to write a\nkeylogger.\n\nThe very first thing that we need to do is to figure out how the kernel\nreceives keys from the keyboard. Knowing a little bit how computers work, we\nmay guess that keys are received as interrupts.\n\nSo, let's try to use a tool in BCC called funccount.py. This tool counts how\nmany times one (or more) function(s), passed as argument, are called in the\nkernel, all at runtime. It accepts wildcards (similar to file globbing), so\nlet's start to count all functions that are called \"*interrupt*\" (because I\nguess an IRQ handler of a keyboard interrupt should be called\n\"something...interrupt...something else\"):\n\n    \n    \n    # ./funccout.py '*interrupt*'\n\nWhile funccount.py is running we press some random keys on the keyboard, then\nwe stop it with CTRL+C and we get an output like the following:\n\n    \n    \n    FUNC COUNT wait_for_completion_interruptible 1 arch_show_interrupts 1 ww_mutex_lock_interruptible.part.10 14 ahci_handle_port_interrupt 26 ww_mutex_lock_interruptible 31 atkbd_interrupt 70 i915_mutex_lock_interruptible 71 ath9k_btcoex_handle_interrupt 80 ath9k_hw_kill_interrupts 84 ath9k_hw_resume_interrupts 85 __ath9k_hw_enable_interrupts 109 show_interrupts 489 psmouse_interrupt 633 i8042_interrupt 774 mutex_lock_interruptible_nested 875 serio_interrupt 906 note_interrupt 930 add_interrupt_randomness 1030 hrtimer_interrupt 2459 get_next_timer_interrupt 14771 __next_timer_interrupt 55993 generic_smp_call_function_single_interrupt 63830\n\nWe've got many interrupt handlers here... but, among those, atkbd_interrupt\nlooks really interesting for our purpose. It's likely the interrupt handler\nthat we were looking for. Now, inspecting the kernel source code we find that\nthe prototype of this function is the following:\n\n    \n    \n    static irqreturn_t atkbd_interrupt(struct serio *serio, unsigned char data, unsigned int flags)\n\nWe got it! It looks like data is what we need to intercept all keys that are\npressed on the keyboard.\n\nTo do so we use another tool provided by BCC: trace.py. This tool allows to\ntrace any function in the kernel and inspect its argument:\n\n    \n    \n    # ./trace.py 'atkbd_interrupt(struct serio *serio, unsigned char data, unsigned int flags) \"data=0x%x\" data' ... PID TID COMM FUNC - 0 0 swapper/3 atkbd_interrupt data=0x1e 0 0 swapper/3 atkbd_interrupt data=0x9e 0 0 swapper/3 atkbd_interrupt data=0x31 0 0 swapper/3 atkbd_interrupt data=0xb1 0 0 swapper/3 atkbd_interrupt data=0x20 0 0 swapper/3 atkbd_interrupt data=0xa0 0 0 swapper/3 atkbd_interrupt data=0x13 0 0 swapper/3 atkbd_interrupt data=0x93 0 0 swapper/3 atkbd_interrupt data=0x12 0 0 swapper/3 atkbd_interrupt data=0x92 0 0 swapper/3 atkbd_interrupt data=0x1e 0 0 swapper/3 atkbd_interrupt data=0x9e ...\n\nAnd here's our keylogger, just two commands, knowing a very little about\nkernel and programming in general.\n\nNOTE: if you test this simple example on your box you may notice that any time\nyou press a key on the keyboard you get 2 interrupts: 1 when the key is\npressed and another when the key is released. The one when the key is released\nreturns a value with the most significant bit set: this can be used to\ndistinguish between a \"key pressed\" event and a \"key released\" event.\n\nAt this point the only thing that you need is to log these data somewhere and\ndecode each number (scancode) into the corresponding key... and you have your\nkeylogger.\n\nHappy hacking!\n\nPosted by\n\narighi at\n\n3:24 PM\n\nEmail ThisBlogThis!Share to TwitterShare to FacebookShare to Pinterest\n\n#### 2 comments:\n\nLibre! said...\n\n    \n\nIntersting!\n\n    December 27, 2019 at 11:05 AM\n\nLibre! said...\n\n    \n\nWhat I like about people is that they have already done everything you can\nthink of. Having read your article, I thought it would be great if not only on\nLinux there was such a thing, but also on Windows. And here. I come across\nRefog. A fairly good keylogger, you can look at the link:\nhttps://www.refog.com/\n\n    December 27, 2019 at 11:08 AM\n\nPost a Comment\n\nNewer Post Older Post Home\n\nSubscribe to: Post Comments (Atom)\n\n## Blog Archive\n\n  * April (1)\n  * March (1)\n  * February (1)\n  * July (1)\n  * August (1)\n  * December (1)\n  * August (1)\n  * May (1)\n  * August (2)\n  * January (2)\n  * September (1)\n  * June (2)\n  * May (2)\n  * April (2)\n  * March (1)\n  * January (2)\n  * December (1)\n  * October (5)\n  * July (1)\n  * May (2)\n  * March (5)\n  * February (1)\n  * January (4)\n  * October (1)\n  * May (4)\n  * April (3)\n  * March (6)\n  * February (2)\n\nAndrea Righi - Kernel Engineer at Canonical. Simple theme. Powered by Blogger.\n\nDiese Website verwendet Cookies von Google, um Dienste anzubieten und Zugriffe\nzu analysieren. Deine IP-Adresse und dein User-Agent werden zusammen mit\nMesswerten zur Leistung und Sicherheit f\u00fcr Google freigegeben. So k\u00f6nnen\nNutzungsstatistiken generiert, Missbrauchsf\u00e4lle erkannt und behoben und die\nQualit\u00e4t des Dienstes gew\u00e4hrleistet werden.Weitere InformationenOk\n\n", "frontpage": false}
