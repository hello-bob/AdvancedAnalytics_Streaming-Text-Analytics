{"aid": "40141060", "title": "A Note about Coercions", "url": "https://oleg.fi/gists/posts/2024-04-21-a-note-about-coercions.html", "domain": "oleg.fi", "votes": 3, "user": "JNRowe", "posted_at": "2024-04-24 05:50:36", "comments": 0, "source_title": "Oleg's gists - A note about coercions", "source_text": "Oleg's gists - A note about coercions\n\nOleg's gists \u2014 Archive\n\n# A note about coercions\n\nPosted on 2024-04-21 by Oleg Grenrus\n\nSafe coercions in GHC are a very powerful feature. However, they are not\nperfect; and already many years ago I was also thinking about how we could\nmake them more expressive.\n\nIn particular such things like \"higher-order roles\" have been buzzing. For the\nrecord, I don't think Proposal #233 is great; but because that proposal is\nalmost four years old, I don't remember why; nor I have tangible counter-\nproposal either.\n\nSo I try to recover my thoughts.\n\nI like to build small prototypes; and I wanted to build a small language with\nzero-cost coercions.\n\nThe first approach, I present here, doesn't work.\n\nWhile it allows model coercions, and very powerful ones, these coercions are\nnot zero-cost as we will see. For language like GHC Haskell where being zero-\ncost is non-negotiable requirement, this simple approach doesn't work.\n\nThe small \"formalisation\" is in Agda file\nhttps://gist.github.com/phadej/5cf29d6120cd27eb3330bc1eb8a5cfcc\n\n## #Syntax\n\nWe start by defining syntax. Our language is \"simple\": there are types\n\n    \n    \n    A, B = A -> B -- function type, \"arrow\"\n\ncoercions\n\n    \n    \n    co = refl A -- reflexive coercion | sym co -- symmetric coercions | arr co1 co2 -- coercion of arrows built from codomain and domain -- type coercions\n\nand terms\n\n    \n    \n    f, t, s = x -- variable | f t -- application | \u03bb x . t -- lambda abstraction | t \u25b9 co -- cast\n\nObviously we'd add more stuff (in particular, I'm interested in expanding\ncoercion syntax), but these are enough to illustrate the problem.\n\nBecause the language is simple (i.e. not dependent), we can define typing\nrules and small step semantics independently.\n\n## #Typing\n\nThere is nothing particularly surprising in typing rules.\n\nWe'll need a \"well-typed coercion\" rules too though, but these are also very\nstraigh-forward\n\n    \n    \n    Coercion Typing: \u0394 \u22a2 co : A \u2261 B ------------------ \u0394 \u22a2 refl A : A \u2261 A \u0394 \u22a2 co : A \u2261 B ------------------ \u0394 \u22a2 sym co : B \u2261 A \u0394 \u22a2 co1 : C \u2261 A \u0394 \u22a2 co2 : D \u2261 B ------------------------------------- \u0394 \u22a2 arr co1 co2 : (C -> D) \u2261 (A -> B)\n\nTerms typing rules are using two contexts, for term and coercion variables\n(GHC has them in one, but that is unhygienic, there's a GHC issue about that).\nThe rules for variables, applications and lambda abstractions are as usual,\nthe only new is the typing of the cast:\n\n    \n    \n    Term Typing: \u0393; \u0394 \u22a2 t : A \u0393; \u0394 \u22a2 t : A \u0394 \u22a2 co : A \u2261 B ------------------------- \u0393; \u0394 \u22a2 t \u25b9 co : B\n\nSo far everything is good.\n\nBut when playing with coercions, it's important to specify the reduction rules\ntoo. Ultimately it would be great to show that we could erase coercions either\nbefore or after reduction, and in either way we'll get the same result. So\nlet's try to specify some reduction rules.\n\n## #Reduction rules\n\nProbably the simplest approach to reduction rules is to try to inherit most\nreduction rules from the system without coercions; and consider coercions and\ncasts as another \"type\" and \"elimination form\".\n\nAn elimination of refl would compute trivially:\n\n    \n    \n    t \u25b9 refl A ~~> t\n\nThis is good.\n\nBut what to do when cast's coercion is headed by arr?\n\n    \n    \n    t \u25b9 arr co1 co2 ~~> ???\n\nOne \"easy\" solution is to eta-expand t, and split the coercion:\n\n    \n    \n    t \u25b9 arr co1 co2 ~~> \u03bb x . t (x \u25b9 sym co1) \u25b9 co2\n\nWe cast an argument before applying it to the function, and then cast the\nresult. This way the reduction is type preserving.\n\nBut this approach is not zero-cost.\n\nWe could not erase coercions completely, we'll still need some indicator that\nthere were an arrow coercion, so we'll remember to eta-expand:\n\n    \n    \n    t \u25b9 ??? ~~> \u03bb x . t x\n\n## #Conclusion\n\nTreating coercions as another type constructor with cast operation being its\nelimination form may be a good first idea, but is not good enough. We won't be\nable to completely erase such coercions.\n\nAnother idea is to complicate the system a bit. We could \"delay\" coercion\nelimination until the result is scrutinised by another elimination form, e.g.\nin application case:\n\n    \n    \n    (t \u25b9 arr co1 co2) s ~~> t (s \u25b9 sym co1) \u25b9 co2\n\nAnd that is the approach taken in Safe Zero-cost Coercions for Haskell, you'll\nneed to look into JFP version of the paper, as that one has appendices.\n\n> (We do not have space to elaborate, but a key example is the use of nth in\n> rule S_KPUSH, presented in the extended version of this paper.)\n\nThe rule S_Push looks some what like:\n\n    \n    \n    ---------------------------------------------- S_Push (t \u25b9 co) s ~~> t (s \u25b9 sym (nth1 co)) \u25b9 nth2 co\n\nwhere we additionally have nth coercion constructor to decompose coercions.\n\nIncidentally there was, technically is, a proposal to remove decomposition\nrule, but it's a wrong solution to the known problem. The problem and a proper\nsolution was kind of already identified in the original paper\n\n> We could similarly imagine a lattice keyed by classes whose instance\n> definitions are to be respected; with such a lattice, we could allow the\n> coercion of Map Int v to Map Age v precisely when Int\u2019s and Age\u2019s Ord\n> instances correspond.\n\nThe original paper also identified the need for higher-order roles. And also\nidentified that\n\n> This means that Monad instances could be defined only for types that expect\n> a representational parameter.\n\nwhich I argue should be already required for Functor (and traverseBia hack\nwith unlawful Mag would still work if GHC had unboxed representational\ncoercions, i.e. GADTs with baked-in representational (not only nominal)\ncoercions).\n\nThere also the mention of unidirectional Coercible, which people asked about\nlater and recently:\n\n> Such uni-directional version of Coercible amounts to explicit inclusive\n> subtyping and is more complicated than our current symmetric system.\n\nIt is fascinating that authors were able to predict the relevant future work\nso well. And I'm thankful that GHC got Coercible implemented even it was\nalready known to not be perfect. It's useful nevertheless. But I'm sad that\nthere haven't been any results of future work since.\n\n  * 2024-04-21 \u2013 A note about coercions\n  * 2024-04-18 \u2013 What makes a good compiler warning?\n  * 2024-04-12 \u2013 Core Inspection\n  * 2024-04-01 \u2013 Implicit arguments\n  * 2024-03-17 \u2013 ST with an early exit\n\nThis work is licensed under a \u201cCC BY SA 4.0\u201d license.\n\nOleg's gists \u2014 Archive\n\ntwitter github email linkedin stackoverflow\n\nSite proudly generated by Hakyll\n\n", "frontpage": false}
