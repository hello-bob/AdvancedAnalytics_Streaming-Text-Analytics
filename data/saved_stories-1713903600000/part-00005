{"aid": "40132214", "title": "ProVerB \u2013 SLEBoK", "url": "https://slebok.github.io/proverb/index.html", "domain": "slebok.github.io", "votes": 1, "user": "todsacerdoti", "posted_at": "2024-04-23 14:11:12", "comments": 0, "source_title": "ProVerB \u2014 SLEBoK", "source_text": "ProVerB \u2014 SLEBoK\n\n### Program Verification Book\n\n# ProVerB: Program Verification Book\n\nProVerB is a project aimed at explaining program verification tools to\npracticing software developers, and at helping them to find they way around\nthe available tools, clearly and briefly summarising the main purpose of the\ntool, its current status, relations to other tools, etc. You can read more\nabout the project on the credits page or visit the dataset repository.\n\nWe classify all tools in this book as belonging to one of the six levels:\n\n  * PV0 tools manipulate given and produced software artefacts with some degree of rigour. Conceptually such artefacts then may correspond to mathematical and formal entities, but this correspondence is mostly a matter of expectations. This category should be reasonably unpopulated since we mostly avoid to include such tools listed on this website.\n  * PV1 tools encode the formal expectations about the artefacts that they manipulate, and report back to their users about found inconsistencies. A typical resident of this level could be a linter: a tool that analyses your program and complains about places where your program does not conform to its expectations.\n  * PV2 tools generate an executable artefact from a formal one that specifies the desired properties and conditions, without necessarily providing means of explicitly verifying the correctness of the synthesised code. For instance, it could be a test data generator that produces a lot of diverse test cases from a model.\n  * PV3 tools allow the end user to control the properties that are being checked. For instance, it could be a tool that analyses user-written assertions in the code and verifies that they are indeed always respected by the program.\n  * PV4 tools operate within a particular paradigm and derive their actions, conclusions and even properties that they need to check, from a built-in formal specification. For example, such a tool can guarantee freedom of deadlocks in a multi-threaded application, or data consistency in a database management system. Generated property set cannot be explicitly adjusted for tools of this level.\n  * PV5 tools allow the end user to write their own specifications and \u201ccompile\u201d them together with desired properties to fully formal mathematical representations that can be combined with mathematical representations of programs themselves or their desired properties, and verified together. Such a tool can already help someone make claims and guarantees about correctness, complexity or predicted performance of a novel, previously non-existing, garbage collection algorithm.\n  * PV6 tools can handle different user-written specifications, encode a wide range of different formulae for properties, and are capable of producing proofs of such properties together with inferring the correctness of such proofs.\n\nNB: this project is a work in progress, and thus may momentarily contain\nimperfect or erroneous data! Use at your own risk or get in touch!\n\nThe PV-hierarchy does not represent how \u201cworthy\u201d or \u201cimportant\u201d a tool is,\nmerely how much it expects and demands of its end user, and what it can offer\nback. In many cases having a lower-PV-level tool is more preferable because it\nis easier in use and is less ambitious about the effort investment. Often\ntools of a lower PV-level are built \u201con top\u201d of tools of higher level which\nthey run as a backend.\n\nLast updated: December 2022.\n\n", "frontpage": false}
