{"aid": "40072674", "title": "Show HN: A decentralized solution for service discovery in pure Rust", "url": "https://github.com/al8n/ruserf", "domain": "github.com/al8n", "votes": 1, "user": "al8n", "posted_at": "2024-04-18 03:27:09", "comments": 0, "source_title": "GitHub - al8n/ruserf: A highly customable, adaptable, runtime agnostic and WASM/WASI friendly decentralized solution for service discovery and orchestration that is lightweight, highly available, and fault tolerant.", "source_text": "GitHub - al8n/ruserf: A highly customable, adaptable, runtime agnostic and\nWASM/WASI friendly decentralized solution for service discovery and\norchestration that is lightweight, highly available, and fault tolerant.\n\nSkip to content\n\nSign in\n\n# Search code, repositories, users, issues, pull requests...\n\nSearch syntax tips\n\nSign in\n\nSign up\n\nYou signed in with another tab or window. Reload to refresh your session. You\nsigned out in another tab or window. Reload to refresh your session. You\nswitched accounts on another tab or window. Reload to refresh your session.\nDismiss alert\n\nal8n / ruserf Public\n\ngenerated from al8n/crates\n\n  * Notifications\n  * Fork 1\n  * Star 9\n\nA highly customable, adaptable, runtime agnostic and WASM/WASI friendly\ndecentralized solution for service discovery and orchestration that is\nlightweight, highly available, and fault tolerant.\n\n### License\n\nMPL-2.0 license\n\n9 stars 1 fork Branches Tags Activity\n\nStar\n\nNotifications\n\n# al8n/ruserf\n\nThis commit does not belong to any branch on this repository, and may belong\nto a fork outside of the repository.\n\n1 Branch\n\n0 Tags\n\n## Folders and files\n\nName| Name| Last commit message| Last commit date  \n---|---|---|---  \n  \n## Latest commit\n\nal8nUpdate APIApr 15, 20245bb9cff \u00b7 Apr 15, 2024Apr 15, 2024\n\n## History\n\n18 Commits  \n  \n### .github\n\n|\n\n### .github\n\n| Cleanup unittests| Apr 15, 2024  \n  \n### art\n\n|\n\n### art\n\n| Bump agnostic and memberlist version| Mar 27, 2024  \n  \n### ci\n\n|\n\n### ci\n\n| Unit tests, bugs fixing, code optimization| Apr 13, 2024  \n  \n### core\n\n|\n\n### core\n\n| Update API| Apr 15, 2024  \n  \n### ruserf\n\n|\n\n### ruserf\n\n| Add documentation| Apr 15, 2024  \n  \n### types\n\n|\n\n### types\n\n| Unit tests, bugs fixing, code optimization| Apr 13, 2024  \n  \n### .codecov.yml\n\n|\n\n### .codecov.yml\n\n| Update .codecov.yml| Apr 13, 2024  \n  \n### .gitignore\n\n|\n\n### .gitignore\n\n| init project| May 18, 2023  \n  \n### Cargo.toml\n\n|\n\n### Cargo.toml\n\n| Add documentation| Apr 15, 2024  \n  \n### LICENSE\n\n|\n\n### LICENSE\n\n| init project| May 18, 2023  \n  \n### README.md\n\n|\n\n### README.md\n\n| Update README.md| Apr 15, 2024  \n  \n### rustfmt.toml\n\n|\n\n### rustfmt.toml\n\n| Bump agnostic and memberlist version| Mar 27, 2024  \n  \n## Repository files navigation\n\n# RuSerf\n\nA highly customable, adaptable, runtime agnostic and WASM/WASI friendly\ndecentralized solution for service discovery and orchestration that is\nlightweight, highly available, and fault tolerant.\n\nPort and improve HashiCorp's serf to Rust.\n\nEnglish | \u7b80\u4f53\u4e2d\u6587\n\n## Introduction\n\nruserf is a decentralized solution for service discovery and orchestration\nthat is lightweight, highly available, and fault tolerant.\n\nThe use cases for such a library are far-reaching: all distributed systems\nrequire membership, and ruserf is a re-usable solution to managing cluster\nmembership and node failure detection.\n\nruserf is eventually consistent but converges quickly on average. The speed at\nwhich it converges can be heavily tuned via various knobs on the protocol.\nNode failures are detected and network partitions are partially tolerated by\nattempting to communicate to potentially dead nodes through multiple routes.\n\nruserf is WASM/WASI friendly, all crates can be compiled to wasm-wasi and\nwasm-unknown-unknown (need to configure the crate features).\n\n### Design\n\nUnlike the original Go implementation, Rust's ruserf use highly generic and\nlayered architecture, users can easily implement a component by themselves and\nplug it to the ruserf. Users can even custom their own Id and Address.\n\nHere are the layers:\n\n  * Transport Layer\n\nBy default, Rust's ruserf provides two kinds of transport -- QuicTransport and\nNetTransport.\n\n    * Runtime Layer\n\nAsync runtime agnostic are provided by agnostic's Runtime trait, tokio, async-\nstd and smol are supported by default. Users can implement their own Runtime\nand plug it into the ruserf.\n\n    * Address Resolver Layer\n\nThe address resolver layer is supported by nodecraft's AddressResolver trait.\n\n    * NetTransport\n\nThree kinds of different builtin stream layers for NetTransport:\n\n      * Tcp: based on TCP and UDP\n      * Tls: based on rustls and UDP\n      * NativeTls: based on native-tls and UDP\n    * QuicTransport\n\nQUIC transport is an experimental transport implementation, it is well tested\nbut still experimental.\n\nTwo kinds of different builtin stream layers for QuicTransport:\n\n      * Quinn: based on quinn\n      * S2n: based on s2n-quic\n\nUsers can still implement their own stream layer for different kinds of\ntransport implementations.\n\n  * Delegate Layer\n\nThis layer is used as a reactor for different kinds of messages.\n\n    * Delegate\n\nDelegate is the trait that clients must implement if they want to hook into\nthe gossip layer of Serf. All the methods must be thread-safe, as they can and\ngenerally will be called concurrently.\n\nHere are the sub delegate traits:\n\n      * MergeDelegate\n\nUsed to involve a client in a potential cluster merge operation. Namely, when\na node does a promised push/pull (as part of a join), the delegate is involved\nand allowed to cancel the join based on custom logic. The merge delegate is\nNOT invoked as part of the push-pull anti-entropy.\n\n      * TransformDelegate\n\nA delegate for encoding and decoding. Used to control how ruserf should\nencode/decode messages.\n\n      * ReconnectDelegate\n\nUsed to custom reconnect behavior, users can implement to allow overriding the\nreconnect timeout for individual members.\n\n    * CompositeDelegate\n\nCompositeDelegate is a helpful struct to split the Delegate into multiple\nsmall delegates, so that users do not need to implement full Delegate when\nthey only want to custom some methods in the Delegate.\n\n### Protocol\n\nruserf is based on \"SWIM: Scalable Weakly-consistent Infection-style Process\nGroup Membership Protocol\". However, Hashicorp developers extends the protocol\nin a number of ways:\n\nSeveral extensions are made to increase propagation speed and convergence\nrate. Another set of extensions, that Hashicorp developers call Lifeguard, are\nmade to make ruserf more robust in the presence of slow message processing\n(due to factors such as CPU starvation, and network delay or loss). For\ndetails on all of these extensions, please read Hashicorp's paper \"Lifeguard :\nSWIM-ing with Situational Awareness\", along with the ruserf source.\n\n## Installation\n\n    \n    \n    [dependencies] ruserf = \"0.1\"\n\n## Q & A\n\n  * Does Rust's ruserf implemenetation compatible to Go's serf?\n\nNo but yes! By default, it is not compatible. But the secret is the\nserialize/deserilize layer, Go's serf use the msgpack as the\nserialization/deserialization framework, so in theory, if you can implement a\nTransformDelegate trait which compat to Go's serf, then it becomes compatible.\n\n  * If Go's serf adds more functionalities, will this project also support?\n\nYes! And this project may also add more functionalities whereas the Go's serf\ndoes not have. e.g. wasmer support, bindings to other languages and etc.\n\n## Related Projects\n\n  * agnostic: helps you to develop runtime agnostic crates\n  * nodecraft: crafting seamless node operations for distributed systems, which provides foundational traits for node identification and address resolution.\n  * transformable: transform its representation between structured and byte form.\n  * peekable: peekable reader and async reader\n  * memberlist: A highly customable, adaptable, runtime agnostic and WASM/WASI friendly Gossip protocol which helps manage cluster membership and member failure detection.\n\n#### License\n\nruserf is under the terms of the MPL-2.0 license.\n\nSee LICENSE for details.\n\nCopyright (c) 2024 Al Liu.\n\nCopyright (c) 2013 HashiCorp, Inc.\n\n## About\n\nA highly customable, adaptable, runtime agnostic and WASM/WASI friendly\ndecentralized solution for service discovery and orchestration that is\nlightweight, highly available, and fault tolerant.\n\n### Topics\n\nrust distributed-systems tokio asynchronous-programming serf gossip-protocol\nconsensus-algorithm smol memberlist async-std\n\n### Resources\n\nReadme\n\n### License\n\nMPL-2.0 license\n\nActivity\n\n### Stars\n\n9 stars\n\n### Watchers\n\n1 watching\n\n### Forks\n\n1 fork\n\nReport repository\n\n## Releases\n\nNo releases published\n\n## Sponsor this project\n\n  * al8n Al Liu\n\n  * patreon.com/al8n\n\nLearn more about GitHub Sponsors\n\n## Packages 0\n\nNo packages published\n\n## Languages\n\n  * Rust 99.4%\n  * Other 0.6%\n\n## Footer\n\n\u00a9 2024 GitHub, Inc.\n\nYou can\u2019t perform that action at this time.\n\n", "frontpage": false}
