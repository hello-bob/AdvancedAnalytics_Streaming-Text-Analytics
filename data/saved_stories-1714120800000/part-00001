{"aid": "40165417", "title": "How Slow Is Database IO\uff1f", "url": "https://github.com/SPLWare/esProc/wiki/How-Slow-Is-Database-IO%EF%BC%9F", "domain": "github.com/splware", "votes": 1, "user": "Judyrabbit", "posted_at": "2024-04-26 02:39:06", "comments": 0, "source_title": "How Slow Is Database IO\uff1f", "source_text": "How Slow Is Database IO? \u00b7 SPLWare/esProc Wiki \u00b7 GitHub\n\nSkip to content\n\n## Navigation Menu\n\nSign in\n\n# Search code, repositories, users, issues, pull requests...\n\nSearch syntax tips\n\nSign in\n\nSign up\n\nYou signed in with another tab or window. Reload to refresh your session. You\nsigned out in another tab or window. Reload to refresh your session. You\nswitched accounts on another tab or window. Reload to refresh your session.\nDismiss alert\n\nSPLWare / esProc Public\n\n  * Notifications\n  * Fork 310\n  * Star 4.4k\n\n# How Slow Is Database IO?\n\nJump to bottom\n\nesProcSPL edited this page Jan 30, 2024 \u00b7 1 revision\n\nMost of your veteran developers must have experienced the rather low database\nI/O performance. But many of you may not have the perception about how slow is\nthe I/O operation, and particularly, about the gap between database I/O speed\nand the speeds of other data read/write methods.\n\nJava is a commonly used technique used for application development. Now we\nperform a field test to find out performances of retrieving data from Oracle\nand MySQL \u2013 the two typical types of databases, in Java, and compare them with\nthe performance of retrieving data from the text file.\n\nUse the international T-PCH benchmark to generate data tables and select the\ncustomer table, which has 30,000,000 rows and 8 fields. The size of the\noriginal text file is 4.9G. Import the file data to Oracle and MySQL\nrespectively.\n\nThe hardware environment consists of a single, 2-CPU and 16-core server where\nboth the text file and the database are stored in the SSD. The whole test is\nperformed on the local machine and there isn\u2019t any substantial network\ntransmission time.\n\nAs it is complicated to implement the test using Java, we write the code in\nSPL. SPL simply encapsulates Java\u2019s data retrieval operation. Data is\nretrieved through the database\u2019s JDBC driver, and performance won\u2019t be\naffected. Here the complete retrieval operation involves retrieving data via\nthe SPL cursor and converting all data into in-memory objects.\n\nA  \n---  \n1| =now()  \n2| =connect(\"oracle\")  \n3| =A2.cursor@x(\"select * from customer\")  \n4| for A3,10000  \n5| =interval@s(A1,now())  \n  \nIt takes Oracle 280 seconds, an average of 100,000 rows per second, and MySQL\n380 seconds, an average of 80,000 rows per second averagely, to retrieve all\nthe 30,000,000 rows from the table.\n\nThe retrieval speed depends on both the number of fields and the data type\nused, as well as the hardware environment. This means that this test result is\nonly a reference and can be quite different in various environments.\n\nBut the comparison is reliable under the same environment. We still use SPL to\ndirectly retrieve a TPCH-generated text file:\n\nA  \n---  \n1| =now()  \n2| =file(\"/home/tpch/customer.tbl\")  \n3| =A2.cursor(;,\"|\")  \n4| for A3,10000  \n5| =interval@s(A1,now())  \n  \nLike we perform the test using the database, here we use SPL cursor to\nretrieve data and then convert the data to in-memory objects. It takes 42\nseconds to complete the retrieval of 30,000,000 rows of data. This is over 6\ntimes faster than Oracle and 9 times faster than MySQL!\n\nWe know that text parsing is rather complex and has high CPU consumption\ndegree. But even so, retrieving data from a text file is still far faster than\ndata retrieval from the database.\n\nNow let\u2019s test data retrieval from a binary file and find out to what extent\nthe performance will be dragged down during the text parsing.\n\nIn order to create obvious contrast and make the later parallel processing\ntest more convenient, we use the larger orders table that has three hundred\nmillion rows of data and nine fields. The code for retrieving data from the\ntext file is similar to the previous one, and it takes 483 seconds to complete\nthe execution.\n\nNow we convert the current text file into a SPL composite table file and test\nthe retrieval speed:\n\nA  \n---  \n1| =now()  \n2| =file(\"/home/tpch/orders.ctx\").open()  \n3| =A2.cursor()  \n4| for A3,10000  \n5| =interval@s(A1,now())  \n  \nIt takes 164 seconds to retrieve all data from the composite table file, which\nis 3 times faster than retrieving data from the text file.\n\nIt is just what we expect because binary data does not need to be parsed and\ncan be directly used to generate objects. The computation amount is less and\nthe speed becomes faster.\n\nBut databases also use the binary format to store data and do not have the\nburden of text parsing. It is natural that they are not as fast as the more\ncompact SPL composite tables as databases should consider data writing and\ncannot use the compression technique. But it is a little bit perplexed about\ntheir being slower than text files.\n\nActually, we find that databases are fast when SQL is used to perform a\ntraversal-based aggregate operation on the above data table and returns a very\nsmall result set, much faster than when we perform the same operation based on\na text file. This means that traversing a data table in the database is not\nslow at all, or we can say the data storage format has a fairly good\nperformance.\n\nThe obstacle lies in the driver. The JDBC driver is extremely slow. We even\ndoubt that this is an intentional design, which expects and even forces data\nnot to be retrieved out of the database but to be computed inside it.\n\nIn view of this, we have come to a conclusion \u2013 when we want to achieve high\nperformance for big data computations, the ad hoc data retrieval from the\ndatabase is infeasible and it would be the best to perform the computation\ninside the database. If data must be first retrieved from the database before\nthe computation can be really handled (because sometimes it is difficult or\neven impossible to implement some computing logics in SQL), we\u2019d better not to\nstore data in the database. If data is still kept in the database, performance\nwon\u2019t be satisfactory in most cases no matter what high-performance algorithms\nwe use outside the database; unless the amount of data involved is very small.\n\nThis is why SPL must implement its own storage formats if it intends to\nimprove SQL\u2019s computing performance. It is impossible to achieve high\nperformance if SPL still uses the database storage.\n\nIs there any way to increase the computing speed when database is the only\ndata source?\n\nIf the problem only lies in the slow driver, that is, the slow speed isn\u2019t due\nto heavy database load, we can improve the situation using parallel\nprocessing.\n\nIt is a little bit complicated to implement the multithreaded computation in\nJava, so we perform a test by using SPL to write the parallel retrieval code:\n\nA| B  \n---|---  \n1| =now()  \n2| =connect(\"oracle\").query@ix(\"SELECT COUNT(*) FROM CUSTOMER\")(1)  \n3| >n=6  \n4| =n.([int(A2/n)*(~-1),int(A2/n)*~])  \n5| fork A4| =connect(\"oracle\")  \n6| =B5.cursor@x(\"SELECT * FROM CUSTOMER WHERE C_CUSTKEY>? AND\nC_CUSTKEY<=?\",A5(1),A5(2))  \n7| for B6,10000  \n8| =interval@s(A1,now())  \n  \nNote that the parallel threads should not share the same database connection;\ninstead, each of them should connect to the database separately.\n\nThe field test shows that when the number of parallel threads is small\n(generally <10), the computing efficiency goes up nearly in a linear way. This\nmeans that the retrieval speed becomes nearly n times faster when there are n\nretrieval threads. The test result is that speed increase reaches 5 times with\na 6-thread parallel processing.\n\nHere we need to first compute the total number of data rows and then write the\nWHERE condition for each thread to retrieve the corresponding part of data,\nplacing many computing actions on the database while still leading to\nnoticeable retrieve performance increase. This further tells that the slow\nspeed is mainly due to the slow driver rather than the in-database retrieval\nand computations.\n\nOf course, it is more convenient to use the multithreaded processing to\nincrease the speed when data is stored in files. It is easy for SPL to\nimplement the parallel computation:\n\nParallel retrieval from the text file:\n\nA| B  \n---|---  \n1| >n=4| =now()  \n2| =file(\"/home/tpch/orders.tbl\")  \n3| fork to(n)| =A2.cursor(;A3:n,\"|\")  \n4| for B3, 10000  \n5| =interval@s(B1,now())  \n  \nParallel retrieval from the composite table file:\n\nA| B  \n---|---  \n1| >n=4| =now()  \n2| =file(\"/home/tpch/orders.ctx\").open()  \n3| fork to(n)| =A2.cursor(;;A3:n)  \n4| for B3, 10000  \n5| =interval@s(B1,now())  \n  \nThe field test result is similar to that when data is stored in the database.\nA linear speed increase is obtained when the number of parallel threads is\nsmall. In the test, the 4 threads make text file retrieval 3.6 times faster\nand composite table data retrieval 3.8 times faster.\n\nSPL Resource: SPL Official Website | SPL Blog | Download esProc SPL | SPL Source Code\n\n  * Learn performance optimization skills from TPCH tests\n  * Ordered storage of SPL\n  * The impasse of SQL performance optimizing\n  * The Open-source SPL Redefines OLAP Server\n\n##### Clone this wiki locally\n\n## Footer\n\n\u00a9 2024 GitHub, Inc.\n\nYou can\u2019t perform that action at this time.\n\n", "frontpage": false}
