{"aid": "40257688", "title": "Deniable Encryption", "url": "https://ayende.com/blog/200993-C/deniable-encryption", "domain": "ayende.com", "votes": 1, "user": "thunderbong", "posted_at": "2024-05-04 13:53:48", "comments": 0, "source_title": "Deniable Encryption - Ayende @ Rahien", "source_text": "Deniable Encryption - Ayende @ Rahien\n\n# Oren Eini\n\naka Ayende Rahien\n\n# Oren Eini\n\n## CEO of RavenDB\n\na NoSQL Open Source Document Database\n\nGet in touch with me:\n\noren@ravendb.net +972 52-548-6969\n\nPosts: 7,496\n\n|\n\nComments: 51,045\n\nCopyright \u00a9\ufe0f Ayende Rahien 2004 \u2014 2024\n\nPrivacy Policy \u00b7 Terms\n\nfilter by tags archive\n\nMay 03 2024\n\n## Deniable Encryption\n\ntime to read 27 min | 5280 words\n\nI ran into an interesting Reddit comment about deniable encryption and decided\nto spend an evening playing with it. The concept is that we have a way to\nencrypt a message in such a way that we can provide a key that would reveal a\ndifferent message.\n\nThe idea is that if you are forced to reveal your key, you can do so, without\nspilling your secret. From a technical perspective, this is a truly\nfascinating scenario. Of course, it comes with the problem that if you\u2019ve\nprovided a key that doesn\u2019t show anything the adversary is happy with, they\u2019ll\nassume that there is another key.\n\nNote: As usual when talking about cryptography, I\u2019m at best an amateur in this\narea. This is strictly me having fun, don\u2019t try to keep your Bitcoin keys here\n(instead, send them to me by snail mail).\n\nIn theory, there is a simple way to do so. Behold my prediction for the winner\nof the 2024 US election. I don\u2019t want to reveal to you ahead of time, but here\nis the encrypted value:\n\n    \n    \n    4a/8AqOcEFzlMRP9VsLgEtXIq8+Cc11bKKp6+iR3c975qOrNtA==\n\nAfter the election, I\u2019ll share the key that will show that I properly\npredicted this (you should send me bitcoins at that point). Let\u2019s commit\nfurther and show you how you can verify this, it\u2019s really simple:\n\n    \n    \n    string Decrypt(string encrypted, string key) { var t = Convert.FromBase64String(encrypted); var k = Convert.FromBase64String(key); return Encoding.UTF8.GetString( t.Select((b, i) => (byte)(b ^ k[i])).ToArray() ); }\n\nIn the interest of time (and those bitcoins), I\u2019ll let you know that the\nanswer is either:\n\n    \n    \n    tsaSbMbuMDODESHNZPbAR4bozqPnECkyR8Rak1dNU4qL3Ye9mg== tsaSbMbuMDODESHNZPbAR4bozqPnECkyR8Rak1dNU5yQzI+jmg==\n\nVoila, we are done, right? Not only did I demonstrate my ability to properly\npredict the future, but I was also able to show how you can use two separate\nkeys to decrypt the same data.\n\nThis is just a property of the way I \u201cencrypted\u201d the data. What happened is\nthat I took some random bytes, and when I needed to produce an answer, I XORed\nthose bytes with the message I wanted to get and then I sent you the XORed\nvalue. When you XOR it again with the \u201cmessage\u201d you previously got, we get the\noutput I want. In essence, that \u201cmessage\u201d you got is a one-time pad, and I can\nuse that to send you any message I want.\n\nThis also has all the usual limitations of one-time pads, you can only send\ndata up to the size of the key, it doesn\u2019t protect you from the text being\ncorrupted, and it is malleable. In other words, you have no way to ensure\n(cryptographically) that the message you received was actually sent by me.\n\nModern cryptography relies on something called AEAD (Authenticated Encryption\nwith Associated Data), which ensures that you can send as much encrypted data\nas you want and ensures that no one can alter the data I receive if the\ndecryption process is successful.\n\nWhat I aim to do is create a proper way to encrypt a message and be able to\nretrieve it later, but also provide another key if needed. Here is the API\nthat I have in my mind:\n\n    \n    \n    var output = DeniableEncryption.Encrypt( (\"P@ssw0rd\", \"Joey doesn't share food!\"), (\"swordfish\", \"Meet at dawn by the beach to toast the new year\"), (\"adm1n!str@t0r\", \"We were on a break!\"), (\"Qwerty!Asdf@2024\", \"Bitcoin seed: lonely ghost need apology spend shy festival funds\" ) );\n\nAs you can see, we are actually encrypting multiple messages here, each with\nits own password. The output of this code will be something like this:\n\n    \n    \n    OwlVWixT3NMen2vuklHsY34SEIfu+zuDKJx5UMQKEjP4GnDnSDsagUiMWxcl83kC4GRI1s64JEU7 x7vf4u15FZOw3DDzwCG71Mqatfjc7nTzAox7Cr9FtVnxqsqkIyeOVsq6yHbiP56HAlUkbu7/D3kp RrRmNtdqo5S6Dl7Y50fH492W/+/wtEhNePfWP7YhO1KsvUcnX2S4B7VKnTZbhJDhvxgTUlMK4/Cl UdQiP3H0R1CZ8ucB1mb1yP/gkwIPYA7ComAzKtM9VOviCzqP5wqzdq7KcWM2FdJH3Lqpuoi376Lr 3Dnh4FUDe8jJhU2xlNhj7O9tXPczIeeUu7GuG0FHegeHprqRc7AkKK5b5kiEN7VnQz58fk29WBAQ 2LTYrBwbDn47Sw4PybMFcl9Wy4Yuw9ElHQoZcvXGk9hAXsqWdRyRgOq8HREiuZpzvSyx5v56T2+u 3hGVeXStKfYF6T5R9w8wqPKQ8UB3/blKguQZjtJNlueXDSpJ5Jzl/7FKUCSJfK16l9NgiVpcGGLg qke4cZ1aVdpL6rsCH8uLLjEO0MVliuLjjX2VP76UrJBpTdh2uuyjaNDa6tFxQ/zx0jz5VlVbNZv+ w4KOl9jkQYk1U9VZ4K1v8IP6swZ1AOmfkWDuXmeNHlBeFk7Au0+ZDgpAJptwZrSDP2rgRgnrTlDL qN9YqSlV4Q2TBmcVmQy9+sW1aI7yHhUdzfx3wZ551BmJX0IBLJviMKm+1DglKlHfs/+BZ1fz1HR2 ygnSSq2FXMf8y8vDZRjxb54Q/4JzgvYMpq47/ukmzPgc6JcYfkLtDCNXeJ+0bUDjn5r+2I8d3DLF FbkGa6oB+um1ipAAeO5paH6aqzERtK3qEDw+nmnHW+y7BQUrQ7VRq2rmmPI2Hq8aMGcyCu5MpI97 /TXgcZDsUxFgRvA4ZQWz0UJ1ZNZOHgCRWgsAOkp1Y6zUKYwcJlhiICfUlfuj+6I2YayldANn/GR/ jn8/U4W2UXN3cAkl9AtgkxooGVQThPnAVTqo4l+EiL9X7WLo3EyaTJSNzxSSgudMQZJJJc+nYK66 A592plmhCzsvWedUeBzacE/pifyWM9DGDHqa5K75VLGV1AenIIBsUkYc44UPDLazpLSUBfTXB7LZ Tig4sHmmLvfiXrD/lH1jFKEsAdTHiYWLooxTBD0Q2COpEM6kyKkljwfko8FVpO6HRNwiyqwQCsDM xSMOO2Vk5qQVAb7VOEXN0fQjxEjSeB890XODduP6d941dqk+L1iAQK50GHk8WWCkZFn6FricVCFs 5T6fEWRj6wJlD4EISmoNVmanqAmF79Spg4YCOr3N2EbSdokf5d4ZNA7GtDFX9esbHTIPS0SiXyUx MHgS99CllTACSEpmEisu/JiEsWKHOg0oy6oCZbi9hrMbeMGGQ9jM4sIxQ20/u7dV1maut67CPN0H F5VYkRQ0/PNqhvT4Tb3CuGLndxD/nsvs9MgOOZljVZWLaF//Gdno2CNNPjnnHTuURScpcIFKMN5c 80NDgQX6kO8Hoiho7NFc61QwDCNYk1xk2qVDo9jcOaJ2zdtFWJfVavhLCNnEfWoHxzBmS4oL6Ss=\n\nAnd I\u2019m able to turn that back into the encrypted message using this code:\n\n    \n    \n    var msg in DeniableEncryption.Decrpyt(pwd, encrypted); Console.WriteLine(msg);\n\nIf I don\u2019t have the password, on the other hand, it should be completely\nunfeasible for me to figure out what the message is. In fact, let\u2019s try to\nlist the requirements from such a scheme:\n\n  * With a password, I can easily decrypt the message.\n  * Knowing one password isn\u2019t useful for decrypting a message using any other password.\n  * I cannot tell how many messages are hiding in the encrypted text.\n  * I cannot detect anything about the messages themselves.\n\nI\u2019m an amateur at best in cryptography, so I\u2019m not going to try to construct\nsomething myself. Let\u2019s see if I can cobble together something that would at\nleast hold up for a bit.\n\nI\u2019m using real passwords, and I need to turn them into encryption keys. I\u2019m\ngoing to be using PBKDF2 to do that, and for the encryption itself, I\u2019ll use\nthe AES-GCM algorithm. Here is the rough format of the output.\n\nWe start with a salt (32 bytes generated using CSRNG) which is used to feed\ninto the PBKDF2 algorithm, then a set of offsets into the file, and the actual\ndata itself. Note that we are always \u201cstoring\u201d exactly 8 messages.\n\nIn practice, I\u2019m going to allow up to 6 user-defined messages, to ensure that\nwe always have \u201cempty\u201d slots. The size of the data is also meaningful, so we\nneed to ensure that we aren\u2019t leaking that.\n\nWhat I\u2019m doing is ensuring that we round up (by 64 bytes) the size of all the\nmessages that we want to encrypt and ensure that each data block is of the\nsame size. To avoid leaking even what is the exact size at 64-byte intervals,\nI\u2019m writing some additional random bytes at the end.\n\nLet\u2019s look a bit deeper into the format of the data block itself. We start by\nwriting the actual size of the block, then the nonce and authentication tag\n(important for the AES-GCM usage), and then the encrypted message. The rest is\nfilled with random data.\n\nYou\u2019ll note that the offsets in the overall output format and the size in the\ndata format implies that we are leaking information about the messages we\nencrypted. Given that I need to know where to look for the value in the value,\nand I need to know the size, why am I spending so much time trying to\nobfuscate that?\n\nThe idea is that I actually have two levels of encryption here. When I derive\nthe key with PBKDF2, I\u2019m asking it to use SHA512 and give me 40 bytes of\nderived key material. I\u2019m actually only using 32 bytes of those as the actual\nencryption key, leaving me with 8 bytes (two pairs of 4 bytes) that I can use\nto XOR with the offset and the length. That hides the actual offset and size\n(basically using some of the PBKFD2 output as a stream cipher).\n\nIt has all the usual problems of raw stream cipher, but I don\u2019t care about\nmalleability or authentication in this scenario. I rely on AES-GCM to handle\nthat part of the process and just need to hide the information from other\nprying eyes. A man-in-the-middle attack targeting those values is going to be\nable to cause me to try (and fail) to decrypt a value, so I don\u2019t think that\nthis matters.\n\nWith all of that said, let\u2019s look at the actual code for the encryption\nportion:\n\n    \n    \n    public static byte[] Encrypt(params (string Password, string Value)[] items) { if (items.Length > MaxUserItems) throw new ArgumentException(\"You are allowed up to 6 items\"); if (items.GroupBy(x => x.Password).Any(x => x.Count() != 1)) throw new ArgumentException(\"No reusing passwords\"); var totalSize = items.Max( x => Encoding.UTF8.GetByteCount(x.Value) + sizeof(int) + AesGcm.NonceByteSizes.MaxSize + AesGcm.TagByteSizes.MaxSize ); var sizeAlignedUp = (totalSize + BlockSize - 1) & -BlockSize; var additionalSizeMixed = RandomNumberGenerator.GetInt32(1, 4) * RandomNumberGenerator.GetInt32(BlockSize / 2, BlockSize); var outputBuffer = RandomNumberGenerator.GetBytes( ItemsCount * sizeAlignedUp + OffsetsBlockSize + SaltSize + additionalSizeMixed ); Span<byte> output = outputBuffer; var salt = output.Slice(0, SaltSize); var offsetsBlock = MemoryMarshal.Cast<byte, int>( output.Slice(SaltSize, OffsetsBlockSize) ); int index = RandomNumberGenerator.GetInt32(ItemsCount); foreach (var (pwd, val) in items) { ReadOnlySpan<byte> derived = Rfc2898DeriveBytes.Pbkdf2(pwd, salt, Iterations, HashAlgorithmName.SHA512, sizeof(int) + DerivedKeySize + sizeof(int) ); var plaintext = Encoding.UTF8.GetBytes(val); var requiredSize = sizeof(int) + AesGcm.NonceByteSizes.MaxSize + AesGcm.TagByteSizes.MaxSize + plaintext.Length; var offset = sizeAlignedUp * index + SaltSize + OffsetsBlockSize + RandomNumberGenerator.GetInt32(sizeAlignedUp - requiredSize); var sizeMask = MemoryMarshal.Read<int>(derived.Slice(0, sizeof(int))); offsetsBlock[index] = offset ^ sizeMask; index = (index + 1) % ItemsCount; Span<byte> mem = output.Slice(offset, requiredSize); var lenMask = MemoryMarshal.Read<int>( derived.Slice(sizeof(int), sizeof(int)) ); var mask = lenMask ^ plaintext.Length; MemoryMarshal.Write(mem, mask); var derivedKey = derived.Slice( sizeof(int) + sizeof(int), DerivedKeySize ); using var cipher = new AesGcm(derivedKey, AesGcm.TagByteSizes.MaxSize); cipher.Encrypt( nonce: mem.Slice(sizeof(int), AesGcm.NonceByteSizes.MaxSize), plaintext: plaintext, ciphertext: mem.Slice(sizeof(int) + AesGcm.NonceByteSizes.MaxSize + AesGcm.TagByteSizes.MaxSize, plaintext.Length ), tag: mem.Slice(sizeof(int) + AesGcm.NonceByteSizes.MaxSize, AesGcm.TagByteSizes.MaxSize) ); } return outputBuffer; }\n\nWe validate that the user provided us with up to 6 messages (MaxUserItems) to\nencrypt and that there are no repeated passwords, then we compute the size\nrequired to encrypt the longest message. We align that on 64 bytes (BlockSize)\nand use that to compute the actual overall buffer size. Note that we also add\na bit of additional space at the end, to confuse attempts to figure out values\nbased on size (such as the BEAST attack).\n\nWe then get the output buffer. Note that in this case, we are asking the\nRandomNumberGenerator class to give us a buffer that is already filled with\nrandom data. The idea is that we don\u2019t need to worry about filling stuff up\nwith cryptographically secured data. We start with random noise, and we add\nwhatever meaning we need from there.\n\nThe first 32 bytes (SaltSize) are the salt, this is used to mitigate rainbow\ntable attacks, among others. The next 32 bytes are used as the offsets array,\nwhich are used to store the location of the actual encrypted messages.\n\nFor the message we want to encrypt, we start by using PBKDF2 to derive a\n40-byte cryptographic key. We are using SHA512 (which has a block size of 64\nbytes) and 210,000 iterations to derive the key, per the OWASP recommendation.\n\nWe want to be unpredictable, so we aren\u2019t writing the first element to the\nfirst offset position. Instead, we start the offset position in a random\nlocation. We figure out what is the size of the encrypted value (including the\nsize, nonce, tag, and actual encrypted bytes) and stash that at a random\nlocation in a random offset in the output buffer.\n\nWe then take the first 4 bytes of the derived key value and XOR that with the\noffset of the value we\u2019ll be writing. We are using those bytes as a stream\ncipher, basically. We write the encrypted offset to the offsets table. Note\nthat in order to decrypt that, you need to re-run the PBKDF2 computation,\nwhich requires that you have the password.\n\nThe next 4 bytes (4..8) are used as a stream cipher to encrypt the length of\nthe value we are about to encrypt. And the other 32 bytes (8..40) are used as\nthe encryption key itself.\n\nNote that we are \u201cmissing\u201d things like nonce generation. We don\u2019t need that,\nsince the nonce buffer we point to has already been seeded with random values\nfrom a cryptographic source.\n\nThe Encrypt() does most of the work, and... this is pretty much it. There\nisn\u2019t a lot of code, most of it is in how we put things together.\n\nThe decryption portion is a lot more interesting, I think, so let\u2019s take a\nlook at it:\n\n    \n    \n    public static string? Decrpyt(string pwd, byte[] encrypted) { Span<byte> mem = encrypted; var salt = mem.Slice(0, SaltSize); ReadOnlySpan<byte> derived = Rfc2898DeriveBytes.Pbkdf2(pwd, salt, Iterations, HashAlgorithmName.SHA512, sizeof(int) + DerivedKeySize + sizeof(int) ); var offsetMask = MemoryMarshal.Read<int>(derived.Slice(0, sizeof(int))); var lenMask = MemoryMarshal.Read<int>( derived.Slice(sizeof(int), sizeof(int)) ); var derivedKey = derived.Slice(sizeof(int) + sizeof(int), DerivedKeySize); var offsetsBlock = MemoryMarshal.Cast<byte, int>( mem.Slice(SaltSize, OffsetsBlockSize) ); for (int i = 0; i < ItemsCount; i++) { var offset = offsetsBlock[i] ^ offsetMask; if (offset < SaltSize + OffsetsBlockSize || offset + sizeof(int) > mem.Length) continue; var maskedLen = MemoryMarshal.Read<int>( mem.Slice(offset, sizeof(int)) ); var len = maskedLen ^ lenMask; if (len < 0 || offset + len + sizeof(int) > mem.Length) continue; using var cipher = new AesGcm(derivedKey, AesGcm.TagByteSizes.MaxSize); var outputBuf = new byte[len]; try { cipher.Decrypt( nonce: mem.Slice( offset + sizeof(int), AesGcm.NonceByteSizes.MaxSize ), ciphertext: mem.Slice( offset + sizeof(int) + AesGcm.NonceByteSizes.MaxSize + AesGcm.TagByteSizes.MaxSize, len ), tag: mem.Slice( offset + sizeof(int) + AesGcm.NonceByteSizes.MaxSize, AesGcm.TagByteSizes.MaxSize ), outputBuf); } catch (CryptographicException) { // expected, we may hit a dummy value or wrong password } return Encoding.UTF8.GetString(outputBuf); } return null; }\n\nHere we take the first 32 bytes (the salt) and use PBKDF2 and the password to\ngenerate the derived key. Again, we are getting 40 bytes back. The first 4\nbytes are the offset mask (to figure out where to look for the values, the\nnext 4 bytes are the length mask, to figure out the length for decryption, and\nthe last 32 bytes are the decryption key.\n\nWithout the password, we cannot get to the derived key, remember. Then we\nstart scanning through the offsets block. For each of the items we XOR the\nvalue in the offsets with the mask. Here we have three options:\n\n  * The XORed value is completely off, which we detect and skip.\n  * The XORed value is correct and points to the right offset to continue the operation.\n  * The XORed value appears to be correct (its value in bounds). We\u2019ll continue the operation, but fail in the next stage when we actually try to decrypt the value. This is because we are using AES-GCM, which is an AEAD (authenticated encryption) that validates (using cryptographic primitives) that the decrypted value matches the value that was encrypted. I wrote a blog post (part of a larger series) explaining this in detail.\n\nWith the offset, we can now read the masked length of the buffer, which has\nthe same problems as the masked offset. We XOR that with the right mask and\nneed to deal with the obvious wrong, correct, or appears to be correct but\nactually wrong scenario as well. We don\u2019t really care, since we leave the\nactual validation to the authenticated encryption portion.\n\nIf we are able to correctly decrypt the value, we immediately return it. But\nif not, we\u2019ll try with the next offset, etc. Note that for decryption, we are\nscanning the offsets array and attempting to check whether the key we derived\nfrom the password is able to decrypt the current value. During encryption, we\nrandomized where everything goes, and here we can just do a simple scan and\nstop on the first value that was successfully decrypted.\n\nAs I mentioned, that was a lovely evening to spend on an interesting exercise.\nI think that this is a valid way to go about building a deniable encryption\nscheme. The full code is here, I would love your feedback on both the code and\nthe actual idea.\n\nI like that I can provide multiple passwords and messages, in a simple manner.\nI think that a viable use case would be to encrypt three values. Safe,\nhoneypot, and the real deal. For example:\n\n    \n    \n    var output = DeniableEncryption.Encrypt( (\"safe\", \"I don't like Mondays\"), (\"honeypot\", \"I microwave fish in the office break room and I\u2019m not going to stop\"), (\"motherlode\", \"Bitcoin seed: armor cactus gaze off future blade artist\") );\n\nThere is no way to tell whether there is a third option here, and the format\nis intentionally always assuming 8 \u201centries\u201d, even if you provide less than\nthe maximum. Of course, that also raises the problem of what if after you give\nup the motherlode, the other side still suspects there are more secrets. At\nthis point, I\u2019ll point you out to Mickens and a wonderful article about threat\nmodels.\n\nCheck out the code and let me know what you think about this.\n\nTweet Share Share 0 comments\n\n## Comments\n\n#### Comment preview\n\n### Join the conversation...\n\n### Markdown formatting\n\nESC to close\n\nMarkdown turns plain text formatting into fancy HTML formatting.\n\n### Phrase Emphasis\n\n    \n    \n    *italic* **bold** _italic_ __bold__\n\n### Links\n\nInline:\n\n    \n    \n    An [example](http://url.com/ \"Title\")\n\nReference-style labels (titles are optional):\n\n    \n    \n    An [example][id]. Then, anywhere else in the doc, define the link: [id]: http://example.com/ \"Title\"\n\n### Images\n\nInline (titles are optional):\n\n    \n    \n    ![alt text](/path/img.jpg \"Title\")\n\nReference-style:\n\n    \n    \n    ![alt text][id] [id]: /url/to/img.jpg \"Title\"\n\n### Headers\n\nSetext-style:\n\n    \n    \n    Header 1 ======== Header 2 --------\n\natx-style (closing #'s are optional):\n\n    \n    \n    # Header 1 # ## Header 2 ## ###### Header 6\n\n### Lists\n\nOrdered, without paragraphs:\n\n    \n    \n    1. Foo 2. Bar\n\nUnordered, with paragraphs:\n\n    \n    \n    * A list item. With multiple paragraphs. * Bar\n\nYou can nest them:\n\n    \n    \n    * Abacus * answer * Bubbles 1. bunk 2. bupkis * BELITTLER 3. burper * Cunning\n\n### Blockquotes\n\n    \n    \n    > Email-style angle brackets > are used for blockquotes. > > And, they can be nested. > #### Headers in blockquotes > > * You can quote a list. > * Etc.\n\n### Horizontal Rules\n\nThree or more dashes or asterisks:\n\n    \n    \n    --- * * * - - - -\n\n### Manual Line Breaks\n\nEnd a line with two or more spaces:\n\n    \n    \n    Roses are red, Violets are blue.\n\n### Fenced Code Blocks\n\nCode blocks delimited by 3 or more backticks or tildas:\n\n    \n    \n    ``` This is a preformatted code block ```\n\n### Header IDs\n\nSet the id of headings with {#<id>} at end of heading line:\n\n    \n    \n    ## My Heading {#myheading}\n\n### Tables\n\n    \n    \n    Fruit |Color ---------|---------- Apples |Red Pears |Green Bananas |Yellow\n\n### Definition Lists\n\n    \n    \n    Term 1 : Definition 1 Term 2 : Definition 2\n\n### Footnotes\n\n    \n    \n    Body text with a footnote [^1] [^1]: Footnote text here\n\n### Abbreviations\n\n    \n    \n    MDD <- will have title *[MDD]: MarkdownDeep\n\n#### FUTURE POSTS\n\nNo future posts left, oh my!\n\n#### RECENT SERIES\n\n  1. Recording (13): 05 Mar 2024 - Technology & Friends - Oren Eini on the Corax Search Engine\n  2. Meta Blog (2): 23 Jan 2024 - I'm a JS Developer now\n  3. Production postmortem (51): 12 Dec 2023 - The Spawn of Denial of Service\n  4. Challenge (74): 13 Oct 2023 - Fastest node selection metastable error state\u2013answer\n  5. Filtering negative numbers, fast (4): 15 Sep 2023 - Beating memcpy()\n\nView all series\n\n#### RECENT COMMENTS\n\n  * Scott, Ouch, that is nasty. This gets _really_ complex if you have any non trivial billing setup. For example, for large...\n\nBy Oren Eini on Permission to pay your money, please!\n\n  * Yeah I agree it's a longshot. Just trying to imagine what they could be worried about.\n\nBy Jag on Permission to pay your money, please!\n\n  * Jag, Chargeback is a concern, but that seems like a far off scenario. And the original customer is still _expecting_ to p...\n\nBy Oren Eini on Permission to pay your money, please!\n\n  * Maybe an attack vector could be paying for someone elses service, then doing a chargeback later, causing the account to be cl...\n\nBy Jag on Permission to pay your money, please!\n\n  * Peter, Just UTC\n\nBy Oren Eini on RavenDB Cloud Global Status vs. Product Status\n\n#### Syndication\n\nMain feed  \n---  \nComments feed  \n  \n}\n\n", "frontpage": false}
