{"aid": "40090661", "title": "Leveraging DearImGui in Unreal", "url": "https://sharundaar.github.io/leveraging-dearimgui-in-unreal.html", "domain": "sharundaar.github.io", "votes": 1, "user": "goranmoomin", "posted_at": "2024-04-19 18:52:11", "comments": 0, "source_title": "Leveraging DearImGui in Unreal", "source_text": "Leveraging DearImGui in Unreal \u00b7 Sharundaar's Blog\n\nSharundaar's Blog\n\n  * Home\n  * Categories\n  * Tags\n  * Archives\n\n# Leveraging DearImGui in Unreal\n\n# Introduction\n\nIf we discuss tooling, I'll invariably talk about DearImGui and how it should\nbe an essential part of all developers tool belt. It's just the kind of lib\nthat sets such a high standard of \"it just works\" that even if you don't have\nan immediate need, I think you should check it out. On top of that, I strongly\nbelieve that knowing about the Immediate mode style of API has some great\nbenefits for development and writing user facing libraries, and this library\nis an excellent example of that style.\n\nSo ! What's the goal today ?\n\nWe'll be building this small debugging tool that allows us to pick an actor in\nthe scene with a line trace, and show some data about the Mesh components\nattached to it. We'll also see how to add buttons that can call arbitrary code\non those components. It took me about 30 minutes to build, and we'll see how\nlittle UI code we end up needing \ud83d\ude01\n\nLet's walk through the process !\n\n# Initial Setup\n\nFirst of all we need to understand that DearImGui is a completely independent\nlibrary, it's meant to be plugged into any arbitrary game engine/rendering\nbackend, and as such you can't just go on the imgui github and hope for it to\nwork out of the box in Unreal. As such, in usual Unreal fashion, we want to\nfind a plugin that already does the implementation for us !\n\nLuckily there's a few, I've been using this one :\nhttps://github.com/segross/UnrealImGui, unfortunately it stopped support at\nUnreal 4.26, but if you look at the forks there's a lot of them that supports\nUnreal >5.0 ! Here's two I can vouch for :\n\n  * IDI-Systems seems to be the most up to date : https://github.com/IDI-Systems/UnrealImGui\n  * BenUI : https://github.com/benui/UnrealImGui\n\nClone the repo in your Plugins folder, then you'll need to go to your .uplugin\nand add the following under \"Plugins\": [:\n\n    \n    \n    { \"Name\": \"ImGui\", \"Enabled\": true }\n\nYou'll also need to add a dependency in your .build.cs :\n\n    \n    \n    PrivateDependencyModuleNames.Add(\"ImGui\");\n\nAnd now we're good to go !\n\nCreate a file named DevGuiSubsystem.h and paste the following inside :\n\n    \n    \n    UCLASS() class UDevGuiSubsystem : public UGameInstanceSubsystem, public FTickableGameObject { GENERATED_BODY() public: // FTickableGameObject implementation Begin virtual UWorld* GetTickableGameObjectWorld() const override { return GetWorld(); } virtual void Tick(float DeltaTime) override; virtual TStatId GetStatId() const override; virtual ETickableTickType GetTickableTickType() const override { return IsTemplate() ? ETickableTickType::Never : ETickableTickType::Always; } virtual bool IsTickableWhenPaused() const override { return true; } // FTickableGameObject implementation End UFUNCTION(BlueprintCallable) static void ToggleImGuiInput(); };\n\nThis gives us a very simple class that's going to have a function called every\nframe (Tick), and that's instantiated only once at runtime with a valid World\n(GetTickableTickType makes sure of that).\n\nOn the implementation side, create a DevGuiSubsystem.cpp file, and paste the\nfollowing :\n\n    \n    \n    #include \"DevGuiSubsystem.h\" #include \"ImGuiModule.h\" UE_DISABLE_OPTIMIZATION void UDevGuiSubsystem::Tick(float DeltaTime) { } TStatId UDevGuiSubsystem::GetStatId() const { RETURN_QUICK_DECLARE_CYCLE_STAT(UDevGuiSubsystem, STATGROUP_Tickables); } void UDevGuiSubsystem::ToggleImGuiInput() { FImGuiModule::Get().GetProperties().ToggleInput(); } UE_ENABLE_OPTIMIZATION\n\nAnd we're good to go !\n\nOur job now is to fill up that Tick function full of ImGui goodness \ud83d\ude0a\n\n# A Very Simple Window\n\nTo start with, we'll be creating a simple window with a button that will print\nsomething, that will be our little Hello World to test that everything works\nproperly \ud83d\ude01\n\nCreating Windows with DearImGui is extremely simple (as is everything as we'll\nsee):\n\n    \n    \n    ImGui::Begin(\"My Little Window :)\"); ImGui::End();\n\nStrap that to your Tick function, and press Play in Unreal, and you'll see...\nA very tiny window !\n\nWithout any more input on our part, DearImGui will instantiate new windows\nwith enough size to display their content, since we don't have any content in\nour case, the window is very tiny ! Luckily default windows are rezisable,\nwhich makes this a good time to talk about interacting with the UI \ud83d\ude0a\n\n# Interacting with our Window\n\nIf you picked the plugin above, it should automatically register the Unreal\ncommand ImGui.ToggleInput. This command make sure the cursor is shown, and\nthat the inputs are routed to the ImGui context. Just type that in the game\nconsole and you should now have a cursor !\n\nAlternatively it's also a good place to use our little UFUNCTION to bind it to\nsome keyboard shortcut. Since I'm just in a demo scene I'll be hardcoding the\nF10 key in my level blueprint (do NOT do this in production \ud83d\ude2c)\n\nIf everything went well, you should now be able to drag the bottom right\ncorner of our window and resize it, showing the title and deep emptyness in\nall its glory !\n\n# Back to our Hello World\n\nWe have a window, we don't have CONTENT, how to fix that ?\n\nThe way DearImGui work, you can add content to a window by making ImGui::\ncalls in between those two Begin/End functions, the library will automatically\ntake care of layouting your elements for you (vertically by default). The\nlibrary comes with a lot of widgets - some would say an insane amount !\nLuckily it's extremely well documented, and comes with an easily searchable\nand debuggable demo, we'll be opening it later to see. For now let's finish\nour Hello World.\n\nThe function we want to call is void ImGui::Text(const char* fmt, ...); ! It\ndisplay a simple Text box with the content you want, it's written with the\nclassical fmt, ... that you'll find in the printf family of functions, so\nwe're right at home here \u263a\n\nYou're code should look like this :\n\n    \n    \n    ImGui::Begin(\"My Little Window :)\"); ImGui::Text(\"Hello, world !\"); ImGui::End();\n\nAaaand, we're done ? \ud83d\ude2e\n\nWith 3 simple lines of work, we have a full window, and a text block that can\ndisplay any arbitrary text we want ? Dark magic I tell you.\n\nYou want some proof we can just show any arbitrary thing ? Well just write\nthis :\n\n    \n    \n    ImGui::Begin(\"My Little Window :)\"); ImGui::Text(\"Hello, world !\"); ImGui::Text(\"We're inside: %ls\", *GetName()); FVector CameraPos = UGameplayStatics::GetPlayerCameraManager(GetWorld(), 0)->GetCameraLocation(); ImGui::Text(\"Camera Position: %.2f %.2f %.2f\", CameraPos.X, CameraPos.Y, CameraPos.Z); ImGui::End();\n\nAnd here we go, very simple, very straightforward, perfect for immediate\ninformation \ud83d\ude0a\n\nAlright ! At this point I think it's good to talk about the Demo !\n\n# Bringing up the Demo\n\nImGui comes with a full demo of all its features, very easy to search, very\neasy to copy code from. You'll find its code in imgui_demo.cpp, and to show it\nyou just have to call ImGui::ShowDemoWindow( &bOpenDemo ) ! What's that\nbOpenDemo you say ? Well it's part of a very common technique to easily spin\nup ImGui windows without too much fuss that relies on local static variables\nto persist states :)\n\nA fundamental philosophy of ImGui is that you provide all the external\nparameters of a widget directly at the callsite, this allows us to construct\nfairly complex UIs with no setup code (we don't retain any information about\nthe widget state), and as a result we need to do fairly little book keeping to\nmake the widgets behave like we want.\n\nHere the ShowDemoWindow function is expecting a boolean (that it might modify,\nhence the ptr), that will tell it if it's open or not. We have to store this\nboolean on our side, you can do it any way you like (member variable, global\nvariable, local static), but I'll show you a way that makes sense for quick\nprototypes.\n\nPaste the following code outside of your hello world window (make sure you're\nbefore the Begin, or past the End !) :\n\n    \n    \n    static bool bShowDemo = true; if(bShowDemo) { ImGui::ShowDemoWindow(&bShowDemo); }\n\nNow if you press play, you should see the Demo window show up :)\n\nAlright ! Play around with it, check all the beautiful and functional widgets\navailable, compare the widget behavior with code in imgui_demo.cpp (search for\nstrings you see in the UI !)\n\nYou'll see that, although the demo window is fairly complex, the actual\nDearImGui code is relatively simple :) That's one of the big advantages right\nhere, spin up complex UI with relatively little code (try to make an\nequivalent window in Slate/UMG or any other UI package).\n\n## Bonus Round\n\nCan you try to add a button to the Hello World window that will toggle the\ndemo window ? Searching in imgui_demo for how to use specific widgets is a\ncore part of using this library, so if you manage to do it by yourself at this\npoint, you're good to go for any debugging tool you want !\n\nYou can jump to the answer here : Jump to answer\n\n# ActorPicker with Fries\n\nOk ! Let's get serious, at this point you should be familiarized with the\nImGui library, but we haven't really dealt with Unreal itself. As you start\nusing the lib you'll find some small pain points, mainly due to the usage of\nUTF16 in Unreal which makes it hard to just send FStrings to the usual calls.\nIn this section we'll build a debugging window with a features that should\ncover a few things about those interactions, and how to set them up properly.\n\nLet me remind you of the goal ! We'll be making a small window that allows us\nto pick an actor, show some data, and make a button to interact with that\nactor \ud83d\ude0a\n\n## The Picking\n\nFirst we want to show a window, with a button that allows us to enter a 'pick\nmode', while in this mode we'll throw line trace through the screen, and if we\nhit an actor we'll store it in a local variable so we can draw informations\nabout it later !\n\nLet's make the window, the button and some variables for book keeping :\n\n    \n    \n    static TWeakObjectPtr<AActor> PickedActor = nullptr; static bool bIsPickingActor = false; ImGui::Begin(\"Actor Debugger\"); const char* ButtonTitle = bIsPickingActor ? \"Stop Picking\" : \"Start Picking\"; if(ImGui::Button(ButtonTitle)) { bIsPickingActor = !bIsPickingActor; } ImGui::End();\n\nSimple enough ? We're making a window, adding a button, and swap the button\ntitle depending on bIsPickingActor ! If you worked with Slate here you would\nalready have created 2 files and passed some variable around :)\n\nFrom there, we want to fill up PickedActor ! Next part is only Unreal code\n(well.. almost, I left a surprise at the end) :\n\n    \n    \n    UWorld* World = GEngine->GetWorldFromContextObject(this, EGetWorldErrorMode::LogAndReturnNull); ULocalPlayer* LP = World ? World->GetFirstLocalPlayerFromController() : nullptr; if(bIsPickingActor) { if (LP && LP->ViewportClient) { // get the projection data FSceneViewProjectionData ProjectionData; if (LP->GetProjectionData(LP->ViewportClient->Viewport, ProjectionData)) { ImVec2 ScreenPosImGui = ImGui::GetMousePos(); // <-- Get the current mouse position ! FVector2D ScreenPos = {ScreenPosImGui.x, ScreenPosImGui.y}; FMatrix const InvViewProjMatrix = ProjectionData.ComputeViewProjectionMatrix().InverseFast(); FVector WorldPosition, WorldDirection; FSceneView::DeprojectScreenToWorld(ScreenPos, ProjectionData.GetConstrainedViewRect(), InvViewProjMatrix, WorldPosition, WorldDirection); FCollisionQueryParams Params(\"DevGuiActorPickerTrace\", SCENE_QUERY_STAT_ONLY(UDevGuiSubsystem), true); FCollisionObjectQueryParams ObjectParams( ECC_TO_BITFIELD(ECC_WorldStatic) | ECC_TO_BITFIELD(ECC_WorldDynamic) | ECC_TO_BITFIELD(ECC_Pawn) | ECC_TO_BITFIELD(ECC_PhysicsBody) ); PickedActor = nullptr; // <-- Reset the actor FHitResult OutHit; if(World->LineTraceSingleByObjectType( // <-- Actually doing the trace OutHit, WorldPosition + WorldDirection * 100.0, WorldPosition + WorldDirection * 10000.0, ObjectParams, Params)) { PickedActor = OutHit.GetActor(); // <-- Set on hit ! } } }/ // Exiting Actor Picking mode if we click the Left button ! if(ImGui::IsMouseClicked(ImGuiMouseButton_Left)) { bIsPickingActor = false; } }\n\nThat's a big code splat \ud83d\ude0a But take your time, read through it, at the end of\nthe day there's no UI code in there, only standard unreal line tracing\nrituals. Right at the end you can see that we're exiting actor picking mode in\na very straightforward way, we just ask ImGui if the left button is clicked,\nand we're setting our boolean to false ! All the mouse state tracking is done\nin ImGui's backend.\n\nOk ! You can put a breakpoint at the PickedActor = line to check if you're\nactually hitting something ! But we have a UI toolset, why not just display it\n?\n\n## The Showing\n\nLet's start simple, let's just show the actor's name :)\n\n    \n    \n    /* {...} our picking code here */ if(AActor* Actor = PickedActor.Get()) { ImGui::Text(\"Picked actor: %ls\", *Actor->GetName()); }\n\nIt doesn't look like much ! But we've got the basis of a very powerful tool\nright there ! We now have full access to any arbitrary AActor pointers in the\nscene, we can make some UI to display and change any properties, show\ncomponent information, and if you're feeling courageous, even mirror any actor\nchanges to the default class \ud83d\ude0a\n\nBut let's continue with the plan. Now we want to list the attached static mesh\ncomponent, show some information about them, and if we have physics enable,\nadd a button to create a push force to interact live with the scene !\n\nTo list all attached component we'll be using the ForEachComponent function :\n\n    \n    \n    Actor->ForEachComponent<UStaticMeshComponent>(true, [](UStaticMeshComponent* Mesh) { // Our ImGui code here });\n\nThe ImGui widgets we'll need are ImGui::CollapsingHeader, ImGui::Button,\nImGui::Text. We'll also need to use 2 helpers for a reason I'll explain later\n: ImGui::PushID, and ImGui::PopID.\n\nLet's do it.\n\nWe'll want to display the component name in the collapsing header, to do so\nwe'll use Mesh->GetName(), sadly you'll notice that this function returns an\nFString which, at least on Windows, are encoded as UTF16 strings. Meaning\nyou'll get some 16 bits TCHAR* instead of the standard 8 bits char* that ImGui\nexpects. Luckily there's a straightforward conversion scheme that allows us to\ngo from one to the other :)\n\n    \n    \n    // We're planning on reusing the name, so let's store the cast result. auto NameANSI = StringCast<ANSICHAR>(*Mesh->GetName()); const char* Name = NameANSI.Get(); // This if you're just doing it once (yes, it is a mouthful) ImGui::CollapsingHeader(StringCast<ANSICHAR>(*Mesh->GetName()).Get());\n\nPerfect ! We can easily convert FString to the needed const char*. Let's setup\nour header and add some content ! We'll be showing the mesh name, and if it's\nNanite enabled.\n\n    \n    \n    auto NameANSI = StringCast<ANSICHAR>(*Mesh->GetName()); if(ImGui::CollapsingHeader(NameANSI.Get(), ImGuiTreeNodeFlags_DefaultOpen)) { if(auto StaticMesh = Mesh->GetStaticMesh()) { ImGui::Text(\"Mesh name: %ls\", *StaticMesh->GetName()); ImGui::Text(\"Nanite Enabled: %s\", StaticMesh->NaniteSettings.bEnabled ? \"true\" : \"false\"); } }\n\nNote that I'm using the %ls modifier to print TCHAR* and %s for char*.\n\nSimple enough !\n\nAlright last part, we want to add a button that, when clicked, send a force to\nthe static mesh to make it jump. To test this out I made a simple Actor with 3\nstatic meshes set as Movable and with gravity enabled. The AddForce function\nwill work for us here.\n\nWith that added in our scene, we just need the following code !\n\n    \n    \n    if(Mesh->IsSimulatingPhysics()) { if(ImGui::Button(\"Add Vertical Force\")) { Mesh->AddForce(FVector{0.0, 0.0, 50000.0}, NAME_None, true); } }\n\nAnd we're done ! We now have a simple interface, that loops over the static\nmesh components of the actor we line traced, displays some arbitrary\ninformation, and on top of that we have a very simple interactive element to\ntrigger effects on that Actor !\n\nYay ! If you click the first button it should work perfectly, but if you click\nthe other ones... You might find them broken \ud83d\ude2c Why is that ?\n\n## DearImGui IDs shenanigans\n\nSo here we need to dig a tiny bit into how DearImGui works behind. When you\ngenerate widgets, especially ones with frame-over-frame interactions (like a\nbutton answering a click), ImGui stores temporal states about widgets in a\ntable, think stuff like \"has the user started a click on this button\", \"is\nthis list element selected\", any info that can't be immediately deduced from\nthe current frame state. For ImGui to track that data between each frame, it\ntries to generate a unique ID per widget from infos available at the call\nsite. In the case of a button (and in fact everything in DearImGui), you're\npassing a string that labels the item ! So DearImGui yonks that, hashes it as\na 64 bits ID, and use that as a key.\n\nIf it were only doing that though, you would quickly be annoyed as you'd build\nother views with buttons with the same name and them not working... To solve\nthis ImGui also rehash that 64 bits ID with an ID stack, each window has it's\nown stack, and various widgets push and pops from this stack. So in our case,\nour buttons are all generated with the same ID stack and the same label, so\ntheir IDs ends up the same ! To solve this we can either change the label, or\nmodify the ID stack so when the widget key is generated, it's unique.\n\nHere's both solutions in action in an Unreal pedantic way:\n\n    \n    \n    // Modify the ID Stack with our little category name ImGui::PushID(NameANSI.Get()); if(Mesh->IsSimulatingPhysics()) { if(ImGui::Button(\"Add Vertical Force\")) { Mesh->AddForce(FVector{0.0, 0.0, 50000.0}, NAME_None, true); } } ImGui::PopID();\n    \n    \n    // Change the button label, anything after ## isn't displayed so we can use that for ID unicity if(Mesh->IsSimulatingPhysics()) { FString ButtonLabel = FString::Printf(TEXT(\"Add Vertical Force##%s\"), NameANSI.Get()); if(ImGui::Button(TCHAR_TO_UTF8(*ButtonLabel))) // TCHAR_TO_UTF8 is equivalent to StringCast we did before { Mesh->AddForce(FVector{0.0, 0.0, 50000.0}, NAME_None, true); } }\n\nWhich method you prefer will depend on your specific context, but they're both\ngood to know about \ud83d\ude04\n\nAnd we're done ! With this we have a nice debugging UI that allows us to pick\narbitrary actors in a scene and display any information we want. There's a lot\nmore we can do but this is just a simple demo of what's possible.\n\n# The Cherry on Top\n\nWe have a debugger, the demo window, a little hello world. As you start\ndeveloping more tools you might wonder: How to organize everything ? Enter the\nMain Menu Bar.\n\nIt's a simple tool bar DearImGui proposes that shows at the top of the screen.\nYou can push buttons, text, sub-menus... anything really, to that menu bar. So\nlet's set that up !\n\nAt the end of your Tick function, write the following :\n\n    \n    \n    static bActorDebuggerOpened = false; // @TODO: Use this to control the actor debugger visibility ! // Only show the bars if we have ImGui inputs enabled if(FImGuiModule::Get().GetProperties().IsInputEnabled()) { if(ImGui::BeginMainMenuBar()) { ImGui::Text(\"Website Support\"); if(ImGui::BeginMenu(\"Actor Debugger\")) { if(ImGui::MenuItem(\"Toggle Actor Debugger\")) { bActorDebuggerOpened = !bActorDebuggerOpened; } ImGui::EndMenu(); } ImGui::EndMainMenuBar(); } if(ImGui::BeginMainMenuBar()) // BeginMainMenuBar calls append to the bar ! So we can set it up in multiple chunks { if(ImGui::BeginMenu(\"ImGui Misc\")) // Creating a sub-menu { if(ImGui::MenuItem(\"Toggle Demo\")) { bShowDemo = !bShowDemo; } ImGui::EndMenu(); } ImGui::EndMainMenuBar(); } }\n\nAnd if you enable ImGui's inputs it should show more or less like this :\n\nI'm leaving the toggle hello world window as en exercise to the reader \ud83d\ude0a\n\n# Conclusion\n\nHopefully you can see how easy and quick we can now develop visualization and\ndebugging tool ! In everything we've written the actual UI code comprised very\nlittle, and that's one of the biggest strength of DearImGui, it doesn't get in\nthe way ! From there don't hesitate to just read imgui.h and spend time\ngetting familiar with the imgui demo. You'll find a lot of interesting and\nuseful widgets are available \ud83d\ude0a\n\nYou can find the complete code we've written here :\n\n  * DevGuiSubsystem.cpp\n  * DevGuiSubsystem.h\n\n# Annexe\n\n## DearImGui or ImGui\n\nIn this article, I've tried to refer to the lib as DearImGui most of the time.\nIf you look online, the term ImGui kinda became ubiquitous with this lib (for\ngood reasons), but ImGui actually refers to Immediate GUI, which is a UI API\nparadigm opposed to Retained UI.\n\nRetained UI would be your more standard UI library, like UMG/Slate, Windows\nForm, Qt. The main characteristic is that the UI data book keeping\nresponsability is put in the hand of the user of the library. You have to\ninstantiate stuff (with SNew calls, or NewObject), keep pointers around, check\ninternal states for response... This generally results in very bloated code to\ndescribe a UI presentation, and a lot of caching issues.\n\nOpposed to that, Immediate UI posits that you should just be able to describe\nthe UI layout and widgets as a part of the program, and the backend should\ntake care of all the state retention. (read this for more information)\n\nNow DearImGui as a library embodies those concepts ! But there's other libs\nthat are worth taking a look :\n\n  * Nuklear\n  * microui\n\nThere's also ways to write retained UI in an immediate mode kind of API, I\nthink it's important to understand the core concepts to simplify how we might\nwrite UI backend code in the future !\n\n## Toggle Demo window code\n\nHere's the full Tick function that will add a simple button that we can click\nto toggle the demo window on/off :\n\n    \n    \n    void UDevGuiSubsystem::Tick(float DeltaTime) { static bool bShowDemo = false; ImGui::Begin(\"My Little Window :)\"); ImGui::Text(\"Hello, world !\"); ImGui::Text(\"We're inside: %ls\", *GetName()); FVector CameraPos = UGameplayStatics::GetPlayerCameraManager(GetWorld(), 0)->GetCameraLocation(); ImGui::Text(\"Camera Position: %.2f %.2f %.2f\", CameraPos.X, CameraPos.Y, CameraPos.Z); if(ImGui::Button(\"Toggle Demo\")) { bShowDemo = !bShowDemo; } ImGui::End(); if(bShowDemo) { ImGui::ShowDemoWindow(&bShowDemo); } }\n\n#### Published\n\nSat 02 September 2023\n\n#### Category\n\nArticles\n\n#### Contact\n\nPowered by: Pelican Theme: Elegant\n\n", "frontpage": false}
