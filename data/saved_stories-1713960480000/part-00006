{"aid": "40139594", "title": "Service-to-Service Zero Trust", "url": "https://docs.otterize.com/security", "domain": "otterize.com", "votes": 1, "user": "mooreds", "posted_at": "2024-04-24 01:57:06", "comments": 0, "source_title": "Security", "source_text": "Security | Otterize\n\nSkip to main content\n\n# Security\n\n## Service-to-service zero trust\n\nIntent-based access control makes it easy to implement a zero trust back end.\nZero trust for service-to-service calls means that a service is only permitted\nto invoke an operation over the network on another service when:\n\n  1. Each service has a trusted identity.\n  2. Their identities are authenticated.\n  3. The calling service is authorized by a policy to invoke the desired operation on the service being called.\n\nZero trust is in a contrast with perimeter security: trusting any service to\nmake any call to any other service it can reach in the network, based on a\npresumption that the perimeter of the network is absolutely protected. It\u2019s\ndifficult to make the network perimeter sufficiently secure, given:\n\n  * The attack vector landscape is vast and highly automated, and includes not just traditional brute-force methods but also supply chain attacks and 0 day vulnerabilities.\n  * Modern development teams are increasingly distributed, exercise a lot of independence, and often release changes very frequently via automated CI/CD systems. And that means there are many chances of introducing vulnerabilities.\n  * Most teams rely extensively on 3rd-party, often open-source software within their code and infrastructure. Despite the great improvements in automated vulnerability scanning, shared vulnerability reporting, and patching frequency, at any given time it\u2019s hard to assume there are no chinks in the armor.\n\nBut the biggest issue with perimeter security is the age-old saying that\ndefenders need to win all the time while attackers only need to win once. And\nonce a service in the network has been compromised and turned malicious, every\nother service in that network is now potentially vulnerable.\n\nZero trust does not replace perimeter security. And service-to-service zero\ntrust does not replace human-to-service zero trust. All of these need to be in\nplace to realize defense in depth, a bedrock principle of security.\n\nBut if service-to-service zero trust is difficult \u2014 if it requires every\ndeveloper to be an expert at multiple access control mechanisms, if it relies\non manual provisioning of access keys or configuration of ACLs, if it requires\nteams to be constantly dependent on each other or on central platform teams to\nget their work done \u2014 then this layer of defense in depth remains a pipedream.\nIt must be easy if it\u2019s to be the reality for most teams.\n\nNote that, unlike perimeter security, service-to-service zero trust can be\nrolled out gradually. For example, certain sensitive services may be protected\nwhile still allowing unrestricted access to other services within the network,\nwhile still greatly improving the security posture of the back end.\n\n## Intent-based access control (IBAC) trust model\n\nWhen modeling service-to-service communications, we will refer to the service\nmaking the call as a client, and the service receiving the call as a server.\nFor asynchronous service communications, such as through message brokers, we\nwill regard the broker itself as the target server: the service that sends the\nmessages calls the broker to publish the message, and the service that\nreceives the message usually calls the broker to receive the message. (In some\ncases the broker pushes the message to its subscribers, in which case the\nroles of client and server are reversed.\n\nIntent-based access control (IBAC) aims to:\n\n  1. Make it easy for client developers to access accessing secured servers.\n  2. Minimize the overhead of maintaining permissions for server teams.\n  3. Shift access-control configuration left, from a run-time concern to a design-time, infrastructure-as-code concern.\n  4. Restrict access at all times to the least privilege needed to achieve the required functionality.\n  5. Align code approval mechanisms and access approval mechanisms.\n  6. Separate concerns between the access needed by development teams and the access granted by platform or server teams, per environment, either automatically or manually.\n  7. Separate concerns, to the extent possible, between the access needed by development teams and the access control mechanisms implemented by platform or server teams.\n\nTo achieve these, IBAC starts from the client\u2019s (caller\u2019s) intents. An intents\nfile for a client service declares the set of calls the client will be making\nto various server services to achieve its functionality. Intents files are\ncreated and maintained by client developers, within the same repositories as\nthe code files of the client. They are updated when the client code changes,\nto reflect at any time the needs of the code to call other services (servers).\n\n### 1\\. Make secure access easy\n\nAn IBAC platform relies on the information in the intents file of a client to\nautomatically configure any access controls between the client and the servers\nit intends to call such that the intended calls are allowed. If service\nidentities need to be established or credentials need to be provisioned and\ndistributed, the IBAC platform should automate that too. The desired client\nexperience should be: just declare your intent to access, without worrying how\nto achieve authorization, and the platform will \u201cmake it so\u201d. This is the\nfirst principle of IBAC, and for a very simple reason: security approaches\nthat aren\u2019t adopted aren\u2019t helping security.\n\n### 2\\. Minimize server team overhead\n\nIf server teams need to maintain information about who is permitted to access\ntheir services, that\u2019s overhead that takes away from their productivity. When\nshould an access request be granted? They would need to establish why the\nclient needs it. When should access be revoked? Rarely would they know when\nthe client no longer needs it. In most cases, they should be able to rely on\nthe client team\u2019s development processes and their organization\u2019s oversight to\nautomatically grant access. With IBAC, the default can be to grant any\nintended access, with rules to except out certain servers or calls or\nenvironments and route those to review and approval processes. In this way,\nserver teams can manage by exception and minimize overhead.\n\n### 3\\. Shift-left for access control\n\nIn leading engineering organizations, particularly cloud-native ones, all the\ninfrastructure, tests, dependencies, resources, and other aspects needed for\ncode to run are declaratively defined at design time. That way, the\ndevelopment life cycle can be automated to be efficient, resilient, and\nreliable, while minimizing the time to deliver value. IBAC adds access\ncontrols to that list of aspects. The specific permissions for what service\ncan call what other service are no longer provisioned after the fact,\nmaintained outside the automated development lifecycle, and potentially\nallowed to go stale. Instead, just as Docker manifests determine the operating\nsystem, virtual machine architecture, code snapshot, and other layers needed\nfor a container to run; and just as Kubernetes manifests determine the pods,\nnetwork policies, stateful sets, and other resources needed for your runtime\nplane to do its work; so intents files determine the access needed for your\nback end ecosystem to achieve its functional goals. The IBAC system will\norchestrate the various access control mechanisms to allow only the intended\naccess at run time.\n\n### 4\\. Least privilege\n\nOne of the pillars of security is least privilege: in our context, a service\nshould be granted the least privilege needed to accomplish its goals. Any more\nprivilege opens it up to abuse, either unintentional (e.g. calls to the wrong\nenvironment, unexpected calls that overload the server, etc.) or intentional\n(a breached service that inappropriately calls other services or allows the\nattackers to pivots and attack other services).\n\nBut how much privilege is the least, without being too little? This boils down\nto: what is an intended call vs an unintended one? IBAC solves precisely this:\nit captures the client developer\u2019s intents, at design time. Unintended calls,\neven if made by the code (inadvertently), will fail since they were not\nexplicitly declared at design-time and hence not explicitly intended. And\ncalls made by a breached service outside of the original declared intent of\nthe developer will similarly fail.\n\n### 5\\. Align code and access approvals\n\nThe IBAC security model starts from: trust your developers. You trust them to\nwrite the code that powers the business, and specifically to code the calls to\nother services, so trust them to declare those calls in intents files. (It\nseems pretty obvious when stated this way.) But responsible organizations\ndon\u2019t stop there: they trust and verify. There are review and approval\nprocesses for code, there are tests and monitoring, there are automated scans,\nthere is revision control with history and rollback, and there is ownership of\nchanges with accountability. All of these can and should incorporate intents\nfiles. For example, code reviewers should ensure that the declared intents\ncorrespond to the calls made in the code, and that changes to the code have\ncorresponding intents file changes.\n\nOnce intents files have been approved, along with the approved code that\nrealizes them, it\u2019s known that this approved code won\u2019t work without granting\naccess exactly as stated in the intents files. Access may then be\nautomatically approved accordingly, or further rules may be imposed \u2014 see the\nnext section.\n\n### 6\\. Separate concerns: access needed and access granted\n\nOnce the code and its intents declarations are approved, then automation can\ntake over. The access that needs to be granted to make the code work as\nintended is now known. The IBAC platform should be configured to overlay the\norganization\u2019s trust model:\n\n  * One example might be to auto-approve (turn intents into actual access) all intents files in dev environments but require secops approvals for any new intents before rolling out to staging, and generate follow-up secops tickets for new intents in prod.\n  * Another example might be to auto-approve all intents other than specific called-out services which require those service teams to approve.\n  * Yet a third example would be to auto-approve all but mutating calls (writes, vs reads) to certain sensitive services; the latter would require an additional label to be added by an authorized party to the calling service, such as Finance approved or License verified.\n\nThese examples illustrate the balance that may be needed between trusting that\ncode that has been developed to make certain calls should be given the access\nto complete the calls, and incorporating other compliance and security needs\nof the business.\n\n### 7\\. Separate concerns: access and access controls\n\nIBAC allows strong separation between the definition of the access required by\na client and the implementation of access controls in front of the servers. To\na large extent, the details of the access control mechanisms and\nconfigurations need not be known at design time, in particular to the client\ndeveloper. There are many advantages that follow:\n\n  * Developers can focus their efforts and expertise on functional needs, without needing all the expertise and overhead to also configure access controls.\n  * Secops engineers can require that access be done securely, and ensure that access controls are implemented correctly and stringently, knowing they are not slowing down the development process when they do so.\n  * Platform engineers can use the IBAC platform to automate the realization of the intended and approved access within the enforcement systems (network policies, ACLs, gateways, etc.), to meet the requirements set by the secops engineers and the security and compliance team.\n\nDepending on the access control mechanisms, it may not be possible to\ncompletely separate the client and server developers from the control\nmechanisms. For example, in some cases the client must present credentials\nexplicitly in calling the server, and the server might need to explicitly\nverify them (if using an inline\n\n## Otterize OSS security\n\nOtterize OSS components \u2014 the intents operator, credentials operator, and\nnetwork mapper \u2014 can only be deployed by cluster admins. Cluster admins can\nalso set the scope in which these components operate, such as the namespaces\nthey watch for intents, or the Kafka topics they will affect (which also\nrequires Kafka admin privileges).\n\nUsers of the cluster, i.e. developers, then use pod annotations and custom\nresources (the Otterize client intents) to instruct the operators to grant\nthem access or credentials. Cluster admins can use Kubernetes RBAC to control\nwho can create and update client intents.\n\nCluster admins can use Kubernetes RBAC to control which Kubernetes users can\napply intents.\n\n### Service identity trust model\n\nServices in Otterize are identified through their resolved or declared service\nname, coupled with the namespace they\u2019re running in. A service in namespace A\nhas a different identity to a service in namespace B \u2014 in network policies as\nwell as cryptographically.\n\nServices can then gain access to connect to other services through declared\nintents that create network policies or Kafka ACLs, as well as request\ncredentials for the instance of the service running in this namespace.\n\nThe service names in each namespace are set by the developers, or the platform\nteam - whoever can set the name of the resource that deploys the pods, or set\nannotations on the pods. It is the cluster admin's responsibility to determine\nwho can set those. In most cases, we expect that restricting access by\nnamespace is sufficient, as service identities are scoped by namespace. Learn\nmore about how service identity resolution works.\n\n### Cryptographic credentials\n\nThe cryptographic credentials created by the Otterize credentials operator\n(mTLS certificate and key pairs) are provided in one of three ways, depending\non how the operator is configured:\n\n  1. By a cert-manager deployment in the same cluster.\n  2. By the Otterize Cloud managed credentials service. That service is built on a Hashicorp Vault instance with a CA automatically created for you. Using Otterize Cloud for credentials means you do not need to deploy SPIRE on your cluster, which makes for a simpler and lightweight deployment.\n  3. By a SPIRE server that is deployed alongside the credentials operator.\n\nNote that, by default, the first option (in-cluster SPIRE) is used, even when\nthe credentials operator is connected to Otterize Cloud). The\ncertificateProvider could be set to otterize-cloud or cert-manager to use the\nother options; see the Helm chart configuration for the credentials operator\nfor more details.\n\nThe credentials operator watches for pods starting up in a Kubernetes cluster,\nand if mTLS credentials are requested, it uses the resolved or declared\nservice name plus the pod\u2019s namespace to generate credentials for that service\nname, in that namespace. The operator is conceptually similar to a SPIRE agent\nin that it attests to the identity of pods.\n\nLearn more about how SPIRE works.\n\nEdit this page\n\nJoin our newsletter to stay up to date on features and releases.\n\nBy subscribing you agree to with our Privacy Policy and to receive updates\nfrom us.\n\n\u00b7\n\nPlatform\n\nOpen Source\n\nOtterize Cloud\n\nresources\n\nDocumentation\n\nResource Hub\n\nAbout Us\n\nPricing\n\nFollow Us\n\n\u00b7\n\n\u00a9 2024 Otterize. All rights reserved.\n\nService Status Privacy Policy Terms of Service Cookies Settings\n\n", "frontpage": false}
