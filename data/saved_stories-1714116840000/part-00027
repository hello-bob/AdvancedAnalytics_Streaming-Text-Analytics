{"aid": "40162330", "title": "React 19 Beta", "url": "https://react.dev/blog/2024/04/25/react-19", "domain": "react.dev", "votes": 9, "user": "georgehill", "posted_at": "2024-04-25 20:05:25", "comments": 0, "source_title": "React 19 Beta \u2013 React", "source_text": "React 19 Beta \u2013 React\n\nStream React Conf on May 15-16.\n\nLearn more.\n\nBlog\n\n# React 19 Beta\n\nApril 25, 2024 by The React Team\n\n### Note\n\nThis beta release is for libraries to prepare for React 19. App developers\nshould upgrade to 18.3.0 and wait for React 19 stable as we work with\nlibraries and make changes based on feedback.\n\nReact 19 Beta is now available on npm!\n\nIn our React 19 Beta Upgrade Guide, we shared step-by-step instructions for\nupgrading your app to React 19 Beta. In this post, we\u2019ll give an overview of\nthe new features in React 19, and how you can adopt them.\n\n  * What\u2019s new in React 19\n  * Improvements in React 19\n  * How to upgrade\n\nFor a list of breaking changes, see the Upgrade Guide.\n\n## What\u2019s new in React 19\n\n### Actions\n\nA common use case in React apps is to perform a data mutation and then update\nstate in response. For example, when a user submits a form to change their\nname, you will make an API request, and then handle the response. In the past,\nyou would need to handle pending states, errors, optimistic updates, and\nsequential requests manually.\n\nFor example, you could handle the pending and error state in useState:\n\n    \n    \n    // Before Actions\n    \n    function UpdateName({}) {\n    \n    const [name, setName] = useState(\"\");\n    \n    const [error, setError] = useState(null);\n    \n    const [isPending, setIsPending] = useState(false);\n    \n    const handleSubmit = async () => {\n    \n    setIsPending(true);\n    \n    const error = await updateName(name);\n    \n    setIsPending(false);\n    \n    if (error) {\n    \n    setError(error);\n    \n    return;\n    \n    }\n    \n    redirect(\"/path\");\n    \n    };\n    \n    return (\n    \n    <div>\n    \n    <input value={name} onChange={(event) => setName(event.target.value)} />\n    \n    <button onClick={handleSubmit} disabled={isPending}>\n    \n    Update\n    \n    </button>\n    \n    {error && <p>{error}</p>}\n    \n    </div>\n    \n    );\n    \n    }\n\nIn React 19, we\u2019re adding support for using async functions in transitions to\nhandle pending states, errors, forms, and optimistic updates automatically.\n\nFor example, you can use useTransition to handle the pending state for you:\n\n    \n    \n    // Using pending state from Actions\n    \n    function UpdateName({}) {\n    \n    const [name, setName] = useState(\"\");\n    \n    const [error, setError] = useState(null);\n    \n    const [isPending, startTransition] = useTransition();\n    \n    const handleSubmit = async () => {\n    \n    startTransition(async () => {\n    \n    const error = await updateName(name);\n    \n    if (error) {\n    \n    setError(error);\n    \n    return;\n    \n    }\n    \n    redirect(\"/path\");\n    \n    })\n    \n    };\n    \n    return (\n    \n    <div>\n    \n    <input value={name} onChange={(event) => setName(event.target.value)} />\n    \n    <button onClick={handleSubmit} disabled={isPending}>\n    \n    Update\n    \n    </button>\n    \n    {error && <p>{error}</p>}\n    \n    </div>\n    \n    );\n    \n    }\n\nThe async transition will immediately set the isPending state to true, make\nthe async request(s), and switch isPending to false after any transitions.\nThis allows you to keep the current UI responsive and interactive while the\ndata is changing.\n\n### Note\n\n#### By convention, functions that use async transitions are called \u201cActions\u201d.\n\nActions automatically manage submitting data for you:\n\n  * Pending state: Actions provide a pending state that starts at the beginning of a request and automatically resets when the final state update is committed.\n  * Optimistic updates: Actions support the new useOptimistic hook so you can show users instant feedback while the requests are submitting.\n  * Error handling: Actions provide error handling so you can and display Error Boundaries when a request fails, and revert optimistic updates to their original value automatically.\n  * Forms: <form> elements now support passing functions to the action and formAction props. Passing functions to the action props use Actions by default and reset the form automatically after submission.\n\nBuilding on top of Actions, we\u2019re also introducing <form> Actions to manage\nforms automatically, useOptimistic to manage optimistic updates, and new hooks\nuseActionState, useFormStatus to support the common cases for Actions and\nForms.\n\nIn React 19, the above example can be simplified to:\n\n    \n    \n    // Using <form> Actions and useActionState\n    \n    function ChangeName({ name, setName }) {\n    \n    const [error, submitAction, isPending] = useActionState(\n    \n    async (previousState, formData) => {\n    \n    const error = await updateName(formData.get(\"name\"));\n    \n    if (error) {\n    \n    return error;\n    \n    }\n    \n    redirect(\"/path\");\n    \n    }\n    \n    );\n    \n    return (\n    \n    <form action={submitAction}>\n    \n    <input type=\"text\" name=\"name\" />\n    \n    <button type=\"submit\" disabled={isPending}>Update</button>\n    \n    {error && <p>{error}</p>}\n    \n    </form>\n    \n    );\n    \n    }\n\nIn the next section, we\u2019ll break down each of the new Action features in React\n19.\n\n### New hook: useActionState\n\nTo make the common cases easier for Actions, we\u2019ve added a new hook called\nuseActionState:\n\n    \n    \n    const [error, submitAction, isPending] = useActionState(async (previousState, newName) => {\n    \n    const {error} = await updateName(newName);\n    \n    if (!error) {\n    \n    // You can return any result of the action.\n    \n    // Here, we return only the error.\n    \n    return error;\n    \n    }\n    \n    // handle success\n    \n    });\n\nuseActionState accepts a function (the \u201cAction\u201d), and returns a wrapped Action\nto call. This works because Actions compose. When the wrapped Action is\ncalled, useActionState will return the last result of the Action as data, and\nthe pending state of the Action as pending.\n\n### Note\n\nReact.useActionState was previously called ReactDOM.useFormState in the Canary\nreleases, but we\u2019ve renamed it and deprecated useFormState.\n\nSee #28491 for more info.\n\nFor more information, see the docs for useActionState.\n\n### <form> Actions\n\nActions are also integrated with React 19\u2019s new <form> features. We\u2019ve added\nsupport for passing functions as the action and formAction props of <form>,\n<input>, and <button> elements to automatically submit forms with Actions:\n\n    \n    \n    <form action={actionFunction}>\n\nWhen a <form> Action succeeds, React will automatically reset the form for\nuncontrolled components. If you need to reset the <form> manually, you can\ncall the new requestFormReset React DOM API.\n\nFor more information, see the docs for <form>, <input>, and <button>.\n\n### New hook: useFormStatus\n\nIn design systems, it\u2019s common to write design components that need access to\ninformation about the <form> they\u2019re in, without drilling props down to the\ncomponent. This can be done via Context, but to make the common case easier,\nwe\u2019ve added a new hook useFormStatus:\n\n    \n    \n    function DesignButton() {\n    \n    const {pending} = useFormStatus();\n    \n    return <button type=\"submit\" disabled={pending} />\n    \n    }\n\nuseFormStatus reads the status of the parent <form> as if the form was a\nContext provider.\n\nFor more information, see the docs for useFormStatus.\n\n### New hook: useOptimistic\n\nAnother common UI pattern when performing a data mutation is to show the final\nstate optimistically while the async request is underway. In React 19, we\u2019re\nadding a new hook called useOptimistic to make this easier:\n\n    \n    \n    function ChangeName({currentName, onUpdateName}) {\n    \n    const [optimisticName, setOptimisticName] = useOptimistic(currentName);\n    \n    const submitAction = async formData => {\n    \n    const newName = formData.get(\"name\");\n    \n    setOptimisticName(newName);\n    \n    const updatedName = await updateName(newName);\n    \n    onUpdateName(updatedName);\n    \n    };\n    \n    return (\n    \n    <form action={submitAction}>\n    \n    <p>Your name is: {optimisticName}</p>\n    \n    <p>\n    \n    <label>Change Name:</label>\n    \n    <input\n    \n    type=\"text\"\n    \n    name=\"name\"\n    \n    disabled={currentName !== optimisticName}\n    \n    />\n    \n    </p>\n    \n    </form>\n    \n    );\n    \n    }\n\nThe useOptimistic hook will immediately render the optimisticName while the\nupdateName request is in progress. When the update finishes or errors, React\nwill automatically switch back to the currentName value.\n\nFor more information, see the docs for useOptimistic.\n\n### New API: use\n\nIn React 19 we\u2019re introducing a new API to read resources in render: use.\n\nFor example, you can read a promise with use, and React will Suspend until the\npromise resolves:\n\n    \n    \n    import {use} from 'react';\n    \n    function Comments({commentsPromise}) {\n    \n    // NOTE: this will resume the promise from the server.\n    \n    // It will suspend until the data is available.\n    \n    const comments = use(commentsPromise);\n    \n    return comments.map(comment => <p>{comment}</p>);\n    \n    }\n\n### Note\n\n#### use does not support promises created in render.\n\nIf you try to pass a promise created in render to use, React will warn:\n\nConsole\n\nA component was suspended by an uncached promise. Creating promises inside a\nClient Component or hook is not yet supported, except via a Suspense-\ncompatible library or framework.\n\nTo fix, you need to pass a promise from a suspense powered library or\nframework that supports caching for promises. In the future we plan to ship\nfeatures to make it easier to cache promises in render.\n\nYou can also read context with use, allowing you to read Context\nconditionally:\n\n    \n    \n    import {use} from 'react';\n    \n    import LightThemeContext from './LightThemeContext'\n    \n    import DarkThemeContext from './ThemeContext'\n    \n    function ThemedPage({theme, children}) {\n    \n    let currentTheme;\n    \n    if (theme === 'dark') {\n    \n    currentTheme = use(DarkThemeContext);\n    \n    } else {\n    \n    currentTheme = use(LightThemeContext);\n    \n    }\n    \n    return (\n    \n    <Page theme={currentTheme}>\n    \n    {children}\n    \n    </Page>\n    \n    );\n    \n    }\n\nThe use API can only be called in render, similar to hooks. Unlike hooks, use\ncan be called conditionally. In the future we plan to support more ways to\nconsume resources in render with use.\n\nFor more information, see the docs for use.\n\n## React Server Components\n\n### Server Components\n\nServer Components are a new option that allows rendering components ahead of\ntime, before bundling, in an environment separate from your client application\nor SSR server. This separate environment is the \u201cserver\u201d in React Server\nComponents. Server Components can run once at build time on your CI server, or\nthey can be run for each request using a web server.\n\nReact 19 includes all of the React Server Components features included from\nthe Canary channel. This means libraries that ship with Server Components can\nnow target React 19 as a peer dependency with a react-server export condition\nfor use in frameworks that support the Full-stack React Architecture.\n\n### Note\n\n#### How do I build support for Server Components?\n\nWhile React Server Components in React 19 are stable and will not break\nbetween major versions, the underlying APIs used to implement a React Server\nComponents bundler or framework do not follow semver and may break between\nminors in React 19.x.\n\nTo support React Server Components as a bundler or framework, we recommend\npinning to a specific React version, or using the Canary release. We will\ncontinue working with bundlers and frameworks to stabilize the APIs used to\nimplement React Server Components in the future.\n\nFor more, see the docs for React Server Components.\n\n### Server Actions\n\nServer Actions allow Client Components to call async functions executed on the\nserver.\n\nWhen a Server Action is defined with the \"use server\" directive, your\nframework will automatically create a reference to the server function, and\npass that reference to the Client Component. When that function is called on\nthe client, React will send a request to the server to execute the function,\nand return the result.\n\n### Note\n\n#### There is no directive for Server Components.\n\nA common misunderstanding is that Server Components are denoted by \"use\nserver\", but there is no directive for Server Components. The \"use server\"\ndirective is used for Server Actions.\n\nFor more info, see the docs for Directives.\n\nServer Actions can be created in Server Components and passed as props to\nClient Components, or they can be imported and used in Client Components.\n\nFor more, see the docs for React Server Actions.\n\n## Improvements in React 19\n\n### ref as a prop\n\nStarting in React 19, you can now access ref as a prop for function\ncomponents:\n\n    \n    \n    function MyInput({placeholder, ref}) {\n    \n    return <input placeholder={placeholder} ref={ref} />\n    \n    }\n    \n    //...\n    \n    <MyInput ref={ref} />\n\nNew function components will no longer need forwardRef, and we will be\npublishing a codemod to automatically update your components to use the new\nref prop. In future versions we will deprecate and remove forwardRef.\n\n### Note\n\nrefs passed to classes are not passed as props since they reference the\ncomponent instance.\n\n### Diffs for hydration errors\n\nWe also improved error reporting for hydration errors. For example, instead of\nlogging multiple errors in DEV without any information about the mismatch:\n\nConsole\n\nWarning: Text content did not match. Server: \u201cServer\u201d Client: \u201cClient\u201d at span\nat App\n\nWarning: An error occurred during hydration. The server HTML was replaced with\nclient content in <div>.\n\nWarning: Text content did not match. Server: \u201cServer\u201d Client: \u201cClient\u201d at span\nat App\n\nWarning: An error occurred during hydration. The server HTML was replaced with\nclient content in <div>.\n\nUncaught Error: Text content does not match server-rendered HTML. at\ncheckForUnmatchedText ...\n\nWe now log a single message with a diff of the mismatch:\n\nConsole\n\nUncaught Error: Hydration failed because the server rendered HTML didn\u2019t match\nthe client. As a result this tree will be regenerated on the client. This can\nhappen if an SSR-ed Client Component used: - A server/client branch if (typeof\nwindow !== 'undefined'). - Variable input such as Date.now() or Math.random()\nwhich changes each time it\u2019s called. - Date formatting in a user\u2019s locale\nwhich doesn\u2019t match the server. - External changing data without sending a\nsnapshot of it along with the HTML. - Invalid HTML tag nesting. It can also\nhappen if the client has a browser extension installed which messes with the\nHTML before React loaded. https://react.dev/link/hydration-mismatch <App>\n<span> \\+ Client - Server at throwOnHydrationMismatch ...\n\n### <Context> as a provider\n\nIn React 19, you can render <Context> as a provider instead of\n<Context.Provider>:\n\n    \n    \n    const ThemeContext = createContext('');\n    \n    function App({children}) {\n    \n    return (\n    \n    <ThemeContext value=\"dark\">\n    \n    {children}\n    \n    </ThemeContext>\n    \n    );\n    \n    }\n\nNew Context providers can use <Context> and we will be publishing a codemod to\nconvert existing providers. In future versions we will deprecate\n<Context.Provider>.\n\n### Cleanup functions for refs\n\nWe now support returning a cleanup function from ref callbacks:\n\n    \n    \n    <input\n    \n    ref={(ref) => {\n    \n    // ref created\n    \n    // NEW: return a cleanup function to reset\n    \n    // the ref when element is removed from DOM.\n    \n    return () => {\n    \n    // ref cleanup\n    \n    };\n    \n    }}\n    \n    />\n\nWhen the component unmounts, React will call the cleanup function returned\nfrom the ref callback. This works for DOM refs, refs to class components, and\nuseImperativeHandle.\n\n### Note\n\nPreviously, React would call ref functions with null when unmounting the\ncomponent. If your ref returns a cleanup function, React will now skip this\nstep.\n\nIn future versions, we will deprecate calling refs with null when unmounting\ncomponents.\n\nDue to the introduction of ref cleanup functions, returning anything else from\na ref callback will now be rejected by TypeScript. The fix is usually to stop\nusing implicit returns, for example:\n\n    \n    \n    - <div ref={current => (instance = current)} />\n    \n    + <div ref={current => {instance = current}} />\n\nThe original code returned the instance of the HTMLDivElement and TypeScript\nwouldn\u2019t know if this was supposed to be a cleanup function or if you didn\u2019t\nwant to return a cleanup function.\n\nYou can codemod this pattern with no-implicit-ref-callback-return .\n\n### useDeferredValue initial value\n\nWe\u2019ve added an initialValue option to useDeferredValue:\n\n    \n    \n    function Search({deferredValue}) {\n    \n    // On initial render the value is ''.\n    \n    // Then a re-render is scheduled with the deferredValue.\n    \n    const value = useDeferredValue(deferredValue, '');\n    \n    return (\n    \n    <Results query={value} />\n    \n    );\n    \n    }\n\nWhen initialValue is provided, useDeferredValue will return it as value for\nthe initial render of the component, and scheduled a re-render in the\nbackground with the deferredValue returned.\n\nFor more, see useDeferredValue.\n\n### Support for Document Metadata\n\nIn HTML, document metadata tags like <title>, <link>, and <meta> are reserved\nfor placement in the <head> section of the document. In React, the component\nthat decides what metadata is appropriate for the app may be very far from the\nplace where you render the <head> or React does not render the <head> at all.\nIn the past, these elements would need to be inserted manually in an effect,\nor by libraries like react-helmet, and required careful handling when server\nrendering a React application.\n\nIn React 19, we\u2019re adding support for rendering document metadata tags in\ncomponents natively:\n\n    \n    \n    function BlogPost({post}) {\n    \n    return (\n    \n    <article>\n    \n    <h1>{post.title}</h1>\n    \n    <title>{post.title}</title>\n    \n    <meta name=\"author\" content=\"Josh\" />\n    \n    <link rel=\"author\" href=\"https://twitter.com/joshcstory/\" />\n    \n    <meta name=\"keywords\" content={post.keywords} />\n    \n    <p>\n    \n    Eee equals em-see-squared...\n    \n    </p>\n    \n    </article>\n    \n    );\n    \n    }\n\nWhen React renders this component, it will see the <title> <link> and <meta>\ntags, and automatically hoist them to the <head> section of document. By\nsupporting these metadata tags natively, we\u2019re able to ensure they work with\nclient-only apps, streaming SSR, and Server Components.\n\n### Note\n\n#### You may still want a Metadata library\n\nFor simple use cases rendering Document Metadata as tags may be suitable, but\nlibraries can offer more powerful features like overriding generic metadata\nwith specific metadata based on the current route. So these feature make it\neasier for frameworks and libraries like react-helmet to support metadata\ntags, rather than replace them.\n\nFor more info, see the docs for <title>, <link>, and <meta>.\n\n### Support for stylesheets\n\nStylesheets, both externally linked (<link rel=\"stylesheet\" href=\"...\">) and\ninline (<style>...</style>), require careful positioning in the DOM due to\nstyle precedence rules. Building a stylesheet capability that allows for\ncomposability within components is hard, so users often end up either loading\nall of their styles far from the components that may depend on them, or they\nuse a style library which encapsulates this complexity.\n\nIn React 19, we\u2019re addressing this complexity and providing even deeper\nintegration into Concurrent Rendering on the Client and Streaming Rendering on\nthe Server with built in support for stylesheets. If you tell React the\nprecedence of your stylesheet it will manage the insertion order of the\nstylesheet in the DOM and ensure that the stylesheet (if external) is loaded\nbefore revealing content that depends on those style rules.\n\n    \n    \n    function ComponentOne() {\n    \n    return (\n    \n    <Suspense fallback=\"loading...\">\n    \n    <link rel=\"stylesheet\" href=\"foo\" precedence=\"default\" />\n    \n    <link rel=\"stylesheet\" href=\"bar\" precedence=\"high\" />\n    \n    <article class=\"foo-class bar-class\">\n    \n    {...}\n    \n    </article>\n    \n    </Suspense>\n    \n    )\n    \n    }\n    \n    function ComponentTwo() {\n    \n    return (\n    \n    <div>\n    \n    <p>{...}</p>\n    \n    <link rel=\"stylesheet\" href=\"baz\" precedence=\"default\" /> <-- will be inserted between foo & bar\n    \n    </div>\n    \n    )\n    \n    }\n\nDuring Server Side Rendering React will include the stylesheet in the <head>,\nwhich ensures that the browser will not paint until it has loaded. If the\nstylesheet is discovered late after we\u2019ve already started streaming, React\nwill ensure that the stylesheet is inserted into the <head> on the client\nbefore revealing the content of a Suspense boundary that depends on that\nstylesheet.\n\nDuring Client Side Rendering React will wait for newly rendered stylesheets to\nload before committing the render. If you render this component from multiple\nplaces within your application React will only include the stylesheet once in\nthe document:\n\n    \n    \n    function App() {\n    \n    return <>\n    \n    <ComponentOne />\n    \n    ...\n    \n    <ComponentOne /> // won't lead to a duplicate stylesheet link in the DOM\n    \n    </>\n    \n    }\n\nFor users accustomed to loading stylesheets manually this is an opportunity to\nlocate those stylesheets alongside the components that depend on them allowing\nfor better local reasoning and an easier time ensuring you only load the\nstylesheets that you actually depend on.\n\nStyle libraries and style integrations with bundlers can also adopt this new\ncapability so even if you don\u2019t directly render your own stylesheets, you can\nstill benefit as your tools are upgraded to use this feature.\n\nFor more details, read the docs for <link> and <style>.\n\n### Support for async scripts\n\nIn HTML normal scripts (<script src=\"...\">) and deferred scripts (<script\ndefer=\"\" src=\"...\">) load in document order which makes rendering these kinds\nof scripts deep within your component tree challenging. Async scripts (<script\nasync=\"\" src=\"...\">) however will load in arbitrary order.\n\nIn React 19 we\u2019ve included better support for async scripts by allowing you to\nrender them anywhere in your component tree, inside the components that\nactually depend on the script, without having to manage relocating and\ndeduplicating script instances.\n\n    \n    \n    function MyComponent() {\n    \n    return (\n    \n    <div>\n    \n    <script async={true} src=\"...\" />\n    \n    Hello World\n    \n    </div>\n    \n    )\n    \n    }\n    \n    function App() {\n    \n    <html>\n    \n    <body>\n    \n    <MyComponent>\n    \n    ...\n    \n    <MyComponent> // won't lead to duplicate script in the DOM\n    \n    </body>\n    \n    </html>\n    \n    }\n\nIn all rendering environments, async scripts will be deduplicated so that\nReact will only load and execute the script once even if it is rendered by\nmultiple different components.\n\nIn Server Side Rendering, async scripts will be included in the <head> and\nprioritized behind more critical resources that block paint such as\nstylesheets, fonts, and image preloads.\n\nFor more details, read the docs for <script>.\n\n### Support for preloading Resources\n\nDuring initial document load and on client side updates, telling the Browser\nabout resources that it will likely need to load as early as possible can have\na dramatic effect on page performance.\n\nReact 19 includes a number of new APIs for loading and preloading Browser\nresources to make it as easy as possible to build great experiences that\naren\u2019t held back by inefficient resource loading.\n\n    \n    \n    import { prefetchDNS, preconnect, preload, preinit } from 'react-dom'\n    \n    function MyComponent() {\n    \n    preinit('https://.../path/to/some/script.js', {as: 'script' }) // loads and executes this script eagerly\n    \n    preload('https://.../path/to/font.woff', { as: 'font' }) // preloads this font\n    \n    preload('https://.../path/to/stylesheet.css', { as: 'style' }) // preloads this stylesheet\n    \n    prefetchDNS('https://...') // when you may not actually request anything from this host\n    \n    preconnect('https://...') // when you will request something but aren't sure what\n    \n    }\n    \n    \n    <!-- the above would result in the following DOM/HTML -->\n    \n    <html>\n    \n    <head>\n    \n    <!-- links/scripts are prioritized by their utility to early loading, not call order -->\n    \n    <link rel=\"prefetch-dns\" href=\"https://...\">\n    \n    <link rel=\"preconnect\" href=\"https://...\">\n    \n    <link rel=\"preload\" as=\"font\" href=\"https://.../path/to/font.woff\">\n    \n    <link rel=\"preload\" as=\"style\" href=\"https://.../path/to/stylesheet.css\">\n    \n    <script async=\"\" src=\"https://.../path/to/some/script.js\"></script>\n    \n    </head>\n    \n    <body>\n    \n    ...\n    \n    </body>\n    \n    </html>\n\nThese APIs can be used to optimize initial page loads by moving discovery of\nadditional resources like fonts out of stylesheet loading. They can also make\nclient updates faster by prefetching a list of resources used by an\nanticipated navigation and then eagerly preloading those resources on click or\neven on hover.\n\nFor more details see Resource Preloading APIs.\n\n### Compatibility with third-party scripts and extensions\n\nWe\u2019ve improved hydration to account for third-party scripts and browser\nextensions.\n\nWhen hydrating, if an element that renders on the client doesn\u2019t match the\nelement found in the HTML from the server, React will force a client re-render\nto fix up the content. Previously, if an element was inserted by third-party\nscripts or browser extensions, it would trigger a mismatch error and client\nrender.\n\nIn React 19, unexpected tags in the <head> and <body> will be skipped over,\navoiding the mismatch errors. If React needs to re-render the entire document\ndue to an unrelated hydration mismatch, it will leave in place stylesheets\ninserted by third-party scripts and browser extensions.\n\n### Better error reporting\n\nWe improved error handling in React 19 to remove duplication and provide\noptions for handling caught and uncaught errors. For example, when there\u2019s an\nerror in render caught by an Error Boundary, previously React would throw the\nerror twice (once for the original error, then again after failing to\nautomatically recover), and then call console.error with info about where the\nerror occurred.\n\nThis resulted in three errors for every caught error:\n\nConsole\n\nUncaught Error: hit at Throws at renderWithHooks ...\n\nUncaught Error: hit <\\-- Duplicate at Throws at renderWithHooks ...\n\nThe above error occurred in the Throws component: at Throws at ErrorBoundary\nat App React will try to recreate this component tree from scratch using the\nerror boundary you provided, ErrorBoundary.\n\nIn React 19, we log a single error with all the error information included:\n\nConsole\n\nError: hit at Throws at renderWithHooks ... The above error occurred in the\nThrows component: at Throws at ErrorBoundary at App React will try to recreate\nthis component tree from scratch using the error boundary you provided,\nErrorBoundary. at ErrorBoundary at App\n\nAdditionally, we\u2019ve added two new root options to complement\nonRecoverableError:\n\n  * onCaughtError: called when React catches an error in an Error Boundary.\n  * onUncaughtError: called when an error is thrown and not caught by an Error Boundary.\n  * onRecoverableError: called when an error is thrown and automatically recovered.\n\nFor more info and examples, see the docs for createRoot and hydrateRoot.\n\n### Support for Custom Elements\n\nReact 19 adds full support for custom elements and passes all tests on Custom\nElements Everywhere.\n\nIn past versions, using Custom Elements in React has been difficult because\nReact treated unrecognized props as attributes rather than properties. In\nReact 19, we\u2019ve added support for properties that works on the client and\nduring SSR with the following strategy:\n\n  * Server Side Rendering: props passed to a custom element will render as attributes if their type is a primitive value like string, number, or the value is true. Props with non-primitive types like object, symbol, function, or value false will be omitted.\n  * Client Side Rendering: props that match a property on the Custom Element instance will be assigned as properties, otherwise they will be assigned as attributes.\n\nThanks to Joey Arhar for driving the design and implementation of Custom\nElement support in React.\n\n#### How to upgrade\n\nSee the React 19 Upgrade Guide for step-by-step instructions and a full list\nof breaking and notable changes.\n\nPreviousBlog\n\nNextReact 19 Beta Upgrade Guide\n\nHow do you like these docs?\n\nTake our survey!\n\n\u00a92024\n\nLearn React\n\nQuick Start\n\nInstallation\n\nDescribing the UI\n\nAdding Interactivity\n\nManaging State\n\nEscape Hatches\n\nAPI Reference\n\nReact APIs\n\nReact DOM APIs\n\nCommunity\n\nCode of Conduct\n\nMeet the Team\n\nDocs Contributors\n\nAcknowledgements\n\nMore\n\nBlog\n\nReact Native\n\nPrivacy\n\nTerms\n\n", "frontpage": true}
