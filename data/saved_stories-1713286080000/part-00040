{"aid": "40048901", "title": "How to hide your IP address: a field guide to VPNs, proxies and traffic relaying", "url": "https://educatedguesswork.org/posts/traffic-relaying/", "domain": "educatedguesswork.org", "votes": 1, "user": "aragonite", "posted_at": "2024-04-16 06:22:04", "comments": 0, "source_title": "How to hide your IP address", "source_text": "How to hide your IP address\n\n# Educated Guesswork\n\n  * Archive\n  * About Me\n  * Contact\n  * Follow on Twitter\n  * Subscribe\n\n# How to hide your IP address\n\nA field guide to VPNs, proxies, and traffic relaying\n\nPosted by ekr on 17 Oct 2022\n\nAs I mentioned previously in my posts on private browsing and public WiFi, if\nyou really want to keep your activity on the Internet private, you need some\nway to protect your IP address (i.e., the address that machines on the\nInternet use to talk to your computer) and the IP addresses of the servers you\nare going to. There are a variety of different technologies you can use for\nthis purpose, with somewhat different properties. This post provides a perhaps\nover-long description of the various options.\n\n## The Basics #\n\nAs usual, with any security problem, we need to start with the threat model.\nWe are concerned with two primary modes of attack:\n\n  1. The server learning the user's IP address and using it to identify them or correlate their activity.\n  2. The local network learning which servers the user is going to.\n  3. The server using your apparent geolocation as determined from your IP address to restrict access to certain kinds of content (soccer, BBC, whatever).\n\nOf course, whether you think this last item is actually a form of attack that\nshould be defended against depends on your perspective and maybe how big a\nDoctor Who fan you are.\n\nThe basic technique for defending against threats (1) and (3) is to push the\ntraffic through some kind of anonymizing relay:\n\nAs shown in the diagram above, the client connects to the relay and tells it\nwhere to connect. It then sends traffic to the relay, which forwards it to the\nserver. The relay replaces the client's IP address with its own, so the server\njust sees the relay's address. In general, the relay will be serving quite a\nfew clients, so the server will find it hard to distinguish which one is which\n(k-anonymity).^[1] This simple version clearly addresses threat (1), and, if\nthe relay operator lets you select an IP address outside your own geographic\nregion, threat (3). In order to defend against threat (2) you also need to\nencrypt the traffic to the relay so that an attacker on your network can't see\nwhich server you are connecting to and the traffic you are sending to it (see\nhere for more on this form of data leakage). Ideally, you would also encrypt\nthe traffic end-to-end to the server (using TLS or QUIC), but that's just\ngenerally good practice, not required for the privacy provided by the relay.\n\n## Relaying Options #\n\nThis basic design is at the heart of every relaying system, but the details\nvary in important ways. There are three major axes of variation:\n\n  * The network layer at which relaying happens\n  * The number of hops in the network\n  * Business model\n\nWe cover each of these below.\n\n### Network Layer #\n\nThe first major point of variation is the layer at which the relaying happens.\nUnderstanding this requires a bit of background on how the Internet networking\nprotocols work.\n\n#### IP #\n\nThe most basic protocol on the Internet is what's called, somewhat\nunsurprisingly, Internet Protocol (IP). IP is what's called a \"packet\nswitching\" protocol, which means that the basic unit is a self-contained\nmessage called a packet. A packet is like a letter in that it has a source\naddress and a destination address. This means that when you send an IP packet\non the network, the Internet can automatically route the packet to the\ndestination address by looking at the packet with no other state about either\ncomputer. A simplified IP packet looks like this:\n\nThe main thing in the packet is the actually data to be delivered from the\nsource to the destination, also called the payload. The payload is variable\nlength with a maximum typically around 1500 bytes. The packet also has a next\nprotocol field which tells the receiver how to interpret the payload (more on\nthis later) and a length field so that it is possible to tell how long the\nentire packet is, including the variable length payload.\n\nUsing IP is very simple: your computer transmits an IP packet on the wire and\nthe Internet uses the destination address to figure out where to route it.\nWhen someone wants to transmit to you, they do the same thing.\n\n#### TCP #\n\nIf all you want to do is send a thousand or so bytes from one machine to the\nother, a single IP packet might be OK, but in practice this is almost never\nwhat you want to do. In particular, it's very common to want to send a stream\nof data (e.g., a file) which is much longer than 1500 bytes. At a high level,\nthis is done by breaking up the data into a series of smaller chunks and\nsending each one in a single packet. But of course, life isn't so simple. For\ninstance:\n\n  * Packets might be lost, and must be retransmitted so that the receiver gets them.\n  * Packets might be reordered, and the receiver must know which order to put them in.\n  * In general, the network will not be able to handle an entire large file at once, so the data must be gradually transmitted over time. The sender must have some way to determine the appropriate sending rate.\n\nThe Transmission Control Protocol (TCP) is responsible for taking care of\nthese issues. The details of TCP are far too complicated to fit in this blog\npost, but at a high level, the data stream is broken up into segments, each of\nwhich has a length and a sequence number, which tells you where it goes in the\nstream. Each segment is sent in an IP packet. When the receiver gets a segment\nit can look at the sequence number to reconstruct the stream and is able to\ndetect gaps where packets are missing. TCP also includes an acknowledgment\nmechanism in which the receiver tells the sender which segments it has\nreceived; this allows the sender to retransmit packets which were lost as well\nas to adjust its sending rate appropriately.^[2] TCP requires setting up state\nbetween the two endpoints; this state is termed a \"TCP connection.\"\n\nThere are of course other protocols besides TCP which can run over IP (for\ninstance, UDP, mentioned later). This is why you need the \"next protocol\"\nfield in IP: to tell the receiver what protocol is in the IP payload.\n\n### TLS #\n\nTCP is a very old protocol and like most of the older Internet protocols, it\nwas designed before widespread use of encryption was practical. This is\nobviously bad news from a security perspective, and eventually people got\naround to fixing it. The standard solution is to carry the data over Transport\nLayer Security (TLS). TLS basically provides the abstraction of an encrypted\nand authenticated stream of data on top of a TCP connection. As with TCP, you\nneed to set up some state to use TLS, and that's called a \"TLS connection\". I\ncan talk endlessly about TLS but I won't do so here.\n\n### UDP and QUIC #\n\nApplications do not implement TCP themselves. Instead it's built into the\noperating system, specifically in what's called the operating system kernel,\ni.e., the piece of the OS that's always running and is responsible for\nmanaging the computer as a whole. The client application tells the operating\nsystem to create a TCP connection to the server, which creates what's called\n\"socket\" on the client side. The client writes data to the socket and the\nkernel automatically packages it up into TCP segments and transmits it to the\nother side, taking care of retransmission, rate control, etc. The kernel also\nreads TCP segments from the other side and makes them available to the\napplication to read. Typically, the application implements TLS itself or more\nlikely, uses some existing TLS library.\n\n#### Why can't you write your own TCP stack? #\n\nObviously, you can write your own TCP stack (it's just software, after all)\nbut the problem is that you can't install it, because on most operating\nsystems, ordinary applications aren't allowed to write or receive raw IP\ndatagrams. This is one of a number of restrictions on networking behavior that\nused to be used for security enforcement in a pre-cryptographic era. For\ninstance, at one time it was assumed that if a packet came from a given\nmachine address with a given \"port number\" (a field in the UDP/TCP header) it\ncame from a privileged process (one that had operating systems privileges).\nThere was even a whole system for remote login based on this where you could\nbe on machine A and execute commands on machine B without authenticating. I\nknow this sounds absurd now, but this was the situation from the early 80s to\nthe late 90s, when we finally got proper cryptographic authentication (at\nleast some of the time.)\n\nThis is convenient in that the application doesn't need to carry around its\nown TCP implementation, but inconvenient in that it's inflexible: suppose the\napplication wants to make some change to TCP to make it more efficient?\nThere's no way to do this without changing the operating system. By contrast,\nit's easy to change TLS behavior just by shipping a new version of the\napplication. This became particularly salient in the late 2010s when people\nwanted to make performance enhancements to TCP but were unable to because the\noperating system didn't move fast enough. The solution was to invent a new\nprotocol that could be implemented entirely in the application: QUIC.\n\nQUIC is sort of like a combination of a fancier version of TCP and the\ncryptography of TLS (in fact, it uses many pieces of TLS internally). However,\nbecause it can be implemented entirely in the application, it can be changed\nvery rapidly. Unfortunately, in most operating systems, applications are not\nallowed to write IP packets directly, and so QUIC runs over a protocol called\nthe User Datagram Protocol (UDP). UDP is a very simple protocol which just\nlets applications send single units of data (datagrams) over IP. So, QUIC runs\nover UDP and UDP runs over IP.\n\n### The protocol stack #\n\nIt's conventional to talk about this as a \"stack\" of protocols and visualize\nit in a picture called a \"layer diagram\", like so:\n\nI've also drawn on this diagram which pieces are implemented in the\napplication and which are typically part of the operating system. When the\napplication wants to write data, it starts at the top of the stack and data\nmoves down to the network. As data comes in from the network, it moves up the\nstack towards the application.\n\nIn terms of the way the data appears on the network, each layer adds its own\nencapsulation, typically either before or after the data. The diagram below\nshows two examples. The first is data being sent over TCP, in this case the\nstring \"Four score and seven years ago\". TCP adds its own header with the\nsequence number, etc. and then passes it to the IP layer, which adds the IP\nheader with the source and destination addresses. The second example is the\nsame data being sent over TLS. The TLS layer encrypts the data (shown by the\ncrosshatching) and adds its own header. It then passes it to TCP, which adds\nits own header, etc. The receiving process reverses these operations.\n\n#### Naming chunks of data #\n\nYou'll probably notice that I've been using the terms \"packet\", \"record\", etc.\nThese are not interchangeable. One of the most annoying problems in networking\nis how to name a single unit of data like a packet (sometimes called\ngenerically a protocol data unit (PDU)). Each protocol tends to have its own\nterm for this, partly just due to being defined by different people and partly\nbecause when you are working at multiple layers of the protocol stack it's a\npain to talk about \"IP datagrams\", \"UDP datagrams\", etc. Here's my incomplete\ntable of names for PDUs in different protocols:\n\nProtocol| Name  \n---|---  \nEthernet| Frame  \nIP| Packet (datagram)  \nUDP| Datagram  \nTCP| Segment  \nTLS| Record  \nQUIC| Packet (but it has things inside it called frames)  \nHTTP| Message  \nRTP| Packet (but they carry media frames)  \nOpenPGP| Packet  \nXMPP| Stanza  \n  \nOne thing that's important to know is that TCP and TLS provide the abstraction\nof a stream of data, not a set of records. What this means is that the\napplication just writes data and the TLS stack or the TCP stack coalesces\nthose chunks into one record (packet) or breaks them up at its convenience.\nThe TCP stack might even send the same data twice with two different framings.\nFor instance, suppose that the application writes \"Hello\" and then the kernel\nsends it in a single packet. While the packet is in flight, the application\nwrites \"Again\". If both packets get lost, and the kernel kernel has to\nretransmit them, it might write them as a single TCP segment (\"HelloAgain\").\n\n### Which Layer #\n\nWith this as background, we are ready to talk about one of the big points of\ndiversity: what layer are we relaying the traffic at? There are two main\noptions, at least for relaying encrypted traffic.\n\n  1. Relay the IP-layer traffic\n  2. Relay the application layer traffic (i.e., the data that would go over UDP or TCP)\n\nI cover both of these below.\n\n#### Relaying IP Traffic #\n\nEncrypting traffic at the network layer (IP) is one of the obvious ways to\naddress network security issues, as it has the important advantage that once\nyou have set it up, it secures all communications between two endpoints. Work\non this goes all the way back to the 1970s, but the IETF started standardizing\ntechnology for this purpose in 1992 under the name IPsec. The original idea\nwas actually not so much the kind of relaying system that I discussed above\nbut rather that you would encrypt traffic between the two machines that were\ncommunicating with each other. So, for instance, say my client wanted to\ncommunicate with your server, we would take the IP packets we wanted to send,\nencrypt them, and send them directly.\n\nLike the protocols we discussed above, IPsec is an encapsulation protocol,\nwhich means that to encrypt an IP packet from A to B we take the entire\noriginal packet, encrypt it,^[3] and then stuff it in another IP packet, like\nso:\n\nIn the scenario I was discussing above, the inner (encrypted) IP header and\nthe outer (plaintext) IP header will have the same addressing information, but\nit's of course possible to have them have different addressing information,\nwhich is useful for creating what's called a Virtual Private Network (VPN).\nThe motivating idea here is that you have two networks (say two offices from\nthe same company) and you want to connect them as if they were in the same\nlocation. Inside the office, you trust that the wires haven't been tampered\nwith (this is before WiFi) and so you don't encrypt all your data (I know,\nthis sounds naive now), and so what you really want is just a wire connecting\noffice 1 and office 2. This kind of private connection\u2014what used to be called\na \"leased line\"\u2014is very expensive to buy and what you actually have is an\nInternet connection which lets you connect to everyone. But if you encrypt the\ntraffic between office 1 and office 2, then you can simulate having your own\nprivate wire. Hence virtual private network. The typical topology looks like\nthis:\n\nIn this scenario, you have two offices, each of which has a \"VPN gateway\"\nwhich detects traffic that is destined from office 1 to office 2 and encrypts\nit before sending it along. Other traffic, say to Facebook, is left untouched.\nWhen the packets are received at the far VPN gateway, it just removes the\nencapsulation and drops them on the network. The effect is as if there were a\nsingle network rather than two networks.\n\nIt's also possible to deploy this kind of thing in a simpler scenario where a\nsingle user VPNs into their office network, for instance if you are in a hotel\nworking remotely, as shown in the diagram below:\n\nThe effect here is that it's like you were in the office, but you're actually\nnot. But this brings up a real problem, which is that the remote user's\nmachine doesn't have the right IP address: it has an IP address associated\nwith the user's home or office (192.0.2.1 in the diagram above) but you want\nit to appear to be in the office, which means it has to have an office IP\naddress (something starting with 203.0.112).\n\nThere are two major ways to make this work. In the first, the VPN gateway\ntells the user's device what IP address it wants it to have, and then the\nuser's device puts that in the inner IP header, while having the outer IP\nheader having the actual address. For instance, the inner (encrypted) IP\nheader would have 203.0.11.50 and the outer (plaintext) IP header would have\n192.0.2.1. The alternative is to have both headers have the user's actual IP\naddress and to have the VPN gateway translate that address into an appropriate\nlocal address for the office network (and translate in the other way on the\nreturn trip). Note that in both cases, the gateway needs to do some work, in\nthe first case to keep track of what addresses were assigned and to enforce\nthat the client uses the right one, and in the second case to do the\ntranslation.\n\nWith that background, we can finally get to the problem statement that we\nstarted with, namely concealing user behavior. Unsurprisingly you can use the\nsame technology as you use for remote access, with the difference that the VPN\ngateway is on the Internet directly rather than on some enterprise network, as\nshown below:\n\nTo the server, this just looks like the user is connecting from the VPN\ngateway, with whatever the IP address of the VPN gateway is. The client's\nlocal network just sees a connection to the VPN server, but doesn't know where\nthe data is eventually going.\n\nHere I've focused on IPsec, but it doesn't really matter which encryption\nlayer protocol you use to carry the IP packets: they're just being\nencapsulated and transported end-to-end. In practice, one sees VPNs deployed\nwith a variety of transport protocols, including DTLS, OpenVPN, WireGuard and\nQUIC. From the user's perspective, the properties of these protocols are\nlargely the same. Most products that are labeled \"VPN\" protect traffic at the\nIP layer using one or more of these protocols.\n\n#### Relaying Application Layer Traffic #\n\nAs mentioned above, the nice thing about protecting traffic at the IP layer is\nthat it protects all the traffic on the system. However, the bad thing is that\nprotecting IP layer traffic requires cooperation from the operating system.\nThis has several undesirable consequences:\n\n  1. Your code isn't portable between operating systems.\n  2. Many operating systems require some kind of administrator access in order to install or configure something that acts at the IP layer.\n  3. You are often limited to whatever affordances the OS offers you. For instance, you may not easily be able to protect some traffic and not other types of traffic.\n\nThese issues can be addressed by relaying at the application layer rather than\nthe IP layer. This can be implemented entirely in the application without\ntouching the operating system; the application just connects to the relay\n(e.g., over TCP) and sends the traffic to the relay (hopefully encrypted to\nthe server). The relay makes its own transport-level connection to the server\nand sends the application level traffic to the server, as shown below.\n\nNote that in this diagram there are two TCP connections, one between the\nclient and the relay and one between the relay and the server. The client\nconnects to the relay over TLS and then over top of that creates an end-to-end\nTLS connection to the server (you could of course not encrypt your data to the\nserver, but don't do that).\n\nOne of the big advantages of this design is that it makes it easy to relay\nsome kinds of traffic and not others. As a concrete example, consider Safe\nBrowsing, which leaks information about the user's browsing history to the\nSafe Browsing server. You might want to proxy Safe Browsing checks (which can\nbe done very cheaply because there isn't much traffic) but not generic\nbrowsing traffic (which is much higher volume and hence more expensive). This\nis easy for the browser to do because it knows which traffic is which but is\nmore difficult for an IP-layer system, which has to somehow distinguish\ndifferent types of traffic. It's not necessarily impossible but it's\nsignificantly more work. For instance, if Safe Browsing uses a separate IP\naddress from the rest of Google, then you could just relay that traffic, but\nif it shares the same IP address, then you will be encrypting people's search\ntraffic as well.\n\nA number of IP concealment systems relay at the application layer, including\nTor, Apple's iCloud Private Relay, and Firefox Private Network. Typically,\nsystems like this are referred to as \"proxies\". Apple's system is interesting\nin that it's implemented in the operating system mostly by hooking Apple's\nhigher level networking APIs. Even so, it only works on Safari not other\napplications.^[4]\n\n### How many hops? #\n\nWhatever the relaying technology, at the end of the day the relay needs to\nsend traffic to the server, which means it has to know what server you're\nconnecting to. But this creates a new privacy problem: you're connecting to\nthe relay and then telling it which server to connect to. This means that\nwhile you've prevented the server from learning your identity, you still have\na privacy problem with respect to the relay itself. The relay will have some\nprivacy policy about how it handles this information (ideally, not keeping\nlogs at all), but that's just something you have to trust them on. Even better\nwould be to have some form of a technical protection.\n\nThe standard approach to providing technical protection here is to have\nmultiple layers of relaying, as shown in the diagram below:\n\nThe way this works is that the client connects to Relay 1. It then tells Relay\n1 to connect it to Relay 2. As with our single-hop system, that data is sent\nover the encrypted channel to Relay 1 and is itself encrypted to Relay 2. The\nclient then tells Relay 2 to connect it to the server. The data to the server\nis thus encrypted three times by the client, in a nested fashion: once to the\nserver, then to Relay 2, and then to Relay 1.^[5] Each hop strips off one\nlayer of encryption and passes it to the next hop.\n\nThe result is that no single entity (other than the client) gets to see both\nthe user's identity and the identity of the server it's connecting to. Here's\nwhat each sees:\n\nEntity| Knowledge  \n---|---  \nRelay 1| Client address, Relay 2 address  \nRelay 2| Relay 1 address, Server address  \nServer| Relay 2 address, Server address  \n  \nNote that if the two relays collude, they can together uncover the client's\naddress and the server's address. However, if either is honest, then the\nclient's privacy should be protected, as neither can easily collude with the\nserver to learn this information: relay 2 because it does not know the\nclient's address and relay 1 because (hopefully) the client's connection to\nrelay 2 is one of many connections it has made to relay 2 during this time\nperiod. How well this last part works depends on the scale of operation of the\nsystem, how long the client leaves the connection up, whether it reuses the\nconnection to relay 2 for connections to multiple servers, etc.\n\nOf course, in order for this to work, the relays need to be operated by\ndifferent entities. Otherwise there's no meaningful guarantee of non-\ncollusion. This includes not being run on the same cloud service provider\n(e.g., AWS). Sometimes you'll hear about multi-hop VPNs but if the same\ncompany is providing both VPN servers, then this doesn't really help. One nice\nfeature of iCloud Private Relay is that your account is with Apple but they\narrange for multiple hops with different providers, so you don't need to worry\nabout the details.\n\nOne important limitation of multiple hops is that it can have a negative\nimpact on performance. In general, the routing algorithms that run the\nInternet try to find a reasonably efficient route between two locations^[6]\nand so you should expect that if instead of routing between point A and point\nB you route from A to C to B, then this will be somewhat slower (you'll often\nhear people use the term triangle inequality as shorthand for this). The more\nhops you do, the more likely it is you will have some kind of performance\nimpact. This isn't a precise effect, but in general, you should expect to have\nsome impact.\n\niCloud Private Relay is a two hop network, with the first hope being operated\nby Apple and the second hop being a large provider that Apple has contracted\nwith (mostly Content Delivery Networks (CDN) like Cloudflare or Akamai). Both\nApple and these CDNs have fast connectivity and good geographic distribution,\nwhich is intended to ensure high performance. Tor uses three hops, a \"guard\nnode\", a \"middle relay\" and an \"exit node\". As discussed below, Tor relays are\neffectively volunteer services, so performance varies in practice.\n\n### Business Model #\n\nYour typical VPN has a simple business model: you pay the VPN provider and\nthen authenticate to them (e.g., with a password) when you connect. This isn't\nideal for privacy because they know your name, contact information, and credit\ncard number.^[7] On the other hand, as described above, they already know your\nIP address and which sites you're going to, so it's not clear how much worse\nthis makes things.\n\nWith Private Relay, however, this would create a real problem: it's not so bad\nwith the first hop relay because that gets your IP address anyway, but if you\nauthenticate to the second relay with your identity, then you've ruined\neverything and you might as well be back with a single hop system. In order to\naddress this problem, Apple uses anonymous credentials generated using blind\nsignatures to authenticate to the proxy, as shown below:\n\nBriefly, the way this works is that the client connects to Apple and\nauthenticates to it using its iCloud account. Apple then issues an anonymous\ncredential that doesn't contain the user's identity. This credential can be\nprovided to the relay to authorize use of the service. In order to prevent\nApple from linking up these two activities the credential is blinded\n(essentially encrypted) when Apple generates it, and then the client unblinds\nit before sending it to the relay (see here for more detail on how this kind\nof credential works). This design allows the proxy to know that you are\nauthorized to use the service but not to see who you are.\n\nTor is different from either of these because it's a free service, operated by\nmembers of the community (you can donate to people who run relays). This\ncreates some unpredictable performance consequences because there really isn't\nmuch in the way of a Service Level Agreement (SLA). It also makes it somewhat\nhard to assess the actual privacy guarantees, because some of the Tor nodes\nmight be run by people you don't trust or who are actively malicious.\nObviously, with iCloud Private Relay you have to judge for yourself how much\nyou trust Apple and its partners, but at least you have some idea who they\nare.\n\n## Summary and Final Thoughts #\n\nIP addresses are an important and highly effective tracking vector and if you\nwant to browse privately you need to do something to conceal your IP, and this\nmostly means relaying. Any relaying system will conceal your identity from the\nserver, as long as your provider isn't colluding with the server. Any one hop\nsystem necessarily means that you are trusting the provider not to track your\nbehavior and not to collude with the server. Depending on how you feel about\nyour local network and its privacy policies, a single hop system might or\nmight not be an improvement (see Yael Grauer's article in Consumer Reports for\nmore on this). A multi-hop system has a much better privacy story because\nmisbehavior by a single relay is not sufficient to compromise your privacy.\n\nThe technical details of how the system works (IP versus application layer,\nmostly) don't matter that much for privacy but do matter for functionality,\nwith application layer systems being more flexible but providing less complete\ncoverage for other applications on your device. In addition, all of the multi-\nhop systems that I know are at the application layer, so as a practical matter\nif you want a multi-hop system you probably will be using an application layer\nsystem.\n\nFinally, it's important to know that even the best system provides only\nlimited protection. An attacker who has a complete view of the network can\noften do enough traffic analysis to determine who is on each end of the\ntraffic. Fortunately, most of us do not need to worry about this powerful an\nattacker.\n\n  1. Some people run their own relays, in which case they might successfully conceal their identity, but because they will be the only user, they'll be trackable by the IP of that relay. \u21a9\ufe0e\n\n  2. The way this works is that when you are sending too quickly, packets get dropped by the network, so the sender can use the rate of loss as a signal that its sending rate is too high. \u21a9\ufe0e\n\n  3. Yes, I'm ignoring \"transport mode\", in which you just carry the UDP or TCP datagram. \u21a9\ufe0e\n\n  4. This includes other browsers on iOS even though those browsers are required to use Apple's WebKit engine. As far as I can tell, this is just a policy choice on Apple's side, not any kind of technical limitation. \u21a9\ufe0e\n\n  5. You'll sometimes hear the term \"onion routing\" applied to this, especially with Tor. \u21a9\ufe0e\n\n  6. This is a hideously complicated topic all on its own. \u21a9\ufe0e\n\n  7. Yes, you could pay with Bitcoin but don't think that's private. \u21a9\ufe0e\n\n### Keep Reading\n\n  * Next: First impressions of Bluesky's AT Protocol\n  * Previous: Self-Driving Vehicles, Monoculture, and You\n\n## More from Educated Guesswork\n\nTech, tech policy, and sometimes running by Eric Rescorla. Subscribe to the\nnewsletter for more like this:\n\n### Recent Posts\n\n  * How to manage a quantum computing emergency 16 Apr 2024 networking security post-quantum\n  * Design choices for post-quantum TLS 30 Mar 2024 networking security post-quantum\n  * Sean O'Brien 100K Race Report (2024) 13 Mar 2024 running race report\n  * A hard look at Certificate Transparency: CT in Reality 25 Dec 2023 privacy crypto security\n  * A hard look at Certificate Transparency, Part I: Transparency Systems 13 Dec 2023 privacy crypto security transparency\n\nFull archives ...\n\nSubscribe to the newsletter for more like this:\n\n", "frontpage": false}
