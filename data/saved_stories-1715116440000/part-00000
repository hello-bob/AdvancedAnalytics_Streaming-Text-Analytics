{"aid": "40286632", "title": "SecureDrop Protocol", "url": "https://securedrop.org/news/introducing-securedrop-protocol/", "domain": "securedrop.org", "votes": 22, "user": "Zezima", "posted_at": "2024-05-07 15:12:56", "comments": 0, "source_title": "Introducing SecureDrop Protocol", "source_text": "Introducing SecureDrop Protocol\n\nSkip to content\n\n# Have a document to share?\n\n## You are not anonymous while using this browser!\n\nHere's what you need to do to download Tor Browser to be anonymous online:\n\n  1. Go to https://www.torproject.org.\n  2. Download and install Tor Browser.\n  3. Launch Tor Browser and return to this site. You are now anonymous online.\n\n# Your Tor security settings are too low!\n\n## Set your Tor security level to \"Safest\" for maximum protection\n\n  1. Click the shield icon in the browser toolbar\n  2. Click Advanced Security Settings\n  3. Select Safest and close the Preferences tab\n  4. Refresh the page\n\n# Have a document to share?\n\n## Follow these steps to protect your anonymity:\n\n  1. Choose a safe location, not a work computer.\n  2. Download the desktop version of Tor Browser from https://www.torproject.org/\n  3. Launch Tor Browser and return to this site. You are are now anonymous online.\n\n## Interest Article\n\n# Introducing SecureDrop Protocol\n\nMay 6, 2024\n\nThis blog post is a part of a series about our research toward the next\ngeneration of the SecureDrop whistleblowing system. If you haven\u2019t been\nfollowing along, check out our previous post for some recommended context.\n\nHere, we present a proposed end-to-end encryption protocol for a future\nversion of SecureDrop server, accompanied by a brief discussion of various\naspects of the protocol and our next steps.\n\n## Protocol overview\n\nWe present a proof-of-concept protocol with the following core properties,\nwhich are derived from the research and threat modeling concerns previously\ndiscussed:\n\n  1. No accounts, and therefore no user authentication;\n  2. No message flow metadata, meaning messages can\u2019t be linked together, and different types of messages are indistinguishable from one another;\n  3. No changes in server state are observable externally;\n  4. No ciphertext collection or information leaks via trial decryption \u2013 a given recipient receives pertinent ciphertext only.\n\nThe protocol has a simple API with only three endpoints: send, fetch, and\ndownload. Sources\u2019 and journalists\u2019 requests to these endpoints are structured\nidentically, to make them harder for a compromised server or network adversary\nto distinguish. The server\u2019s response is unique for each request, to avoid\nleaking information about server state.\n\nIt uses well-established cryptographic primitives (currently libsodium for\nproof-of-concept purposes), achieving end-to-end encryption and one-way\nforward secrecy for messages flowing from source to journalist. The server has\naccess to minimal metadata, theoretically opening the door to deployment in\nadversarial environments.\n\nAlong with this blog post, we\u2019re also publishing:\n\n  * A proof-of-concept GitHub repository that demonstrates the end-to-end protocol and documents how it works;\n  * And a preliminary audit, which also contains a concise summary of the protocol.\n\nThis is proof-of-concept code and is not intended for production use. The\nprotocol details are not yet finalized.\n\n## Discussion\n\nLet\u2019s contextualize the four notable properties of the SecureDrop Protocol as\nenumerated above.\n\nThe first property arises from the desire to maximize plausible deniability\nfor the source in a variety of situations, including repeated snapshotting of\nthe server. The motivation for the second property is evident, but the\nimplementation is less trivial: it\u2019s one thing to conceal a sender, but how\ndoes a server deliver a message to an unknown recipient? One approach is trial\ndecryption \u2014 deliver all ciphertext to everyone, and valid recipients will\ndetermine locally which messages belong to them based on what their own secret\nkeys can decrypt. But besides being inefficient, this would also introduce an\ninformation leak: it would allow anyone to constantly monitor the server state\nand know when messages are added and deleted, observe message upload patterns,\nand so on. In the context of a relatively low-traffic self-hosted system, this\nwould represent a significant metadata leak, thus the need for our third\nproperty.\n\nFinally, one of our additional goals is a graceful degradation of security\nproperties, in case of different degrees of user or server compromise.\nAllowing anyone on the internet to observe ciphertext would allow for \u201charvest\nnow, decrypt later\u201d attacks, so the fourth property reflects the need to guard\nagainst such possibilities.\n\n### Comparison of messaging protocols\n\n1\\. While there isn\u2019t a single standard library, the implementation is\nstraightforward. 2. New iteration of the research focuses on groups. 3.\nSecureDrop Protocol does not preclude scalability, but scaling to mass\nadoption level (i.e. millions of users) is a nonrequirement for our purposes.\n\nThe following is a highly simplified comparison of real-world message delivery\napproaches.\n\n#### Trial decryption\n\nTrial decryption is a simple way to conceal recipient information. Payloads\nare encrypted for a given recipient, which in turn has full visibility of all\nthe payloads in the system. As the name suggests, a recipient will discover\nwhich messages belong to them by trying to decrypt all the messages they\nreceive.\n\nBenefits to this approach include symmetry among user traffic (all users\ndownload all payloads) and lack of account creation requirement. Limitations\ninclude the lack of scalability, the information leak mentioned above, and the\nability for an arbitrary attacker to collect payloads/ciphertext. This\napproach would satisfy requirements 1 and 2 (lack of accounts, lack of message\nflow metadata), but not 3 and 4 (externally-observable server state, bulk\nciphertext collection).\n\n#### Signal Protocol\n\nSignal relies on accounts for both message submission and delivery. Only\nauthenticated users can submit messages, and recipients must be specified\noutside the encrypted payload in order for the server to deliver the pertinent\npayloads at the next recipient login and fetch.\n\nThis message delivery approach has high delivery reliability, and is resource-\nefficient for the recipient, since only pertinent payloads are being\ndownloaded and decrypted, but it would not support our transition towards a\nless trusted server. It satisfies properties 3 and 4 (no externally-observable\nserver state changes, no bulk ciphertext collection), but not 1 and 2\n(accounts, message flow metadata).\n\n#### Oblivious Message Detection/Retrieval (OMD/OMR)\n\nOblivious Message Detection and Retrieval is a newer message delivery\nmechanism aimed at concealing the recipient and addressing the scalability\nissues of trial decryption by, in very broad terms, mixing pertinent and non-\npertinent payloads, and using one or more \u201cdetector\u201d servers to heuristically\ngroup, as well as distinguish, pertinent and non-pertinent content for a given\nuser based on the \u201cclues\u201d assigned to each payload. (The idea of\ndetecting/delivering messages in a way that makes them differentiable only by\nthe receiver is an active research area; see also Fuzzy Message Detection.)\n\nFuzzy message delivery is less feasible for small-scale systems like\nSecureDrop, where a burdensome level of decoy traffic would be required. In\naddition, OMR uses homomorphic encryption and other constructs that, at the\ntime of writing, are relatively new, and pose some design challenges. The\ncombination of the protocol's complexity and the bleeding-edge nature of some\nof the protocol's components gave us pause, although research in this area,\nparticularly that focused on group messaging, is promising.\n\n#### SecureDrop Protocol\n\nAs with OMR, in the SecureDrop Protocol a sender sends the payload and a\n\u201cclue\u201d without any authentication. The recipient anonymously asks the server\nfor clues, and the server serves both clues and decoys on every request. Every\ntime a message-fetching request is made to the server, the response contains a\nnew combination of clue and decoy ciphertext. Since every request returns a\ndifferent response, and since the ciphertext is indistinguishable without\nbeing able to decrypt one or more of the clues, individual requests do not\nleak information about server state changes.\n\nMessage-fetching is a two-step operation. The recipient requests clues, and\nattempts trial decryption on them. For each successfully-decrypted clue, the\nrecipient discovers a message_id. The message_id is a cryptographically\nunguessable value generated by the server upon message submission and kept\nprivate from all other parties. When an anonymous user discovers a message_id,\nthey are able to fetch the corresponding message payload from the server. This\ntwo-step process is an optimization-related implementation detail, not a\nsecurity measure.\n\n### SecureDrop Protocol in detail\n\nUnderstanding SecureDrop Protocol\u2019s message retrieval mechanism requires a\nbasic understanding of classical Diffie-Hellman key agreement. In particular,\nwe take advantage of the notable properties that key agreement is commutative\nand can be extended to any number of parties.\n\nAsynchronous three party Diffie-Hellman between sender, server, and recipient\n\nThis diagram shows how the recipient of a message can agree with the server on\na shared key K without learning anything about the state of the server \u2013 while\npreventing the server from knowing whether the recipient is indeed the\nintended one. Every K is obtained using: long-term key material, which later\nallows the correct recipient to detect their pertinent messages; per-message\nephemeral key material, which introduces unlinkability between messages\naddressed to the same recipient; and per-request ephemeral key material via\n\u201cremixed\u201d clues, which provides unlinkability between message-fetching\nrequests, since the clues are transformed before every request.\n\nAs shown in the next diagram, this scheme allows the server to obliviously\nencrypt and transfer some information using symmetric key K, without knowing\nif the requesting recipient will be able to decrypt it.\n\nDetail of the oblivious transfer of a message_id between the server and a\nrecipient\n\nThe material that is obliviously-transferred is the message_id, a securely\nrandom, unguessable value that the server generates upon message submission.\nConceptually, it can be thought of as a server-side message uuid. Its main\npurpose is to keep clue sizes small, rather than encrypting and remixing full\nmessage payloads.\n\nLeveraging the commutativity of multi-party Diffie-Hellman to achieve\nunlinkability between requests is an uncommon application. We credit this\ncontribution to former SecureDrop team member Michael Z, who resolved what was\na multi-month sticking point in our research.\n\nSample visualization of five fetch attempts from two valid and three invalid\nrecipients, from a server containing 3 messages (values are symbolic)\n\nWhy is the server \u201cuntrusted\u201d if it generates secret key material? The server\nis \u201cuntrusted\u201d in the sense that it should learn nothing about users and\nmessages besides what is inherently observable from its pattern of requests,\nand it should not have access to sensitive metadata, or sender or receiver\ninformation. What the server must know are ciphertext payloads and associated\nclues that need to be stored. In this regard, the server is still a\n\u201cprivileged\u201d asset that should not be queryable by anyone on the internet.\nThat is why the server contributes with an ephemeral key: to hide its state\nand thus render all requests unlinkable to any change of such state.\n\n### SecureDrop Protocol: encryption properties\n\n#### Message retrieval symmetry despite source-journalist asymmetry\n\nUntil now, we have commonly used the terms sender and recipient to indicate a\nrole that a user can have. In classical messaging applications, all users can\nboth receive messages and initiate conversations. In whistleblowing\napplications, the anonymized party (source) initiates communication with the\ntrusted party (journalist). Our previous blog post outlines the difference in\ntheir endpoint requirements in detail, and describes the limitations on the\ntype of key material that a source can have.\n\nSo, while both journalists and sources will use the same message retrieval\nmechanism and the same submission mechanism (and in practice, the same API\nendpoints), and are treated indistinguishably from the server\u2019s perspective,\ntheir key setup is inherently different. This difference of roles and setup\nhas a significant impact on the encryption properties we can achieve,\nespecially in three areas: forward secrecy, participant authentication, and\ndeniability.\n\n#### Forward secrecy: It\u2019s imperfect\n\nForward secrecy requires ephemeral keys, implying an evolving state with some\nnon-predictable, non-deterministic source of entropy. Forward secrecy requires\nthat both parties use per-message ephemeral keys, and is commonly achieved by\nperiodically re-generating secret-key material and then discarding it, like an\nautomatic key-rotation procedure. Our design constraints allow for source-to-\njournalist forward secrecy, by rotating some journalist encryption key, but\nnot vice versa: for usability reasons, we do not want to rotate a source\npassphrase, and we cannot add non-deterministic key material on the source\nside, since we cannot store it anywhere. We consider the anonymity of the\nsource a higher priority than the confidentiality of the material, so under\nthese circumstances we accept this \u201cone-way\u201d form of forward secrecy.\n\n#### Participant authentication\n\nConsider a simple Diffie-Hellman key-agreement used with per-message ephemeral\nkeys used for symmetric message encryption. A Diffie-Hellman key agreement is\nperformed between the secret part of the per-message key and the public\ncomponent of the recipient.\n\nThis kind of key agreement is unauthenticated: the recipient has no implicit\nor explicit proof that a particular sender sent that public key and\nciphertext. This does not matter for a \u201cfirst contact\u201d message, which by\ndefinition comes from an anonymous/unknown party, but for ongoing\nconversations, some measure of participant authentication is required \u2013\nessentially, to ensure that the source who began the conversation is indeed\nthe one who is continuing it.\n\nThe question of participant authentication is an open problem that is\ninterlinked with deniability. We see several fairly straightforward ways of\naddressing it; more discussion can be found here.\n\n#### Deniability for sources\n\nThere are multiple layers at which SecureDrop seeks to create deniability:\nforensic deniability on a source\u2019s own machine; forensic deniability on the\nserver of the existence of a given source; and message-level cryptographic\ndeniability.\n\nThe first forensic deniability property is discussed at length in our previous\nposts and is orthogonal to the protocol; broadly, we satisfy it by avoiding\nwriting to disk on the source\u2019s machine. The second type of forensic\ndeniability is served by the lack of server-side accounts; the only way to\nprove that a given party exists is to gain ciphertext addressed to them (a\npending message) along with their key material.\n\nConversation-level and message-level deniability require a more detailed\ndiscussion.\n\nIn cryptographic terms, deniability is often called repudiation, of which\nparticipation repudiation and message repudiation are two forms. Repudiation\nand authentication are both important security principles, and yet, in some\nways they appear at odds with one another: how can a protocol offer both\nauthentication and the ability to deny sending a message or being part of a\nconversation?\n\nThe Signal Protocol does offer both repudiation attributes and implicit\nparticipant authentication under certain conditions, via a clever use of\nmultiple Diffie-Hellman key exchanges. Broadly, the implicit authentication\ncomes from the use of long-term identity keys, while the deniability comes\nfrom the combination of approximately-discoverable public keys (via phone\nnumber/username, on Signal\u2019s servers) and the idea that, while both parties\nmust agree on a shared key to facilitate their conversation, neither party\nmust sign their individual messages. Hypothetically, a conversation between\ntwo parties could be forged by one of the parties, providing the other with a\nmeasure of deniability.\n\nBy contrast, the SecureDrop Protocol cannot provide conversation-level\nrepudiation in cases where an ongoing source-journalist conversation is\ndesired. This is because, while journalist public key material can and must be\npublicly discoverable so that anonymous sources can contact them, sources do\nnot publish their public key material, and must attach it in their first-\ncontact message so that journalists can reply, proving their participation in\nat least this initial message.\n\nSecureDrop Protocol could theoretically support two modes: a true \u201cdead drop\u201d\nmode from a source that never intends to return or receive replies, and a\nconversational mode, in which the source expects to return and continue\ncorrespondence. In the former, the source achieves full deniability. In the\nlatter, which is the more typical use-case, individual message repudiation can\nbe achieved (as can participant authentication, mentioned above), but\nparticipation repudiation cannot. This issue is an area of ongoing research.\n\n#### Putting it all together: message-fetching and encryption\n\nThe following is a simplified illustration of the message-fetching and\nencryption in the SecureDrop Protocol. (Ephemeral keys have been omitted for\nillustrative purposes). The full protocol diagram can be found on GitHub.\n\n### Cryptographic primitives\n\nThe proof-of-concept implementation uses libsodium for both key-agreement and\nsymmetric encryption. That means, as of now, that our DH exchanges are powered\nby X25519 and our authenticated symmetric encryption is powered by XSalsa20\nand Poly1305 MAC.\n\n#### Post-quantum security?\n\nElliptic-curve Diffie-Hellman is not considered quantum-safe. There are\nvarious key encapsulation mechanisms we could make use of that are appropriate\nfor encryption, however, we have not yet found a post-quantum-secure solution\nfor the message-fetching mechanism in the protocol, which requires the\ncommutative properties of multi-party ECDH discussed above.\n\nThe multi-party mechanism we describe is used to protect anonymized metadata\nfrom leaking information about the state of the server over time, similar to a\nnetwork-level correlation attack. One possibility is a hybrid model where\nmessages themselves (including their sender information and other metadata)\nare encrypted in a quantum-safe manner, while the message-retrieval mechanism\nremains usable with less future-proofing.\n\nThat said, this protocol will not transition to production-readiness until a\nthorough post-quantum security assessment has taken place.\n\nPost-quantum readiness is an open research topic that we do not have the\nresources to address alone; we are grateful for the offers of assistance with\npost-quantum readiness that we have received, and we welcome additional\ncollaboration in this area!\n\n### Preliminary audit\n\nIn November 2023, we engaged cryptographic researcher Michele Orr\u00f9 for a\npreliminary audit of the protocol and some of our claimed security properties,\nwith a focus on the server state hiding and message unlinkability. The full\nreport is available here, and a preliminary discussion of the findings can be\nfound on GitHub.\n\n## Next steps\n\nAstute readers will have wondered where the client side of this protocol takes\nplace. We previously discussed the problem of browser-side encryption in\n\u201cAnatomy of a Whistleblowing System\u201d, and we\u2019ll have more to say on this topic\nsoon.\n\nLater this year, we also expect to have the results of ongoing work on\nformally modeling the SecureDrop protocol, proving its security properties,\nand finalizing the specification for audit and publication.\n\nIn the meantime, we want to invite feedback from the security and cryptography\ncommunity on this research. You can join our discussion list, write to us\nprivately at <securedrop@freedom.press>, or get involved on GitHub.\n\nIf you have expertise in post-quantum/quantum-resistant cryptography, we\u2019d\nespecially like to hear from you!\n\n## Acknowledgments\n\nThis research has been funded by Freedom of the Press Foundation (FPF) and is\nbeing led by SecureDrop team member Giulio B. Davide TheZero and smaury from\nsecurity firm Shielder SpA have partnered in the research effort. The audit of\nour proposed framework was conducted by Michele Orr\u00f9.\n\nWe\u2019d like to acknowledge Michael Z for their core contributions to this work,\nboth as a SecureDrop team member and as an independent contributor.\n\nWe would also like to thank the following people:\n\nStuart Haber Jennifer Helsby David Liu Olivia Murat Guillermo Pascual P\u00e9rez\nPaul R\u00f6sler Eleanor Saitta Jacob Young\n\n## Appendix\n\n### Additional resources and links\n\n  * Lua server demonstrating another example SecureDrop Protocol implementation\n  * Slide deck from SecureDrop presentation on deniability\n  * Audit report\n  * Original proof-of-concept repository based on the Signal Protocol\n\n### Timeline\n\n  * October 2020: First commit in https://github.com/freedomofpress/signal-protocol\n  * November 2021: Working demo of https://github.com/freedomofpress/securedrop-signal-poc\n  * January 2022: Internal open discussion on the code integrity problem; JavaScript discussion and necessary steps for any end to end encryption\n  * July - October 2022: Various team meetings, discussion advances\n  * January - February 2023: Initial proof-of-concept development with Shielder, first external feedback requests\n  * October 2023: Final version of the message delivery protocol\n  * November 2023: Team members participate in IETF; initial outreach to cryptographers\n  * November 2023: Engaged Michele Orr\u00f9 for the audit\n  * January 2024: Audit report, ongoing outreach to and collaboration with cryptographers\n\nReturn to News\n\n## Get support\n\nDonate Contribute\n\nSecureDrop is a project of Freedom of the Press Foundation\n\nSecureDrop release signing key (not for communication)\n\n2359 E653 8C06 13E6 5295 5E6C 188E DD3B 7B22 E6A3\n\nTor address\n\nsdolvtfhatvsysc6l34d65ymdwxcujausv7k5jk4cy5ttzhjoi6fzvyd.onion\n\n", "frontpage": true}
