{"aid": "40259733", "title": "Remix for Next.js Developers, Learn by Example", "url": "https://remixfornextdevs.com/", "domain": "remixfornextdevs.com", "votes": 2, "user": "remorses", "posted_at": "2024-05-04 19:28:39", "comments": 0, "source_title": "Remix for Next.js Developers", "source_text": "Remix for Next.js Developers\n\n# Remix for Next.js Developers\n\nTable of Contents\n\n  * Routes definition\n  * Dynamic route [city].tsx\n  * Catch all routes [...slug].tsx\n  * Route groups (app directory)\n  * Routes with dots (sitemap.xml)\n  * _document.tsx\n  * Layouts (app directory)\n  * getServerSideProps\n  * getServerSideProps with redirect\n  * getServerSideProps notFound\n  * API Routes\n  * useRouter().push\n  * useRouter().replace\n  * useRouter().reload()\n  * useRouter().query\n  * useRouter().asPath\n  * useRouter().back()\n  * useRouter().forward()\n  * dynamic params\n  * getStaticProps\n  * _error.jsx\n  * 400.jsx\n  * useRouter().events\n  * Showing skeleton while loading (app directory)\n  * Dynamic imports\n\n## Routes definition\n\nInstead of using folders and slashes to define routes, you can use dots (.) to\ndefine routes, each dot define a path segment.\n\nNext.js\n\npages/\n\n\u251c\u2500\u2500 _app.tsx\n\n\u251c\u2500\u2500 index.tsx\n\n\u251c\u2500\u2500 about.tsx\n\n\u251c\u2500\u2500 concerts/\n\n\u2502 \u251c\u2500\u2500 index.tsx\n\n\u2502 \u251c\u2500\u2500 trending.tsx\n\n\u2502 \u2514\u2500\u2500 [city].tsx\n\nRemix\n\napp/\n\n\u251c\u2500\u2500 routes/\n\n\u2502 \u251c\u2500\u2500 _index.tsx\n\n\u2502 \u251c\u2500\u2500 about.tsx\n\n\u2502 \u251c\u2500\u2500 concerts._index.tsx\n\n\u2502 \u251c\u2500\u2500 concerts.$city.tsx\n\n\u2502 \u251c\u2500\u2500 concerts.trending.tsx\n\n\u2502 \u2514\u2500\u2500 concerts.tsx\n\n\u2514\u2500\u2500 root.tsx\n\n## Dynamic route [city].tsx\n\nInstead of using square brackets to define dynamic routes, you can use the\ndollar sign with your param name ($city) to define dynamic routes.\n\nNext.js\n\npages/\n\n\u251c\u2500\u2500 _app.tsx\n\n\u251c\u2500\u2500 concerts/\n\n\u2502 \u251c\u2500\u2500 index.tsx\n\n\u2502 \u2514\u2500\u2500 [city].tsx\n\nRemix\n\napp/\n\n\u251c\u2500\u2500 routes/\n\n\u2502 \u251c\u2500\u2500 concerts._index.tsx\n\n\u2502 \u251c\u2500\u2500 concerts.$city.tsx\n\n\u2514\u2500\u2500 root.tsx\n\n## Catch all routes [...slug].tsx\n\nInstead of using three dots to define catch all routes, you can use the dollar\nsign ($) to define catch all routes.\n\nNext.js\n\npages/\n\n\u251c\u2500\u2500 _app.tsx\n\n\u251c\u2500\u2500 posts/\n\n\u2502 \u251c\u2500\u2500 [...slug].tsx\n\n\u2502 \u2514\u2500\u2500 index.tsx\n\nRemix\n\napp/\n\n\u251c\u2500\u2500 routes/\n\n\u2502 \u251c\u2500\u2500 posts.$.tsx\n\n\u2502 \u2514\u2500\u2500 posts._index.tsx\n\n\u2514\u2500\u2500 root.tsx\n\n## Route groups (app directory)\n\nRoute groups exist in Next.js app directory, Remix has them too, if a route\nstarts with a underscore it will be used as an hidden route, useful to define\na layout for a set of routes.\n\nNext.js\n\napp/\n\n\u251c\u2500\u2500 (group)/\n\n\u2502 \u251c\u2500\u2500 folder/\n\n\u2502 \u2502 \u251c\u2500\u2500 page.tsx\n\n\u2502 \u2502 \u2514\u2500\u2500 layout.tsx\n\n\u2502 \u251c\u2500\u2500 page.tsx\n\n\u2502 \u2514\u2500\u2500 layout.tsx\n\n\u251c\u2500\u2500 other/\n\n\u2502 \u2514\u2500\u2500 page.tsx\n\n\u251c\u2500\u2500 layout.tsx\n\nRemix\n\napp/\n\n\u251c\u2500\u2500 routes/\n\n\u2502 \u251c\u2500\u2500 group_.tsx\n\n\u2502 \u251c\u2500\u2500 group_._index.tsx\n\n\u2502 \u251c\u2500\u2500 group_.folder.tsx\n\n\u2502 \u2514\u2500\u2500 other.tsx\n\n\u2514\u2500\u2500 root.tsx\n\n## Routes with dots (sitemap.xml)\n\nYou can escape dots in Remix with [] syntax. This is useful for characters\nlike . and _ that have special meaning in the route syntax.\n\nNext.js\n\npages/\n\n\u251c\u2500\u2500 _app.tsx\n\n\u251c\u2500\u2500 posts/\n\n\u2502 \u251c\u2500\u2500 index.tsx\n\n\u2502 \u2514\u2500\u2500 about.tsx\n\n\u251c\u2500\u2500 sitemap.xml.tsx\n\nRemix\n\napp/\n\n\u251c\u2500\u2500 routes/\n\n\u2502 \u251c\u2500\u2500 posts._index.tsx\n\n\u2502 \u251c\u2500\u2500 posts.about.tsx\n\n\u2502 \u2514\u2500\u2500 sitemap[.xml].tsx\n\n\u2514\u2500\u2500 root.tsx\n\n## _document.tsx\n\nIn Remix, the equivalent of _document.tsx in Next.js is root.tsx.\n\nNext.js\n\n// /pages/_document.tsx\n\nimport { Html, Head, Main, NextScript } from 'next/document'\n\nexport default function Document() {\n\nreturn (\n\n<Html lang='en'>\n\n<Head />\n\n<body>\n\n<Main />\n\n<NextScript />\n\n</body>\n\n</Html>\n\n)\n\n}\n\nRemix\n\n// app/root.tsx\n\nimport {\n\nLinks,\n\nMeta,\n\nOutlet,\n\nScripts,\n\nScrollRestoration,\n\n} from '@remix-run/react'\n\nexport default function Root() {\n\nreturn (\n\n<html lang='en'>\n\n<head>\n\n<Links />\n\n<Meta />\n\n</head>\n\n<body>\n\n<Outlet />\n\n<ScrollRestoration />\n\n<Scripts />\n\n</body>\n\n</html>\n\n)\n\n}\n\n## Layouts (app directory)\n\nIn Remix, you can define layouts in the app directory, the equivalent of\n_app.tsx in Next.js is root.tsx. Each route folder can have a layout too,\nsimply define a component for that folder and use Outlet to render the child\nroutes.\n\nNext.js\n\n// app/posts/layout.tsx\n\nexport default function Layout({ children }) {\n\nreturn <div>{children}</div>\n\n}\n\n// app/posts/[id]/page.tsx\n\nexport default function Page() {\n\nreturn <div>Hello World</div>\n\n}\n\nRemix\n\nimport { Outlet } from '@remix-run/react'\n\n// app/routes/posts.tsx\n\nexport default function Layout() {\n\nreturn (\n\n<div>\n\n<Outlet />\n\n</div>\n\n)\n\n}\n\n// app/routes/posts.$id.tsx\n\nexport default function Page() {\n\nreturn <div>Hello World</div>\n\n}\n\n## getServerSideProps\n\nRemix has loader instead of getServerSideProps, the loader function is a top-\nlevel export in a route module that is used to fetch data for the route. This\nfunction is called on every render, on client side navigation this function\nwill be used to get the json for the next page.\n\nNext.js\n\n// /pages/index.tsx\n\nexport async function getServerSideProps() {\n\nconst data = await fetchData()\n\nreturn { props: { data } }\n\n}\n\nconst Page = ({ data }) => <div>{data}</div>\n\nexport default Page\n\nRemix\n\n// /routes/index.tsx\n\nimport { LoaderFunction, json } from '@remix-run/node'\n\nimport { useLoaderData } from '@remix-run/react'\n\nexport let loader: LoaderFunction = async (request) => {\n\nconst data = await fetchData()\n\nreturn json(data)\n\n}\n\nexport default function Index() {\n\nlet data = useLoaderData<typeof loader>()\n\nreturn <div>{data}</div>\n\n}\n\n## getServerSideProps with redirect\n\nRemix has an utility function called redirect you can return in your loaders,\nnotice that this function simply returns a Response.\n\nNext.js\n\nexport async function getServerSideProps() {\n\nreturn {\n\nredirect: {\n\ndestination: '/home',\n\npermanent: false,\n\n},\n\n}\n\n}\n\nRemix\n\nimport { LoaderFunction, redirect } from '@remix-run/node'\n\nexport let loader: LoaderFunction = async () => {\n\nreturn redirect('/home', { status: 307 })\n\n}\n\n## getServerSideProps notFound\n\nRemix supports throwing responses, similar to what Next.js app directory does,\nwhen you throw a response you can intercept it in a route ErrorBoundary to\nshow a custom message.\n\nNext.js\n\nexport async function getServerSideProps() {\n\nreturn {\n\nnotFound: true,\n\n}\n\n}\n\nRemix\n\nimport { LoaderFunction } from '@remix-run/node'\n\nexport let loader: LoaderFunction = async () => {\n\nthrow new Response('', { status: 404 })\n\n}\n\n## API Routes\n\nRemix has no concept of API routes, just use normal loaders like any other\nroute and return a Response object.\n\nNext.js\n\n// /pages/api/hello.ts\n\nimport { NextApiRequest, NextApiResponse } from 'next'\n\nexport default async function handler(\n\nreq: NextApiRequest,\n\nres: NextApiResponse,\n\n) {\n\nres.status(200).json({ name: 'John Doe' })\n\n}\n\nRemix\n\n// /routes/api/hello.ts\n\nimport { LoaderFunctionArgs, LoaderFunction } from '@remix-run/node'\n\nexport let loader = async ({ request }: LoaderFunctionArgs) => {\n\nconst res = new Response(JSON.stringify({ name: 'John Doe' }))\n\nreturn res\n\n}\n\n## useRouter().push\n\nRemix instead of useRouter has many little hooks unfortunately. One of these\nis useNavigate which is used to navigate to a new route.\n\nNext.js\n\nimport { useRouter } from 'next/router'\n\nexport default function Index() {\n\nconst router = useRouter()\n\nreturn (\n\n<button\n\nonClick={() => {\n\nrouter.push('/home')\n\n}}\n\n>\n\nHome\n\n</button>\n\n)\n\n}\n\nRemix\n\nimport { useNavigate } from '@remix-run/react'\n\nexport default function Index() {\n\nconst navigate = useNavigate()\n\nreturn (\n\n<button\n\nonClick={() => {\n\nnavigate('/home')\n\n}}\n\n>\n\nHome\n\n</button>\n\n)\n\n}\n\n## useRouter().replace\n\nRemix uses navigate with a second options argument.\n\nNext.js\n\nimport { useRouter } from 'next/router'\n\nexport default function Index() {\n\nconst router = useRouter()\n\nreturn (\n\n<button\n\nonClick={() => {\n\nrouter.replace('/home')\n\n}}\n\n>\n\nHome\n\n</button>\n\n)\n\n}\n\nRemix\n\nimport { useNavigate } from '@remix-run/react'\n\nexport default function Index() {\n\nconst navigate = useNavigate()\n\nreturn (\n\n<button\n\nonClick={() => {\n\nnavigate('/home', { replace: true })\n\n}}\n\n>\n\nHome\n\n</button>\n\n)\n\n}\n\n## useRouter().reload()\n\nIn Next.js you can reload with router.reload() or\nrouter.replace(router.asPath). In Remix you can use revalidate from\nuseRevalidator.\n\n> In Remix revalidate loading state is not the same as useNavigation.state,\n> this means if you want to create a progress bar at the top of the page you\n> will also need to use this revalidator state too to show the loading bar\n> during reloads or form submits.\n\nNext.js\n\nimport { useRouter } from 'next/router'\n\nexport default function Index() {\n\nconst router = useRouter()\n\nreturn (\n\n<button\n\nonClick={() => {\n\nrouter.reload()\n\n}}\n\n>\n\nReload\n\n</button>\n\n)\n\n}\n\nRemix\n\nimport { useRevalidator } from '@remix-run/react'\n\nexport default function Index() {\n\nconst { revalidate } = useRevalidator()\n\nreturn (\n\n<button\n\nonClick={() => {\n\nrevalidate()\n\n}}\n\n>\n\nReload\n\n</button>\n\n)\n\n}\n\n## useRouter().query\n\nTo access query parameters in Remix, you can use the useSearchParams hook.\n\n> Remix will not pass params in this object, unlike Next.js.\n\nNext.js\n\nimport { useRouter } from 'next/router'\n\nexport default function Index() {\n\nconst router = useRouter()\n\nreturn (\n\n<button\n\nonClick={() => {\n\nrouter.replace({ query: { ...router.query, name: 'John Doe' } })\n\n}}\n\n>\n\n{router.query.name}\n\n</button>\n\n)\n\n}\n\nRemix\n\nimport { useSearchParams } from '@remix-run/react'\n\nexport default function Index() {\n\nconst [searchParams, setSearchParams] = useSearchParams()\n\nreturn (\n\n<button\n\nonClick={() =>\n\nsetSearchParams((prev) => {\n\nprev.set('name', 'John Doe')\n\nreturn prev\n\n})\n\n}\n\n>\n\n{searchParams.get('name')}\n\n</button>\n\n)\n\n}\n\n## useRouter().asPath\n\nNext.js has asPath to get the current path as shown in the browser. Remix has\nuseLocation, which returns an object similar to the window.location object.\n\nNext.js\n\nimport { useRouter } from 'next/router'\n\nexport default function Index() {\n\nconst router = useRouter()\n\nreturn <div>{router.asPath}</div>\n\n}\n\nRemix\n\nimport { useLocation } from '@remix-run/react'\n\nexport default function Index() {\n\nconst location = useLocation()\n\nreturn <div>{location.pathname}</div>\n\n}\n\n## useRouter().back()\n\nRemix uses the navigate function to go back in the history stack.\n\nNext.js\n\nimport { useRouter } from 'next/router'\n\nexport default function Index() {\n\nconst router = useRouter()\n\nreturn (\n\n<button\n\nonClick={() => {\n\nrouter.back()\n\n}}\n\n>\n\nBack\n\n</button>\n\n)\n\n}\n\nRemix\n\nimport { useNavigate } from '@remix-run/react'\n\nexport default function Index() {\n\nconst navigate = useNavigate()\n\nreturn (\n\n<button\n\nonClick={() => {\n\nnavigate(-1)\n\n}}\n\n>\n\nBack\n\n</button>\n\n)\n\n}\n\n## useRouter().forward()\n\nRemix uses the navigate function to go forward in the history stack.\n\nNext.js\n\nimport { useRouter } from 'next/router'\n\nexport default function Index() {\n\nconst router = useRouter()\n\nreturn (\n\n<button\n\nonClick={() => {\n\nrouter.forward()\n\n}}\n\n>\n\nForward\n\n</button>\n\n)\n\n}\n\nRemix\n\nimport { useNavigate } from '@remix-run/react'\n\nexport default function Index() {\n\nconst navigate = useNavigate()\n\nreturn (\n\n<button\n\nonClick={() => {\n\nnavigate(1)\n\n}}\n\n>\n\nForward\n\n</button>\n\n)\n\n}\n\n## dynamic params\n\nDynamic params in Remix can be accessed both in the loaders and with an hook\nuseParams.\n\nNext.js\n\nimport { useRouter } from 'next/router'\n\nexport function getServerSideProps({ params }) {\n\nreturn { props: { params } }\n\n}\n\nexport default function Index({ params }) {\n\nconst router = useRouter()\n\nreturn (\n\n<div>\n\n{params.name} is same as {router.query.name}\n\n</div>\n\n)\n\n}\n\nRemix\n\nimport { LoaderFunctionArgs, json } from '@remix-run/node'\n\nimport { useParams } from '@remix-run/react'\n\nexport function loader({ params }: LoaderFunctionArgs) {\n\nreturn json({ params })\n\n}\n\nexport default function Index() {\n\nconst params = useParams()\n\nreturn <div>{params.name}</div>\n\n}\n\n## getStaticProps\n\nRemix does not have a direct equivalent to getStaticProps, but you can use\nloader with a stale-while-revalidate cache control header to achieve the same\nbehavior. You will also need a CDN on top of your host to support this feature\nthe same way Next.js on Vercel does.\n\nOne drawback is that you can't create the pages ahead of time to have them\nfast on the first load.\n\nNext.js\n\nexport function getStaticProps({ params }) {\n\nreturn { props: { params } }\n\n}\n\nexport const revalidate = 60\n\nexport default function Index({ params }) {\n\nreturn <div>{params.name}</div>\n\n}\n\nRemix\n\nimport { LoaderFunctionArgs, json } from '@remix-run/node'\n\nimport { useLoaderData } from '@remix-run/react'\n\nexport function loader({ params }: LoaderFunctionArgs) {\n\nreturn json(\n\n{ params },\n\n{\n\nheaders: {\n\n// you will need a CDN on top\n\n'Cache-Control': 'public, stale-while-revalidate=60',\n\n},\n\n},\n\n)\n\n}\n\nexport default function Index() {\n\nconst data = useLoaderData<typeof loader>()\n\nreturn <div>{data.params.name}</div>\n\n}\n\n## _error.jsx\n\nRemix can have an error boundary for each route, this error boundary will be\nrendered when you throw an error in a loader or during rendering\n\nNext.js\n\nfunction Error({ statusCode }) {\n\nreturn (\n\n<p>\n\n{statusCode\n\n? `An error ${statusCode} occurred on server`\n\n: 'An error occurred on client'}\n\n</p>\n\n)\n\n}\n\nError.getInitialProps = ({ res, err }) => {\n\nconst statusCode = res ? res.statusCode : err ? err.statusCode : 404\n\nreturn { statusCode }\n\n}\n\nexport default Error\n\nRemix\n\nimport { useRouteError, Scripts, isRouteErrorResponse } from '@remix-\nrun/react'\n\n// root.tsx\n\nexport function ErrorBoundary() {\n\nconst error = useRouteError()\n\nreturn (\n\n<html>\n\n<head>\n\n<title>Oops!</title>\n\n</head>\n\n<body>\n\n<h1>\n\n{isRouteErrorResponse(error)\n\n? `${error.status} ${error.statusText}`\n\n: error instanceof Error\n\n? error.message\n\n: 'Unknown Error'}\n\n</h1>\n\n<Scripts />\n\n</body>\n\n</html>\n\n)\n\n}\n\n## 400.jsx\n\nRemix does not have a special file for 400 errors, you can use the error\nboundary to show a custom message for 400 errors.\n\n> Notice that the same Remix ErrorBoundary used for runtime errors is also\n> called for 404 errors, you can check if the error is a response error to\n> show a not found message.\n\nNext.js\n\n// pages/400.jsx\n\nexport default function Custom404() {\n\nreturn <h1>404 - Page Not Found</h1>\n\n}\n\nRemix\n\n// root.tsx\n\nimport { useRouteError, Scripts, isRouteErrorResponse } from '@remix-\nrun/react'\n\n// a 404 page is the same thing as an error page, where the error is a 404\nresponse\n\nexport function ErrorBoundary() {\n\nconst error = useRouteError()\n\nreturn (\n\n<html>\n\n<head>\n\n<title>Oops!</title>\n\n</head>\n\n<body>\n\n<h1>\n\n{isRouteErrorResponse(error)\n\n? `${error.status} ${error.statusText}`\n\n: error instanceof Error\n\n? error.message\n\n: 'Unknown Error'}\n\n</h1>\n\n<Scripts />\n\n</body>\n\n</html>\n\n)\n\n}\n\n## useRouter().events\n\nNext.js pages directory has router events, perfect to show progress bar at the\ntop of the screen. Remix can do the same thing with the useNavigation hook.\n\nNext.js\n\nimport { useRouter } from 'next/router'\n\nimport { useEffect, useState } from 'react'\n\nexport default function Index() {\n\nconst router = useRouter()\n\nconst [isNavigating, setIsNavigating] = useState(false)\n\nuseEffect(() => {\n\nrouter.events.on('routeChangeStart', () => setIsNavigating(true))\n\nrouter.events.on('routeChangeComplete', () => setIsNavigating(false))\n\nrouter.events.on('routeChangeError', () => setIsNavigating(false))\n\n}, [router.events])\n\nreturn <div>{isNavigating ? 'Navigating...' : 'Not navigating'}</div>\n\n}\n\nRemix\n\nimport { useNavigation } from '@remix-run/react'\n\nexport default function Index() {\n\nconst { state } = useNavigation()\n\nreturn <div>{state === 'loading' ? 'Navigating...' : 'Not navigating'}</div>\n\n}\n\n## Showing skeleton while loading (app directory)\n\nNext.js support streaming when using the app directory and server components,\nwhen you fetch a page you get the suspense fallback first while the browser\nstreams the rest of the page and React injects script tags at the end to\nreplace the fallbacks with the real components.\n\nRemix can do the same, using the defer utility function. You pass unresolved\npromises and Remix can start render the page and replace the fallbacks with\nthe rendered components later on time.\n\nNext.js\n\n// app/page.tsx using server components\n\nimport { Suspense } from 'react'\n\nasync function ServerComponent() {\n\nconst data = await fetchData()\n\nreturn <div>{data}</div>\n\n}\n\nexport default function Page() {\n\nreturn (\n\n<Suspense fallback={<div>Loading...</div>}>\n\n<ServerComponent />\n\n</Suspense>\n\n)\n\n}\n\nRemix\n\nimport { defer } from '@remix-run/node'\n\nimport { useLoaderData, Await } from '@remix-run/react'\n\nimport { Suspense } from 'react'\n\nexport function loader() {\n\nreturn defer({\n\ndata: fetchData(),\n\n})\n\n}\n\nexport default function Page() {\n\nconst { data } = useLoaderData<typeof loader>()\n\nreturn (\n\n<Suspense fallback={<div>Loading...</div>}>\n\n<Await resolve={data}>{(data) => <div>{data}</div>}</Await>\n\n</Suspense>\n\n)\n\n}\n\n## Dynamic imports\n\nRemix supports the React.lazy function to load components dynamically.\n\nNext.js\n\nimport dynamic from 'next/dynamic'\n\nconst Page = dynamic(() => import('./page'), {\n\nloading: () => <div>Loading...</div>,\n\n})\n\nexport default function App() {\n\nreturn <Page />\n\n}\n\nRemix\n\nimport { lazy, Suspense } from 'react'\n\nconst Page = lazy(() => import('./page'))\n\nexport default function App() {\n\nreturn (\n\n<Suspense fallback={<div>Loading...</div>}>\n\n<Page />\n\n</Suspense>\n\n)\n\n}\n\nWritten by @__morse\n\n", "frontpage": false}
