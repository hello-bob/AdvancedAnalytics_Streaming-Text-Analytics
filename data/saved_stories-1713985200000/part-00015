{"aid": "40143725", "title": "Java Scoped Values: Better ThreadLocals", "url": "https://realjenius.com/2023/11/10/scoped-values/", "domain": "realjenius.com", "votes": 1, "user": "chillax", "posted_at": "2024-04-24 12:48:18", "comments": 0, "source_title": "Java Scoped Values: Better ThreadLocals", "source_text": "Java Scoped Values: Better ThreadLocals \u00b7 RealJenius.com\n\n\u2193Skip to main content\n\n# Java Scoped Values: Better ThreadLocals\n\nNovember 10, 2023\u00b715 mins\n\nLargely motivated by Virtual Threads, a new lightweight thread-local\nalternative has been introduced with the incubation JEP-429 called\nScopedValues. ScopedValue is purpose-built to provide a lighter-weight\nalternative to ThreadLocal that works well with virtual threads and also\nsolves multiple API shortcomings of the twenty-five year old counterpart. This\narticle will dive in to how ScopedValue is different, and how it is made\nfaster under the covers.\n\n## Scoped Value Re-Cap #\n\nOverall, the JEP does an excellent job of explaining the motivational benefits\nof ScopedValue over ThreadLocal. It can briefly be re-summarized with a few\nkey bullet points:\n\n  * Enforce immutability and make the object lifecycle explicit in the API design. This serves to simplify API, reduce risk of errors, and also vastly expands performance optimizations available in the implementation.\n  * Move to a light-weight, processor-friendly implementation that does not pay the same cost of thread locals, and maximizes performance for the normal/expected use-cases, with an eye toward \u201cvirtual Thread\u201d scenarios with many-thousands of live threads as a real possibility\n  * Enable inexpensive/free inheritance of values from parent threads to child threads via the use of a lightweight data sharing model, again considering the virtual thread extended use-cases\n\nBecause of the different API approach, it is explicitly stated that\nScopedValue is not meant to replace all cases for which a ThreadLocal might be\nused; just those common scenarios where thread locals are used for capturing\nper-thread context:\n\n> There are a few scenarios that favor thread-local variables. An example is\n> caching objects that are expensive to create and use, such as instances of\n> java.text.DateFormat. Notoriously, a DateFormat object is mutable, so it\n> cannot be shared between threads without synchronization. Giving each thread\n> its own DateFormat object, via a thread-local variable that persists for the\n> lifetime of the thread, is often a practical approach.\n\nScoped values are a preview feature in Java 20+ (including the latest Java 21\nrelease). As a result it would require setting --enable-preview on the\ncompiler and JVM args.\n\n## API Usage Examples #\n\n### Basic Comparison #\n\nHistorically, if you wanted to have a value that was \u201cglobal to a thread\u201d,\nthread locals provided a convenient way to do that. Here is some example code\nshowing what that might look like:\n\n    \n    \n    private static final ThreadLocal<String> CURRENT_FRUIT = new ThreadLocal<>(); // ... CURRENT_FRUIT.set(\"banana\"); printFruit(); CURRENT_FRUIT.set(\"apple\"); printFruit(); CURRENT_FRUIT.remove(); // ... void printFruit() { System.out.println(\"Fruit: \" + currentFruit.get()); }\n\nThis would print banana, and then apple.\n\nScoped values work similarly from an API perspective, but binding them is now\na far more explicit scope that is controlled by the API. By forcing the use\nthrough a runnable or callable, it ensures that the underlying values are\nproperly disposed at the completion of the scope:\n\n    \n    \n    private static final ScopedValue<String> currentFruit = ScopedValue.newInstance(); // ... ScopedValue .where(currentFruit, \"banana\") .run(() -> printFruit()); ScopedValue .where(currentFruit, \"apple\") .run(() -> printFruit()); // ... void printFruit() { System.out.println(\"Fruit: \" + currentFruit.get()); }\n\nThere are convenient counterparts for the common single-value case with\ncallWhere and runWhere, but I\u2019m showing the more general form to illustrate\nthat creating a series of bindings is distinct to executing scopes of code\nagainst them.\n\n### Nulls #\n\nA major difference between thread locals and scoped values is the handling of\nnull/unset values. ThreadLocal will return null from get() whether it is unset\nor explicitly set to null:\n\n    \n    \n    // Prints 'Fruit: null' printFruit(); CURRENT_FRUIT.set(null); // Prints 'Fruit: null' printFruit();\n\nScopedValue, on the other hand, makes a strong distinction between the two,\nand treats unbound values as an error:\n\n    \n    \n    // Fails with a java.util.NoSuchElementException printFruit(); // Prints 'Fruit: null' ScopedValue.runWhere(CURRENT_FRUIT, null, () -> printFruit());\n\n### Recursion #\n\nScoped values can also be used recursively, which behaves as you would expect:\n\n    \n    \n    ScopedValue.where(CURRENT_FRUIT, \"banana\").run(() -> { printFruit(); ScopedValue .where(CURRENT_FRUIT, \"apple\") .run(() -> printFruit()); printFruit(); });\n\nThis would print out banana, apple, and then banana again. With threadlocals,\nthis would require more manually error-prone code:\n\n    \n    \n    CURRENT_FRUIT.set(\"banana\"); printFruit(); var lastFruit = CURRENT_FRUIT.get(); try { CURRENT_FRUIT.set(\"apple\"); printFruit(); } finally { CURRENT_FRUIT.set(lastFruit); } printFruit(); CURRENT_FRUIT.remove();\n\n### Thread Inheritence #\n\nThe other area where this matters is in thread boundaries. To have thread\nlocals cross thread boundaries, a special variant of the thread local must be\nused, with InheritableThreadLocal. This type will be captured when a thread is\nspawned and carried over to the new thread, but any changes made on either\nthread to the thread local will be independent from each other:\n\n    \n    \n    INHERITABLE_FRUIT.set(\"banana\"); printFruit(); new Thread(() -> { printFruit(); INHERITABLE_FRUIT.set(\"kiwi\"); printFruit(); sleep(2000); printFruit(); }).start(); sleep(1000); printFruit(); INHERITABLE_FRUIT.set(\"apple\"); printFruit();\n\nThis would print as follows:\n\n    \n    \n    banana // from the parent thread banana // from the child thread kiwi // from the child thread banana // from the parent thread apple // from the parent thread kiwi // from the child thread\n\nScoped values, on the other hand, don\u2019t inherit with normal threads. The only\ntime with which scopes values will inherit is with structured concurrency.\nWhile a full illustration of the new structured concurrency APIs is outside\nthe scope of this article, here is an illustration of this same model:\n\n    \n    \n    ScopedValue.callWhere(CURRENT_FRUIT, \"banana\", () -> { printFruit(); try (var scope = new StructuredTaskScope.ShutdownOnFailure()) { scope.fork(() -> { printFruit(); ScopedValue.runWhere(CURRENT_FRUIT, \"kiwi\", () -> { printFruit(); sleep(2000); printFruit(); }); return null; }); sleep(1000); printFruit(); ScopedValue.runWhere(CURRENT_FRUIT, \"apple\", () -> printFruit()); scope.join(); } return null; });\n\nThis would print the same as the thread local example.\n\n## Implementation Details #\n\n### ThreadLocal #\n\nThe JEP discusses briefly the nature of the thread local implementation, but\nlet\u2019s take a deeper dive into the internals.\n\nThread locals are stored directly on each thread as a ThreadLocalMap, which is\nan array-backed map. The map is very basic and meant to be specifically tuned\nfor the use-cases with thread locals:\n\ngraph TD A(Thread) -- threadLocals --> B(ThreadLocalMap) B -- Contains -->\nC(Array of Entry) B -- Grows --> C C --key --> D(key: ThreadLocal<*>) D --\nvalue --> E(value: *) subgraph Internals B C D E end\n\nThe ThreadLocal object itself acts as the logical key in the map. The hashcode\nof the key is used to find a position in the entry array, and collisions are\nhandled by a fairly basic \u201ctry next index\u201d methodology to look for an open\nspot.\n\nAdditionally, the thread local map regularly attempts to expunge stale\nentries; i.e.: those that are no longer associated with any valid value. This\nprocess is triggered in various flows, such as potential resize scenarios as\nwell as when hash collisions occur.\n\nOne of the most notable scenarios with ThreadLocalMap is what happens with\nchild threads. There is a special type of thread local called\nInheritableThreadLocal which is designed to carry thread local state from\nparent threads to child threads. However, per the specification, once carried\ninto a child thread, any changes to the parent thread value do not propagate\nto the child thread, and vice-versa.\n\nThis behavior, combined with the \u201calways mutable\u201d nature of thread locals,\nresults in an unavoidable inefficient implementation of thread locals, as the\nchild thread has no choice than to eagerly copy over the full thread local\nstate at construction time. Consider this expected behavior:\n\n  1. Inheritable thread local in Thread Parent has value \"test\"\n  2. Child thread created/forked from Parent\n  3. Child thread has value \"test\"\n  4. Parent has thread local value re-set to \"test2\"\n  5. Child still has value \"test\"\n\nTo support this, the implementation internally looks like this:\n\ngraph TB A(Parent) -- inheritableThreadLocals --> C(ThreadLocalMap) A --\ncreates --> B(Child) B -- inheritableThreadLocals --> D(ThreadLocalMap) C --\ncopied to --> D C -- Contains --> E(Array of Entry) D -- Contains --> F(Array\nof Entry) C -- Grows --> E D -- Grows --> F E -- key --> G(key:\nThreadLocal<*>) F -- key --> H(key: ThreadLocal<*>) G -- value --> I(value: *)\nH -- value --> J(value: *) subgraph Internals C E G I end subgraph Child\nInternals D F H J end\n\nIn other words, there are two full independent copies of the values stored in\ntwo independent heap arrays in the system. Even if the values are treated\nfully immutably.\n\nWhen thinking about virtual threads and having ten-thousand, or even one-\nhundred-thousand virtual threads in memory, it is hopefully clear how this\ninheritable thread local map copying can create significant memory pressure.\n\n### ScopedValue #\n\nIn comparison to thread locals, scoped values are designed with an optimized\ninternal model in mind. The implementation details are definitely worth\nexploring.\n\nWith scoped values, the primary mechanisms for holding bound values are the\nCarrier and the Snapshot:\n\n  * The ScopedValue<T> object itself behaves like a map key; a unique pointer to the value as set in other references. This is also where the user-facing API typically resides, much like the ThreadLocal object\n  * Carrier objects are a binding of a value to a scoped value at a point in time; effectively a key-value pair. However, carriers are modeled as a linked list (or chain) of bindings, so that when a caller says something like .where(scope1, \"xyz\").where(scope2, \"abc\").run(() -> { ... }), both scope1 and scope2 are in the search path for that specific set of carrier bindings - in effect the contained value is Carrier[scope2 -> \"abc\"] -> Carrier[scope1 -> \"xyz\"]\n  * Snapshot objects are where the carrier objects are saved for a scope execution. Snapshots are created when the run or call is invoked. Each snapshot really represents a \u201ctier of scoping\u201d in the processing. Like carriers, snapshots are modeled as a chain, so as you nest scoping, snapshots will extend from each other.\n\nAll of these descriptions may be confusing, so we can try a diagram combined\nwith code to make it a little easier to understand. Revisiting previous\nexamples, consider this scoped value logic:\n\n    \n    \n    // Snapshot 1: [Carrier B -> \"b2\", Carrier A -> \"a1\"] // Previous: none ScopedValue.where(A, \"a1\").where(B, \"b2\") .run(() -> { // Snapshot 2: [Carrier C -> \"c3\"] // Previous: Snapshot 1 ScopedValue.where(C, \"c3\", () -> { // Snapshot 3: [Carrier D -> \"d5\", Carrier A -> \"a4\"] // Previous: Snapshot 3 ScopedValue.where(A, \"a4\").where(D, \"d5\") .run(() -> doSomething(A.get(), B.get(), C.get(), D.get())); }); });\n\nAs a reminder, at the point of doSomething() being invoked, the scopes values\nwould have these values:\n\n    \n    \n    A=a4 B=b2 C=c3 D=d5\n\nHere is a visualization of this structure:\n\nflowchart TB s3>Snapshot 3] s2>Snapshot 2] s1>Snapshot 1] s3c1([carrier:\nD=d5]) s3c2([carrier: A=a4]) s2c1([carrier: C=c3]) s1c1([carrier: B=b2])\ns1c2([carrier: A=a1]) s0>Empty] s3 -- prev --> s2 s3 -- bindings --> s3c1 s3c1\n-- prev --> s3c2 s2 -- prev --> s1 s2 -- bindings --> s2c1 s1 -- prev --> s0\ns1 -- bindings --> s1c1 s1c1 -- prev --> s1c2\n\nWhen an execution boundary completes, the snapshot (and all carriers) are\n\u201cpopped\u201d, simply by the thread moving back to the prev snapshot.\n\nFrom an implementation perspective, because a Snapshot and the associated\nCarrier objects is an immutable data structure, a snapshot can be freely\nshared across thread boundaries without any risk of corruption nor any need to\ncopy or otherwise secure values for multithreaded reasons.\n\nWith traditional thread locals, every time a new child thread is created, the\ninheritable values are copied to the new thread, but with scoped values it is\njust a pointer to an immutable snapshot; a \u201cprevious\u201d structure in the\nhierarchy. In fact, the only time in which new objects are created in this\nmodel is when new scope executions occur. Changing a scoped value or adding\nadditional scoped values using where results in new carriers and a new\nsnapshot for the duration of that code block executing.\n\n### Fast Lookups #\n\nWhile this immutable hierarchy is a big benefit for sharing scoped binding\nacross threads, further performance benefits are built in to help with this\nwork at a large scale. Notably: traversing the snapshot hierarchy to find\nvalues is relatively slow (as compared to a simple hash-table lookup).\n\nUsing the example above we can revisit how slow it could be, by following a\nnaive traversal for the value for B (the first bound value), while within\nSnapshot3 (the inner-most binding):\n\n  1. Check snapshot 3 carrier 1 for B - no\n  2. Check snapshot 3 carrier 2 for B - no\n  3. Check snapshot 2 carrier 1 for B - no\n  4. Check snapshot 2 carrier 2 for B - no\n  5. Check snapshot 1 carrier 1 for B - no\n  6. Finally: check snapshot 1 carrier 2 for B - yes!\n\nThere are two optimizations in place for this slow traversal. The first is a\nbitmask for all values. Here is a high-level overview of this bitmask:\n\n  * Every ScopedValue has a hash, which is generated randomly (as of Java 21, via a Marsaglia xor shift generator)\n  * A bitmask is computed for any given ScopedValue, which serves as a fixed-size (though, potentially non-unique) fingerprint for the scoped value\n  * Every carrier, when bound, captures the bitmask of the ScopedValue for which it is bound. If the carrier has a previous carrier binding, the bitmask on the carrier is bitwise-or\u2019ed with the bitmask of the previous. This additive nature makes a bitmask representing all carrier bindings\n  * Similarly, every snapshot has a bitmask equal to its head carrier\u2019s bitmask (which may represent several bindings), bitwise-or\u2019ed with any prior snapshot bitmasks\n  * When traversing for a binding, the ScopedValue bitmask is compared to the snapshot\n  * If the mask is not set, the value is known to not be bound in that snapshot\n  * If the mask is set, the snapshot carriers are traversed, checking for a match unless/until the mask does not match\n  * If no carrier is found, the previous snapshot is traversed\n  * This process repeats until the most recent binding is found, or the mask/binding is not found\n\nIn effect, this bitmask acts as a bloom filter, and allows for very efficient\n\u201clikely\u201d binding discovery, but can have false-positives in the case of\nbitmask collisions.\n\nHere is a more concrete example of what this might look like using the example\nfrom above. I\u2019ll use a simplified bit-mask representation for the sake of this\ndiagram, specifically with these bitmasks:\n\n  * A = [1,0,0,1,0,0,0,0]\n  * B = [0,1,0,0,1,0,0,0]\n  * C = [0,0,1,0,0,1,0,0]\n  * D = [0,0,0,0,0,0,1,1]\n\nAs you can see, for this simplified example, all slots are occupied and there\nare no collisions. The important detail to track here is that, in the case of\ncollisions, the lookup logic will simply fall back to the slower model,\nhowever the bit space is ideally large enough and the number of in-use scoped\nvalues is ideally small enough that collisions are quite infrequent.\n\nHere is how this bitmask organization would look in the snapshot hierarchy:\n\nflowchart TB s3>\"Snapshot 3 [1,1,1,1,1,1,1,1] (A+B+C+D)\"] s2>\"Snapshot 2\n[1,1,1,1,1,1,0,0] (A+B+C)\"] s1>\"Snapshot 1 [1,1,0,1,1,0,0,0] (A+B)\"]\ns3c1([\"D=d5 [0,0,0,0,0,0,1,1] (D)\"]) s3c2([\"A=a4 [1,0,0,1,0,0,0,0] (A)\"])\ns2c1([\"C=c3 [0,0,1,0,0,1,0,0] (C)\"]) s1c1([\"B=b2 [1,1,0,1,1,0,0,0] (A+B)\"])\ns1c2([\"A=a1 [1,0,0,1,0,0,0,0] (A)\"]) s0>\"Empty [0,0,0,0,0,0,0,0]\"] s3 -- prev\n--> s2 s3 -- bindings --> s3c1 s3c1 -- prev --> s3c2 s2 -- prev --> s1 s2 --\nbindings --> s2c1 s1 -- prev --> s0 s1 -- bindings --> s1c1 s1c1 -- prev -->\ns1c2\n\nWith this hierarchy it\u2019s clear to see that, while in snapshot 3, we can\nquickly verify that it is likely all the scoped values are set.\n\nThe other component that exists to help traversal performance even more is a\nlazy per-thread cache. Each thread carries a special scopedValueCache (simply\nan Object[]), which has a pre-determined, constant size. The ScopedValue hash\nis used to further facilitate the use of the cache:\n\n  * When storing a value in the cache, attempt a primary slot location or a secondary slot location, computed off of the hash\n  * If the primary slot is available,\n  * For the given hash calculate a primary slot where the scoped value might reside in the cache, and check that location\n  * If the value is not found, calculate a secondary slot where the value might reside\n\nPer the documentation on scoped values themselves, this is all optimized\naround the idea that there might be a lot of threads accessing scoped values,\nbut not very many scoped values (meaning: fewer chances for collisions and\ncache rollovers):\n\n> Scoped values are designed to be used in fairly small numbers. get()\n> initially performs a search through enclosing scopes to find a scoped\n> value\u2019s innermost binding. It then caches the result of the search in a\n> small thread-local cache. Subsequent invocations of get() for that scoped\n> value will almost always be very fast. However, if a program has many scoped\n> values that it uses cyclically, the cache hit rate will be low and\n> performance will be poor. This design allows scoped-value inheritance by\n> StructuredTaskScope threads to be very fast: in essence, no more than\n> copying a pointer, and leaving a scoped-value binding also requires little\n> more than updating a pointer.\n>\n> Because the scoped-value per-thread cache is small, clients should minimize\n> the number of bound scoped values in use. For example, if it is necessary to\n> pass a number of values in this way, it makes sense to create a record class\n> to hold those values, and then bind a single ScopedValue to an instance of\n> that record.\n>\n> For this release, the reference implementation provides some system\n> properties to tune the performance of scoped values.\n>\n> The system property java.lang.ScopedValue.cacheSize controls the size of the\n> (per-thread) scoped-value cache. This cache is crucial for the performance\n> of scoped values. If it is too small, the runtime library will repeatedly\n> need to scan for each get(). If it is too large, memory will be\n> unnecessarily consumed. The default scoped-value cache size is 16 entries.\n> It may be varied from 2 to 16 entries in size. ScopedValue.cacheSize must be\n> an integer power of 2.\n>\n> For example, you could use -Djava.lang.ScopedValue.cacheSize=8.\n>\n> The other system property is jdk.preserveScopedValueCache. This property\n> determines whether the per-thread scoped-value cache is preserved when a\n> virtual thread is blocked. By default this property is set to true, meaning\n> that every virtual thread preserves its scoped-value cache when blocked.\n> Like ScopedValue.cacheSize, this is a space versus speed trade-off: in\n> situations where many virtual threads are blocked most of the time, setting\n> this property to false might result in a useful memory saving, but each\n> virtual thread\u2019s scoped-value cache would have to be regenerated after a\n> blocking operation.\n\n## Summary #\n\nScoped values are a welcome edition to Java that provide a high-efficiency\nthread-local value alternative for a future where there is more virtual thread\nuse, but that also has a much more constrained immutable API that eliminates a\nwhole host of possible bugs due to developer error.\n\n\u2190\u2192 Repairing a Very Corrupt Nix Store July 21, 2023 Why Project Wakefield\nMatters December 15, 2023 \u2192\u2190\n\ncomments powered by Disqus\n\n\u2191\n\n\u00a9 2024\n\nPowered by Hugo & Congo\n\n", "frontpage": false}
