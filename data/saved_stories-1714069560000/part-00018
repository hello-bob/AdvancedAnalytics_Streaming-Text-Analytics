{"aid": "40154988", "title": "Improvements to the GHC-debug terminal interface", "url": "https://well-typed.com/blog/2024/04/ghc-debug-improvements/", "domain": "well-typed.com", "votes": 1, "user": "JNRowe", "posted_at": "2024-04-25 08:38:39", "comments": 0, "source_title": "Improvements to the ghc-debug terminal interface", "source_text": "Improvements to the ghc-debug terminal interface - Well-Typed: The Haskell\nConsultants\n\n# Improvements to the ghc-debug terminal interface\n\n## Matthew Pickering, Zubin Duggal, Hannes Siebenhandl \u2013 Wednesday, 24 April\n2024\n\nall community ghc ghc-debug memory mercury performance profiling well-typed\n\nghc-debug is a debugging tool for performing precise heap analysis of Haskell\nprograms (check out our previous post introducing it). While working on Eras\nProfiling, we took the opportunity to make some much needed improvements and\nquality of life fixes to both the ghc-debug library and the ghc-debug-brick\nterminal user interface.\n\nTo summarise,\n\n  * ghc-debug now works seamlessly with profiled executables.\n  * The ghc-debug-brick UI has been redesigned around a composable, filter based workflow.\n  * Cost centers and other profiling metadata can now be inspected using both the library interface and the TUI.\n  * More analysis modes have been integrated into the terminal interface such as the 2-level profile.\n\nThis post explores the changes and the new possibilities for inspecting the\nheap of Haskell processes that they enable. These changes are available by\nusing the 0.6.0.0 version of ghc-debug-stub and ghc-debug-brick.\n\n## Recap: using ghc-debug\n\nThere are typically two processes involved when using ghc-debug on a live\nprogram. The first is the debuggee process, which is the process whose heap\nyou want to inspect. The debuggee process is linked against the ghc-debug-stub\npackage. The ghc-debug-stub package provides a wrapper function\n\n    \n    \n    withGhcDebug :: IO a -> IO a\n\nthat you wrap around your main function to enable the use of ghc-debug. This\nwrapper opens a unix socket and answers queries about the debuggee process\u2019\nheap, including transmitting various metadata about the debuggee, like the ghc\nversion it was compiled with, and the actual bits that make up various objects\non the heap.\n\nThe second is the debugger process, which queries the debuggee via the socket\nmechanism and decodes the responses to reconstruct a view of the debuggee\u2019s\nHaskell heap. The most common debugger which people use is ghc-debug-brick,\nwhich provides a TUI for interacting with the debuggee process.\n\nIt is an important principle of ghc-debug that the debugger and debuggee don\u2019t\nneed to be compiled with the same version of GHC as each other. In other\nwords, a debugger compiled once is flexible to work with many different\ndebuggees. With our most recent changes debuggers now work seamlessly with\nprofiled executables.\n\n## TUI improvements\n\n### Exploring Cost Center Stacks in the TUI\n\nFor debugging profiled executables, we added support for decoding profiling\ninformation in the ghc-debug library. Once decoding support was added, it\u2019s\neasy to display the associated cost center stack information for each closure\nin the TUI, allowing you to interactively explore that chain of cost centers\nwith source locations that lead to a particular closure being allocated. This\ngives you the same information as calling the GHC.Stack.whoCreated function on\na closure, but for every closure on the heap! Additionally, ghc-debug-brick\nallows you to search for closures that have been allocated under a specific\ncost center.\n\nViewing the cost center stack for a specific list closure\n\nAs we already discussed in the eras profiling blog post, object addresses are\ncoloured according to the era they were allocated in.\n\nEras profiling, each era is given a different colour\n\nIf other profiling modes like retainer profiling or biographical profiling are\nenabled, then the extra word tracked by those modes is used to mark used\nclosures with a green line.\n\nBiographical profiling, used closures are marked green\n\n### A filter based workflow\n\nTypical ghc-debug-brick workflows would involve connecting to the client\nprocess or a snapshot and then running queries like searches to track down the\nobjects that you are interested in. This took the form of various search\ncommands available in the UI:\n\nThe commands now available in ghc-debug-brick\n\nHowever, sometimes you would like to combine multiple search commands, in\norder to more precisely narrow down the exact objects you are interested in.\nEarlier you would have to do this by either writing custom queries with the\nghc-debug Haskell API or modify the ghc-debug-brick code itself to support\nyour custom queries.\n\nFilters provide a composable workflow in order to perform more advanced\nqueries. You can select a filter to apply from a list of possible filters,\nlike the constructor name, closure size, era etc. and add it to the current\nfilter stack to make custom search queries. Each filter can also be inverted.\n\nThe filters available in ghc-debug-brick\n\nWe were motivated to add this feature after implementing support for eras\nprofiling as it was often useful to combine existing queries with a filter by\nera. With these filters it\u2019s easy to express your own domain specific queries,\nfor example:\n\n  * Find the Foo constructors which were allocated in a certain era.\n  * Find all ARR_WORDS closures which are bigger than 1000 bytes.\n  * Show me everything retained in this era, apart from ARR_WORDS and GRE constructors.\n\nHere is a complete list of filters which are currently available:\n\nName| Input| Example| Action  \n---|---|---|---  \nAddress| Closure Address| 0x421c3d93c0| Find the closure with the specific\naddress  \nInfo Table| Info table address| 0x1664ad70| Find all closures with the\nspecific info table  \nConstructor Name| Constructor name| Bin| Find all closures with the given\nconstructor name  \nClosure Name| Name of closure| sat_sHuJ_info| Find all closures with the\nspecific closure name  \nEra| <era>/<start-era>-<end-era>| 13 or 9-12| Find all closures allocated in\nthe given era range  \nCost centre ID| A cost centre ID| 107600| Finds all closures allocated\n(directly or indirectly) under this cost centre ID  \nClosure Size| Int| 1000| Find all closures larger than a certain size  \nClosure Type| A closure type description| ARR_WORDS| Find all ARR_WORDS\nclosures  \n  \nAll these queries are retainer queries which will not only show you the\nclosures in question but also the retainer stack which explains why they are\nretained.\n\n### Improvements to profiling commands\n\nghc-debug-brick has long provided a profile command which performs a heap\ntraversal and provides a summary like a single sample from a -hT profile. The\nresult of this query is now displayed interactively in the terminal interface.\nFor each entry, the left column in the header shows the type of closure in\nquestion, the total number of this closure type which are allocated, the\nnumber of bytes on the heap taken up by this closure, the maximum size of each\nof these closures and the average size of each allocated closure. The right\ncolumn shows the same statistics, but taken over all closures in the current\nheap sample.\n\nA 1-level profile, displayed in ghc-debug-brick\n\nEach entry can be expanded, five sample points from each band are saved so you\ncan inspect some closures which contributed to the size of the band. For\nexample, here we expand the THUNK closure and can see a sample of 5 thunks\nwhich contribute to the 210,000 thunks which are live on this heap.\n\nExpanding the THUNK entry in a 1-level profile\n\nSupport for the 2-level closure type profile has also been added to the TUI.\nThe 2-level profile is more fine-grained than the 1-level profile as the\nprofile key also contains the pointer arguments for the closure rather than\njust the closure itself. The key :[(,), :] means the list cons constructor,\nwhere the head argument is a 2-tuple, and the tail argument is another list\ncons.\n\nA 2-level profile displayed in ghc-debug-brick\n\nFor example, in the 2-level profile, lists of different types will appear as\ndifferent bands. In the profile above you can see 4 different bands resulting\nfrom lists, of 4 different types. Thunks also normally appear separately as\nthey are also segmented based on their different arguments. The sample feature\nalso works for the 2-level profile so it\u2019s straightforward to understand what\nexactly each band corresponds to in your program.\n\n### Other UI improvements\n\nIn addition to the new features discussed above, some other recent\nenhancements include:\n\n  * Improved the performance of the main view when displaying a large number of rows. This noticeably reduces input lag while scrolling.\n  * The search limit was hard-coded to 100 objects, which meant that only the first few results of a search would be visible in the UI. This limit is now configurable in the UI.\n  * Additional analyses are now available in the TUI, such as finding duplicate ARR_WORDS closures, which is useful for identifying cases where programs end up storing many copies of the same bytestring.\n\n## Conclusion\n\nWe hope that the improvements to ghc-debug and ghc-debug-brick will aid the\nworkflows of anyone looking to perform detailed inspections of the heap of\ntheir Haskell processes.\n\nThis work has been performed in collaboration with Mercury. Mercury have a\nlong-term commitment to the scalability and robustness of the Haskell\necosystem and are supporting the development of memory profiling tools to aid\nwith these goals.\n\nWell-Typed are always interested in projects and looking for funding to\nimprove GHC and other Haskell tools. Please contact info@well-typed.com if we\nmight be able to work with you!\n\nContents\n\n  * Recap: using ghc-debug\n  * TUI improvements\n\n    * Exploring Cost Center Stacks in the TUI\n    * A filter based workflow\n    * Improvements to profiling commands\n    * Other UI improvements\n  * Conclusion\n\nContact us\n\n  * info@well-typed.com\n\ninfo@well-typed.com | Company information | Privacy | Cookies | Copyright \u00a9 2008\u20132024 Well-Typed LLP\n\n", "frontpage": false}
