{"aid": "40234169", "title": "Extending Neovim for Blogging: Customizing Neovim", "url": "https://www.jonashietala.se/blog/2024/05/02/customizing_neovim/", "domain": "jonashietala.se", "votes": 1, "user": "lawn", "posted_at": "2024-05-02 09:05:19", "comments": 0, "source_title": "Customizing Neovim", "source_text": "Jonas Hietala: Customizing Neovim\n\n~jonashietala.se\n\n## Extending Neovim for blogging\n\n# Customizing Neovim\n\nMay 2, 2024\n\nThis is part 1 of the Extending Neovim for blogging series.\n\n> Scripting is configuration. Configuration is scripting.\n>\n> TJ DeVries A different take on editing code\n\nI\u2019ve been using Neovim since it forked from Vim almost 8 years ago, and I used\nVim many years before that. I feel quite comfortable with Neovim, and I\u2019ve\ngone down the configuration rabbit hole too many times I\u2019d like to admit, but\nI never dove deeper by writing something truly custom like a plugin.\n\nThat changed when I got inspired by the excellent Developing a Neovim Docker\nPlugin from Scratch where the creator goes through how to extend\ntelescope.nvim in a very pedagogical manner.\n\nI was only planning to make a simple telescope picker... Yet I fell into\nrabbit hole again and ended up implementing some cool features such as:\n\n  1. Browse posts using telescope.nvim.\n  2. Autocomplete post urls, link definitions, and more using nvim-cmp.\n  3. Goto definition.\n  4. Diagnostics.\n  5. Browser preview with auto refresh and scroll.\n\nBecause of my overambitious self, I couldn\u2019t squeeze all these topics into a\nsingle blog post, so I split the post into a series. This first post will go\nthrough how to get started configuring Neovim with a basic setup and some user\ncommands, leaving the more advanced topics for later posts.\n\n## Initial setup\n\nWhile I could develop this as a normal plugin, because it\u2019s for my\npersonalized blogging setup I decided to organize it under nvim/lua/blog:\n\n    \n    \n    lua/blog/ \u251c\u2500\u2500 autocmd.lua \u251c\u2500\u2500 cmp.lua \u251c\u2500\u2500 commands.lua \u251c\u2500\u2500 content.lua \u251c\u2500\u2500 diagnostics.lua \u251c\u2500\u2500 files.lua \u251c\u2500\u2500 goto.lua \u251c\u2500\u2500 init.lua \u251c\u2500\u2500 path.lua \u251c\u2500\u2500 server.lua \u2514\u2500\u2500 telescope.lua\n\nAnd include the relevant code in my init script at init.lua (well, really\nlua/config/init.lua but a white lie to make it easier to grokk doesn\u2019t hurt):\n\n    \n    \n    require(\"blog\")\n\nThis calls lua/blog/init.lua that in turn requires other initialization files:\n\n    \n    \n    require(\"blog.autocmd\") require(\"blog.cmp\") require(\"blog.commands\")\n\nThe above files handles the initial registration, the other files are required\nwhen they\u2019re needed.\n\nFor example, autocmd.lua registers a { \"BufRead\", \"BufNewFile\" } autocommand\nthat establishes a connection to the backend, and registers buffer local\nkeymaps:\n\n    \n    \n    -- This way we include other blog related functionality local path = require(\"blog.path\") local server = require(\"blog.server\") local diagnostics = require(\"blog.diagnostics\") local keymaps = require(\"config.keymaps\") local autocmd = vim.api.nvim_create_autocmd local augroup = vim.api.nvim_create_augroup local blog_group = augroup(\"blog\", { clear = true }) -- Only handle Djot files inside the blog directory -- (at `~/code/jonashietala`). local autocmd_pattern = path.blog_path .. \"*.dj\" -- The callback function is called whenever a `.dj` file -- is read or created. autocmd({ \"BufRead\", \"BufNewFile\" }, { pattern = autocmd_pattern, group = blog_group, callback = function(opts) -- Register buffer local keymaps. keymaps.buf_blog(opts.buf) -- Other initialization go here... end, })\n\nOne quirk of my Neovim config is that I\u2019ve tried to collect all keymaps in one\nfile, where I added some new keymaps for the blog:\n\n    \n    \n    local map = vim.keymap.set -- Called via `init.lua`. M.init = function() map(\"n\", \"gd\", require(\"blog.telescope\").find_draft, { desc = \"Find blog draft\" }) map(\"n\", \"gp\", require(\"blog.telescope\").find_post, { desc = \"Find blog post\" }) -- Lots of other keymaps... end -- Used by the \"BufRead\", \"BufNewFile\" autocommand shown above. M.buf_blog = function(buffer) map(\"n\", \"<localleader>t\", require(\"blog.telescope\").find_tags, { buffer = buffer, desc = \"List tags\" }) map(\"n\", \"<localleader>d\", require(\"blog.goto\").goto_def, { buffer = buffer, desc = \"Goto definition\" }) end\n\nWhere buf_blog is called by the autocommand when editing a blog post.\n\n## Creating and moving posts\n\nOne of the basic features I want is having user commands that simplify my life\na little\u2014like creating a new post.\n\nWhen I write a blog post I start by creating a markup file in drafts/, that\nshould contain a frontmatter with some metadata like so:\n\n    \n    \n    ---toml title = \"Customizing Neovim\" tags = [\"Lua\", \"Neovim\"] series = \"extending_neovim_for_my_blog\" ---\n\nWhen I feel the post is done I \u201cpromote\u201d the draft to a blog post by moving it\nfrom drafts/ to posts/, while adding the release date to the path.\n\nI didn\u2019t do this file manipulation manually\u2014that would be crazy\u2014I had it\nimplemented as an option in the blog generation tool (the blog is a static\nsite, generated by a Rust command-line program).\n\nI think it\u2019s better to to have this kind of manipulation inside Neovim, which\nis a good starting point for our customization.\n\n### User commands\n\nI think implementing them as user commands makes sense\u2014I\u2019ll forget them if I\ncreate I keybinding for them. (I know, I tried.)\n\nI setup user commands in blog/commands.lua:\n\n    \n    \n    local cmd = require(\"util\").create_cmd local files = require(\"blog.files\") -- Create a new draft, promote it to a post, or revert it back to a draft. cmd(\"BlogNewDraft\", files.new_draft) cmd(\"BlogPromoteDraft\", files.promote_curr_draft) cmd(\"BlogDemotePost\", files.demote_curr_post)\n\nIn Neovim you can use vim.api.nvim_create_user_command to create a user\ncommand. Because it takes three arguments, with the third options argument\nonly being empty, I use the helper create_cmd to make it optional:\n\n    \n    \n    -- A module file in lua by convention use an `M` table, -- allowing us to call`require(\"util\").create_cmd(...)`. local M = {} M.create_cmd = function(command, f, opts) opts = opts or {} vim.api.nvim_create_user_command(command, f, opts) end return M\n\n### New draft\n\nCreating a draft should do two things:\n\n  1. Create a file at drafts/some_title.dj under the blog directory.\n  2. Open it and fill in some placeholder data.\n\nCreating a file and opening it can be done using vim.cmd to send the :edit\ncommand.\n\nInserting text from lua was harder to figure out, I tried to search Neovim\u2019s\nhelp with :Telescope help_tags but came up short. In the end I found\nvim.api.nvim_buf_set_lines via Google that can be used to insert lines.\n\nThis is the solution I came up with:\n\n    \n    \n    local path = require(\"blog.path\") local nio = require(\"nio\") local M = {} M.new_draft = function() nio.run(function() -- Prompt for the title of the new draft. local title = nio.ui.input({ prompt = \"Draft title: \" }) -- Create and open the draft for edit (without checking if it exists...) -- `path.blog_path` expands to the path to my blog and `slugify` converts -- a title to a slug by replacing spaces with underscores and removing symbols. local file_path = path.blog_path .. \"drafts/\" .. M.slugify(title) .. \".dj\" vim.cmd(\":e \" .. file_path) -- The text the draft will start with. local template = { \"---toml\", 'title = \"' .. title .. '\"', 'tags = [\"Some tag\"]', \"---\", } -- Insert the text into the current buffer (0) at row 0 (to 0). vim.api.nvim_buf_set_lines(0, 0, 0, true, template) end) end -- Convert a title to a \"slug\" used in the post path and url. -- for example, converts `My title` to `my_title`. M.slugify = function(title) title = title:lower() -- Remove disallowed characters. title = title:gsub(\"[^ a-zA-Z0-9_-]+\", \"\") -- Convert spaces and multiple `_` to a single `_`. title = title:gsub(\"[ _]+\", \"_\") -- Remove dashes and underscores from the beginning and end. title = title:gsub(\"^[ _-]+\", \"\") title = title:gsub(\"[ _-]+$\", \"\") return title end return M\n\nI hope it\u2019s clear what the above code is doing, but I want to call out the\nusage of nvim-nio. It\u2019s a great library that makes asynchronous programming\nsimple in Neovim.\n\nTo start an async task you use nio.run:\n\n    \n    \n    nio.run(function() -- Code here is run async end)\n\nFor this example of creating a new draft async is overkill. Async is required\nfor some other situations and it\u2019s easy to add so I use it liberally, even\nwhen not strictly needed.\n\n### Moving files\n\nIn my blogging setup I store posts under posts/ with the release date in the\npath, and drafts under drafts/. So promoting and demoting is accomplished by\nmoving the file:\n\n  * Promote a draft to a post by moving it from drafts/post_title.dj to posts/2024-04-14-post_title.dj.\n  * Demote a post by moving it from posts/2024-04-14-post_title.dj to drafts/post_title.dj.\n\nInstead of pasting a big chunk of code, let\u2019s go through the most important\nimplementation details:\n\n  1. I want to use the title from the metadata because I\u2019ll often change the title and I want the slug to be updated.\n\nWe can extract the title from the post by shelling out to ripgrep that matches\nagainst a title = \"My title\" line.\n\nnvim-nio provides process.run to run a shell command:\n\n    \n        local proc = nio.process.run(args) proc.stdout.read()\n\nWe can use process.run to run ripgrep to search for the title by passing this\ntable as args:\n\n    \n        { cmd = \"rg\", args = { \"-INo\", \"^title = (.+)$\", path, }, }\n\nBecause we might get multiple matches (such as in this post), we can extract\nit using Lua:\n\n    \n        return output:match('title = \"([^%\"]+)\"')\n\nNot the prettiest solution I\u2019ve come up with.\n\nAnother solution would be to rely on the Rust blog generation tool to provide\nthe title; it would be more robust since the backend properly parses the file.\nI started with this route as one of my goals with customizing Neovim was to\nfamiliarize myself more with Lua. I may move it in the future if the need\narises.\n\n  2. Create the destination path.\n\nFor example a post path is created like this:\n\n    \n        path.blog_path .. \"posts/\" .. os.date(\"%Y-%m-%d\") .. \"-\" .. M.slugify(title) .. \".dj\"\n\n  3. Move the file.\n\nI don\u2019t know what the idiomatic way to rename a file is, or even how to do it\nin Neovim using Lua. But I do know that with :! you can call an external\nprogram... Like mv!\n\nSo here\u2019s one way to rename a file, that works for me on Linux:\n\n    \n        vim.cmd(\":!mv \" .. from .. \" \" .. to) vim.cmd(\":e \" .. to)\n\nBecause everything is done in an async context (inside nio.run) we run into a\nproblem: we can\u2019t call the Neovim API. We\u2019ll get an error like this:\n\n    \n        ...e/tree/.local/share/nvim/lazy/nvim-nio/lua/nio/tasks.lua:95: Async task failed without callback: The co routine failed with this message: vim/_editor.lua:0: E5560: nvim_exec2 must not be called in a lua loop callback stack traceback: [C]: in function 'nvim_exec2' vim/_editor.lua: in function 'cmd' /home/tree/.config/nvim/lua/blog/files.lua:82: in function '_rename' /home/tree/.config/nvim/lua/blog/files.lua:116: in function </home/tree/.config/nvim/lua/blog/file s.lua:106>\n\nThe error to look out for is nvim_exec2 must not be called in a lua loop\ncallback, which I assume means that nio uses the lower level lua loop API for\nits async system.\n\nWhat we need to do is yield to the Neovim scheduler before calling vim.cmd to\nrename the file, which can be done with nio.scheduler() :\n\n    \n        nio.scheduler() -- Now we can call `vim.cmd` and `vim.fn`.\n\n## More functionality\n\nI have some more user commands for creating other types of files; series,\nprojects, and standalones (see /uses) but they work exactly the same as\ncreating drafts. There are a few other commands that I\u2019ll bring up in future\nposts, which will go into more advanced functionality.\n\nThis is part 1 of the Extending Neovim for blogging series.\n\nThis series is ongoing.\n\nView all series\n\nCheck out the source code for the site.\n\n", "frontpage": false}
