{"aid": "40291309", "title": "Show HN: Deriveit.org \u2013 A smart resource to master LeetCode efficiently", "url": "https://deriveit.org/coding/using-recursion-215", "domain": "deriveit.org", "votes": 1, "user": "andrewp123", "posted_at": "2024-05-07 20:50:59", "comments": 0, "source_title": "Using Recursion - DeriveIt", "source_text": "Using Recursion - DeriveIt\n\nDeriveIt\n\nRoadmap\n\nCheat Sheets\n\nPremium\n\nLog In\n\n#\n\nRecursion\n\n# Using Recursion\n\nLesson\n\nYou can use Recursion to solve literally every coding problem, and it's\nextremely useful on tree and graph problems. Recursion is just when you have\nan equation with the same thing on both sides. Here are a couple examples:\n\nf(n) = f(n-1) + f(n-2)\n\nsum(root) = root.val + sum(root.left) +\n\nsum(root.right)\n\nHere we'll solve an example, and you'll learn about the 3 steps you should use\nto solve any problem using Recursion.\n\nProblem: Given the root node of a binary tree root, return the number of nodes\nin the tree.\n\nExample:\n\n=> returns 7\n\nFirst Few Test Cases:\n\nnumNodes(TreeNode.of([1]))\n\n# 1\n\nnumNodes(TreeNode.of([1, 2]))\n\n# 2\n\nnumNodes(TreeNode.of([1, 2, 3]))\n\n# 3\n\n1\\. Recursion\n\nStep 1 is to find a recursive equation.\n\nIn this problem, we're asked to find the the number of nodes in a tree, which\nwe'll call numNodes(root). We want to find a Recursive equation for this,\nwhich just means we want an equation that has numNodes on both sides of it. It\nshould look something like this:\n\nnumNodes(root) = something with\n\nnumNodes(?)\n\nHow do we find this equation? In other words, what is numNodes(root) equal to?\n\nWhen you're coming up with any recursion, you should think \"locally\" near the\noriginal problem. Here, the original problem is on the root node, so we should\nthink about the nodes root.left and root.right. Here's a visual of this:\n\nFrom this image, it's pretty obvious that the number of nodes in the tree is\njust equal to the number of nodes in the left tree, plus the number of nodes\nin the right tree, plus the 1 root node. This is our recursive equation - the\ntwo sides of it are equal, the same way that 1 + 1 = 2.\n\nTypically, you should write the recursion in your code editor and discuss it\nwith your interviewer.\n\n2\\. Base case\n\nStep 2 is to find when the recursive equation stops working. This is called\nthe \"base case\".\n\nThe recursive equation here stops working if we call a null node,\nnumNodes(None). This is because the recursion uses None.left and None.right\nwhich throws an error. We can't use the recursion to find numNodes(None), so\nwe need to manually set what this value is equal to. The number of nodes at a\nnull node is just 0.\n\nnumNodes(None) = 0\n\n3\\. Code\n\nStep 3 is to code up the solution.\n\nTo do this, you should write a function that always returns what numNodes is\nequal to. That way it's guaranteed to be correct. numNodes is always equal to\nthe recursion, unless we're in the base case in which case it's equal to 0.\nHere's the full code:\n\n1\n\n2\n\n3\n\n4\n\n5\n\n6\n\n7\n\ndef numNodes(root):\n\n# base case\n\nif root is None:\n\nreturn 0\n\n# recursion\n\nreturn 1 + numNodes(root.\n\nleft) + numNodes(root.right)\n\nTime Complexity O(n), where n is the number of nodes in the tree. The\nrecursion does roughly 1 operation on every node in the tree. This means it\ntakes n\u22c5O(1) time, which is the same as O(n) time.\n\nSpace Complexity O(n). For now, you don't need to know where this comes from -\nwe'll go over the full details in the next lesson \"Call Stack\". Just know the\ncomputer needs some memory to keep track of the function calls it's making.\n\nMark as Completed:\n\nSubmits:\n\nnumNodes\n\nImports:\n\nTreeNode\n\n1\n\n2\n\n3\n\n4\n\n5\n\n6\n\n7\n\n8\n\n9\n\n10\n\n11\n\n12\n\n\"\"\"\n\n# Here's the definition of a TreeNode:\n\nclass TreeNode:\n\ndef __init__(self, val=None, left=None, right=None):\n\nself.val = val\n\nself.left = left\n\nself.right = right\n\n\"\"\"\n\ndef numNodes(root):\n\n# your code goes here\n\nTest your code to get an output here!\n\nnumNodes(\n\n)\n\nTest your code to get an output here!\n\n##\n\nHelper Functions\n\nUse these functions to debug your code.\n\nThe TreeNode.of function can be used to create an entire binary tree using 1\nline of code. The input is a BFS traversal of the tree including nulls, and\nthe output is the root node of the tree.\n\nTreeNode.of([1, None, 2, None, 3])\n\nWhen you print a TreeNode, it automatically gets printed as \"TreeNode.of(...)\"\n\nThe ListNode.of function lets you create an entire Linked List using 1 line of\ncode. The input is an array, and the output is the head of the Linked List.\n\nListNode.of([1, 2, 3])\n\nOptionally, you can add a loop using the second parameter. Here's an example\nthat loops back to index 1:\n\nListNode.of([1, 2, 3], 1)\n\nWhen you print a ListNode, it automatically gets printed as \"ListNode.of(...)\"\n\nThe GraphNode.of function lets you create an entire Graph using 1 line of\ncode. The input is an Adjacency Matrix, and the output is the first node in\nthe matrix.\n\nHere's how you create the graph below. The function returns the node with\nvalue 'A'.\n\n    \n    \n    GraphNode.of([ ['A', 1, 2], ['B', 2], ['C', 0] ])\n\nWhen you print a GraphNode, it automatically gets printed as\n\"GraphNode.of(...)\"\n\nIf the problem you're solving uses a Class, you can run your own custom test\ncases. To do this, you can provide the functions that you want to call inside\nof an Array, along with their arguments. Here's an example:\n\n[['__init__', 15], ['add', 16], ['get']]\n\nThe above input will run this code:\n\n    \n    \n    c = MyClass(15) c.add(16) c.get()\n\nThe call to the __init__ function must come first and should not be repeated.\n\n##\n\nHelper Functions\n\nUse these functions to debug your code.\n\nThe TreeNode.of function can be used to create an entire binary tree using 1\nline of code. The input is a BFS traversal of the tree including nulls, and\nthe output is the root node of the tree.\n\nTreeNode.of([1, None, 2, None, 3])\n\nWhen you print a TreeNode, it automatically gets printed as \"TreeNode.of(...)\"\n\nThe ListNode.of function lets you create an entire Linked List using 1 line of\ncode. The input is an array, and the output is the head of the Linked List.\n\nListNode.of([1, 2, 3])\n\nOptionally, you can add a loop using the second parameter. Here's an example\nthat loops back to index 1:\n\nListNode.of([1, 2, 3], 1)\n\nWhen you print a ListNode, it automatically gets printed as \"ListNode.of(...)\"\n\nThe GraphNode.of function lets you create an entire Graph using 1 line of\ncode. The input is an Adjacency Matrix, and the output is the first node in\nthe matrix.\n\nHere's how you create the graph below. The function returns the node with\nvalue 'A'.\n\n    \n    \n    GraphNode.of([ ['A', 1, 2], ['B', 2], ['C', 0] ])\n\nWhen you print a GraphNode, it automatically gets printed as\n\"GraphNode.of(...)\"\n\nIf the problem you're solving uses a Class, you can run your own custom test\ncases. To do this, you can provide the functions that you want to call inside\nof an Array, along with their arguments. Here's an example:\n\n[['__init__', 15], ['add', 16], ['get']]\n\nThe above input will run this code:\n\n    \n    \n    c = MyClass(15) c.add(16) c.get()\n\nThe call to the __init__ function must come first and should not be repeated.\n\n", "frontpage": false}
