{"aid": "40105555", "title": "Data as the Abstraction", "url": "https://www.deathbyabstraction.com/Data-as-the-abstraction", "domain": "deathbyabstraction.com", "votes": 1, "user": "throwaway9021", "posted_at": "2024-04-21 13:18:38", "comments": 0, "source_title": "Data as the abstraction", "source_text": "Data as the abstraction\n\n# death by abstraction\n\n# Data as the abstraction\n\n### Why Haskell is so important and what we can learn from it\n\n04 Jan 2024\n\n## part 1: introduction to concept\n\nFair warning: this text won\u2019t really be about Haskell. Many other people have\nalready written praises of Haskell as a language or the experience of using it\nway better than I could have. What I want to talk about is Haskell as a\nconcept, which is to say, use Haskell as an example in order to talk about a\nconcept that would exist regardless of it. Therefore it\u2019s not necessary to\nhave in-depth Haskell knowledge to understand the argument presented here,\nfamiliarity with its basic ideas should be enough.\n\nUsually when people praise Haskell\u2019s type system they talk about how it makes\nsure your code is always correct when you are writing or refactoring it. This\nis of course true and important, but it\u2019s also somewhat of an understatement.\nTruly, the type system is not only something Haskell has, it\u2019s what Haskell\nis. Types are data (it is perhaps even more accurate to say that data has a\ntype and a value and then talk about values, like Rich Hickey did here so\nbrilliantly, but I also don\u2019t think it\u2019s wrong to use data as our core\nconcept, which I will do here), and there is nothing you can do in Haskell\nthat is not data. No logic can be written in Haskell outside of data.\n\nThink about Haskell programming constructs: the often dreaded Haskell monads\nare really just side effects represented as data. Typeclasses are data that\ndefine certain behaviour, yes, but this behaviour, like all behaviour in\nHaskell, is merely a rule, a declaration, a law, which states how one piece of\ndata is transformed into another. This is also what functions are. You can\u2019t\nreally do things in Haskell except for in an appropriately titled do block\nwhich communicates with the outside world. Other than that everything is\ntelling Haskell how to transform one piece of data into another. Higher order\nfunctions, currying and function composition are all natural consequences of\nthis: since a function is just a piece of data it makes sense that we can pass\nit around and combine it with other pieces of data. In other words: we can\ntreat it the same way as we would a variable in mathematics.\n\n## part 2: a very simple practical example\n\nIf you already understand what I mean by \u2018any Haskell program is just a series\nof data transformations\u2019, you can skip this next part, but I do think a very\npractical example can be useful to supplement the somewhat philosophical\nnature of this argument. The example is from a project I did, a semi-random\ntext generator. We will analyse its most important part which is pretty much\njust a text formatter that formats text with random words. First this will be\nexplained in plain english to illustrate the \u2018series of data transformations\u2019\npoint, then the actual code will be included (which more experiences\nHaskellers can feel free to critique).\n\n#### data:\n\nAll the necessary inputs to the program are represented as one data type\ncalled Generator which has three fields. The first field is of type Map, the\nsecond is a FilePath and third is a list of integers.\n\n    \n    \n    data Generator = Generator (Map.Map Int [String]) FilePath [Int]\n\nAt program execution time, these pieces of data could for example be the\nfollowing:\n\n  1. first field is a data structure containing lists of words:\n    \n        wordsMap = Map.fromList[(1, ['short', 'simple', 'stupid'], 2, ['our, 'placeholder', 'useless'], 3, ['reading', 'looking at', 'ignoring'])]\n\n  2. second field is a filename \u2018input.txt\u2019 containing the text:\n    \n        inputText = 'This is a {1} example of {2} text. Thanks for {3} it.'\n\n  3. third field is a list of three integers:\n    \n        randIntList = [1,2,2]\n\nThis list is generated randomly every time the program runs, which is why the\nfinal output is also different every time. While the generation of this list\nand its randomness happen in another part of the program and are out of scope\nof this example, it is important to note its two constraints. Firstly, the\nintegers it contains must be between 0 and 2, as the possible indexes of the\nwords in the lists in wordsMap are only 0,1 and 2 (since all lists of words\nare of length 3). Secondly its length must be 3, because it must be equal to\nthe length of wordsMap itself. Read on to understand why these constraints are\nsuch.\n\n#### transformations:\n\nThese are the transformations used to generate the final output from the above\npieces of data:\n\n  1. Transform inputText into a list of words:\n    \n        listOfWords = ['This', 'is', 'a', '{1}', 'example', 'of', '{2}', 'text.', 'Thanks', 'for', '{3}', 'it'.]\n\n  2. Create a list of tuples from randIntList and its lenght (3) like so:\n    \n        intMap = [(1,1), (2,2), (3,2)]\n\n  3. Create a new Map data structure from intMap and wordsMap by replacing integers in intMap with the words of the same index in a list in wordsMap like so:\n    \n        transformedMap = Map.fromList[(1, 'simple'), (2, 'useless'), (3, 'ignoring')]\n\n  4. Create a new list of words by checking every word in listOfWords to see whether the word needs to be replaced (if it is of the form { + integer + }). If yes, use transformedMap to replace the integer inside the curly brackets with the corresponding word. The result will look like this:\n    \n        finalListOfWords = ['This','is','a','simple','example','of','useless','text.', 'Thanks', 'for', 'ignoring', 'it'.]\n\n  5. Transform finalListofWords back to text:\n    \n        finalText = 'This is a simple example of useless text. Thanks for ignoring it.'\n\n#### full code:\n\n    \n    \n    import System.IO import qualified Data.Map as Map import Data.Char (digitToInt) data Generator = Generator (Map.Map Int [String]) FilePath [Int] generate :: Generator -> IO String generate (Generator inputmap filepath randomnumbers) = do handle <- openFile filepath ReadMode contents <- hGetContents handle let wordslist = words contents let transformedMap = zipWith transformMap (createRandomMap randomnumbers) let finalString = unwords $ map (getreplacementWord $ Map.fromList $ transformedMap $ Map.toList inputmap) wordslist return finalString createRandomMap :: [Int] -> [(Int, Int)] createRandomMap randList = zip [1..length randList] randList transformMap :: (Int, Int) -> (Int, [String]) -> (Int, String) transformMap firstTuple secondTuple = (fst firstTuple, snd secondTuple !! snd firstTuple) getreplacementWord :: Map.Map Int String -> String -> String getreplacementWord map word = case getReplacement word of Nothing -> word Just x -> getItemFromMap map (digitToInt x) getItemFromMap :: Map.Map Int String -> Int -> String getItemFromMap map intItem = case Map.lookup intItem map of Nothing -> \" \" Just x -> x getReplacement:: String -> Maybe Char getReplacement word | chars == 3 = getNumOfReplacement word | otherwise = Nothing where chars = length word getNumOfReplacement :: String -> Maybe Char getNumOfReplacement word | first_char =='{' && third_char == '}' = Just second_char | otherwise = Nothing where first_char = head word second_char = word !! 1 third_char = word !! 2\n\n## part 3: the actual argument\n\nThe above algorithm could also be written in a pretty similar way in many\nother languages, even some non-functional ones. What makes Haskell different\nhowever is that this is the only way in which you can do it. It forces you to\nyes, learn some mathematical concepts, but on a more fundamental level to\nreason about your code only in terms of data and transformations between it.\n\nIn imperative languages, the difference between the simplest and the most\ncomplicated program is that the simplest one is just a procedure: do this,\nthen do this, then this. But the most complicated one is an abstraction:\nalmost always a class and often also a design pattern. In Haskell however,\nboth the simplest and the most complicated possible program are\ntransformations of data, the more complicated one will simply have more\ncomplex data (such as many levels of nested custom types) and more\n(complicated) transformations. Where another language would turn to a design\npattern to implement a solution to a complex problem, in Haskell we would\napproach this by asking ourselves \u2018How can we break this problem down into\nsmaller pieces, then represent them as data?\u2019 and then design our types in a\nway that is conducive to solving the problem (the Generator type designed to\nhelp hold pieces of data needed for text generation is a very simple example\nof exactly that).\n\nBefore arguing which of those approaches is \u2018better\u2019 we must ask ourselves:\n\u2018better\u2019 from which perspective? Because if it\u2019s from the perspective of the\nperson writing code then it\u2019s no surprise that this breeds objections along\nthe lines of \u2018well everyone has their favourite programming language or\nparadigm, stop trying to enforce yours\u2019 and to be fair, that is valid - no one\nshould be forced to work with a technology they don\u2019t like working with. But I\nbelieve people trying to argue some objective superiority of the functional\nparadigm are really arguing that it is better from the perspective of the\nprogram execution. Data is predictable, safe, it cannot break, it has no\nability to influence anything around it. While behaviour-based abstractions\nsuch as classes and design patterns are certainly better than no abstractions\nat all, they need to be implemented exactly correctly to produce the expected\noutcome. There is no way to check at the time of program execution whether an\nimplementation of a class or design pattern actually makes sense semantically\nbeyond being syntactically correct. But when data is the only abstraction, we\ncan do that - and that is exactly what the Haskell compiler does and what its\ntype system is for. It can check the correctness of an abstractions\u2019s internal\nlogic, and that is extraordinarily powerful.\n\nAn even simpler way to put this (and I\u2019m probably not the first one to make\nthis analogy) would be to think of a behaviour-based abstraction as a recipe\nwhile data is just a list of ingredients. While the success of the former\ndepends heavily on the human factor, the latter lays this burden mostly on\nthat which executes the program. And needless to say, a computer is much, much\nless likely to make a mistake than a human is.\n\ncontact@deathbyabstraction.com\n\n", "frontpage": false}
