{"aid": "40112990", "title": "Integrating JWT with Spring Security 6 in Spring Boot 3", "url": "https://www.unlogged.io/post/integrating-jwt-with-spring-security-6-in-spring-boot-3", "domain": "unlogged.io", "votes": 1, "user": "shardullavekar", "posted_at": "2024-04-22 10:32:19", "comments": 0, "source_title": "Integrating JWT with Spring Security 6 in Spring Boot 3", "source_text": "Integrating JWT with Spring Security 6 in Spring Boot 3\n\nBlog\n\nnavigate_next\n\nJava\n\nIntegrating JWT with Spring Security 6 in Spring Boot 3\n\nGaurav Sharma\n\nApril 22, 2024\n\nIn our previous article, we covered the fundamentals of Spring Security\nimplementation for our Spring Boot project. Building on that foundation, this\narticle will shift its focus towards a more advanced topic: integrating JWT\n(JSON Web Token) with Spring Security in our Spring Boot application. This\nwill enable us to enhance our security framework by incorporating robust\nauthentication and authorization mechanisms using JWT.\n\nObjective:To ensure that critical endpoints are accessible only with a valid\nJWT token.In our Spring Boot project, we primarily have two critical REST\nendpoints: one for fetching all employee data, and another for adding new\nemployees, which are secured and necessitates JWT-based authentication for\naccess.\n\nIn our Spring Boot project, we primarily have two critical REST endpoints: one\nfor fetching all employee data, and another for adding new employees, which\nare secured and necessitates JWT-based authentication for access.\n\nWe have made essential endpoints like user registration and login available\nwithout any security. When a user logs in, they receive a JWT (JSON Web\nToken), which must be used for authorization in all subsequent API requests.\n\nUpon completing this article, you will be well-equipped to integrate JWT with\nSpring Security 6 in a Spring Boot 3 project, thereby bolstering your\napplication's security. Additionally, you'll be able to adapt and modify this\nimplementation as your project requirements evolve.\n\n## Introduction\n\n### What is JWT?\n\nJWT, or JSON Web Tokens, are like digital passes that help keep web\napplications secure. When someone logs into an application, the server gives\nthem a JWT.\n\nIt\u2019s like getting a badge that proves who you are every time you come back.\nEach time the user wants to access a secure part of the application, they show\nthis badge, and the server knows it\u2019s safe to let them in.\n\nHere\u2019s why JWTs are so great:\n\n  1. Easy to Manage: They are simple strings of text, making them easy to handle and send between computers and devices.\n  2. All-in-One: Everything the server needs to verify the user is packed into the JWT. This means the server doesn\u2019t have to keep asking a database for information, speeding things up.\n  3. Safe: They can be encrypted and signed, making it hard for unauthorized people to mess with them.\n\nA JWT token typically appears as shown on the left side in the provided image\nbelow:\n\n### Parts of a JWT token:\n\nA JWT consists of three main parts, each separated by a dot (.). Here's an\neasy breakdown:\n\n  1. Header\n\n     * Purpose: The header typically tells us the type of the token, which is JWT, and the algorithm that is used for signing the token, like HMAC SHA256 or RSA.\n     * Example: {\"alg\": \"HS256\", \"typ\": \"JWT\"}\n     * Explanation: This is a simple JSON object that states the JWT is using the 'HS256' algorithm for encryption. It's encoded in Base64Url format to make it URL-safe.\n  2. Payload\n\n     * Purpose: The payload contains the claims. Claims are statements about an entity (typically, the user) and additional data.\n     * Example: {\"sub\": \"1234589670\", \"name\": \"Gaurav Sharma\", \"admin\": true}\n     * Explanation: This JSON object contains information about the user and other metadata. It says that the subject (user) of the JWT has the ID \"1234589670\", the name \"Gaurav Sharma\", and has administrative rights.\n  3. Signature\n\n     * Purpose: The signature is used to verify that the sender of the JWT is who it says it is and to ensure that the message wasn't changed along the way.\n     * How It's Made: To create the signature, you take the encoded header, the encoded payload, a secret, the algorithm specified in the header (like HMAC SHA256), and sign that.\n     * Explanation: For example, if you are using the HMAC SHA256 algorithm, the signature will be created by applying the HMAC SHA256 algorithm to the combined string of Base64Url encoded header and payload, using a secret key.\n\nThese three parts together form the JWT: header.payload.signature. When the\nJWT is sent, it appears as a string of three Base64Url-encoded parts,\nseparated by dots, looking something like this:\neyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c.\n\nThat's essentially what a JWT is made up of and how each part functions.\n\n\ud83d\udca1 Note: JWTs are encoded but not encrypted, making them readable if\nintercepted. Therefore, avoid storing sensitive data like passwords directly\nin JWTs, as anyone with access can decode and extract this information.\n\n\ud83d\udca1 Note: Instead, JWTs should contain only the necessary information required\nfor user identification and session management, such as user ID or username,\nand permissions or roles that help with access control decisions. For securing\nthe integrity and authenticity of the token, it is digitally signed using a\nsecret key known only to the server. Even though the contents can be viewed,\nthe signature helps ensure that the token hasn't been altered after it was\nissued.\n\n### Why JWT?\n\nOne might wonder: if we can simply use a username and password to access\nsecure endpoints in a web application, why then do we opt for using JWT with\nSpring Security?\n\nChoosing JWT (JSON Web Tokens) with Spring Security instead of just using\nusernames and passwords has several benefits, especially for modern web\napplications:\n\n  1. No Need for Constant Check-ins: JWTs contain all the user information right inside them, so servers can verify who you are without having to ask the database every time you make a request. This is great for handling lots of users because it cuts down on database traffic.\n  2. Extra Security: While you still use a username and password to log in, JWT provides a more secure way to keep checking who you are after you're logged in. The tokens are protected and have a built-in expiration time, which helps prevent them from being misused.\n  3. Works Everywhere: JWTs are good at working across different systems and devices. This means that once you're logged in to one part of a system, you can use other parts too without having to log in again.\n  4. Faster: Because your server isn't always asking the database who you are, things can run faster. With JWT, your server just needs to check the token you send with your requests, which speeds things up.\n  5. Carries More Info: JWTs can also include extra details like what permissions you have, which helps the server know what you're allowed to do without having to look it up all the time.\n\nIn simple terms, JWT makes things more secure, quicker, and easier to manage,\nespecially when you have lots of users or need to work across different parts\nof a system. This makes them a strong choice for modern web applications.\n\nIn the case of microservices, where there are multiple servers involved:\n\n\ud83d\udca1 JWTs (JSON Web Tokens) are extensively used in microservices architectures,\nwhere web applications are built with multiple servers handling different\nservices. In such environments, retrieving usernames and passwords from a\nspecific server every time a user makes a request can be inefficient and slow\ndown the system.\n\n\ud83d\udca1 JWTs address this challenge by encapsulating the user's identity and\nauthorization details within a secure token. This token is issued once,\ntypically after the user logs in, and then used for subsequent requests across\ndifferent services. This method eliminates the need to continuously query a\ncentral authentication server or database, thereby streamlining authentication\nprocesses across multiple servers and enhancing overall system performance.\n\nIn a microservices setup, where multiple small services work together, JWT\n(JSON Web Tokens) offer some clear benefits for managing security efficiently:\n\n  * Independent Verification: Each microservice can check who you are on its own using the information in the JWT. There\u2019s no need to keep asking a central server to verify your identity, which cuts down on delays.\n  * Less Network Traffic: Because JWTs carry all needed user info right inside them, there\u2019s no need for services to constantly talk to each other or to a central database to check user details. This reduces network traffic and speeds things up.\n  * Works Across Services: JWTs are great for setups that stretch over different areas or systems. Once you\u2019re logged in and have a JWT, any service within the system can recognize and trust it.\n  * No Memory Needed: JWTs help keep the system simple because services don\u2019t need to remember user sessions. Everything needed is in the JWT, which supports the stateless operation of microservices.\n\nOverall, JWT makes security smoother, quicker, and more scalable in a\nmicroservices architecture, fitting well with the need for each service to\noperate independently yet securely.\n\n### Chapter-0: This article is divided into three sections:\n\n  1. The first section involves developing a basic API to add an employee and retrieve all employees.\n  2. The second section focuses on implementing user-related classes in Spring Security.\n  3. The third section covers the integration of JWT with Spring Security and accesing the critical end points of the project using jwt in header of the request.\n\n### Chapter 1: Building APIs for Employee Management in Spring Boot\n\nChapter 1 offers a basic overview of creating APIs in Spring Boot to add and\nretrieve employees within an employee management system.\n\nEmployee.java\n\n    \n    \n    package com.unlogged.model; import jakarta.persistence.Entity; import jakarta.persistence.GeneratedValue; import jakarta.persistence.GenerationType; import jakarta.persistence.Id; import lombok.AllArgsConstructor; import lombok.Data; import lombok.NoArgsConstructor; @Entity @Data @NoArgsConstructor @AllArgsConstructor public class Employee { @Id @GeneratedValue(strategy = GenerationType.AUTO) private Integer employeeId; private String name; private String email; private String department; private String company; }\n\nExplanation for the above code:\n\nThe Employee class is a Java entity model that represents an employee with\nattributes like ID, name, email, department, and company, and it utilizes\nannotations for automatic database integration and boilerplate code\ngeneration.\n\nEmployeeRepository.java\n\n    \n    \n    package com.unlogged.repo; import com.unlogged.model.Employee; import org.springframework.data.jpa.repository.JpaRepository; public interface EmployeeRepository extends JpaRepository<Employee, Integer> { }\n\nExplanation for the above code:\n\nThe EmployeeRepository interface provides automatic CRUD operation methods for\nEmployee objects using Spring Data JPA.\n\nEmployeeService.java\n\n    \n    \n    package com.unlogged.service; import com.unlogged.model.Employee; import com.unlogged.repo.EmployeeRepository; import org.springframework.stereotype.Service; import java.util.List; @Service public class EmployeeService { private final EmployeeRepository repository; public EmployeeService(EmployeeRepository repository) { this.repository = repository; } public List<Employee> findAll() { return repository.findAll(); } public Employee save(Employee employee) { return repository.save(employee); } }\n\nExplanation for the above code:\n\nThe EmployeeService class provides methods to manage employee data, including\nretrieving all employees and saving a new or updated employee, by utilizing a\nrepository layer.\n\nEmployeeController.java\n\n    \n    \n    package com.unlogged.controller; import com.unlogged.model.Employee; import com.unlogged.service.EmployeeService; import org.springframework.web.bind.annotation.*; import java.util.List; @RestController @RequestMapping(\"/api\") public class EmployeeController { private final EmployeeService service; public EmployeeController(EmployeeService service) { this.service = service; } @GetMapping(\"/employees\") public List<Employee> getAllEmployees() { return service.findAll(); } @PostMapping(\"/employee\") public Employee createEmployee(@RequestBody Employee employee) { return service.save(employee); } }\n\nExplanation for the above code:\n\nThe EmployeeController class provides web endpoints to retrieve all employees\nand create a new employee through HTTP GET and POST requests, respectively,\nusing the EmployeeService.\n\n\ud83d\udca1 Our application is configured to automatically populate the database with\ninitial data at startup, utilizing SQL files named schema.sql and data.sql.\n\nschema.sql\n\n    \n    \n    CREATE TABLE IF NOT EXISTS employee ( employee_id SERIAL PRIMARY KEY, name VARCHAR(255), email VARCHAR(255), department VARCHAR(255), company VARCHAR(255) );\n\nExplanation for the above code:\n\nThis SQL statement creates a new table named employee with columns for\nemployee ID, name, email, department, and company, ensuring the table only\nexists if it hasn't been defined previously.\n\ndata.sql\n\n    \n    \n    INSERT INTO Employee (name, email, department, company) VALUES ('Aarav Kumar', 'aarav.kumar@example.com', 'HR', 'Tech Innovations Pvt Ltd'); INSERT INTO Employee (name, email, department, company) VALUES ('Diya Sharma', 'diya.sharma@example.com', 'Marketing', 'Creative Minds Ltd'); INSERT INTO Employee (name, email, department, company) VALUES ('Rohan Gupta', 'rohan.gupta@example.com', 'Finance', 'Financial Solutions Inc'); INSERT INTO Employee (name, email, department, company) VALUES ('Isha Patel', 'isha.patel@example.com', 'IT', 'Tech Solutions Pvt Ltd'); INSERT INTO Employee (name, email, department, company) VALUES ('Aditya Singh', 'aditya.singh@example.com', 'Operations', 'Manufacturing Corp');\n\nExplanation for the above code:\n\nThese SQL commands insert records into the Employee table, adding new\nemployees with specified names, emails, departments, and companies.\n\napplication.properties\n\n    \n    \n    spring.application.name=EmployeeManagementSystem spring.datasource.url=jdbc:postgresql://localhost:5432/employeeDb spring.datasource.username=postgres spring.datasource.password=12345 spring.jpa.hibernate.ddl-auto=update spring.jpa.show-sql=true server.port=8080 spring.sql.init.mode=always spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.PostgreSQLDialect\n\n### Chapter 2: Implementing User related Classes in Spring Security\n\n\ud83d\udca1 Note: Between Chapters 2 and 3, I've inserted brief comments throughout the\ncode for better clarity, as integrating JWT with Spring Boot and Spring\nSecurity is a heavylifting task.\n\nTo set up our security system, we need to create a user class that includes\nfields such as username and password. This allows us to store user information\nin the database and authenticate users based on these credentials.\n\nHowever, there\u2019s an important aspect to note: Spring Security does not\nautomatically recognize this custom user class. Instead, it works with its\npredefined UserDetails interface.\n\nIn simple terms, UserDetails is a special interface in Spring Security\ndesigned to handle user information in a way that Spring Security can\nunderstand. This means that for Spring Security to work with our custom user\nclass, we need to adapt our class to fit this interface. Essentially, we need\nto convert our user class into one that implements the UserDetails interface.\n\nUser.java\n\n    \n    \n    package com.unlogged.model; import jakarta.persistence.*; import lombok.AllArgsConstructor; import lombok.Data; import lombok.NoArgsConstructor; /** * The UserInfo class represents a user entity in the application. * It is used to store user-related data such as name, password etc. */ @Data @NoArgsConstructor @AllArgsConstructor @Entity @Table(name = \"users\") public class User { @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Integer id; private String userName; private String password; }\n\nExplanation for the above code:\n\nThis code sets up a simple User class to store user information in a database,\nspecifically their ID, username, and password.\n\nimplementing the UserDetails interface provided by spring security:\n\nUserPrincipal.java\n\n    \n    \n    package com.unlogged.model; import org.springframework.security.core.GrantedAuthority; import org.springframework.security.core.authority.SimpleGrantedAuthority; import org.springframework.security.core.userdetails.UserDetails; import java.util.Collection; import java.util.Collections; import java.util.Set; public class UserPrincipal implements UserDetails { /** * */ private static final long serialVersionUID = 1L; String userName = null; String password = null; Set<SimpleGrantedAuthority> authorities; public UserPrincipal(User user) { userName = user.getUserName(); password = user.getPassword(); authorities = Collections.singleton(new SimpleGrantedAuthority(\"USER\")); } @Override public Collection<? extends GrantedAuthority> getAuthorities() { return authorities; } @Override public String getPassword() { return password; } @Override public String getUsername() { return userName; } @Override public boolean isAccountNonExpired() { return true; } @Override public boolean isAccountNonLocked() { return true; } @Override public boolean isCredentialsNonExpired() { return true; } @Override public boolean isEnabled() { return true; } }\n\nExplanation of the above code:\n\nThe UserPrincipal class in the code is a custom implementation of the\nUserDetails interface provided by Spring Security. This class is used to\nintegrate your application's user entities with Spring Security's\nauthentication and authorization mechanisms.\n\nHere\u2019s a breakdown of its functionality:\n\n  * Fields: The class has three main fields - userName, password, and authorities. These represent the user's login credentials and their roles or permissions respectively.\n  * Constructor: The UserPrincipal constructor takes a User object as an argument. It extracts the username and password from this user object, and initializes the user's authorities.\n  * getAuthorities(): This method specifies the roles or authorities granted to the user. In this case, every user is given a single authority of \"USER\".\n  * getPassword() and getUsername(): These methods simply retrieve the password and username from the User instance, respectively.\n  * Account Status Methods: The methods isAccountNonExpired(), isAccountNonLocked(), isCredentialsNonExpired(), and isEnabled() are all overridden to return true. These methods are used by Spring Security to determine if the account is still active, locked, has expired credentials, or is enabled. Returning true from all these methods suggests that in this simple implementation, these checks are not being used to restrict user access.\n\nUserRepo.java\n\n    \n    \n    package com.unlogged.repo; import com.unlogged.model.User; import org.springframework.data.jpa.repository.JpaRepository; import org.springframework.stereotype.Repository; import java.util.Optional; @Repository public interface UserRepo extends JpaRepository<User, Integer> { /** * findByName method is used to retrieve a user by their username. * It returns an Optional of UserInfo, which will be empty if no user is found. */ Optional<User> findByUserName(String userName); }\n\nExplanation for the above code:\n\nThe findByUsername(String username) method in the UserRepo interface is a\nspecialized function that lets you find and retrieve a User based on their\nusername.\n\nUserService.java\n\n    \n    \n    package com.unlogged.service; import com.unlogged.model.User; import com.unlogged.model.UserPrincipal; import com.unlogged.repo.UserRepo; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.security.core.userdetails.UserDetails; import org.springframework.security.core.userdetails.UserDetailsService; import org.springframework.security.core.userdetails.UsernameNotFoundException; import org.springframework.security.crypto.password.PasswordEncoder; import org.springframework.stereotype.Service; import java.util.Optional; /** * UserInfoService provides user-related services including loading user details * and managing user data in the repository. */ @Service public class UserService implements UserDetailsService { @Autowired private UserRepo userRepo; @Autowired private PasswordEncoder passwordEncoder; // Loads a user's details given their userName. @Override public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException { Optional<User> user = userRepo.findByUserName(username); return user.map(UserPrincipal::new) .orElseThrow(() -> new UsernameNotFoundException(\"UserName not found: \" + username)); } // Adds a new user to the repository and encrypting password before saving it. public String addUser(User user) { user.setPassword(passwordEncoder.encode(user.getPassword())); userRepo.save(user); return \"user added successfully\"; } }\n\nExplanation for the above code:\n\nThe UserService class implements the UserDetailsService interface from Spring\nSecurity, providing a method to load user details from the database. This\nensures that the class works seamlessly with Spring Security's authentication\nprocesses.\n\nThe UserService class is responsible for handling user information within a\nSpring Security framework. It includes two main methods:\n\n  1. loadUserByUsername: This method retrieves user details from the database using the provided username. If the user exists, it returns their details wrapped in a UserPrincipal object for Spring Security's authentication processes. If the username isn't found, it throws an exception.\n  2. addUser: This method takes a User object, encrypts the user's password for security using the PasswordEncoder, and saves the updated user to the database. It confirms the addition with a success message.\n\n### Chapter-3:Integrating JWT with Spring Security\n\nTo implement JSON Web Tokens (JWT) for authorization in a Spring Boot Maven\nproject, we need to include specific dependencies in our pom.xml file.\n\n    \n    \n    <dependency> <groupId>io.jsonwebtoken</groupId> <artifactId>jjwt-jackson</artifactId> <version>0.11.5</version> </dependency> <dependency> <groupId>io.jsonwebtoken</groupId> <artifactId>jjwt-api</artifactId> <version>0.11.5</version> </dependency> <dependency> <groupId>io.jsonwebtoken</groupId> <artifactId>jjwt-impl</artifactId> <version>0.11.5</version> </dependency>\n\nExplanation for the above dependencies:\n\n#### 1\\. jjwt-jackson\n\n  * What it does:Integrates the Jackson library with JWT operations, optimizing how your Java application encodes and decodes JSON data within JWTs.\n\n#### 2\\. jjwt-api\n\n  * What it does: Supplies the fundamental classes and interfaces for constructing and validating JWTs, providing the building blocks for JWT functionality in Java.\n\n#### 3\\. jjwt-impl\n\n  * What it does: Provides the actual implementation for the interfaces from jjwt-api, enabling the generation, parsing, and management of JWTs according to your application's security protocols.\n\nOur final pom.xml file should look something like this:\n\n    \n    \n    <?xml version=\"1.0\" encoding=\"UTF-8\"?> <project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\"> <modelVersion>4.0.0</modelVersion> <parent> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-starter-parent</artifactId> <version>3.2.4</version> <relativePath/> <!-- lookup parent from repository --> </parent> <groupId>com.unlogged</groupId> <artifactId>EmployeeManagementSystem</artifactId> <version>0.0.1-SNAPSHOT</version> <name>EmployeeManagementSystem</name> <description>EmployeeManagementSystem</description> <properties> <java.version>17</java.version> </properties> <dependencies> <dependency> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-starter-data-jpa</artifactId> </dependency> <dependency> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-starter-security</artifactId> </dependency> <dependency> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-starter-web</artifactId> </dependency> <dependency> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-devtools</artifactId> <scope>runtime</scope> <optional>true</optional> </dependency> <dependency> <groupId>org.postgresql</groupId> <artifactId>postgresql</artifactId> <scope>runtime</scope> </dependency> <dependency> <groupId>org.projectlombok</groupId> <artifactId>lombok</artifactId> <optional>true</optional> </dependency> <dependency> <groupId>io.jsonwebtoken</groupId> <artifactId>jjwt-jackson</artifactId> <version>0.11.5</version> </dependency> <dependency> <groupId>io.jsonwebtoken</groupId> <artifactId>jjwt-api</artifactId> <version>0.11.5</version> </dependency> <dependency> <groupId>io.jsonwebtoken</groupId> <artifactId>jjwt-impl</artifactId> <version>0.11.5</version> </dependency> <dependency> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-starter-test</artifactId> <scope>test</scope> </dependency> <dependency> <groupId>org.springframework.security</groupId> <artifactId>spring-security-test</artifactId> <scope>test</scope> </dependency> </dependencies> <build> <plugins> <plugin> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-maven-plugin</artifactId> <configuration> <excludes> <exclude> <groupId>org.projectlombok</groupId> <artifactId>lombok</artifactId> </exclude> </excludes> </configuration> </plugin> </plugins> </build> </project>\n\neach dependency included in our pom.xml file:\n\n  * Spring Boot Starter Data JPA: Integrates Spring Data JPA with Spring Boot to simplify database interactions using JPA repositories.\n  * Spring Boot Starter Security: Adds security features like authentication and authorization to your Spring Boot application.\n  * Spring Boot Starter Web: Provides all the necessities for building web applications, including RESTful applications, using Spring MVC.\n  * Spring Boot DevTools: Offers tools for automatic restarts and live reload capabilities to enhance developer productivity.\n  * PostgreSQL Driver: Enables JDBC connectivity to PostgreSQL databases, allowing for data transactions between the app and the database.\n  * Lombok: Facilitates reducing boilerplate code in Java applications by auto-generating getters, setters, constructors, and more.\n  * jjwt-jackson: Provides Jackson JSON processing capabilities to the JJWT library for handling JSON web tokens.\n  * jjwt-api: Offers API support for creating and verifying JSON Web Tokens (JWTs) efficiently.\n  * jjwt-impl: Implements the JJWT API, providing the necessary code to manage JWTs.\n\nNow, we will define classes that will allow us to integrart jwt into our\nsecurity mechanism.\n\n\ud83d\udca1 The JwtService class creates, checks, and validates security tokens (JWTs)\nto help confirm user identities in an application.\n\nJwtService.java\n\n    \n    \n    package com.unlogged.service; import io.jsonwebtoken.Claims; import io.jsonwebtoken.Jwts; import io.jsonwebtoken.SignatureAlgorithm; import io.jsonwebtoken.io.Decoders; import io.jsonwebtoken.security.Keys; import org.springframework.security.core.userdetails.UserDetails; import org.springframework.stereotype.Component; import java.security.Key; import java.util.Date; import java.util.HashMap; import java.util.Map; import java.util.function.Function; //JwtService is responsible for handling JWT (JSON Web Token) operations // such as token generation, extraction of claims, and token validation. @Component public class JwtService { // Secret Key for signing the JWT. It should be kept private. private static final String SECRET = \"TmV3U2VjcmV0S2V5Rm9ySldUU2lnbmluZ1B1cnBvc2VzMTIzNDU2Nzg=\\r\\n\" + \"\"; // Generates a JWT token for the given userName. public String generateToken(String userName) { // Prepare claims for the token Map<String, Object> claims = new HashMap<>(); // Build JWT token with claims, subject, issued time, expiration time, and signing algorithm // Token valid for 3 minutes return Jwts.builder() .setClaims(claims) .setSubject(userName) .setIssuedAt(new Date(System.currentTimeMillis())) .setExpiration(new Date(System.currentTimeMillis() + 1000 * 60 * 3)) .signWith(getSignKey(), SignatureAlgorithm.HS256).compact(); } // Creates a signing key from the base64 encoded secret. //returns a Key object for signing the JWT. private Key getSignKey() { // Decode the base64 encoded secret key and return a Key object byte[] keyBytes = Decoders.BASE64.decode(SECRET); return Keys.hmacShaKeyFor(keyBytes); } // Extracts the userName from the JWT token. //return -> The userName contained in the token. public String extractUserName(String token) { // Extract and return the subject claim from the token return extractClaim(token, Claims::getSubject); } // Extracts the expiration date from the JWT token. //@return The expiration date of the token. public Date extractExpiration(String token) { // Extract and return the expiration claim from the token return extractClaim(token, Claims::getExpiration); } // Extracts a specific claim from the JWT token. // claimResolver A function to extract the claim. // return-> The value of the specified claim. private <T> T extractClaim(String token, Function<Claims, T> claimResolver) { // Extract the specified claim using the provided function final Claims claims = extractAllClaims(token); return claimResolver.apply(claims); } //Extracts all claims from the JWT token. //return-> Claims object containing all claims. private Claims extractAllClaims(String token) { // Parse and return all claims from the token return Jwts.parserBuilder() .setSigningKey(getSignKey()) .build().parseClaimsJws(token).getBody(); } //Checks if the JWT token is expired. //return-> True if the token is expired, false otherwise. public Boolean isTokenExpired(String token) { // Check if the token's expiration time is before the current time return extractExpiration(token).before(new Date()); } //Validates the JWT token against the UserDetails. //return-> True if the token is valid, false otherwise. public Boolean validateToken(String token, UserDetails userDetails) { // Extract username from token and check if it matches UserDetails' username final String userName = extractUserName(token); // Also check if the token is expired return (userName.equals(userDetails.getUsername()) && !isTokenExpired(token)); } }\n\nkey methods in the JwtService class:\n\n1\\. generateToken: Makes a secure token for a user that includes their\nusername and how long the token is good for.\n\n2\\. getSignKey: Creates a special key from a secret key to help keep the token\nsafe.\n\n\ud83d\udca1 The secret key in the JwtService class acts like a digital signature for\nsecuring JSON Web Tokens (JWTs). This key is encoded in base64, a method that\ntransforms the key into a string format that's easier to handle in programming\nenvironments. Its primary role is to ensure that the data within the JWT\nhasn't been altered by unauthorized parties. It is crucial to keep this key\nconfidential; if it falls into the wrong hands, someone could create\ncounterfeit tokens, potentially gaining unauthorized access to user data and\nprivileged system functions. This makes maintaining the secrecy of this key\nvital for the security of your application.\n\nA little demo in case you want to generate your own secret key:\n\na useful website for creating a secret key is :\n\nhttps://asecuritysite.com/encryption/plain\n\nDemo for the same:\n\n3\\. extractUserName: Gets the username from a token.\n\n4\\. extractExpiration: Finds out when the token will stop working.\n\n5\\. extractClaim: The extractClaim method in the JwtService class uses a\nfunction passed as a parameter to retrieve a specific claim, such as the\nusername or expiration date, from a parsed JWT token.\n\n6\\. isTokenExpired: Checks if the token has run out of time and is no longer\nvalid.\n\n7\\. validateToken: Ensures the token is still good and matches the right user,\nconfirming it can be used safely for logging in.\n\n\ud83d\udca1 The JwtFilter class checks every incoming request to make sure the user has\na valid login token and sets up their login status if everything checks out.\n\nJwtFilter.java\n\n    \n    \n    package com.unlogged.filter; import com.unlogged.service.JwtService; import com.unlogged.service.UserService; import jakarta.servlet.FilterChain; import jakarta.servlet.ServletException; import jakarta.servlet.http.HttpServletRequest; import jakarta.servlet.http.HttpServletResponse; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.context.ApplicationContext; import org.springframework.security.authentication.UsernamePasswordAuthenticationToken; import org.springframework.security.core.context.SecurityContextHolder; import org.springframework.security.core.userdetails.UserDetails; import org.springframework.security.web.authentication.WebAuthenticationDetailsSource; import org.springframework.stereotype.Component; import org.springframework.web.filter.OncePerRequestFilter; import java.io.IOException; @Component public class JwtFilter extends OncePerRequestFilter { @Autowired private JwtService jwtService; @Autowired private ApplicationContext applicationContext; // Method to lazily fetch the UserService bean from the ApplicationContext // This is done to avoid Circular Dependency issues private UserService getUserService() { return applicationContext.getBean(UserService.class); } @Override protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException { // Extracting token from the request header String authHeader = request.getHeader(\"Authorization\"); String token = null; String userName = null; if (authHeader != null && authHeader.startsWith(\"Bearer \")) { // Extracting the token from the Authorization header token = authHeader.substring(7); // Extracting username from the token userName = jwtService.extractUserName(token); } // If username is extracted and there is no authentication in the current SecurityContext if (userName != null && SecurityContextHolder.getContext().getAuthentication() == null) { // Loading UserDetails by username extracted from the token UserDetails userDetails = getUserService().loadUserByUsername(userName); // Validating the token with loaded UserDetails if (jwtService.validateToken(token, userDetails)) { // Creating an authentication token using UserDetails UsernamePasswordAuthenticationToken authToken = new UsernamePasswordAuthenticationToken(userDetails, null, userDetails.getAuthorities()); // Setting authentication details authToken.setDetails(new WebAuthenticationDetailsSource().buildDetails(request)); // Setting the authentication token in the SecurityContext SecurityContextHolder.getContext().setAuthentication(authToken); } } // Proceeding with the filter chain filterChain.doFilter(request, response); } }\n\neach method in the JwtFilter class:\n\n  1. getUserService: The getUserService method in the JwtFilter class is designed to retrieve the UserService instance from the Spring application context only when it's needed. This approach is used to prevent problems related to the order in which Spring beans are loaded, known as circular dependency issues. Essentially, it ensures that UserService is available and fully initialized when accessed, avoiding any startup errors due to dependency conflicts.\n  2. doFilterInternal:\n\n     * Purpose: Examines each incoming HTTP request for a JWT in the Authorization header.\n     * Process: If a valid JWT is found, it extracts the username and checks with SecurityContextHolder to determine if the user is already authenticated for the current session.\n     * User Authentication: If the user is not logged in, it retrieves user details, verifies the token against these details, and if validated, sets the user\u2019s authentication in the SecurityContextHolder.\n     * Session Management: This mechanism centralizes security information, facilitating easy access and management of user authentication and authorization across the application.\n     * Continuation: Allows the request to move forward to the next stage in the filter chain or the intended final destination.\n\n\ud83d\udca1 SecurityContextHolder: This is a part of Spring Security that holds the\nsecurity context (i.e., details about the current user and their permissions)\nfor the current thread. It is used throughout an application to grant or\nrestrict access to different parts of the system.\n\n\ud83d\udca1 The SecurityConfig.java class sets up security rules for a web application\nto ensure that only authorized users can access specific areas.\n\nSecurityConfig.java\n\n    \n    \n    package com.unlogged.config; import com.unlogged.filter.JwtFilter; import com.unlogged.service.UserService; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import org.springframework.security.authentication.AuthenticationManager; import org.springframework.security.authentication.AuthenticationProvider; import org.springframework.security.authentication.dao.DaoAuthenticationProvider; import org.springframework.security.config.Customizer; import org.springframework.security.config.annotation.authentication.configuration.AuthenticationConfiguration; import org.springframework.security.config.annotation.web.builders.HttpSecurity; import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity; import org.springframework.security.config.http.SessionCreationPolicy; import org.springframework.security.core.userdetails.UserDetailsService; import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder; import org.springframework.security.crypto.password.PasswordEncoder; import org.springframework.security.web.SecurityFilterChain; import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter; import org.springframework.web.bind.annotation.CrossOrigin; @Configuration @EnableWebSecurity @CrossOrigin public class SecurityConfig { @Autowired private JwtFilter jwtFilter; // Defines a UserDetailsService bean for user authentication @Bean public UserDetailsService userDetailsService() { return new UserService(); } // Configures the security filter chain @Bean public SecurityFilterChain securityFilterChain(HttpSecurity httpSecurity) throws Exception { return httpSecurity .cors(Customizer.withDefaults()) // Apply CORS .csrf(csrf -> csrf.disable()) // Disable CSRF protection .authorizeHttpRequests(auth -> auth .requestMatchers(\"/auth/addUser\", \"/auth/login\") .permitAll()// Permit all requests to certain URLs .anyRequest().authenticated()) // Require authentication for all other requests .sessionManagement(session -> session.sessionCreationPolicy(SessionCreationPolicy.STATELESS)) // Set session management to stateless .authenticationProvider(authenticationProvider()) // Register the authentication provider .addFilterBefore(jwtFilter, UsernamePasswordAuthenticationFilter.class) // Add the JWT filter before processing the request .build(); } // Creates a DaoAuthenticationProvider to handle user authentication @Bean public AuthenticationProvider authenticationProvider() { DaoAuthenticationProvider authenticationProvider = new DaoAuthenticationProvider(); authenticationProvider.setUserDetailsService(userDetailsService()); authenticationProvider.setPasswordEncoder(passwordEncoder()); return authenticationProvider; } // Defines a PasswordEncoder bean that uses bcrypt hashing by default for password encoding @Bean PasswordEncoder passwordEncoder() { return PasswordEncoderFactories.createDelegatingPasswordEncoder(); } // Defines an AuthenticationManager bean to manage authentication processes @Bean public AuthenticationManager authenticationManager(AuthenticationConfiguration config) throws Exception { return config.getAuthenticationManager(); } }\n\nExplantion for the above code:\n\neach method defined in the SecurityConfig class:\n\n  1. userDetailsService():\n\n     * Initializes a service for loading user-specific data. It connects the application to a user service that retrieves necessary user information for authentication.\n  2. securityFilterChain(HttpSecurity httpSecurity):\n\n     * Configures security policies for HTTP requests within the application. It sets up how requests are authenticated and authorized. Key configurations include:\n\n       * CORS Configuration: Applies default settings for Cross-Origin Resource Sharing to manage resource interaction between different origins.\n       * CSRF Protection: Disables Cross-Site Request Forgery protection, typically for APIs using token-based authentication instead of cookies.\n       * Authorization Rules: Defines access rules, allowing unrestricted access to certain paths like /auth/addUser and /auth/login, and requiring authentication for all other requests.\n       * Session Management: Sets sessions to be stateless, meaning the server does not maintain any session state between requests.\n       * Authentication Provider: Integrates a DaoAuthenticationProvider that uses a user details service and a password encoder to authenticate users.\n       * JWT Filter Integration: Incorporates a JWT filter before the standard username-password authentication filter to process and validate JWTs in requests.\n  3. authenticationProvider():\n\n     * Creates an authentication provider that uses a database to handle user authentication. This provider retrieves user details and verifies passwords using a specified encoder.\n  4. passwordEncoder():\n\n     * Establishes a method for password encoding using BCrypt by default, an algorithm that hashes passwords securely before they are stored.\n  5. authenticationManager(AuthenticationConfiguration config):\n\n     * Provides a manager to see the authentication process, crucial for processing authentication requests and central to Spring Security's authentication framework.\n\n### JWT Authentication Mechanism For Our Project\n\n### Demo:\n\n#### Understanding JWT Tokens Issued After User Login:\n\nThus, we have used jwt based authorization in our spring securityproject to\naccess critical end points.\n\nAdditional topics related to this will be covered soon, as it's impossible to\ninclude everything in a single article.\n\nThanks!\n\nHappy coding and best wishes!\n\nGaurav Sharma\n\nApril 22, 2024\n\nUse Unlogged to\n\nmock instantly\n\nrecord and replay methods\n\nmock instantly\n\nInstall Plugin\n\nAbout Us\n\nBlog\n\n\u00a9 2024 Unlogged. All right reserved.\n\nTerms of Service\n\n", "frontpage": false}
