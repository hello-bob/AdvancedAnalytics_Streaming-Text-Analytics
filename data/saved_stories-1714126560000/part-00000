{"aid": "40165904", "title": "Type Safety Doesn't Matter", "url": "https://www.fpcomplete.com/blog/type-safety-doesnt-matter/", "domain": "fpcomplete.com", "votes": 2, "user": "lemper", "posted_at": "2024-04-26 04:15:22", "comments": 0, "source_title": "Type Safety Doesn't Matter - FP Complete", "source_text": "Type Safety Doesn't Matter - FP Complete\n\nFP Complete\n\nMenu\n\n# Type Safety Doesn\u2019t Matter\n\nShare this\n\nI\u2019m a huge believer in using strongly typed languages and leveraging type\nlevel protections in my codebases. But I\u2019d like to clarify my new, somewhat\nmodified stance on this:\n\nType safety does not matter.\n\nWhat I mean is that, on its own, type safety is not important. It\u2019s only\nuseful because of what it accomplishes: moving errors from runtime to compile\ntime. Even that isn\u2019t a goal on its own. The real goal is reducing runtime\nerrors. Type safety is one of the best methods of achieving these cascading\ngoals, but it\u2019s far from the only one.\n\nThis may sound pedantic and click-baity, but in my opinion it\u2019s a vitally\nimportant distinction with real world ramifications. For example, when\ndiscussing architecture of code or reviewing a pull request, I will often\ntimes push back on changes that add more complexity in the type system. The\nreason is because, even if a change adds \u201ctype safety,\u201d this extra complexity\nis only warranted if it achieves our primary goal, namely reducing runtime\nerrors.\n\nSuch an assessment is largely speculative, subjective, and risk-based. By that\nlast point, I\u2019m tapping into my actuarial background. The idea is that, when\nconsidering a code change, the question will always be: do I think there\u2019s a\nhigh likelihood that this change will meaningfully reduce bug count in the\nlong term more so than other activities I could be spending this time on? And\nif you watched my talk the economic argument for functional programming (or\nread the slides), you may be familiar with this way of thinking as the\nopportunity cost of spending more time on type safety.\n\nThis is why languages that provide for strong typing with type inference end\nup working out so well. There\u2019s relatively little cost for basic type safety\nmechanisms with significant gain. It\u2019s the 80/20 rule. I continue to believe\nthat the vast majority of the value I\u2019ve received from strongly typed\nlanguages like Rust, Haskell, and even TypeScript come from the \u201csimplest\u201d\nfeatures like enums/ADTs and pattern matching.\n\nBug reduction is not the only benefit of strong typing. There\u2019s also: easier\ncodebase maintainability, simplicity of refactoring, new engineering\nonboarding, potentially performance gains, and probably a few other things I\nmissed. But for me, reduction in bugs is still the primary benefit.\n\nThis paradigm of assessing the value in bug reduction from type safety lets us\nbroaden our scope a bit. If we want to reduce bugs in production, and we\nbelieve that moving bugs from runtime to compile time is a good way to do it,\nwe can naturally find some related techniques. An obvious one is \u201cstatic code\nanalysis.\u201d But I\u2019ll simplify that with the 80/20 rule as well to linting\ntools. Using linting tools is a great way to get lots of benefits with little\ncost.\n\nJust to prove this isn\u2019t only about types, let\u2019s take a concrete example from\neveryone\u2019s favorite language, JavaScript. If I\u2019m writing a React application\nin JavaScript, I get virtually no type safety. (TypeScript is a different\nstory, and it\u2019s the only thing that keeps me sane when working on frontend\ncode.) Consider this bit of almost-correct React code:\n\n    \n    \n    const { userName, gameLevel } = props const [userScore, setUserScore] = useState() useEffect(() => { const helper = async () => { const res = await fetchUserScore(userName, gameLevel) const body = await res.json() setUserScore(body.score) } helper() }, [userName, setUserScore])\n\nFor those not familiar: useEffect allows me to run some kind of an action, in\nthis case an asynchronous data load from a server. This is a common pattern in\nReact. As the user is using this application and changes the game level, I\nwant to perform an action to load up their current score from the server and\nset it in a local store that can be used by the rest of the application.\nuseEffect takes two arguments: the function to perform, and the list of\ndependencies to use. When one of those dependencies changes, the effect is\nrerun.\n\nThere are plenty of improvements to be made in this code, but there\u2019s one\nblatant bug: my useEffect dependency list does not include gameLevel. This\nwould be a bug at runtime: once the user\u2019s score is loaded for a level, we\nwould never reload it despite moving on to other levels. This would be the\nkind of bug that is easy to miss during manual testing, and could end up in\nproduction pretty easily.\n\nAutomated testing, unit tests, QA acceptance guidelines... basically\neverything around quality assurance will help ameliorate bugs like this. But\nstatic analysis arguably does even better here. The above code will\nimmediately trigger lints saying \u201chey, I see you used gameLevel in your\nfunction, but you didn\u2019t list it in your dependencies.\u201d This is a prime\nexample of moving a bug from runtime to compile time (or at least development\ntime), preventing an entire class of bugs from occurring, and it didn\u2019t need\nany type safety to do it. Sure, it doesn\u2019t eliminate every potential bug, but\nit does knock down a whole bunch of them.\n\nAs you might imagine, this blog post was inspired by a specific set of\nproblems I was running into at work. I thought about getting into those\ndetails here, and if there\u2019s interest I can write a follow-up blog post, but\nhonestly the specific case isn\u2019t terribly interesting. My point here is the\ngeneral principles:\n\n  1. Understand why you\u2019re trying to use type safety. Is it preventing some kind of a bug from occurring? Is the time you\u2019re spending on implementing the type-safe solution paying off in bug reduction and other benefits?\n  2. There are lots of other techniques worth considering for bug reduction. Static analysis is one I mentioned. Automated testing falls into this category as well. Don\u2019t be ideologically driven in which approaches you use. Choose the tool with the best power-to-weight ratio for what you\u2019re dealing with right now.\n\nSubscribe to our blog via email\n\nEmail subscriptions come from our Atom feed and are handled by Blogtrottr. You\nwill only receive notifications of blog posts, and can unsubscribe any time.\n\nTagged functional programmingnext gen software engineering\n\n## Contact Us\n\n10130 Perimeter Parkway Suite 200 Charlotte, NC 28216\n\n+1 858-617-0430\n\nsales@fpcomplete.com\n\n## Solutions\n\nMenu\n\n## Success Stories\n\nMenu\n\n## Resources\n\nMenu\n\n## About Us\n\nMenu\n\n## \u00a9FPComplete All Rights Reserved. Privacy Policy.\n\n## Contact Us\n\nCorporate Office 10130 Perimeter Parkway Suite 200 Charlotte, NC 28216\n\n+1 858-617-0430\n\nsales@fpcomplete.com\n\n## Solutions\n\nMenu\n\n## Success Stories\n\nMenu\n\n## Resources\n\nMenu\n\n## About Us\n\nMenu\n\n## \u00a9FPComlpete All Rights Reserved. Privacy Policy.\n\n## Contact Us\n\nCorporate Office 10130 Perimeter Parkway Suite 200 Charlotte, NC 28216\n\n+1 858-617-0430\n\nsales@fpcomplete.com\n\n## Solutions\n\nMenu\n\n## Success Stories\n\nMenu\n\n## About Us\n\nMenu\n\n## Resources\n\nMenu\n\n## \u00a9FPComlpete All Rights Reserved. Privacy Policy.\n\n", "frontpage": false}
