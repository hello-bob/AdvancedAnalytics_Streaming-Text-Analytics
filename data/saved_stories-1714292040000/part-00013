{"aid": "40184175", "title": "Making Sandspiel", "url": "https://maxbittker.com/making-sandspiel/", "domain": "maxbittker.com", "votes": 1, "user": "alschwalm", "posted_at": "2024-04-27 22:30:07", "comments": 0, "source_title": "Making Sandspiel | max-bittker", "source_text": "Making Sandspiel | max-bittker\n\nWant to become a better programmer? Join the Recurse Center!\n\nmax bittker\n\nprojects\n\nblog\n\nshelf\n\n# Making Sandspiel\n\nApril 30, 2019\n\nSandspiel is a falling sand game I built in late 2018. I really enjoyed\nwriting this game, and wanted to put into writing some of my goals, design\ndecisions, and learnings from that process. If you\u2019re reading this but haven\u2019t\nplayed sandspiel, you should probably go try it!\n\n## I love falling sand games.\n\nIf Sandspiel is the first \u201cfalling sand game\u201d you\u2019ve played, it\u2019s important to\nunderstand that it fits into a genre of games, which are developed\nindependently and usually distributed as free webgames in the form of flash or\njava applets. In each game, you\u2019re given a pallette of virtual solids,\nliquids, and gasses, and it\u2019s up to you to paint them onto the screen to\ndiscover how they interact.\n\nI think that I love these games so much because their mode of play is creative\nin a way that activates many parts of your imagination. Playing with the\nelements means asking questions, building experiments, and inventing stories\nand games of your own.\n\n> \u201cWhat does fungus do?\u201d\n\n> \u201cLet\u2019s make a cool volcanic island!\u201d\n\n> \u201cDoes anything destroy lava?\u201d\n\n> \u201cWhat happens if I do this?\u201d\n\nIn sand games, just like in other cellular automata (such as the Game of\nLife), the behavior of any single element is very simple. The interactions\nbetween the elements and across the space is where the interesting complexity\nof the simulation unfolds. The result is a system with surprising depth and\nvariety to explore.\n\nIt\u2019s also important that this system is engaging not just for its actual\ndepth, but also because of the ways your imagination sees reality reflected in\nit. Predicting how a scenario will play out based on your physical intuition\nis a form of play, as is projecting your imagination over what you see\nrepresented on screen. Much like playing with dolls or other simplistic model,\nthe pixels flowing around on the screen are stand ins for the story you tell\nyourself about them.\n\n> \u201cLow-fidelity art is also appealingly open to interpretation. If a character\n> is only eight pixels tall, a large part of what we see is within our own\n> imagination.\u201d - Loren Schmidt\n\nflotsam by mark wonnacott\n\n### Microcommunity\n\nEveryone loves to opine on their forgotten, weird corners of the internet, and\nmine is the upload gallery of dan-ball.jp\u2019s Powder Game around 2007-2013.\nThere was a beautiful micro-culture of people making games, toys, demos,\npropaganda, and art.\n\nPowder Game\u2019s upload galleries were a special place \u2014 the accessible venue to\nbuild something and share it led to people inspiring each other, riffing, and\npushing the game in incredible directions! Sand games captured my free time\nand imagination throughout my childhood in large part because of this weird\ncommunity.\n\nIt\u2019s also important that this system was built right into the game \u2014 every\nplayer had a immediate audience for their creation, in contrast to a culture\nbuilt around a few famous youtubers or streamers, or even that peculiar sort\nof self-selecting community you find on enthusiast forums. There was a wide\nvariety in complexity and motivations among posters. All this with no comment\nsection!\n\nThree archetypes of upload I remember fondly:\n\nGames for the player, often with empty promises of some reward for voting.\n\nmood ring\n\nGrotesque \u201cDon\u2019t Smoke\u201d educational demonstrations. (I think these were\ndirectly fueled by children coming home after D.A.R.E. programs at school)\n\ndont smoke\n\nCool volcanos. (a true classic)\n\nvolcano\n\nBeautiful pixel-art architecture to destroy.\n\ncastle\n\nThe added dimension of an audience brings so much depth to playing around with\nsand. I wanted to facilitate this in sandspiel with the upload system.\n\n## Building Sandspiel\n\nThe first thing you should know is that Sandspiel is actually my third or\nfourth attempt at building an interactive falling sand simulation.\n\n### \u201cHTML5\u201d\n\nThe first proper attempt was pure javascript in 2015. (You can try it out\nhere!)\n\ndust\n\nIt\u2019s... a falling sand game! You can set things on fire, draw fountains, and\nthere\u2019s even a fluid simulation that allows particles to float around in the\nwind. I think my favorite things about this game was making pixel art with the\nrainbow \u201cDust\u201d element, and the way that \u201cDirt\u201d absorbs and diffuses water to\nbecome mud.\n\nOn the negative side, resolution is only 100x100 (Sandspiel has 9x more\npixels), doesn\u2019t work on a phone, the interface is confusing and keyboard\nbased, and the element logic is pretty janky.\n\nIt\u2019s also rendered with canvas APIs, and the code is not organized in any\nintentional way. Plenty of dynamic typing, gnarly switch statements, and\nglobal variables. All of this made implementing and debugging each successive\nelement\u2019s logic increasingly difficult\u2014 to the point that it resulted in bugs\nthat I domesticated and kept in the game, such as the element \u201cGlitch\u201d which\nbehaves differently depending on what element you have selected.\n\nI was really proud of this game and had a great time building it, but it\nfollowed the familiar arc of a system collapsing under its own weight as\nprogress became more difficult and motivation waned. The last commit message\nwas kind of classic, and I never did follow up on that \u201cimpending refactor\u201d.\n\nlast dust commit\n\n### L\u00d6VEly\n\nThe second approach was with Lua in 2018, and my work here turned out to be\nthe direct prototype for Sandspiel.\n\nlua\n\nA few things are briefly worth saying on this experience: First I need to gush\nthat lua is super fast thanks to LuaJIT, and the L\u00d6VE framework is lovely tool\nfor building games. Shaders, input handling, update and render loops \u2014\neverything clicked together thanks to L\u00d6VE and made life easy - I could get\nthings running quickly with minimal yak shaving and boilerplate.\n\nComing from the browser, a tool into which I have personally sunk many\nhundreds of hours learning APIs, edge cases, and performance characteristics,\nit was a big surprise to see how effective a minimal programming environment\nfor building games could be. So much complexity that we put up with is due to\nlegacy and sunk costs!\n\nFirst vaguely working moment of the lua demo\n\nComing into this second attempt to build a sand game, I had 3 years of\nexperience beyond what I had when building the pure javascript version. I also\nhad an important new goal - not only did I want the game to be fun to play,\nbut I also wanted elements to be fun to write.\n\nI approached the project with a focus on the ergonomics of defining elements\nwith code because I was imagining a new type of sand game with a fully\nsandboxed programming interface that would allow people to not only paint and\nshare their compositions, but also to code their own new elements and share\nthose too!\n\nMy hope was that a community of people collaborating to build a plethora of\nweird elements would find really interesting interactions that hadn\u2019t been\ncovered in other sand games.\n\nHowever, this was a big goal, and the first step of the process was still\nbuilding out a game engine and initial set of elements on my own. While\nbuilding these, I was thinking carefully about the needs of the future element\nauthors. Viewing the game engine as a public API meant designing it to move as\nmuch complexity as possible inside the engine and away from being the\nresponsibility of the individual elements.\n\n    \n    \n    -- implementation of the rules for the \"Gas\" element, in lua function updateGas(particle, getNeighbor, setNeighbor) local d = {x = math.random(-1, 1), y = math.random(-1, 1)} -- random location offset if (getNeighbor(d) == species.empty) then -- if that relative location is empty setNeighbor({x = 0, y = 0}, species.empty) -- write \"empty\" to my current location setNeighbor(d, particle) -- and write my particle type to the random offset end end\n\nThis meant defining a format that elements were expressed in \u2014 I settled on a\nsingle update method which defines the behavior of a single particle for a\nsingle update tick. The code inside the method can interact with the system\nonly via special methods which provide safe reading and writing to their\nneighbors.\n\nThis API abstracts away concerns such as:\n\n  * The particle needing to know its absolute position (setNeighbor and getNeighbor deal in relative offsets),\n  * Interactions with the edges of the grid (all of the edge condition logic is in the engine),\n  * Enforcing a small local read/write neighborhood for the particles (no \u201caction at a distance\u201d).\n\nThat work relieved the individual elements from needing to take on these\nconcerns into their own logic, and made the system more consistent and easier\nto experiment with as I implemented my cast of elements.\n\nFocusing on making the definition of a new element simple and self-contained\nreally paid off, even though I ultimately ended up being the only person\nconsuming these APIs. The system being more fun to iterate on was rewarding\nenough to justify the extra care put into the architecture early on.\n\nI was excited about this approach and it was working well, but wanted to build\nthe game in a way that I could reach users. Despite everything good I had to\nsay about L\u00d6VE, the web is too powerful of a platform to pass up, and it\u2019s\nworth the quirks and warts.\n\nI decided to put down the lua implementation and switch to Rust, but I was\nable to directly translate many lessons and patterns over. Having a good idea\nof what my data-structures would be and what types of APIs would be defined\nbetween components made writing the Rust version much smoother.\n\nImplementing one idea multiple times was a huge strength in my ability to\nstructure my codebase, forsee pitfalls, and make more thoughtful and\nintentional tradeoffs. I would strongly recommend this experience to anyone -\nIf you have a project that you\u2019ve attempted in the past but either didn\u2019t\nfinish or made compromises on due to your technical skills or endurance,\ntaking another crack at it can a great opportunity to sweat the details and\nsee new approaches.\n\n### Architecture:\n\nSandspiel.club can be described as four main components\n\n  * the particle simulation code, written in Rust\n  * a fluid simulation, written in JS & GLSL\n  * user interface written in React & JS\n  * a CRUD backend written with TypeScript and Firebase Postgres\n\nThe main simulation, controlling the movement and interactions of all of the\nelements, takes place in Rust in a class called Universe. This is the class\nholds the game state and exports a set of methods to be called by the\nJavascript application, which do things like process a frame of the\nsimulation, paint some pixels, or return a pointer to the particle state\nbuffer.\n\nThis means that I don\u2019t try to handle an event loop, do rendering, or interact\nwith the browser from inside the Rust code - all of that would be perfectly\npossible, but I\u2019m very happy with this division of labor between the JS and\nRust. Everything low level or CPU intensive happens within the Rust-generated\nWeb Assembly code, while all of the the glue related to human interface, WebGL\ncalls, and browser APIs takes place in the Javascript.\n\n#### Data format\n\nThe first most notable aspect of Sandspiel\u2019s architecture is the compact data\nformat I used for the game state. By setting some constraints on the system, I\nwas able to benefit from a uniform format that performed and serialized well.\nThis came in handy several times!\n\nThe state for a single particle is represented as a 32 bit struct.\n\n    \n    \n    #[repr(C)] pub struct Cell { species: Species, ra: u8, rb: u8, clock: u8, }\n\nThe first field, species, is a custom enum type which represents the varieties\nof particles as numbers:\n\n    \n    \n    #[wasm_bindgen] #[repr(u8)] pub enum Species { Empty = 0, Wall = 1, Sand = 2, Water = 3, ... Seed = 19, }\n\nra and rb are two 8 bit \u201cregisters\u201d for storing extra some cell state beyond\nspecies, such as what color a given flower petal is, or how hot an ember of\nfire is. They\u2019re used in different ways by different element species, and some\nspecies don\u2019t use them at all (for instance, a Wall particle has no extra\nstate to track). The two state registers only differ in that ra is initialized\nto a random value, and rb is initialized to 0. ra is also used in rendering to\ndetermine how light the pixel should be, which is where the slight visual\ngrain effect comes from.\n\nclock is just used to prevent a single particle from being simulated multiple\ntimes in a single tick if it moves in the same direction as the update scans.\nBecause we execute cell update functions one at a time from left to right and\ntop to bottom, if a particle something is moving down, it will keep bumping\nitself ahead of the \u201cscan line\u201d and could move many spaces in a single frame.\nClock is meant to keep track of what elements have been simulated already -\nthis could have been accomplished single bit that is flipped back and forth\nbut it\u2019s important that my Cell type is represented by a total of exactly 32\nbits, and I didn\u2019t have any use for the other 7 bits!\n\nNowhere in this cell state struct is a concept of location. This is because,\nas opposed to a particle simulation where we maintain a list of entities and\ntheir positions, here we store all particles in a dense 2D array, and directly\nencode the position of a cell as its location in that grid.\n\n### Update Function\n\nThe most important pieces of code in the game are the set of functions, one\nfor each type of element, that define how particles of that type interact with\ntheir neighbors each frame. Theoretically, you could delete these functions\n(which live in species.rs ) and write a new set that transform the game into a\ncellular automata simulator for some other system, such an ant farm, a petri\ndish, a city-scape, a paint canvas, an aquarium, or an abstract fractal\nplayground.\n\nHere\u2019s an example of how one of our elements is defined:\n\n    \n    \n    // Called once per sand particle per frame: pub fn update_sand(cell: Cell, mut api: SandApi) { let dx = rand_dir(); // random value in {-1, 0, 1} let neighbor = api.get(0, 1); // get the Cell Struct of the cell below me if neighbor.species == Species::Empty { // try to fall down api.set(0, 0, EMPTY_CELL); // erase my current location api.set(0, 1, cell); // write myself one cell lower } else if api.get(dx, 1).species == Species::Empty { // try to fall diagonally api.set(0, 0, EMPTY_CELL); // erase my current location api.set(dx, 1, cell); // write myself down and to the side } }\n\nSandApi is a struct provided to the function which holds the location of the\nparticle without directly exposing their values. It exposes some important\nfunctions, like get and set, which accept relative coordinates and let you\nread and write to your neighboring cells. For instance, api.get(0, 1).species\ntells you the species of the particle below you, and calling\n\n    \n    \n    api.set(0, 0, Cell { species: Species::Fire, ra: 150, } );\n\nwill write a Fire particle to your current location (erasing yourself in the\nprocess).\n\nDesigning and tuning these update functions was a lot of fun, and I was able\nto test out a lot of ideas and play with different interactions. I didn\u2019t make\nuse of syntax macros or anything as fancy as that, but the experience was a\nlot like that of building a system by first building a \u201cDomain Specific\nLanguage\u201d which encodes the shared behaviors and invariants of the system, and\nthen scripting its inhabitants in that simplified DSL.\n\nAnother thing to note here is that these update functions, which hold so much\nof the gameplay logic, are run thousands of time per frame! This means that\nthey\u2019re simultaneously critical to the feel of the game, and are some of the\nhottest lines of code in the project. Rust\u2019s commitment to enabling\nexpressive, high level code without invisible performance cliffs really\nallowed me to write the logic how I wanted to write it, without accidentally\ncausing a bunch of slow heap allocation or writing code that a JIT will\ncapriciously decide not to optimize. It\u2019s probably possible that there are\npeople out there who could carefully craft some high-performance javascript\nthat would be competitive with my Rust code, but I was able to mostly \u201cjust\ncode\u201d and not worry too much about performance.\n\nZero cost abstractions!\n\nLast interesting anecdote here is that I unwittingly wrote most of the game\nwith my rustc optimization strategy on \u201cz\u201d, which means the compiler will\noptimize for binary size. Once the project was almost finished, I realized\nthis and switched it to \u201co3\u201d which does things like inlining and gave me a big\nperformance boost, where I had been being frugal! That was a nice surprise, it\nperformed better and the WASM output only increased in size from 66Kb to 84Kb.\nA big mistake I made was to immediately take this extra performance budget and\n\u201cspend it\u201d to increase my canvas size from 250x250 to 300x300, because now I\ncould still get 60 fps on the 300x300 canvas. This was a blunder because there\nare a ton of devices which can\u2019t run sandspiel at 60fps, and I should have\nheld onto this spare performance headroom so that more devices could run the\nsimulation at full speed.\n\n### Rendering\n\nI mentioned that the simulation takes place in Web Assembly, and that the\nJavascript manages the WebGL rendering (it\u2019s totally possible to call WebGL\nAPIs directly from web assembly, but I didn\u2019t want to compound my WebGL\ninexperience with my Rust inexperience).\n\nRendering is basically as easy as reading each cell of our gamestate grid, and\npainting a corresponding pixel with a color according to its species and ra\nvalues.\n\nWe just need to make sure that our fragment shader (the code which runs on the\nGPU and decides what color the pixels should be) has access to the game state,\nwhich is stored in the Web Assembly heap.\n\nIn order to move the game state from Web Assembly to WebGL, we construct a\nJavascript typed array view over the game state array which lives in Web\nAssembly memory, and pass that view to our fragment shader (GPU code) as a\ntexture.\n\n    \n    \n    // Typed Array is not a copy, it's a view of our web assembly array const cellsData = new Uint8Array( memory.buffer, universe.cells(), <- // a pointer to the Cell array in WASM width * height * 4 ); gl.bindTexture(gl.TEXTURE_2D, cellTexture); gl.texImage2D( gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, gl.UNSIGNED_BYTE, cellsData );\n\nBecause our game state data is arranged in such a way that it happens to be a\nvalid image texture, we can ship the whole grid over to the GPU with minimal\ncopying and allocation! This was a big deal for making Sandspiel\u2019s rendering\nperformant- the rendering code blocks the CPU for less than 1 millisecond,\ncritical for meeting the strict 16ms budget needed to achieve 60FPS.\n\nsand-trace\n\nThis is also one of the reasons it was so important that our Cell state was\nstored as an array of 4 byte chunks. WebGL has a lot of restrictions on the\nformats of data that can be used in textures, but RGBA textures where each\npixel is 4 unsigned bytes are well supported.\n\n### Fluid Dynamics\n\nSandspiel\u2019s fluid simulation usually really stands out to people who play with\nit, which makes me feel a little bit guilty, because it\u2019s largely ripped from\nPavel Dobryakov\u2019s WebGL Navier-Stokes implementation. I\u2019m extremely grateful\nto have had such a quality implementation to learn from\u2014 adapting and\nextending this code was the most personally challenging technical hurdle I\nfaced building the game.\n\nAdapting the code was difficult because, in order to have interactions between\nthe wind (simulated on the GPU) and the particles (simulated on the CPU), I\nneeded to pass data from Web Assembly to WebGL (in the same fashion as I\nmentioned for the rendering), and from WebGL back into to Web Assembly (this\nbit was trickier, as WebGL can by picky about which buffers are readable, and\nwhen you can read from them).\n\nI also needed to do this in a way that used only the subset of WebGL features\nsupported on most phones - WebGl is a pretty large spec, and for hardware and\ndriver reasons, not all of it is available on all devices.\n\nThis process was made worse by the fact that my only phone on which to test\ncode runs iOS, and Apple only allows you to connect to the mobile safari\ndeveloper tools from a Mac (which I don\u2019t have). So I was debugging many of\nthese WebGL device-specific limitations without so much as a console.\nFrustrating!\n\n### User Interface\n\nSandspiel\u2019s interface is actually much simpler than most falling sand games. I\nmade an intentional effort to keep the UI light and fun on a touch screen, by\navoiding interactions that require multiple taps to complete. Some examples of\nthis are that none of the tools require cycling through different settings or\ndrop-down menus, and I dropped the system of two-stage selection that other\ngames use to implement elements like clone and firework.\n\nsandspiel ui\n\nI also put care into the line drawing itself - there\u2019s some fiddly edge cases\nrelated to handling taps, drags, scrolling, and other interaction events on\nthe canvas. This is the sort of tuning that should be invisible if it\u2019s\nworking, but I ran into a lot of interaction scenarios while testing the game,\nand tried to sand down the rough edges.\n\nAs part of this work, I disabled pinch-to-zoom - it would be an interesting\nchallenge to try to fit that back into the space of supported interactions.\n\nFacilitating and disambiguating multiple gestures in a single arena is a\ncomplex and fascinating corner of algorithms and human computer interaction,\nand I have new respect for the often invisible work that goes into building\nrich touch screen experiences.\n\n#### UI Code\n\nI threw the interface together mostly in React. If you have one takeaway about\nWeb Assembly from this project, I want it to be that WASM is not an all or\nnothing undertaking! Having the ability to put low-level and performance-\ncritical logic into Rust and still handle all the browser API stuff, glue\ncode, and UI in Javascript was critical to this project coming together\nquickly and having a nice interface.\n\nLeveraging the npm ecosystem for tools like React, Regl, and GLSLify, as well\nas exercising Javascript\u2019s flexibility to toss data anywhere I needed it\nwithout much planning or refactoring enabled me patch things together quickly\nand loosely.\n\nNothing I wrote in JS would have been impossible to accomplish in Rust, but it\nwouldn\u2019t have come together as easily and I wouldn\u2019t have been able to test as\nmany ideas along the way.\n\n### Sharing & Persistence\n\nTo fully capture the creative micro-community of other falling sand games, I\nwanted there to be functionality for uploading creations, and browsing others\u2019\nworks. I decided to try using Firebase to handle my backend needs, and I think\nthat worked out pretty well! One design decision that turned out to be\nimportant was that I wanted to avoid dealing with accounts and authorization.\nI find that stuff annoying for the user and boring to implement so I went to\nsome lengths to do without it.\n\nThe way that I handled data security without auth was putting all data writing\ninside of api endpoints, and using these to constrain what the client could\ndo. (basically, GET, INSERT and voting only, no editing or deleting of other\nposts). My workaround for voting deduplication was to use IP addresses, which\nis possible to manipulate, but I don\u2019t really care enough to try to fight it.\n\nI run these API endpoints as a cloud function, cloud functions seem cheap and\ngreat.\n\nA cool thing here about the storage functionality is that I serialize the game\nstate as a PNG file, which is lossless and highly compressible. Plus, browsers\nhave efficient PNG encoders and decoders built in, so that\u2019s more code I don\u2019t\nneed to import and ship with my bundle. Here\u2019s what the data looks like as a\nPNG: (remember, in each RGB pixel, \u201cred\u201d is species, \u201cgreen\u201d is ra, and blue\nis rb)\n\ndata as png\n\nThe basic architecture of my backend is something like this:\n\nfirebase\n\nThere were times while debugging when I was really just wished I was writing a\nhttp server backed by a redis instance and a directory full of files, with\nnothing hidden behind proprietary services and configuration languages. But I\ndon\u2019t want to be on the hook for availability, persistance, and server\nmanagement - especially when the other things running on my VPS are already\nfragile, stateful, and ad hoc. Firebase was harder to debug and run adhoc\nscripts against, but I don\u2019t have to think about it now that the service is\ndeployed, and it\u2019s reliable and cheap enough.\n\nRunning the game for a few months started to become expensive as traffic\nramped up, 99% dominated by Firestore reads. (I think the architecture I had\nof listing out large sections of documents without caching or pagination\nwasn\u2019t well suited to Firestore.)\n\nI didn\u2019t want to continue paying $50 a month for Firestore, and I also wanted\nto implement more interesting query capabilities, including full-text search.\n\nThis led me to migrate my ~60k records off of Firestore and into a Postgres\ninstance, which I\u2019m really glad to have done. Operating Postgres has been\nabout 10% of the price, significantly lower latency, and allows me to run\ncomplex queries to power new features like the search box.\n\n### Community\n\nA couple thousand people play with sandspiel every day now! The upload boards\nget spammed with all sorts of beauty and nonsense, and it warms my heart to\nsee people playing, interacting and (mostly) having fun. The playerbase skews\npretty young, and uploads are filled with memes, kids promoting their youtube\naccounts, etc etc. For the most part, it gets used as a paint program, and the\nactual simulation aspects are an afterthought!\n\nvampkiddle\n\nIf you load one creation, this irreverent homage to the Notre Dame cathedral\nmight be my favorite: (Make sure to press \u25b7 once it\u2019s loaded)\n\nnotre dame\n\nPeople have uploaded more than 70,000 creations, ranging from sophisticated\nrube goldberg reactions, coloring book \u201ccomplete the drawing\u201d prompts,\nimpressionist paintings, crude kinetic graffiti, and everything in between.\n\nsystem\n\nOne upload that surprised me was when someone manipulated the data buffer\ndirectly, to upload out-of-range species data. This resulted in a pink element\nwith no intentionally defined behavior, like the \u201dMissingNo.\u201d of sandspiel. It\ntotally made my day when I realized what had happened, as this was not\nsomething I thought was possible! I like to call it \u201cbelp\u201d.\n\nThere\u2019s a healthy remix culture of people making new takes on popular\ntemplates. Two favorites are doonaloona, the lithuanian puppy queen of\nsandspiel\n\ndoona\n\nand these images of reggie that someone was able to somehow hack into the game\nin different elements.\n\nreggie\n\nThank you so much for reading this long post!\n\n# Resources to check out:\n\nThe Rust Wasm Book is a great succinct resource that covers all aspects of\nwriting a hybrid JS & Rust application. I had basic rust knowledge before\nstarting Sandspiel, but no knowledge of web assembly, and was able to follow\nthis book to bootstrap the game. A lot of code from the book actually ended up\nin my game, since their example was cellular automata related.\n\nThe Book of Shaders I didn\u2019t specifically reference TBoS during this project,\nbut I take any opportunity I can get to recommend it to anyone interested in\nlearning graphics programming. I wish this book was a part of high school math\ncurriculums.\n\nWebGL Fundamentals & WebGL2 Fundamentals Really solid & complete explanations\nof WebGL basics, put into context of common tasks and patterns. Finding those\ntwo things together is rare!\n\nFast Fluid Dynamics Simulation on the GPU is a chapter from the book GPU Gems,\nwhich details the math and mechanics that go into a beautiful and buttery\nNavier Stokes fluid simulation. It\u2019s really interesting how physical concepts\nlike pressure, advection, and diffusion, all expressed as math operations on\ngrids of floats, can be composed into a convincing simulation.\n\nAlso, thanks to Chris Crawford, Nikhilesh Sigatapu, Thais Correia, Pavel\nDobryakov, the Rust WebAssembly working group, and ha55ii for inspiration,\nknowledge, code, and feedback!\n\n# Extra links:\n\nsandspiel source code\n\n@sandspiel_feed twitter feed of uploads\n\n  * \u2190 How to Program Your GPU (and Not Do It Alone) @DinosaurJS\n  * Simulating Sand: Building With WebAssembly @JSConf EU \u2192\n\n", "frontpage": false}
