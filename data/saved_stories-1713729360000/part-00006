{"aid": "40105177", "title": "Behind the Curtain of Inline Terminal Applications", "url": "https://textual.textualize.io/blog/2024/04/20/behind-the-curtain-of-inline-terminal-applications/", "domain": "textualize.io", "votes": 3, "user": "willm", "posted_at": "2024-04-21 12:27:03", "comments": 0, "source_title": "Textual - Behind the Curtain of Inline Terminal Applications", "source_text": "Behind the Curtain of Inline Terminal Applications - Textual\n\nSkip to content\n\n# Behind the Curtain of Inline Terminal Applications\u00b6\n\nTextual recently added the ability to run inline terminal apps. You can see\nthis in action if you run the calculator example:\n\nThe application appears directly under the prompt, rather than occupying the\nfull height of the screen\u2014which is more typical of TUI applications. You can\ninteract with this calculator using keys or the mouse. When you press Ctrl+C\nthe calculator disappears and returns you to the prompt.\n\nHere's another app that creates an inline code editor:\n\n    \n    \n    from textual.app import App, ComposeResult from textual.widgets import TextArea class InlineApp(App): CSS = \"\"\" TextArea { height: auto; max-height: 50vh; } \"\"\" def compose(self) -> ComposeResult: yield TextArea(language=\"python\") if __name__ == \"__main__\": InlineApp().run(inline=True)\n\nThis post will cover some of what goes on under the hood to make such inline\napps work.\n\nIt's not going to go in to too much detail. I'm assuming most readers will be\nmore interested in a birds-eye view rather than all the gory details.\n\n## Programming the terminal\u00b6\n\nFirstly, let's recap how you program the terminal. Broadly speaking, the\nterminal is a device for displaying text. You write (or print) text to the\nterminal which typically appears at the end of a continually growing text\nbuffer. In addition to text you can also send escape codes, which are short\nsequences of characters that instruct the terminal to do things such as change\nthe text color, scroll, or other more exotic things.\n\nWe only need a few of these escape codes to implement inline apps.\n\nNote\n\nI will gloss over the exact characters used for these escape codes. It's\nenough to know that they exist for now. If you implement any of this yourself,\nrefer to the wikipedia article.\n\n## Rendering frames\u00b6\n\nThe first step is to display the app, which is simply text (possibly with\nescape sequences to change color and style). The lines are terminated with a\nnewline character (\"\\n\"), except for the very last line (otherwise we get a\nblank line a the end which we don't need). Rather than a final newline, we\nwrite an escape code that moves the cursor back to it's prior position.\n\nThe cursor is where text will be written. It's the same cursor you see as you\ntype. Normally it will be at the end of the text in the terminal, but it can\nbe moved around terminal with escape codes. It can be made invisible (as in\nTextual apps), but the terminal will keep track of the cursor, even if it can\nnot be seen.\n\nTextual moves the cursor back to its original starting position so that\nsubsequent frames will overwrite the previous frame.\n\nHere's a diagram that shows how the cursor is positioned:\n\nNote\n\nI've drawn the cursor in red, although it isn't typically visible.\n\nThere is an additional consideration that comes in to play when the output has\nless lines than the previous frame. If we were to write a shorter frame, it\nwouldn't fully overwrite the previous frame. We would be left with a few lines\nof a previous frame that wouldn't update.\n\nThe solution to this problem is to write an escape code that clears lines from\nthe cursor downwards before we write a smaller frame. You can see this in\naction in the above video. The inline app can grow or shrink in size, and\nstill be anchored to the bottom of the terminal.\n\n## Cursor input\u00b6\n\nThe cursor tells the terminal where any text will be written by the app, but\nit also assumes this will be where the user enters text. If you enter CJK\n(Chinese Japanese Korean) text in to the terminal, you will typically see a\nfloating control that points where new text will be written. If you are on a\nMac, the emoji entry dialog (Ctrl+Cmd+Space) will also point at the current\ncursor position. To make this work in a sane way, we need to move the\nterminal's cursor to where any new text will appear.\n\nThe following diagram shows the cursor moving to the point where new text is\ndisplayed.\n\nThis only really impacts text entry (such as the Input and TextArea widgets).\n\n## Mouse control\u00b6\n\nInline apps in Textual support mouse input, which works the same as fullscreen\napps.\n\nTo use the mouse in the terminal you send an escape code which tells the\nterminal to write encoded mouse coordinates to standard input. The mouse\ncoordinates can then be parsed in much the same was as reading keys.\n\nIn inline mode this works in a similar way, with an added complication that\nthe mouse origin is at the top left of the terminal. In other words if you\nmove the mouse to the top left of the terminal you get coordinate (0, 0), but\nthe app expects (0, 0) to be where it was displayed.\n\nIn order for the app to know where the mouse is relative to it's origin, we\nneed to ask the terminal where the cursor is. We do this with an escape code,\nwhich tells the terminal to write the current cursor coordinate to standard\ninput. We can then subtract that coordinate from the physical mouse\ncoordinates, so we can send the app mouse events relative to its on-screen\norigin.\n\n## tl;dr\u00b6\n\nEscapes codes.\n\n## Found this interesting?\u00b6\n\nIf you are interested in Textual, join our Discord server.\n\nOr follow me for more terminal shenanigans.\n\n  * @willmcgugan\n  * mastodon.social/@willmcgugan\n\nCopyright \u00a9 Textualize, Inc\n\nMade with Material for MkDocs\n\n", "frontpage": false}
