{"aid": "40162343", "title": "Dependent types in Haskell, Part 3", "url": "https://serokell.io/blog/ghc-dependent-types-in-haskell-3", "domain": "serokell.io", "votes": 2, "user": "todsacerdoti", "posted_at": "2024-04-25 20:06:05", "comments": 0, "source_title": "Dependent types in Haskell, Part 3", "source_text": "Dependent types in Haskell, Part 3\n\n  * Close\n\n  * Projects\n  * Shop\n  * Blog\n  * Labs\n  * Courses\n  * Careers\n  * Team\n  * Contacts\n\nResearchProgrammingArtificial IntelligenceInterviewsOther\n\n#\n\nSerokell\u2019s Work on GHC: Dependent Types, Part 3\n\nArticle by Serokell GHC team\n\nApril 25th, 2024\n\n9 min read\n\nTwitter\n\nFacebook\n\nLinkedin\n\nTelegram\n\nMail\n\nWhatsApp\n\nCopy Link\n\n2\n\nAt Serokell, we are convinced that Haskell would greatly benefit from the\naddition of dependent types to its type system. We have a dedicated GHC team\nto make this happen. It currently consists of Vladislav Zavialov and Andrei\nBorzenkov.\n\nIn this report, we\u2019d like to share our recent progress with you.\n\n##\n\nSummary\n\nThere are four topics that the report covers:\n\n  1. @-binders in lambdas and function equations\n  2. Namespace specifiers in fixity declarations and pragmas\n  3. Refactoring of exact-print annotations (EPA)\n  4. Pun-free syntax for list and tuple types\n\nHere we go!\n\n##\n\n@-binders in lambdas and function equations\n\nLet\u2019s start with the most signifant achievement out of the four, namely\n@-binders in lambdas and function equations. This is a new feature that we\nimplemented, and it looks like this:\n\n    \n    \n    {-# LANGUAGE TypeAbstractions #-} f :: forall a. a -> a f @a x = x :: a -- @a-binder on the LHS of a function equation\n\nNotice the @a on the LHS \u2013 that\u2019s the new syntax that allows binding invisible\ntype variables. In lambdas, it looks about the same: \\ @a -> rhs. The name of\nthe bound variable may or may not coincide in the signature and the equation,\nthe following example is fully equivalent to the last one:\n\n    \n    \n    {-# LANGUAGE TypeAbstractions #-} f :: forall a. a -> a f @b x = x :: b -- @b corresponds to forall a. in the signature\n\nThere are two reasons you might want to use @-binders.\n\nThe first use case is to replace ScopedTypeVariables. Consider this example\nwritten in the old style:\n\n    \n    \n    {-# LANGUAGE ScopedTypeVariables #-} f :: forall a. a -> a f x = x :: a\n\nNotice how in x :: a on the RHS, the a comes into scope from the signature.\nThis means that scoping is not contiguous, i.e. it can have gaps\n\n    \n    \n    {-# LANGUAGE ScopedTypeVariables #-} f :: forall a. a -> a g = 42 -- scope gap f x = x :: a\n\nThe a is in scope in the signature, then not in scope in g = 42, then in scope\nagain in f x = x :: a. Noncontiguous scope is unusual. Sometimes it is also\nunreliable, for example, with ScopedTypeVariables you\u2019re not allowed to hide\nthe forall behind a type synonym:\n\n    \n    \n    {-# LANGUAGE ScopedTypeVariables #-} type T = forall a. a -> a f :: T f x = x :: a -- oops! not working anymore\n\nNone of this is an issue with @-binders, which scope contiguously and interact\nharmoniously with other language features such as type synonyms.\n\nThe second use case for @-binders is binding type variables in higher-rank\nscenarios:\n\n    \n    \n    ex :: (Int8, Int16) ex = higherRank (\\ @a x -> maxBound @a - x ) -- @a-binder in a lambda pattern in an argument -- to a higher-order function higherRank :: (forall a. (Num a, Bounded a) => a -> a) -> (Int8, Int16) higherRank f = (f 42, f 42)\n\nIn this example, we use an @a-binder in a lambda to bind a type variable. Then\nwe pass the type variable a as a type argument to maxBound. If not for this\nnew feature, we would have to rely on implicit binders in pattern signatures\nto bring such variables into scope:\n\n    \n    \n    \\(x :: a) -> ... -- old style with implicit binding\n\nThe problem with implicit binding is that it relies on unification, so if the\nvariable is under a non-injective type constructor (a type family or a type\nsynonym), there\u2019s no way to bind it at all, leading API designers to introduce\nProxy arguments (e.g. reify in reflection). Now it is a solved problem.\n\nTo understand the connection of @-binders to dependent types, remember that\none of the proposed quantifiers in Dependent Haskell is foreach a. t, which is\nsimilar to forall a. t, except the argument is retained and passed at runtime.\nRetaining the argument enables dependent pattern matching. We wanted an\nelegant solution for binding invisible type arguments that would be\nappropriate for both of those quantifiers.\n\nIn their current form, @-binders can be used with the erased quantifier forall\na. t. In the future, we can build upon this binding mechanism in the\nimplementation of the retained invisible quantifier foreach a. t. It offers a\nmuch more solid foundation than ScopedTypeVariables, especially if we consider\nthe potential interactions with pattern matching or nested quantification.\n\nIt is also quite satisfying that @-binders are a feature that is useful in and\nof itself, even if we put dependent types aside for a moment. This is thanks\nto the GHC proposal process, which ensures that each incremental change has a\ncompelling motivation. In fact, @-binders have a long backstory, starting with\nGHC Proposal #155 (written in 2018, accepted in 2019). The proposal was\nsomewhat underspecified, as our initial implementation attempts revealed. It\nturned out that we needed to modify the type checker to do skolemisation\nlazily. The paper \u201cSeeking Stability by being Lazy and Shallow\u201d (2021) added\nsome clarity by formally specifying lazy skolemisaiton, though we later\ndiscovered new corner cases that needed to be addressed. GHC Proposal #448\n(written 2021, accepted 2022) offered a more comprehensive spec, though this\ntime, it was more of a package deal: there were some other features included\nin 448, so now we are talking about implementing a small section of it that\ncorresponds to 155. After a few setbacks and about a year of inactivity,\n@-binders made it into GHC 9.10.\n\nAs always, adding a new feature means not only extending the language, but\nalso updating the template-haskell library, the head.hackage compatibility\nlayer, and documenting it in the User\u2019s Guide (see the new section 6.4.17.2.\nType Abstractions in Functions).\n\n##\n\nNamespace specifiers in fixity declarations and pragmas\n\nThe second item in our list is the implementation of GHC Proposal #65. Here is\na code example:\n\n    \n    \n    data T = T {-# DEPRECATED type T \"Deprecation message\" #-}\n\nNotice how the name T is used both for a type constructor and a data\nconstructor. But how could we deprecate only one of them? This is where\nnamespace specifiers enter the picture: we can write type T or data T to refer\nto the type constructor or the data constructor respectively.\n\nThe same principle applies to fixity declarations:\n\n    \n    \n    f # a = f a type f # a = f a infix 1 type # infix 2 data #\n\nIf there are both a term-level operator # and a type operator # in scope, we\ncan write data # and type # respectvely to refer to them in a fixity\ndeclaration.\n\nThe reason we decided to implement namespace specifiers is that the lack of\nthis feature was blocking progress on non-punning tuple constructors. We\nneeded a way to mark the Solo data constuctor deprecated:\n\n    \n    \n    {-# DEPRECATED data Solo \"The Solo constructor has been renamed to MkSolo to avoid punning.\" #-} pattern Solo :: a -> Solo a pattern Solo x = MkSolo x\n\nMore on that in the NoListTuplePuns section of this report (4th topic).\n\nCompared to @-binders, namespace specifiers in pragmas felt like low-hanging\nfruit. It was quite clear what modifications to the compiler were necessary.\nThe proposal was accepted back in 2017, and was laying around waiting for\nsomeone to come along and submit a patch. Our work on dependent types has\nfinally forced that thunk.\n\n##\n\nRefactoring of exact-print annotations (EPA)\n\nOur third topic is a refactoring of exact-print annotations. This is mostly an\ninternal change, affecting only GHC developers and GHC API users.\n\nThe point is this: adding support for dependent types requires various\nsyntactic additions and changes to the Haskell AST (e.g. extending the HsExpr\ntype with new constructor for \u201ctypes-in-terms\u201d), so we better have a clear\nvision of how the AST should be structured. However, there is an ongoing\neffort (mostly driven by Alan Zimmerman) to extend GHC with capabilities for\nautomatic refactoring. Part of this effort is the addition of exact-print\nannotations, allowing GHC to faithfully pretty-print a parsed program. The\nproblem is that this too requires extensive modification to the AST.\n\nSo instead of stepping on each other\u2019s toes, we discussed the design in #23447\n\u201cWhere should tokens live in the abstract syntax tree?\u201d\", found a satisfying\nsolution and collaborated on its implementation. There is still work to do,\nbut now it is clear where we are heading and how new AST constructors should\nbe structured.\n\nThis unblocks the work on those parts of Dependent Haskell that require AST\nmodification, and, hopefully, it means that the new features will work\ncorrectly with exact-print.\n\n##\n\nPun-free syntax for list and tuple types\n\nLet us conclude the report with a feature that was designed and implemented in\na spontaneous collaboration with Torsten Schmits (Tweag).\n\nOriginally, the design for pun-free syntax for list and tuple types was a part\nof GHC Proposal #281 \u201cVisible forall\u201d. You might be familiar with it from our\nprevious reports where we talked about visible dependent quantification forall\na -> t. However, the size and complexity of the specification quickly spiraled\nout of control, so non-punning syntax was factored out into a separate\nproposal, namely GHC Proposal #475 \u201cNon-punning list and tuple syntax\u201d\n(written 2021, accepted 2022). See the proposal for the motivation and\nspecification.\n\nThe main payload of the proposal is to rename [] to List, (,) to Tuple<n>, and\nintroduce the ListTuplePuns extension for the legacy syntax. Our team at\nSerokell started the implementation in small incremental steps, e.g. commits\n02279a9c37 and a13affce1a. We were going to slowly chip away at it, but we\nwere focusing on other tasks and the progress was slow. Thankfully, Torsten\ntook the initiative and implemented the majority of the proposed changes in\ncommit d91d00fccf.\n\nThere is one remaining issue with type inference that prevents us from\ndefining Tuple and Constraints type families, and at the moment, it is not\nclear how to address it. Enthusiasts can already switch to non-punning syntax\nby specifyig NoListTuplePuns in GHC 9.10, though the majority of developers\nmight want to wait until Tuple and Constraints are available.\n\nNon-punning syntax is a positive change in its own right, as the proposal\nargues. Consider, for example:\n\n    \n    \n    single :: [Int] single = [5] just :: Maybe Int just = Maybe 5\n\nCan you spot the mistake? It is somehow valid to use brackets [] both for the\nlist type and its value, yet the same can\u2019t be said about Maybe or many other\ndata types. This irregular design has been a source of confusion for\nnewcomers, so we find it preferable to always use distinct syntax for types\nand terms:\n\n    \n    \n    single :: List Int single = [5] just :: Maybe Int just = Just 5\n\nAs we move towards dependent types, the problem becomes more prominent.\nExtensions such as DataKinds and RequiredTypeArguments already allow terms to\noccur in types and vice versa, e.g.\n\n    \n    \n    f :: T (Just 10) -- promoted term (Just 10) in a type x = g (Maybe Int) -- type (Maybe Int) in a term\n\nThe eventual goal is to unify term and type syntax, and this means we want to\navoid ambiguous/punned constructor names, e.g. [a] (type of a list) vs [a]\n(list of one element). The introduction of NoListTuplePuns is a big step\ntowards this goal.\n\n##\n\nFeatures in GHC 9.10\n\nWe are proud to say that our GHC team continues to design and implement new\nHaskell features, both through our own efforts and in collaboration with other\ncontributors, in the true spirit of open-source development. In particular, we\nwould like to highlight two features shipped with GHC 9.10: TypeAbstractions\nand RequiredTypeArguments.\n\n  * TypeAbstractions is a language extension that enables @-binders in type declarations, function equations, and other contexts. User\u2019s Guide section 6.4.17. Type abstractions.\n  * RequiredTypeArguments is a language extension that enables visible forall forall a -> t in types of terms. User\u2019s Guide section 6.4.18. Required type arguments.\n\nAs with all new features, expect some rough edges, but we look forward to\nfeedback from early adopters.\n\n##\n\nPrevious updates on dependent types\n\n  * Serokell\u2019s Work on GHC: Dependent Types, Part 2, 22-12-2023 (Serokell Blog)\n  * Serokell\u2019s Work on GHC: Dependent Types, 2023-09-12 (Serokell Blog)\n  * GHC+DH Weekly Update #7, 2023-06-14 (Discourse)\n  * GHC+DH Weekly Update #6, 2023-06-07 (Discourse)\n  * GHC+DH Weekly Update #5, 2023-01-25 (Discourse)\n  * GHC+DH Weekly Update #4, 2023-01-18 (Discourse)\n  * GHC+DH Weekly Update #3, 2023-01-11 (Discourse)\n  * GHC+DH Weekly Update #2, 2022-12-21 (Discourse)\n  * GHC+DH Weekly Update #1, 2022-12-07 (Discourse)\n\n##\n\nStay tuned\n\nThis was the third blog post of our series \u201cWork on GHC: Dependent Types\u201d. We\nare commited to our vision of dependently-typed programming in Haskell, so\nstay tuned for future updates!\n\ntagged:\n\nGHCHaskell\n\nShare:\n\n2 upvotes\n\nGet new articles via email\n\nNo spam \u2013 you'll only receive stuff we\u2019d like to read ourselves.\n\nSerokell\u2019s Work on GHC: Dependent Types, Part 3\n\n  * Summary\n  * @-binders in lambdas and function equations\n  * Namespace specifiers in fixity declarations and pragmas\n  * Refactoring of exact-print annotations (EPA)\n  * Pun-free syntax for list and tuple types\n  * Features in GHC 9.10\n  * Previous updates on dependent types\n  * Stay tuned\n\nMore from Serokell\n\nSerokell\u2019s Work on GHC: Dependent Types, Part 2\n\nAt Serokell, we have a dedicated team working on GHC. The primary goal is to\nhelp add dependent types to Haskell, as outlined in GHC proposal #378, Design\nfor Dependent Types..\n\nDecember 22nd, 2023\n\n6 min read\n\nSerokell\u2019s Work on GHC: Dependent Types\n\nAt Serokell, we have been working hard for some time now to help add dependent\ntypes to Haskell. It is the primary goal of our dedicated GHC team, currently\nconsisting of Vladislav Zavialov and Andr...\n\nSeptember 12th, 2023\n\n6 min read\n\nHaskell in Production: Chordify\n\nIn this edition of our \u201cHaskell in Production\u201d series, we interview Jeroen\nBransen from Chordify, an online platform, which turns any music or song into\nchords. Jeroen has been working at Chordify since 2016. We discussed how\nChordify ensures the correctness of Haskell code and scalability of its\ncodebase, which libraries they use in their work, and more.\n\nDecember 28th, 2023\n\n6 min read\n\n(+372) 699-1531\n\nhi@serokell.io\n\nPille tn 7/5-13, Kesklinna linnaosa, Tallinn, Harju maakond, 10135, Estonia\n\nSerokell: Rate5.0based on 9 Google Business reviews\n\nBiotechBlockchainFintechManaged IT ServicesML ConsultingBig Data\nConsultingCI/CD and SRE ServicesSmart Contract AuditNLP Service ProviderOil &\nGas Custom IT SolutionsElixir DevelopmentHaskell DevelopmentNix\nDevelopmentPython DevelopmentRust DevelopmentTypeScript DevelopmentHow We\nWorkPrivacy Policy\n\n\u00a9 2015\u20132024 Serokell\n\n", "frontpage": false}
