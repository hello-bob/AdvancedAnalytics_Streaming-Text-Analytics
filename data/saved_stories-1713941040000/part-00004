{"aid": "40137831", "title": "Are batch scripts a security vulnerability?", "url": "https://chrisdenton.dev/p/batcmd/", "domain": "chrisdenton.dev", "votes": 2, "user": "todsacerdoti", "posted_at": "2024-04-23 21:57:31", "comments": 0, "source_title": "Are batch scripts a security vulnerability?", "source_text": "Are batch scripts a security vulnerability? - Chris Denton\n\n# Chris Denton\n\n23 April 2024\n\n# Are batch scripts a security vulnerability?\n\nA few weeks back a CVE landed that affected practically every language's\nstandard library on Windows. RyotaK has a very detailed write up that you\nshould definitely read if you haven't already: BatBadBut: You can't securely\nexecute commands on Windows. The short version is that sending untrusted\narguments to even a trusted batch script is a vulnerability because the shell\ngets involved before the script is even run (more on that in a sec).\n\nHowever, different languages reacted to it differently:\n\n  * Some (like Rust) issued a fix.\n  * Some others only documented the issue.\n  * Still others did nothing at all.\n\nA question I've been asked a fair bit since then is why there were this range\nof responses. I can't speak for other languages but I can try to explain why\nRust considered this a library vulnerability and speculate why others may be\neither reluctant to patch or else not consider this critical enough to fix.\n\nSo why does Rust think this is a library vulnerability? Let me try to\nexplain...\n\n## Running scripts\n\nOn Linux a bash script can be run like this:\n\n    \n    \n    bash script.sh one two three\n\nThis runs script.sh with the arguments one, two and three. If you use an exec*\nfunction to execute bash, and not a shell, then the arguments are passed\ndirectly to the script.\n\nOk but imagine for a second that this way of running bash scripts didn't\nexist. Well there is another way:\n\n    \n    \n    bash -c \"script.sh one two three\"\n\nThis will do the same thing but the big difference is that the arguments are\nevaluated by bash. In this case it's harmless but you can see how it could be\nused for more nefarious purposes...\n\n    \n    \n    bash -c \"script.sh && rm -rf ./\"\n\nThis is in essence the issue with running .bat files on Windows. cmd.exe\nrequires you to use cmd.exe /c to run batch scripts meaning the whole command\nis evaluated by the the script interpreter.\n\n## CreateProcess and standard library vulnerabilities\n\nCreateProcess is the Windows API used to spawn a new process. It has a fun,\nundocumented, feature that it'll automatically run .bat (and .cmd) files using\ncmd.exe /c without even telling you. I say \"undocumented\" but this is actually\nanti-documented:\n\n> To run a batch file, you must start the command interpreter; set\n> lpApplicationName to cmd.exe and set lpCommandLine to the following\n> arguments: /c plus the name of the batch file.\n\nIt's telling you that you must do the cmd.exe /c dance manually. Only this\nisn't true and it's easy for people to accidentally discover it isn't true.\n\nSo if you run the following in Rust 1.0:\n\n    \n    \n    Command::new(\"script.bat\").arg(\"&calc\").spawn();\n\nIt will run cmd /c script.bat &calc, causing calc.exe to be spawned. The same\nwas true of any language, and still is for those who haven't patched. That's\nthe library vulnerability.\n\nNote that this has nothing to do with script.bat itself. You may have a batch\nscript that the foremost experts in all the land have verified is safe and\nsecure, yet it would still be vulnerable because the script is not involved at\nall. In short this is somewhat akin to passing an untrusted string to eval in\nmany languages.\n\nThis also has nothing to do with the way arguments are passed to new processes\non Windows (although that is relevant to the workaround). If standard\nlibraries (or the OS!) automatically ran bash scripts using bash -c on Linux\nthen they would also be vulnerable. Unless of course the library function,\nlike system, documents that commands are run in a shell.\n\nThe fix here would be for cmd.exe to be able to have some way of passing on\narguments to scripts without first evaluating them as commands to run. However\nlanguage standard libraries obviously cannot implement that. They can instead\nworkaround the issue by escaping arguments, as RyotaK's article explains.\n\n## So why didn't some languages patch this?\n\nI would reiterate here that I can't speak for other languages, only offer\nspeculation as to why their security teams would interpret the same issue\ndifferently. With that disclaimer out of the way, I'd suggest it's some\ncombination of the following:\n\n  1. They disagree that this issue is as critical as claimed. This is after all a feature of Windows that has existed for decades and isn't exactly a secret, even if undocumented. It could also be argued that if there's any fault then the blame lies with the OS and not with libraries that simply wrap OS APIs.\n\n  2. They didn't want to make a breaking change. The workaround by Rust and others might be considered a breaking change, however hard it tries to avoid any real-world breakage. Also some (hopefully few) people may have actually been counting on the command injection for some reason. Those people could've just used cmd /c directly but maybe they didn't want to.\n\n  3. They already documented that untrusted arguments are a vulnerability. A broad enough disclaimer can cover this and any future CVE related to process arguments, all without ever needing to update their standard library or even documentation.\n\n## A niche issue?\n\nI'll end by admitting this is perhaps a more niche issue than it's 10/10\ncritical rating on github might suggest even if I agree that it is indeed a\nlibrary vulnerability. I suspect most people aren't in fact passing untrusted\ninput (e.g. from the internet) to batch scripts. Or if they are then they at\nleast validate the input.\n\nBut for those people who are unavoidably affected, having some way to avoid\ncommand injection attacks is undoubtedly critical.\n\n", "frontpage": false}
