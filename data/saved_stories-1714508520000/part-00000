{"aid": "40211065", "title": "Understand Internals of Std:Expected", "url": "https://www.cppstories.com/2024/expected-cpp23-internals/", "domain": "cppstories.com", "votes": 1, "user": "ibobev", "posted_at": "2024-04-30 14:04:50", "comments": 0, "source_title": "Understand internals of std::expected", "source_text": "Understand internals of std::expected - C++ Stories\n\nC++ Stories\n\nStay up-to-date with Modern C++\n\nLast Update: 30 April 2024\n\n# Understand internals of std::expected\n\nTable of Contents\n\nIn the article about std::expected, I introduced the type and showed some\nbasic examples, and in this text, you\u2019ll learn how it is implemented.\n\n## A simple idea with struct\n\nIn short, std::expected should contain two data members: the actual expected\nvalue and the unexpected error object. So, in theory, we could use a simple\nstructure:\n\n    \n    \n    template <class _Ty, class _Err> struct expected { /*... lots of code ... */ _Ty _Value; _Err _Unexpected; };\n\nHowever, there are better solutions than this. Here are some obvious issues\nfor our \u201cstruct\u201d approach.\n\n  * The size of the object is the sum of the Value type and the Error type (plus padding if needed).\n  * Two data members are \u201cactive\u201d and initialized, which might not be possible - for example, what if the Value type has no default constructor? The Standard requires that std::expected\" holds either a value of type Tor an error of typeE` within its storage.\n  * We\u2019d have to guarantee that _Ty cannot be a reference type or an array type; it must be a Destructible Type.\n  * Similarly for the _Err type we have to guarantee that it\u2019s also Destructible, and must be a valid template argument for std::unexpected (so not an array, non-object type, nor cv-qualified type).\n  * Plus, we\u2019d have to write a lot of code that creates an API for the type\n\n## How about std::variant?\n\nOk, since we want to have a more compact type, why not use std::variant?\n\nstd::variant is a tagged union, so it holds only one of the list of types and\nhas an efficient way to switch between them.\n\nWe can try with the following code:\n\n    \n    \n    template<typename T, typename E> using expected = std::variant<T, std::unexpected<E>>;\n\nHowever, std::variant does not provide some specific behaviors that\nstd::expected might need, such as conditional explicit constructors and\nassignment operators based on the contained types\u2019 properties. So, additional\nwork would be required to implement these properly.\n\nFurthermore, std::variant has to be very generic and offers a way to handle\nmany alternative types in one object, which is \u201ctoo much\u201d for the expected\ntype, which needs only two alternatives.\n\n## Real implementation\n\nLet\u2019s look at some open implementations and see what\u2019s under the hood.\n\nWe can go to the Microsoft STL repository:\n\nhttps://github.com/microsoft/STL/blob/main/stl/inc/expected\n\nThe expected class uses a union to store either a value of type _Ty or an\nerror of type _Err:\n\n    \n    \n    _EXPORT_STD template <class _Ty, class _Err> class expected { /*... lots of code ... */ union { _Ty _Value; _Err _Unexpected; }; bool _Has_value; };\n\nHere, _Value and _Unexpected are two data members that share the same memory\nlocation within an instance of expected. Which member of the union is\ncurrently active (i.e., contains valid data) is not tracked by the union\nitself. Therefore, the expected class maintains an additional boolean member,\n_Has_value, to track whether the union currently holds a _Ty value (_Has_value\nis true) or an _Err error (_Has_value is false).\n\nAs you can see, this approach is much more advanced than our simple structure\nand uses some ideas from std::variant.\n\n## Size of Objects:\n\nThe size of an expected object depends on several factors:\n\n  1. Size of _Ty and _Err: The size of the union will be at least as large as the size of its largest member because the union allocates enough space to hold the largest member.\n  2. Alignment: we have to honour _Ty\u2019s and _Err\u2019s alignment requirements.\n  3. Boolean _Has_value: There\u2019s also a boolean member variable _Has_value indicating which member of the union is active. This adds to the total size of the class.\n\nSo, the total size of an expected<_Ty, _Err> object will be approximately:\n\n    \n    \n    max(sizeof(_Ty), sizeof(_Err)) + sizeof(bool) + possible padding for alignment\n\nHere are some examples of the sizes on GCC x64:\n\n    \n    \n    Type: int Size: 4 Type: std::string Size: 32 Sizeof std::expected: 40 Type: int Size: 4 Type: double Size: 8 Sizeof std::expected: 16 Type: int Size: 4 Type: std::pair<int, int> Size: 8 Sizeof std::expected: 12\n\nYou can check the code here: @Compiler Explorer.\n\n## Going further down\n\nLet\u2019s have a look at some other member functions:\n\n    \n    \n    _NODISCARD constexpr const _Ty& value() const& { if (_Has_value) { return _Value; } _Throw_bad_expected_access_lv(); } _NODISCARD constexpr _Ty& value() & { if (_Has_value) { return _Value; } _Throw_bad_expected_access_lv(); }\n\nThose are relatively simple: they check the flag and return the value.\n\nOn the other hand, one of the overloads for the assignment operators (see at\nthis line) is more complex:\n\n    \n    \n    constexpr expected& operator=(const expected& _Other) noexcept( is_nothrow_copy_constructible_v<_Ty> && is_nothrow_copy_constructible_v<_Err> && is_nothrow_copy_assignable_v<_Ty> && is_nothrow_copy_assignable_v<_Err>) // strengthened requires _Expected_binary_copy_assignable<_Ty, _Err> { if (_Has_value && _Other._Has_value) { _Value = _Other._Value; } else if (_Has_value) { _Reinit_expected(_Unexpected, _Value, _Other._Unexpected); } else if (_Other._Has_value) { _Reinit_expected(_Value, _Unexpected, _Other._Value); } else { _Unexpected = _Other._Unexpected; } _Has_value = _Other._Has_value; return *this; }\n\nThe _Reinit_expected template function manages the transition of an\nstd::expected object from one state to another. Because the code uses union,\nit has to manage the lifetime of alternatives.\n\n## Other implementations\n\n  * In GCC libstdc++ - expected @ Github - it also uses union to hold the alternatives\n  * In LLVM libc++: expected @Github - in many places it uses no_unique_address attribute and Empty Base Class Optimization so in theory if might use less space than the regular union approach.\n\n## Summary\n\nIn this text, I covered a rough idea of how to implement the std::expected\ntype. As you can see, it\u2019s not just a simple structure of <ValueT, ErrorT> and\ncontains a lot of tricks to fulfill all of the requirements.\n\nI believe that understanding and appreciating the patterns within the Standard\nLibrary can be valuable, even if we don\u2019t need to delve too deeply into its\nimplementation in our everyday C++ tasks.\n\nSee the introduction to std::expected in my previous article.\n\nI've prepared a valuable bonus if you're interested in Modern C++! Learn all\nmajor features of recent C++ Standards! Check it out here:\n\nDownload a free copy of C++20/C++17 Ref Cards!\n\n#### Similar Articles:\n\n  * Using std::expected from C++23\n  * Parsing Numbers At Compile Time with C++17, C++23, and C++26\n  * Six Handy Operations for String Processing in C++20/23\n  * How to use std::span from C++20\n  * Spans, string_view, and Ranges - Four View types (C++17 to C++23)\n\nTags: cpp, cpp23, standard library, vocabulary types,\n\nTable of Contents\n\n#### See My Books:\n\n#### Recent Articles\n\nUnderstand internals of std::expected\n\nUsing std::expected from C++23\n\nParsing Numbers At Compile Time with C++17, C++23, and C++26\n\n\u00a9 2011-2022, Bartlomiej Filipek Disclaimer: Any opinions expressed herein are\nin no way representative of those of my employers. All data and information\nprovided on this site is for informational purposes only. I try to write\ncomplete and accurate articles, but the web-site will not be liable for any\nerrors, omissions, or delays in this information or any losses, injuries, or\ndamages arising from its display or use. This site contains ads or referral\nlinks, which provide me with a commission. Thank you for your understanding.\nBuilt on the Hugo Platform!\n\n", "frontpage": false}
