{"aid": "40155351", "title": "Vercel to Self-Hosted Next.js", "url": "https://prototypr.io/post/nextjs-selfhost-vercel", "domain": "prototypr.io", "votes": 3, "user": "Akcium", "posted_at": "2024-04-25 09:37:35", "comments": 0, "source_title": "Vercel to Self-Hosted Next.js: Setting up Zero Downtime Deploys with GitHub Actions", "source_text": "Vercel to Self-Hosted Next.js: Setting up Zero Downtime Deploys with GitHub\nActions\n\n\ud83d\udc4b\n\nPublished April 24, 2024\n\n# Vercel to Self-Hosted Next.js: Setting up Zero Downtime Deploys with GitHub\nActions\n\nBy Graeme Fulton\n\n\"It works fine locally. What's gone wrong?\" \u2013 the inevitable (and eternal?)\ndilemma of deployment, as if the actual coding wasn't hard enough (even today\nwith the help of AI)! Software development can be a real maze - solving one\nissue often unravels another:\n\n> Building software is like having a giant house of cards in our brains Idan\n> Gazit on Developer Experience\n\nWith countless moving parts to juggle, tools that ease the transition from\ncode to shipped product are real game-changers. For me, Vercel's developer\nexperience did just that. It would seamlessly deploy and host my NextJS app\n(this site!) from a single 'Git push'. The zero-downtime deployments, and\nknowing it rolls back if something goes wrong gave me peace of mind. I could\njust focus on the creating, not managing servers!\n\n## From Serverless to Self-host NextJS\n\nAlthough Serverless hosting provides so much convenience, the intricate\nbilling model brought a layer of complexity that ultimately compelled me to\nrevert to self-hosting. After experiencing the awesomeness of Vercel though, I\ncouldn't just go back to an old manual workflow.\n\nThis post therefore walks you through how I set up a self-hosted NextJS app\nwith a development workflow powered by GitHub Actions. It gives:\n\n  * Zero downtime \u2013 no downtime between deployments\n\n  * 'Roll back' \u2013 if the build fails, use the working version\n\n  * Auto Deploy - 'git push' to main\n\n  * Logs \u2013 See the View all the build logs and see build progress\n\nYou'll also find a couple script files you can copy and paste to create a\ndeploy experience along the lines of Vercel's.\n\nWith the recent discussions around serverless pricing vs self hosting, I hope\nthe post saves you some time if you're trying self-hosted NextJS.\n\nImproved infrastructure pricing \u2013 Vercel\n\nWe\u2019re reducing pricing on Vercel fundamentals like bandwidth and functions.\n\n...but first, enter Blue Green deployment: \ud83d\udc40\n\n# Blue Green Deployment\n\nBefore anything, let's understand the general workflow. The app will use a\n'Blue Green' deployment model, where we'll have 2 copies of the Next app side-\nby-side. Here's how it works:\n\n  * 2 versions of the same app - one called blue, one called green\n\n  * 1 live version at a given time (say the green one), and changes get deployed to the 'sleeping' version (or the blue one)\n\n  * If the build is successful, the sleeping app is turned on so is live. The other app is turned off, and is now the 'old version'.\n\nThis diagram from Candost's blog illustrates it really well:\n\nBlue green deployment strategy with traffic routed to blue app (source:\nCandost's blog).\n\nWhat is Blue-Green Deployment\n\nThe Blue-Green Deployment is an application deployment technique used in\ncontinuous delivery. The new service is deployed and put into production\ngradually.\n\nOverall it seems safe - if the build fails, nothing happens. There's no\ndowntime as the new build must work before the old one is turned off.\n\nHere's another article that explains blue green deployment in more depth -\nwhen I came across the concept, I thought this was all beyond me, but in\npractice I found it more straightforward.\n\nWhat is blue green deployment?\n\nBlue green deployment is an application release model that gradually transfers\nuser traffic from a previous version of an app or microservice to a nearly\nidentical new release\u2014both of which are running in production.\n\nLet's see how it's done in practice:\n\n# Server Setup and Deployment Guide\n\nTo get started with this 'blue green' setup, this guide assumes you have a\nserver running, preferably NGINX (but it should be possible with others like\nApache). I'm not going to walk you through setting that stuff up, but how to\nconfigure it all. The rest of the 'guide' is split into 2 parts:\n\n1\\. Server Setup\n\n  * Next Apps: Setting up the 2 NextJS apps (blue and green)\n\n  * NGINX/PM2: Configure the NGINX server and PM2 processes\n\n2\\. Deployment Guide\n\n  * Deploy: Add a deploy script to build the new deployment\n\n  * GitHub Actions: Configure GitHub Actions to trigger/log the build\n\nLet's begin the server setup with the NextJS app:\n\n# Part 1: Server Setup\n\nI started out with a single Next app running on the server using NGINX and PM2\nfirst. So let's do that first, then add the second Next app to create the blue\ngreen workflow.\n\n## A. Green App\n\nFollow these 3 parts to set up the green app:\n\nGreen app. Image source: What is Blue-Green Deployment\n\n  * Next App (green): The initial app was cloned from the Prototypr GitHub repo (give it a star \u2b50) - and the .next folder is built using npm run build. For the deploy script to work, call this folder next-app-green.\n\n  * PM2 (port 3000): The initial app is running on PM2, using the command below. If you're following my process, make sure your app name is \"green\", and you specify port 3000. That's important for later!\n\n    \n    \n    pm2 start npm --name \"green\" -- run start -- --port 3000\n\n  * NGINX (proxy_pass): The initial NGINX location block looked like below. It uses `proxy_pass` which points to the PM2 (the process manager) running on port 3000. Make sure you have this working first, then we'll make a couple tweaks for blue/green.\n\n    \n    \n    { location / { proxy_pass http://localhost:3000; proxy_http_version 1.1; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection 'upgrade'; proxy_set_header Host $host; proxy_cache_bypass $http_upgrade; } }\n\nBe sure your app is turned on by running PM2 ls - it will say 'online' in the\nstatus column.\n\n## B. Blue app\n\nBlue app. Source: What is Blue-Green Deployment\n\nHere's the bits for the blue app, and to get the blue green concept set up:\n\n  * Next App (blue): Now clone the same Next app Github repo into a new directory called it next-app-blue (the name is important for the deploy script in part 2)\n\n  * PM2 (port 3001): start your blue version with the following command. Ensure the --name flag is blue, and the --port flag is 3001:\n\n    \n    \n    pm2 start npm --name \"blue\" -- run start -- --port 3001\n\n  * NGINX (upstream): this is the cool part! With 1 additional block in the NGINX, we can have both apps running at the same time with these 2 changes:\n\n    1. Add an 'upstream' block is at the top, that directs to both of our running PM2 processes (localhost:3000 and localhost:3001).\n\n    2. Change the original proxy_pass to http:// + the name of the upstream block. In this case it is http://bluegreen, but you can call it anything.\n\n    \n    \n    upstream bluegreen { server localhost:3000 weight=1; server localhost:3001 weight=1; } server { server_name yourdomain.com; location / { proxy_pass http://bluegreen; #proxy_pass http://localhost:3000; ... } }\n\n## It's called Load Balancing\n\nNGINX load balancing concept. From this youtube vid\n\nThis is actually called load balancing - the requests to the domain will be\nsent to either of your running apps. If one of the apps is stopped, all\nrequests will go to the other running app. Load balancing sounded really\ncomplicated to me, but it was done it with those 2 changes. Here's more info\non it with NGINX:\n\nSimple Load Balancing | NGINX\n\nAn example NGINX configuration that performs simple load balancing.\n\nWhat Is Load Balancing? How Load Balancers Work\n\nLoad balancing is the distribution of incoming network traffic accross a group\nof backend servers.\n\nLast step for this section: now both apps running, stop one of them using pm2\nstop green (or blue). At this stage, running pm2 ls will produce a table like\nbelow - 1 app online, the other stopped (doesn't matter which way around):\n\nPM2 ls output showing blue app running, and green app stopped.\n\nAll the traffic is therefore going through 1 app.\n\n# Part 2: Deployment Guide\n\nWith that Blue/Green server setup done, there's 2 parts left. You can paste my\nscripts for both of these, but there's a little bit of configuring to do to\nset up SSH keys for GitHub:\n\n  1. Deploy Script: Add a deploy.sh script on the server that will create the latest build, and fail gracefully if anything goes wrong.\n\n  2. GitHub Actions: Set up GitHub actions to trigger a deployment when you push to the main branch\n\nVisual from GitHub actions site, showing automated build\n\n## 1\\. Deploy Script\n\nThis is the script that will be triggered by a GitHub action when you push to\nyour main branch. Find it below- you can copy paste it into a file called\ndeploy.sh (or whatever), and put it in your user's home directory.\n\nThe script seems long, but I've added comments to explain what's happening.\nHere's an overview:\n\n  * Checks live app: It first determines which app is running in PM2 - if green is running, set the deploy folder to blue. If blue is running, deploy to green folder.\n\n  * Builds new deployment: Then it navigates to the deployment folder, runs git pull, npm install, and next build. If anything fails, it will display in the console. (if nvm isn't installed you'll get an error)\n\n  * Starts new deployment: If everything builds without errors, it will start the new app and stop the old one. Otherwise, it will just fail, leaving your live app still running.\n\nIf you've set up the folders with the same names as outlined throughout,\nyou'll be able to paste this into your deploy.sh file and it should work with\nminimal changes. You should test it after you paste it in:\n\n    \n    \n    #!/bin/bash #both app folders start with 'next-app' LIVE_DIR_PATH=/var/www/html/next-app #add the suffixes to the app folders BLUE_DIR=$LIVE_DIR_PATH-blue GREEN_DIR=$LIVE_DIR_PATH-green # set up variables to store the current live and deploying to directories CURRENT_LIVE_NAME=false CURRENT_LIVE_DIR=false DEPLOYING_TO_NAME=false DEPLOYING_TO_DIR=false # this checks if the green and blue apps are running GREEN_ONLINE=$(pm2 jlist | jq -r '.[] | select(.name == \"green\") | .name, .pm2_env.status' | tr -d '\\n\\r') BLUE_ONLINE=$(pm2 jlist | jq -r '.[] | select(.name == \"blue\") | .name, .pm2_env.status' | tr -d '\\n\\r') # if green is running, set the current live to green and 'deploying to' is blue if [ \"$GREEN_ONLINE\" == \"greenonline\" ]; then echo \"Green is running\" CURRENT_LIVE_NAME=\"green\" CURRENT_LIVE_DIR=$GREEN_DIR DEPLOYING_TO_NAME=\"blue\" DEPLOYING_TO_DIR=$BLUE_DIR fi # if blue is running, set the current live to blue and 'deploying to' is green if [ \"$BLUE_ONLINE\" == \"blueonline\" ]; then echo \"Blue is running\" CURRENT_LIVE_NAME=\"blue\" CURRENT_LIVE_DIR=$BLUE_DIR DEPLOYING_TO_NAME=\"green\" DEPLOYING_TO_DIR=$GREEN_DIR fi # if both green and blue are running, set 'deploying to' to blue if [ \"$GREEN_ONLINE\" == \"greenonline\" ] && [ \"$BLUE_ONLINE\" == \"blueonline\" ]; then echo \"Both blue and green are running\" DEPLOYING_TO_DIR=$BLUE_DIR fi # display the current live and deploying to directories echo \"Current live: $CURRENT_LIVE_NAME\" echo \"Deploying to: $DEPLOYING_TO_NAME\" echo \"Current live dir: $CURRENT_LIVE_DIR\" echo \"Deploying to dir: $DEPLOYING_TO_DIR\" # Navigate to the deploying to directory cd $DEPLOYING_TO_DIR || { echo 'Could not access deployment directory.' ; exit 1; } # use the correct node version # Load nvm export NVM_DIR=\"$HOME/.nvm\" [ -s \"$NVM_DIR/nvm.sh\" ] && \\. \"$NVM_DIR/nvm.sh\" # This loads nvm nvm use 18.17.0 || { echo 'Could not switch to node version 18.17.0' ; exit 1; } # load the .env file source .env.local || { echo 'The ENV file does not exist' ; exit 1; } # Pull the latest changes # clear any changes to avoid conflicts (usually permission based) git reset --hard || { echo 'Git reset command failed' ; exit 1; } git pull -f origin main || { echo 'Git pull command failed' ; exit 1; } # install the dependencies npm install --legacy-peer-deps || { echo 'npm install failed' ; exit 1; } # Build the project npm run build || { echo 'Build failed' ; exit 1; } # Restart the pm2 process pm2 restart $DEPLOYING_TO_NAME || { echo 'pm2 restart failed' ; exit 1; } # add a delay to allow the server to start sleep 5 # check if the server is running DEPLOYMENT_ONLINE=$(pm2 jlist | jq -r '.[] | select(.name == \"$DEPLOYING_TO_NAME\") | .name, .pm2_env.status' | tr -d '\\n\\r') if [ \"$DEPLOYMENT_ONLINE\" == \"$DEPLOYING_TO_NAMEonline\" ]; then echo \"Deployment successful\" else echo \"Deployment failed\" exit 1 fi # stop the live one which is out of date pm2 stop $CURRENT_LIVE_NAME;\n\nHere it is in a GitHub repo for easier access:\n\nGitHub - Prototypr/nextjs-deploy-script: Script to deploy NextJS with NGINX\nand PM2\n\nScript to deploy NextJS with NGINX and PM2. Contribute to Prototypr/nextjs-\ndeploy-script development by creating an account on GitHub.\n\nThat script was hard for someone who never wrote a bash script before! If you\nhave any improvements, they're welcome.\n\nBefore going to the next step, it's a good idea to make sure it works. Log\ninto your server and run it with ./deploy.sh. Fix any errors, and run pm2 ls\nagain to see if the correct app is running.\n\n## 2\\. Set up GitHub Actions\n\nAfter ensuring the deploy script works, and it is sitting in your user's home\ndirectory (cd ~/), we now need a GitHub action to run it when pushing to the\nmain branch. You can learn how to do it by pasting my action, or here's a\ndecent guide if you like reading:\n\nHandling Continuous Integration And Delivery With GitHub Actions \u2014 Smashing\nMagazine\n\nIn this article, Aleem Isiaka explains how you can deploy a basic NodeJS\napplication to Heroku, automate and schedule a deployment to run at certain\nintervals of the day, and use other actions from the Github Actions community.\n\n## Create the deploy.yml workflow file\n\nFrom the above article, this is a practical part to do now:\n\n> From the root of our application, create a folder named .github/workflows\n> that will contain all the GitHub action workflows inside this folder create\n> a file named action.yml, this file will hold the instructions for our\n> deployment process\n\nIn my workflow folder, I have a file called deploy.yaml - you can copy its\ncontents to your own yaml file:\n\nprototypr-frontend/.github/workflows/deploy.yml at main \u00b7 Prototypr/prototypr-\nfrontend\n\nOpen source publishing platform, built with Next.js and Strapi CMS backend.\nUses Tiptap / Prose-mirror editor. \ud83d\udc99 - Prototypr/prototypr-frontend\n\nUpon inspecting this deploy.yml, you can see in the first few lines that it\ngets triggered when pushing to the main branch. It also needs these 2\nenvironmental secrets to deploy on your server:\n\n    \n    \n    SERVER_HOST: ${{ secrets.SERVER_HOST }} SERVER_USER: ${{ secrets.SERVER_USER }} SERVER_SSH_PRIVATE_KEY: ${{ secrets.SERVER_SSH_PRIVATE_KEY }}\n\nLet's set that bit up:\n\n## Set up your server access secrets\n\nThe 3 secrets needed are these:\n\n  * SERVER_HOST is your server's IP address\n\n  * SERVER_USER is the username of the user where the deploy.sh script is\n\n  * SERVER_SSH_PRIVATE_KEY: your user's key to ssh into the server.\n\nAdd them to the environments secret section of your repo as shown here:\n\nSettings > Environments > Production\n\nSteps 1,2 and 3 of the following article by Gourab shows you how to do this\npart. That's what I followed to set up the secrets, and generate the ssh key\nneeded for SERVER_SSH_PRIVATE_KEY.\n\nAutomating Next.js Application Deployment with GitHub Actions\n\nAre you ready to supercharge your Next.js application deployment? With GitHub\nActions, the process...\n\nThat's pretty much it - pushing to the main branch should trigger the deploy\nscript on your server, and you can watch the build progress from GitHub\nitself. All the logs and progress from the deploy.sh script will be logged in\nGitHub. I don't think that happens if you use a webhook rather than SSH, which\nis why I think this is great:\n\nNextJS deploy logs in GitHub actions\n\nThat's all I got for now, didn't expect this post to be so long. Below are\nsome issues I ran into.\n\n## Star us on GitHub \u2b50\n\nIf this helped you, give the repository a star:\n\nGitHub - Prototypr/prototypr-frontend: Open source publishing platform, built\nwith Next.js and Strapi CMS backend. Uses Tiptap / Prose-mirror editor. \ud83d\udc99\n\nOpen source publishing platform, built with Next.js and Strapi CMS backend.\nUses Tiptap / Prose-mirror editor. \ud83d\udc99 - Prototypr/prototypr-frontend\n\nI'm trying out this GitHub sponsors thing to make more resources like this, so\ncheck that out too if you want to support open source efforts:\n\nSponsor @Prototypr on GitHub Sponsors\n\nSupport Prototypr\u2019s open source work\n\n# Troubleshooting\n\nHere are a couple issues I had connecting to my server from GitHub actions\n\n## Host key verification failed:\n\nOnce that's set up all should be ready to go, or you might get this error:\n\n    \n    \n    Run mkdir -p ~/.ssh/ Host key verification failed.\n\n> The \"Host key verification failed\" error typically means that the SSH client\n> was unable to verify the identity of the server. This can happen if the\n> server's host key has changed or if it's the first time you're connecting to\n> the server and its host key is not in your known_hosts file. (copilot\n> response)\n\nI fixed it by adding GitHub to my server's known hosts by following this:\n\nGitHub\u2019s SSH key fingerprints - GitHub Docs\n\nPublic key fingerprints can be used to validate a connection to a remote\nserver.\n\nThen added this to the deploy.yaml:\n\n    \n    \n    # Fetch the server's host key and add it to known_hosts ssh-keyscan -H ${{ secrets.SERVER_HOST }} >> ~/.ssh/known_hosts\n\n## Permission denied (publickey):\n\nOther issues I had when connecting via ssh was was:\n\n    \n    \n    Load key \"/home/runner/.ssh/id_rsa\": error in libcrypto @: Permission denied (publickey).\n\nThis happened because I pasted the wrong key to SERVER_SSH_PRIVATE_KEY, or\npasted it incorrectly by missing out (or including) the ssh-rsa part of the\nkey (can't remember how its should be, but pasting the keys correctly fixed\nthe permission denied issue.\n\nfin.\n\nGitHub - Prototypr/prototypr-frontend: Open source publishing platform, built\nwith Next.js and Strapi CMS backend. Uses Tiptap / Prose-mirror editor. \ud83d\udc99\n\nOpen source publishing platform, built with Next.js and Strapi CMS backend.\nUses Tiptap / Prose-mirror editor. \ud83d\udc99 - Prototypr/prototypr-frontend\n\nShare to your friends\n\n# Graeme Fulton\n\n### Making Prototypr and Letter.so\n\n# Welcome to Prototypr\n\nJoin today to make posts and grow with us.\n\n# Related Articles\n\n## Hugo Duprez\n\n\u00b7\n\nApr 25\n\n## What if Webflow + Integromat + Windows 95 style?\n\n## Graeme Fulton\n\n\u00b7\n\nApr 25\n\n## Using Framer Motion to Create Smooth Lazy Load Image Effects\n\n## Sophie Clifton-Tucker\n\n\u00b7\n\nApr 25\n\n## The Freemium Web: You\u2019ve Read All Your Free Articles This Month\n\n## Graeme Fulton\n\n\u00b7\n\nApr 25\n\n## Announcing Prototypr + Grant for the Web: Flagship Project \ud83c\udf89\n\nGet Prototypr Weekly\n\nTop articles and tools every week \ud83d\udc8c\n\n\u00a9 2024 Prototypr, All rights reserved.\n\nGood Stuff\n\n  * Help\n  * Open Source\n  * Prototypr Open\n  * Twitter\n  * Instagram\n\nOther Resources\n\n  * Adobe Fund for Design\n  * Grant for the Web\n  * Web Monetization\n  * Mail by Letter\n  * Privacy Policy\n\n", "frontpage": false}
