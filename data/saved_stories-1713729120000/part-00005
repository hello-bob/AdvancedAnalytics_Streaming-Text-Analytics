{"aid": "40104492", "title": "Lunatik: Lunatik is a framework for scripting the Linux kernel with Lua", "url": "https://github.com/luainkernel/lunatik", "domain": "github.com/luainkernel", "votes": 9, "user": "todsacerdoti", "posted_at": "2024-04-21 10:14:42", "comments": 0, "source_title": "GitHub - luainkernel/lunatik: Lunatik is a framework for scripting the Linux kernel with Lua.", "source_text": "GitHub - luainkernel/lunatik: Lunatik is a framework for scripting the Linux\nkernel with Lua.\n\nSkip to content\n\nSign in\n\n# Search code, repositories, users, issues, pull requests...\n\nSearch syntax tips\n\nSign in\n\nSign up\n\nYou signed in with another tab or window. Reload to refresh your session. You\nsigned out in another tab or window. Reload to refresh your session. You\nswitched accounts on another tab or window. Reload to refresh your session.\nDismiss alert\n\nluainkernel / lunatik Public\n\n  * Notifications\n  * Fork 15\n  * Star 117\n\nLunatik is a framework for scripting the Linux kernel with Lua.\n\n117 stars 15 forks Branches Tags Activity\n\nStar\n\nNotifications\n\n# luainkernel/lunatik\n\nThis commit does not belong to any branch on this repository, and may belong\nto a fork outside of the repository.\n\n13 Branches\n\n13 Tags\n\n## Folders and files\n\nName| Name| Last commit message| Last commit date  \n---|---|---|---  \n  \n## Latest commit\n\nglk0andlnetoprevent running already loaded scriptMar 27, 20249544739 \u00b7 Mar 27,\n2024Mar 27, 2024\n\n## History\n\n4,853 Commits  \n  \n### examples\n\n|\n\n### examples\n\n| limit the syscalls to track on examples/systrack.lua| Mar 18, 2024  \n  \n### include\n\n|\n\n### include\n\n| add klibc submodule and use it for setjmp/longjmp| Nov 14, 2023  \n  \n### klibc @ 3dfe5b3\n\n|\n\n### klibc @ 3dfe5b3\n\n| fix FPAC exception on arm64's setjmp/longjmp| Mar 18, 2024  \n  \n### lib\n\n|\n\n### lib\n\n| allow creating objects that sleep accordingly to runtime sleep property| Jan\n24, 2024  \n  \n### lua @ ee330a4\n\n|\n\n### lua @ ee330a4\n\n| update lua/ to fix <time.h> include| Jul 13, 2023  \n  \n### .gitignore\n\n|\n\n### .gitignore\n\n| update .gitignore| Mar 15, 2023  \n  \n### .gitmodules\n\n|\n\n### .gitmodules\n\n| fix FPAC exception on arm64's setjmp/longjmp| Mar 18, 2024  \n  \n### Kbuild\n\n|\n\n### Kbuild\n\n| disable UBSAN_SANITIZE| Mar 18, 2024  \n  \n### Makefile\n\n|\n\n### Makefile\n\n| enable building against a custom kernel| Mar 18, 2024  \n  \n### README.md\n\n|\n\n### README.md\n\n| limit the syscalls to track on examples/systrack.lua| Mar 18, 2024  \n  \n### gensymbols.sh\n\n|\n\n### gensymbols.sh\n\n| autogenerate exported symbols| Mar 15, 2023  \n  \n### lunatik\n\n|\n\n### lunatik\n\n| allow running non-sleepable rutimes from the command line| Jan 24, 2024  \n  \n### lunatik.h\n\n|\n\n### lunatik.h\n\n| bump lunatik version to 3.4| Mar 6, 2024  \n  \n### lunatik.lua\n\n|\n\n### lunatik.lua\n\n| prevent running already loaded script| Mar 27, 2024  \n  \n### lunatik_aux.c\n\n|\n\n### lunatik_aux.c\n\n| allow creating objects that sleep accordingly to runtime sleep property| Jan\n24, 2024  \n  \n### lunatik_conf.h\n\n|\n\n### lunatik_conf.h\n\n| add lunatik_lookup()| Jan 15, 2024  \n  \n### lunatik_core.c\n\n|\n\n### lunatik_core.c\n\n| avoid requiring lunatik library on non-sleepable runtimes| Jan 24, 2024  \n  \n### lunatik_obj.c\n\n|\n\n### lunatik_obj.c\n\n| allow creating objects that sleep accordingly to runtime sleep property| Jan\n24, 2024  \n  \n### lunatik_run.c\n\n|\n\n### lunatik_run.c\n\n| add lunatik object| Dec 16, 2023  \n  \n## Repository files navigation\n\n# Lunatik\n\nLunatik is a framework for scripting the Linux kernel with Lua. It is composed\nby the Lua interpreter modified to run in the kernel; a device driver (written\nin Lua =)) and a command line tool to load and run scripts and manage runtime\nenvironments from the user space; a C API to load and run scripts and manage\nruntime environments from the kernel; and Lua APIs for binding kernel\nfacilities to Lua scripts.\n\nHere is an example of a character device driver written in Lua using Lunatik\nto generate random ASCII printable characters:\n\n    \n    \n    -- /lib/modules/lua/passwd.lua -- -- implements /dev/passwd for generate passwords -- usage: $ sudo lunatik run passwd -- $ head -c <width> /dev/passwd local device = require(\"device\") local linux = require(\"linux\") local function nop() end -- do nothing local s = linux.stat local driver = {name = \"passwd\", open = nop, release = nop, mode = s.IRUGO} function driver:read() -- read(2) callback -- generate random ASCII printable characters return string.char(linux.random(32, 126)) end -- creates a new character device device.new(driver)\n\n## Usage\n\n    \n    \n    make sudo make install sudo lunatik # execute Lunatik REPL Lunatik 3.4 Copyright (C) 2023-2024 ring-0 Ltda. > return 42 -- execute this line in the kernel 42\n\n### lunatik\n\n    \n    \n    usage: lunatik [load|unload|reload|status|list] [run|spawn|stop <script>]\n\n  * load: load Lunatik kernel modules\n  * unload: unload Lunatik kernel modules\n  * reload: reload Lunatik kernel modules\n  * status: show which Lunatik kernel modules are currently loaded\n  * list: show which runtime environments are currently running\n  * run: create a new runtime environment to run the script /lib/modules/lua/<script>.lua\n  * spawn: create a new runtime environment and spawn a thread to run the script /lib/modules/lua/<script>.lua\n  * stop: stop the runtime environment created to run the script <script>\n  * default: start a REPL (Read\u2013Eval\u2013Print Loop)\n\n## Lua Version\n\nLunatik 3.4 is based on Lua 5.4 adapted to run in the kernel.\n\n### Floating-point numbers\n\nLunatik does not support floating-point arithmetic, thus it does not support\n__div nor __pow metamethods and the type number has only the subtype integer.\n\n### Lua API\n\nLunatik does not support both io and os libraries, and the given identifiers\nfrom the following libraries:\n\n  * debug.debug, math.acos, math.asin, math.atan, math.ceil, math.cos, math.deg, math.exp, math.floor, math.fmod, math.huge. math.log, math.modf, math.pi, math.rad, math.random, math.randomseed, math.sin, math.sqrt, math.tan, math.type, package.cpath.\n\nLunatik modifies the following identifiers:\n\n  * _VERSION: is defined as \"Lua 5.4-kernel\".\n  * collectgarbage(\"count\"): returns the total memory in use by Lua in bytes, instead of Kbytes.\n  * package.path: is defined as \"/lib/modules/lua/?.lua;/lib/modules/lua/?/init.lua\".\n  * require: only supports built-in or already linked C modules, that is, Lunatik cannot load kernel modules dynamically.\n\n### C API\n\nLunatik does not support luaL_Stream, luaL_execresult, luaL_fileresult,\nluaopen_io and luaopen_os.\n\nLunatik modifies luaL_openlibs to remove luaopen_io and luaopen_os.\n\n## Lunatik C API\n\n    \n    \n    #include <lunatik.h>\n\n#### lunatik_runtime\n\n    \n    \n    int lunatik_runtime(lunatik_object_t **pruntime, const char *script, bool sleep);\n\nlunatik_runtime() creates a new runtime environment then loads and runs the\nscript /lib/modules/lua/<script>.lua as the entry point for this environment.\nIt must only be called from process context. The runtime environment is a\nLunatik object that holds a Lua state. Lunatik objects are special Lua\nuserdata which also hold a lock type and a reference counter. If sleep is\ntrue, lunatik_runtime() will use a mutex for locking the runtime environment\nand the GFP_KERNEL flag for allocating new memory later on on lunatik_run()\ncalls. Otherwise, it will use a spinlock and GFP_ATOMIC. lunatik_runtime()\nopens the Lua standard libraries present on Lunatik. If successful,\nlunatik_runtime() sets the address pointed by pruntime and Lua's extra space\nwith a pointer for the new created runtime environment, sets the reference\ncounter to 1 and then returns 0. Otherwise, it returns -ENOMEM, if\ninsufficient memory is available; or -EINVAL, if it fails to load or run the\nscript.\n\n##### Example\n\n    \n    \n    -- /lib/modules/lua/mydevice.lua function myread(len, off) return \"42\" end\n    \n    \n    static lunatik_object_t *runtime; static int __init mydevice_init(void) { return lunatik_runtime(&runtime, \"mydevice\", true); }\n\n#### lunatik_stop\n\n    \n    \n    int lunatik_stop(lunatik_object_t *runtime);\n\nlunatik_stop() closes the Lua state created for this runtime environment and\ndecrements the reference counter. Once the reference counter is decremented to\nzero, the lock type and the memory allocated for the runtime environment are\nreleased. If the runtime environment has been released, it returns 1;\notherwise, it returns 0.\n\n#### lunatik_run\n\n    \n    \n    void lunatik_run(lunatik_object_t *runtime, <inttype> (*handler)(...), <inttype> &ret, ...);\n\nlunatik_run() locks the runtime environment and calls the handler passing the\nassociated Lua state as the first argument followed by the variadic arguments.\nIf the Lua state has been closed, ret is set with -ENXIO; otherwise, ret is\nset with the result of handler(L, ...) call. Then, it restores the Lua stack\nand unlocks the runtime environment. It is defined as a macro.\n\n##### Example\n\n    \n    \n    static int l_read(lua_State *L, char *buf, size_t len, loff_t *off) { size_t llen; const char *lbuf; lua_getglobal(L, \"myread\"); lua_pushinteger(L, len); lua_pushinteger(L, *off); if (lua_pcall(L, 2, 2, 0) != LUA_OK) { /* calls myread(len, off) */ pr_err(\"%s\\n\", lua_tostring(L, -1)); return -ECANCELED; } lbuf = lua_tolstring(L, -2, &llen); llen = min(len, llen); if (copy_to_user(buf, lbuf, llen) != 0) return -EFAULT; *off = (loff_t)luaL_optinteger(L, -1, *off + llen); return (ssize_t)llen; } static ssize_t mydevice_read(struct file *f, char *buf, size_t len, loff_t *off) { ssize_t ret; lunatik_object_t *runtime = (lunatik_object_t *)f->private_data; lunatik_run(runtime, l_read, ret, buf, len, off); return ret; }\n\n#### lunatik_getobject\n\n    \n    \n    void lunatik_getobject(lunatik_object_t *object);\n\nlunatik_getobject() increments the reference counter of this object (e.g.,\nruntime environment).\n\n#### lunatik_put\n\n    \n    \n    int lunatik_putobject(lunatik_object_t *object);\n\nlunatik_putobject() decrements the reference counter of this object (e.g.,\nruntime environment). If the object has been released, it returns 1;\notherwise, it returns 0.\n\n#### lunatik_toruntime\n\n    \n    \n    lunatik_object_t *lunatik_toruntime(lua_State *L);\n\nlunatik_toruntime() returns the runtime environment referenced by the L's\nextra space.\n\n## Lunatik Lua APIs\n\n### lunatik\n\nThe lunatik library provides support to load and run scripts and manage\nruntime environments from Lua.\n\n#### lunatik.runtime(script [, sleep])\n\nlunatik.runtime() creates a new runtime environment then loads and runs the\nscript /lib/modules/lua/<script>.lua as the entry point for this environment.\nIt returns a Lunatik object representing the runtime environment. If sleep is\ntrue or omitted, it will use a mutex and GFP_KERNEL; otherwise, it will use a\nspinlock and GFP_ATOMIC. lunatik.runtime() opens the Lua standard libraries\npresent on Lunatik.\n\n#### lunatik.stop(runtime), runtime:stop()\n\nlunatik.stop() stops the runtime environment and clear its reference from the\nruntime object.\n\n### device\n\nThe device library provides support for writting character device drivers in\nLua.\n\n#### device.new(driver)\n\ndevice.new() returns a new device object and installs its driver in the\nsystem. The driver must be defined as a table containing the following field:\n\n  * name: string defining the device name; it is used for creating the device file (e.g., /dev/<name>).\n\nThe driver table might optionally contain the following fields:\n\n  * read: callback function to handle the read operation on the device file. It receives the driver table as the first argument followed by two integers, the length to be read and the file offset. It should return a string and, optionally, the updated offset. If the length of the returned string is greater than the requested length, the string will be corrected to that length. If the updated offset is not returned, the offset will be updated with offset + length.\n  * write: callback function to handle the write operation on the device file. It receives the driver table as the first argument followed by the string to be written and an integer as the file offset. It might return optionally the written length followed by the updated offset. If the returned length is greater than the requested length, the returned length will be corrected. If the updated offset is not returned, the offset will be updated with offset + length.\n  * open: callback function to handle the open operation on the device file. It receives the driver table and it is expected to return nothing.\n  * release: callback function to handle the release operation on the device file. It receives the driver table and it is expected to return nothing.\n  * mode: an integer specifying the device file mode.\n\nIf an operation callback is not defined, the device returns -ENXIO to VFS on\nits access.\n\n#### device.stop(dev), dev:stop()\n\ndevice.stop() removes a device driver specified by the dev object from the\nsystem.\n\n### linux\n\nThe linux library provides support for some Linux kernel facilities.\n\n#### linux.random([m [, n]])\n\nlinux.random() mimics the behavior of math.random, but binding\n<linux/random.h>'s get_random_u32() and get_random_u64() APIs.\n\nWhen called without arguments, produces an integer with all bits\n(pseudo)random. When called with two integers m and n, linux.random() returns\na pseudo-random integer with uniform distribution in the range [m, n]. The\ncall math.random(n), for a positive n, is equivalent to math.random(1, n).\n\n#### linux.stat\n\nlinux.stat is a table that exports <linux/stat.h> integer flags to Lua.\n\n  * \"IRWXUGO\": permission to read, write and execute for user, group and other.\n  * \"IRUGO\": permission only to read for user, group and other.\n  * \"IWUGO\": permission only to write for user, group and other.\n  * \"IXUGO\": permission only to execute for user, group and other.\n\n#### linux.schedule([timeout [, state]])\n\nlinux.schedule() sets the current task state and makes the it sleep until\ntimeout milliseconds have elapsed. If timeout is omitted, it uses\nMAX_SCHEDULE_TIMEOUT. If state is omitted, it uses task.INTERRUPTIBLE.\n\n#### linux.task\n\nlinux.task is a table that exports task state flags to Lua.\n\n  * \"RUNNING\": task is executing on a CPU or waiting to be executed.\n  * \"INTERRUPTIBLE\": task is waiting for a signal or a resource (sleeping).\n  * \"UNINTERRUPTIBLE\": behaves like \"INTERRUPTIBLE\" with the exception that signal will not wake up the task.\n  * \"KILLABLE\": behaves like \"UNINTERRUPTIBLE\" with the exception that fatal signals will wake up the task.\n  * \"IDLE\": behaves like \"UNINTERRUPTIBLE\" with the exception that it avoids the loadavg accounting.\n\n#### linux.errno\n\nlinux.errno is a table that exports <uapi/asm-generic/errno-base.h> flags to\nLua.\n\n  * \"PERM\": Operation not permitted.\n  * \"NOENT\": No such file or directory.\n  * \"SRCH\": No such process.\n  * \"INTR\": Interrupted system call.\n  * \"IO\": I/O error.\n  * \"NXIO\":No such device or address.\n  * \"2BIG\":, Argument list too long.\n  * \"NOEXEC\": Exec format error.\n  * \"BADF\": Bad file number.\n  * \"CHILD\": No child processes.\n  * \"AGAIN\": Try again.\n  * \"NOMEM\": Out of memory.\n  * \"ACCES\": Permission denied.\n  * \"FAULT\": Bad address.\n  * \"NOTBLK\": Block device required.\n  * \"BUSY\": Device or resource busy.\n  * \"EXIST\": File exists.\n  * \"XDEV\": Cross-device link.\n  * \"NODEV\": No such device.\n  * \"NOTDIR\": Not a directory.\n  * \"ISDIR\": Is a directory.\n  * \"INVAL\": Invalid argument.\n  * \"NFILE\": File table overflow.\n  * \"MFILE\": Too many open files.\n  * \"NOTTY\": Not a typewriter.\n  * \"TXTBSY\": Text file busy.\n  * \"FBIG\": File too large.\n  * \"NOSPC\": No space left on device.\n  * \"SPIPE\": Illegal seek.\n  * \"ROFS\": Read-only file system.\n  * \"MLINK\": Too many links.\n  * \"PIPE\": Broken pipe.\n  * \"DOM\": Math argument out of domain of func.\n  * \"RANGE\": Math result not representable.\n\n### notifier\n\nThe notifier library provides support for the kernel notifier chains.\n\n#### notifier.keyboard(callback)\n\nnotifier.keyboard() returns a new keyboard notifier object and installs it in\nthe system. The callback function is called whenever a console keyboard event\nhappens (e.g., a key has been pressed or released). This callback receives the\nfollowing arguments:\n\n  * event: the available events are defined by the notifier.kbd table.\n  * down: true, if the key is pressed; false, if it is released.\n  * shift: true, if the shift key is held; false, otherwise.\n  * key: keycode or keysym depending on event.\n\nThe callback function might return the values defined by the notifier.notify\ntable.\n\n#### notifier.kbd\n\nnotifier.kbd is a table that exports KBD flags to Lua.\n\n  * \"KEYCODE\": keyboard keycode, called before any other.\n  * \"UNBOUND_KEYCODE\": keyboard keycode which is not bound to any other.\n  * \"UNICODE\": keyboard unicode.\n  * \"KEYSYM\": keyboard keysym.\n  * \"POST_KEYSYM\": called after keyboard keysym interpretation.\n\n#### notifier.netdevice(callback)\n\nnotifier.netdevice() returns a new netdevice notifier object and installs it\nin the system. The callback function is called whenever a console netdevice\nevent happens (e.g., a network interface has been connected or disconnected).\nThis callback receives the following arguments:\n\n  * event: the available events are defined by the notifier.netdev table.\n  * name: the device name.\n\nThe callback function might return the values defined by the notifier.notify\ntable.\n\n#### notifier.netdev\n\nnotifier.netdev is a table that exports NETDEV flags to Lua.\n\n#### notifier.notify\n\nnotifier.notify is a table that exports NOTIFY flags to Lua.\n\n  * \"DONE\": don't care.\n  * \"OK\": suits me.\n  * \"BAD\": bad/veto action.\n  * \"STOP\": clean way to return from the notifier and stop further calls.\n\n#### notifier.delete(notfr), notfr:delete()\n\nnotifier.delete() removes a notifier specified by the notfr object from the\nsystem.\n\n### socket\n\nThe socket library provides support for the kernel networking handling. This\nlibrary was inspired by Chengzhi Tan's GSoC project.\n\n#### socket.new(family, type, protocol)\n\nsocket.new() creates a new socket object. This function receives the following\narguments:\n\n  * family: the available address families are defined by the socket.af table.\n  * sock: the available types are present on the socket.sock table.\n  * protocol: the available protocols are defined by the socket.ipproto table.\n\n#### socket.af\n\nsocket.af is a table that exports address families (AF) to Lua.\n\n  * \"UNSPEC\": Unspecified.\n  * \"UNIX\": Unix domain sockets.\n  * \"LOCAL\": POSIX name for AF_UNIX.\n  * \"INET\": Internet IP Protocol.\n  * \"AX25\": Amateur Radio AX.25.\n  * \"IPX\": Novell IPX.\n  * \"APPLETALK\": AppleTalk DDP.\n  * \"NETROM\": Amateur Radio NET/ROM.\n  * \"BRIDGE\": Multiprotocol bridge.\n  * \"ATMPVC\": ATM PVCs.\n  * \"X25\": Reserved for X.25 project.\n  * \"INET6\": IP version 6.\n  * \"ROSE\": Amateur Radio X.25 PLP.\n  * \"DEC\": Reserved for DECnet project.\n  * \"NETBEUI\": Reserved for 802.2LLC project.\n  * \"SECURITY\": Security callback pseudo AF.\n  * \"KEY\": PF_KEY key management API.\n  * \"NETLINK\": Netlink.\n  * \"ROUTE\": Alias to emulate 4.4BSD.\n  * \"PACKET\": Packet family.\n  * \"ASH\": Ash.\n  * \"ECONET\": Acorn Econet.\n  * \"ATMSVC\": ATM SVCs.\n  * \"RDS\": RDS sockets.\n  * \"SNA\": Linux SNA Project (nutters!).\n  * \"IRDA\": IRDA sockets.\n  * \"PPPOX\": PPPoX sockets.\n  * \"WANPIPE\": Wanpipe API Sockets.\n  * \"LLC\": Linux LLC.\n  * \"IB\": Native InfiniBand address.\n  * \"MPLS\": MPLS.\n  * \"CAN\": Controller Area Network.\n  * \"TIPC\": TIPC sockets.\n  * \"BLUETOOTH\": Bluetooth sockets.\n  * \"IUCV\": IUCV sockets.\n  * \"RXRPC\": RxRPC sockets.\n  * \"ISDN\": mISDN sockets.\n  * \"PHONET\": Phonet sockets.\n  * \"IEEE802154\": IEEE802154 sockets.\n  * \"CAIF\": CAIF sockets.\n  * \"ALG\": Algorithm sockets.\n  * \"NFC\": NFC sockets.\n  * \"VSOCK\": vSockets.\n  * \"KCM\": Kernel Connection Multiplexor.\n  * \"QIPCRTR\": Qualcomm IPC Router.\n  * \"SMC\": reserve number for PF_SMC protocol family that reuses AF_INET address family.\n  * \"XDP\": XDP sockets.\n  * \"MCTP\": Management component transport protocol.\n  * \"MAX\": Maximum.\n\n#### socket.sock\n\nsocket.sock is a table that exports socket types (SOCK):\n\n  * \"STREAM\": stream (connection) socket.\n  * \"DGRAM\": datagram (conn.less) socket.\n  * \"RAW\": raw socket.\n  * \"RDM\": reliably-delivered message.\n  * \"SEQPACKET\": sequential packet socket.\n  * \"DCCP\": Datagram Congestion Control Protocol socket.\n  * \"PACKET\": linux specific way of getting packets at the dev level.\n\nand flags (SOCK):\n\n  * \"CLOEXEC\": n/a.\n  * \"NONBLOCK\": n/a.\n\n#### socket.ipproto\n\nsocket.ipproto is a table that exports IP protocols (IPPROTO) to Lua.\n\n  * \"IP\": Dummy protocol for TCP.\n  * \"ICMP\": Internet Control Message Protocol.\n  * \"IGMP\": Internet Group Management Protocol.\n  * \"IPIP\": IPIP tunnels (older KA9Q tunnels use 94).\n  * \"TCP\": Transmission Control Protocol.\n  * \"EGP\": Exterior Gateway Protocol.\n  * \"PUP\": PUP protocol.\n  * \"UDP\": User Datagram Protocol.\n  * \"IDP\": XNS IDP protocol.\n  * \"TP\": SO Transport Protocol Class 4.\n  * \"DCCP\": Datagram Congestion Control Protocol.\n  * \"IPV6\": IPv6-in-IPv4 tunnelling.\n  * \"RSVP\": RSVP Protocol.\n  * \"GRE\": Cisco GRE tunnels (rfc 1701,1702).\n  * \"ESP\": Encapsulation Security Payload protocol.\n  * \"AH\": Authentication Header protocol.\n  * \"MTP\": Multicast Transport Protocol.\n  * \"BEETPH\": IP option pseudo header for BEET.\n  * \"ENCAP\": Encapsulation Header.\n  * \"PIM\": Protocol Independent Multicast.\n  * \"COMP\": Compression Header Protocol.\n  * \"SCTP\": Stream Control Transport Protocol.\n  * \"UDPLITE\": UDP-Lite (RFC 3828).\n  * \"MPLS\": MPLS in IP (RFC 4023).\n  * \"ETHERNET\": Ethernet-within-IPv6 Encapsulation.\n  * \"RAW\": Raw IP packets.\n  * \"MPTCP\": Multipath TCP connection.\n\n#### socket:close(sock), sock:close()\n\nsocket.close() removes sock object from the system.\n\n#### socket.send(sock, message, [addr [, port]]), sock:send(message, [addr [,\nport]])\n\nsocket.send() sends a string message through the socket sock. If the sock\naddress family is af.INET, then it expects the following arguments:\n\n  * addr: integer describing the destination IPv4 address.\n  * port: integer describing the destination IPv4 port.\n\nOtherwise:\n\n  * addr: packed string describing the destination address.\n\n#### socket.receive(sock, length, [flags [, from]]), sock:receive(length,\n[flags [, from]])\n\nsocket.receive() receives a string with up to length bytes through the socket\nsock. The available message flags are defined by the socket.msg table. If from\nis true, it returns the received message followed by the peer's address.\nOtherwise, it returns only the received message.\n\n#### socket.msg\n\nsocket.msg is a table that exports message flags to Lua.\n\n  * \"OOB\": n/a.\n  * \"PEEK\": n/a.\n  * \"DONTROUTE\": n/a.\n  * \"TRYHARD\": Synonym for \"DONTROUTE\" for DECnet.\n  * \"CTRUNC\": n/a.\n  * \"PROBE\": Do not send. Only probe path f.e. for MTU.\n  * \"TRUNC\": n/a.\n  * \"DONTWAIT\": Nonblocking io.\n  * \"EOR\": End of record.\n  * \"WAITALL\": Wait for a full request.\n  * \"FIN\": n/a.\n  * \"SYN\": n/a.\n  * \"CONFIRM\": Confirm path validity.\n  * \"RST\": n/a.\n  * \"ERRQUEUE\": Fetch message from error queue.\n  * \"NOSIGNAL\": Do not generate SIGPIPE.\n  * \"MORE\": Sender will send more.\n  * \"WAITFORONE\": recvmmsg(): block until 1+ packets avail.\n  * \"SENDPAGE_NOPOLICY\": sendpage() internal: do no apply policy.\n  * \"SENDPAGE_NOTLAST\": sendpage() internal: not the last page.\n  * \"BATCH\": sendmmsg(): more messages coming.\n  * \"EOF\": n/a.\n  * \"NO_SHARED_FRAGS\": sendpage() internal: page frags are not shared.\n  * \"SENDPAGE_DECRYPTED\": sendpage() internal: page may carry plain text and require encryption.\n  * \"ZEROCOPY\": Use user data in kernel path.\n  * \"FASTOPEN\": Send data in TCP SYN.\n  * \"CMSG_CLOEXEC\": Set close_on_exec for file descriptor received through SCM_RIGHTS.\n\n#### socket.bind(sock, addr [, port]), sock:bind(addr [, port])\n\nsocket.bind() binds the socket sock to a given address. If the sock address\nfamily is af.INET, then it expects the following arguments:\n\n  * addr: integer describing host IPv4 address.\n  * port: integer describing host IPv4 port.\n\nOtherwise:\n\n  * addr: packed string describing host address.\n\n#### socket.listen(sock [, backlog]), sock:listen([backlog])\n\nsocket.listen() moves the socket sock to listening state.\n\n  * backlog: pending connections queue size. If omitted, it uses SOMAXCONN as default.\n\n#### socket.accept(sock [, flags]), sock:accept([flags])\n\nsocket.accept() accepts a connection on socket sock. It returns a new socket\nobject. The available flags are present on the socket.sock table.\n\n#### socket.connect(sock, addr [, port] [, flags]), sock:connect(addr [, port]\n[, flags])\n\nsocket.connect() connects the socket sock to the address addr. If the sock\naddress family is af.INET, then it expects the following arguments:\n\n  * addr: integer describing the destination IPv4 address.\n  * port: integer describing the destination IPv4 port.\n\nOtherwise:\n\n  * addr: packed string describing the destination address.\n\nThe available flags are present on the socket.sock table.\n\nFor datagram sockets, addr is the address to which datagrams are sent by\ndefault, and the only address from which datagrams are received. For stream\nsockets, attempts to connect to addr.\n\n#### socket.getsockname(sock), sock:getsockname()\n\nsocket.getsockname() get the address which the socket sock is bound. If the\nsock address family is af.INET, then it returns the following:\n\n  * addr: integer describing the bounded IPv4 address.\n  * port: integer describing the bounded IPv4 port.\n\nOtherwise:\n\n  * addr: packed string describing the bounded address.\n\n#### socket.getpeername(sock), sock:getpeername()\n\nsocket.getpeername() get the address which the socket sock is connected. If\nthe sock address family is af.INET, then it returns the following:\n\n  * addr: integer describing the peer's IPv4 address.\n  * port: integer describing the peer's IPv4 port.\n\nOtherwise:\n\n  * addr: packed string describing the peer's address.\n\n### socket.inet\n\nThe socket.inet library provides support for high-level IPv4 sockets.\n\n#### inet.tcp()\n\ninet.tcp() creates a new socket using af.INET address family, sock.STREAM type\nand ipproto.TCP protocol. It overrides socket methods to use addresses as\nnumbers-and-dots notation (e.g., \"127.0.0.1\"), instead of integers.\n\n#### inet.udp()\n\ninet.udp() creates a new socket using af.INET address family, sock.DGRAM type\nand ipproto.UDP protocol. It overrides socket methods to use addresses as\nnumbers-and-dots notation (e.g., \"127.0.0.1\"), instead of integers.\n\n##### udp:receivefrom(length [, flags])\n\nudp:receivefrom() is just an alias to sock:receive(length, flags, true).\n\n### rcu\n\nThe rcu library provides support for the kernel Read-copy update (RCU)\nsynchronization mechanism. This library was inspired by Caio Messias' GSoC\nproject.\n\n#### rcu.table([size])\n\nrcu.table() creates a new rcu.table object which binds the kernel generic hash\ntable. This function receives as argument the number of buckets rounded up to\nthe next power of 2. The default size is 1024. Key must be a string and value\nmust be a Lunatik object or nil.\n\n### thread\n\nThe thread library provides support for the kernel thread primitives.\n\n#### thread.run(runtime, name)\n\nthread.run() creates a new thread object and wakes it up. This function\nreceives the following arguments:\n\n  * runtime: the runtime environment for running a task in the created kernel thread. The task must be specified by returning a function on the script loaded in the runtime environment.\n  * name: string representing the name for the thread (e.g., as shown on ps).\n\n#### thread.shouldstop()\n\nthread.shouldstop() returns true if thread.stop() was called; otherwise, it\nreturns false.\n\n#### thread.current()\n\nthread.current() returns a thread object representing the current task.\n\n#### thread.stop(thrd), thrd:stop()\n\nthread.stop() sets thread.shouldstop() on the thread thrd to return true,\nwakes thrd, and waits for it to exit.\n\n#### thread.task(thread), thrd:task()\n\nthread.task() returns a table containing the task information of this thread\n(e.g., \"cpu\", \"command\", \"pid\" and \"tgid\").\n\n### fib\n\nThe fib library provides support for the kernel Forwarding Information Base.\n\n#### fib.newrule(table, priority)\n\nfib.newrule() binds the kernel fib_nl_newrule API; it creates a new FIB rule\nthat matches the specified routing table with the specified priorioty. This\nfunction is similar to the user-space command ip rule add provided by\niproute2.\n\n#### fib.delrule(table, priority)\n\nfib.delrule() binds the kernel fib_nl_delrule API; it removes a FIB rule that\nmatches the specified routing table with the specified priorioty. This\nfunction is similar to the user-space command ip rule del provided by\niproute2.\n\n### data\n\nThe data library provides support for binding the system memory to Lua.\n\n#### data.new(size)\n\ndata.new() creates a new data object which allocates size bytes.\n\n#### data.getnumber(d, offset), d:getnumber(offset)\n\ndata.getnumber() extracts a lua_Integer from the memory referenced by a data\nobject and a byte offset, starting from zero.\n\n#### data.setnumber(d, offset, number), d:setnumber(offset, number)\n\ndata.setnumber() insert a lua_Integer number into the memory referenced by a\ndata object and a byte offset, starting from zero.\n\n#### data.getbyte(d, offset), d:getbyte(offset)\n\ndata.getbyte() extracts a byte from the memory referenced by a data object and\na byte offset, starting from zero.\n\n#### data.setbyte(d, offset, byte), d:setbyte(offset, byte)\n\ndata.setbyte() insert a byte into the memory referenced by a data object and a\nbyte offset, starting from zero.\n\n#### data.getstring(d, offset, length), d:getstring(offset, length)\n\ndata.getstring() extracts a string with length bytes from the memory\nreferenced by a data object and a byte offset, starting from zero.\n\n#### data.setstring(d, offset, s), d:setstring(offset, s)\n\ndata.setstring() insert the string s into the memory referenced by a data\nobject and a byte offset, starting from zero.\n\n### probe\n\nThe probe library provides support for kernel probes.\n\n#### probe.new(symbol|address, handlers)\n\nprobe.new() returns a new probe object for monitoring a kernel symbol (string)\nor address (light userdata) and installs its handlers in the system. The\nhandler must be defined as a table containing the following field:\n\n  * pre: function to be called before the probed instruction. It receives the symbol or address, followed by a closure that may be called to show the CPU registers and stack in the system log.\n  * post: function to be called after the probed instruction. It receives the symbol or address, followed by a closure that may be called to show the CPU registers and stack in the system log.\n\n#### probe.stop(p), p:stop()\n\nprobe.stop() removes the probe handlers from the system.\n\n#### probe.enable(p, bool), p:enable(bool)\n\nprobe.enable() enables or disables the probe handlers, accordingly to bool.\n\n### syscall\n\nThe syscall library provides support for system call addresses and numbers.\n\n#### syscall.address(number)\n\nsyscall.address() returns the system call address (light userdata) referenced\nby the given number.\n\n#### syscall.number(name)\n\nsyscall.number() returns the system call number referenced by the given name.\n\n### syscall.table\n\nThe syscall.table library provides support for translating system call names\nto addresses (light userdata).\n\n# Examples\n\n### spyglass\n\nspyglass is a kernel script that implements a keylogger inspired by the spy\nkernel module. This kernel script logs the keysym of the pressed keys in a\ndevice (/dev/spyglass). If the keysym is a printable character, spyglass logs\nthe keysym itself; otherwise, it logs a mnemonic of the ASCII code, (e.g.,\n<del> stands for 127).\n\n#### Usage\n\n    \n    \n    sudo make examples_install # installs examples sudo lunatik run examples/spyglass # runs spyglass sudo tail -f /dev/spyglass # prints the key log sudo sh -c \"echo 'enable=false' > /dev/spyglass\" # disable the key logging sudo sh -c \"echo 'enable=true' > /dev/spyglass\" # enable the key logging sudo sh -c \"echo 'net=127.0.0.1:1337' > /dev/spyglass\" # enable network support nc -lu 127.0.0.1 1337 & # listen to UDP 127.0.0.1:1337 sudo tail -f /dev/spyglass # sends the key log through the network\n\n### keylocker\n\nkeylocker is a kernel script that implements Konami Code for locking and\nunlocking the console keyboard. When the user types \u2191 \u2191 \u2193 \u2193 \u2190 \u2192 \u2190 \u2192 LCTRL\nLALT, the keyboard will be locked; that is, the system will stop processing\nany key pressed until the user types the same key sequence again.\n\n#### Usage\n\n    \n    \n    sudo make examples_install # installs examples sudo lunatik run examples/keylocker # runs keylocker <\u2191> <\u2191> <\u2193> <\u2193> <\u2190> <\u2192> <\u2190> <\u2192> <LCTRL> <LALT> # locks keyboard <\u2191> <\u2191> <\u2193> <\u2193> <\u2190> <\u2192> <\u2190> <\u2192> <LCTRL> <LALT> # unlocks keyboard\n\n### tap\n\ntap is a kernel script that implements a sniffer using AF_PACKET socket. It\nprints destination and source MAC addresses followed by Ethernet type and the\nframe size.\n\n#### Usage\n\n    \n    \n    sudo make examples_install # installs examples sudo lunatik run examples/tap # runs tap cat /dev/tap\n\n### shared\n\nshared is a kernel script that implements an in-memory key-value store using\nrcu, data, socket and thread.\n\n#### Usage\n\n    \n    \n    sudo make examples_install # installs examples sudo lunatik spawn examples/shared # spawns shared nc 127.0.0.1 90 # connects to shared foo=bar # assigns \"bar\" to foo foo # retrieves foo bar ^C # finishes the connection\n\n### echod\n\nechod is an echo server implemented as kernel scripts.\n\n#### Usage\n\n    \n    \n    sudo make examples_install # installs examples sudo lunatik spawn examples/echod/daemon # runs echod nc 127.0.0.1 1337 hello kernel! hello kernel!\n\n### systrack\n\nsystrack is a kernel script that implements a device driver to monitor system\ncalls. It prints the amount of times each system call was called since the\ndriver has been installed.\n\n#### Usage\n\n    \n    \n    sudo make examples_install # installs examples sudo lunatik run examples/systrack # runs systracker cat /dev/systrack writev: 0 close: 1927 write: 1085 openat: 2036 read: 4131 readv: 0\n\n## References\n\n  * Scripting the Linux Routing Table with Lua\n  * Lua no N\u00facleo (Portuguese)\n  * Linux Network Scripting with Lua\n  * Scriptables Operating Systems with Lua\n\n## About\n\nLunatik is a framework for scripting the Linux kernel with Lua.\n\n### Topics\n\nc kernel lua linux-kernel\n\n### Resources\n\nReadme\n\nActivity\n\nCustom properties\n\n### Stars\n\n117 stars\n\n### Watchers\n\n11 watching\n\n### Forks\n\n15 forks\n\nReport repository\n\n## Releases 9\n\nLunatik v3.4 Latest\n\nMar 6, 2024\n\n\\+ 8 releases\n\n## Packages 0\n\nNo packages published\n\n## Contributors 14\n\n## Languages\n\n  * C 89.6%\n  * Lua 7.8%\n  * Makefile 2.5%\n  * Shell 0.1%\n\n## Footer\n\n\u00a9 2024 GitHub, Inc.\n\nYou can\u2019t perform that action at this time.\n\n", "frontpage": true}
