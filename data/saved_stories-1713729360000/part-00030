{"aid": "40105541", "title": "DIY Gaming Mouse", "url": "https://github.com/wareya/DIY-Gaming-Mouse", "domain": "github.com/wareya", "votes": 2, "user": "jamapy", "posted_at": "2024-04-21 13:15:46", "comments": 0, "source_title": "GitHub - wareya/DIY-Gaming-Mouse: Completely open source DIY gaming mouse, including hardware (PCB, shell) design files", "source_text": "GitHub - wareya/DIY-Gaming-Mouse: Completely open source DIY gaming mouse,\nincluding hardware (PCB, shell) design files\n\nSkip to content\n\nSign in\n\n# Search code, repositories, users, issues, pull requests...\n\nSearch syntax tips\n\nSign in\n\nSign up\n\nYou signed in with another tab or window. Reload to refresh your session. You\nsigned out in another tab or window. Reload to refresh your session. You\nswitched accounts on another tab or window. Reload to refresh your session.\nDismiss alert\n\nwareya / DIY-Gaming-Mouse Public\n\n  * Notifications\n  * Fork 4\n  * Star 99\n\nCompletely open source DIY gaming mouse, including hardware (PCB, shell)\ndesign files\n\n99 stars 4 forks Branches Tags Activity\n\nStar\n\nNotifications\n\n# wareya/DIY-Gaming-Mouse\n\nThis commit does not belong to any branch on this repository, and may belong\nto a fork outside of the repository.\n\n1 Branch\n\n0 Tags\n\n## Folders and files\n\nName| Name| Last commit message| Last commit date  \n---|---|---|---  \n  \n## Latest commit\n\nwareyaUpdate Readme.mdApr 14, 2024080fd6e \u00b7 Apr 14, 2024Apr 14, 2024\n\n## History\n\n39 Commits  \n  \n### Case Model\n\n|\n\n### Case Model\n\n| update scroll wheel model to fit better in the encoder| Apr 8, 2024  \n  \n### KiCad schematic + PCB\n\n|\n\n### KiCad schematic + PCB\n\n| initial commit| Apr 7, 2024  \n  \n### .gitignore\n\n|\n\n### .gitignore\n\n| initial commit| Apr 7, 2024  \n  \n### 3360_Mouse_pico.ino\n\n|\n\n### 3360_Mouse_pico.ino\n\n| implement state latch| Apr 9, 2024  \n  \n### APACHE LICENSE-2.0.txt\n\n|\n\n### APACHE LICENSE-2.0.txt\n\n| add license| Apr 7, 2024  \n  \n### Readme.md\n\n|\n\n### Readme.md\n\n| Update Readme.md| Apr 14, 2024  \n  \n### SOLDERPAD LICENSE-2.1.txt\n\n|\n\n### SOLDERPAD LICENSE-2.1.txt\n\n| specify license of hardware design files| Apr 7, 2024  \n  \n### relmouse_16.h\n\n|\n\n### relmouse_16.h\n\n| initial commit| Apr 7, 2024  \n  \n### srom_dummy_blank.h\n\n|\n\n### srom_dummy_blank.h\n\n| add dummy (blank) srom file for use without an srom| Apr 7, 2024  \n  \n## Repository files navigation\n\n# DIY Gaming Mouse\n\nVideo about why and how I made this, and what the various iterations were\nlike: https://www.youtube.com/watch?v=h-Cdl4Vq9H4\n\nThis repository contains the code, schematic, PCB layout, and 3d model for a\ncompletely DIY gaming mouse, all designed around a Pixart PMW3360 sensor.\n\nThe firmware for this mouse uses a special debouncing algorithm that\ncompletely eliminates chatter without adding ANY latency, and eliminates\nbounce better than commercial mice do. Random double-clicks be gone!\n\nNone of the companies that make gaming mouse sensors sell them to consumers,\nincluding Pixart, so the sensor needs to be salvaged (or bought from a\nscalper, or a small business that specializes in reselling them).\n\n(The shell has a top, too, but it's turned off in this picture so you can see\nthe PCB.)\n\n## Features\n\n  * True zero-latency button debouncing with no glitching\n  * Buttons that will not develop double-clicking problems after only a few months\n  * Low-latency motion tracking (no smoothing)\n  * Completely open source (Apache 2.0 license)\n  * Even the hardware is open source! (except the processor and sensor)\n  * Ultra light-weight shell and assembly (55g in total)\n  * Fingertip-grip shell shape\n  * Extra middle mouse button\n  *     * the button that normally controls DPI on other mice is mapped to M3\n  * PCB exposes extra unused pins from the rp2040 as test pads for hardware/firmware modding fun; attach your own sensors! or LEDs! whatever you want!\n  * Full 1000hz tracking\n\nTODO:\n\n  * Configurable DPI (currently hardcoded at 1200)\n  *     * To change it in the firmware code, edit the spi_write(REG_CONFIG1, 11); // 1200 dpi line, replacing 11 with your dpi divided by 100 minus 1, e.g. 7 for 800 dpi, 3 for 400, 15 for 1600, etc\n  * rebinding, macros, etc\n  *     * can already be hardcoded atm if you're skilled at programming\n  * \"fun\" optional features like WMO-style diagonal jaggy removal or optional in-firmware acceleration, anti-smoothing (prediction), angle snapping, cinematic smoothing, etc\n\n## Required skills\n\nYou need to be familiar with, or be able to learn quickly:\n\n  * 3d printing\n  * how to use a \"slicer\" (e.g. Cura) to convert stl models to gcode (what your 3d printer uses)\n  * repeatedly making test prints\n  * how to clean up 3d prints and remove support material from fragile prints\n  * basic firmware code debugging skills\n  * the ability to read embedded C/C++ code\n  * the Arduino IDE (I use 2.x, not 1.x)\n  * desoldering (with a hot air rework station)\n  * soldering (with a soldering iron)\n  * soldering bodge wires to existing pieces of hardware without creating solder bridges (for SROM extraction)\n  * comfort using a hot air rework station to soften and fix misshapen parts on 3d printed objects if they print improperly\n  * the ability to do all of the above without wasting tons of money or burning your home down\n  * familiarity with PCB printing companies and PCB assembly manufacturers (JLCPCB, PCBWay, etc)\n  * patience\n\nIf you cannot do all of the above, you should have someone else build this\nproject for you, rather than building it for yourself. Or, at the very least,\nI can't give you support if you don't have the skills needed to make this; I'm\njust some random guy.\n\nYou also need:\n\n  * access to a 3d printer that you can repeatedly print test prints on until they come out right\n  * a hot air rework station with temperature and air flow rate control\n  * a soldering iron with temperature control\n  * hot glue device (for securing the USB cable, nothing else)\n  * various small tools like screwdrivers, tweezers, cleanup blades / deburring tools, etc. for various parts of the building process\n\n## Instructions\n\n### 3D printing the shell\n\nThis assumes you're using a filament printer. Resin printers might work too,\nbut I have never used one.\n\nI print with PLA filament.\n\nPrint each of the STL files in the \"Case Model\" directory in their natural\n(not default!) orientations. To repeat, some of the models have to be rotated;\nthey're saved in the orientation they have in the mouse, not the orientation\nthey need to have on the 3d printer's build plate.\n\nYou need to convert the stl files to gcode yourself and run various test\nprints because each 3d printer and filament has different requirements for\nlayer thickness, support cutoff angle, printing speed, z seam alignment\nplacement, etc.\n\nCura will complain about certain pieces (like the shell bottom) not being\n\"water tight\", but it's wrong; the watertightness check doesn't handle\nmultiple overlapping solids properly. The models will still slice correctly\nand without glitches.\n\nThe thumb pieces must be rotated into the orientation where they do not need\nany supports. This means the small part of the thumb piece is facing up, and\nthe long part of the switch clamp section is on the bottom.\n\nThe scroll wheel must be rotated so that the thick cylinder part is on the\nbottom and the thin pin part is on the top. It must be printed with supports;\nany type of support is fine. It should be printed at 100% speed or lower, not\nhigher, until it gets to the pin, at which point you MUST reduce the printing\nspeed as low as you can tolerate. On my printer, a Sovol SV06, I had to turn\nit down to 25% speed. If your printer doesn't allow you to change the speed\nmid-print, you have to print at the low speed for the entire print. This is\nimportant; you have to print it slowly, because otherwise, the pin will be\nmisaligned with itself and the scroll wheel will be off-balance and hit the\nmiddle mouse button switch with different pressures depending on where it is\nin its spin cycle.\n\nPrint the scroll wheel brace as-is.\n\nPrint the shell bottom as-is.\n\nPrint the shell top with tree supports and a support cutoff angle between 60\nand 70 degrees. Do not use \"standard\"/traditional/grid supports; they will be\ntoo difficult to remove, and you will probably damage the print trying to\nremove them. On my printer, a Sovol SV06, 67 degrees was just right. If you\nhave poor print quality, you might need to reduce the cutoff angle down to\nsomething silly like 50 degrees. If you have to go below 50 degrees, get a\nbetter printer, or make sure you're using the right filament at the right\ntemperature, etc.\n\nOnce the shell top is printed, you need to use a deburring tool (or other\nhard, sharp metal implement) to remove a small amount of material from a\ncertain curved edge along the seam where it meets the shell bottom, on the\nright side of the shell (with the button pieces away from you and the \"butt\"\npart towards you). The shell will fit together without removing a small amount\nof material from this part of the shell top, but it'll be misaligned by around\na quarter of a millimeter and the right click won't quite work right. This\nmaterial has to be removed because it sags during printing, and it sags during\nprinting because of how support bridging works; the 3d model itself is\ncorrect.\n\nYou should print each part one-by-one and check for errors each time.\n\nThe final result will be somewhat rough and rugged, but it's a functional\nmouse shell.\n\n### SROM preparation\n\nNote: The SROM is optional, but highly recommended because it contains sensor\nfirmware bugfixes. If you can't get it, comment out the call to srom_upload();\nin pmw3360_boot(), and then rename the .h file inclusion to #include\n\"srom_dummy_blank.h\", but be warned that your mouse might experience glitchy\nbehavior like \"spinout\" or have generally poor tracking. For example, while\nwriting this and testing the firmware without an SROM, I click-and-dragged a\ntitle bar on a window, and then the mouse cursor teleported 300~400 pixels to\nthe right for no reason.\n\nThe SROM needs to be captured from an existing mouse because it's copyrighted.\nGive it the name srom_3360_0x03.h, srom_3360_0x04.h, or srom_3360_0x05.h,\ndepending on what version it is. I poked around github and found other\nprojects using the 3360 SROM, and this seems to be the way they decided to\nname their SROM header files, so I'm copying the filename from them.\n\nOnce you have the SROM, edit the #include \"srom_3360_0x05.h\" line in\n3360_Mouse_pico.ino to point to the file for your SROM.\n\nThe below is instructions on how to capture the SROM from a commercial mouse.\n\nCapture the SROM from a commercial 3360 mouse with this code, and a standalone\nraspberry pi pico (not this mouse's custom PCB):\nhttps://gist.github.com/wareya/0dc3498bd80be93c47b6f79aa9164321\n\nNote: the above SROM capturing code requires you to use the \"arduino-pico\"\nboard type in the Arduino IDE. But the firmware in this repostory requires you\nto use the \"mbed OS\" rp2040 board type.\n\nUse a breadboard to make a ripping setup equivalent to that depicted in the\nfollowing image:\n\nBe very careful not to create any solder bridges between any of the pins on\nthe 3360.\n\nReconnect the mouse so that it reboots and sends the SROM to the sensor again.\n\nThe output should be exactly 4094 bytes long, and the second byte should be\n0x03, 0x04, or 0x05 (different versions).\n\nRepeat the capturing process until you get the same SROM several times, just\nto make sure that it captured properly. To capture the SROM again, you need to\nreboot the mouse. This can be plugging it in to your computer again, or\ndisconnecting and reconnecting its USB power wire, or any safe method you\nprefer.\n\nThe MD5 checksums of the versions of the SROM that I know about are:\n\n    \n    \n    0x03 - C64F2BDA742DD1623D6A5DC869FC5E60 0x04 - 0BCB410858FF21D091DDC497D19BC943 0x05 - 337254C54AD82C689D4B9A58D06A3CF6\n\nIf you have an SROM with a different version number, it might not work with\nthis firmware. It might, but it also might not. I can't provide support for\nother SROM versions.\n\nAfter capturing the SROM data, save it in a formatted .h file formatted as\nsuch:\n\n    \n    \n    #define SROM_LENGTH (4094) const uint8_t PROGMEM srom[SROM_LENGTH] = { 0x01, 0x<version number>, // ... // etc };\n\nI cannot distribute the SROM in this repository, because it's copyrighted\nproprietary code.\n\nDisclaimer: The above steps do not bypass any copy protection, no encryption\nis being broken, and copyright law is not being violated by making your own\nbackup copy of the sensor's SROM and using it on your own device. This is\nfully legal in reasonable countries (like the US).\n\n### PMW 3360 sensor salvage\n\nThe Pixart PMW3360 is not sold commercially to hobbyists or small repair\nshops; to get one, you have to either buy an expensive breakout board, buy it\nfrom scalpers on aliexpress (or similar), or salvage it from an existing\ncommercial mouse. This project assumes that you're salvaging it from an\nexisting commercial mouse, after capturing the SROM from that mouse.\n\nYou need a hot air rework station, NOT a soldering iron, to desolder and\nsalvage the 3360 safely. If you try to use a soldering iron, even with\ndesoldering wick and/or a desoldering pump, you are VERY likely to fail to\nsalvage it, damaging the pins or sensor internals in the process. The 3360 is\nsomewhat sensitive to high temperatures, so you can only heat it up for a\nfairly short amount of time, and desoldering the ground pin with a soldering\niron will get the sensor hot enough that it might start to damage it.\n\nThe 3360 sensor's lens is usually directly mounted to the sensor by melting\nits clear mounting pins down onto the top of the sensor's IC package.\n\nTake the commercial mouse's PCB, scrape off (don't break off) the top melted\npart of the lens's mounting posts. Then, being careful not to damage anything,\nremove the lens from the sensor and PCB and put it somewhere safe.\n\nNow, put the commercial mouse's PCB upside down on a non-flammable surface, in\na workspace free of any flammable material. I cannot be held responsible if\nyou start a fire in an unsafe workspace. You have been warned!\n\nBefore continuing, you might want to cover the bottom of the sensor with paper\nand/or tape to prevent anything from getting inside of it. If you do this, do\nit in a way that doesn't create a fire hazard.\n\nFind the bottom of the sensor's pins. To each of these pins, apply a small\namount of either leaded solder (if it's all you have) or low-temperature non-\nleaded solder paste/gel/etc (preferred) (NOT the same thing as flux!). You\nwant to mix your solder into the existing solder on the pins because this will\nlower the melting temperature of the existing solder and make it easier to\ndesolder the chip. Use a soldering iron or hot air tool at around 600F/300C to\nmake the two types of solder mix together. Do not physically touch the PCB or\npins with the hot air tool; rely only on the air itself.\n\nOnce the solder for each pin is mixed together, pass the hot air tool over\neach section of pins in a circular motion until the sensor eventually, finally\ncomes loose. At this point, use any metal tool (like metal tweezers or a screw\ndriver) to make sure the sensor fully comes out of the PCB.\n\nNow, use a soldering iron to clean any excess remaining solder off of the\npins. If the soldering iron ends up with too much solder on it, clean it off\nwith brass/bronze wool or similar. Be warned that, at very high temperatures,\nbrass wool is flammable. Do not use steel wool as a subtitute, as it is even\nmore flammable.\n\n### PCB building and assembly\n\nBuild gerber files and drill files and all the other necessary files (BOM,\npick and place, etc) that your PCB manufacturer needs to print and assemble\nthe PCB. Some of the components on the PCB are very, very delicate, so unless\nyou're a genuine expert, trying to hand-solder them is doomed.\n\nOnce you have your PCBs, you need the following parts to manually solder to\nthe board:\n\n  * 6 Omron D2F-01F switches (or compatible, e.g. D2FC)\n  * 11mm Alps-compatible scroll wheel encoder\n  * salvaged PMW 3360 sensor, undamaged, pins not bent\n  *     * 3360 sensor's lens, with mounting posts still intact\n  * Four dupont-compatible header pins for connecting to USB cable (optional)\n  * spare discrete resistors in case you messed up any of the resistor values when ordering the PCB like I did\n\nAnd the following additional parts for assembly:\n\n  * USB cable, ideally with dupont-compatible connectors (you can crimp them on yourself, you don't have to buy a special cable for this)\n  * 3d printed shell (2 parts)\n  * 3d printed side buttons (2 parts)\n  * 3d printed scroll wheel brace (1 part)\n  * 3d printed scroll wheel OR salvaged scroll wheel for 11mm Alps-compatible scroll wheel encoder with the right middle-mouse-button shaft thickness\n  * mouse feet (salvaged or custom) with approximately 0.6mm thickness (that's zero-point-six millimeters)\n\nThe mouse feet thickness is very important, within a quarter of a millimeter!\nUsing any other thickness of mouse feet is likely to result in poor, glitchy\ntracking. The PMW3360 is VERY sensitive to VERY small changes in tracking\ndistance.\n\nMake sure you have screws the right size to screw everything together. I\nrecommend doing a test-fit of the shell and plain PCB with screws before doing\nanything else. Be careful not to overtighten the side screws; doing so can\ncause their mounting holes to split. The PCB is held down with two screws and\nthe case is held together with three screws. I used salvaged screws with a\nmajor diameter (outside edge of threads) of 2mm and a minor diameter of around\n1.65~1.7mm, and the holes on the case were designed around these screws, but\nslightly different screws will still work.\n\nSolder the dupont-compatible header pins to the PCB, or if you have a\ndifferent plan to connect the PCB to USB, do that instead. Then, connect it to\nyour computer and make sure you can program it with the Arduino IDE. If it\ndoesn't work, try a different copy of the PCB. Don't continue until you know\nthat the PCB and its rp2040 processor are working properly. You should also do\na test-fit of the PCB inside the 3d printed shell bottom to make sure nothing\nwent wrong in 3d printing, and that the edge cuts and drill holes on the PCB\nare accurate to how they were specified in the design files.\n\nSolder each Omron switch to the board with the plungers aligned with the\noutline on the silkscreen illustration. Check and double check that the\nswitches are fully flush with the board before and while you solder them;\ndouble check that they're flush after soldering the first pin.\n\nTest fit the PCB into the shell bottom, and without screwing anything into\nanything else, attach the top half of the shell and make sure that the buttons\ncan be clicked properly and aren't clicked just by attaching the top half of\nthe shell. If they're hard to click or they click themselves, your 3d printer\nhas poor tolerances, and you may need to adjust the button pieces by softening\nthem with the hot air tool and bending them slightly until they fit just\nright. Once you're done here, remove the PCB from the shell.\n\nSolder the scroll wheel encoder in into the RotaryEncoder footprint on the\nPCB. Be very sure that it's all the way down before and while soldering it.\nYou may need to twist the pins very slightly with a pair of needle-nose pliers\nto get them to fit into their holes; the holes are very narrow, on purpose, to\nreduce the chance of solder bridges forming between them.\n\n(Example photo of a 11mm Alps-compatible encoder. 11mm is the distance between\nthe center of the rotor and the surface of the PCB, not the top to bottom of\nthe entire encoder.)\n\nSolder the PMW3360 sensor to the center of the PCB, making VERY, VERY sure\nthat it's in ALL THE WAY before and while soldering it. If it's not in all the\nway, the PCB may not fit properly in the shell, and/or the sensor may fail to\ntrack properly. The sensor must be mounted \"upside-down\" relative to the rest\nof the board, such that the text on it is upside-down compared to the text at\nthe top of the board. If you put the sensor in the wrong way, it will look\nuncentered; if you put it in the right way (upside-down), it will look\ncentered. If you get the wrong, the sensor might fry itself when you turn the\nmouse on, and the lens might not even fit against the sensor through the PCB.\n\nAttach the lens to the sensor on the underside of the PCB. Then, slot the PCB\ninto the bottom shell and make sure it fully fits all the way down.\n\nIf, at this point, you connect the mouse to USB again and check what it says\nin the Arduino IDE's \"Serial Logger\" when the mouse boots, and the SROM's ID\nis a value other than zero or 0xFF, the sensor is working properly. If it's\nworking properly but still doesn't track, double check the value of the LED\nresistor; that's the component closest to the \"U10\" silkscreen text, also near\nfour diodes arranged in a rectangle (not in a row). The resistor value should\nbe 39 ohms, or something very close like 40. If the resistor value is wrong,\nyou have to desolder it and bodge on 40 ohms worth of discrete resistors (I\npersonally use two 20 ohm resistors in series). WARNING: Using too few ohms\nwill permanently damage the sensor's LED and make the sensor useless.\n\nRemove the PCB and fit the side button thumb pieces to their switches. This is\ndifficult and should feel like you're almost going to break the thumb pieces,\nbut not like you're definitely going to break them. The long piece of the\nswitch brace should wrap around the \"inside\" of the switches (towards the\nother side button switch), not the \"outside\". To get the thumb pieces around\nthe switches, first fit the \"hook\" to the bottom around the edge of the PCB,\nslightly offset from the switch, and rotate the thumb piece down so that the\nfar end of its brace hits the top of the switch. Move it as far from the\nswitch as you comfortably can, so that it doesn't have to bend too much to\nslide down past the top and around the other side of the switch. Once that\nhappens, slide it towards the switch so that the small hook piece at the end\nof the brace fully wraps around the other corner of the switch. Repeat this\nfor the other switch's thumb piece.\n\nAbove is a visual image series depicting the process for mounting the thumb\nbutton pieces. It's OK if they crack or break while attempting to fit them;\nthey will still fit and work, just be slightly less snug than they're supposed\nto be.\n\nFit scroll wheel brace around the middle mouse button (near the right mouse\nbutton), with the spikes towards the \"inside\" of the mouse and away from the\nmiddle mouse button. Now fit the scroll wheel and make sure it's snug and\nproperly balanced. If it's not, you'll need to reprint it.\n\nPut the PCB back into the shell bottom and make sure it's still snug. Route\nthe USB cable behind the support post in the back of the case (it has a screw\nhole in it) and around the right side of the PCB (NOT the left side), hugging\nthe right side of the right mouse button, and then feed it out through the\nslot in the front. Use hot glue to secure the USB cable to that front slot.\nMake sure that it points relatively straight out the front when you hot glue\nit down.\n\nPlug it in, compile and upload the firmware from the Arduino IDE, and make\nsure everything works. If it does, you're done! Just re-screw everything\ntogether. Be careful not to overtighten the side screws; doing so can cause\ntheir mounting holes to split.\n\n## License\n\n3360_Mouse_pico.ino, the main file of this project, is released under the\nApache License, version 2.0.\n\nrelmouse_16.h is based on files from mbed OS, also licensed under the Apache\nLicense, version 2.0. https://github.com/arduino/ArduinoCore-mbed\n\nThe hardware design files (under \"Case Model\" and \"KiCad schematic + PCB\") are\nlicensed under the SolderpadLicense, version 2.1, as follows:\n\n    \n    \n    Copyright 2024 wareya SPDX-License-Identifier: Apache-2.0 WITH SHL-2.1 Licensed under the Solderpad Hardware License v 2.1 (the \u201cLicense\u201d); you may not use this file except in compliance with the License, or, at your option, the Apache License version 2.0. You may obtain a copy of the License at https://solderpad.org/licenses/SHL-2.1/ Unless required by applicable law or agreed to in writing, any work distributed under the License is distributed on an \u201cAS IS\u201d BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.\n\n## About\n\nCompletely open source DIY gaming mouse, including hardware (PCB, shell)\ndesign files\n\n### Resources\n\nReadme\n\nActivity\n\n### Stars\n\n99 stars\n\n### Watchers\n\n6 watching\n\n### Forks\n\n4 forks\n\nReport repository\n\n## Releases\n\nNo releases published\n\n## Packages 0\n\nNo packages published\n\n## Languages\n\n  * C 56.5%\n  * C++ 43.5%\n\n## Footer\n\n\u00a9 2024 GitHub, Inc.\n\nYou can\u2019t perform that action at this time.\n\n", "frontpage": false}
