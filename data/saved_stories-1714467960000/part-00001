{"aid": "40206825", "title": "A few facts about POSIX", "url": "https://vorakl.com/articles/posix/", "domain": "vorakl.com", "votes": 3, "user": "vorakl", "posted_at": "2024-04-30 03:05:38", "comments": 0, "source_title": "A few facts about POSIX - Vorakl's notes", "source_text": "A few facts about POSIX - Vorakl's notes\n\nVorakl's notes\n\n  * Reading\n  * Projects\n  * Contacts\n  * About\n\n# A few facts about POSIX\n\non 2024-04-23 in article about cs os programming ~8 min read\n\n### A journey to portable software\n\nTLDR: quick summary of the article\n\n## How did we get there?\n\nIn the early days of computing, programmers could only dream of portability.\nAll programs were written directly in machine code for each computer\narchitecture they were intended to run on. Assembly languages with mnemonic\nnames for each CPU instruction and other goodies made programmers' lives a\nlittle easier, but programs were still architecture-specific. Operating\nsystems (OS) had not yet been invented, so a program not only controlled the\nentire computer system, it also had to initialize and manage the peripherals.\nIn fact, such bare-metal programs implemented drivers for every device they\nused. And every time a program needed to run on hardware with a different\narchitecture, it was literally rewritten to accommodate a difference in the\nCPU instruction set, memory layout, and so on.\n\nThis is exactly what happened with Unix, which was originally written in\nassembly language by Ken Thompson over 50 years ago. The first versions of\nUnix were written for the PDP-7 platform, and porting it to the PDP-11 meant\nrewriting the code. When Dennis Ritchie created the C programming language,\nand together they rewrote most of the Unix code in it, software portability\nsuddenly became possible. There are two main reasons for this. First, the code\nwritten in a high-level programming language is platform-agnostic, because\ncompilers translate it into the assembly language for a target architecture.\nThis is even more important for target systems based on RISC CPUs, as they\nrequire writing significantly more assembly instructions than CISC CPU\narchitecture. Even porting Unix to another platform was mostly a matter of\nadapting the architecture-dependent parts of the code. On the other hand, the\noperating system itself abstracts away all hardware specifics from a user\nprogram. Programmers don't have to implement multitasking, memory management,\nor drivers for different devices as they used to, because it's all part of the\nOS kernel and runs in the kernel address space. In contrast, user programs run\nin the user address space and access all of the features provided by the OS\nthrough the the system call interface. In Real-time OSes, such as Zephyr OS,\nit's slightly different, but the idea of memory isolation and protection for\nuser programs is preserved. This leads to two conclusions:\n\n  * User programs become portable when they are written in a high-level programming language for a particular OS. Once both requirements are met, programs are compiled into instructions for a target CPU and linked with system functions provided by the libc and OS-specific libraries to access the underlying hardware.\n  * Portability is intended to be achieved at the source code level.\n\n## The birth of POSIX\n\nThis could have been the end of the story, but something fateful happened. Due\nto a legal restriction, AT&T was not allowed to sell Unix, so there was no\nmoney to be made from the newly born OS, which became increasingly popular\nafter it was introduced to the world. However, it turned out to be possible to\ndistribute Unix to any interested organization for the cost of the media.\nThat's how Unix got to Berkeley in 1974 and many other places, leading to the\ncreation of a number of OS derivatives. Some of the best known and still\npopular today are OSes based on the software distributed by Berkley (BSD),\ne.g. FreeBSD and OpenBSD. Despite sharing the same ancestors and principles,\neach operating system followed its own unique path. Each of these operating\nsystems had a unique interface (API) and implementation of kernel subsystems,\nsyscalls, different system tools, etc. Even libc, which provides common\nfunctionality and wrappers on top of syscalls, used to be very OS-specific.\nAll of these OSes were Unix-like, but at the same time, it wasn't possible to\ntake the source code of a program written for one OS and recompile it on\nanother.\n\nOver 35 years ago, these problems with software portability led to the\nemergence of the first POSIX standard in 1988. The acronym was coined by\nRichard Stallman, who added \"X\" to the end of Portable Operating System\nInterface. It's meant to provide a specification of the interface that\ndifferent Unix operating systems should have in common, including programming\nlanguages and tools. It's important to note that the interface is portable,\nand not the implementation.\n\nThis was the common ground that made it possible to compile the same source\ncode of a user program on any OS without modification, if both sides strictly\nfollowed the same standard. And this is still true to some extent today, as\nmost modern and widely used Unix-like systems, such as Linux, and *BSD, do not\nstrictly and completely follow POSIX standard, but rather use it as a guide.\nHowever, there are a number of operating systems, such as MacOS, that are\nfully compliant with the POSIX standard and can therefore be called Unix\noperating systems, not just Unix-like. Originally, POSIX was only created for\nUnix-like OSes, but over time it became so popular that its specification, in\nthe form of the Operating System Abstraction Layer (OSAL), was partially\nimplemented (some subset of the interface that applicable to the target\nsystem) in non-Unix OSes, such as Windows, FreeRTOS, Zephyr, etc.\n\n## The POSIX spec\n\nThe very first standard was ratified by the IEEE in 1988 as IEEE Std\n1003.1-1988, so it's called POSIX.1-1988. Since then, the standard has gone\nthrough several revisions, with different subsets of the specification being\nratified under different names. For example, POSIX.1-1990 (IEEE 1003.1-1990)\ndefined the system interface and computing environment, POSIX.2 (IEEE Std\n1003.2-1992) defined command language (shell) and tools, etc. A very good and\nbrief overview of the standard's revisions can be found in the standards(7)\nLinux man page. You may even come across references to some old revisions,\nsuch as POSIX.2, for example, when reading the Bash source code. In 2001,\nPOSIX.1, POSIX.2, and the Single UNIX Specification (SUS) were merged into a\nsingle document called POSIX.1-2001. Despite the somewhat misleading name, it\ndoes include the shell and tools specifications from POSIX.2. The latest\nversion of the standard is POSIX.1-2017, also known as IEEE Std 1003.1-2017,\nwhich is almost identical to POSIX.1-2008.\n\nThe document of the standard basically describes a specification that spans\nover two environments (a build-time and a run-time) and is represented by a\nfew volumes:\n\n  * Base Definitions: defines common to all volumes general terms and concepts, conformant requirements (symbolic constants, options, option groups), computing environment (locales, regexp, directory structure, tty, environment variables, etc), and C-language header files which need to be implemented by the compliant systems.\n  * System Interfaces: defines the C language standard (ISO C99, ISO/IEC 9899:1999), system service functions, and the extension of the C standard library (libc) in terms of header files and functions.\n  * Shell & Utilities: defines a source code-level interface to the Shell Command Language (sh) and the system utilities (awk, sed, wc, cat, ...), including behavior, command line parameters, exit statuses, etc.\n  * Rationale: includes considerations for portability, subprofiling, option groups, and additional rationale that didn't fit any other volumes.\n\nThe current POSIX standard defines source code-level compatibility for only\ntwo programming languages: The C language (C99) and the command language\n(shell). Strictly speaking, the C standard library (libc) doesn't have to\nimplement any additional functionality (functions and headers) that is not\ndefined by the C standard (ISO C99 in this case), but most of them do. For\nexample, the ISO C99 standard, defines 24 header files, including math\nfunctions (<math.h>), standard input/output (<stdio.h>), date and time\n(<time.s>), signal management (<signal.h>), string operations (<string.h>),\nand so on. However, the latest POSIX standard, defines 82 header files and,\nbeing fully compliant with ISO C99, extends it with with POSIX threads\n(<pthreads.h>), semaphores (<semaphore.h>), and many others. Modern libc\nimplementations, e.g. musl libc, are also very OS-specific, providing library\nfunctions to access operating system services (wrappers for system calls).\nSometimes, the overlap with the POSIX specifications leads to difficulties in\nimplementing the POSIX abstraction layer in the non-Unix operating systems,\nwhich also use some portable standalone libc implementations with their own\nPOSIX support, e.g. using picolibc together with Zephyr's POSIX library.\n\n## Options and Option Groups\n\nWhile POSIX standardizes the system interface (C language headers and\nfunctions), shell, and utilities, it is not necessary to follow the entire\nspecification to be POSIX conformant. Some features in \"POSIX System\nInterfaces\", \"POSIX Shell and Utilities\", and \"XSI System Interfaces\" are\noptional. The <unistd.h> header file contains definitions of the standard\nsymbolic constants for Options, which reflect a particular feature, and Option\nGroups which define a set of related functions or options. Names of option\ngroups, unlike options, typically do not begin with the underscore symbol.\nPOSIX Conformant systems are intended to implement and support a set of\nmandatory options with one or more additional options. The symbolic constants\nfor mandatory options should have specific values, e.g. 200809L, while other\noptions may be\n\n  * undefined or contain -1, which means that the option is not supported for compilation\n  * 0, which means the option might or might not be supported at runtime\n  * some other value, which means the option is always supported\n\nThese symbolic constants are used by user applications to check the\navailability of a particular feature. At the C source code-level, constansts\nmay be checked either at build time (in #if preprocessing directives) or at\nruntime, by calling one of the sysconf(), pathconf(), fpathconf(), or\nconfstr(3) functions. In the shell source code, the getconf utility should be\nused for runtime checks. A very good collection of the POSIX options, their\ncorresponding names for use as the sysconf(3) parameters, and the list of\nheader files and functions that these options represent can be found in the\nposixoptions(7) Linux man page.\n\nSubprofiling Option Groups are intended for use within the systems where\nimplementing a full POSIX specification is not reasonable. For example, real-\ntime embedded systems are typically resource-constrained, do not have shells,\nuser interfaces, and OS kernels are often designed to run as a single process\n(with multiple threads). Such systems may only implement subsets of related\nfunctions defined by option groups.\n\n## Summary\n\n  * The development of high-level programming languages like C, along with operating systems that abstract away hardware details, enabled software portability at the source code level.\n  * The POSIX standard emerged in the 1988 to provide a portable interface specification for Unix-like operating systems, allowing programs to be compiled across different platforms.\n  * The POSIX standard has evolved over time, with the latest version being POSIX.1-2017 (IEEE Std 1003.1-2017).\n  * Modern Unix-like systems like Linux and *BSD do not strictly follow the POSIX standard, but rather use it as a guide.\n  * POSIX standardizes a based on ISO C99 (ISO/IEC 9899:1999) standard the C language API (header files and functions), the shell (command language) and system utilities.\n  * POSIX-compliant systems are expected to implement mandatory options and may support additional optional features.\n  * Applications can check for POSIX feature availability at both compile-time and runtime using symbolic constants and system functions.\n  * For resource-constrained systems like real-time embedded platforms, POSIX allows for the implementation of subsets of the full specification through \"subprofile\" option groups.\n\nFound a bug or typo? Please, send me feedback or submit a PR on Github.\n\n##### This is my personal blog. All ideas, opinions, examples, and other\ninformation that can be found here are my own and belong entirely to me. This\nis the result of my personal efforts and activities at my free time. It\ndoesn't relate to any professional work I've done and doesn't have\ncorrelations with any companies I worked for, I'm currently working, or will\nwork in the future.\n\n\u00a9 2024 vorakl All Rights Reserved\n\nPowered by Pelican and Aves theme\n\n", "frontpage": true}
