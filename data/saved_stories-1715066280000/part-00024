{"aid": "40280696", "title": "Advanced Ruby: The Chainable Request Pattern", "url": "https://thoughtbot.com/blog/advanced-ruby-the-chainable-request-pattern", "domain": "thoughtbot.com", "votes": 1, "user": "thunderbong", "posted_at": "2024-05-06 23:36:12", "comments": 0, "source_title": "Advanced Ruby: The Chainable Request Pattern", "source_text": "Advanced Ruby: The Chainable Request Pattern\n\nSkip to main content\n\nLive on Twitch!\n\n#### thoughtbot is livestreaming\n\nWork alongside the thoughtbot team as we collaborate with each other and our\nclients, live. Ask us anything, we're live right now!\n\nLet\u2019s get started!\n\nView all Services\n\nWeb Development\n\n  * Ruby on Rails\n  * React\n  * Maintenance\n  * AI and Machine Learning\n\nMobile Development\n\n  * React Native\n  * iOS\n  * Android\n\nDesign\n\n  * UX, UI, and Product Design\n  * Design Research\n  * Design Systems\n\nProduct\n\n  * Product Management\n  * Product Design Sprint\n  * Research and Strategic Insights\n  * Accessibility\n\nTeam & Processes\n\n  * Team Augmentation\n  * Fractional Leadership\n  * Team Level Up\n  * Recruiting and Hiring\n  * DevOps, SRE, Platform\n\nView all Services\n\nView all Resources\n\nDevelopment\n\n  * Open Source\n  * Books\n  * The Bike Shed Podcast\n  * Upcase\n  * Live Streaming on YouTube\n\nThe business of great software\n\n  * Playbook\n  * Startup Incubator\n  * Giant Robots Smashing Into Other Giant Robots Podcast\n  * Design Sprint Guide\n  * Live Streaming on LinkedIn\n\nView all Resources\n\n# Advanced Ruby: The Chainable Request Pattern\n\nThiago Ara\u00fajo Silva May 6, 2024\n\n  * ruby\n  * error handling\n  * api\n  * distributed systems\n  * fault tolerance\n  * rails\n\nIn the previous article of my series on error handling and fault tolerance, we\ndiscussed how to run external API requests in a transaction while handling\nerrors and making it fault-tolerant. That article is not a requirement to\nunderstand this one, so read on in either case!\n\nHere, we will explore some means of abstraction for the transactional pattern.\nYou will learn how to encapsulate API requests for use in an external\ntransaction, including:\n\n  * Automatic rollback on error;\n  * Support for running custom code in between requests;\n  * Chain multiple API requests with automatic rollback support;\n  * Return a chained result of all API requests.\n\nLet\u2019s call it the \u201cChainable Request Pattern\u201d.\n\n## The request object\n\nThe first step is to wrap the API request in a class. The code must return a\nresult object with the outcome:\n\n    \n    \n    Result = Struct.new(:status, :error_code, :id, keyword_init: true) do def success? status == :ok end def error? !success? end end class LineItemRequest BASE_URL = \"https://app.moderntreasury.com/api/\" HEADERS = {\"Content-Type\" => \"application/json\"}.freeze def self.execute(params) response = client.post(\"ledger_transactions\", JSON.dump(params)) if response.status == 200 Result.new(status: :ok, id: response.body[\"id\"]) else Result.new(status: :error, error_code: response.status) end end private_class_method def self.client Faraday.new(url: BASE_URL, headers: HEADERS) do |client| org_id = Configuration.organization_id api_key = Configuration.api_key client.response :json client.request :authorization, :basic, org_id, api_key end end end\n\nThe result object must return whether the request was successful or not.\n\n## The request runner\n\nThe role of the request runner is to execute a request object and optionally\nrun arbitrary code on success. Let\u2019s see how it could be implemented:\n\n    \n    \n    class RequestRunner def self.execute(request, params) result = request.execute(params) if block_given? && result.success? yield result end result end end\n\nUsing the request object is straightforward:\n\n    \n    \n    params = { description: \"Scientific Calculator\", status: \"pending\", ledger_entries: [ { amount: 10_00, direction: \"debit\", ledger_account_id: \"368feff6-fe48-44f0-95de-50ee1f2d1e50\", }, { amount: 10_00, direction: \"credit\", ledger_account_id: \"eec76db0-b537-47bf-a28d-3aa397f35f69\", }, ] } RequestRunner.execute LineItemRequest, params do |result| puts \"Success! ID: #{result.id}\" end\n\n## Rollbacks\n\nIf you are asking, \u201cHow can the request runner be helpful? It seems to be a\nthin wrapper that provides no value\u201d, that is a great question! And the\npreliminar answer is rollbacks. The request runner runs a request and executes\na block that optionally runs dependent code. If the dependent code fails, the\nrequest runner should automatically roll back the request.\n\nThe first step to implementing that is to write a rollback method in our\nrequest object:\n\n    \n    \n    class LineItemRequest # ... def self.execute(params) # Code for 'execute' goes here end def self.rollback(result, _params) return if result.nil? # Archiving is how we roll back our particular operation # in the Modern Treasury API. patch_params = {status: \"archived\"} client.patch \"ledger_transactions/#{result.id}\", JSON.dump(patch_params) end # ... end\n\nOur implementation example doesn\u2019t use params, so we simply prepend an\nunderline to the variable (_params) to hint that it\u2019s not used.\n\nIf you think this looks familiar, you\u2019re on point, as LineItemRequest\nimplements the Command pattern.\n\nSo far, every request object must implement the following interface:\n\n  * execute(params) - Returns a Struct result that responds to success?.\n  * rollback(result, params) - Returns void. Don\u2019t care for the return value.\n\nSecond, we need to hook up rollback to our request runner:\n\n    \n    \n    class RequestRunner def self.execute(request, params) result = request.execute(params) if block_given? && result.success? begin yield result rescue => e request.rollback(result, params) raise e end end result end end\n\nAnd we do that through an exception handler because we want to revert our\nsuccessful request if an exception is raised. After rollback, we still need to\nreraise the exception to signal an error to the application.\n\nWhy not roll back when the result is an error? Because it means the request\nfailed, so its side-effects were not applied. We don\u2019t need to roll back a\nfailed request. Exceptionally, a timeout could occur, and the request could\nstill make it through, but we wouldn\u2019t get a result with an ID that would\nallow rolling back.\n\nNow, let\u2019s execute the request and try to save an Active Record reference:\n\n    \n    \n    RequestRunner.execute LineItemRequest, params do result OrderLineItem.create! external_id: result.id end\n\nIn Rails, create! raises an exception on error. If that ever happens, our\nrequest will automatically roll back. Neat!\n\n## Chaining dependent requests\n\nDo you recall that the role of the success block is to run dependent code with\nrollback support? What if that code is another request? Would it work? Yes!\n\nHowever, chaining requests poses an exciting challenge: the caller needs to\nget the chained results of various requests. Managing local variables and\noverriding them in our success blocks would achieve that, but it\u2019s not\npractical:\n\n    \n    \n    result_1 = nil result_2 = nil RequestRunner.call ... do |r1| result_1 = r1 RequestRunner.call ... do |r2| result_2 = r2 end end final_result = [result_1, result_2]\n\nInstead, let\u2019s change the request runner to do that work behind the scenes and\nchain the results in a linked list. By wishful thinking, the API we want to\nachieve is:\n\n    \n    \n    # Different types of request can be chained, not just a single type result = RequestRunner.execute LineItemRequest, params_1 do |_result_1| RequestRunner.execute LineItemRequest, params_2 do |_result_2| RequestRunner.execute LineItemRequest, params_3 end end result # Result of the first request result.next_result # Result of the second request result.next_result.next_result # Result of the third request\n\nAlso, if the second or third request fails, the first result should be an\nerror; after all, it\u2019s an all or nothing transaction.\n\n    \n    \n    # Should always return false on error throughout the chain first_result.success?\n\nFinally, if the second request fails, the chain must halt and not run the\nthird request:\n\n    \n    \n    result.success? # false result.next_result.success? # false result.next_result.next_result # nil. Third request does not run.\n\nLet\u2019s see how we can achieve that. The first step is to change the request\nrunner to chain the previous result with the next result in case of success:\n\n    \n    \n    class RequestRunner def self.execute(request, params) result = request.execute(params) if block_given? && result.success? begin next_result = yield(result) rescue => e request.rollback(result, params) raise e end if next_result.respond_to?(:chain_result) result = result.chain_result(next_result) if next_result.error? request.rollback(result, params) end end end result end end\n\nWe only call chain_result if the current result is successful; otherwise, we\nreturn the current result unchanged.\n\nWe are naming our method chain_result to avoid overriding Struct\u2018s\nEnumerable#chain.\n\nWe are also rolling back the current request if the next result is an error,\nwhich is a great companion to the exception handler and makes our code work\nper our intended design. Oh, and if you are asking if that works recursively\nfor every chained request, the answer is yes! This will be clear down below,\nso read on.\n\nAnd, of course, we need to implement chain_result in our result object.\nBecause we want the \u201cchain\u201d ability in requests with different requirements,\nwe need a reusable module:\n\n    \n    \n    module ResultChainable attr_reader :next_result def initialize(next_result: nil, **attrs) super(**attrs) @next_result = next_result end def chain_result(next_result) attrs = { status: next_result.status, next_result: next_result } self.class.new(**to_h, **attrs) end end\n\nNote that ResultChainable requires the result object to respond to status and\nto_h (which comes free with Struct objects). The status of the chained result\nmust become the status of the next result because one error should make\neverything fail.\n\nNow, let\u2019s include the module in our result class:\n\n    \n    \n    Result = Struct.new(:status, :error_code, :id, keyword_init: true) do include ResultChainable def success? status == :ok end def error? !success? end end\n\nAnd try it out:\n\n    \n    \n    result_1 = Result.new(status: :ok, id: \"result-1-id\") result_2 = Result.new(status: :ok, id: \"result-2-id\") result_3 = Result.new(status: :error, error_code: \"101\") chained_result = result_1.chain_result(result_2.chain_result(result_3)) chained_result.status # :error, not :ok chained_result.id # \"result-1-id\" chained_result.success? # false, not true chained_result.next_result.status # :error, not :ok chained_result.next_result.id # \"result-2-id\" chained_result.next_result.success? # true chained_result.next_result.next_result.status # :error chained_result.next_result.next_result.success? # false chained_result.next_result.next_result.error_code # \"101\" chained_result.next_result.next_result.next_result # nil\n\nThis works as expected! Let\u2019s review our request chaining code:\n\n    \n    \n    chained_result = RequestRunner.execute LineItemRequest, params_1 do |_result_1| RequestRunner.execute LineItemRequest, params_2 do |_result_2| RequestRunner.execute LineItemRequest, params_3 do |_result_3| # ... end end end\n\nWith our code so far, the results are chained in a fold right fashion. For\nexample, assuming that the three above requests are indeed run, their three\nresults would get implicitly folded:\n\n    \n    \n    # This happens behind the scenes chained_result = result_1.chain_result(result_2.chain_result(result_3))\n\nNote that you can still run custom code before running the next request:\n\n    \n    \n    result = RequestRunner.execute LineItemRequest, params_1 do # Can still run arbitrary code here RequestRunner.execute LineItemRequest, params_2 do # Can still run arbitrary code here RequestRunner.execute LineItemRequest, params_3 end end\n\nLet\u2019s imagine a few scenarios to form a mental picture of how this all works.\n\nScenario 1: An exception is thrown in the success block of the third request.\nWhat happens: Requests 1 and 2 roll back. Chained result is error.\n\nScenario 2: Request 1 succeeds, request 2 returns a non-200 response. What\nhappens: Requests 1 rolls back. Request 3 does not run. Chained result is\nerror.\n\nScenario 3: Requests 1 and 2 succeed, request 3 returns a non-200 response.\nWhat happens: Requests 1 and 2 roll back. Chained result is error.\n\nScenario 4: All requests succeed, no exceptions thrown. What happens: No\nrollbacks. Chained result is success.\n\n## Flattening the chain\n\nIf you can, you should avoid running too many dependent requests. If you are\nrunning just a few requests, though, the nesting imposed by the block\nstructure should not be a big deal. But what if you need to run more than a\nfew requests? Then, unnesting the structure should improve clarity and\nreadability.\n\nIt also formalizes the overall pattern, which comes with a benefit regardless\nif you are running just a few requests or more than a few. Oh, and you can\nalso run requests dynamically with that!\n\nLet\u2019s imagine an API where we could flatten our requests:\n\n    \n    \n    on_line_item_success = -> { OrderLineItem.create!(external_id: _1.id) } array_of_arguments = [ [LineItemRequest, params_1, on_line_item_success], [OrderRequest, params_2], ] result = TransactionalRequestRunner.execute(array_of_arguments) # Do something with the result, or not\n\narray_of_arguments is a matrix that has the arguments of each request. For\neach request, we have the request class, the params, and an optional block to\nrun on the success of that request where we don\u2019t worry about request chaining\nbecause TransactionalRequestRunner will already do it for us.\n\nNow let\u2019s write the code to run a batch of requests in a transaction:\n\n    \n    \n    class TransactionalRequestRunner def self.execute(array_of_arguments) request, params, on_success = array_of_arguments.shift request.execute(params) do |result| on_success.call result if on_success unless array_of_arguments.empty? execute array_of_arguments end end end end\n\nAs you can see, TransactionalRequestRunner#execute is a recursive method that\nruns a request, and within the request\u2019s success block, it recursively calls\nitself to fire the subsequent request. It formalizes the overall pattern and\nleverages all the features we\u2019ve implemented.\n\n## What we haven\u2019t discussed\n\nWe can make both essential and nice-to-have improvements to this code, but\nI\u2019ll leave it as an exercise for the reader. For example:\n\n  * Make rollback asynchronous for fault tolerance and reducing the overall runtime;\n  * Improve HTTP response handling;\n  * Improve exception handling and isolate exceptions from third-party libraries;\n  * Support rolling back custom code that runs in between requests;\n  * Support traversing the linked list in the result object to collect data;\n  * Allow the on_success blocks in TransactionalRequestRunner to access the result of previous requests.\n\nWhat other improvements do you have in mind?\n\n## Wrapup\n\nYou can find the complete code examples here in this gist.\n\nI hope this article inspires you to up your external API code game! A more\nadvanced version of this pattern has been successfully used in production in a\nsystem that moves millions of dollars. Regardless of your app\u2019s size, these\nare all good practices you can adopt to make your code more resilient and\nfault-tolerant. It\u2019s not specific to the Ruby language, either.\n\nIf you want to dive deeper into the theory behind transactional API requests\nwith an eye on error handling and fault tolerance, I highly recommend you read\nthe previous article.\n\nI also recommend the first article in the series about the resumable pattern,\nwhich discusses a different approach for dealing with external API requests.\n\n## Footer\n\n  * Services\n  * Case Studies\n  * Resources\n  * Let's Talk\n\n  * Our Company\n  * Careers\n  * Purpose\n  * Blog\n  * Sponsor\n\n  * Mastodon\n  * GitHub\n  * Instagram\n  * YouTube\n  * twitch\n\n\u00a9 2024 thoughtbot, inc.\n\nThe design of a robot and thoughtbot are registered trademarks of thoughtbot,\ninc.\n\n  * US: +1 (877) 9-ROBOTS\n  * UK: +44 (0)20 3807 0560\n\n  * Beware of fraudulent thoughtbot job listings Learn more\n\n  * Code of Conduct\n  * Accessibility Statement\n  * Privacy Policy\n\n", "frontpage": false}
