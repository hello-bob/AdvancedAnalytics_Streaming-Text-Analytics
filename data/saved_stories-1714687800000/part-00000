{"aid": "40237835", "title": "Comprehensive Analysis of Design Patterns for REST API SDKs", "url": "https://vineeth.io/posts/sdk-development", "domain": "vineeth.io", "votes": 2, "user": "vvoruganti", "posted_at": "2024-05-02 16:07:23", "comments": 0, "source_title": "Comprehensive Analysis of Design Patterns for REST API SDKs", "source_text": "Comprehensive Analysis of Design Patterns for REST API SDKs\n\n# \ud83e\udd14 Vineeth's Thoughts\n\nSearch\n\n### Recent Posts\n\n  * ### Comprehensive Analysis of Design Patterns for REST API SDKs\n\nApr 30, 2024\n\n    * dev\n    * review\n\n  * ### Diving into the Dark Forest\n\nMar 28, 2024\n\n    * digital-gardens\n    * side-projects\n\n  * ### A Year with Fly and Developer Delight\n\nJan 11, 2024\n\n    * dev\n    * review\n\nSee 8 more \u2192\n\n# Comprehensive Analysis of Design Patterns for REST API SDKs\n\nApr 30, 202415 min read\n\n  * dev\n  * review\n\nFor the past few months I have been working on managing the Honcho project and\nits associated SDKs. We\u2019ve been taking the approach of developing the SDK\nmanually as we are focused on trying to find the best developer UX and\nmaximize developer delight.\n\nThis has led to a rather arduous effort that has required a large amount of\nrefactoring as we are making new additions to the project, and the\ncapabilities of the platform rapidly expand.\n\nWhile these efforts have been going on a new player in the SDK generation\nspace dropped on hacker news.\n\nWhen I first started working on Honcho I did a cursory look at a number of SDK\ngenerators, but wasn\u2019t impressed with the results I saw. However, a lot of\nthat was speculative and Honcho was not nearly as mature as it is now.\n\nSo spurred by the positive comments in the thread above I\u2019ve decided to do a\nmore detailed look into the space and, also try to develop a better\nunderstanding of what approaches are generally favorable in creating API\nclient libraries.\n\n## Background\n\nFor a full understanding of Honcho I recommend the great Simple Honcho Primer\npost, but I\u2019ll try to summarize the important details here.\n\nHoncho is a personalization platform for LLM applications. It is\ninfrastructure that developers can use for storing data related to their\napplications, deriving insights about their data and users, and evaluating the\nperformance of their applications. This functionality is exposed through a\nREST API interface with the following resource constructs.\n\n|____Apps |____|____Users |____|____|____Sessions |____|____|____|____Messages\n|____|____|____|____Metamessages |____|____|____Collections\n|____|____|____|____Documents\n\nSo Apps have Users that have Sessions and Collections where Sessions can have\nMessages and Metamessages and Collections can have Documents.\n\nAt the time of writing this post Honcho is being manually maintained with a\nsingular client SDK for the Python ecosystem. The SDK is co-located in the\nrepo.\n\nThe SDK is written in an object-oriented style where the top level Honcho\nobject will return lower level objects such as a User object and Session\nobjects. These objects contain the CRUD methods necessary to use them i.e.\n\n    \n    \n    from honcho import Honcho honcho = Honcho(\"Test App Name\") honcho.initialize() user = honcho.create_user(\"username\") session = user.create_session()\n\nThere is an Async version of the SDK with an AsyncHoncho class that uses\nobjects such as AsyncSession and AsyncUser.\n\n## Guiding Questions\n\nBefore evaluating the below platforms I wanted to investigate a few questions\nI had about how to design SDKs and how they are generally maintained in other\norganizations. I\u2019ve also included some questions I want to think about when\nlooking at the different platforms\n\nI\u2019m doing this through the lense of a Python developer as Honcho currently\nonly has a Python client library with plans to quickly expand to other\necosystems.\n\nGeneral SDK Questions\n\n  1. Do developers prefer an object-oriented approach or singleton approach for client SDKs that wrap a REST API?\n  2. What additional features are generally important in SDK design outside the functionality of the API (retry, pagination, etc.)?\n\nPlatform Specific Questions\n\n  1. How readable and easy to understand is the generated code?\n  2. How customizable is the end result?\n  3. How easy was it to use the tool?\n  4. What approach does the tool take? Object-oriented or singleton?\n  5. How does it handle async vs sync interfaces?\n\n## Research\n\n> First I took a look at sources and posts onlines that talk in general about\n> developing SDKs. This isn\u2019t an exhaustive look at every link I looked at,\n> but ones I thought were relevant. The notes are messy and not necessarily\n> fully formed sentences.\n\nAny design patterns and tips on writing an API client library\n\nThings they are laying out here.\n\nOne person\n\n  * Auth is really hard to figure out\n  * Retry logic and pagination is really important\n\nAnother person\n\n  * Keep data objects as just data and use other objects for transformations\n\n^ basically advocating for the singleton model\n\nPerson 3\n\n  * Also arguing for singleton approach. Made a good case where if you really only care about lower level stuff it\u2019s annoying\n\nFirstly, don\u2019t go over the top with object-oriented modelling. If you\u2019ve got\nan API call like:\n\nGET /locations/12345/customers/65432/orders/87678768 Don\u2019t implement this as:\n\n    \n    \n    client.location(12345).customer(65432).order(87678768).get()\n\nJust implement:\n\n    \n    \n    client.get_order(12345, 65432, 87678768)\n\nthat last one is better tbh it\u2019s just managing that data isn\u2019t done within the\nobject, which is my main problem.\n\nSo arguments for singleton approach are\n\n  * harder to go to lower levels from the start\n\nThe object-oriented approach looks more readable.\n\nA Design Pattern for Python API Client Libraries\n\nIt mainly covers how to build an singleton library but has this one snippet at\nthe end.\n\n> Other types of APIs This pattern works well for RPC-style APIs, but tends to\n> break down for more object-based or RESTful APIs as having a single\n> interface class gets messy quickly. In those cases I find it makes more\n> sense to break the interface down to resource-level, modeling things more\n> like an ORM. I\u2019ll cover that in a later post, next time I find the need to\n> build one.\n\nAt the time of this research there was no follow-up post.\n\nAsk HN: Best practices (and examples) for designing client libraries for APIs?\n\nThe first comment actually advocates for an object-oriented model but just\nusing the top level client object for authentication and setup stuff.\n\nMost of the sentiments kind of make me think using an object-oriented model\nmight make more sense.\n\nHow to design a good API and why it matters\n\nNothing really to note from there. It\u2019s more about the API itself and not the\nSDK.\n\nBuilding A Creative & Fun API Client In Ruby: A Builder Pattern Variation\n\nThis is basically a guy who saw an singleton approach and said I want an\nobject oriented approach.\n\nHow to design your API SDK\n\nA developer from twilio talking about their approach to creating helper\nlibraries and client libraries.\n\nA point he makes is that \u201cIf you\u2019ve designed your API in a RESTful way, your\nAPI endpoints should map to objects in your system\u201d\n\nThis point isn\u2019t explicitly asking for the object-oriented approach as the\nsingelton approach just moves the verbs to the singleton, but usually still\nhas data only objects for the different resources.\n\nI say this, but the examples seem to use an object-oriented model.\n\nHow to build an SDK from scratch: Tutorial & best practices\n\nWritten by one of the SDK generation platforms.\n\nIt talks in general terms about creating data objects and mapping methods to\nendpoints. One of the points is suggests as a good grouping method is to group\nfunctions in service classes, essentially advocating for an object-oriented\nmodel.\n\nDesigning Pythonic library APIs\n\nThe two takeaways that are the most important to me when looking at these are\n\n  * Design your library to be used as import lib ... lib.Thing() rather than from lib import LibThing ... LibThing().\n  * Avoid global state; use a class instead\n\nFrom that it seems using a singleton for are actions/verbs and then storing\ndata in dataclasses would support both of the requirements. The examples in\nthe post show a class that has functionality.\n\nUsing tree-shaking style imports should also allow for lower scopes. For\nexample when only worrying about messages for a particular session in honcho a\nuser could import just the messages namespace i.e.\n\n    \n    \n    from honcho.apps.users.sessions import messages messages.create(\"sample\")\n\nso there are pythonic ways to make the code less verbose. However the benefit\nof having the entire string is making it clearer what messages are being\ndiscusses. Are these Honcho mesages? LangChain messages? It can get messy that\nway especially in the LLM space where many libraries and components are\nconverging on similar naming schemes.\n\nBuild a Python SDK\n\nLooks like a guide made by Cisco. I paid special attention to the \u201cAPI Wrapper\nModule\u201d section. It was a really barebones example in this guide that just\nimplemented a very small client and put most of the attention on how to manage\nthe connection logic.\n\nIt used one singleton object that had all the methods available for the API.\nThere was no concept of resources or data objects here as no data was being\npersistently stored.\n\nHow to build a user-friendly Python SDK\n\nNoticing the trend of abstracting all connection logic for http requests to a\nseparate module and havign reusable methods for different http functions.\n\nMain focus of the post was just on good practices of documentation, testing,\nand logical organization.\n\nSDKs.io\n\nA more comprehensive repository of thoughts and principles around SDK design.\nMade by APIMATIC. which seems to be another player in the code generation\nspace.\n\nI paid special attention to the Build section under Best Practices, and\nspecifically the endpoints to methods and the models & serialization.\n\nThey state putting all methods in a single class (singleton) has the advantage\nof reducing the need to initialize classes, but can make the class size very\nlarge if there are many endpoints.\n\nGrouping methods into different namespaces could probably remove this problem\ntoo. A nested singleton can reduce the confusion, while still not needing to\nmess with classes and objects.\n\nIt generally seems popular to at the very least create types and data objects\nfor handling and storing API responses. They help with readability, type\nhints, data validations, etc. Regardless of the singleton or object-oriented\napproach data objects are something that should probably still be included.\n\nGenerating SDKs for your API\n\nAdvocates for using generators for making SDKs and talks about how different\nlanguages have different idioms and conventions that will be hard to manage.\n\nAlso mentions having the generator create data models.\n\nGuiding Principles for Building SDKs\n\nSome key insights\n\n  * Make sure documentation is very comprehensive\n  * Try to minimize external dependencies\n  * Have modular design patterns that make it easy to extend and pick and choose features.\n\nShould I implement OOP in a REST API?\n\nMost people seem to be saying a full OOP method is overkill, but there are\npeople advocating for having a controller class with methods that take data\nobjects as inputs. Essentially advocating for the singelton approach with data\nonly objects.\n\n### Analysis\n\nMany of the generic concerns of SDK design do not have to do with the UX of\nthe SDK for the end developer, rather background processes that an SDK handle.\nThis includes:\n\n  * Authentication\n  * Retry Logic\n  * Pagination\n  * Logging\n\nWhen it comes to the actual developer experience and interfaces for\ninteracting with the SDK the community seems a bit split. This is very much\nbecause of the boring fact that REST APIs are designed very differently and so\nit depends on the specifics of the API.\n\nSome APIs have many resources with basic CRUD operations. Others have many\ndifferent endpoints, but only have a few resources. The singleton architecture\nvs a strict object-oriented approach again seems to depend a lot. Some sources\nadvocate for a strict object-oriented approach where classes have their own\nmethods, while others advocate for a singleton approach stating objects are\noverkill.\n\nHowever, the singleton approach doesn\u2019t completely abandon the idea of objects\nand almost always advocates for data objects, or some kind of models that can\nbe used for type hints and validation.\n\nThere is some tradeoff regardless with problems arising at different levels of\nscale. The singleton approach could be verbose and cumbersome at smaller\nscales, but the object-oriented approach may not be a readable, and it could\nbe unclear what methods are doing in complex codebases. Even GPT-4 couldn\u2019t\ndecide between the two.\n\nAgain and again, the best way to approach SDK development is to just do\nwhatever is easier, and create tons of documentation that will help developers\nnavigate your API Ladder. Someone will get confused regardless of what you do,\nso the key is to make sure the SDK makes sense (even if it\u2019s not the most\nefficient or clean) and remove hurdles for users to navigate errors and\nmistakes.\n\n## SDK Generation Platforms\n\nWith a sense of the best standards for SDK design and additional features that\nshould be supported in the SDK I want to look at a few different options to\ndetermine what is the best solution to go with.\n\nBelow is a list of the different platforms I wanted to review\n\n  * Stainless\n  * Speakeasy\n  * liblab\n  * OpenAPI-Generator\n\nI was using the OpenAPI Spec for Honcho that was housed at\nhttps://demo.honcho.dev/openapi.json.\n\n### Stainless\n\nSince the hacker news thread for the release of stainless is what spurred this\nresearch I decided to try them out first.\n\nFrom their web portal they were able to take a link to the OpenAPI spec and\ngenerate a NodeJS and Python SDK immediately. There was no tweaking or\nanything necessary.\n\nI mainly paid attention to the Python SDK. The code was very readable and made\nsense. I also liked how it used httpx and pydantic by default and made an\nasync version of the interface. They took the singleton approach to the design\nof the interface. There was also built in capabilities for retries,\npagination, and auth.\n\nThere\u2019s also capability for adding custom code such as utility functions.\n\n### Speakeasy\n\nSpeakeasy required me to do everything locally through their brew package. It\ndid not immediately accept the OpenAPI Spec and required me to make some\ntweaks. These were low-hanging fruit, and their cli has a handly AI tool that\nwill diagnose the issue and tell you what to fix.\n\nI just had to add a list of servers and deduplicate some routes. I\u2019m happy it\nfound these errors, but there was some friction for me to get started.\nStainless just worked out of the box and made some logical assumptions.\n\nThe generated SDK didn\u2019t feel as strong as the stainless one. There didn\u2019t\nseem to support async methods, it did not use pydantic and used the built-in\nPython @dataclass. The methods had really unwieldy names, and looked like it\nwould need a lot of tweaking to get it more production ready.\n\n### Liblab\n\nAlso had me do the generation from the cli using their npm package. It was\npretty straightforward to login and give it an API spec. Liblab seems to\nrequire a lot tweaking to get better results. It gave me several warnings\nasking me to add tags to my API Spec. I did not add them and went ahead to\nlook at the generation.\n\n> I\u2019m not opposed to adding the tags if necessary, but I was able to get good\n> results without adding them on other platforms.\n\nThe results were also lack luster. The SDK took the singleton approach as\nwell, which seems to be the industry standard for codegen tools. The method\nnames were also unwieldy. It also didn\u2019t make use of pydantic and instead\nimplemented its own BaseModel class. It was built on the requests model and\ndoesn\u2019t seem to support async methods.\n\n### OpenAPI Generator\n\nThis is the only one on the list that is not expressly backed by a company\nwhose main goal is SDK generation. It is however a very popular project with\nmany sponsors.\n\nAgain, I tried to generate a client from the cli using their npm package. I\nused version 7.5.0 and once again gave it my API Spec. It gave a few warnings\nabout OpenAPI Spec v3.1 not being fully supported yet, but generated a package\neither way.\n\nI again was not too impressed with the results, however I did like it more\nthan liblab. The method names were also unwieldy, and the project relies on\nurllib3. I did not see an indication of support for an async client.\n\nThe repo did use pydantic for typing and data classes, which is a plus. Once\nagain, the sdk use the singleton approach.\n\nI also did not see any indication of functionality for retry logic,\nauthentication, or pagination.\n\n### Conclusion\n\nOverall, Stainless had the results that I liked the most. With almost no work\nfrom me, it produced a high quality SDK that designed things in a sensible way\nwith many built-in features such as retries, pagination, and auth.\n\nAll the platforms took the singleton approach with a host of data models so\nthere isn\u2019t much to compare in that regard.\n\nThe other platforms did not produce anything unusable, but they seemed to use\nless modern features and require a lot more massaging to get a desirable\nresult.\n\nThe docs for stainless also looked more clear, and it seems easier to add\ncustomizations after the fact.\n\nI will give Speakeasy some kudos for having documentation for different API\nframeworks. The FastAPI one made it easy to figure out what I needed to tweak\nand how to do it. The AI debugging feature was also a nice help.\n\nWhat I\u2019m looking for right now is the platform or tool that can reduce my work\nthe most and let me focus on other things and stainless achieved that. The\nresults are not perfect, but it doesn\u2019t look like it\u2019ll need more than some\nslight tweaking and testing to get to a state I want.\n\n## Future Work\n\nI want to see if I can combine an SDK generator platform with something like\nGritQL to automatically change the generated results to be in the format I\u2019d\nlike (singleton to object-oriented?)\n\n### Graph View\n\n  * Background\n  * Guiding Questions\n  * Research\n  * Analysis\n  * SDK Generation Platforms\n  * Stainless\n  * Speakeasy\n  * Liblab\n  * OpenAPI Generator\n  * Conclusion\n  * Future Work\n\n### Backlinks\n\n  * No backlinks found\n\nCreated with Quartz v4.2.3 \u00a9 2024\n\n  * GitHub\n  * LinkedIn\n  * Twitter\n  * RSS\n  * Colophon\n\n", "frontpage": false}
