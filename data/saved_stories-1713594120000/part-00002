{"aid": "40091712", "title": "Spring-It-On: The Game Developer's Spring-Roll-Call", "url": "https://theorangeduck.com/page/spring-roll-call", "domain": "theorangeduck.com", "votes": 1, "user": "lukejagg", "posted_at": "2024-04-19 20:45:52", "comments": 0, "source_title": "Spring-It-On: The Game Developer's Spring-Roll-Call", "source_text": "Spring-It-On: The Game Developer's Spring-Roll-Call\n\n\u2022 Projects \u2022 \u2022 Publications \u2022 \u2022 About \u2022 \u2022 All \u2022\n\n# Spring-It-On: The Game Developer's Spring-Roll-Call\n\n### Created on March 4, 2021, 5:49 p.m.\n\nSprings! What do springs have to do with game development? We'll if you're\nasking that question and reading this article you're in the right place.\nBecause we're about to do a lot of talking about springs... and, while some of\nyou may well have used springs before, I'm guessing that even if you did the\ncode you used resided in the dark depths of your project as a set of\nmysterious equations that no one ever touched.\n\nAnd that's sad, because although the maths can undeniably be tricky, springs\nare interesting, and a surprisingly versatile tool, with lots of applications\nin Computer Science that I never even realized were possible until I thought\n\"wouldn't it be nice to know how those equations came about?\" and dug a bit\ndeeper.\n\nSo I think every Computer Scientist, and in particular those interested in\ngame development, animation, or physics, could probably benefit from a bit of\nknowledge of springs. In the very least this: what they are, what they do, how\nthey do it, and what they can be used for. So with that in mind, let's start\nright from the beginning: The Damper.\n\n### The Damper\n\n  * The Damper\n  * The Exact Damper\n\n### The Spring Damper\n\n  * The Spring Damper\n  * The Exact Spring Damper\n  * Over, Under, and Critical Damping\n  * The Half-life and the Frequency\n  * The Damping Ratio\n  * The Critical Spring Damper\n\n### Applications\n\n  * Smoothing\n  * Filtering\n  * Controllers\n  * Inertialization\n  * Interpolation\n  * Resonance\n  * Extrapolation\n\n### Other Springs\n\n  * The Double Spring\n  * The Timed Spring\n  * The Velocity Spring\n  * The Quaternion Spring\n  * The Scale Spring\n  * The Tracking Spring\n\n### Conclusion\n\n  * Source Code\n  * Conclusion\n\n# The Damper\n\nAs a game developer here is a situation you've probably come across: for some\nreason there is an object which suddenly we realize should be at a different\nposition - perhaps we got some information from a game server about where it\nshould really be, or the player did something and now the object needs to be\nmoved. Well, when we move this object we probably don't want it to pop -\ninstead we would prefer if it moved more smoothly towards the new position.\n\nA simple thing we might try to achieve this is to just blend the object's\nposition x with the new goal position g by some fixed factor such as 0.1 each\nframe.\n\nIn C++ we might write something like this, and while this code is for a single\nfloat the same can be done for a position just by applying it to each\ncomponent of the vector independently.\n\n    \n    \n    float lerp(float x, float y, float a) { return (1.0f - a) * x + a * y; } float damper(float x, float g, float factor) { return lerp(x, g, factor); }\n\nBy applying this damper function each frame we can smoothly move toward the\ngoal without popping. We can even control the speed of this movement using the\nfactor argument:\n\n    \n    \n    x = damper(x, g, factor);\n\nBelow you can see a visualization of this in action where the horizontal axis\nrepresents time and the vertical axis represents the position of the object.\n\nBut this solution has a problem: if we change the framerate of our game (or\nthe timestep of our system) we get different behavior from the damper. More\nspecifically, it moves the object slower when we have a lower framerate:\n\nAnd this makes sense if we think about it - if the game is running at 30\nframes per second you are going to perform half as many calls to damper as if\nyou were running at 60 frames per second, so the object is not going to get\npulled toward the goal as quickly. One simple idea for a fix might be to just\nmultiply the factor by the timestep dt - now at least when the timestep is\nlarger the object will move more quickly toward the goal...\n\n    \n    \n    float damper_bad(float x, float t, float damping, float dt) { return lerp(x, t, damping * dt); }\n\nThis might appear like it works on face value but there are two big problems\nwith this solution which can come back to bite us badly. Firstly, we now have\na mysterious damping variable which is difficult to set and interpret. But\nsecondly, and more importantly, if we set the damping or the dt too high (such\nthat damping * dt > 1) the whole thing becomes unstable, and in the worst case\nexplodes:\n\nWe could use various hacks like clamping damping * dt to be less than 1 but\nthere is fundamentally something wrong with what we've done here. We can see\nthis if we imagine that damping * dt is roughly equal to 0.5 - here, doubling\nthe dt does not produce the same result as applying the damper twice: lerping\nwith a factor of 0.5 twice will take us 75% of the way toward the goal, while\nlerping with a factor of 1.0 once will bring us 100% of the way there. So\nwhat's the real fix?\n\n## The Exact Damper\n\nLet's start our investigation by plotting the behavior of x using the normal\ndamper with a fixed dt of 1.0, a goal of 0, and a factor of 0.5:\n\nHere we can see repeated calls to lerp actually produce a kind of exponential\ndecay toward the goal:\n\nt=0,t=1,t=2,t=3,xxxx=1.0=0.5=0.25=0.125\n\nAnd for a lerp factor of 0.5, we can see that this pattern is exactly the\nequation xt=0.5t. So it looks like somehow there is an exponential function\ngoverning this relationship, but how did this appear? The trick to uncovering\nthis exponential form is to write our system as a recurrence relation.\n\n#### Recurrence Relation\n\nWe'll start by defining a separate variable y=1\u2212damping\u22c5ft, which will make\nthe maths a bit easier later on. In this case ft is a fixed, small dt such as\n601. Then we will expand the lerp function:\n\nxt+1xt+1xt+1xt+1=lerp(xt,g,1\u2212y)=(1\u2212(1\u2212y))\u22c5xt+(1\u2212y)\u22c5g=y\u22c5xt\u2212(y\u22121)\u22c5g=y\u22c5xt\u2212y\u22c5g+g\n\nNow for the recurrence relation: by plugging this equation into itself we are\ngoing to see how the exponent appears. First we need to increment t+1 to t+2\nand then replace the new xt+1 which appears on the right hand side with the\nsame equation again.\n\nxt+1xt+2xt+2xt+2xt+2=y\u22c5xt\u2212y\u22c5g+g=y\u22c5xt+1\u2212y\u22c5g+g=y\u22c5(y\u22c5xt\u2212y\u22c5g+g)\u2212y\u22c5g+g=y\u22c5y\u22c5xt\u2212y\u22c5y\u22c5g+y\u22c5g\u2212y\u22c5g+g=y\u22c5y\u22c5xt\u2212y\u22c5y\u22c5g+g\n\nIf we repeat this process again and we can start to see a pattern emerging:\n\nxt+2xt+3xt+3xt+3xt+3=y\u22c5y\u22c5xt\u2212y\u22c5y\u22c5g+g=y\u22c5y\u22c5xt+1\u2212y\u22c5y\u22c5g+g=y\u22c5y\u22c5(y\u22c5xt\u2212y\u22c5g+g)\u2212y\u22c5y\u22c5g+g=y\u22c5y\u22c5y\u22c5xt\u2212y\u22c5y\u22c5y\u22c5g+y\u22c5y\u22c5g\u2212y\u22c5y\u22c5g+g=y\u22c5y\u22c5y\u22c5xt\u2212y\u22c5y\u22c5y\u22c5g+g\n\nMore generally we can see that:\n\nxt+n=yn\u22c5xt\u2212yn\u22c5g+g\n\nAh-ha! Our exponent has appeared. And by rearranging a bit we can even write\nthis in terms of lerp again:\n\nxt+nxt+nxt+n=yn\u22c5xt\u2212yn\u22c5g+g=yn\u22c5xt+g\u22c5(1\u2212yn)=lerp(xt,g,1\u2212yn)\n\nAs a small tweak, we can make the exponent negative:\n\nxt+nxt+n=lerp(xt,g,1\u2212yn)=lerp(xt,g,1\u2212y1\u2212n)\n\nRemember that n represents a multiple of ft, so if we have a new arbitrary dt\nwe will need to convert it to n first using n=ftdt. In C++ we would write it\nas follows:\n\n    \n    \n    float damper_exponential( float x, float g, float damping, float dt, float ft = 1.0f / 60.0f) { return lerp(x, g, 1.0f - powf(1.0 / (1.0 - ft * damping), -dt / ft)); }\n\nLet's see it action! Notice how it produces the same, identical and stable\nbehavior even when we make the dt and damping large.\n\nSo have we fixed it? Well, in this formulation we've essentially solved the\nproblem by letting the behavior of the damper match one particular timestep\nwhile allowing the rate of decay to still vary. In this case 1.0f - ft *\ndamping is our rate of decay, and it dictates what proportion of the distance\ntoward the goal will remain after ft in time. As long as we make the fixed\ntimestep ft small enough, ft * damping should never exceed 1.0 and the system\nremains stable and well behaved.\n\n#### The Half-Life\n\nBut there is another, potentially better way to fix the problem. Instead of\nfixing the timestep, we can fix the rate of decay and let the timestep vary.\nThis sounds a little odd at first but in practice it makes things much easier.\nThe basic idea is simple: let's set the rate of decay to 0.5 and instead scale\nthe timestep such that we can control the exact half-life of the damper -\na.k.a the time it takes for the distance to the goal to reduce by half:\n\nxt+dtxt+dt=lerp(xt,g,1\u22120.51\u2212dt/halflife)=lerp(xt,g,1\u22122\u2212dt/halflife)\n\nThis simplifies the code and gives a more intuitive parameter to control the\ndamper. Now we don't ever need to worry about if we've set the damping too\nlarge or made the fixed timestep ft small enough.\n\n    \n    \n    float damper_exact(float x, float g, float halflife, float dt) { return lerp(x, g, 1.0f - powf(2, -dt / halflife)); }\n\nFor neatness, we can also switch to an exponential base using the change of\nbase theorem: just multiply the dt by ln(2)=0.69314718056 and switch to using\nexpf. Finally, we should add some small epsilon value like 1e-5f to avoid\ndivision by zero when our halflife is very small:\n\n    \n    \n    float damper_exact(float x, float g, float halflife, float dt, float eps=1e-5f) { return lerp(x, g, 1.0f - expf(-(0.69314718056f * dt) / (halflife + eps))); }\n\nThe change of base theorem tells us another thing: that changing the rate of\ndecay is no different from scaling the dt in the exponent. So using the\nhalflife to control the damper should not limit us in any of the behaviors we\nwant to achieve compared to if we changed the rate of decay like in our\nprevious setup.\n\nThere is one more nice little trick we can do - a fast approximation of the\nnegative exponent function using one over a simple polynomial (or we could use\nthis even better approximation from Danny Chapman):\n\n    \n    \n    float fast_negexp(float x) { return 1.0f / (1.0f + x + 0.48f*x*x + 0.235f*x*x*x); }\n\nAnd that's it - we've converted our unstable damper into one that is fast,\nstable, and has intuitive parameters!\n\n    \n    \n    float damper_exact(float x, float g, float halflife, float dt, float eps=1e-5f) { return lerp(x, g, 1.0f-fast_negexp((0.69314718056f * dt) / (halflife + eps))); }\n\nLet's see how it looks...\n\nPerfect!\n\n# The Spring Damper\n\nThe exact damper works well in a lot of cases, but has one major issue - it\ncreates discontinuities when the goal position changes quickly. For example,\neven if the object is moving in one direction, it will immediately switch to\nmoving in the opposite direction if the goal changes direction. This can\ncreate a kind of annoying sudden movement which you can see in the previous\nvideos.\n\nThe problem is that there is no velocity continuity - no matter what happened\nin the previous frames the damper will always move toward the goal. Let's see\nhow we might be able to fix that. We can start by looking again at our old\nbroken bad damper, and examining it in a bit more detail:\n\nxt+dtxt+dt=lerp(xt,g,dt\u22c5damping)=xt+dt\u22c5damping\u22c5(g\u2212xt)\n\nWe can see that this looks a bit like a physics equation where damping\u22c5(g\u2212xt)\nrepresents the velocity.\n\nvt+dtxt+dt=damping\u22c5(g\u2212xt)=xt+dt\u22c5vt\n\nThis system is like a kind of particle with a velocity always proportional to\nthe difference between the current particle position and the goal position.\nThis explains the discontinuity - the velocity of our damper will always be\ndirectly proportional to the difference between the current position and the\ngoal without ever taking any previous velocities into account.\n\nWhat if instead of setting the velocity directly each step we made it\nsomething that changed more smoothly? For example, we could instead add a\nvelocity taking us toward the goal to the current velocity, scaled by a\ndifferent parameter which for now we will call the stiffness.\n\nvt+dtxt+dt=vt+dt\u22c5stiffness\u22c5(g\u2212xt)=xt+dt\u22c5vt\n\nBut the problem now is that this particle wont slow down until it has already\nover-shot the goal and is pulled back in the opposite direction. To fix this\nwe can add a q variable which represents a goal velocity, and add another term\nwhich takes us toward this goal velocity. This we will scale by another new\nparameter which we will call the damping (for reasons which will become\nclearer later in the article).\n\nvt+dtxt+dt=vt+dt\u22c5stiffness\u22c5(g\u2212xt)+dt\u22c5damping\u22c5(q\u2212vt)=xt+dt\u22c5vt\n\nWhen q is very small we can think of this like a kind of friction term which\nsimply subtracts the current velocity. And when q=0 and dt\u22c5damping=1 we can\nsee that this friction term actually completely removes the existing velocity,\nreverting our system back to something just like our original damper.\n\nAnother way to think about these terms is by thinking of them as\naccelerations, which can be shown more clearly by factoring out the dt:\n\nat+dtvt+dtxt+dt=stiffness\u22c5(g\u2212xt)+damping\u22c5(q\u2212vt)=vt+dt\u22c5at=xt+dt\u22c5vt\n\nAssuming the mass of our particle is exactly one, it really is possible to\nthink about this as two individual forces - one pulling the particle in the\ndirection of the goal velocity, and one pulling it toward the goal position.\nIf we use a small enough dt we can actually plug these functions together and\nsimulate a simple damped spring with exactly the velocity continuity we\nwanted. Here is a function which does that (using semi-implicit euler\nintegration).\n\n    \n    \n    void spring_damper_bad( float& x, float& v, float g, float q, float stiffness, float damping, float dt) { v += dt * stiffness * (g - x) + dt * damping * (q - v); x += dt * v; }\n\nLet's see how it looks:\n\nBut unfortunately just like before we have problems when the dt is large, and\ncertain settings for stiffness and damping can make the system unstable. These\nunintuitive parameters like damping and stiffness are also back again... arg!\n\nCan we give this spring the same treatment as we did for our damper by\nfiddling around with the maths? Well yes we can, but unfortunately from here\non in things are going to get a bit more complicated...\n\n## The Exact Spring Damper\n\nThis time the exact version of our model is too complicated to solve using a\nsimple recurrence relation. Instead we're going to have to try a different\ntactic: we're going to guess an equation we think models the spring and then\ntry to work out how to compute all the different parameters of that equation\nbased on the parameters we do know such as the damping and stiffness.\n\nIf we take a look at the movement of the spring in the previous section we can\nsee there are basically two features - an exponential decay toward the goal\nposition, and a kind of oscillation, a bit like a cos or sin function. So\nlet's try and come up with an equation which fits that kind of shape and go\nfrom there. What about something like this?\n\nxt=j\u22c5e\u2212y\u22c5t\u22c5cos(w\u22c5t+p)+c\n\nWhere j is the amplitude, y controls the time it takes to decay, a bit like\nour half-life parameter, t is the time, w is the frequency of oscillations, p\nis the phase of oscillations, and c is an offset on the vertical axis. This\nseems like a reasonable formulation of the behavior we saw previously.\n\nBut before we try to find all of these unknown parameters, let's write down\nthe derivatives of this function with respect to t too. We'll use vt to denote\nthe velocity, and at to denote the acceleration.\n\nxtvtat=j\u22c5e\u2212y\u22c5t\u22c5cos(w\u22c5t+p)+c=\u2212y\u22c5j\u22c5e\u2212y\u22c5t\u22c5cos(w\u22c5t+p)\u2212w\u22c5j\u22c5e\u2212y\u22c5t\u22c5sin(w\u22c5t+p)=y2\u22c5j\u22c5e\u2212y\u22c5t\u22c5cos(w\u22c5t+p)\u2212w2\u22c5j\u22c5e\u2212y\u22c5t\u22c5cos(w\u22c5t+p)+2\u22c5w\u22c5y\u22c5j\u22c5e\u2212y\u22c5t\u22c5sin(w\u22c5t+p)\n\nThose might look a bit scary but we can make them a lot less scary by just\nsummarizing some of the common terms:\n\nCS=j\u22c5e\u2212y\u22c5t\u22c5cos(w\u22c5t+p)=j\u22c5e\u2212y\u22c5t\u22c5sin(w\u22c5t+p)\n\nGiving us the following:\n\nxtvtat=C+c=\u2212y\u22c5C\u2212w\u22c5S=y2\u22c5C\u2212w2\u22c5C+2\u22c5w\u22c5y\u22c5S\n\n#### Finding the Spring Parameters\n\nOur plan for finding the first set of unknown parameters is as follows: we're\ngoing to substitute these new equations for xt, vt, and at into our previous\nequation of motion at=s\u22c5(g\u2212xt)+d\u22c5(q\u2212vt) (where d=damping and s=stiffness ) and\ntry to rearrange to solve for y, w, and c using all the other values we know:\ns, d, q, and g.\n\nBut first let's shuffle around some terms in this equation of motion:\nexpanding the stiffness and damping terms, moving some values onto the left\nhand side, and finally negating everything. This will make the next steps much\neasier for us.\n\nat00\u2212s\u22c5g\u2212d\u22c5qs\u22c5g+d\u22c5q=s\u22c5(g\u2212xt)+d\u22c5(q\u2212vt)=s\u22c5(g\u2212xt)+d\u22c5(q\u2212vt)\u2212at=s\u22c5g\u2212s\u22c5xt+d\u22c5q\u2212d\u22c5vt\u2212at=\u2212s\u22c5xt\u2212d\u22c5vt\u2212at=s\u22c5xt+d\u22c5vt+at\n\nNow let's substitute in our three new equations we just created for xt, vt,\nand at:\n\ns\u22c5g+d\u22c5qs\u22c5g+d\u22c5q=s\u22c5xt+d\u22c5vt+at=s\u22c5(C+c)+d\u22c5(\u2212y\u22c5C\u2212w\u22c5S)+((y2\u2212w2)\u22c5C+2\u22c5w\u22c5y\u22c5S)\n\nAnd by multiplying out and then gathering all the coefficients of C and S\ntogether we can get:\n\ns\u22c5g+d\u22c5qs\u22c5g+d\u22c5q\u2212s\u22c5cs\u22c5g+d\u22c5q\u2212s\u22c5c=s\u22c5(C+c)+d\u22c5(\u2212y\u22c5C\u2212w\u22c5S)+((y2\u2212w2)\u22c5C+2\u22c5w\u22c5y\u22c5S)=s\u22c5C+d\u22c5\u2212y\u22c5C\u2212d\u22c5w\u22c5S+y2\u22c5C\u2212w2\u22c5C+2\u22c5w\u22c5y\u22c5S=((y2\u2212w2)\u2212d\u22c5y+s)\u22c5C+(2\u22c5w\u22c5y\u2212d\u22c5w)\u22c5S\n\nThere is one more additional fact we can use to get the variables we need from\nthis equation: because C and S are essentially cos and sin functions with the\nsame phase, amplitude, and frequency, the only way this equation can be\nbalanced for all potential values of t, w, y, j and c is when both the\ncoefficients of C and S are zero and when the left hand side equals zero. This\ngives us three smaller equations to solve:\n\ns\u22c5g+d\u22c5q\u2212s\u22c5c(y2\u2212w2)\u2212d\u22c5y+s2\u22c5w\u22c5y\u2212d\u22c5w=0=0=0\n\n#### Finding c\n\nUsing equation (1) we can solve for c right away to get our first unknown!\n\ns\u22c5g+d\u22c5q\u2212s\u22c5cs\u22c5g+d\u22c5qg+sd\u22c5q=0=s\u22c5c=c\n\n#### Finding y\n\nAnd by rearranging equation (3) we can also find a solution for y:\n\n2\u22c5w\u22c5y\u2212d\u22c5wd\u22c5wd2d=0=2\u22c5w\u22c5y=2\u22c5y=y\n\n#### Finding w\n\nWhich we can substitute into equation (2) to solve for w:\n\n(y2\u2212w2)\u2212d\u22c5y+s((2d)2\u2212w2)\u2212d\u22c52d+s4d2\u2212w2\u22122d2+s4d2\u22122d2+ss\u22124d2s\u22124d2=0=0=0=w2=w2=w\n\n#### Finding the Spring State\n\nThere are two final unknown variables remaining: j, and p - the amplitude and\nthe phase. Unlike y, w, and c, these two are determined by the initial\nconditions of the spring. Therefore, given some initial position and velocity,\nx0 and v0, we can plug these in our equations along with t=0 to get some more\nequations we will use to find j and p:\n\nx0x0v0v0=j\u22c5e\u2212y\u22c50\u22c5cos(w\u22c50+p)+c=j\u22c5cos(p)+c=\u2212y\u22c5j\u22c5e\u2212y\u22c50\u22c5cos(w\u22c50+p)\u2212w\u22c5j\u22c5e\u2212y\u22c50\u22c5sin(w\u22c50+p)=\u2212y\u22c5j\u22c5cos(p)\u2212w\u22c5j\u22c5sin(p)\n\n#### Finding j\n\nLet's start with j. First we'll re-arrange our equation for x0 in terms of p:\n\nx0x0\u2212cjx0\u2212carccos(jx0\u2212c)=j\u22c5cos(p)+c=j\u22c5cos(p)=cos(p)=p\n\nAnd substitute this into our equation for v0:\n\nv0v0v0v0=\u2212y\u22c5j\u22c5cos(p)\u2212w\u22c5j\u22c5sin(p)=\u2212y\u22c5j\u22c5cos(arccos(jx0\u2212c))\u2212w\u22c5j\u22c5sin(arccos(jx0\u2212c))=\u2212y\u22c5j\u22c5jx0\u2212c\u2212w\u22c5j\u22c51\u2212j2(x0\u2212c)2=\u2212y\u22c5(x0\u2212c)\u2212w\u22c5j\u22c51\u2212j2(x0\u2212c)2\n\nWhich we can now rearrange for j:\n\nv0+y\u22c5(x0\u2212c)\u2212w\u22c5jv0+y\u22c5(x0\u2212c)(\u2212w\u22c5j)2(v0+y\u22c5(x0\u2212c))2w2(v0+y\u22c5(x0\u2212c))2w2(v0+y\u22c5(x0\u2212c))2+(x0\u2212c)2w2(v0+y\u22c5(x0\u2212c))2+(x0\u2212c)2=\u2212w\u22c5j\u22c51\u2212j2(x0\u2212c)2=1\u2212j2(x0\u2212c)2=1\u2212j2(x0\u2212c)2=j2\u2212(x0\u2212c)2=j2=j\n\nNice! Since this relies on squares and a square root, some sign information is\nlost. This means that in our code we will also need to negate j in the case\nthat x0\u2212c<0.\n\n#### Finding p\n\nFinally, we are ready to find p. We can start by rearranging our velocity\nequation v0 for j:\n\nv0v0\u2212y\u22c5cos(p)\u2212w\u22c5sin(p)v0=\u2212y\u22c5j\u22c5cos(p)\u2212w\u22c5j\u22c5sin(p)=j\u22c5(\u2212y\u22c5cos(p)\u2212w\u22c5sin(p))=j\n\nAnd then substitute this into our equation for x0 to solve for p:\n\nx0x0x0\u2212cx0\u2212cx0\u2212c(x0\u2212c)\u22c5(\u2212y\u2212w\u22c5tan(p))\u2212(x0\u2212c)\u22c5y\u2212(x0\u2212c)\u22c5w\u22c5tan(p)\u2212(x0\u2212c)\u22c5w\u22c5tan(p)tan(p)p=j\u22c5cos(p)+c=(\u2212y\u22c5cos(p)\u2212w\u22c5sin(p)v0)\u22c5cos(p)+c=\u2212y\u22c5cos(p)\u2212w\u22c5sin(p)v0\u22c5cos(p)=\u2212y\u2212w\u22c5cos(p)sin(p)v0=\u2212y\u2212w\u22c5tan(p)v0=v0=v0=v0+(x0\u2212c)\u22c5y=\u2212(x0\u2212c)\u22c5wv0+(x0\u2212c)\u22c5y=arctan(\u2212(x0\u2212c)\u22c5wv0+(x0\u2212c)\u22c5y)\n\n#### Putting it together\n\nPutting all of this together, and throwing in a fast approximate atanf for\nfun, we get the following...\n\n    \n    \n    float fast_atan(float x) { float z = fabs(x); float w = z > 1.0f ? 1.0f / z : z; float y = (M_PI / 4.0f)*w - w*(w - 1)*(0.2447f + 0.0663f*w); return copysign(z > 1.0f ? M_PI / 2.0 - y : y, x); } float squaref(float x) { return x*x; } void spring_damper_exact( float& x, float& v, float x_goal, float v_goal, float stiffness, float damping, float dt, float eps = 1e-5f) { float g = x_goal; float q = v_goal; float s = stiffness; float d = damping; float c = g + (d*q) / (s + eps); float y = d / 2.0f; float w = sqrtf(s - (d*d)/4.0f); float j = sqrtf(squaref(v + y*(x - c)) / (w*w + eps) + squaref(x - c)); float p = fast_atan((v + (x - c) * y) / (-(x - c)*w + eps)); j = (x - c) > 0.0f ? j : -j; float eydt = fast_negexp(y*dt); x = j*eydt*cosf(w*dt + p) + c; v = -y*j*eydt*cosf(w*dt + p) - w*j*eydt*sinf(w*dt + p); }\n\nPhew - that was a lot of equations and re-arranging, but it worked, and\nproduces a smooth, stable motion even with a very large dt or stiffness. And\nanyway, doesn't it feel nice to actually use those high school trig identities\nand do some old school equation manipulation for once!\n\n## Over, Under, and Critical Damping\n\nBut hold on... one of the steps we took in the previous section wasn't really\nlegit... can you spot it? Here is the problem:\n\nw=s\u22124d2\n\nIt's a square root... but I never assured you the input to this square root\ncouldn't be negative. In fact it can be... and definitely will be if d is\nlarge!\n\nBut what does this negative square root actually correspond to? Does it mean\nthat there is no exact solution to this spring when the damping is large? Do\nwe just have to give up? Well, not exactly...\n\nIn fact we didn't notice when we came up with our original equation to model\nthe behavior of the spring, but there are three different ways this spring can\nact depending on the relative sizes of the damping and stiffness values.\n\nIf s\u22124d2>0 it means the spring is under damped, causing oscillations to appear\nwith motions governed by the equations we already derived. If s\u22124d2=0 it means\nthe spring is critically damped, meaning it returns to the goal as fast as\npossible without extra oscillation, and if s\u22124d2<0 it means the spring is over\ndamped, and will return slowly toward the goal.\n\nIn each of these cases there is a different set of basic equations governing\nthe system, leading to a different derivation just like the one we completed.\nI'm going to save us a bit of time and write them all our here rather than\ngoing through the trial and error process of examining different guesses at\nequations and seeing if they fit:\n\n#### Under Damped:\n\nxtvtat=j\u22c5e\u2212y\u22c5t\u22c5cos(w\u22c5t+p)+c=\u2212y\u22c5j\u22c5e\u2212y\u22c5t\u22c5cos(w\u22c5t+p)\u2212w\u22c5j\u22c5e\u2212y\u22c5t\u22c5sin(w\u22c5t+p)=y2\u22c5j\u22c5e\u2212y\u22c5t\u22c5cos(w\u22c5t+p)\u2212w2\u22c5j\u22c5e\u2212y\u22c5t\u22c5cos(w\u22c5t+p)+2\u22c5w\u22c5y\u22c5j\u22c5e\u2212y\u22c5t\u22c5sin(w\u22c5t+p)\n\n#### Critically Damped:\n\nxtvtat=j0\u22c5e\u2212y\u22c5t+t\u22c5j1\u22c5e\u2212y\u22c5t+c=\u2212y\u22c5j0\u22c5e\u2212y\u22c5t\u2212y\u22c5t\u22c5j1\u22c5e\u2212y\u22c5t+j1\u22c5e\u2212y\u22c5t=y2\u22c5j0\u22c5e\u2212y\u22c5t+y2\u22c5t\u22c5j1\u22c5e\u2212y\u22c5t\u22122\u22c5y\u22c5j1\u22c5e\u2212y\u22c5t\n\n#### Over Damped:\n\nxtvtat=j0\u22c5e\u2212y0\u22c5t+j1\u22c5e\u2212y1\u22c5t+c=\u2212y0\u22c5j0\u22c5e\u2212y0\u22c5t\u2212y1\u22c5j1\u22c5e\u2212y1\u22c5t=y02\u22c5j0\u22c5e\u2212y0\u22c5t+y12\u22c5j1\u22c5e\u2212y1\u22c5t\n\nWhat we did in the previous section was solve for the under damped case, but\nthe other two cases require exactly the same style of derivation to get them\nworking.\n\n#### Solving the Critically Damped Case\n\nLet's start with the easiest: the critically damped case. The first two\nunknowns c and y have exactly the same solution as in the under-damped case,\nc=g+sd\u22c5q and y=2d, while the other two unknowns j0 and j1 can be found easily\nfrom the initial conditions x0, v0, and t=0:\n\nx0x0=j0\u22c5e\u2212y\u22c50+0\u22c5j1\u22c5e\u2212y\u22c50+c=j0+c\n\nAnd for the velocity...\n\nv0v0=\u2212y\u22c5j0\u22c5e\u2212y\u22c50\u2212y\u22c50\u22c5j1\u22c5e\u2212y\u22c5t+j1\u22c5e\u2212y\u22c50=\u2212y\u22c5j0+j1\n\nGiving us...\n\nj0j1=x0\u2212c=v0+j0\u22c5y\n\nAnd that's it, easy!\n\n#### Solving the Over Damped Case\n\nThe over-damped case is a little more difficult so let's first summarize some\nterms again to make our equations clearer.\n\nE0E1=j0\u22c5e\u2212y0\u22c5t=j1\u22c5e\u2212y1\u22c5t\n\nGiving us...\n\nxtvtat=E0+E1+c=\u2212y0\u22c5E0\u2212y1\u22c5E1=y02\u22c5E0+y12\u22c5E1\n\nWe'll start by finding the two unknowns y0, and y1. Just like before we are\ngoing to substitute these equations into our equation of motion, gathering up\nthe coefficients for the exponential terms:\n\ns\u22c5g+d\u22c5qs\u22c5g+d\u22c5qs\u22c5g+d\u22c5qs\u22c5g+d\u22c5q\u2212s\u22c5c=s\u22c5xt+d\u22c5vt+at=s\u22c5(E0+E1+c)+d\u22c5(\u2212y0\u22c5E0\u2212y1\u22c5E1)+(y02\u22c5E0+y12\u22c5E1)=s\u22c5E0+s\u22c5E1+s\u22c5c\u2212d\u22c5y0\u22c5E0\u2212d\u22c5y1\u22c5E1+y02\u22c5E0+y12\u22c5E1=(s\u2212d\u22c5y0+y02)\u22c5E0+(s\u2212d\u22c5y1+y12)\u22c5E1\n\nAgain, just like before, this equation is only solved when both coefficients\nand the left hand side equal zero. This gives us our existing solution for c\nplus two more quadratic equations to solve:\n\ns\u2212d\u22c5y0+y02s\u2212d\u22c5y1+y12=0=0\n\nIn this case y0 and y1 represent the two different solutions to the same\nquadratic, so we can use the quadratic formula to get these:\n\ny0y1=2d+d2\u22124\u22c5s=2d\u2212d2\u22124\u22c5s\n\nNow that these are found we're ready to solve for j0 and j1 using the initial\nconditions x0, v0, and t=0:\n\nx0x0v0v0=j0\u22c5e\u2212y0\u22c50+j1\u22c5e\u2212y1\u22c50+c=j0+j1+c=\u2212y0\u22c5j0\u22c5e\u2212y0\u22c50\u2212y1\u22c5j1\u22c5e\u2212y1\u22c50=\u2212y0\u22c5j0\u2212y1\u22c5j1\n\nFirst we'll re-arrange our eqiation for x0 in terms of j0\n\nx0x0\u2212j1\u2212c=j0+j1+c=j0\n\nWhich we'll substitute into our equation for v0 to solve for j1:\n\nv0v0v0\u2212v0y0\u22c5c\u2212v0\u2212y0\u22c5x0y0\u22c5c\u2212v0\u2212y0\u22c5x0y1\u2212y0y0\u22c5c\u2212v0\u2212y0\u22c5x0=\u2212y0\u22c5j0\u2212y1\u22c5j1=\u2212y0\u22c5(x0\u2212j1\u2212c)\u2212y1\u22c5j1=\u2212y0\u22c5x0+y0\u22c5j1+y0\u22c5c\u2212y1\u22c5j1=y0\u22c5x0\u2212y0\u22c5j1\u2212y0\u22c5c+y1\u22c5j1=\u2212y0\u22c5j1+y1\u22c5j1=j1\u22c5(y1\u2212y0)=j1\n\nAfter which is is easy to get j0:\n\nx0x0\u2212j1\u2212c=j0+j1+c=j0\n\nAnd that's it! Let's add all of these different cases to our spring damper\nfunction:\n\n    \n    \n    void spring_damper_exact( float& x, float& v, float x_goal, float v_goal, float stiffness, float damping, float dt, float eps = 1e-5f) { float g = x_goal; float q = v_goal; float s = stiffness; float d = damping; float c = g + (d*q) / (s + eps); float y = d / 2.0f; if (fabs(s - (d*d) / 4.0f) < eps) // Critically Damped { float j0 = x - c; float j1 = v + j0*y; float eydt = fast_negexp(y*dt); x = j0*eydt + dt*j1*eydt + c; v = -y*j0*eydt - y*dt*j1*eydt + j1*eydt; } else if (s - (d*d) / 4.0f > 0.0) // Under Damped { float w = sqrtf(s - (d*d)/4.0f); float j = sqrtf(squaref(v + y*(x - c)) / (w*w + eps) + squaref(x - c)); float p = fast_atan((v + (x - c) * y) / (-(x - c)*w + eps)); j = (x - c) > 0.0f ? j : -j; float eydt = fast_negexp(y*dt); x = j*eydt*cosf(w*dt + p) + c; v = -y*j*eydt*cosf(w*dt + p) - w*j*eydt*sinf(w*dt + p); } else if (s - (d*d) / 4.0f < 0.0) // Over Damped { float y0 = (d + sqrtf(d*d - 4*s)) / 2.0f; float y1 = (d - sqrtf(d*d - 4*s)) / 2.0f; float j1 = (c*y0 - x*y0 - v) / (y1 - y0); float j0 = x - j1 - c; float ey0dt = fast_negexp(y0*dt); float ey1dt = fast_negexp(y1*dt); x = j0*ey0dt + j1*ey1dt + c; v = -y0*j0*ey0dt - y1*j1*ey1dt; } }\n\nAwesome! Now it works even for very high damping values!\n\n## The Half-life and the Frequency\n\nWe're almost there, but our functions still use these mysterious damping and\nstiffness parameters. Can we turn these into something a bit more meaningful?\nYes! Just like before we can use a halflife parameter instead of a damping\nparameter by controlling what we give as input to the exp functions:\n\n    \n    \n    float halflife_to_damping(float halflife, float eps = 1e-5f) { return (4.0f * 0.69314718056f) / (halflife + eps); } float damping_to_halflife(float damping, float eps = 1e-5f) { return (4.0f * 0.69314718056f) / (damping + eps); }\n\nHere as well as our previous constant of ln(2) we need to multiply by 4. This\nis a bit of a fudge factor but roughly it corresponds to the fact that we\ndivide by two once to get y from d, and that the spring equation is usually a\nsum of two exponential terms instead of the single one we had for the damper.\n\nWhat about the stiffness parameter? Well this one we can turn into a parameter\ncalled frequency:\n\n    \n    \n    float frequency_to_stiffness(float frequency) { return squaref(2.0f * M_PI * frequency); } float stiffness_to_frequency(float stiffness) { return sqrtf(stiffness) / (2.0f * M_PI); }\n\nWhich is close to what will become w in the under-damped case.\n\nBoth are not completely honest names - the velocity continuity and\noscillations of the spring means that the position will not be exactly half\nway toward the goal in halflife time, while the frequency parameter is more\nlike a pseudo-frequency as the rate of oscillation is also affected by the\ndamping value. Nonetheless, both give more intuitive controls for the spring\nthan the damping and stiffness alternatives.\n\nAlong these lines, another useful set of functions are those that give us\nsettings for these two parameters in the critical case (i.e. when 4d2=s ).\nThese can be useful for setting defaults or in other cases when we only want\nto set one of these parameters.\n\n    \n    \n    float critical_halflife(float frequency) { return damping_to_halflife(sqrtf(frequency_to_stiffness(frequency) * 4.0f)); } float critical_frequency(float halflife) { return stiffness_to_frequency(squaref(halflife_to_damping(halflife)) / 4.0f); }\n\nThe critical_halflife function doesn't make that much sense since when\ncritical there aren't any oscillations, but it can still be useful in certain\ncases. Putting it all together we can provide our spring with a nicer\ninterface:\n\n    \n    \n    void spring_damper_exact( float& x, float& v, float x_goal, float v_goal, float frequency, float halflife, float dt, float eps = 1e-5f) { float g = x_goal; float q = v_goal; float s = frequency_to_stiffness(frequency); float d = halflife_to_damping(halflife); float c = g + (d*q) / (s + eps); float y = d / 2.0f; ... }\n\nBelow you can see which critical frequency corresponds to a given halflife.\nAnd now I promise we really are done: that's it, an exact damped spring!\n\n## The Damping Ratio\n\nAlthough controlling the frequency is nice, there is a different control which\nmay be even better for users as it resembles a bit more the scale from less\nspringy to more springy they might want. This is the damping ratio, where a\nvalue of 1 means a critically damped spring, a value <1 means an under-damped\nspring, and a value >1 means a over-damped spring.\n\nThe equation for the damping ratio r is as follows, where d is the damping and\ns is the stiffness:\n\nr=2 sd\n\nThis we can re-arrange to solve for stiffness or damping as required.\n\n    \n    \n    float damping_ratio_to_stiffness(float ratio, float damping) { return squaref(damping / (ratio * 2.0f)); } float damping_ratio_to_damping(float ratio, float stiffness) { return ratio * 2.0f * sqrtf(stiffness); }\n\nAnd use instead of the frequency.\n\n    \n    \n    void spring_damper_exact_ratio( float& x, float& v, float x_goal, float v_goal, float damping_ratio, float halflife, float dt, float eps = 1e-5f) { float g = x_goal; float q = v_goal; float d = halflife_to_damping(halflife); float s = damping_ratio_to_stiffness(damping_ratio, d); float c = g + (d*q) / (s + eps); float y = d / 2.0f; ... }\n\nAnd here it is in action!\n\n## The Critical Spring Damper\n\nLooking at our exact spring damper, the critical case is particularly\ninteresting for us (and is most likely the case you may have actually used in\nyour games) - not only because it's the situation where the spring moves\ntoward the goal as fast as possible without additional oscillation, but\nbecause it's the easiest to compute and also to use as it has fewer\nparameters. We can therefore make a special function for it, which will allow\nus to remove the frequency parameter and throw in a few more basic\noptimizations:\n\n    \n    \n    void critical_spring_damper_exact( float& x, float& v, float x_goal, float v_goal, float halflife, float dt) { float g = x_goal; float q = v_goal; float d = halflife_to_damping(halflife); float c = g + (d*q) / ((d*d) / 4.0f); float y = d / 2.0f; float j0 = x - c; float j1 = v + j0*y; float eydt = fast_negexp(y*dt); x = eydt*(j0 + j1*dt) + c; v = eydt*(v - j1*y*dt); }\n\nWith no special cases for over-damping and under-damping this can compile down\nto something very fast. Separate functions for other common situations can be\nuseful too, such as when the goal velocity q is zero...\n\n    \n    \n    void simple_spring_damper_exact( float& x, float& v, float x_goal, float halflife, float dt) { float y = halflife_to_damping(halflife) / 2.0f; float j0 = x - x_goal; float j1 = v + j0*y; float eydt = fast_negexp(y*dt); x = eydt*(j0 + j1*dt) + x_goal; v = eydt*(v - j1*y*dt); }\n\nor when the goal position is zero too...\n\n    \n    \n    void decay_spring_damper_exact( float& x, float& v, float halflife, float dt) { float y = halflife_to_damping(halflife) / 2.0f; float j1 = v + x*y; float eydt = fast_negexp(y*dt); x = eydt*(x + j1*dt); v = eydt*(v - j1*y*dt); }\n\nAnother optimization that can be useful is to pre-compute y and eydt for a\ngiven halflife. If there are many springs that need to be updated with the\nsame halflife and dt this can provide a big speed-up.\n\n# Applications\n\n## Smoothing\n\nProbably the most common application of springs in game development is\nsmoothing - any noisy signal can be easily smoothed in real time by a spring\ndamper and the half life can be used to control the amount of smoothing\napplied vs how responsive it is to changes.\n\n## Filtering\n\nSprings also work well for filtering out sudden changes or jitters in signals,\nand even springs with quite a small halflife will do really well at removing\nany sudden jitters.\n\n## Controllers\n\nAnother common application of springs in game development is for moving\ncharacters. The usual process is to take the user input from the gamepad and\nturn it into a desired character velocity, which we then set as the goal for a\nspring. Each timestep we tick this spring and use what it produces as a\nvelocity with which to move the character. By tweaking the parameters of the\nspring we can achieve movement with different levels of smoothness and\nresponsiveness.\n\nThe slightly unintuitive thing to remember about this setup is that we are\nusing the spring in a way such that its position corresponds to the\ncharacter's velocity - meaning the spring's velocity will correspond to the\ncharacter's acceleration.\n\nAssuming the desired character velocity remains fixed we can also use this\nspring to predict the future character velocity by simply by evaluating the\nspring with a larger dt than we normally would and seeing what the result is.\n\nIf we want the character's position after some timestep (not just the\nvelocity) we can compute it more accurately by using the the integral of our\ncritical spring equation with respect to time. This will give us an accurate\nprediction of the future position of the character too.\n\nxtxt=\u222b(j0\u22c5e\u2212y\u22c5t+t\u22c5j1\u22c5e\u2212y\u22c5t+c)dt=y2\u2212j1\u22c5e\u2212y\u22c5t+y\u2212j0\u2212j1\u22c5t\u22c5e\u2212y\u22c5t+y2j1+yj0+c\u22c5t+x0\n\nAnd translated into code...\n\n    \n    \n    void spring_character_update( float& x, float& v, float& a, float v_goal, float halflife, float dt) { float y = halflife_to_damping(halflife) / 2.0f; float j0 = v - v_goal; float j1 = a + j0*y; float eydt = fast_negexp(y*dt); x = eydt*(((-j1)/(y*y)) + ((-j0 - j1*dt)/y)) + (j1/(y*y)) + j0/y + v_goal * dt + x; v = eydt*(j0 + j1*dt) + v_goal; a = eydt*(a - j1*y*dt); }\n\nThis code is the same as the critically damped spring, but applied to the\ncharacter velocity and the integral used to compute the character position. If\nwe want to predict the future trajectory we can use this to update arrays of\ndata each with a different dt:\n\n    \n    \n    void spring_character_predict( float px[], float pv[], float pa[], int count, float x, float v, float a, float v_goal, float halflife, float dt) { for (int i = 0; i < count; i++) { px[i] = x; pv[i] = v; pa[i] = a; } for (int i = 0; i < count; i++) { spring_character_update(px[i], pv[i], pa[i], v_goal, halflife, i * dt); } }\n\nThis really shows how using a completely exact spring equation comes in handy\n- we can accurately predict the state of the spring at any arbitrary point in\nthe future without having to simulate what happens in between.\n\nHere you can see me moving around a point in the world using the above code\nand a desired character velocity coming from the gamepad. By adjusting the\nhalflife of the spring we can achieve different levels of responsiveness and\nsmoothness, and by evaluating the spring at various different times in the\nfuture we can predict where the character would be if the current input were\nto remain fixed (shown in red).\n\nThis is exactly the method we use to predict the future character trajectory\nin Learned Motion Matching.\n\n## Inertialization\n\nIn game animation, inertialization is the name given to a kind of blending\nthat fades in or out an offset between two animations. Generally it can be use\nas a more performant alternative to a cross-fade blend since it only needs to\nevaluate one animation at a time. In the original presentation a polynomial is\nused blend out this offset smoothly, but springs can be used for this too.\n\nThe idea is this: if we have two different streams of animation we wish to\nswitch between, at the point of transition we record the offset between the\ncurrently playing animation and the one we want to switch to. Then, we switch\nto this new animation but add back the previously recorded offset. We then\ndecay this offset smoothly toward zero over time - in this case using a spring\ndamper.\n\nIn code it looks something like this. First at the transition point we record\nthe offset in terms of position and velocity between the currently playing\nanimation src and the one we're going to switch to dst:\n\n    \n    \n    void inertialize_transition( float& off_x, float& off_v, float src_x, float src_v, float dst_x, float dst_v) { off_x = (src_x + off_x) - dst_x; off_v = (src_v + off_v) - dst_v; }\n\nWe then switch to this animation, and at every frame we decay this offset\ntoward zero, adding the result back to our currently playing animation.\n\n    \n    \n    void inertialize_update( float& out_x, float& out_v, float& off_x, float& off_v, float in_x, float in_v, float halflife, float dt) { decay_spring_damper_exact(off_x, off_v, halflife, dt); out_x = in_x + off_x; out_v = in_v + off_v; }\n\nHere you can see it in action:\n\nAs you can see, each time we toggle the button there is a transition between\nthe two different streams of animation (in this case two different sin waves\nshown in red), while the inertialization smoothly fills in the difference\n(shown in blue).\n\nUnlike the original presentation which uses a polynomial to blend out the\noffset over a specific period, a spring does not provide a fixed blend time\nand can easily overshoot. However the exponential decay does mean it tends to\nlook smooth and blends out to something negligible at a very fast rate. In\naddition, since there is no need to remember the last transition time the code\nis very simple, and because we use the decay_spring_damper_exact variant of\nthe spring it can be made exceptionally fast, in particular when all the\nblends for the different bones use the same halflife and dt to update.\n\nThis is exactly the method we use for switching between animations in our\nMotion Matching implementation as demonstrated in Learned Motion Matching.\n\n## Interpolation\n\nThe time dimension of a spring doesn't have to always be the real time that\nticks by - it can be any variable that increases monotonically. For example we\ncould use the parameterization along a curve as the time dimension to feed to\na spring to produce a kind of spline.\n\nHere I set up a piecewise interpolation of some 2D control points and used\nthat as position and velocity goal for two springs (one for each dimension in\n2D).\n\n    \n    \n    void piecewise_interpolation( float& x, float& v, float t, float pnts[], int npnts) { t = t * (npnts - 1); int i0 = floorf(t); int i1 = i0 + 1; i0 = i0 > npnts - 1 ? npnts - 1 : i0; i1 = i1 > npnts - 1 ? npnts - 1 : i1; float alpha = fmod(t, 1.0f); x = lerp(pnts[i0], pnts[i1], alpha); v = (pnts[i0] - pnts[i1]) / npnts; }\n\nThe result is a kind of funky spline which springs toward the control points.\nBy adjusting the halflife and frequency we can produce some interesting shapes\nbut overall the result has an odd feel to it since it's not symmetric and\nusually doesn't quite reach the last control point. Perhaps some more\nexperimentation here could be interesting, such as running two springs along\nthe control points in opposite directions and mixing the result.\n\nI think there is probably still a way to formulate an interesting and useful\ntype of spline using springs. Tell me if you manage to come up with anything\ninteresting!\n\n## Resonance\n\nIf you've got a signal which you think contains at specific frequency but you\ndon't know exactly which frequency it is what do you do? Well, I can already\nsee you starting to type \"fast fourier transform\" into google but hold on a\nsecond, do you really need to do something that complicated?\n\nSprings can be used to see if a signal is oscillating at a specific frequency!\nFed with a goal moving at their resonate frequency springs will oscillate and\nbuild up energy, while fed a goal moving at any other frequency will make them\ndie out and lose energy.\n\nWe can measure the energy of the spring using the sum of potential and\nkinematic energies.\n\n    \n    \n    float spring_energy( float x, float v, float frequency, float x_rest = 0.0f, float v_rest = 0.0f, float scale = 1.0f) { float s = frequency_to_stiffness(frequency); return ( squaref(scale * (v - v_rest)) + s * squaref(scale * (x - x_rest))) / 2.0f; }\n\nThen, if we want to see which frequency is contained in a signal we can simply\ndrive a spring (or multiple springs at different frequencies) and see which\nsetting produces the most energy.\n\nAs mentioned in the previous sections, the frequency parameter we're using\ndoesn't actually reflect the true resonate frequency of the spring (the true\nresonate frequency is also affected by the damping), but we can find the\nfrequency we need to set a spring to match some resonant frequency by fixing\nthe halflife:\n\n    \n    \n    float resonant_frequency(float goal_frequency, float halflife) { float d = halflife_to_damping(halflife); float goal_stiffness = frequency_to_stiffness(goal_frequency); float resonant_stiffness = goal_stiffness - (d*d)/4.0f; return stiffness_to_frequency(resonant_stiffness); }\n\nWhen trying to pick out specific frequencies the halflife of the spring\naffects the sensitivity. A long halflife (or low damping) means the spring\nwill only build up energy when driven at frequencies very close to its\nresonate frequency, and it will build up more energy too. While a shorter\nhalflife means a broader range of frequencies that build up energy.\n\nFor a really cool application of this idea check out this blog post by Kevin\nBergamin.\n\n## Extrapolation\n\nIf we have an object moving at a velocity with damping applied we can use a\ndamper to estimate a what the position might be at some time in the future.\n\nThe idea is to assume the velocity is being reduced over time via an\nexponential decay (i.e. via a damper):\n\nvt=v0\u22c5e\u2212y\u22c5t\n\nThen, like in the controller example, we can then take the integral of this\nequation to work out the exact future position at some time t:\n\nxtxt=\u222bv0\u22c5e\u2212y\u22c5tdt=yv0 (1\u2212e\u2212y\u22c5t)+x0\n\nIn code it looks something like this where halflife controls the decay rate of\nthe velocity.\n\n    \n    \n    void extrapolate( float& x, float& v, float dt, float halflife, float eps = 1e-5f) { float y = 0.69314718056f / (halflife + eps); x = x + (v / (y + eps)) * (1.0f - fast_negexp(y * dt)); v = v * fast_negexp(y * dt); }\n\nAnd here is a little demo showing it in action:\n\n# Other Springs\n\n## Double Spring\n\nYou'll notice that the spring damper has a kind of asymmetric look to it - the\nstart is very steep and it quickly evens out. We can achieve more of an \"S\"\nshape to the spring by using another spring on the goal. We'll deem this the\n\"double spring\":\n\n    \n    \n    void double_spring_damper_exact( float& x, float& v, float& xi, float& vi, float x_goal, float halflife, float dt) { simple_spring_damper_exact(xi, vi, x_goal, 0.5f * halflife, dt); simple_spring_damper_exact(x, v, xi, 0.5f * halflife, dt); }\n\nAnd here you can see it in action:\n\nIn red you can see the intermediate spring xi while in blue you can see the\n\"double spring\" which has a slightly more \"S\" shaped start and end.\n\n## Timed Spring\n\nIn some cases we might not want the spring to reach the goal immediately but\nat some specific time in the future - yet we might still want to keep the\nsmoothing and filtering properties the spring brings when the goal changes\nquickly. Here is a spring variant that takes as input a goal time as well as a\ngoal position and tries to achieve the goal at approximately the correct time.\nThe idea is to track a linear interpolation directly toward the goal but to do\nso some time in the future (to give the spring time to blend out once it gets\nclose to the goal).\n\n    \n    \n    void timed_spring_damper_exact( float& x, float& v, float& xi, float x_goal, float t_goal, float halflife, float dt, float apprehension = 2.0f) { float min_time = t_goal > dt ? t_goal : dt; float v_goal = (x_goal - xi) / min_time; float t_goal_future = dt + apprehension * halflife; float x_goal_future = t_goal_future < t_goal ? xi + v_goal * t_goal_future : x_goal; simple_spring_damper_exact(x, v, x_goal_future, halflife, dt); xi += v_goal * dt; }\n\nHere the apprehension parameter controls how far into the future we try to\ntrack the linear interpolation. A value of 2 means two-times the half life, or\nthat we expect the blend-out to be 75% done by the goal time. Below we can see\nthis spring in action, with the linear interpolation toward the goal shown in\nred.\n\n## Velocity Spring\n\nWe can use a similar idea to make a spring that tries to maintain a given\nvelocity by tracking an intermediate target that moves toward the goal at that\nfixed velocity.\n\n    \n    \n    void velocity_spring_damper_exact( float& x, float& v, float& xi, float x_goal, float v_goal, float halflife, float dt, float apprehension = 2.0f, float eps = 1e-5f) { float x_diff = ((x_goal - xi) > 0.0f ? 1.0f : -1.0f) * v_goal; float t_goal_future = dt + apprehension * halflife; float x_goal_future = fabs(x_goal - xi) > t_goal_future * v_goal ? xi + x_diff * t_goal_future : x_goal; simple_spring_damper_exact(x, v, x_goal_future, halflife, dt); xi = fabs(x_goal - xi) > dt * v_goal ? xi + x_diff * dt : x_goal; }\n\nAnd here is how this one looks, with the intermediate target shown in red.\n\n## Quaternion Spring\n\nThe simplified code of the simple spring damper also lends itself to be easily\nadapted to other things such as quaternions. Here the main trick is to convert\nquaternion differences into angular velocities (first convert to angle axis\nthen scale the axis by the angle) so that they can interact with the other\nterms such as the exponential terms and the spring velocity.\n\n    \n    \n    void simple_spring_damper_exact_quat( quat& x, vec3& v, quat x_goal, float halflife, float dt) { float y = halflife_to_damping(halflife) / 2.0f; vec3 j0 = quat_to_scaled_angle_axis(quat_mul(x, quat_inv(x_goal))); vec3 j1 = v + j0*y; float eydt = fast_negexp(y*dt); x = quat_mul(quat_from_scaled_angle_axis(eydt*(j0 + j1*dt)), x_goal); v = eydt*(v - j1*y*dt); }\n\nOne thing that is perhaps unintuitive about this derivation is the fact that\nwe actually compute a rotation which takes the goal toward the initial state\nrather than the other way around (which is what we might expect).\n\nIt's a good exercise to try and do this same style of derivation for other\nspring variants and other quantities such as angles, but I'll leave that as an\nexercise for you...\n\n## Scale Spring\n\nIn this post I show how we can derive an equation for a spring that works on\nobject scales.\n\n## Tracking Spring\n\nSee this article for a spring which can be used to perfectly track animation\ndata while still removing discontinuities.\n\n# Conclusion\n\n## Source Code\n\nThe source code for all the demos shown in this article can be found here.\nThey use raylib and more specifically raygui but once you have both of those\ninstalled you should be ready to roll.\n\n## Conclusion\n\nI hope this article has piqued your interest in springs. Don't hesitate to get\nin contact if you come up with any other interesting derivations,\napplications, or spring variations. I'd be more than happy to add them to this\narticle for others to see. Other than that there is not much more to say -\nhappy exploring!\n\n", "frontpage": false}
