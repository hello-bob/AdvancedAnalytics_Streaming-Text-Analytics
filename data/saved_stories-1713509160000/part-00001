{"aid": "40081439", "title": "Hydradancer: Faster USB Emulation for Facedancer", "url": "https://blog.quarkslab.com/./hydradancer-faster-usb-emulation-for-facedancer.html", "domain": "quarkslab.com", "votes": 3, "user": "todsacerdoti", "posted_at": "2024-04-18 22:31:39", "comments": 0, "source_title": "Hydradancer: Faster USB Emulation for Facedancer", "source_text": "Hydradancer: Faster USB Emulation for Facedancer - Quarkslab's blog\n\nQuarkslab's blog\n\n  * Archives\n\n# Hydradancer: Faster USB Emulation for Facedancer\n\nDate Thu 18 April 2024 By Thi\u00e9baud Fuchs Category Hardware Tags USB USB2 USB3\nHydraUSB3 Facedancer RISC-V embedded fuzzing open-source release tool 2024\n\nIn this blogpost, we present Hydradancer, a new board for Facedancer based on\nHydraUSB3 allowing faster USB peripherals emulation.\n\nUSB (Universal Serial Bus) is the current standard for connecting peripherals\nto devices. USB is used to connect keyboards, mouses, printers, music\ninstruments, storage, cameras and pretty much everything to a device. This\nmakes it the perfect target for security researchers with physical access to a\nUSB port.\n\nWhile exchanging with USB peripherals can be done in Python with PyUSB^1 on\nany PC, creating custom USB peripherals for security assessment and testing\n(e.g. attack surface analysis, scanning, fuzzing) of USB hosts can be more\nchallenging as it requires specific hardware. That's where Facedancer came in\n12 years ago: Facedancer^2 is a Python library from Great Scott Gadgets that\ninteracts with a dedicated hardware capable of creating USB devices, allowing\nyou to create and modify a USB2 peripheral in seconds. However, the\nflexibility of Facedancer comes with a cost: data has to go from the target\nhost to the controlling PC, then back to the target host using a much longer\npath than a regular USB device would use. The current implementation of\nFacedancer is based on backends, which support different hardwares:\nFacedancer21^3/Raspdancer^4/BeagleDancer^5, GreatFET One ^6 and the Moondancer\nbackend for the upcoming Cynthion board^7. While Moondancer should bring USB2\nHigh-speed support (480Mb/s), Facedancer is currently stuck to USB2 Full-speed\n(1.5Mb/s) with instability issues.\n\nWith the open-source project Hydradancer, we bring a USB2 High-speed backend\nto Facedancer using the USB3 capabilities of HydraUSB3, a platform based on\nthe RISC-V WCH569 chip. While emulating USB3 peripherals is still out of the\nquestion with the current delays, Hydradancer brings improved speeds and\nstability for USB2 peripheral emulation. As the WCH569 lacks documentation for\nUSB3 and a proper SDK, a lot of testing was required to get the USB3\nconnection working and we will present the different challenges that we\nencountered while making wch-ch56x-lib, a support library for WCH569 with\ntested USB2/USB3/HSPI (High-speed Parallel Interface)/SerDes\n(Serializer/Deserializer) drivers.\n\nWhile we initially started with a dual HydraUSB3 setup, a new board called\nHydradancer, based on HydraUSB3 was created. It is easier to use and more\nreliable. We will present the differences between the two configurations and\nwhy we switched to this new version.\n\nAs we needed to measure the improvements of Hydradancer over existing\nbackends, we will present our benchmarks that compare Hydradancer with the\nexisting Facedancer21 and GreatFET One boards. Our results showed 607 times\nfaster average write transfers for USB2 Full-speed transmission compared with\nFacedancer21 and 12 times faster compared with GreatFET One.\n\n# Hydradancer: a faster, USB2 High-Speed capable backend for Facedancer based\non HydraUSB3\n\n## The current state of Facedancer\n\nFacedancer principle\n\nThe Facedancer project was started in 2012 by Travis Goodspeed, the creator of\nthe GoodFET^8 multi-tool. GoodFET was already a USB interface for multiple\nprotocols (JTAG, SPI, CAN, etc.) and Travis Goodspeed created a new board\nbased on Goodfet that could be a USB interface for the USB MAX3421 chip:\nFacedancer. By connecting the board to your computer on one side and the\ntarget USB port on the other side, you can create various peripherals (a\nkeyboard, mass storage, FTDI serial adapter, ...) by simply launching a Python\nscript that uses a library also called Facedancer. Two other boards,\nRaspdancer and BeagleDancer, are also based on the USB MAX3421 chip but remove\nthe external communication with Facedancer: Facedancer runs directly on the\nRaspberry Pi or Beagle Bone Black.\n\nFacedancer21 and newer boards from Great Scott Gadgets\n\nA few years later, GreatFET One^6, the successor of GoodFET was created by\nGreat Scott Gadgets, a company founded by Michael Ossmann that also makes the\nHackRF One Software Defined Radio peripheral. GreatFET One is based on the\nsame principle as GoodFET: an extensible board that interfaces to a PC using\nUSB. Great Scott Gadgets became the maintainer of the Facedancer Python\nlibrary and made several improvements while adding support for the GreatFET\nOne: move to Python3, API changes, support of new boards in the form of\nbackends, integration of USBProxy directly in Facedancer.\n\nGreat Scott Gadgets is currently working on its next generation USB tool: the\nCynthion^7 board with the Luna gateware. Cynthion is a platform based on a\nFPGA, that aims at becoming a USB multi-tool: USB2 protocol sniffer, USB\nhost/device emulation using Facedancer, a teaching platform for the USB\nprotocol. The current release window is June 2024, but initial support has\nalready been added to Facedancer in September 2023.\n\nFacedancer is now at version 2.9 and supports both the creation of USB devices\nand hosts, along with a proxy mode that implements a Man-in-the-middle on USB\ncommunications between existing USB devices and hosts.\n\nHowever, Facedancer is currently limited by the supported boards, as the\nfollowing table shows.\n\nBoard| Maximum speed| Number of endpoints (not EP0)| Host mode  \n---|---|---|---  \nFacedancer21/Raspdancer| USB2 Full-speed| EP1 OUT, EP2 IN, EP3 IN| yes  \nGreatFET One| USB2 Full-speed| 3 IN / 3 OUT| yes  \nHydradancer| USB2 High-speed| 5 IN / 5 OUT| no  \n(Cynthion/LUNA)(coming 2024)| (USB2 High-speed)| (15 IN / 15 OUT)| (yes)  \n  \nFacedancer backends functionalities\n\nFacedancer is currently limited to USB2 Full-speed and a very limited number\nof endpoints. Cynthion will probably bring a huge improvement to those\ncapabilities but its performance will need to be evaluated once it is\nreleased.\n\n## HydraUSB3 and Hydradancer\n\nBefore presenting Hydradancer, let's first introduce the board on which it is\nbased: HydraUSB3.\n\nHydraUSB3^9 is a development board created by Benjamin Vernoux around the\nWCH569 MCU. The WCH569 is a RISC-V single-core MCU that integrates various\nhigh-speed peripherals: USB3 Superspeed (5 Gbps), Gigabyte Ethernet, USB2\nHigh-speed, HSPI (High-speed parallel interface), SerDes\n(Serializer/Deserializer). The presence of those high-speed peripherals makes\nit a good candidate for creating a faster Facedancer board, especially with\nUSB3 support.\n\nTwo HydraUSB3 plugged together\n\nWhile a datasheet is provided by WCH in English (translated from Chinese)\nalong with examples on a GitHub repository, using it in practice is painful:\nmost functionalities are only presented as examples with loads of magic\nnumbers (and no SDK), the USB3/SerDes examples use libraries in the form of\nbinary blobs and the datasheet does not give any information to the developers\nfor these protocols.\n\nFor those reasons, Benjamin Vernoux had to reverse-engineer the USB3 and\nSerDes implementation of the WCH569 to create an open-source implementation.\nHe presented his work at the GreHack2022 cybersecurity conference in a talk\n\"Reverse Engineering of advanced RISC-V MCU with USB3 & High Speed\nperipherals\"^10.\n\nThis allowed him to make a complete and clean SDK called wch-ch56x-bsp^11 for\nthe WCH569 that served as the basis for making the Hydradancer peripheral\ndrivers.\n\n## Hydradancer: overall architecture\n\nHydradancer^12 connects to the target host (for the case where we want to\nemulate USB devices) using one USB2 port that connects to the target host and\na USB3 port that connects to the controlling PC running the Python script.\n\nThe firmware^13 implements a passthrough for the USB protocol: whenever the\nboard receives data from the target host, it is sent to the controlling PC\nthrough the other USB port. The Python script implementing the device then\ncrafts a reply, sends it back to the board which sends it to the target host.\n\nBefore going into more details, let's first define some of the terms that\nwe'll use in the rest of the blogpost.\n\nWhen we started Hydradancer, we used two HydraUSB3^9 boards connected using\nHSPI or SerDes. control board refers to the board connected to Facedancer\nusing USB3 which effectively controls the second board, called the emulation\nboard, which uses its USB2 controller to create the USB peripheral.\n\nHydradancer protocol loop for the dual HydraUSB3 configuration\n\nHowever, as you'll see later in this blogpost, we realized we could use a\nsingle modified HydraUSB3 by splitting the USB3 and USB2 controllers. We kept\nthe control/emulation structure and naming, meaning control refers to the USB3\ndevice (the one connected to Facedancer, controlling the communication) and\nemulation refers to the USB2 passthrough device/controller connected to the\ntarget host.\n\nIn both dual or single-board setups, the overall principle is the same and\nworks as described in the following diagram.\n\nHydradancer overall principle for the dual-HydraUSB3 configuration\n\nEmulating a USB peripheral with the Hydradancer works like this:\n\n  1. Hydradancer connects to the side running Facedancer using a USB3 cable and to the target host using a USB2 cable.\n  2. When the USBDevice is created by Facedancer, the connect method of USBBaseDevice is called, which will initialize the backend.\n  3. The Hydradancer backend is initialized and the backend waits for the board to be ready by polling the control endpoint using the CHECK_HYDRADANCER_READY vendor request. This was implemented to let the boards reinitialize after a USB peripheral is disconnected (before connecting a new one).\n  4. Then, the connect method of the backend is called.\n\nEach endpoint on the target USB port (managed by the emulation board) is\nmapped to an endpoint connected to the Facedancer host (control board\nendpoints). The WCH569 chip of HydraUSB3 can only handle 7 bidirectional\nendpoints independently at a time (not counting endpoint 0), but can handle\nall endpoint numbers from 1 to 15 for USB2. To avoid weird incompatibilities\n(like \"you can use endpoint 4 but not while using endpoint 8 or endpoint 12\"),\nwe settled for using only endpoint numbers from 1 to 7 at the moment. For\nUSB3, in the absence of more documentation from WCH, only 7 endpoints are\nsupported (not counting endpoint 0). Since one endpoint is used for\nstatus/event polls, this leaves 6 endpoints on the control board to be used by\nthe Facedancer peripheral, including one for the control endpoint (EP0). To\nallow using all endpoint numbers from 0 to 7 (and maybe more later), a mapping\nbetween control board endpoints and emulation board endpoints is set in the\nFacedancer backend and shared with the boards.\n\nconnect first creates a mapping for the control endpoint, as this endpoint is\nrequired. The backend then sends a SET_SPEED vendor control request to set the\nUSB2 speed of the Hydradancer USB2 controller (low/full/high speed).\n\nFinally, Hydradancer sends an ENABLE_USB_CONNECTION_REQUEST_CODE vendor\ncontrol request to tell the firmware to enable the USB pull-up, which starts\nthe USB communication.\n\n  5. The Hydradancer backend then starts polling the status of the emulation endpoints in service_irqs. This function is called in an infinite loop in the run function from USBBaseDevice, which is an async coroutine: it uses asyncio.sleep to let other coroutines execute. The status is a bitfield. For IN endpoints, 1 means the buffer is empty which means it is available. For OUT endpoints, 1 means the endpoint is full which means data is available on the corresponding mapped control endpoint. It serves as a synchronization variable between the control and emulation boards/controllers.\n\nPolling directly on the mapped endpoints (for status or data) would have freed\nthe status/event endpoint and make things more efficient but this was not\nfeasible using libusb's synchronous API (the only one currently available in\nPyUSB): in the case where no data is available, each endpoint request will\ntake 1 ms (the smallest libusb timeout) to complete. If only one endpoint is\nsharing data, it adds a 6-ms delay which would seriously limit transfer rate\nand reactivity.\n\nPolling is done using control requests on EP0 before the device is configured,\nthen using the EP1 BULK endpoint of the control board/controller. This mirrors\nthe endpoint type used on the emulation board/controller, thus mirroring the\nbandwidth/timing requirements, which seemed to improve stability during the\nenumeration phase and improve data transfer rates after the enumeration.\nIdeally, we would also mirror the type of each data endpoint for the same\nreasons, but we only use bulk endpoints at the moment for simplicity.\n\n  6. After receiving a SET_CONFIGURATION request from the target host, the backend will send several SET_ENDPOINT_MAPPING vendor control requests to map the emulated board/controller endpoints to control endpoints.\n\n  7. At this point, both the emulation board/controller and control board/controller are configured, the target host has finished enumerating it and will start sending IN/OUT requests. Hydradancer handles IN and OUT requests in the following way:\n\n     * Initially, all IN endpoints are available (bit set to 1 in the status bitfield). If the target host sends an IN request and the buffer is empty, the firmware sends a NAK. The Facedancer device needs to prime the IN endpoints (meaning set an initial buffer) when it is ready to send data. The corresponding bit in the status bitfield is then set to 0 (meaning the device won't be able to send more data). When the target host has finished reading, the bit is set back to 1 and a status update is prepared on the control board EP1 so that the backend emulation endpoint state is updated. So currently, Hydradancer does not react to the host sending IN requests, but rather to the IN buffer being empty.\n     * All OUT endpoints have their bit set to 0 in the status bitfield initially. When data is received on an emulation endpoint, the bit is set to 1 and a status update is prepared on the control EP1 IN endpoint. While the status bit is 1, all following OUT requests from the target host will be NACKed. When the backend polls the endpoints status, it will then poll the corresponding mapped endpoint which returns data. After the backend has finished reading, the corresponding bit in the bitfield is set back to 0.\n  8. Punctual events like bus resets are also handled using the status bitfield, but the corresponding bit is cleared after being sent once (since it's a one-time event).\n\n### Dual-board setup\n\nEach HydraUSB3 being able to handle only one USB peripheral (single USB port),\ntwo HydraUSB3 have been connected together through HSPI for this project.\n\nA USB3 connection is used to interface with Facedancer, HSPI is used for the\ncommunication between the two HydraUSB3 boards. Using USB3 for the\ncommunication with Facedancer proved to be a requirement when emulating USB2\nHigh-speed peripherals during the enumeration phase. However, USB2 High-speed\nseems to be sufficient to handle USB2 Full-speed.\n\nWorking with two HydraUSB3 boards connected through HSPI posed quite a lot of\nchallenges, especially to get the timings right. One of the biggest issues\ninitially was missing interrupts, something we fixed by deferring interrupts\nin user mode using a queue as shown in the diagram below.\n\nHydradancer sequence for an OUT and an IN transfer\n\nBut one issue remained with HSPI and the WCH569 chip: there is no way in the\nHSPI implementation to know when the receiving side has finished processing\nthe previous request and is ready to process the next. The receiving HSPI\ncontroller will drive its HTACK/HTRDY line up to signal it is ready to receive\ndata after the transmitting side asks for permission on the HTREQ line,\nhowever this can happen as soon as the previous buffer has been received, even\nduring interrupts apparently. So if the interrupt handler is not fast enough,\nsome buffers will simply be overwritten, even with double-buffering. It could\nbe interesting to dive more into this, maybe this happens only in double-\nbuffering mode, where the current HSPI buffer would keep switching even during\ninterrupts, thus overwriting buffers. But in any case, using HSPI on the\nWCH569 proved to be a headache when increasing the number of exchanges with\nthe dual HydraUSB3 setup.\n\nThe only solution we found for this was to detect consecutive sends in the\ntask queue of the sender and add an artificial delay to prevent missing\ncommunications, which is not a clean solution.\n\nOther solutions included:\n\n  * adding another protocol layer on top of HSPI that would check if the communication went through properly. However the problem still exists: some messages of this protocol could still be overwritten, corrupting the state of the firmware...\n  * synchronizing using additional GPIO, we tried but it didn't give meaningful results\n\nMaybe we missed something in the HSPI/SerDes implementation, but the provided\nexamples from WCH do not really help.\n\nSo while we managed to get the dual HydraUSB3 setup working, it still has some\ninstabilities that the single-board setup does not.\n\n### Single-board setup: the way forward\n\nAbout six months after the start of the Hydradancer project, we randomly\ntalked about how the USB2 and USB3 hardware of the WCH569 are physically\nseparate. This prompted us to check if we could indeed use both USB2 and USB3\nseparately: USB3 should always be retro-compatible with USB2 and we were\nfocused on making HSPI/SerDes work for the dual-board setup, so it did not\noccur to us that this could be done.\n\nSome additional work had to be done to completely separate the USB3 and USB2\nparts of the library, as both WCH demo code and our library were built to\nsupport USB3 with USB2 downgrade (meaning one was deactivated while the other\nwas working).\n\nBut in the end, we were able to make a proof-of-concept by creating one USB3\nand one USB2 loopback device simultaneously on the same (modified) HydraUSB3\nboard and run the tests successfully!\n\nHydradancer prototype board, derived from HydraUSB3. The USB-C below the board\nis USB2-only (emulation side, connected to target host) and the USB3 connector\nhas no USB2 lines (connected to Facedancer host).\n\nUsing a USB3 connector with no USB2 differential pair does not seem to be an\nissue: all USB3 hosts will start establishing a USB3 link connection and will\nonly activate their USB2 controller if the USB3 fails. While this is not\nstandard, we don't see any way a host would reject our USB3 peripheral.\n\nAfter proving this would work properly, we implemented the firmware supporting\nthe Hydradancer backend for the single-board setup.\n\nBeing able to use both USB3 and USB2 on the same WCH569 chip has huge\nadvantages: we don't need to copy buffers and transmit them through an\nexternal protocol (HSPI/SerDes) with all the timing issues and delays, the\nbuffers just stay at the same place in memory (zero copy).\n\nHydradancer protocol loop for the Hydradancer dongle\n\nMoving from a dual-board setup to a single-board one vastly improved the\nresults of our loopback/speed tests, the stability of the Facedancer backend\nand ease of code maintenance.\n\n## Using Hydradancer\n\nTo use Hydradancer, you need either two HydraUSB3 or a Hydradancer board\n(recommended), along with one USB3 cable and one USB2 cable.\n\nThen, you'll need to flash the required firmwares as described on GitHub^13,\ndepending on the setup (dual HydraUSB3 boards or single Hydradancer board).\n\nFinally, while we hope to merge the Hydradancer backend for Facedancer into\nthe main repository^2 along with some bug fixes we may have found, you can use\nour fork^14 in the meantime.\n\nFirst, clone the Facedancer fork\n\n    \n    \n    git clone https://github.com/HydraDancer/Facedancer\n\nThen, reuse your virtual env or create a new one to keep your local Python\ninstallation clean\n\n    \n    \n    sudo apt install python3 python3-venv python3 -m venv venv\n\nActivate the venv\n\n    \n    \n    source venv/bin/activate\n\nInstall Facedancer\n\n    \n    \n    cd Facedancer pip install --editable .\n\nThe --editable isn't necessary but it allows you to modify Facedancer's files.\n\nThen, tell Facedancer to use the Hydradancer backend\n\n    \n    \n    export BACKEND=hydradancer\n\nAnd finally, run one of the examples to check if everything works, this one\nshould make your cursor wiggle.\n\n    \n    \n    python3 ./examples/crazy-mouse.py\n\n## Results: benchmark against Facedancer21 and GreatFET One\n\nWrite average estimate| Relative write uncertainty| Write transfer size| Read\naverage estimate| Relative read uncertainty| Read transfer size| Confidence  \n---|---|---|---|---|---|---  \nHydradancer High-speed| 7996.352\u00b1314.348 KB/s| 4%| 499.712 KB|\n4224.192\u00b1157.058 KB/s| 4%| 499.712 KB| 99.9%  \nHydradancer Full-speed| 747.295\u00b120.899 KB/s| 3%| 49.984 KB| 414.188\u00b17.368\nKB/s| 2%| 49.984 KB| 99.9%  \nGreatFET One Full-speed un par un| 32.422\u00b10.844 KB/s| 3%| 49.959 KB|\n33.066\u00b11.095 KB/s| 3%| 49.984 KB| 99.9%  \nFacedancer21 Full-speed| 0.697\u00b10.0 KB/s| 0%| 9.984 KB| 0.682\u00b10.0 KB/s| 0%|\n9.984 KB| 99.9%  \n  \nSpeedtest results\n\nAll benchmarks were conducted using a single libusb transfer, except for\nGreatFET One. A single USB transfer equals a single call to libusb: libusb\ntakes the responsibility of sending the packets as fast as possible. While\nrunning our test for GreatFET One, we ran into an issue that prevented us from\ndoing a single transfer: GreatFET One just would not accept packets of 64\nbytes (the full packet size for USB2 full-speed) so we had to settle for\npackets of 63 bytes and sending with individual transfers. However, this\nshould not matter that much for speedtesting Facedancer: there is a lot of\ndowntime with all the transfers from one side to the other, so libusb can't\nsend the packets too fast either.\n\nNote that speedtests are not everything. While GreatFET One has proven mostly\nreliable, Facedancer21 was a pain to get working with scripts being launched\nmore than ten times before the board starts working. We have found Hydradancer\nto be reliable during our tests, especially the single-board setup.\n\n## Field-tested drivers for the WCH569\n\nDuring this project, we developed a high-level library wch-ch56x-lib^15 based\non wch-ch56x-bsp^11, with improved peripherals and testing.\n\nThis library includes:\n\n  * USB2/USB3 drivers with a shared USB abstraction layer\n  * HSPI (bidirectional half-duplex): two versions are implemented, one handles data directly in the interrupt handler, the other uses the interrupt queue to defer processing\n  * SerDes (simplex)\n  * memory pool: a RAMX (the memory used by the peripherals) pool that allows swapping peripheral buffers while keeping previous buffers for deferred processing using the interrupt queue. It also avoids unnecessary copies and uses reference counting\n  * interrupt_queue: a simple task queue to defer processing in user mode, so that it can be interrupted and fewer interrupts might be missed\n  * logging: different loggers are implemented, mainly direct logging through UART1 and logging to a ringbuffer. Logging has a noticeable impact on performance and can create new bugs when trying to debug the high-speed peripherals like USB3. Logging to a ringbuffer and flushing to UART1 later can help, but even then logging might need to be kept to a minimum. Log levels and categories have been set up to easily activate the logs of different parts of the library\n\nVarious tests were implemented for the wch-ch56x-lib library, mainly loopback\nand speed tests, with Python and C host programs to support them.\n\nTesting was a huge part of this project, as we often reached the limitations\nof WCH's examples and documentation, for instance:\n\n  * USB3 out control requests were not working and we actually had to manually inline the code to make them work (the USB3 part of the firmware is really sensitive on timings)\n  * USB3 did not support packets of size less than the maximum packet-size, we also encountered issues with how the examples dealt with bursts\n  * we had to test if HSPI could work in half-duplex on both sides simultaneously\n  * timing issues with HSPI: we could not prevent the sender from overriding the receiving buffer while processing it in an interrupt (although the HSPI protocol supports such signals)\n\nWe relied on logs to reverse some of the WCH569 functionalities, for instance\nto find the right usage for the USB3 control registers when handling bursts.\nThe WCH-LinkE did not work properly for us, even with the MoonRiver IDE.\n\n# How to get the Hydradancer board\n\nIf you are interested by this project, we recommend buying the new Hydradancer\nboard when it is available on the Hydrabus website, it will be announced on\nHydrabus's Twitter/X account. In this blogpost, we presented the prototype\nused for development but Benjamin Vernoux has launched the production of a\nfirst batch of HydraDancer Dongle V1 R0, which will be much smaller. This\nfirst batch will be tested before launching a second batch that will be made\navailable.\n\nHydraDancer Dongle V1 R0\n\nThis new Hydradancer can also be used to create USB3 peripherals, although\nwithout USB2 downgrade contrary to a HydraUSB3.\n\nIf you encounter any bugs or missing features (like the currently\nunimplemented host-mode), don't hesitate to create an issue on GitHub\nrepository of the Hydradancer firmware^13.\n\n# Conclusion\n\nIn this blogpost, we presented Hydradancer, a new backend and board for\nFacedancer that supports USB2 High-speed and allows faster data-transfer rates\noverall using USB3.\n\nThis project would not have been possible without the support of Benjamin\nVernoux, the creator of the HydraUSB3 and Hydradancer hardware. I would also\nlike to thank Philippe Teuwen (doegox) and Mengsi Wu from Quarkslab for their\nhelp and support during this project.\n\n# Sources\n\n  1. https://github.com/pyusb/pyusb \u21a9\n\n  2. https://github.com/greatscottgadgets/Facedancer \u21a9\u21a9\n\n  3. https://goodfet.sourceforge.net/hardware/facedancer21/ \u21a9\n\n  4. https://wiki.yobi.be/index.php/Raspdancer \u21a9\n\n  5. https://github.com/dominicgs/BeagleDancer \u21a9\n\n  6. https://greatscottgadgets.com/greatfet/one/ \u21a9\u21a9\n\n  7. https://greatscottgadgets.com/cynthion/ \u21a9\u21a9\n\n  8. https://goodfet.sourceforge.net/ \u21a9\n\n  9. https://hydrabus.com/hydrausb3-v1-0-specifications \u21a9\u21a9\n\n  10. https://github.com/hydrausb3/grehack22 \u21a9\n\n  11. https://github.com/hydrausb3/wch-ch56x-bsp \u21a9\u21a9\n\n  12. https://hydradancer.com \u21a9\n\n  13. https://github.com/HydraDancer/hydradancer_fw \u21a9\u21a9\u21a9\n\n  14. https://github.com/HydraDancer/Facedancer \u21a9\n\n  15. https://github.com/hydrausb3/wch-ch56x-lib \u21a9\n\nIf you would like to learn more about our security audits and explore how we\ncan help you, get in touch with us!\n\n  * #### Quarkslab's Website\n\n  * #### SOCIAL\n\n    * twitter\n    * mastodon\n    * github\n  * #### CATEGORIES\n\n    * \u2022Android\n    * \u2022Blockchain\n    * \u2022Challenge\n    * \u2022Containers\n    * \u2022Cryptography\n    * \u2022Exploitation\n    * \u2022Fuzzing\n    * \u2022Hardware\n    * \u2022Kernel Debugging\n    * \u2022Life at Quarkslab\n    * \u2022Math\n    * \u2022Pentest\n    * \u2022Program Analysis\n    * \u2022Programming\n    * \u2022Reverse-Engineering\n    * \u2022Software\n    * \u2022Vulnerability\n\n\u00a9 2024 Quarkslab \u00b7 Powered by pelican-bootstrap3, Pelican, Bootstrap\n\nBack to top\n\n", "frontpage": false}
