{"aid": "40188557", "title": "How to configure a custom Test Container on the EventStoreDB example", "url": "https://event-driven.io/en/custom_test_container_on_esdb_example/", "domain": "event-driven.io", "votes": 1, "user": "RyeCombinator", "posted_at": "2024-04-28 13:47:20", "comments": 0, "source_title": "How to configure a custom Test Container on the EventStoreDB example", "source_text": "How to configure a custom Test Container on the EventStoreDB example - Event-\nDriven.io\n\n# Oskar Dudycz\n\n## Pragmatic about programming\n\n# How to configure a custom Test Container on the EventStoreDB example\n\n2024-04-28 oskar dudyczTesting\n\nTestcontainers became a popular way of setting up dependencies for integration\ntesting. They\u2019re not ideal, as configuring them to run your tests efficiently\nis not as trivial as it\u2019s glossed; I explained that in A simple way to\nconfigure integration tests pipeline. Still, undeniably, it can speed up the\ninitial ramp-up phase and, if used wisely, can be a decent way to handle\ncommon testing dependencies.\n\nTestcontainers already provide the default configurations for tools like\nPostgreSQL, Kafka, MongoDB etc. Yet, sometimes you need to use something a bit\nless mainstream, for instance, EventStoreDB as your event store. How to do it?\n\nLuckily, test Containers provide a built-in way of handling such cases,\nproviding a generic abstraction for that: GenericContainer. We can extend it\nto provide our test container. Let\u2019s see how to do it using Typescript.\n\nWe need to start by adding two classes, one representing a container image\nconfiguration and the other representing a started container instance.\n\n    \n    \n    import { AbstractStartedContainer, GenericContainer, type StartedTestContainer, } from 'testcontainers'; export const EVENTSTOREDB_IMAGE_NAME = 'eventstore/eventstore'; export const EVENTSTOREDB_IMAGE_TAG = '23.10.1-bookworm-slim'; export class EventStoreDBContainer extends GenericContainer { constructor( image = `${EVENTSTOREDB_IMAGE_NAME}:${EVENTSTOREDB_IMAGE_TAG}` ) { super(image); }; } async start(): Promise<StartedEventStoreDBContainer> { return new StartedEventStoreDBContainer(await super.start()); } } export class StartedEventStoreDBContainer extends AbstractStartedContainer { constructor(container: StartedTestContainer) { super(container); } getConnectionString(): string { return `esdb://${this.getHost()}:${this.getMappedPort(2113)}?tls=false`; } }\n\nAnd that\u2019s the bare minimum that we need to have. The container definition\ntakes the default LTS EventStoreDB image, allowing us to provide the other\none. We\u2019re also exposing the EventStoreDB connection string. It\u2019s important as\nTestcontainers run containers on random ports to help in test isolation.\n\nWe could set it up as:\n\n    \n    \n    const container: StartedEventStoreDBContainer = await new EventStoreDBContainer().start(); const eventStore = EventStoreDBClient.connectionString(this.getConnectionString())\n\nThat\u2019s some aid, but well, if Testcontainers are to reduce the cognitive load\nby providing a default container setup, then we could do better than that.\n\nWe could set up default recommended options for testing. What could they be?\nFor instance, EventStoreDB is secure by default. You should run the setup to\nconfigure certificates, etc. It\u2019s also recommended that a cluster with at\nleast three nodes on production be configured to get proper resiliency. All of\nthat is, of course, important, and running tests against the production setup\nis a must at some point (read more in I tested it on production, and I\u2019m not\nashamed of it). Still, for most of the integration tests touching common\nfeatures (like appending events and (subscribing to notifications about\nthem](/en/persistent_vs_catch_up_eventstoredb_subscriptions_in_action/)),\nrunning an insecure single cluster should be more than enough. We could even\ndisable file storage and use an in-memory setup to enable the reusing of the\ncontainer between multiple tests. All of those are performance optimisations\nand tradeoffs, but we need to be sure that our test suite is not only giving\nproper results but also running fast. Tests on real production databases can\nbe covered by synthetic tests.\n\nOk, then, how to do it? Let\u2019s define some default options like default\nEventStoreDB ports to expose:\n\n    \n    \n    export const EVENTSTOREDB_PORT = 2113; export const EVENTSTOREDB_TCP_PORT = 1113; export const EVENTSTOREDB_TCP_PORTS = [ EVENTSTOREDB_TCP_PORT, EVENTSTOREDB_PORT, ];\n\nThen, defining the default image setup.\n\n    \n    \n    export const EVENTSTOREDB_IMAGE_NAME = 'eventstore/eventstore'; export const EVENTSTOREDB_IMAGE_TAG = '23.10.1-bookworm-slim'; export const EVENTSTOREDB_ARM64_IMAGE_TAG = '23.10.1-alpha-arm64v8'; export const EVENTSTOREDB_DEFAULT_IMAGE = `${EVENTSTOREDB_IMAGE_NAME}:${process.arch !== 'arm64' ? EVENTSTOREDB_IMAGE_TAG : EVENTSTOREDB_ARM64_IMAGE_TAG}`;\n\nAnd yes, we\u2019re also giving help to the Mac M1 users, as the ARM64 image is not\nincluded in the default tag. It\u2019s still in alpha, so why not automate it?\n\nNow, let\u2019s define the explained earlier options:\n\n    \n    \n    export type EventStoreDBContainerOptions = { disableProjections?: boolean; isSecure?: boolean; useFileStorage?: boolean; withoutReuse?: boolean; }; export const defaultEventStoreDBContainerOptions: EventStoreDBContainerOptions = { disableProjections: false, isSecure: false, useFileStorage: false, withoutReuse: false, };\n\nAs you see, we\u2019re making them customisable, as we\u2019d like people to enable the\nfull setup. It\u2019s also a good practice to have all default options named in a\nway so that the default can be assumed as false. That reduces the cognitive\nload.\n\nHaving that, we can update our base container definition:\n\n    \n    \n    import { AbstractStartedContainer, GenericContainer, } from 'testcontainers'; import type { Environment } from 'testcontainers/build/types'; export class EventStoreDBContainer extends GenericContainer { private readonly tcpPorts = EVENTSTOREDB_TCP_PORTS; constructor( image = EVENTSTOREDB_DEFAULT_IMAGE, options: EventStoreDBContainerOptions = defaultEventStoreDBContainerOptions, ) { super(image); const environment: Environment = { ...(!options.disableProjections ? { EVENTSTORE_RUN_PROJECTIONS: 'ALL', } : {}), ...(!options.isSecure ? { EVENTSTORE_INSECURE: 'true', } : {}), ...(options.useFileStorage ? { EVENTSTORE_MEM_DB: 'false', EVENTSTORE_DB: '/data/integration-tests', } : {}), EVENTSTORE_CLUSTER_SIZE: '1', EVENTSTORE_START_STANDARD_PROJECTIONS: 'true', EVENTSTORE_EXT_TCP_PORT: `${EVENTSTOREDB_TCP_PORT}`, EVENTSTORE_HTTP_PORT: `${EVENTSTOREDB_PORT}`, EVENTSTORE_ENABLE_EXTERNAL_TCP: 'true', EVENTSTORE_ENABLE_ATOM_PUB_OVER_HTTP: 'true', }; this.withEnvironment(environment).withExposedPorts(...this.tcpPorts); if (!options.withoutReuse) this.withReuse(); } async start(): Promise<StartedEventStoreDBContainer> { return new StartedEventStoreDBContainer(await super.start()); } }\n\nAs you can see, we\u2019re setting up the default Environment settings, exposing\nports, and marking our container as reusable by default (by calling\nthis.withReuse()). Thanks to that, Testcontainers will not start a new\ncontainer if a Testcontainers-managed container with the same configuration is\nalready running. That cuts the cold-start time. Yet, you need to ensure that\nthe test data you\u2019re adding won\u2019t collide with other tests, so you better be\ncareful.\n\nYou can still override the environment settings by calling withEnvironment\nmethod.\n\nHaving that, let\u2019s also extend the started container by adding getClient\nmethod that\u2019ll return already setup EventStoreDB client for your container.\n\n    \n    \n    import { EventStoreDBClient } from '@eventstore/db-client'; import { AbstractStartedContainer, type StartedTestContainer, } from 'testcontainers'; export class StartedEventStoreDBContainer extends AbstractStartedContainer { constructor(container: StartedTestContainer) { super(container); } getConnectionString(): string { return `esdb://${this.getHost()}:${this.getMappedPort(2113)}?tls=false`; } getClient(): EventStoreDBClient { return EventStoreDBClient.connectionString(this.getConnectionString()); } }\n\nYou can test if all is working fine through the test:\n\n    \n    \n    import { jsonEvent } from '@eventstore/db-client'; import assert from 'node:assert/strict'; import { randomUUID } from 'node:crypto'; import { after, beforeEach, describe, it } from 'node:test'; import { EventStoreDBContainer, StartedEventStoreDBContainer, } from './eventStoreDBContainer'; void describe('EventStoreDBContainer', () => { let container: StartedEventStoreDBContainer; beforeEach(async () => { container = await new EventStoreDBContainer().start(); }); void it('should connect to EventStoreDB and append new event', async () => { const client = container.getClient(); const result = await client.appendToStream( `test-${randomUUID()}`, jsonEvent({ type: 'test-event', data: { test: 'test' } }), ); assert.ok(result.success); }); after(async () => { await container.stop(); }); });\n\nYou can use the same pattern for any other tool with container image. Also you\ncan define custom images in the similar way, if you\u2019re using C#, Java, Go, or\nother supported by Testcontainers developer environment.\n\nStill, if you\u2019re using Node.js, and you\u2019d like to use EventStoreDB\nTestcontainer, then hey, you can just install Emmett Testcontainers package:\n\n    \n    \n    npm add @event-driven-io/@event-driven-io/emmett-testcontainers\n\nAnd use it as:\n\n    \n    \n    import { EventStoreDBContainer, type StartedEventStoreDBContainer, } from '@event-driven-io/emmett-testcontainers'; let esdbContainer: StartedEventStoreDBContainer; void describe('ShoppingCart E2E', () => { // Set up a container before all tests before(async () => { esdbContainer = await new EventStoreDBContainer().start(); }); // Stop container once we finished testing after(() => { return esdbContainer.stop(); }); // (...) Tests will go here });\n\nRead also more in Testing Event Sourcing, Emmett edition.\n\nCheers!\n\nOskar\n\np.s. Ukraine is still under brutal Russian invasion. A lot of Ukrainian people\nare hurt, without shelter and need help. You can help in various ways, for\ninstance, directly helping refugees, spreading awareness, putting pressure on\nyour local government or companies. You can also support Ukraine by donating\ne.g. to Red Cross, Ukraine humanitarian organisation or donate Ambulances for\nUkraine.\n\n\ud83d\udc4b If you found this article helpful and want to get notification about the\nnext one, subscribe to Architecture Weekly.\n\n\u2709\ufe0f Join over 5000 subscribers, get the best resources to boost your skills,\nand stay updated with Software Architecture trends!\n\nSHARE\n\nOskar Dudycz For over 15 years, I have been creating IT systems close to the\nbusiness. I started my career when StackOverflow didn't exist yet. I am a\nprogrammer, technical leader, architect. I like to create well-thought-out\nsystems, tools and frameworks that are used in production and make people's\nlives easier. I believe Event Sourcing, CQRS, and in general, Event-Driven\nArchitectures are a good foundation by which this can be achieved.\n\n#### Mocking the native Node.js Test Runner 2024-04-17\n\n  * \u00a9 License Creative Commons BY-SA 4.0 to Oskar Dudycz 2020 - 2024\n\n", "frontpage": false}
