{"aid": "40081336", "title": "XZ/LZMA Worked Example", "url": "https://nigeltao.github.io/blog/2024/xz-lzma-part-1-range-coding.html", "domain": "nigeltao.github.io", "votes": 1, "user": "todsacerdoti", "posted_at": "2024-04-18 22:16:18", "comments": 0, "source_title": "XZ/LZMA Worked Example Part 1: Range Coding", "source_text": "XZ/LZMA Worked Example Part 1: Range Coding | Nigel Tao\n\n# Nigel Tao\n\n# XZ/LZMA Worked Example Part 1: Range Coding\n\nThis blog post is one of a five part series.\n\n  * Part 1: Range Coding\n  * Part 2: A Complete Toy Range Coder\n  * Part 3: Literal-Only LZMA\n  * Part 4: Lempel-Ziv, Markov-chain\n  * Part 5: XZ\n\n## Background\n\nXZ is a general purpose compression file format, achieving very good\ncompression ratios (smaller compressed file sizes). Almost always better than\ngzip/deflate and usually better than bzip2. Newer formats like brotli and zstd\nare now pretty competitive (and also offer better compression or decompression\nspeeds), depending on your test corpus, but XZ is still widely used.\n\nTo be pedantic, XZ is a container format and LZMA is the compression\nalgorithm. The 7z and LZIP file formats aren\u2019t XZ but can also use LZMA.\n\nFor further pedantry, XZ is the name of the file format (such files are\nconventionally named foobar.xz) but also the name of a git repository of\nsoftware that implements that file format. liblzma and /usr/bin/xz are example\nartifacts built from that project.\n\nA few weeks ago, a backdoor was discovered in xz/liblzma, targeting SSH\nservers since sshd can depend on libsystemd can depend on liblzma. Planting\nthat backdoor exploited the build process, rather than a weakness in the file\nformat or its C code implementation. Still, xz is having its 15 minutes of\ninfamy and some of you might be curious about how LZMA compression actually\nworks. How does it achieve such a good compression ratio?\n\nThis blog post series answers that question. We\u2019ll start with range coding.\n\n## Notation\n\nLet [lb, ub) denote a half-open numerical range, defined by lower and upper\nbounds. It is the set of all numbers x such that (lb \u2264 x) and (x < ub). For\nexample, [0.5, 0.625) are those numbers that are at least 1\u20442 and less than\n5\u20448. This example (and most of this blog post) uses base-10 decimal digits\n(the digits 0, 1, 2, ..., 9), which humans are most familiar with. Computers\nwork better with powers of two, especially base-2 (binary, bit-based) or\nbase-256 (byte-based). The same [1\u20442, 5\u20448) range could also be written as\n[0b0.1, 0b0.101) or [0b0.100, 0b0.101) or [0x0.80, 0x0.A0).\n\nLet\u2019s also introduce some \u201cno-op underscores\u201d, so that 0.834626841674073 is\nthe same as 0.83462_68416_74073. These underscores will be most helpful (for\nhumans) with our base-256 numbers, where each base-256 digit combines two\nbase-16 (hexadecimal) digits.\n\nThe [lb, ub) pair representation is equivalent to a (lb ++ width) pair\nrepresentation, where width = (ub - lb). Many discussions of range coding use\nthe term range instead of width, but range is a reserved keyword in the Go\nprogramming language, so I\u2019m going to use width in my runnable code snippets.\n\nThe width can be implicit. Let \u00ab834626841\u00bb (which you can think of as a \u201cdigit\nstring\u201d with length 9) denote a lowerBound of 0.834626841 and an upper bound\nof 1e-9, where 9 is that string length. That range is equivalent to\n[0.834626841, 0.834626842), where the two bounds differ in their last digit.\n\nNote that trailing zeroes matter. \u00ab123\u00bb and \u00ab1230\u00bb are different ranges, even\nthough 0.123 and 0.1230 are the same numbers. Those two ranges have larger and\nsmaller widths: (0.123 ++ 1e-3) and (0.1230 ++ 1e-4).\n\nNote also that \u00ab123\u00bb being a \u201cprefix\u201d of \u00ab123456\u00bb means that the first range\ncompletely contains the second range. The less precise \u00ab123\u00bb is a\n\u201cconservative estimate\u201d of the more precise \u00ab123456\u00bb.\n\nThis \u00ab123\u00bb example range uses decimal digits. Summarizing this blog post\nseries: the essence of LZMA compression is recording one very precise range\njust like this (precise means a large number of digits, so a narrow width),\nbut using base-256 digits. This very precise range forms the vast majority of\nthe compressed file\u2019s bytes.\n\n## Byms (Binary Symbols)\n\nLZMA is a compression technique combining two steps: (1) \u201cLempel-Ziv back-\nreferences\u201d (I\u2019ll get to those later) with some bureaucratic overhead and (2)\nrange coding. Decoding LZMA involves decoding both steps, in reverse order.\nRange decoding consumes the compressed bytes (a digit stream, base-256 digits\nfor LZMA) and produces a symbol stream.\n\nWikipedia\u2019s range coding article discusses a 3-symbol example (\u2018A\u2019, \u2018B\u2019, EOF)\nbut LZMA uses a simpler 2-symbol stream (and \u201cEnd Of File\u201d is often implicit,\nas the byte length of the uncompressed text (after decoding step 1) is\ntransmitted separately.\n\nA 2-symbol stream is a bit stream but, in order to disambiguate compressed\nbits-and-bytes from uncompressed bits-and-bytes, I\u2019m going to use \u201cbyte\nstream\u201d for LZMA range coding\u2019s compressed form and \u201cbym stream\u201d for its\nuncompressed form. Bym is short for \u201cbinary symbol\u201d the way that \u201cbit\u201d is\nshort for \u201cbinary digit\u201d. There are two bym values. Let\u2019s call them blue (0)\nand green (1).\n\nLZMA gets good compression ratios because the blues and greens don\u2019t have to\nbe equally weighted in the byte stream. If blues are more common than greens\nthen they can have a shorter representation. For those familiar with Huffman\ncoding, a further advantage of range coding is that the symbol (or symbol-\ncluster) probabilities don\u2019t have to be a power-of-a-half: 50%, 25%, 12.5%,\n6.25%, etc. If blues are roughly twice as common as greens then range coding\ncan still represent a 2:1 split (a 67% probability, roughly) fairly\naccurately.\n\n## Treasure Hunting\n\nWhen decoding LZMA, how does a very narrow range convert into a bym stream?\nI\u2019ll use a \u201ctreasure hunting\u201d analogy. Suppose that you\u2019re looking for buried\ntreasure on a 1-dimensional island, aligned west to east. The island is 0.9999\nunits long, so you can identify any location by a number in the range (0 ++\n0.9999). You also have a cryptic treasure map: that previously mentioned, very\nprecise list of digits that locates that treasure. That location (call it the\nactual treasure range) is a narrow range.\n\nYou can\u2019t keep more-than-four-digit numbers in your head and four is less than\nthe length of the treasure map, so you can\u2019t just head straight to the precise\ntreasure location. Instead, you keep a treasure-prefix range that\u2019s equivalent\nto a prefix of the treasure map\u2019s digit string. The treasure-prefix range\nalways contains the actual treasure range. You\u2019ll iterate, making progress,\nand on some iterations you\u2019ll \u201czoom in\u201d, reading more digits from your\ntreasure map, narrowing the treasure-prefix range\u2019s width by a factor of 10.\n\nYou\u2019ll also keep a coverage range that always that always contains (covers)\nthe entire treasure-prefix range (a range has a width; it\u2019s not a single\nnumber) and therefore always contains the actual treasure range.\n\nEach iteration, your coverage range gets narrower. Some arithmetic will tell\nyou how to split your coverage range into two parts, maybe of unequal size,\nbut only one part will contain the treasure-prefix range. Those two parts,\nwest and east, are also labeled blue and green. Each iteration, note whether\nyou\u2019re taking the blue or green branch.\n\nEventually, you\u2019ll get to the end of the treasure map, but the analogy\u2019s\nburied treasure chest only held a MacGuffin. The real treasure was the\nsequence of blue and green byms we made along the way.\n\nHere\u2019s an illustration of \u00ab8\u00bb and \u00ab83\u00bb in light yellow and dark yellow. The\ncoverage range starts at full width and, at each iteration (row), that range\nis split into blue and green parts, at either a 1:1 (top) or 2:1 (bottom)\nratio. At each iteration, whichever \u2018b\u2019 or \u2018g\u2019 (blue or green) split contained\nthe yellow treasure range becomes the next iteration\u2019s coverage range. Note\nthat the bym sequence for \u00ab83...\u00bb (top: \u201cggbgbg...\u201d or bottom: \u201cgbgbb...\u201d)\ndepends on the blue-green ratio (or, equivalently, the \u201cprobability\u201d or\nprediction of the next bym being blue), not just the \u00ab83...\u00bb treasure map\nitself.\n\nIn this illustration, the bym stream decoding stops when it becomes ambiguous:\nwhen the \u00ab83\u00bb dark yellow column crosses a blue-green boundary. In practice,\nwith LZMA, it\u2019d never get to that ambiguous stage. The coverage, blue and\ngreen widths are always an integer multiple of the treasure-prefix width. We\u2019d\nzoom in (making the treasure-prefix width smaller, the yellow column narrower)\nwhenever the coverage width got too small (as a multiple of that treasure-\nprefix width granularity).\n\n## Zooming In\n\nAt first glance, you\u2019ll need to track four numbers (two pairs of two), since\nboth the coverage range and the treasure-prefix range have a lower bound and a\nwidth. But also, if you\u2019re limited to four-digit numbers, you can\u2019t just drop\nthe \u20181\u2019 when you load the \u20185\u2019 from \u00ab123456\u00bb. There\u2019s a transformation that\naddresses both concerns.\n\nYou conceptually track two lower bounds (coverage and treasure-prefix) but, in\npractice, only track the difference between them. Remember that the treasure-\nprefix range is always completely within the coverage range, and the treasure-\nprefix has non-zero range, so an invariant is that this difference is strictly\nless than the coverage width.\n\nWe can also set the treasure-prefix width implicitly to always be 1 ZLU (Zoom\nLevel Unit), the granularity that our current iteration is working at. We then\nonly have to track two state variables: a lower-bound difference (which I\u2019ll\ncall bits, since it derives from the compressed-data bit stream - the treasure\nmap; some other range coding implementations call this variable code) and a\nwidth (the coverage width). Both bits and width are integer multiples of ZLUs.\n\nTo start with, set bits the first four digits of the treasure map (actually,\nthe first five, since the first digit is always zero to simplify the encoder,\nsee \u201cfive digits\u201d below), width to 9999 and the ZLU to 1e-5.\n\nOn each iteration, you\u2019ll pick blue or green, then width (the coverage width)\nwill get smaller. Whenever it gets too small (less than 1000 ZLUs), zoom in\n(which makes the ZLU smaller by 10x). Conceptually, zooming in leaves the\ncoverage range unchanged (it\u2019s 10x as many ZLUs but each ZLU is now 10x\nsmaller) but narrows the treasure-prefix range by 10x (because we load another\ndigit from the treasure map; the treasure-prefix width stays at 1 ZLU but a\nZLU is now smaller). It also nudges (by that loaded digit) the bits lower-\nbound difference (as measured in ZLUs). In terms of code, zooming in is:\n\n    \n    \n    if width < 1000 { // An invariant is that (bits < width) and so, when limited to // four-digit numbers, the high (thousands) digit of both bits and // width must be zero. Multiplying by 10 (and adding up to 9) will // not overflow. bits = (10 * bits) + loadNextDigit() width = (10 * width) }\n\nThe ZLU isn\u2019t explicitly tracked. It\u2019s a useful concept for visualizing and\nunderstanding the iterative process but isn\u2019t actually needed in the code.\n\n## Decoder\n\nHere\u2019s the decoder inner loop\u2019s code (and a visualization).\n\n    \n    \n    // t is the threshold. t = mul(width, prob) // Decode the bym. if bits < t { width = t bym = blue // \u00b6 TODO: adaptive probabilities. } else { bits -= t width -= t bym = green // \u00b6 TODO: adaptive probabilities. } // Zoom in if necessary. if width < 1000 { bits = (10 * bits) + loadNextDigit() width = (10 * width) }\n\nThe mul(width, prob) expression basically multiplies width and prob, but the\nmul abstraction glosses away whether prob uses a fixed-point or floating-point\nrepresentation.\n\nSo far, that probability has been constant and previously agreed on between\nencoder and decoder. I\u2019ve stuck a couple of \u201c\u00b6\u201d pins in that code for now.\nWe\u2019ll come back to that later.\n\n## Encoder\n\nAs always, encoding is the opposite to decoding. Decoding starts with the\ntreasure map and produces a bym stream. Encoding starts with the bym stream\nand needs to produce a treasure map.\n\nVisually, recalling the first image above, playing a sequence of blue and\ngreen byms defines a successively narrower range. Setting the treasure range\u2019s\nlower bound to the final, narrowest row will lead the decoder down the same\npath (and hence recover the same bym stream).\n\nThe decoder basically had two state variables (bits and width) plus the\ntreasure map itself. The encoder also has two state variables (plus a couple\nothers; see \u201cN+1 pending digits\u201d below), that are very similar, but slightly\ndifferent, so I\u2019m going to call them low and width. In both cases, the width\nis the coverage width, which the encoder tracks step-for-step with each\nencoded bym the way the decoder updates its coverage width with each decoded\nbym.\n\nThe encoder\u2019s low is a range\u2019s lower bound, compared to the decoder\u2019s bits\nbeing a difference of two ranges\u2019 lower bounds. The encoder needs to know the\ncoverage\u2019s lower bound (in ZLUs, modulo 10000) in absolute terms. Its digits\nare the ones written out as the treasure map. Here\u2019s the encoder core loop\u2019s\ncode (and a visualization).\n\nThe encoder code is similar to the decoder code. Note especially that both\nencoder and decoder zoom in at the same time, after the same number of\niterations. Zooming in happens when the width is small enough, and updating\nthe width only depends on the threshold (i.e. on the width and prob) and\nwhether the bym is blue or green. The formula for updating the width does not\ndepend on the value of the decoder\u2019s bits, other than the decoder uses bits\nand t to deduce blue versus green.\n\n    \n    \n    // t is the threshold. t = mul(width, prob) // Encode the bym. if bym == blue { width = t // \u00b6 TODO: adaptive probabilities. } else { low += t width -= t // \u00b6 TODO: adaptive probabilities. } // Zoom in if necessary. if width < 1000 { low = shiftLow(low) width = (10 * width) }\n\n## ShiftLow\n\nThe shiftLow function shifts the left-most digit out of the 4-digit low number\nand shifts a zero digit into the right-most. For example, with base-10 digits,\nit turns 5678 into 6780, having \u201cshifted out\u201d the \u20185\u2019 and \u201cshifted in\u201d a \u20180\u2019.\nIn code:\n\n    \n    \n    out = low / 1000 low = (low * 10) % 10000\n\nFor base-256 digits and a 4 digit uint32_t low variable, this involves << and\n>> bit-shift operators, hence the \u201cshift\u201d in the function name.\n\n    \n    \n    out = low >> 24 low = low << 8\n\nThe out digits basically form the treasure map digits. There\u2019s one detail,\nthough, since we can\u2019t undo writing a digit to the treasure map. Recall that,\nat any given iteration, (low ++ width) is a conservative estimate of the\ntreasure range. If we\u2019ve already written \u00ab123\u00bb to the treasure map and our low\nvalue is 4996, we don\u2019t want shiftLow to prematurely write out the \u20184\u2019 digit\nbefore we\u2019re certain that the treasure range\u2019s lower bound is 0.1234something\nand not 0.1235something. shiftLow therefore doesn\u2019t emit the \u20184\u2019 immediately.\nInstead, it puts the \u20184\u2019 in the encoder\u2019s \u201cpending digits\u201d, also known as its\n\u201ccache\u201d. Pending digits are only flushed to the actual output byte stream when\nthe encoder is certain there won\u2019t be any overflow that would imply \u201ccarrying\nthe 1\u201d. Some code for that is in the complete range coding implementation in\nthe next blog post.\n\nThere can be more than one pending digit, but if so, all but the first digit\nmust be \u20189\u2019 (with base-10 digits, or \u20180xFF\u2019 with base-256 digits).\n\nIt simplifies the encoder if there\u2019s also always at least one pending digit.\nIt\u2019s therefore initialized with a pending digit of zero. That\u2019s why the\ntreasure map always starts with a zero digit (and the decoder starts by\nreading five digits instead of four, discarding that initial always-zero).\n\nWe therefore always have N+1 pending digits, for some non-negative N that\ncounts the number of trailing \u20189\u2019s. The encoder can track this in two state\nvariables: one holds the first pending digit and the second holds N.\n\n## Initial Zero Byte\n\nTangentially, there\u2019s some disagreement whether LZMA decoders should enforce\nthat the initial treasure map digit is zero.\n\nBoth xz and lzma-sdk return an error if that initial byte is non-zero.\nHowever, LZIP has an ignore_marking configuration option that allows for non-\nzero initial bytes. Its testsuite/fox6_mark.lz file explicitly tests for this.\nLZIP files can be concatenated and this one \u2018marked\u2019 the overall file with\n{'\\x00', '\\x00', 'm', 'a', 'r', 'k'} in the ignored bytes at positions 0x006,\n0x056, 0x0A6, 0x0F6, 0x146 and 0x196. Each sixth of that lz file is otherwise\nidentical.\n\n    \n    \n    $ wget https://download.savannah.gnu.org/releases/lzip/lzip-1.24.tar.gz $ tar xvf lzip-1.24.tar.gz $ grep -C 5 get_byte.*ignore_marking lzip-1.24/decoder.h bool load( const bool ignore_marking = true ) { code = 0; range = 0xFFFFFFFFU; // check and discard first byte of the LZMA stream if( get_byte() != 0 && !ignore_marking ) return false; for( int i = 0; i < 4; ++i ) code = ( code << 8 ) | get_byte(); return true; } void normalize() $ lzip --decompress --stdout lzip-1.24/testsuite/fox6_mark.lz The quick brown fox jumps over the lazy dog. The quick brown fox jumps over the lazy dog. The quick brown fox jumps over the lazy dog. The quick brown fox jumps over the lazy dog. The quick brown fox jumps over the lazy dog. The quick brown fox jumps over the lazy dog. $ hd lzip-1.24/testsuite/fox6_mark.lz 00000000 4c 5a 49 50 01 0c 00 2a 1a 08 a2 03 25 66 f1 4b |LZIP...*....%f.K| 00000010 78 c5 a2 05 ff 2e e6 d9 d2 20 1a ad 34 f8 e2 1d |x........ ..4...| 00000020 e8 41 36 fa dc 06 69 bb 3c e4 10 34 27 09 eb b3 |.A6...i.<..4'...| 00000030 66 e3 ec 97 ea ae 23 ff fe 8e a0 00 6a cc 50 eb |f.....#.....j.P.| 00000040 2d 00 00 00 00 00 00 00 50 00 00 00 00 00 00 00 |-.......P.......| 00000050 4c 5a 49 50 01 0c 00 2a 1a 08 a2 03 25 66 f1 4b |LZIP...*....%f.K| 00000060 78 c5 a2 05 ff 2e e6 d9 d2 20 1a ad 34 f8 e2 1d |x........ ..4...| 00000070 e8 41 36 fa dc 06 69 bb 3c e4 10 34 27 09 eb b3 |.A6...i.<..4'...| 00000080 66 e3 ec 97 ea ae 23 ff fe 8e a0 00 6a cc 50 eb |f.....#.....j.P.| 00000090 2d 00 00 00 00 00 00 00 50 00 00 00 00 00 00 00 |-.......P.......| 000000a0 4c 5a 49 50 01 0c 6d 2a 1a 08 a2 03 25 66 f1 4b |LZIP..m*....%f.K| 000000b0 78 c5 a2 05 ff 2e e6 d9 d2 20 1a ad 34 f8 e2 1d |x........ ..4...| 000000c0 e8 41 36 fa dc 06 69 bb 3c e4 10 34 27 09 eb b3 |.A6...i.<..4'...| 000000d0 66 e3 ec 97 ea ae 23 ff fe 8e a0 00 6a cc 50 eb |f.....#.....j.P.| 000000e0 2d 00 00 00 00 00 00 00 50 00 00 00 00 00 00 00 |-.......P.......| 000000f0 4c 5a 49 50 01 0c 61 2a 1a 08 a2 03 25 66 f1 4b |LZIP..a*....%f.K| 00000100 78 c5 a2 05 ff 2e e6 d9 d2 20 1a ad 34 f8 e2 1d |x........ ..4...| 00000110 e8 41 36 fa dc 06 69 bb 3c e4 10 34 27 09 eb b3 |.A6...i.<..4'...| 00000120 66 e3 ec 97 ea ae 23 ff fe 8e a0 00 6a cc 50 eb |f.....#.....j.P.| 00000130 2d 00 00 00 00 00 00 00 50 00 00 00 00 00 00 00 |-.......P.......| 00000140 4c 5a 49 50 01 0c 72 2a 1a 08 a2 03 25 66 f1 4b |LZIP..r*....%f.K| 00000150 78 c5 a2 05 ff 2e e6 d9 d2 20 1a ad 34 f8 e2 1d |x........ ..4...| 00000160 e8 41 36 fa dc 06 69 bb 3c e4 10 34 27 09 eb b3 |.A6...i.<..4'...| 00000170 66 e3 ec 97 ea ae 23 ff fe 8e a0 00 6a cc 50 eb |f.....#.....j.P.| 00000180 2d 00 00 00 00 00 00 00 50 00 00 00 00 00 00 00 |-.......P.......| 00000190 4c 5a 49 50 01 0c 6b 2a 1a 08 a2 03 25 66 f1 4b |LZIP..k*....%f.K| 000001a0 78 c5 a2 05 ff 2e e6 d9 d2 20 1a ad 34 f8 e2 1d |x........ ..4...| 000001b0 e8 41 36 fa dc 06 69 bb 3c e4 10 34 27 09 eb b3 |.A6...i.<..4'...| 000001c0 66 e3 ec 97 ea ae 23 ff fe 8e a0 00 6a cc 50 eb |f.....#.....j.P.| 000001d0 2d 00 00 00 00 00 00 00 50 00 00 00 00 00 00 00 |-.......P.......| 000001e0\n\nThe Linux kernel\u2019s MicroLZMA variant, used by EROFS, also re-purposes this\nalways-zero initial byte.\n\nNext: Part 2: A Complete Toy Range Coder.\n\nPublished: 2024-04-14\n\n", "frontpage": false}
