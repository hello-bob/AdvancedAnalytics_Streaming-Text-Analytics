{"aid": "40120060", "title": "What Is the Metropolis Algorithm?", "url": "https://jameshfisher.com/2024/04/18/metropolis-algorithm/", "domain": "jameshfisher.com", "votes": 2, "user": "janvdberg", "posted_at": "2024-04-22 20:45:23", "comments": 0, "source_title": "What is the Metropolis algorithm?", "source_text": "What is the Metropolis algorithm?\n\n# What is the Metropolis algorithm?\n\nWe could estimate Bob\u2019s lunch tomorrow by counting the previous lunches you\u2019ve\nseen him eating in the cafeteria:\n\nLunch| Count  \n---|---  \nApple| 2  \nBanana| 3  \n  \nNow we want to simulate Bob\u2019s future lunches. Assume Bob randomly picks a\nlunch each morning, with the relative proportions you\u2019ve observed. Then we can\nsimulate Bob\u2019s lunch with:\n\n    \n    \n    type Meal = \"Apple\" | \"Banana\"; function sample(): Meal { return Math.random() < 2 / 5 ? \"Apple\" : \"Banana\"; }\n\n52 of the samples will be Apple, and 53 will be Banana.\n\nThe Metropolis algorithm gives a different way to get samples with those\ncorrect proportions. It looks like this:\n\n    \n    \n    function nextMeal(currentMeal: Meal): Meal { if (currentMeal === \"Apple\") { return \"Banana\"; } else { if (Math.random() < 2 / 3) { return \"Apple\"; } else { return \"Banana\"; } } } class Chain { currentMeal: Meal; constructor() { this.currentMeal = \"Apple\"; } sample(): Meal { const current = this.currentMeal; this.currentMeal = nextMeal(current); return current; } }\n\nYes: this algorithm is more complicated and performs worse! But the underlying\ntechnique can help us sample from more complex distributions. So let\u2019s see\nwhat it\u2019s doing here, and why it works at all.\n\nInstead of each sample call being independent, the Metropolis algorithm\ninitializes a Chain which maintains a \u201ccurrent meal\u201d. Each call to sample sets\nthe next meal.\n\nHere\u2019s one run of one chain:\n\n    \n    \n    const chain = new Chain(); for (let i = 0; i < 10; i++) { console.log(`Day ${i}: `, chain.sample()); }\n    \n    \n    Day 0: Apple Day 1: Banana Day 2: Apple Day 3: Banana Day 4: Banana Day 5: Apple Day 6: Banana Day 7: Banana Day 8: Apple Day 9: Banana\n\nNotice Bob\u2019s first meal is always Apple. And if Bob\u2019s current meal is Apple,\nthe next meal is always Banana, so Bob\u2019s second meal is always Banana. Here\nare two problems with the Metropolis algorithm: the first few samples are not\nin the correct distribution, samples are dependent on the previous samples.\n\nLet\u2019s run 10,000 chains, and then log the distribution of apples on each day:\n\n    \n    \n    const chains: Chain[] = []; for (let i = 0; i < 10000; i++) chains.push(new Chain()); for (let i = 0; i < 10; i++) { const samples = chains.map((chain) => chain.sample()); const numApples = samples.filter((sample) => sample === \"Apple\").length; console.log(`Num apples on day ${i}:`, numApples); }\n    \n    \n    Num apples on day 0: 0 Num apples on day 1: 6673 Num apples on day 2: 2202 Num apples on day 3: 5186 Num apples on day 4: 3184 Num apples on day 5: 4563 Num apples on day 6: 3600 Num apples on day 7: 4255 Num apples on day 8: 3846 Num apples on day 9: 4041\n\nBy day 9, approximately 4,000 of the 10,000 chains have apples. This is the\ncorrect proportion of 52. But the number bounces around before reaching this\nequilibrium.\n\nThis is called convergence. To analyze this more mathematically, we can\ninstead simulate the distribution of chains for the current meal, and\ncalculate the distribution for the next meal:\n\n    \n    \n    type MealDist = [number, number]; function nextMealDist(currentMealDist: MealDist): MealDist { const [numApples, numBananas] = currentMealDist; // Consider those eating apples today. What will they eat tomorrow? let a2a = numApples * 0; // None will eat apples. let a2b = numApples * 1; // All will eat bananas. // Then consider those eating bananas today. What will they eat tomorrow? let b2a = numBananas * (2 / 3); // Two-thirds will eat apples. let b2b = numBananas * (1 / 3); // The rest will eat bananas. const numApplesTomorrow = a2a + b2a; const numBananasTomorrow = a2b + b2b; return [numApplesTomorrow, numBananasTomorrow]; } // To start, all 10,000 chains are eating apples. let currentMealDist: MealDist = [10_000, 0]; for (let i = 0; i < 10; i++) { currentMealDist = nextMealDist(currentMealDist); console.log(`Num apples on day ${i}: ${currentMealDist[0].toFixed(3)}`); }\n\nAgain, we see that by day 9, around 52 of the chains are eating apples:\n\n    \n    \n    Num apples on day 0: 0.000 Num apples on day 1: 6666.667 Num apples on day 2: 2222.222 Num apples on day 3: 5185.185 Num apples on day 4: 3209.877 Num apples on day 5: 4526.749 Num apples on day 6: 3648.834 Num apples on day 7: 4234.111 Num apples on day 8: 3843.926 Num apples on day 9: 4104.049\n\nActually, we don\u2019t need to start the distribution at [10_000, 0]. We can just\nstart with [1, 0]. This is then a probability distribution, because the sum of\nthe two numbers is 1. Then the output is the probability distribution of the\neach meal:\n\n    \n    \n    let currentMealDist: MealDist = [1, 0]; for (let i = 0; i < 10; i++) { currentMealDist = nextMealDist(currentMealDist); console.log( `Probability of apples on day ${i}: ${currentMealDist[0].toFixed(3)}`, ); }\n    \n    \n    Probability of apples on day 0: 0.000 Probability of apples on day 1: 0.667 Probability of apples on day 2: 0.222 Probability of apples on day 3: 0.519 Probability of apples on day 4: 0.321 Probability of apples on day 5: 0.453 Probability of apples on day 6: 0.365 Probability of apples on day 7: 0.423 Probability of apples on day 8: 0.384 Probability of apples on day 9: 0.410\n\nAfter 93 days, the probability of apples reaches a stable state, at least in\n64-bit floating-point. And that stable state is the correct distribution: 52\napple and 53 banana.\n\nBecause the first samples are not in the correct distribution, it\u2019s common to\ndiscard them. This is called burn-in.\n\nThe precise claim of the Metroplis algorithm is that, the correct distribution\nof is a stable distribution. To prove this, evaluate nextMealDist([2/5, 3/5]),\nand you\u2019ll see that it\u2019s [2/5, 3/5]. How many will eat Apple for the next\nmeal? None of the 52 currently eating apples will eat apples tomorrow. Of the\n53 currently eating bananas, 32 will eat apples tomorrow. for a total of\n53\u00d732=52. And so the probability of 52 is maintained.\n\nThe example algorithm above was hard-coded to generate the stable state 52 and\n53. But time passes, after which we\u2019ve counted 3 apple meals, and 6 banana\nmeals. Let\u2019s update the algorithm to work with any counts:\n\n    \n    \n    // Our observed counts. // We want to generate more meals in this proportion. const A = 3; // Count of apples const B = 6; // Count of bananas function nextMeal(currentMeal: Meal): Meal { if (currentMeal === \"Apple\") { return \"Banana\"; } else { if (Math.random() < A / B) { return \"Apple\"; } else { return \"Banana\"; } } }\n\nLet\u2019s show that, for any counts A and B, this converges to the correct\nprobability distribution, A+BA and A+BB.\n\nnumApplesnumBananasa2ab2anumApplesTomorrow=A+BA=A+BB=0=numBananas\u00d7BA=A+BB\u00d7BA=(A+B)BBA=A+BA=a2a+b2a=0+A+BA=A+BA\n\nSo far, we\u2019ve only observed Bob eating Apple or Banana. But then one day Bob\u2019s\nin the cafeteria eating Chips! We need to handle more states. We can record\nour observed frequencies with a function f:\n\n    \n    \n    function f(meal: Meal): number { return { Apple: 3, Banana: 6, Chips: 1, }[meal]; }\n\nThe true Metropolis sample algorithm actually starts by proposing a new meal.\nThen it decides whether to change to that meal, or eat the current meal again.\nHere\u2019s a proposal function that picks from possible meals with uniform\nprobability:\n\n    \n    \n    function proposeMeal(): Meal { const meals: Meal[] = [\"Apple\", \"Banana\", \"Chips\"]; const i = Math.floor(Math.random() * 3); return meals[i]!; }\n\nThen the true nextMeal function looks like:\n\n    \n    \n    function nextMeal(currentMeal: Meal): Meal { const proposedMeal = proposeMeal(); const proposedMealFreq = f(proposedMeal); const currentMealFreq = f(currentMeal); // The key line! const transitionProb = Math.min(proposedMealFreq / currentMealFreq); if (Math.random() < transitionProb) { return proposedMeal; } else { return currentMeal; } }\n\nThis works, but why does it work? The key point in the proof is that, for any\ntwo states A and B in the steady state, the probability mass transferred from\nA to B is the same as the probability mass transferred from B to A.\n\nLet\u2019s prove that. If we\u2019re in steady state, every state S has mass\nproportional to f(S). For simplicity, just say the mass at S is f(S). Without\nloss of generality, let\u2019s assume f(A)\u2264f(B).\n\nHow much mass is transferred from state A to B? With our uniform proposal\nfunction, N1th of the mass at A is proposed to move to B. The probability of\naccepting this proposal is min(1,f(A)f(B)). Since f(A)\u2264f(B), this is 1, i.e.\nthe proposal is always accepted. So the mass moving from A to B is Nf(A).\n\nHow much mass is transferred from state B to A? Again, N1th of the mass at B\nis proposed to move to A. The probability of accepting this proposal is\nmin(1,f(B)f(A)). Since f(A)\u2264f(B), this is f(B)f(A). So the mass moving from B\nto A is Nf(B)\u00d7f(B)f(A)=Nf(A).\n\nThe same amount of mass, Nf(A), is transferred from A to B as from B to A.\nThis condition is called detailed balance, and it implies that we are in a\nsteady state.\n\nThe proposeMeal function above just picks a meal uniformly at random. But we\nwant to propose meals in proportion to their frequency. The only requirement\nis that the proposal function is symmetric: the probability of proposing A\nfrom B is the same as the probability of proposing B from $A. (Try to prove\nthat this results in detailed balance.)\n\nSo far, we\u2019ve been using discrete states. But the Metropolis algorithm is most\nuseful for continuous distributions. Here\u2019s a weird distribution over the real\nnumbers:\n\n    \n    \n    function sinFreq(x: number): number { if (0 < x && x < Math.PI * 2) { return Math.abs(Math.sin(x)); } return 0; }\n\nWe can sample from this distribution using the Metropolis algorithm in its\nfull generality:\n\n    \n    \n    class Chain<State> { constructor( // Initial state private state: State, // Function to calculate the frequency of any state private f: (state: State) => number, // Function to propose a new state - must be symmetric private propose: (state: State) => State, // Number of initial samples to discard burnIn = 1000, ) { for (let i = 0; i < burnIn; i++) { this.sample(); } } sample(): State { const current = this.state; const proposed = this.propose(current); const prob = Math.min(1, this.f(proposed) / this.f(current)); const next = Math.random() < prob ? proposed : current; this.state = next; return current; } } function propose(currentState: number): number { return currentState + (Math.random() - 0.5); } const chain = new Chain(0.5, sinFreq, propose); const numSamples = 1000000; const buckets: Record<number, number> = {}; for (let i = 0; i < numSamples; i++) { const sample = chain.sample(); const bucket = Math.floor(sample * 10); buckets[bucket] = (buckets[bucket] ?? 0) + 1; } for (const bucket in buckets) { buckets[bucket] /= numSamples; } for (const bucket in buckets) { const len = Math.floor(buckets[bucket]! * 1000); console.log(\"#\".repeat(len)); }\n\nSure enough, here\u2019s that weird lumpy distribution:\n\n    \n    \n    # ### ###### ######## ########## ############# ############## ################ ################## #################### ###################### ####################### ######################## ######################## ######################### ######################### ######################### ######################### ######################## ####################### ###################### ##################### ################### ################## ################ ############## ############ ######### ####### #### ## ## ##### ####### ######### ########### ############## ############### ################# ################### ##################### ###################### ####################### ######################## ######################## ######################### ######################## ######################## ######################## ####################### ###################### ##################### ################### ################# ################ ############## ############ ########## ####### ##### ###\n\nTagged .\n\n\ud83d\udc4b I'm Jim, a full-stack product engineer. Want to build an amazing product and\na profitable business? Read more about me or Get in touch!\n\n### Similar posts\n\nShape typing in Python\n\n2024-04-12\n\nAutomatic differentiation with dual numbers\n\nDifferentiation asks: how does tweaking the inputs change the output? To\naccurately differentiate an arbitrary function, perhaps the simplest way is\nusing \u201cdual numbers\u201d. 2024-04-02\n\nWhat is numerical differentiation?\n\nDifferentiation asks: how does tweaking the inputs change the output?\nNumerical differentiation is a simple, general way to do this. But it\u2019s not\nvery accurate, and it\u2019s inefficient when there are many inputs. 2024-04-01\n\nTell the LLM the business context\n\nTell LLM why its task is needed and how the output will be used. You\u2019ll get\nbetter results, but programmers often don\u2019t do this because it\u2019s anti-modular.\n2024-03-30\n\nAuto-summarizing my blog posts\n\nSummarizing my blog posts using Claude Haiku. The benefits of providing\nbusiness context. The benefits of iterating. 2024-03-26\n\nIt might not need a label\n\nOften, content is self-labelling. Removing its label can make the content more\nscannable. Programmers often over-label. 2024-03-20\n\n### Similar posts\n\nShape typing in Python\n\n2024-04-12\n\nAutomatic differentiation with dual numbers\n\nDifferentiation asks: how does tweaking the inputs change the output? To\naccurately differentiate an arbitrary function, perhaps the simplest way is\nusing \u201cdual numbers\u201d. 2024-04-02\n\nWhat is numerical differentiation?\n\nDifferentiation asks: how does tweaking the inputs change the output?\nNumerical differentiation is a simple, general way to do this. But it\u2019s not\nvery accurate, and it\u2019s inefficient when there are many inputs. 2024-04-01\n\nTell the LLM the business context\n\nTell LLM why its task is needed and how the output will be used. You\u2019ll get\nbetter results, but programmers often don\u2019t do this because it\u2019s anti-modular.\n2024-03-30\n\nAuto-summarizing my blog posts\n\nSummarizing my blog posts using Claude Haiku. The benefits of providing\nbusiness context. The benefits of iterating. 2024-03-26\n\nIt might not need a label\n\nOften, content is self-labelling. Removing its label can make the content more\nscannable. Programmers often over-label. 2024-03-20\n\n### More by Jim\n\nWhat does the dot do in JavaScript?\n\nfoo.bar, foo.bar(), or foo.bar = baz - what do they mean? A deep dive into\nprototypical inheritance and getters/setters. 2020-11-01\n\nSmear phishing: a new Android vulnerability\n\nTrick Android to display an SMS as coming from any contact. Convincing\nphishing vuln, but still unpatched. 2020-08-06\n\nA probabilistic pub quiz for nerds\n\nA \u201ctrue or false\u201d quiz where you respond with your confidence level, and the\noptimal strategy is to report your true belief. 2020-04-26\n\nTime is running out to catch COVID-19\n\nSimulation shows it\u2019s rational to deliberately infect yourself with COVID-19\nearly on to get treatment, but after healthcare capacity is exceeded, it\u2019s\nbetter to avoid infection. Includes interactive parameters and visualizations.\n2020-03-14\n\nThe inception bar: a new phishing method\n\nA new phishing technique that displays a fake URL bar in Chrome for mobile. A\nkey innovation is the \u201cscroll jail\u201d that traps the user in a fake browser.\n2019-04-27\n\nThe hacker hype cycle\n\nI got started with simple web development, but because enamored with\nincreasingly esoteric programming concepts, leading to a \u201ctrough of hipster\ntechnologies\u201d before returning to more productive work. 2019-03-23\n\nProject C-43: the lost origins of asymmetric crypto\n\nBob invents asymmetric cryptography by playing loud white noise to obscure\nAlice\u2019s message, which he can cancel out but an eavesdropper cannot. This\nidea, published in 1944 by Walter Koenig Jr., is the forgotten origin of\nasymmetric crypto. 2019-02-16\n\nHow Hacker News stays interesting\n\nHacker News buried my post on conspiracy theories in my family due to\noverheated discussion, not censorship. Moderation keeps the site focused on\ninteresting technical content. 2019-01-26\n\nMy parents are Flat-Earthers\n\nFor decades, my parents have been working up to Flat-Earther beliefs. From\nEgyptology to Jehovah\u2019s Witnesses to theories that human built the Moon\nbillions of years in the future. Surprisingly, it doesn\u2019t affect their\nsuccessful lives very much. For me, it\u2019s a fun family pastime. 2019-01-20\n\nThe dots do matter: how to scam a Gmail user\n\nGmail\u2019s \u201cdots don\u2019t matter\u201d feature lets scammers create an account on, say,\nNetflix, with your email address but different dots. Results in convincing\nphishing emails. 2018-04-07\n\nThe sorry state of OpenSSL usability\n\nOpenSSL\u2019s inadequate documentation, confusing key formats, and deprecated\ninterfaces make it difficult to use, despite its importance. 2017-12-02\n\nI hate telephones\n\nI hate telephones. Some rational reasons: lack of authentication, no spam\nfiltering, forced synchronous communication. But also just a visceral fear.\n2017-11-08\n\nThe Three Ts of Time, Thought and Typing: measuring cost on the web\n\nBusinesses often tout \u201cfree\u201d services, but the real costs come in terms of\ntime, thought, and typing required from users. Reducing these \u201cThree Ts\u201d is\nkey to improving sign-up flows and increasing conversions. 2017-10-26\n\nGranddad died today\n\nGranddad died. The unspoken practice of death-by-dehydration in the NHS. The\nLiverpool Care Pathway. Assisted dying in the UK. The importance of planning\nin end-of-life care. 2017-05-19\n\nHow do I call a program in C, setting up standard pipes?\n\nA C function to create a new process, set up its standard input/output/error\npipes, and return a struct containing the process ID and pipe file\ndescriptors. 2017-02-17\n\nYour syntax highlighter is wrong\n\nSyntax highlighters make value judgments about code. Most highlighters judge\nthat comments are cruft, and try to hide them. Most diff viewers judge that\ncode deletions are bad. 2014-05-11\n\nThis page copyright James Fisher 2024. Content is not associated with my\nemployer. Found an error? Edit this page.\n\nJim Fisher\n\nCV\n\nSpeaking\n\nBlogroll\n\nRSS\n\nTigYog\n\nKickabout\n\n", "frontpage": false}
