{"aid": "40092157", "title": "Multi-cursor code editing: An animated introduction", "url": "https://alexharri.com/blog/multi-cursor-code-editing-animated-introduction", "domain": "alexharri.com", "votes": 3, "user": "liamswayne", "posted_at": "2024-04-19 21:33:01", "comments": 0, "source_title": "Multi-cursor code editing: An animated introduction", "source_text": "Multi-cursor code editing: An animated introduction\n\nAlex Harri\n\nHomeBlog\n\n# Multi-cursor code editing: An animated introduction\n\nJanuary 28, 2023\n\nWhen editing text, especially structured text, the need occurs to make\nrepeated changes in multiple locations. A common case is renaming a variable.\n\nLoading editor...\n\nSelect and type, select and type.\n\nFor a small block of code it's fine. A bit tedious, but fine. Banging this out\ndoesn't take a lot of time.\n\nHowever, the number of keystrokes grows linearly. Increasing the number of\nreferences to a few dozens already makes the task quite taxing.\n\nWe want the effort for repeated changes to grow in a non-linear fashion. We\ncan do that using Command D.\n\nLoading editor...\n\nNote: This post is focused on VS Code, but Command D can be used in other text\neditors such as Sublime Text. Other text editors will have analogous keyboard\nshortcuts. On Windows and Linux, the keyboard shortcut is Control D. This post\nis MacOS-oriented, but non-Mac shortcuts will be displayed throughout.\n\nCommand D selects the next instance of whatever you have selected, which\nenables multi-cursor editing.\n\nUsing Command D seems deceptively simple. Find a pattern to match, and then\nmake the change:\n\nLoading editor...\n\nThere's already a lot of value in using Command D for simple transformations,\nsuch as the above, but we're just scratching the surface. Combined with smart\ntext navigation techniques, we can take Command D quite far.\n\n## Navigating text\n\nFirst off, the basics.\n\n  * Arrow keys to move the cursor\n  * Shift to select text while moving the cursor.\n\nLoading editor...\n\nUse Option to jump over words.\n\nLoading editor...\n\nUse Control with the arrow keys to jump over words on Windows and Linux.\n\nJumping over words allows us to navigate text containing words of different\nlengths.\n\nLoading editor...\n\nUse Command to jump to the beginning or end of a line.\n\nLoading editor...\n\nOn Windows and Linux, use Home and End to jump to the beginning and end of a\nline, respectively.\n\nJumping to line boundaries allows us to navigate text that contains a variable\nnumber of words.\n\nLoading editor...\n\nWith text navigation locked down, let's do some cool stuff.\n\n## Finding the pattern\n\nTake this example of converting a series of if statements to a switch\nstatement.\n\nLoading editor...\n\nThe if statements all have the exact same structure, so matching them is\nsomewhat trivial. These sorts of patterns are the bread and butter of Command\nD, they're very common.\n\nBut Command D is still very effective for non-uniform patterns. Those more\ncomplex patterns can come in the form of\n\n  * a variable number of arguments,\n  * a variable number of words in a string, or\n  * different argument types.\n\nLet's take a look at an example.\n\n### Non-uniform patterns\n\nLet's say that we're developing a library for evaluating math expressions.\n\n    \n    \n    import { evaluate } from \"imaginary-mathlib\";\n    \n    evaluate(\"2 * 4\"); // 8\n    \n    evaluate(\"[5, 10] / 2\"); // [2.5, 5]\n    \n    evaluate(\"1 > 1/2 ? 1 : 'err'\"); // 1\n\nIn making testing the library less verbose, we made a utility function that\ntakes an expression, and its expected value.\n\n    \n    \n    function expectEqual(expression: string, expectedValue: any): void;\n\nWe have some test code using it that looks like so:\n\n    \n    \n    expectEqual(\"2**4\", 16);\n    \n    expectEqual(\"1/0\", ERR_DIV_ZERO);\n    \n    expectEqual(\"[1, 3, 5] * 2\", [2, 6, 10]);\n    \n    expectEqual(\"1/10 < 0.2 ? 'a' : 'b'\", \"a\");\n\nHowever, we want to convert this test code into the following:\n\n    \n    \n    const tests = [\n    \n    { expression: \"2**4\", value: 16 },\n    \n    { expression: \"1/0\", value: ERR_DIV_ZERO },\n    \n    { expression: \"[1, 3, 5] * 2\", value: [2, 6, 10] },\n    \n    { expression: \"1/10 < 0.2 ? 'a' : 'b'\", value: \"a\" },\n    \n    ];\n\nSince we have a lot of tests, doing this manually would be a lot of work. This\nis a prime case for using Command D, we just need to find a pattern to match.\n\nIf we match expectEqual and move in from there, we run into the problem of the\nexpressions being of different lengths.\n\nLoading editor...\n\nMatching the end runs into the same problem. The values are of different\nlengths.\n\nLoading editor...\n\nIf we try to match the commas , between the expression and the value, we also\nmatch commas within the expressions and expected values:\n\nLoading editor...\n\nThe expression and expected value can be of any length, so matching the start\nor end is of no use.\n\nHowever, we can observe that the expression is always a string. The expression\nalways ends with double quote \" immediately followed by a comma ,. That's a\npattern we can match!\n\nLoading editor...\n\n## Matching every instance\n\nIn the example above, we matched four tests. That's a pretty small number of\ntests, especially for a library that evaluates math expressions.\n\nPressing Command D three times is not a lot of work, but if the number of\ntests were increased to 1,000 we would need to press Command D 999 times. This\ngoes against our goal of making repeated changes grow non-linearly.\n\nThis is a nice time to introduce Shift Command L, which is the keyboard\nshortcut for Select All Matches.\n\nLoading editor...\n\nSelect All Matches with Shift Control L on Windows and Linux.\n\nYou have to be a bit more careful with Shift Command L, since it selects every\nmatch in a file. You may match something that you did not intend to, which can\noccur outside of the current viewport.\n\nFor this reason, I prefer Command D when working with a small number of\nmatches. The matching feels more local, you visually see every match happen.\n\n## Skipping an instance\n\nWhen selecting matches, you may want to skip an instance. To skip a match,\npress Command K followed by Command D.\n\nLoading editor...\n\nSkip matches with Control K followed by Control D on Windows and Linux.\n\nIn order to skip a match, you first need to add the match to the selection.\nAfter you have added a match to your selection, press Command K and Command D\nto unselect it and select the next match.\n\nPressing Command K and Command D resolves to a command called Move Last\nSelection to Next Find Match. It's quite a technical name, but basically means\n\n  * remove the most recent match, and\n  * select the next match.\n\nThis is not very intuitive at first, but becomes second-nature given enough\npractice.\n\n## Matching line breaks\n\nMatching every line can be useful when working with arbitrary data.\n\nTake this text file:\n\n    \n    \n    Python\n    \n    Java\n    \n    C++\n    \n    Go\n    \n    Rust\n    \n    Elixir\n\nLet's say that we want to convert the lines of this file into a JSON array of\nstrings:\n\n    \n    \n    [\n    \n    \"Python\",\n    \n    \"Java\",\n    \n    \"C++\",\n    \n    \"Go\",\n    \n    \"Rust\",\n    \n    \"Elixir\",\n    \n    ]\n\nThere is no pattern across these lines, so matching each line seems\nimpossible. However, Command D allows us to match newlines.\n\nLoading editor...\n\nMatching newlines is occasionally useful when\n\n  * matching every line, or\n  * matching a pattern that only appears at the end of a line, or\n  * matching a pattern that spans two or more lines.\n\nFor an example of matching a multi-line pattern, take this example of only\nmatching the empty arrays:\n\nLoading editor...\n\n## Case transformations\n\nTranslating between cases (such as changing snake-case to camelCase) comes up\nfrom time-to-time. I typically encounter this case when working across HTML,\nCSS and JavaScript.\n\nVS Code has a handy Transform to Uppercase command that we can combine with\nCommand D to make this happen.\n\nLoading editor...\n\nThere is not a direct keyboard shortcut for the Transform to Uppercase\ncommand. In VS Code, you can run it by opening the command prompt with Shift\nCommand P and then typing the name of the command.\n\nNote: Unfortunately, you will not be able to use the Transform to Uppercase\nmethod in this editor. This post uses Monaco Editor, which does not have VS\nCode's command prompt.\n\n## That's a wrap!\n\nThere are many ways to do multi-cursor editing using VS Code, but I find\nCommand D to be the simplest and most useful method.\n\nTake what you learned in this post and apply it in your own work! There is a\nlearning curve, but if you get past it then I promise that Command D will\nprove itself to be a really useful and productive tool.\n\nThanks for reading the post!\n\nAlex Harri\n\n\u00a9 2024 Alex Harri J\u00f3nsson\n\nLinks\n\nGitHub\n\nLinkedIn\n\nRSS\n\nMedium\n\nPages\n\nHome\n\nBlog\n\nSnippets\n\n", "frontpage": true}
