{"aid": "40216606", "title": "Borgo is a programming language that compiles to Go", "url": "https://borgo-lang.github.io", "domain": "borgo-lang.github.io", "votes": 1, "user": "stock_toaster", "posted_at": "2024-04-30 21:30:37", "comments": 0, "source_title": "Borgo Programming Language", "source_text": "Borgo Programming Language\n\n# Borgo Programming Language\n\nIntro Primitive Types Control flow Algebraic data types and pattern matching\nStructs Result and Option Interoperability with Go Package definitions\nPointers and References Methods Interfaces Error handling Zero values and nil\nConcurrency (goroutines) Channels Select statements\n\n## Intro\n\nBorgo is a new programming language that compiles to Go.\n\nFor a high-level overview of the features and instructions on running the\ncompiler locally, check the README.\n\nThis playground runs the compiler as a wasm binary and then sends the\ntranspiled go output to the official Go playground for execution.\n\n    \n    \n    use fmt enum NetworkState<T> { Loading, Failed(int), Success(T), } struct Response { title: string, duration: int, } fn main() { let res = Response { title: \"Hello world\", duration: 0, } let state = NetworkState.Success(res) let msg = match state { NetworkState.Loading => \"still loading\", NetworkState.Failed(code) => fmt.Sprintf(\"Got error code: %d\", code), NetworkState.Success(res) => res.title, } fmt.Println(msg) }\n\n## Primitive Types\n\nPrimitive types are the same as in Go.\n\nCollections like slices and maps can be used without specifying the type of\nthe values.\n\nFor example, a slice of int elements would be declared as []int{1,2,3} in Go,\nwhereas Borgo relies on type inference to determine the type, so you can just\nwrite [1, 2, 3].\n\nFunctions like append() and len() are available as methods.\n\nMaps are initialized with the Map.new() function, which under the hood\ncompiles to a map[K]V{} expression, with the K and V types helpfully filled in\nfor you.\n\nBorgo also has tuples! They work exactly like in Rust.\n\nMultiline strings are defined by prefixing each line with \\\\\\ like in Zig.\nThis has the benefit that no character needs escaping and allows more control\nover whitespace.\n\n    \n    \n    use fmt fn main() { let n = 1 let s = \"hello\" let b = false fmt.Println(\"primitives: \", n, s, b) let mut xs = [1,2,3] fmt.Println(\"slice:\", xs) xs = xs.Append(10) fmt.Println(\"len after append:\", xs.Len()) let mut m = Map.new() m.Insert(1, \"alice\") m.Insert(2, \"bob\") fmt.Println(\"map:\", m) let pair = (\"hey\", true) fmt.Println(\"second element in tuple:\", pair.1) let multi = \\\\a multi line \\\\ string with unescaped \"quotes\" \\\\ that ends here fmt.Println(\"multiline string:\", multi) }\n\n## Control flow\n\nLike in Go, the only values that can be iterated over are slices, maps,\nchannels and strings.\n\nHowever, loops always iterate over a single value, which is the element in the\nslice (contrary to Go, where using a single iteration variable gives you the\nindex of the element).\n\nTo iterate over (index, element) pairs call the .enumerate() method on slices.\nThis has no runtime cost, it just aids the compiler in generating the correct\ncode.\n\nWhen iterating over maps, you should always destructure values with (key,\nvalue) pairs instead of a single value.\n\nLike in Rust, infinite loops use the loop {} construct whereas loops with\nconditions use while {}.\n\nExpressions like if, match and blocks return a value, so you can assign their\nresult to a variable.\n\n    \n    \n    use fmt use math.rand fn main() { let xs = [\"a\", \"b\", \"c\"] fmt.Println(\"For loop over slices\") for letter in xs { fmt.Println(letter) } fmt.Println(\"Indexed for loop\") for (index, letter) in xs.Enumerate() { fmt.Println(index, letter) } let m = Map.new() m.Insert(1, \"alice\") m.Insert(2, \"bob\") fmt.Println(\"For loop over maps\") for (key, value) in m { fmt.Println(key, value) } fmt.Println(\"Loop with no condition\") loop { let n = rand.Float64() fmt.Println(\"looping...\", n) if n > 0.75 { break } } fmt.Println(\"While loop\") let mut count = 0 while (count < 5) { fmt.Println(count) count = count + 1 } fmt.Println(\"using if statements as expressions\") fmt.Println(if 5 > 3 { \"ok\" } else { \"nope\" }) let block_result = { let a = 1 let b = 2 a + b } fmt.Println(\"block result:\", block_result) }\n\n## Algebraic data types and pattern matching\n\nYou can define algebraic data types with the enum keyword (pretty much like\nRust).\n\nPattern matches must be exhaustive, meaning the compiler will return an error\nwhen a case is missing (try removing any case statement from the example and\nsee what happens!).\n\n> For now, variants can only be defined as tuples and not as structs.\n    \n    \n    use fmt use strings enum IpAddr { V4(uint8, uint8, uint8, uint8), V6(string), } fn isPrivate(ip: IpAddr) -> bool { match ip { IpAddr.V4(a, b, _, _) => { if a == 10 { return true } if a == 172 && b >= 16 && b <= 31 { return true } if a == 192 && b == 168 { return true } false } IpAddr.V6(s) => strings.HasPrefix(s, \"fc00::\") } } enum Coin { Penny, Nickel, Dime, Quarter, } fn valueInCents(coin: Coin) -> int { match coin { Coin.Penny => 1, Coin.Nickel => 5, Coin.Dime => 10, Coin.Quarter => 25, } } fn main() { let home = IpAddr.V4(127, 0, 0, 1) let loopback = IpAddr.V6(\"::1\") fmt.Println(\"home ip is private: \", home, isPrivate(home)) fmt.Println(\"loopback: \", loopback) let cents = valueInCents(Coin.Nickel) fmt.Println(\"cents:\", cents) }\n\n## Structs\n\nDefining and instantiating structs is similar to Rust.\n\nContrary to Go, all struct fields must be initialized. See the section on nil\nand zero values for more information.\n\n    \n    \n    use fmt struct Person { name: string, hobbies: [Hobby], } enum Hobby { SkyDiving, StaringAtWall, Other(string), } fn main() { let mut p = Person { name: \"bob\", hobbies: [Hobby.StaringAtWall, Hobby.Other(\"sleep\")], } fmt.Println(\"person:\", p) p.hobbies = p.hobbies.Append(Hobby.SkyDiving) fmt.Println(\"with more hobbies:\", p) }\n\n## Result and Option\n\nSometimes it's helpful to deal with values that may or may not be there. This\nis the idea behind the Option<T> type.\n\nFor example, to get an element out of a slice or a map, you can use the\n.get(index) method that will force you to handle the case where the element\nisn't there.\n\nOther times you may want to return a value or an error. In those cases use\nResult<T, E> to let the caller know that a function may return an error.\n\nWhen you're sure that a value is definitely there, you can call .unwrap().\nLike in Rust, this is an unsafe operation and will panic.\n\nA lot of methods are missing from both Result and Option, contributions to the\nstdlib are welcome!\n\n    \n    \n    use fmt struct Person { name: string, age: int } fn validate(name: string, age: int) -> Result<Person, string> { if (age < 18) { return Err(\"too young\") } if (age > 98) { return Err(\"too old\") } Ok(Person { name, age }) } fn main() { let xs = [\"a\", \"b\", \"c\"] let element = xs.Get(2) // Option<string> match element { Some(s) => fmt.Println(\"ok, the element was found:\", s), None => fmt.Println(\"element not found\"), } let result = validate(\"alice\", 33) // Result<Person, string> match result { Ok(p) => fmt.Println(\"got a person:\", p), Err(e) => fmt.Println(\"couldn't validate:\", e), } }\n\n## Interoperability with Go\n\nOne ambitious goal of this project is to be fully compatible with the existing\nGo ecosystem.\n\nYou've already seen how the fmt package was used in previous examples, but how\ndo we deal with functions that return multiple values?\n\nThis is where our trusty Option and Result types come in! The compiler will\nhandle the conversion automatically for you :)\n\nA good mental model is to think of return types in Go functions as:\n\n    \n    \n    when return type is (T, bool) it becomes Option<T> when return type is (T, error) it becomes Result<T, E>\n\nLet's take the os.LookupEnv function as an example:\n\n    \n    \n    Go definition: func LookupEnv(key string) (string, bool) becomes: fn LookupEnv(key: string) -> Option<string>\n\nOr the os.Stat function from the same package:\n\n    \n    \n    Go definition: func Stat(name string) (FileInfo, error) becomes: fn Stat(name: string) -> Result<FileInfo>\n\n> Result<T> is short-hand for Result<T, error> where error is the standard Go\n> interface.\n\nWith this simple convention, pretty much any Go package can be used in Borgo\ncode! All is needed is a package declaration, which is discussed in the next\nsection.\n\n    \n    \n    use fmt use os fn main() { let key = os.LookupEnv(\"HOME\") match key { // Option<T> Some(s) => fmt.Println(\"home dir:\", s), None => fmt.Println(\"Not found in env\"), } let info = os.Stat(\"file-does-not-exist\") match info { // Result<T, E> Ok(_) => fmt.Println(\"The file exists\"), Err(err) => fmt.Println(\"Got error reading file\", err), } }\n\n## Package definitions\n\nIn order to use existing Go packages, Borgo needs to know what types and\nfunctions they contain. This is done in declaration files, which serve a\nsimilar purpose to what you might see in Typescript with d.ts files.\n\nOnly a small part of the Go stdlib is currently available for use in Borgo --\ncheck the std/ folder for more information.\n\nThe example on the right uses the regexp package from the Go standard library.\nThe relevant bindings are defined in std/regexp/regexp.brg (here's a snippet):\n\n    \n    \n    struct Regexp { } fn Compile (expr: string) -> Result<*Regexp> { EXT } fn CompilePOSIX (expr: string) -> Result<*Regexp> { EXT } fn MustCompile (str: string) -> *Regexp { EXT } fn MustCompilePOSIX (str: string) -> *Regexp { EXT } fn Match (pattern: string, b: [byte]) -> Result<bool> { EXT } // ... other stuff\n\nWriting such declarations by hand is a pain! There's no reason why this\nprocess couldn't be automated though. The compiler comes with an importer tool\nthat parses a Go package and generates corresponding bindings to be used in\nBorgo.\n\n    \n    \n    use fmt use regexp fn main() { let validID = regexp.MustCompile(\"^[a-z]+[[0-9]+]$\") fmt.Println(validID.MatchString(\"adam[23]\")) fmt.Println(validID.MatchString(\"eve[7]\")) }\n\n## Pointers and References\n\nPointers and References work the same as in Go.\n\nTo dereference a pointer, use foo.* instead of *foo (like in Zig).\n\n    \n    \n    use fmt struct Foo { bar: int } struct Bar { foo: *Foo } fn main() { let mut f = Foo { bar: 0 } let b = Bar { foo: &f } f.bar = 99 fmt.Println(b.foo) // pointer dereference // In Go, this would be: *b.foo = ... b.foo.* = Foo { bar: 23 } fmt.Println(b.foo) }\n\n## Methods\n\nTo define methods on types, you can use impl {} blocks.\n\nIn Go, the method receiver must be specified at each function declaration. In\nBorgo, this is specified only once at the beginning of the impl block (p:\n*Person). All functions within the block will have that receiver.\n\nIt's also possible to declare static methods: functions can be declared with\ndots in their name, so you can define a Person.new function like in the\nexample.\n\n    \n    \n    use fmt struct Person { name: string, hours_slept: int, } fn Person.new(name: string) -> Person { Person { name, hours_slept: 0, } } impl (p: *Person) { fn sleep() { p.hours_slept = p.hours_slept + 1 } fn ready_for_work() -> bool { p.hours_slept > 5 } fn ready_to_party() -> bool { p.hours_slept > 10 } } fn main() { let mut p = Person.new(\"alice\") p.sleep() p.sleep() fmt.Println(\"is ready:\", p.ready_for_work()) }\n\n## Interfaces\n\nInterfaces in Borgo work the same as in Go, it's all duck typing.\n\nIf a type implements the methods declared by the interface, then the type is\nan instance of that interface.\n\nEmbedded interfaces are also supported, just list out the other interfaces\nimplied by the one being defined (prefixed by impl). For example, the\nReadWriter interface from the io package can be defined as:\n\n    \n    \n    interface ReadWriter { impl Reader impl Writer }\n\n> type sets are not supported.\n    \n    \n    use fmt use math interface geometry { fn area() -> float64 fn perim() -> float64 } struct rect { width: float64, height: float64, } impl (r: rect) { fn area() -> float64 { r.width * r.height } fn perim() -> float64 { 2 * r.width + 2 * r.height } } struct circle { radius: float64, } impl (c: circle) { fn area() -> float64 { math.Pi * c.radius * c.radius } fn perim() -> float64 { 2 * math.Pi * c.radius } } fn measure(g: geometry) { fmt.Println(g) fmt.Println(g.area()) fmt.Println(g.perim()) } fn main() { let r = rect { width: 3, height: 4, } let c = circle { radius: 5 } measure(r) measure(c) }\n\n## Error handling\n\nIn functions that return a Result, it's possible to propagate errors with the\n? operator.\n\nThis is similar to what happens in Rust, refer to the section on Propagating\nerrors in the Rust book .\n\nCurrently the ? operator only works with Result, but it will be extended to\nalso work with Option.\n\n    \n    \n    use fmt use io use os fn copy_file(src: string, dst: string) -> Result<(), error> { let stat = os.Stat(src)? if !stat.Mode().IsRegular() { return Err(fmt.Errorf(\"%s is not a regular file\", src)) } let source = os.Open(src)? defer source.Close() let destination = os.Create(dst)? defer destination.Close() // ignore number of bytes copied let _ = io.Copy(destination, source)? Ok(()) } fn copy_all_files(folder: string) -> Result<int, error> { let mut n = 0 for f in os.ReadDir(folder)? { if !f.IsDir() { let original = f.Name() let new_name = fmt.Sprintf(\"%s-copy\", original) fmt.Println(\"copying\", original, \"to\", new_name) copy_file(original, new_name)? n = n + 1 } } Ok(n) } fn main() { match copy_all_files(\".\") { Ok(n) => fmt.Println(n, \"files copied\"), Err(err) => fmt.Println(\"Got error:\", err), } }\n\n## Zero values and nil\n\nIn Borgo, you can't create nil values.\n\nThe concept of null references (or nil in this case) is being referred to as\n\"The billion dollar mistake\" and modern languages are moving away from it with\ntypes like Option<T>. Borgo tries to do the same.\n\nYou can still end up with null pointers if you're calling into existing Go\ncode, which is unfortunate. That should be solvable by writing better\nbindings, so that functions that could return a null pointer, will instead\nreturn an Option<*T>, forcing you to handle all cases.\n\nIn Go, it's common to see types not needing to be initialized, as their zero\nvalue is ready to be used (ie. sync.Mutex or sync.WaitGroup). Borgo goes in\nthe opposite direction, requiring that all values are explicitely initialized.\n\nYou can use the built-in function zeroValue() whenever you need the zero value\nof a type. While you won't need to provide a type annotation in all cases (as\nthe type can be inferred), it's probably clearer to annotate variables that\nare initialized with zeroValue().\n\nAs mentioned in a previous section, this also applies to struct fields, which\nalways need to be initialized.\n\n    \n    \n    use sync use bytes use fmt fn main() { // in Go: // var wg sync.WaitGroup let wg: sync.WaitGroup = zeroValue() // in Go: // var b bytes.Buffer let b: bytes.Buffer = zeroValue() fmt.Println(\"variables are initialized:\", wg, b) }\n\n## Concurrency (goroutines)\n\nBorgo aims to support all concurrency primitives available in Go.\n\nUse the spawn keyword (instead of go) to start a goroutine. The parameter\nneeds to be a function call.\n\nChannels and select {} statements are discussed next.\n\n    \n    \n    use sync use fmt struct Counter { count: int, mu: sync.Mutex, } fn Counter.new() -> Counter { Counter { count: 0, mu: zeroValue() } } impl (c: *Counter) { fn Inc() { c.mu.Lock() c.count = c.count + 1 c.mu.Unlock() } } fn main() { let desired = 1000 let counter = Counter.new() let wg: sync.WaitGroup = zeroValue() wg.Add(desired) let mut i = 0 while (i < desired) { // equivalent to: go func() { ... }() spawn (|| { counter.Inc() wg.Done() })() i = i + 1 } wg.Wait() fmt.Println(\"Counter value:\", counter.count) }\n\n## Channels\n\nBorgo doesn't provide any extra syntax to send/receive from channels.\n\nYou use Channel.new() to create a Sender<T> and Receiver<T>.These are roughly\nequivalent to send-only and receive-only channels in Go and will compile to\nraw channels in the final Go output.\n\nWith a Sender<T> you can call send(value: T) to send a value. With a\nReceiver<T> you can call recv() -> T to receive a value.\n\nThis design is somewhat inspired by the sync::mspc::channel module in the Rust\nstandard library.\n\n    \n    \n    use fmt fn main() { let (sender, receiver) = Channel.new() spawn (|| { sender.Send(1) })() spawn (|| { sender.Send(2) })() let msg = receiver.Recv() let msg2 = receiver.Recv() fmt.Println(msg + msg2) }\n\n## Select statements\n\nselect {} works like in Go, however the syntax is slightly different.\n\n    \n    \n    Reading from a channel Go: case x := <- ch Borgo: let x = ch.Recv() Sending to a channel Go: case ch <- x Borgo: ch.Send(x) Default case Go: default Borgo: _\n    \n    \n    use fmt use time fn main() { let (tx1, rx1) = Channel.new() let (tx2, rx2) = Channel.new() // dummy done channel let (_, done) = Channel.new() spawn (|| { tx1.Send(\"a\") })() spawn (|| { loop { select { // in Go: // case tx2 <- \"b\": tx2.Send(\"b\") => { fmt.Println(\"sending b\") time.Sleep(1 * time.Second) } let _ = done.Recv() => return } } })() select { // in Go: // case a := <- rx1: let a = rx1.Recv() => { fmt.Println(\"got\", a) }, let b = rx2.Recv() => { fmt.Println(\"got\", b) }, } }\n\n99\n\n1\n\n2\n\n3\n\n4\n\n5\n\n6\n\n7\n\n8\n\n9\n\n10\n\n11\n\n12\n\n13\n\n14\n\n15\n\n16\n\n17\n\n18\n\n19\n\n20\n\n21\n\n22\n\n23\n\n24\n\n25\n\n26\n\n27\n\n28\n\n29\n\n\u203a\n\n\u2304\n\n\u2304\n\n\u2304\n\n\u2304\n\n\u2304\n\nuse fmt\n\nenum NetworkState<T> {\n\nLoading,\n\nFailed(int),\n\nSuccess(T),\n\n}\n\nstruct Response {\n\ntitle: string,\n\nduration: int,\n\n}\n\nfn main() {\n\nlet res = Response {\n\ntitle: \"Hello world\",\n\nduration: 0,\n\n}\n\nlet state = NetworkState.Success(res)\n\nlet msg = match state {\n\nNetworkState.Loading => \"still loading\",\n\nNetworkState.Failed(code) => fmt.Sprintf(\"Got error code: %d\", code),\n\nNetworkState.Success(res) => res.title,\n\n}\n\nfmt.Println(msg)\n\n}\n\nBorgo on Github\n\n", "frontpage": false}
