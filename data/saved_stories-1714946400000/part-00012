{"aid": "40263782", "title": "Writing a PostgreSQL formatter / pretty printer in Rust. (2021)", "url": "https://blog.urth.org/2021/03/14/writing-a-postgres-sql-pretty-printer-in-rust-part-1/", "domain": "urth.org", "votes": 1, "user": "fanf2", "posted_at": "2024-05-05 10:42:03", "comments": 0, "source_title": "Writing a Postgres SQL Pretty Printer in Rust: Part 1", "source_text": "Writing a Postgres SQL Pretty Printer in Rust: Part 1 - House Absolute(ly\nPointless)\n\nHouse Absolute(ly Pointless)\n\nX\n\nSearch\n\nHouse Absolute(ly Pointless)\n\n# Writing a Postgres SQL Pretty Printer in Rust: Part 1\n\n2021-03-14\n\nThis is the first of a planned series of blog posts about my pg-pretty\nproject. I\u2019ll cover some things I\u2019ve learned about Rust and Postgres SQL, as\nwell as some things I still don\u2019t know.\n\n## Series Links\n\n  * Part 1: Introduction to the project and generating Rust with Perl\n  * Part 1.5: More about enum wrappers and Serde\u2019s externally tagged enum representation\n  * Part 2: How I\u2019m testing the pretty printer and how I generate tests from the Postgres docs\n\n## Why?\n\nI really, really, really, really cannot stand unformatted code, or a mishmash\nof code styles throughout a codebase. But at the same time, rejecting PRs from\nother developers at $WORK just because of code formatting is not okay. Making\nthem manually fiddle with formatting is not a good use of their time (or\nmine).\n\nThis is why we have linters, tidiers, and meta code quality tools like my\nprecious.\n\nCombine these with a commit hook and CI checks for code cleanliness, and I\nnever have to reject a PR for formatting. Instead, it gets auto-\u201crejected\u201d by\ngit commit or CI, and I\u2019m off the hook.\n\nAnd besides the value of not annoying me, there is also value to enforcing\ncode formatting rules throughout a large codebase. Consistency eliminates a\npotential distraction, because every Go, Perl, or Python file in the codebase\nwill look like every other Go, Perl, or Python file.\n\nSQL is code, so it sure would be nice to do the same thing there, but I can\u2019t.\nThere are a few SQL pretty printing tools that I\u2019ve found, but none of them\nhandle Postgres-specific idioms.\n\nSo of course I should write one!\n\nAnd I should write one in Rust! Of course?^1\n\nRust turned out to be a great fit for this project. More on that in a future\npost.\n\n## Where to Start?\n\nWriting a Postgres SQL parser from scratch would be quite painful^2\n\nThat\u2019s an understatement. It would be a mammoth project of its own.\n\n. Fortunately, a lot of the hard lower level work has already been done.\n\nAt the very lowest level we have libpg_query, created by Lukas Fittl. This is\na project to rip the parser out of the Postgres source tree and turn it into a\nC library. It\u2019s a shame that the Postgres source is not already organized this\nway. But I imagine that the parser started off as an integral part of the\nPostgres codebase, and by the time anyone thought of extracting it, it was\nmore work than anyone wanted to take on.\n\nThe next step is to create a Rust wrapper around this C library. Luckily that\nwas already done too. I\u2019m using libpg_query-sys, which is a bare bones wrapper\naround the C library. It exposes the same types and functions as the C\nlibrary, but in Rust.\n\n## From C to Rust\n\nThese underlying tools work by parsing a string containing Postgres SQL and\nreturning a string containing JSON. That JSON represents the AST (Abstract\nSyntax Tree) of the parsed SQL.\n\nBut to actually do anything with that AST, you want native Rust structs, not a\ngiant JSON blob.\n\nAnd that\u2019s where my work started.\n\nThe libpg_query source has a handy directory containing JSON files describing\nvarious parts of the AST. For example, the nodestypes.json file defines all of\nthe possible nodes. Many parts of the AST reference the Node type, which is\nbasically \u201cany valid bit of SQL\u201d.\n\nBut the most important file is struct_defs.json. This file defines all the\ndata structures we might care about, providing the name, fields, and field\ntypes for each struct.\n\nRust is a statically typed language, so we can\u2019t just parse this stuff at\nruntime and generate structs in memory. Instead, we need codegen. And since\nthese struct definitions reference C types, we need to translate this all into\nRust!\n\n## Generating Rust\n\nEnter my totally not-a-hacked-up-mess json-to-parser.pl script.\n\nFor each C struct that we care about we generate a corresponding Rust struct^3\n\nI figured out what to care about by a combination of trial and error and\nexperimentation. The struct_defs.json file organizes structs based on what\nfiles they\u2019re defined in. I was able to determine that (so far) I only care\nabout types from a small subset of these files.\n\n. This mostly means translating from C types to Rust types. To make things\nextra fun, I try to make the types more specific wherever I can. There are a\nnumber of places where the C struct just uses Node*, but in reality only a\nlimited subset of nodes are valid.\n\nI\u2019ve figured this out a couple ways. Sometimes, the comment for the field\n(which is in the struct_defs.json file) actually tells me. For example, many\ncomments include the text \u201clist of Value strings\u201d, which means it\u2019s a list of\nstrings. For whatever reason, the Postgres C code just uses List* (an array of\nNode*) here instead of String*^4\n\nProbably because if you\u2019re writing the parser and the thing that consumes it\nat the same time, you can write code that knows that it\u2019s only a String. Also,\nC doesn\u2019t have Rust\u2019s exhaustive pattern matching, so you\u2019re not forced to\ndeal with all possible Node types.\n\n.\n\nAs an aside, I turn all the comments in the struct_defs.json file into Rust\ndocumentation comments in the generated code, which has been quite helpful.\nThis lets me read the generated AST code and get a pretty good understanding\nof what each struct and field contains.\n\nBut in Rust, we really want to know what our possible types are. That\u2019s\nbecause I\u2019m using Rust\u2019s enum-based pattern matching. The Node enum has over\n100 variants. That\u2019s a lot of matching!\n\nI also need to generate enum wrappers around many structs. Any time a struct\nreferences another struct, I need the wrapper indirection. So for example,\nhere\u2019s a little bit of the DeleteStmt struct:\n\n    \n    \n    1 2 3 4 5 6 7\n\n|\n\n    \n    \n    #[skip_serializing_none] #[derive(Debug, Deserialize, PartialEq)] pub struct DeleteStmt { // relation to delete from pub relation: RangeVarWrapper, // RangeVar* // ... more fields ... }  \n  \n---|---  \n  \nThe relation field is going to contain a RangeVarWrapper, which is a one-\nvariant enum that looks like this:\n\n    \n    \n    1 2 3 4\n\n|\n\n    \n    \n    #[derive(Debug, Deserialize, PartialEq)] pub enum RangeVarWrapper { RangeVar(RangeVar), }  \n  \n---|---  \n  \n### Why the Wrapper?\n\nThe wrappers are annoying, and I\u2019d like to get rid of them, but I can\u2019t figure\nout how!\n\nLet\u2019s take a very simple DELETE statement and parse it:\n\n    \n    \n    1\n\n|\n\n    \n    \n    DELETE FROM films  \n  \n---|---  \n  \nThe parser gives us this (with some outer bits removed for simplicity):\n\n    \n    \n    1 2 3 4 5 6 7 8 9 10 11 12\n\n|\n\n    \n    \n    { \"DeleteStmt\": { \"relation\": { \"RangeVar\": { \"inh\": true, \"location\": 12, \"relname\": \"films\", \"relpersistence\": \"p\" } } } }  \n  \n---|---  \n  \nThere\u2019s a lot to look at there, so let\u2019s zoom in on one part:\n\n    \n    \n    1 2 3 4 5 6 7\n\n|\n\n    \n    \n    { \"DeleteStmt\": { \"relation\": { \"RangeVar\": {...} } } }  \n  \n---|---  \n  \nWe need to deserialize this into a Rust struct. For deserialization in Rust\nI\u2019m using serde, which is a powerful Rust framework for deserialization that\nsupports many data formats, including JSON.\n\nThe particular structure of the JSON above corresponds to what the serde docs\ncall \u201cthe externally tagged enum representation\u201d. In this format, the \u201ctags\u201d\nsuch as DeleteStmt and RangeVar are used to indicate which enum variant to\ndeserialize to. A variant of what? Well, that\u2019s the problem.\n\nAs far as I can tell, the only way to make this work is to make an enum\nwrapper for every single struct which might be contained in any other struct.\nSo for the RangeVar struct I need this wrapper:\n\n    \n    \n    1 2 3 4\n\n|\n\n    \n    \n    #[derive(Debug, Deserialize, PartialEq)] pub enum RangeVarWrapper { RangeVar(RangeVar), }  \n  \n---|---  \n  \nAnd then when I\u2019m working with the delete statement, I need to pattern match\nRangeVar struct out of the DeleteStmt:\n\n    \n    \n    1 2 3 4\n\n|\n\n    \n    \n    fn format_delete_stmt(&mut self, d: &DeleteStmt) -> R { let RangeVarWrapper::RangeVar(r) = &d.relation; // .. do something with the RangeVar in r }  \n  \n---|---  \n  \nI really don\u2019t like this pattern, but from my reading so far I haven\u2019t seen a\nsimple way to eliminate it. I think the only way to do this would be to\nprovide custom serde deserialization logic for every struct which contains\nanother struct.\n\nThis is absolutely possible, but I\u2019ve avoided this so far in order to focus on\nother aspects of the project. But I want to come back to this in the future,\nbecause these wrappers require a lot of extra pattern matching in the\nformatter code.\n\n### So ...\n\nSo that\u2019s why I need a Perl script to generate Rust code, though I can think\nof at least a couple other approaches.\n\nOne would be to rewrite the Perl in Rust. That would work, but the Perl script\nis already fast. The naive Rust approach would probably be slower, since I\nwould have to re-compile the Rust generator code every time I changed it,\nthough I could ameliorate that by moving some data to config files. But Perl\nis a great language for reading JSON and generating code.\n\nAnother, almost certainly terrible option, would be to write one or more\nmacros that could read the JSON source data and generate the Rust code\ndirectly. I\u2019m fairly sure this is possible with procedural macros. A\nprocedural macro looks like a function call or an attribute when you use it.\nThe implementation is just regular Rust code that takes either its \u201cfunction\u201d\narguments as input, or the thing that they are an attribute of (a type, struct\nfield, etc.). Either way, the macro implementation returns a new AST of Rust\ncode that is effectively inlined in place of the macro.\n\nProcedural macros are incredibly powerful, and I wrote one to change how\nbitflags are serialized so that serde expects these flags to be integers\nduring deserialization, rather than expecting a JSON object like { \"bits\": 42\n} later realized that serde already did what I needed, so I didn\u2019t need to\nwrite that wrapper. The bitflags crate itself is a proc macro, so it\u2019s macros\nall the way down.\n\nBut a procedural macro that parses arbitrary JSON files to generate Rust code\nseems a bit gross^5\n\nMore than a bit. Really, really gross.\n\n. And right now I find myself constantly referring to the generated SQL AST\nstructs. Having those available as regular Rust code that I can examine in my\neditor is very helpful.\n\n## Can You Try it Out?\n\nErr, sort of. If you want to give it a whirl you can clone the repo, then edit\nthe contents of cli/src/main.rs, which has some SQL to be formatted in it. But\nI haven\u2019t actually built a proper CLI for it yet. I\u2019ve just been focused on\nthe core formatting implementation, which I exercise through its test suite.\n\n## Coming Soon\n\nThis post is already quite long, but there are many other things I\u2019ve learned\nwhile working on this project that I plan to write about, including:\n\n  * Diving into the Postgres grammar to understand the AST.\n  * How I\u2019m approaching tests for this project, and how I generate test cases from the Postgres documentation.\n  * The benefits of Rust pattern-matching for working with ASTs.\n  * How terrible my solution to generating SQL in the pretty printer is, and how I wonder if there\u2019s a better way to do this.\n  * How the proc macro in the bitflags_serde_int crate works^6\n\nEdit 2021-04-24: Nope, not gonna write about this. It turns out I was\nreimplementing the already existing #[serde(transparent)] feature.\n\n.\n\n  * Who knows what else?\n\n  1. Rust turned out to be a great fit for this project. More on that in a future post. \u21a9\ufe0e\n\n  2. That\u2019s an understatement. It would be a mammoth project of its own. \u21a9\ufe0e\n\n  3. I figured out what to care about by a combination of trial and error and experimentation. The struct_defs.json file organizes structs based on what files they\u2019re defined in. I was able to determine that (so far) I only care about types from a small subset of these files. \u21a9\ufe0e\n\n  4. Probably because if you\u2019re writing the parser and the thing that consumes it at the same time, you can write code that knows that it\u2019s only a String. Also, C doesn\u2019t have Rust\u2019s exhaustive pattern matching, so you\u2019re not forced to deal with all possible Node types. \u21a9\ufe0e\n\n  5. More than a bit. Really, really gross. \u21a9\ufe0e\n\n  6. Edit 2021-04-24: Nope, not gonna write about this. It turns out I was reimplementing the already existing #[serde(transparent)] feature. \u21a9\ufe0e\n\nFound a typo? Fix it by editing this page on GitHub.\n\nComments?\n\nDiscuss this post on:\n\n  * /r/rust\n  * /r/programming\n\nYou can also email me directly.\n\nPowered by Hugo | Theme - Jane \u00a9 2007 - 2024 Dave Rolsky\n\nThis work by David Rolsky is licensed under CC BY-SA 4.0\n\n", "frontpage": false}
