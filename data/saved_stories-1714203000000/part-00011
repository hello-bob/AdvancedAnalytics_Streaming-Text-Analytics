{"aid": "40174187", "title": "Pathfinder: High-Resolution Control-Flow Attacks Exploiting the Conditional BP", "url": "https://pathfinder.cpusec.org/", "domain": "cpusec.org", "votes": 1, "user": "matt_d", "posted_at": "2024-04-26 20:56:25", "comments": 0, "source_title": "Pathfinder", "source_text": "Pathfinder\n\n> Pathfinder: High-Resolution Control-Flow Attacks Exploiting the Conditional\n> Branch Predictor\n>\n> ACM International Conference on Architectural Support for Programming\n> Languages and Operating Systems (ASPLOS), April 2024.\n>\n> Hosein Yavarzadeh, Archit Agarwal, Max Christman, Christina Garman, Daniel\n> Genkin, Andrew Kwong, Daniel Moghimi, Deian Stefan, Kazem Taram, Dean\n> Tullsen\n>\n> [ Paper | bibtex | Slides | Teaser | Video ]\n\n# TL;DR\n\nIn our prior research, Half&Half ( Paper | Video ), we completely reverse-engineered the intricate details of the conditional branch predictor (CBP) found in modern Intel processors. This involved dissecting the prediction tables, deciphering their indexing and tagging hash functions, examining associativity, size, and delving into the contents of each entry.\n\nBuilding upon this foundation, our present study, Pathfinder, unveils two\ninnovative side-channel attacks exploiting the CBP:\n\n  1. The first attack introduces an entirely novel approach within the branch predictor realm, enabling the leakage of crucial historical information pertaining to thousands of recently executed branch instructions.\n  2. The second attack unveils an exceptionally high-resolution Spectre-style exploit, capable of generating intricate patterns of mispredictions to steer the victim into executing a specific code path unintended by the programmer.\n\nWe demonstrate the implications of these attacks with two case studies: We\ndemonstrate a speculative execution attack against AES that returns\nintermediate values at multiple steps to recover the AES key. We also steal\nsecret images by capturing the complete control flow of libjpeg routines.\n\n# Background: Branch Prediction in Modern Intel CPUs\n\nIn our prior research, we discovered that the CBP within Modern Intel CPUs\nexhibits a TAGE-like structure. This entails a local base predictor, solely\nindexed by the branch address (PC), alongside a series of tagged global\npredictors. Each global predictor is 4-way set associative and indexed and\ntagged using a blend of global history geometric lengths (PHR) and the branch\naddress (PC).\n\nOriginal TAGE uses the Global History Register (GHR) to capture global\ncorrelations, updating it with each conditional branch. In contrast, Intel's\nCBPs employ the Path History Register (PHR), updated only for taken branches\nof any type. The PHR update involves shifting it left by two bits and XORing a\n16-bit branch footprint with the lower 16 bits of the PHR.\n\nTo know more about the structure of the CBP within Intel CPUs, please refer to\nour Half&Half paper.\n\n# Attack Primitives Overview\n\n  * Read PHR: Reading the PHR can be extremely powerful, because it reveals not just branch outcomes, but also the branch locations and the path that led to each branch. This study represents the first instance in the literature where we reveal the extraction of the PHR value by a malicious actor, enabling the reconstruction of the entire runtime control flow of any victim program.\n  * Extended Read PHR: This primitive extends the Read PHR primitive by allowing the attacker to read more than 194 bits of the PHR. In fact, the attacker can read the complete branch history of the victim program. This is achieved by exploiting the PHTs as a side-channel to reconstruct the PHR beyond 194 bits.\n  * Read PHT: This primitive extracts the saturating counter value of the PHT entry indexed by (PC, PHR). This counter value is crucial for understanding the prediction state of the branch predictor.\n  * Write PHT: This primitive sets the PHT entry accessed by (PC, PHR) to the provided attacker_controlled value (taken or not). This can be used to manipulate the prediction state of the branch predictor.\n\n# Pathfinder\n\nCapturing the PHR is distinct from capturing the runtime control flow of a\ntarget program, as the PHR is a complex combination of multiple addresses and\ntarget bits for each taken branch. Consequently, we introduce the Pathfinder\ntool, which, given a PHR outcome and an executable code(containing the victim\nfunction), constructs the runtime control flow graph of the victim function.\n\nPathfinder uses the angr binary analysis tool and an algorithm to identify all\npotential control flow paths matching the observed PHR values. While it's not\nguaranteed that there will always be a single path leading to the specific\nPHR, our extensive analysis has shown that ambiguous results are exceedingly\nrare due to the PHR\u2019s size and complex update function.\n\n# Attack Results\n\nWe demonstrate the implications of these attacks with two case studies:\n\n  1. Speculative Execution Attack Against AES: We demonstrate a speculative execution attack against AES that returns intermediate values at multiple steps to recover the AES key.\n  2. Stealing Secret Images: We steal secret images by capturing the complete control flow of libjpeg routines.\n\n# Mitigations\n\nWe propose the following mitigations to protect against the attacks outlined\nin this paper:\n\n  1. Flushing the PHR: The most straightforward software-based solution for mitigating the Read PHR is to flush the PHR using 194 unconditional direct branches during context switching between different security domains. Because unconditional direct branches do not interact with the PHTs at all, this prevents the attacker from exploiting the PHTs as a side-channel to reconstruct the PHR beyond 194.\n  2. Randomizing the PHR: Less costly, we could add a small, non-deterministic number of random branches into the PHR during context switching. This randomization of the PHR value would prevent attackers from obtaining the same PHR upon repeated calls to the victim, significantly reducing the attacker's ability to read the PHR.\n  3. Flushing the PHTs during Context Switching.\n  4. Partitioning the PHTs between Different Security Domains.\n  5. Encrypting Index/Tag Hash Functions of the PHTs.\n\n# Responsible Disclosure\n\nWe communicated the security findings outlined in the paper to both Intel and\nAMD in November 2023. Intel has informed other affected hardware/software\nvendors about the issues. Intel has shared their plans to address the concerns\nraised in the paper through a Security Announcement,\nINTEL-2024-04-26-001-Pathfinder. AMD plans to address the concerns raised in\nthe paper through a Security Bulletin, AMD-SB-7015.\n\nAlso, we have shared our findings with the Vulnerability Information and\nCoordination Environment (VINCE) and they have assigned a vulnerability case,\nCase VU#157097: Class of Attack Primitives Enable Data Exposure on High End\nIntel CPUs.\n\n# Contact\n\nPlease do not hesitate to reach out to me at hyavarzadeh@ucsd.edu.\n\nCopyright @ Hosein Yavarzadeh 2024\n\n", "frontpage": false}
