{"aid": "40154159", "title": "TypeScript: Mapped Type Magic", "url": "https://prosopo.io/articles/typescript-mapped-type-magic/", "domain": "prosopo.io", "votes": 1, "user": "febeling", "posted_at": "2024-04-25 06:32:07", "comments": 0, "source_title": "TypeScript: Mapped Type Magic \ud83e\ude84", "source_text": "TypeScript: Mapped Type Magic \ud83e\ude84 - Prosopo\n\n# TypeScript: Mapped Type Magic \ud83e\ude84\n\nPART 2: TypeScript Branding\n\nGreetings, esteemed coding enthusiasts! Today, we embark on a journey into the\nrealm of TypeScript mapped types. Brace yourselves for an insightful\nexploration enriched with practical insights and applications.\n\nSo, what exactly are TypeScript mapped types? Picture having the ability to\neffortlessly modify and refine existing types with a simple keystroke. Mapped\ntypes empower you to enhance your type definitions by seamlessly adding,\nremoving, or modifying properties as needed.\n\n## Presenting Our Beloved Companions: Lassie and Garfield\n\nLet's delve into some practical examples featuring our cherished furry\ncompanions, Dogs and Cats!\n\n    \n    \n    abstract class Animal { abstract name(): string } class Dog extends Animal { override name(): string { return 'Lassie' } } class Cat extends Animal { override name(): string { return 'Garfield' } }\n\nWe have our reliable entities, Dog and Cat, demonstrating their abilities by\nextending the Animal class.\n\nNow, let's exemplify mapped types by deriving the sound type emitted by our\nDog and Cat.\n\n    \n    \n    type SoundOf<T> = T extends Dog ? 'Bark' : 'Meow';\n\nExplore this innovative feature we've developed\u2014a specialized sound-selector\nfor animals. Customized for each critter, let's test its functionality and\nunveil the distinct melodies our furry companions produce.\n\n## The Curious Case of Barking Cats\n\nA dog goes \"bark,\" right? Let's see if TypeScript agrees!\n\n    \n    \n    type DogSound = SoundOf<typeof dog>; // Inferred as 'Bark'\n\nAnd surely, a cat goes \"meow.\" Let's check it out!\n\n    \n    \n    type CatSound = SoundOf<typeof cat>; // Inferred as 'Bark'?!?!\n\nWhat's occurring here is beyond comprehension! At this juncture, dear reader,\nwe felt like we were losing grasp of reality. However, sanity is merely a\ndebugging session away! \ud83e\udde0\ud83d\udcbb\ud83d\ude80\n\nWhat's going on here? \ud83e\udd14 Picture this: TypeScript views types as shapes of\nobjects. So, when we compare Cat and Dog types, TypeScript sees them both as\nobjects with a solitary function (name()). In other words, it asks, \"Does this\nCat object with a single name() function match the shape of this Dog object\nwith a single name() function?\" And voil\u00e0, it returns 'Bark' for a Cat! What a\nmix-up!\n\n## Overcoming Glitches: Adding Unique Traits\n\nHere's the scoop on using mapped types to avoid this peculiar mix-up. Think of\nit as playing detective \u2013 you must differentiate between our feline friends\nand canine companions. But fret not, it's simpler than it appears! Just\nintroduce a unique trait to the Dog class, akin to assigning them distinct\nbadges. As long as one possesses a badge the other lacks, TypeScript will\ndiscern the disparity. Let's give it a try, shall we? \ud83d\udc31\ud83d\udc36\n\n    \n    \n    class Dog extends Animal { chewsShoes = true // Marking our territory! override name(): string { return 'Lassie' } }\n\nWhat does Typescript think?\n\n    \n    \n    type DogSound = SoundOf<typeof dog>; // Inferred as 'Bark' type CatSound = SoundOf<typeof cat>; // Inferred as 'Meow'\n\nAnd just like magic, TypeScript gets it right!\n\n## It's a Sign Symbol!\n\nTread carefully though! The addition of random fields could result in chaos.\nConsider this scenario: if both Cat and Dog were to sport a 'chewShoes' field,\nwe'd find ourselves right back to square one!\n\nBut fear not, courageous coder, for there exists a ray of hope: Symbols! These\nprovide a means to hide a field away from everyone else. It's akin to\nbestowing upon Dog its very own secret handshake, inaccessible to Cat.\n\nA symbol is essentially a UUID which we can to create a unique variable name\nfor our Dog class:\n\n    \n    \n    const dogMarker: unique symbol = Symbol('Dog');\n    \n    \n    class Dog extends Animal { readonly [dogMarker]: undefined = undefined; // Unleashing the power of symbols! override name(): string { return 'Lassie' } }\n\nVoil\u00e0! By transforming the 'chewsShoes' field name into a symbol, we cloak it\nin mystery, hidden from any Cat implementations. Problem solved, just like\nthat! (As long as we keep that dogMarker variable private!)\n\n## Quick, hide!\n\nAnother twist in the tail (pun intended)! When we thought we had our solution\ntucked neatly away, along comes the issue of visibility during enumeration and\nin the toString() output. Not ideal, especially when we're aiming to keep this\nimplementation detail under wraps.\n\n    \n    \n    Object.keys(new Dog()) // ['<a-uuid-value-here>']\n\nBut fear not, for we've got a nifty trick up our sleeve! Let's disable\nenumeration for this field, ensuring it remains hidden from prying eyes. And\nwhy stop there? Let's go the extra mile and make it readonly and un-deletable\ntoo, just to really drive the point home!\n\nWith these safeguards in place, our field remains concealed to all except\nthose privy to its secrets.\n\n    \n    \n    class Dog extends Animal { readonly [dogMarker]: undefined = undefined; constructor() { super() Object.defineProperty(this, dogMarker, { enumerable: false, writable: false, configurable: false}) } override name(): string { return 'Lassie' } }\n\n## Generics, the magician's wand of coding!\n\nBut wait, there's more! What about generics, you ask? Most applications deal\nwith more than Dogs and Cats!\n\nLet's construct a marker interface mirroring the structure of the Dog class,\nencapsulated within an interface to facilitate reusability.\n\n    \n    \n    const marker: unique symbol = Symbol('my unique string here'); interface Marker { readonly [marker]: undefined }\n\nWe're taking a leaf out of our Dog class's playbook and applying the same\nstrategy to an interface. Just like how our Dog class boasts a 'dogMarker'\nfield to distinguish itself, our interface will wield a similar marker to\nassert its uniqueness.\n\nBy mandating our generic type to implement the 'Marker' interface, we're\nforcing our types to implement a unique marker to identify them. With\ngenerics, we ensure whatever type is passed to SoundOf must implement our\nMarker interface. The Marker interface must have the unique marker field to\ndistinguish it from other types, allowing Typescript to tell types apart. \ud83d\udd0d\n\n    \n    \n    type SoundOf<T> = T extends Marker ? 'Bark' : 'Meow';\n\nThanks to our 'SoundOf' type using generics with our Marker interface, we're\nnot confined solely to Dogs and Cats; we can accommodate any type seamlessly.\n\n## Dogs++\n\nLet's expand our repertoire with some dog breeds, all of which are destined to\n'Bark'! \ud83d\udc3e\ud83d\udc15\n\nWe'll implement the Marker interface to enforce this behaviour.\n\n    \n    \n    class Labrador extends Animal implements Marker { readonly [marker]: undefined = undefined; // ... } class Poodle extends Animal implements Marker { readonly [marker]: undefined = undefined; // ... } // etc...\n\nAnd just to be fair, let's introduce some more breeds of Cats too.\n\n    \n    \n    class Tabby extends Animal { // ... } class Ragdoll extends Animal { // ... } // etc...\n\nAnd drawing it all together, we get:\n\n    \n    \n    type LabradorSound = SoundOf<typeof dog>; // Inferred as 'Bark' type PoodleSound = SoundOf<typeof dog>; // Inferred as 'Bark' type TabbySound = SoundOf<typeof cat>; // Inferred as 'Meow' type RagdollSound = SoundOf<typeof cat>; // Inferred as 'Meow'\n\nI'm sure you're thinking: \"Great, but didn't we just discern the types by\nadding a field again?\". While it may seem like we've circled back to\ndistinguishing types through fields, the key difference lies in consistency\nand abstraction.\n\nBy crafting an interface to define how types are distinguished, we've\nabstracted away the concrete implementation details. This means our mapped\ntype doesn't need to know the specifics of each Cat or Dog. It can work its\nmagic on any type that adheres to our marker interface, making our solution\nincredibly flexible and versatile.\n\nMoreover, with classes capable of implementing multiple interfaces, the\npossibilities are endless! We can create a whole arsenal of marker interfaces\ntailored to different mapped-type scenarios, all without burdening our types\nwith unnecessary knowledge of concrete implementations! \ud83d\udee0\ufe0f\ud83c\udf32\ud83d\ude80\n\nAnd there you have it, folks! TypeScript mapped types demystified and\nconquered.\n\nPART 2: TypeScript Branding\n\n### Ready to ditch Google reCAPTCHA? Start for free today. No credit card\nrequired.\n\nGet started\n\n\ufe0f\ud83d\udd12 Private, Decentralized, Secure.\n\n#### Community\n\n  * Blog\n  * Documentation\n  * GitHub\n  * Twitter\n  * LinkedIn\n  * RSS Feed\n\n#### Company\n\n  * About\n  * Contact\n  * Jobs\n  * Privacy\n  * Cookie policy\n  * Terms\n\nBuilt with \u2665 by the team @ prosopo.io. Copyright \u00a9 2021-2024 | Prosopo\u00ae | ProcaptchaTM\n\n", "frontpage": false}
