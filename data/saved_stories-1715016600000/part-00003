{"aid": "40271797", "title": "Pair Your Compilers at the ABI Caf\u00e9", "url": "https://faultlore.com/blah/abi-puns/", "domain": "faultlore.com", "votes": 1, "user": "nrabulinski", "posted_at": "2024-05-06 06:35:04", "comments": 0, "source_title": "Faultlore", "source_text": "Pair Your Compilers At The ABI Caf\u00e9 - Faultlore\n\n#\n\nFaultlore\n\nFaultlore\n\nFaultlore\n\n# Pair Your Compilers At The ABI Caf\u00e9\n\nAria Beingessner\n\nMay 5th, 2024\n\n> Not sure if your compilers have matching ABIs? Then put them through the\n> ultimate compatibility crucible and pair them up on a shift at The ABI Caf\u00e9!\n> Find out if your one true pairing fastcalls for each other or are just\n> another slowburn disaster. (Maid outfits optional but recommended.)\n\nI\u2019m pretty sure I\u2019ve tried to write some version of this article like 5 times\nover several years, but finally I got the right motivation, and I need to get\nsome of this out of my head.\n\n# \u00a71 Last Time On FFI Bugs\n\nWhen last we left our heroine, she was sobbing uncontrollably about the\nabsolutely disastrous state of affairs that is FFI, and how the best we\u2019ve\ncome up with is \u201ceveryone pretends to be C, even though C has the worst and\nwobbliest ABIs of all time\u201d.\n\nIn that article I briefly discussed my own attempts at this, a tool called\n\u201cabi-checker\u201d which I\u2019ve since renamed to abi-cafe.\n\nTo recap, abi-cafe was created in a feverish mania as I became increasingly\nobsessed with the disaster that was C\u2019s technically-nonstandard-but-also-\nliterally-used-in-standards __int128. Like sure there\u2019s the whole intmax_t\ndebacle, but that\u2019s understandable. The truly unforgivable thing was that\nclang and gcc couldn\u2019t reliably pass __int128 between each other. This of\ncourse meant that if Rust\u2019s i128 wished to interoperate with them... it would\nalways be wrong, because there was no correct answer.\n\nActually I\u2019m telling this story a bit backward. Initially we definitely knew\nthat Rust and Clang disagreed in at least one case on at least platform.\nDiscussion of this issue was stalled out because people weren\u2019t sure of the\nscope and nature of the problem. Which cases were broken? Who was right or\nwrong and needed to be fixed? What needed to be fixed? Did __int128 FFI work\nright on any platforms?\n\nSo I made abi-cafe, which let me describe a function signature in the abstract\nand generate code for the caller and callee, in Rust or C, and compile and\nlink them together. Notably the generated code had both sides \u201creport\u201d the\nvalues they saw with callbacks, so the test harness could just run them and\ncompare what each side reported.\n\nI like this approach because it requires no actual knowledge of what the ABI\n\u201cshould\u201d be and gets you very concrete error reports.\n\nabi-cafe quickly helped me reproduce the __int128 issue between rustc and\nclang. I was also able to generate tons of different ways of passing it, so I\nquickly understood in what ways they diverged! Then on a lark I added support\nfor gcc, and tested gcc_calls_clang and clang_calls_gcc to establish a\nbaseline of \u201chere\u2019s it working\u201d and... it... didn\u2019t!? In fact all 3 compilers\ndisagreed on x64 Linux!\n\nThis work quickly resulted in two important and clear conclusions:\n\n  * Remember how I said __int128 was technically-nonstandard-but-also-literally-used-in-standards? Well those standards are the registers for Aarch64 (ARM64)! Specifically some low-level APIs for saving/restoring NEON (SIMD) registers are defined in terms of the __int128 type, and so absolutely everyone agrees on the ABI of that type. As such, I was able to mark __int128 FFI as safe/correct on that architecture!\n\n  * It was clear that the __int128 bug was rooted in LLVM, and that clang and rustc were inheriting the issue. Clang half-worked around it, while rustc just did whatever LLVM said. As a result, everyone disagreed! I am pleased to report that after much hand-wringing the issue has been resolved in LLVM, and that the latest rustc and clang releases interoperate with each other and gcc perfectly! I highly recommend the excellent article about this on Rust\u2019s blog.\n\nCongrats to everyone who worked on this, you\u2019re the real MVPs!!!\n\n# \u00a72 The Limits of abi-cafe 1.0\n\nIn the intervening time, abi-cafe was also used by the developers of rustc\u2019s\ncranelift codegen backend to find at least one bug, which was super cool!\n\nThey suggested some more features it could have for checking more ABIs and I\nwas in absolute agreement, but also at a bit of a loss for how to do them.\n\nIf you dig into the current main branch of abi-cafe you will see... A Big\nFucking Mess. I had a specific problem to solve, and I wanted to fuck around\nwith some ideas I had, and well, the whole thing was stuck in a bit of a local\noptima.\n\nMost fundamentally, there were limits to the format for specifying a test that\nprevented enums, unions, and more complex type puns from being expressed.\n\nAs a result I\u2019ve been at vaguely toying with the idea of abi-cafe 2.0 for\nquite a while, occasionally working through the theory and implementation of\nit, but needless to say it was all a bit exhausting and overwhelming,\nespecially without the original motivation driving it forward.\n\nBut! My most recent burst of motivation has finally borne fruit, and I\u2019ve\nfinally gotten the full pipeline just barely working enough to compile and\ntest rustc against itself with actual tagged unions! At this point I just need\nto fill in the C implementation and polish up some TODOs, although one of\nthose TODOs in particular weighs heavily on my mind, and is the reason I wrote\nthis article.\n\nOr rather I was trying to explain the problem and solution I think I\u2019ve worked\nout for the TODO, but, it\u2019s so deep in the weeds that I accidentally wrote\nthis entire article while trying to do so.\n\nSo... buckle up, we\u2019ve got a lot of context to give!\n\nAnd also keep in mind everything about abi-cafe 2.0 is EXTREMELY work-in-\nprogress, and I only just barely got it kinda working, so, there\u2019s still a\nfair bit of work to do!\n\n# \u00a73 Why is abi-cafe\n\nOk so if the previous sections didn\u2019t make it clear enough, I\u2019ll just say it\noutright: ABIs are fucking Fake. Like, yes, they\u2019re real. Lots of very\nimportant things rely on them. But they\u2019re overwhelmingly unspecified and\ndoomed to be \u201cwhatever the fuck some random compiler does\u201d. People are\nconstantly reverse-engineering them, often buggily. Other people get very mad\nyou\u2019re relying on them, often fruitlessly.\n\nThere are some specs, but they often don\u2019t match the implementation, or are\ntoo vague to actually use. Also most importantly, the specs are often\nlanguage-specific. This is fine and all for gcc and clang trying to\ninteroperate, but Swift and Rust don\u2019t have a type called \u201clong long\u201d and they\nsomehow \u201cdo\u201d C ABIs, so there\u2019s absolutely Shenanigans happening even with\nwell-regarded compilers. Cross-language FFI is definitionally all type puns,\nbecause the two languages don\u2019t even have the same type systems or semantics!\n\nWhen you explain this situation to people, they often get really upset, and\ninvariably suggest that there should be some sort of abstract DSL for\nspecifying ABIs, so that all the compilers can share and interoperate and\neverything will be great.\n\nListen, if this is you: Do it. It sounds impossible but I would love to have\nit. ABIs are so complicated and so variable and the inputs and outputs sound\nhellish but anything would be better than what we have now.\n\nSo anyway I\u2019m a coward and abi-cafe is specifically not that. It has\nabsolutely no idea how any ABI is implemented. It believes in the Existence of\nABIs, and knows how to make things that Might survive a crossing through the\nblind eternities of a function call, and it knows how to check that the trip\nwas a success.\n\nSo if you do ever write that ABI DSL, abi-cafe will pair wonderfully with it\nas a way to test that a compiler that uses it continues to produce the same\nresults (or better).\n\n# \u00a74 What Does It Mean For Compilers To Agree?\n\nEarlier I mentioned that abi-cafe works by having both sides \u201creport\u201d the\nvalues they saw with callbacks. But what does that mean, and how do we\ndetermine that the values are \u201cright\u201d?\n\nTo investigate this question, we\u2019re going to look at a bunch of examples of\ncode/types we want to have interoperate between Rust and C(++), with little\nsplit code sections like this:\n\ni\n\n    \n    \n    some_rust | some_c some_more_rust | some_more_c\n\n## \u00a74.1 The Base Case: Primitives\n\nPrimitives like integers and floats are the indivisible atoms of a language.\nLet\u2019s start with a type pun so boring, many would balk at the suggestion that\nit even is one:\n\ni\n\n    \n    \n    u32 | uint32_t\n\nI think we can all agree that these have to work or nothing will. That said,\nthere\u2019s a ton of things to get right, as discussed in a previous article on\nABIs. Things can definitely go wrong here, as we saw with the whole __int128\ndebacle!\n\nCurrently abi-cafe asks both languages to copy a primitive\u2019s bytes into a\nbuffer to prove they knows its value. If both sides agree, well, clearly the\nvalue was passed properly! This is a pretty good heuristic for the platforms\nand languages I care about, because finding a primitive\u2019s location (and size)\nin memory is basically the only challenge.\n\nSo for instance, if we were interested in checking i32 interop we\u2019d generate\ncode like this, with Rust being the \u201ccaller\u201d that produces the values and C\nbeing the \u201ccallee\u201d that receives them. We then use some API for reporting\nvalues (sending their bytes to the test harness). For the purposes of the\narticle, we\u2019ll call that API write_val:\n\ni\n\n    \n    \n    fn run_tests() { | void test1(int32_t x, int32_t y) { let x: i32 = 0x0403_0201; | write_val(&x); write_val(&x); | write_val(&y); | } let y: i32 = 0x1413_1211; | write_val(&y); | | test1(x, y); | } |\n\nIf the harness sees both sides reported two values, and the bytes of each\nvalue are the same on both sides, then we\u2019re pretty confident the two i32s\nwere passed properly here! Generate a lot more cases to stress all the weird\ncorners or register allocation and alignment and suddenly you\u2019re pretty\nconfident the two languages interoperate completely.\n\n\u26a0\ufe0f Something subtle but important here is that we\u2019re relying on both sides\nagreeing on the order to report the values in. We can guarantee this in abi-\ncafe because we\u2019re generating both sides from an abstract definition. In fact\nthe test harness can theoretically know exactly what the write_val results\nshould be before even running the test (although this requires\nassuming/knowing ABI details and we want to avoid that). This will become a\nharder problem with more subtle implications as we go on.\n\n### \u00a74.1.1 An Aside: Picking Values For Primitives\n\nYou may have noticed I picked kind of weird example values there: 0x0403_0201\nand 0x1413_1211. I call these \u201cgraffiti values\u201d because each byte has been\ntagged with metadata of where it\u2019s supposed to be. If we break up each value\ninto its bytes, we get a nice little sequence:\n\n    \n    \n    x = [04, 03, 02, 01] y = [14, 13, 12, 11]\n\nThe idea here is that the high nibble of the byte is tagged with the index of\nthe value (x = 0, y = 1), and the low nibble is indexed with the tag of the\nbyte. The are several benefits to this system!\n\nFirst off, basically every byte is unique up to multiples of 16, so it\u2019s hard\nto \u201cget lucky\u201d when there\u2019s an ABI error, as opposed to if there was lots of\n0x0000 or 0xFFFF. I initially was providing \u201cdistinct\u201d values manually and I\nquickly determined that no we should just let the computer do that.\n\nSecond, when there is an error, it\u2019s often relatively easy to see what went\nwrong. For instance, let\u2019s say the test harness reports and error and shows us\nthe following:\n\n    \n    \n    gcc_calls_rustc mismatch on test1 arg1: gcc: [13, 12, 11, 10] rustc: [11, 10, 24, 23]\n\nThe gcc value looks normal: all the high nibbles are equal, and they appear in\nthe order your expect. The rustc value is definitely messed up though: we can\nsee that half of its bytes are from arg1, but the other half are from arg2!\nAlso we didn\u2019t get an error on arg0. Together these facts point to rustc\nexpecting the value to be more aligned (and therefore padded).\n\nWe don\u2019t know which compiler is right here, but we know they disagree, and can\nnow do the social work that is getting people to agree on the ABI (or just\nconcede that gcc is the boss and change rustc to match).\n\n### \u00a74.1.2 An Aside: Primitive Semantic Checking\n\nThe above implementation is technically missing an opportunity to check that\nthe languages agree on the semantics of the values. Even if they find the same\nbytes they could theoretically diverge on things like signedness, endianess,\ntwos complement, which values of bool are \u201ctrue\u201d vs \u201cfalse\u201d, and so on.\n\nI haven\u2019t implemented this and I\u2019m not sure I ever will, but one way to\napproach this would be to introduce a challenge-response protocol to the\nprocess. For instance, if you have one side add a number to the value, and\nrequire the other side to subtract it back out, then you\u2019re pretty confident\nthey agree on at least endianess (and I\u2019m sure you could come up with\nchallenges for any other properties you care about):\n\ni\n\n    \n    \n    fn run_tests() { | void test1(int32_t x, int32_t y) { let mut x: i32 = 0x0403_0201; | x -= 0x1234_5678; write_val(&x); | write_val(&x); x += 0x1234_5678; | | y -= 0xABCD_EF12; let mut y: i32 = 0x1413_1211; | write_val(&y); write_val(&y); | } y += 0xABCD_EF12; | | test1(x, y); | } |\n\n## \u00a74.2 The Inductive Case: Composite Types\n\nStructs like this require us to think a little bit harder about what it means\nfor two languages to agree on values:\n\ni\n\n    \n    \n    #[repr(C)] | struct Simple { struct Simple { | uint8_t flags; flags: u8; | uint32_t val; val: u32; | }; } |\n\nWe can\u2019t just copy the bytes of the entire structs, because they\u2019re liable to\ncontain padding which is allowed to differ between the two sides of the\nboundary. The only parts we can and should care about are the primitive fields\nthat form the \u201cleaves\u201d of a (potentially nested) composite type.\n\nWe already know how to analyze those, so the only thing we need to introduce\nhere is an understanding of how to access each subfield, and a new kind of\ndelimiter for \u201cend of function argument\u201d for easier bookkeeping and error\nreporting. So we add an end_arg() callback and generate this kind of code:\n\ni\n\n    \n    \n    fn run_tests() { | void test1(Simple x, Simple y) { let x = Simple { | write_val(&x.flags); flags: true, | write_val(&x.val); val: 0x1413_1211, | end_arg(); }; | write_val(&x.flags); | write_val(&y.flags); write_val(&x.val); | write_val(&y.val); end_arg(); | end_arg(); | } let y = Simple { | flags: false, | val: 0x3433_3231, | }; | write_val(&x.flags); | write_val(&x.flags); | end_arg(); | | test1(x, y); | } |\n\n\u26a0\ufe0f Once again we find ourselves relying on ordering, but once again this is\nfine because the test harness that generates the code gets to pick a\n\u201ccanonical\u201d ordering, and both sides agree on the number of primitive fields\nto report. There are two ways of looking at what we\u2019re doing:\n\n  * We\u2019re essentially generating a fully inlined implementation of #[derive(Debug)] for each function argument, and then checking that both sides produced the same printout. Just visiting every field, how hard could that be?\n\n  * We\u2019re generating an in-order tree traversal of the primitives in a composite type.\n\nWhat tree am I talking about? Well, look at this:\n\n    \n    \n    arg0: MyType { some_val: MyInnerType { count: u32, down: u64, engaged: bool, } some_other_vals: MyArray( [Vec3 { x: f32, y: f32, }; 2] ) }\n\nThat right there is a damn tree, as demonstrated through hasty paint diagrams:\n\nConsider this some Really Fucking Important Foreshadowing.\n\n## \u00a74.3 Tagged Unions: I Guess Alright?\n\nIt\u2019s time for me to bring up my favourite Rust RFC: 2195-really-tagged-unions,\nwherein I let you put repr(C) and repr(u8) on Rust tagged unions to get a\nguaranteed C(++)-compatible layout. Here we show the more pleasant C++ layout:\n\ni\n\n    \n    \n    #[repr(u8)] | enum class TaggedUnion_Tag: uint8_t { enum TaggedUnion { | Val1, Val2, Val3, Empty1, Empty2 Val1(u32), | }; Val2(u32), | Val3(u32, bool) | union TaggedUnion { Empty1, | struct { Empty2, | TaggedUnion_Tag tag; } | uint32_t val0; | } Val1; | struct { | TaggedUnion_Tag tag; | uint32_t val0; | } Val2; | struct { | TaggedUnion_Tag tag; | uint32_t val0; | bool val1; | } Val3; | struct { | TaggedUnion_Tag tag; | } Empty1; | struct { | TaggedUnion_Tag tag; | } Empty2; | };\n\nThis is absolutely a real thing, and cbindgen knows how to generate it, and\nFireFox uses it in production (I don\u2019t think I can stable-link that file\u2019s\ncontents, search for \u201cunion RasterSpace\u201d).\n\nThis case poses a few problems.\n\nThe first problem is a totally artificial limitation of abi-cafe 1.0: because\nI opted for describing function signatures with example values, any type with\ncases that won\u2019t show up in every value is fundamentally inexpressible. If I\ngive the value TaggedUnion::Val1(u32(100)), that fundamentally fails to\ndescribe Val2 and Empty. This limitation is the crux of why abi-cafe 2.0 had\nto be basically a complete rewrite. I need a proper type system to describe\nthe shape of a type independently from its values!\n\nThe second problem is that \u201cselecting\u201d a value is now a much more dramatic\nproblem. Before the only decision worth making was what number to put in an\ninteger. Now we need to pick which case is \u201cinteresting\u201d, and that can change\nthe number and types of fields to report. But that\u2019s ok, because both sides\nwill agree! You can totally #[derive(Debug)] on a Rust tagged union, so we\nknow we can report the fields of each case properly with a bit of elbow\ngrease.\n\nThe last problem is that \u201creporting\u201d all the values is suddenly less well\ndefined. Previously we hand-waived the matter of \u201csemantics\u201d and said that if\nboth sides agree on the primitives, we\u2019re all good. But here Val1 and Val2 are\nindistinguishable by that metric. Empty1 and Empty2 are even worse, with no\nvalues to report at all!\n\nIn this case we kind of get lucky, because the C-compatible layout forces the\nvalue of the tag to become defined as a u8, so we can introduce that as a\n\u201cfield\u201d that needs to be reported whenever you report a tagged union\u2019s values.\nIf we were testing Rust\u2019s own ABI we would have to make up a numbering system\nfor the tags.\n\nNone of this is a dealbreaker, but it\u2019s certainly a lot more annoying work.\nProbably we end up with something like:\n\ni\n\n    \n    \n    fn run_tests() { let x = TaggedUnion::Val3(16, true); match &x { TaggedUnion::Val1(val0) => { write_val(0u8); write_val(val0); } TaggedUnion::Val2(val0) => { write_val(1u8); write_val(val0); } TaggedUnion::Val3(val0, val1) => { write_val(2u8); write_val(val0); write_val(val1); } TaggedUnion::Empty1 => { write_val(3u8); } TaggedUnion::Empty2 => { write_val(4u8); } } end_arg(); test1(x); }\n\n## \u00a74.4 Untagged Unions: FUCK OK\n\nHey we just did tagged unions so c-like untagged unions are probably the same\nand... well. They\u2019re not! All of our foreshadowing has come to roost! Let\u2019s\nreview:\n\n> We\u2019re essentially generating a fully inlined implementation of\n> #[derive(Debug)] for each function argument.\n\n> You can totally #[derive(Debug)] on a Rust tagged union, so we know we can\n> report the fields of each case properly with a bit of elbow grease.\n\nYou know what you can\u2019t #[derive(Debug)] on? A c-like untagged union. Just\nabsolutely not, no way. There\u2019s no way for the receiver of the value to know\nwhich case you should be in, and trying to report all the cases would generate\nrandom padding-like garbage.\n\nBut we\u2019re not doomed! We can cheat with more foreshadowing!\n\n> In fact the test harness can theoretically know exactly what the write_val\n> results should be before even running the test (although this requires\n> assuming/knowing ABI details and we want to avoid that). This will become a\n> harder problem with more subtle implications as we go on.\n\nThe subtle implications, they are here! We don\u2019t need to generate proper match\nstatements for untagged unions, because the test harness generating the code\nalready knows which case every single value is. So for tagged unions, instead\nof actually generating a full match it could generate this:\n\n    \n    \n    // I am a smart test harness that knows what case it will be let TaggedUnion::Val1(val0) = &arg0 else { panic!(\"arg0 was supposed to be Val1, but wasn't!\"); } write_val(0u8); write_val(val0);\n\nWhich for an untagged union becomes this even simpler expression:\n\n    \n    \n    // I am a smart test harness that knows what case it will be write_val(&arg0.Val1.0);\n\nOk so we\u2019re still trucking, but now we definitely need a central system that\nknows the values of everything, and can\u2019t just pick them on the fly when\ngenerating the caller. How to express this in code is a bit brain-melty, but\nwe can appeal to our last bit of foreshadowing:\n\n> We\u2019re generating an in-order tree traversal of the primitives in a\n> composite.\n\nWe\u2019re still doing this but at some of the nodes we have to pick only one of\nthe branches to take (the enum variant to select). There\u2019s lots of ways to\nencode tree-traversals, like numbering the branches of each node, and creating\na sequence of the branches to follow. I\u2019m sure we can figure something out.\n\n## \u00a74.5 REAL PUNS: REAL PAIN\n\nNow to really fuck my whole life up with overly ambitious ideas. It\u2019s time for\nforeshadowing part two: fuck your life for real!\n\n> Now we need to pick which case is \u201cinteresting\u201d, and that can change the\n> number and types of fields to report. But that\u2019s ok, because both sides will\n> agree!\n\n> There\u2019s lots of ways to encode tree-traversals, like numbering the branches\n> of each node, and creating a sequence of the branches to follow. I\u2019m sure we\n> can figure something out.\n\nWHAT IF THE TWO LANGUAGES DIDN\u2019T AGREE ON THE NUMBER AND STRUCTURE OF THE\nFIELDS?\n\nLet\u2019s start off really simple, and work our way up to the real warcrimes.\n\n### \u00a74.5.1 Transparent Primitives: Ok!\n\nA cute little feature of Rust is repr(transparent), which lets you wrap\nprimitive types in a new type so you can get stronger type checking on \u201cthese\nare the array indices for this specific kind of data structure\u201d or \u201cthese are\nmeters\u201d, but critically you can keep them 100% abi-compatible with a bare\nprimitive:\n\ni\n\n    \n    \n    #[repr(transparent)] | #define Meters uint32_t struct Meters(u32); |\n\nFor example, 32-bit x86 Linux has a C ABI where a primitive and a struct\nwrapping a primitive get passed differently, so this attribute is significant,\nand we definitely want to test that it works right!\n\nBut suddenly we have introduced a non-trivial divergence in the structure of\nour types. In Rust there is an extra layer of composite to peel away, while in\nC the primitive is right there.\n\nIn our nice naive world of \u201cjust report the primitives in order\u201d this is\nactually totally fine, we don\u2019t care about how many composites are in the way.\nBut...\n\n> There\u2019s lots of ways to encode tree-traversals, like numbering the branches\n> of each node, and creating a sequence of the branches to follow. I\u2019m sure we\n> can figure something out.\n\nThis is now a bit harder to think about, eh? One of the trees has an extra\nnode in it. Thankfully it has to be a node with one child, so you can imagine\na few ways to handle this automatically, but the cracks are really starting to\nform!\n\n### \u00a74.5.2 Option Optimization: Uhhh\n\nHere\u2019s another fan favourite: the guaranteed Optional reference optimization\nin Rust:\n\ni\n\n    \n    \n    enum Option<T> { | uint64_t* Some(T) | None, | } | | Option::<&u64> |\n\nNot only is Option<&T> guaranteed to be the same size and layout as a pointer,\nbut it\u2019s even guaranteed that None will be null, and that it will be ABI\ncompatible with C pointers. Also note: this enum doesn\u2019t have a repr\nannotation on it, this is a for reals native Rust enum layout.\n\nIn the Some case things are easy enough, but in the None case... what are we\nsupposed to do? I\u2019m not sure how to handle this other than absolutely special-\ncasing the fuck out of it! Alas!\n\n### \u00a74.5.3 CRIMES CRIMES CRIMES\n\nLook I know I just finished explaining repr(transparent) and also how __int128\nis a nightmare buuuut maybe you think you can get away with this hot garbage:\n\ni\n\n    \n    \n    #[repr(C)] struct SyntheticU128 { | __uint128 high: u64, | low: u64, | } |\n\nSure would be nice to be able to test on which platforms and in which\nsituations that kind of thing would work, but oh god now the \u201ctrees\u201d we want\nconsistent traversals for are becoming an absolute mess.\n\nHey you know what, why not fuck me up with this:\n\ni\n\n    \n    \n    #[repr(C)] | struct AltPair { struct Pair { | uint32_t y; x: u32, | uint32_t z; y: u32, | }; } | | struct AltTriple { #[repr(C)] | uint32_t x; struct Triple { | AltPair pair; pair: Pair, | }; z: u32, | } |\n\nOr this:\n\ni\n\n    \n    \n    struct Vec3 { | struct Vec3 { x: f32, | float vals[3]; y: f32, | }; z: f32, | } |\n\nI wanna be able to test all these!!!\n\nTrying to build a system that can properly synchronize all these different\ntype puns into a single coherent \u201ctraversal\u201d where the values can be properly\ncompares is the big \u201cTODO\u201d that got me to write this article.\n\nThere is a certain intuition to how you can synchronize the trees properly,\nand boy howdy this article was supposed to elucidate that intuition, but it\u2019s\nso long and I\u2019ve absolutely fried my brain writing this much, so I think I\u2019m\ngonna just mention where I\u2019m at and wrap it up for now.\n\n# \u00a75 The Heart Of abi-cafe 2.0: kdl-script\n\nOk so abi-cafe 1.0 fell over by the time we got to tagged unions, because we\nneeded a way to talk about the structure of types in a way that single values\ncouldn\u2019t. The code for ABI backends (generating Rust and C code) for the\ndefinitions was also already an unmaintainable mess, so I wanted to have more\nof an agnostic framework that handles a lot of the details, so that the\nbackends could focus on just the specifics of their languages.\n\nThis is a type system and a compiler. I\u2019m describing a normal compiler. I fear\nand loathe normal compilers, even though I keep making and working on them.\n\nOne of the biggest hurdles for me was good parsing and error handling. We all\nknow the old gag: you take a compilers course in university, and they spend\n90% of the course talking about LR(1) grammars and then frantically at the end\ngo \u201cuhh oh and you should make the compiler actually do things\u201d. Except also\neverything they teach you about parsers is bad and wrong too.\n\nThen I got shown KDL, whose canonical implementation is written in Rust and\nwhich looks a lot like Rust code:\n\n    \n    \n    package { name \"my-pkg\" version \"1.2.3\" dependencies { // Nodes can have standalone values as well as // key/value pairs. lodash \"^3.2.1\" optional=true alias=\"underscore\" } numbers { x 123 y 456 } }\n\nWouldn\u2019t it be funny if I made a programming language where every program was\na valid KDL document? And thus kdl-script was born!\n\n    \n    \n    @derive \"Display\" struct \"Point\" { x \"f64\" y \"f64\" } fn \"main\" { outputs { _ \"f64\"; } let \"pt1\" \"Point\" { x 1.0 y 2.0 } let \"pt2\" \"Point\" { x 10.0 y 20.0 } let \"sum\" \"add:\" \"pt1\" \"pt2\" print \"sum\" return \"+:\" \"sum.x\" \"sum.y\" } fn \"add\" { inputs { a \"Point\"; b \"Point\"; } outputs { _ \"Point\"; } return \"Point\" { x \"+:\" \"a.x\" \"b.x\" y \"+:\" \"a.y\" \"b.y\" } }\n\nWell, ok that\u2019s the shitpost version with actual function bodies. kdl-script\nfor its true purpose ends up looking more like this:\n\n    \n    \n    // Types struct \"Simple\" { a \"i32\" } alias \"Simple2\" \"Simple\" struct \"Complex\" { elems \"[Simple;10]\" val \"Simple2\" opaque \"ptr\" flag \"bool\" } enum \"ErrorCode\" { Ok 0 FileNotFound 1 Bad -3 } tagged \"MyResult\" { Ok { _ \"[u32;3]\"; } Err { _ \"ErrorCode\"; } } tagged \"MyDeepResult\" { Ok { _ \"MyResult\"; } FileNotFound { x \"bool\"; y \"Simple\"; } } // Function signatures we want to test fn \"func1\" { inputs { a \"Complex\"; b \"Simple\"; } outputs { out \"i32\"; } } fn \"enumtime\" { inputs { a \"&MyResult\" b \"MyDeepResult\" c \"[&ErrorCode;4]\" } }\n\nIt\u2019s all signatures, no bodies. Because at the end of the day, generating the\nbodies is the problem of abi-cafe\u2019s ABI backends. And I\u2019m happy to report, the\nkdl-script compiler works, and I\u2019ve got the rust backend fully implemented!\n\n...except for maybe some overzealous outparam support that I don\u2019t really care\nabout anymore. Oh and the whole \u201ccomplex type pun tree traversal\u201d thing this\nwhole article is all about.\n\nOh right I haven\u2019t even shown the feature of kdl-script that makes complex\npuns a possibility: pun types!\n\n    \n    \n    pun \"MetersU32\" { lang \"rust\" { @ \"#[repr(transparent)]\" struct \"MetersU32\" { a \"u32\" } } lang \"c\" \"cpp\" { alias \"MetersU32\" \"u32\" } }\n\nkdl-script has a first-class notion of basically \u201ca type wrapped in an ifdef\nswitch statement\u201d. This allows us to declare a single function signature, but\nmake different languages/compilers interpret in different ways.\n\nI fucking love it, but it\u2019s an absolute nightmare to think about because IT\nMAKES THE TREES DIFFERENT SHAPES.\n\nBUT I SWEAR, YOU CAN MAKE IT MAKE SENSE.\n\nTRUST ME.\n\nOK I NEED. TO GO. TO BED. I HAVE BEEN WRITING THIS ALL DAY. HAVE A GOOD NIGHT.\n\n", "frontpage": false}
