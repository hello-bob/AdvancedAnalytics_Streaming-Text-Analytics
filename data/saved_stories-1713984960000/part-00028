{"aid": "40143181", "title": "So, You Want to Learn to Break Ciphers", "url": "https://littlemaninmyhead.wordpress.com/2015/09/28/so-you-want-to-learn-to-break-ciphers/", "domain": "littlemaninmyhead.wordpress.com", "votes": 1, "user": "luu", "posted_at": "2024-04-24 11:46:24", "comments": 0, "source_title": "So, You Want to Learn to Break Ciphers", "source_text": "So, You Want to Learn to Break Ciphers \u2013 Little Man In My Head\n\nSkip to content\n\n# Little Man In My Head\n\n## World Wide Web Security\n\n# So, You Want to Learn to Break Ciphers\n\nSeptember 28, 2015May 23, 2021 | crazycontini\n\nEvery now and then, I read a question about learning how to break ciphers, or\nmore generally how to become a cryptographer/cryptologist. From my viewpoint,\nthe most important part of learning this skill is not advanced mathematics,\nbut instead first learning how to think like a cryptographer. When you go to\nbreak a cipher, there are no instructions on how to do it. You simply need to\nget your hands dirty with the function under consideration and look for things\nthat do not seem desirable for a secure function of that type. While having a\nbag of tricks is going to help, ultimately it\u2019s your creativity, persistence,\nand skills that are more likely going to make the difference.\n\nI believe that there are a number of hackers out there that already know how\nto think the right way, and it is simply a matter of exercising that thought\nprocess on some reasonable, non-contrived examples to begin to understand what\nit takes to be a cryptologist. You should not need to know advanced\nmathematics or advanced cryptographic techniques (such as linear or\ndifferential cryptanalysis) to get started. So welcome to my blog post, which\nprovides a number of exercise for you to practice on. These examples mostly\ncome from cryptanalysis that I have done, largely because I know the results,\nI was able to dig them up, and attacking them did not use advanced techniques.\nI am building a list of other examples at the bottom of this blog, and invite\nother readers to add to it.\n\nBefore we begin, I want to point out some other resources on this topic:\n\n  * Schneier\u2019s Self-Study Course in Block Cipher Cryptanalysis is a great resource, but in my mind it is not the ideal place to start \u2014 from my viewpoint, it is the next step after you prove you can break ciphers such as what I have below. By the way, you absolutely should read Schneier\u2019s article So, You Want to be a Cryptographer.\n  * The Cryptopals Crypto Challenges. While they are similar in same spirit of what I am writing here, my focus is at a lower level \u2014 breaking specific cryptographic primitives rather than constructs from these primitives. Regardless, the Matasano challenges are another great place to start.\n  * The Simon Singh Cipher Challenges from his book, The Code Book. This book is really fun to read, and will get you into the spirit of breaking his challenges. But the first challenges are too easy and the last ones are very hard: it is really the middle ones that are most interesting.\n\nI\u2019m adding to existing resources because I thought I have a nice, small\ncollection of my own that I have accumulated over the years. Like the Matasano\nchallenges, my focus is on providing modern examples that are easy to break\nwithout complex mathematics or advanced cryptographic techniques. These\nexamples illustrate how to think like a cryptographer without requiring all\nthe complex background in the most advanced cryptanalytic techniques. If you\ncan solve these problems (and your solutions may not necessarily be the same\nas mine), then you have the right type of thinking to become a cryptographer.\nThis blog post is written for computer scientists without deep mathematics\nskills that want to learn how to do cryptanalysis, and teachers of\ncryptography for computer science students.\n\nThe examples come from different sources. For example, I have a few proposals\nby amateurs that were easily cracked, including a couple from the old\nsci.crypt Google group (it was a popular meeting place for crypto-geeks before\nGoogle took over). I have at least one proposal by an expert in some other\nfield that was attempting to apply his skills to cryptography despite having\nlittle background in crypto. I have one design that was built into software\nand relied upon for real-world security. And then I have one example of\nsomething that was not intended for cryptographic purposes yet sometimes is\nmisused by developers who do not understand that. So let\u2019s get started!\n\n# PHP\u2019s lcg_value( )\n\nPHP\u2019s lcg_value( ) is a pseudo random number generator (PRNG) that is not\nintended to provide cryptographic security. Nevertheless, it occasionally gets\nused in ways that it should not be used.\n\nThe internal state of the PRNG has a total possibility of 2^62 combinations,\nwhich is too much to brute force this day in age. However, one technique that\nis often employed in cryptanalysis is trying all possibilities for half of the\nbits (2^31 combinations here) and for each candidate, see if you can compute\nthe remaining bits in constant time. You then check whether the candidate is\nright by computing future outputs of the assumed internal state to to see\nwhether or not it matches. If it does, then you presume you have the right\nstate, and if it does not match, then you know the candidate is wrong.\n\nIt turns out that this technique does work for lcg_value( ), and thus it can\nbe cracked in 2^31 operations. The details are here (the page describes the\nalgorithm, how to attack it, and then provides a link to my solution). This\ncould take anywhere from a half-day to two days, depending upon your\nexperience. As a bonus, there is an advanced topic at the end of the link \u2014\nhow to crack lcg_value( ) if you only get a fraction of the output bits per\niteration: this is a bit harder.\n\n# Chaotic hash function\n\nEvery year there is the Crypto conference in Santa Barbara that has a light-\nhearted \u201crump session\u201d where participants can present research-in-progress or\nanything of interest to the cryptographic community. In the Crypto 2005 rump\nsession, a researcher presented his new hash function based upon chaos theory.\nThe researcher was unknown to the cryptographic community. He put up lots of\ngraphs of his hash function, which might have been intimidating to one with no\ncryptographic experience, but that was not most of the audience, and hence\nhardly anybody listened to his presentation. But I listened carefully, because\nI suspected an easy target that I wanted to have a go at.\n\nWhy did I suspect it an easy target? I knew absolutely zero about chaos\ntheory, and had no intention to learning it. But what I saw was a guy who did\nnot know anything about cryptography and how ciphers were attacked, and I was\npretty sure I could find collisions in his hash function regardless of any\ngraphs or mathematics behind his design. The only trick was getting an exact\nspecification so that I can demonstrate that I can break it. This obstacle is\noften encountered in cryptanalysis \u2014 non-experts do not nail down their\nspecification for whatever reason, but the cryptanalyst needs something\nconcrete to demonstrate his attack. So I exchanged email with him a few times\nand we finally agreed that the following C code represents his hash function\n(where ROTL and ROTR are circular left and right bit rotations):\n\n    \n    \n    void hash( unsigned int *input, int len, unsigned int output[4] ) { unsigned int x, y, z, u, X, Y, Z, U, A, B, C, D, RV1, RV2, RV3, RV4; unsigned int M = 0xffff; int i, offset; x = 0x0124fdce; y = 0x89ab57ea; z = 0xba89370a; u = 0xfedc45ef; A = 0x401ab257; B = 0xb7cd34e1; C = 0x76b3a27c; D = 0xf13c3adf; RV1 = 0xe12f23cd; RV2 = 0xc5ab6789; RV3 = 0xf1234567; RV4 = 0x9a8bc7ef; for (i=0; i < len; ++i) { offset = 4*i; X = input[offset + 0] ^ x; Y = input[offset + 1] ^ y; Z = input[offset + 2] ^ z; U = input[offset + 3] ^ u; /* compute chaos */ x = (X & 0xffff)*(M-(Y>>16)) ^ ROTL(Z,1) ^ ROTR(U,1) ^ A; y = (Y & 0xffff)*(M-(Z>>16)) ^ ROTL(U,2) ^ ROTR(X,2) ^ B; z = (Z & 0xffff)*(M-(U>>16)) ^ ROTL(X,3) ^ ROTR(Y,3) ^ C; u = (U & 0xffff)*(M-(X>>16)) ^ ROTL(Y,4) ^ ROTR(Z,4) ^ D; RV1 ^= x; RV2 ^= y; RV3 ^= z; RV4 ^= u; } /* now run 4 more times */ for (i=0; i < 4; ++i) { X = x; Y = y; Z = z; U = u; /* compute chaos */ x = (X & 0xffff)*(M-(Y>>16)) ^ ROTL(Z,1) ^ ROTR(U,1) ^ A; y = (Y & 0xffff)*(M-(Z>>16)) ^ ROTL(U,2) ^ ROTR(X,2) ^ B; z = (Z & 0xffff)*(M-(U>>16)) ^ ROTL(X,3) ^ ROTR(Y,3) ^ C; u = (U & 0xffff)*(M-(X>>16)) ^ ROTL(Y,4) ^ ROTR(Z,4) ^ D; RV1 ^= x; RV2 ^= y; RV3 ^= z; RV4 ^= u; } output[0] = RV1; output[1] = RV2; output[2] = RV3; output[3] = RV4; }\n\nDoes it look intimidating? Well, once you start to get your hands dirty, you\nwill see that it is not that bad at all. The loop at the bottom does not\ninvolve any inputs, so if we can create a collision in the top loop, then it\nwill give a collision in the hash. The top loop takes blocks of 4 input words\n(128-bits) per iteration and mixes them into the existing state. Here\u2019s the\nreal killer: for any iteration, the attacker can make (X, Y, Z, U) to be\nwhatever he wants because he can compute (x, y, z, u) at the beginning of that\niteration (simply by processing the previous inputs) and choose the next\ninputs accordingly. Now there is still some ugly multiply and rotation stuff\nin there, but given that you can control (X, Y, Z, U), you can then make those\nmultiplies and rotations behave in a convenient way for your attack. Suddenly,\nwhat seemed to be a ferocious looking lion is nothing more than a tiny kitty\ncat. Have a go yourself before you look at my attacks. This one was easy and\nreally fun to break.\n\nBy the way, after breaking this one, you should have decent insight into why\nalgorithms of the MD and SHA families have a pre-processing phase that\ninvolves the message length, and use a message expansion that makes sure that\nfunctions of the input words get mixed in multiple times per iteration.\n\n# Hash Function with \u201cTechnique in Overlapping Sums\u201d\n\nHere is another easy one from amateur on the good old sci.crypt group. The\nauthor forgot to both declare and initialise the hash variable, so I fix-up\nthe code below:\n\n    \n    \n    #define UL unsigned long #define LEFT 13 #define RIGHT 19 UL hash[5]; void round() { hash[4] += hash[0] >> RIGHT; hash[0] += hash[0] << LEFT; hash[0] += hash[1] >> RIGHT; hash[1] += hash[1] << LEFT; hash[1] += hash[2] >> RIGHT; hash[2] += hash[2] << LEFT; hash[2] += hash[3] >> RIGHT; hash[3] += hash[3] << LEFT; hash[3] += hash[4] >> RIGHT; hash[4] += hash[4] << LEFT; } void processBlock(const UL in[25]) { int i, j, r, s; memset( hash, 0, sizeof(hash) ); for (i = 0; i < 5; i++) { s = 0; for (r=0; r<5; r++) { for (j = 0; j < 5; j++) { hash[j] ^= in[j+s]; hash[j]++; } round(); s += 5; } } }\n\nIt seems to only be a compression function (processBlock( )) that takes a 25\nword input and produces a 5 word output. For the r\u2019th round, he is mixing in\ninputs from in[5*r], ... , in[5*r+4] into hash[0], ..., hash[4]; seemingly\nunaware that we could compute the state of hash at any point and choose our\nnext inputs accordingly (similar to the way we broke chaotic hash). This one\nfalls trivially, but for fun, I made my collisions to be preimages of the all\nzero output.\n\n# FastFlex\n\nWhen FastFlex was proposed in 2006, the author made bold claims on the\nsci.crypt newsgroup about it not being resistant to linear or differential\ncryptanalysis, and wondered if there might be any other issues that he needs\nto worry about. When somebody talks about these cryptanalysis techniques, you\nassume they know a little bit about cryptography, but it just goes to show:\nlearning the techniques without knowing how to think like a cryptographer is\nof little value. I took a look at the code the author had, and it had basic\nproblems such as not initialising variables. Within about a half hour, I found\ncollisions (it may seem like I am always sending in zero words for the\nfunctions I break, but I didn\u2019t need to for this one) in the hash function\nusing techniques similar to how I broke the chaotic hash function above, and\nsuch collisions could easily be produced regardless of how variables were\ninitialised. The amusing reply from the author acknowledged the problem but\nsomehow concluded that FastFlex is still safe!\n\nAfter my reply, the author modified his design and sent it for publication,\ncarefully making sure that the sci.crypt people didn\u2019t see his updated design\nin the time frame of the publication attempt. The author claims that the paper\nwas published (see bottom of page), but the updated paper made no\nacknowledgement of the insecurity of the previous version or my finding. The\nevidence for the security in the updated paper is pretty bad.\n\nUnfortunately, the original specification seems to be no longer around, so\nbreaking the new version remains open. But let\u2019s just say that how I broke it\nhad a lot of similarities to how I broke the chaotic hash function, so first\nprepare yourself accordingly, and then take out the new FastFlex! FastFlex is\ndesigned to build a number of cryptographic constructs from it. I recommend\nstarting with the hash functions, and after you break those, go after the\nrandom number generator. If you are like me, you\u2019ll start by going directly\nafter the implementation rather than trying to waste too much time trying to\nread the author\u2019s research paper.\n\nIf FastFlex was indeed published, then you should be able to get a publication\nout of breaking it provided that you write it up well. I\u2019d be most delighted\nto hear successful attacks on this one. Note to attackers: make sure you save\na copy of his code and pdf description after you break it so that the author\ncannot hide the history.\n\n# R.A.T.\n\nAmateurs are never shy to come up with their own cryptographic solutions, and\noften are generous enough to give them to the world unencumbered by patents.\nWhile their hearts are in the right place, it is just not that easy to build a\nsecure cryptosystem. At the bottom of this linked page, you can read about the\nR.A.T. encoding and decoding system.\n\nI\u2019m pretty sure there are numerous ways to attack this one (especially if you\nwant to use linear algebra, but I didn\u2019t), but my solution is in this link.\nDon\u2019t look at it until you found your own solution!\n\nBut here\u2019s two hints to start you out:\n\n  1. Always give yourself the advantage by starting out with a chosen plaintext attack (or chosen ciphertext attack), and then it can likely be converted into other types of attacks later.\n  2. It makes things easier if you write it out in terms of arrays (for A and B) so you can keep track of the relation between things from iteration to iteration.\n\nTo elaborate on point 2, the cipher would look something like this (where A,\nB, and X are byte arrays of the length of the input size, and key is a byte\narray of length 256 \u2014 how it was generated does not really matter in my\nattack):\n\n    \n    \n    initialise: A[0] = 0, B[0] = 128 for i = 1 to the number of plaintext bytes { Let X[i] = i'th plaintext byte A1 = X[i] ^ key[ B[i-1] ] B[i] = A1 ^ key[ A[i-1] ] output B[i] as the i'th byte of the ciphertext A[i] = A1 }\n\nMy break revealed bytes of the key when a certain condition happens, but I bet\nyou can generalise it to do better.\n\n# \u201cMultiswap\u201d\n\nIn 2001, \u201cBeale Screamer\u201d reverse engineered and broke Microsoft\u2019s Digital\nRights Scheme \u2014 see link. The scheme involved a cipher that he named\n\u201cmultiswap\u201d (described in the link), because it used multiplication and\nswapped halves of computer words around. Beale Screamer\u2019s break of the DRM\nscheme did not touch the cryptography, which made it a prime target for\ncryptographers.\n\nI immediately had a look at the cipher, and it didn\u2019t take me long before I\nfound a way to recover two words of the key (k[5] and k[11]) simply by\nchoosing my plaintexts in such a way that made the multiplies disappear (hint\nhint). I went to sleep thinking I will return to it the next day for attacking\nmore of the cipher. Unfortunately, my plans were preempted by a fast team of\nBerkley cryptographers who had the entire cipher broke by the next day \u2014 their\nsolution is here.\n\nUnsurprisingly, I started my attack the exact same way as the the Berkeley\nteam to recover two words of the key. You should be able to do the same thing.\nAfter that, they used differential cryptanalysis to get the rest. Since I\nassume that the reader is new to cryptography, I am not going to expect that\nhe/she derives the remaining parts of the key similar to the Berkeley team.\nHowever, there are various approaches one can play with in order to refine\ntheir cryptographic skills. For example, knowing the plaintext allows you to\ncompute s0\u2032 and s1\u2032 (from Berkeley description, which I believe is easier to\nwork from). Then, one can try to deduce k[0], ..., k[4] independently of k[6],\n... , k[10]. We could almost attempt the same technique that we used to break\nthe lcg_value( ) here, except that\u2019s still too many key bits to guess in a\npractical implementation. However, if you reduce the size of the cipher in\nhalf (half of the number of key words, half of the number of rounds), then\nsuch a technique should work. Give it a try!\n\nFinally, one of the cutest parts of the Berkeley attack was showing how to\nconvert the chosen plaintext attack into a known plaintext attack. As we said\nbefore, give yourself the best advantage to start out with, and then worry\nabout converting it to other forms of attacks later!\n\n# Other targets to play around with\n\nOver many years on sci.crypt, I saw a number of ciphers broken by members of\nthe group. I also occasionally see new ones that I think must be trivially\nbreakable. Nowadays, reddit seems to be the place to go. It is impossible for\nme to dig up all of the easily broken designs, but here are a few that I\nremember:\n\n  * The hash function Shahaha was proposed here, and broken the next day by Scott Fluhrer here. Can you come up with your own break? (Scott Fluhrer broke a number of amateur designs in the sci.crypt days, but this is the only one I found so far).\n  * Just as I was trying to dig up old sci.crypt examples of ciphers, somebody on reddit\u2019s crypto group posted an I designed my own crypto thread. This is a block cipher called XCRUSH. The full design is here. The author claims that it is purely an academic exercise and makes no security claims at all in the paper, so his motivation is entirely for learning. It\u2019s also written up nicely, which is an advantage if you want people to look at your design. Upon posting it on reddit, a character by the identity of bitwiseshiftleft found theoretical weaknesses quite soon (like in many of the examples above, the magic zero comes into play here again). See the comments in the reddit thread for more detail. There was also some interesting analysis based upon SAT solvers, but this is outside my expertise so I leave the reference for interested parties.\n  * This one might require a little bit of math, who knows how much (can\u2019t be sure \u2014 I have not tried attacking it yet). Here is a public key cryptosystem that seems too good to be true. However, the author made a pretty basic mistake in his analysis (first observed by rosulek): the author claims to have proven that you can break it by solving circuit satisfiability (SAT). Ummm, you can break every cryptosystem if you can solve SAT efficiently! What would have been more interesting was showing the contrapositive: (i.e. if you could break his cryptosystem, then you can solve SAT). The simple fact that the author did not know which direction to do the security reduction is indicative of his lack of experience, and hints that it can easily be broken.\n  * I was debating whether or not to include the first attacks on the original SecurId in the main list above, but ultimately I decided that it is too much detail. However if anybody wants to have a go, here is the code reverse-engineered from \u201cI.C. Wiener\u201d, here is the description of the function from Belgian cryptographers (My coauthor and I worked from the original version that they posted on eprint, which has since been updated), and here is the first attack I found. Read through section 1 of my attack, and then try to attack it with the following information in mind: the vanishing differentials (collisions) happen in the first 32-subrounds, so key search can be expedited by computing only part of the function rather than the full thing (so what fraction of the function do you need to compute in order to test for a collision?) But there is even more you can do here: only the first 32-bits of the key are involved in the first 32-subrounds, and many of these permutations on the data overlap, leading to more speedups. Two important notes: (1) although the term \u201cvanishing differential\u201d suggests differential cryptanalysis (not suitable for a beginner), the term really just means hash collision here, and (2) RSA has since discontinued that function and is now using something more standard in their design.\n\nIf you know of any other good ones (including a sample break), then please\nprovide the link and I will try to regularly update the list.\n\n### Share this:\n\n  * Twitter\n  * Facebook\n\nLike Loading...\n\n### Related\n\nA Curious Connection Between Cubing and CryptographyMarch 20, 2022In\n\"cryptography\"\n\nWhy I left cryptographyOctober 23, 2017Liked by 1 person\n\nTop 10 Developer Crypto MistakesApril 22, 2017Liked by 4 people\n\n## 14 thoughts on \u201cSo, You Want to Learn to Break Ciphers\u201d\n\n  1. Pingback: Cautionary note: UUIDs should generally not be used for authentication tokens |\n\n  2. Pingback: TECNOLOG\u00cdA \u00bb Cautionary note: UUIDs generally do not meet security requirements\n\n  3. Pingback: So, You Want to Learn to Break Ciphers \u2013 Evil Bits\n\n  4. Pingback: How I became a cryptographer\n\n  5. John NoNotReally says:\n\nMay 19, 2017 at 11:49 pm\n\nFYI, your first bolded statement has a grammatical error: \u201cThis blog post is\nwritten for and [missing \u201cby\u201d?] computer scientists without deep mathematics\nskills that want to learn how to do cryptanalysis, and teachers of\ncryptography for computer science students.\u201d\n\nThanks for the read!\n\nLikeLike\n\nReply\n\n  6. Oscar says:\n\nMay 20, 2017 at 1:20 am\n\n> If you know of any other good ones (including a sample break), then please\n> provide the link\n\n> But I listened carefully, because I suspected an easy target that I wanted\n> to have a go at.\n\nThis was my easy target.\n\nhttps://github.com/ed770878/HohhaDynamicXOR\n\nLikeLike\n\nReply\n\n  7. Pingback: So, You Want to Learn to Break Ciphers | ExtendTree\n\n  8. Foo says:\n\nMay 20, 2017 at 6:42 am\n\nHalf of 2^62 is not 2^31, it\u2019s 2^61.\n\nLikeLike\n\nReply\n\n    1. crazycontini says:\n\nMay 20, 2017 at 11:54 am\n\nCorrect. Not seeing where that matches up in the blog. In only place I talk\nabout \u201chalf of the bits\u201d, which is different than half of the complexity.\nPlease clarify where you believe there is a mistake. Thanks.\n\nLikeLiked by 1 person\n\nReply\n\n  9. Nivritatma says:\n\nMay 20, 2017 at 1:00 pm\n\nCan you tell how a mathematics student can learn cryptogrophy. Thank you.\n\nLikeLike\n\nReply\n\n    1. crazycontini says:\n\nMay 20, 2017 at 7:54 pm\n\nI would say first take a class on cryptography to find out what part of\ncryptography interests you. Once you know that, then you need to find where\nthere are Professors who do research in the area that interests you, and try\nto become a graduate student under them, That way you would get guidance on\nwhere the field is going and understand better the skills you need to develop\nto understand and potentially contribute to the field.\n\nThere are many online courses for cryptography, but if you are good at\nmathematics, then you might look at Dan Boneh\u2019s class:\nhttps://www.coursera.org/learn/crypto . I don\u2019t think he\u2019ll get into breaking\nsymmetric ciphers like I have done above (a computer science algorithmic\napproach), but he will instead focus more on mathematical properties of\nciphers, which will include application of mathematics to breaking ciphers.\n\nYou might also have a look at my recent blog on how I became a cryptographer:\nhttps://littlemaninmyhead.wordpress.com/2017/05/18/how-i-became-a-\ncryptographer/ and also Seny Kamara\u2019s blog on How Not to Learn Cyrptography\nhttp://outsourcedbits.org/2014/11/11/how-not-to-learn-cryptography/\n\nLikeLike\n\nReply\n\n  10. Pingback: Les liens de la semaine \u2013 \u00c9dition #235 | French Coding\n\n  11. Chops says:\n\nFebruary 13, 2021 at 10:33 pm\n\n\u201cmade bold claims on the sci.crypt newsgroup about it not being resistant to\nlinear or differential cryptanalysis\u201d\n\nBold claim indeed, to announce up front that your new cipher is vulnerable\n\nLikeLike\n\nReply\n\n  12. Pingback: A Curious Connection between Cubing and cryptography \u2013 Little Man In My Head\n\n### Leave a comment Cancel reply\n\n# Recent Posts\n\n  * A Curious Connection Between Cubing and Cryptography\n  * How I Avoided Management for 25 Years\n  * If you copied any of these popular StackOverflow encryption code snippets, then you coded it wrong\n  * Why We Shouldn\u2019t Commit Secrets into Source Code Repositories\n  * No, Java is not a Secure Programming Language\n\n# Recent Comments\n\nPeter on No, Java is not a Secure Progr...  \n---  \nRaj on Cautionary note: UUIDs general...  \nkira on A Review of PentesterLab  \n[SOLVED] For REST re... on Account Enumeration via Timing...  \nA Curious Connection... on So, You Want to Learn to Break...  \n  \n# Archives\n\n  * March 2022\n  * January 2022\n  * September 2021\n  * April 2021\n  * January 2021\n  * September 2020\n  * June 2020\n  * November 2019\n  * September 2019\n  * August 2019\n  * July 2019\n  * January 2019\n  * June 2018\n  * February 2018\n  * October 2017\n  * May 2017\n  * April 2017\n  * April 2016\n  * November 2015\n  * September 2015\n  * July 2015\n  * May 2015\n\n# Categories\n\n  * Uncategorized\n\n# Meta\n\n  * Register\n  * Log in\n  * Entries feed\n  * Comments feed\n  * WordPress.com\n\nStart a Blog at WordPress.com.\n\n  * Comment\n  * Reblog\n  * Subscribe Subscribed\n\n    * Little Man In My Head\n    * Already have a WordPress.com account? Log in now.\n\n  * Privacy\n  *     * Little Man In My Head\n    * Customize\n    * Subscribe Subscribed\n    * Sign up\n    * Log in\n    * Copy shortlink\n    * Report this content\n    * View post in Reader\n    * Manage subscriptions\n    * Collapse this bar\n\n%d\n\n", "frontpage": false}
