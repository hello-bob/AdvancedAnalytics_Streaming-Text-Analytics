{"aid": "40222541", "title": "Show HN: A Kotlin DSL for WebAssembly", "url": "https://github.com/kobjects/greenspun", "domain": "github.com/kobjects", "votes": 1, "user": "dukoid", "posted_at": "2024-05-01 13:00:06", "comments": 0, "source_title": "GitHub - kobjects/greenspun", "source_text": "GitHub - kobjects/greenspun\n\nSkip to content\n\n## Navigation Menu\n\nSign in\n\n# Search code, repositories, users, issues, pull requests...\n\nSearch syntax tips\n\nSign in\n\nSign up\n\nYou signed in with another tab or window. Reload to refresh your session. You\nsigned out in another tab or window. Reload to refresh your session. You\nswitched accounts on another tab or window. Reload to refresh your session.\nDismiss alert\n\nkobjects / greenspun Public\n\n  * Notifications\n  * Fork 0\n  * Star 0\n\n### License\n\nApache-2.0 license\n\n0 stars 0 forks Branches Tags Activity\n\nStar\n\nNotifications\n\n# kobjects/greenspun\n\nThis commit does not belong to any branch on this repository, and may belong\nto a fork outside of the repository.\n\n1 Branch\n\n0 Tags\n\n## Folders and files\n\nName| Name| Last commit message| Last commit date  \n---|---|---|---  \n  \n## Latest commit\n\nstefanhausteinhello world linkMay 1, 2024078637d \u00b7 May 1, 2024May 1, 2024\n\n## History\n\n125 Commits  \n  \n### core\n\n|\n\n### core\n\n| Keep calls in the interpreter| Apr 28, 2024  \n  \n### gradle\n\n|\n\n### gradle\n\n| build infra / gradle update| Apr 21, 2024  \n  \n### .gitignore\n\n|\n\n### .gitignore\n\n| gitignore expanded| Mar 29, 2024  \n  \n### LICENSE\n\n|\n\n### LICENSE\n\n| Create LICENSE| Feb 6, 2022  \n  \n### README.md\n\n|\n\n### README.md\n\n| hello world link| May 1, 2024  \n  \n### build.gradle.kts\n\n|\n\n### build.gradle.kts\n\n| build infra / gradle update| Apr 21, 2024  \n  \n### gradle.properties\n\n|\n\n### gradle.properties\n\n| build infra / gradle update| Apr 21, 2024  \n  \n### gradlew\n\n|\n\n### gradlew\n\n| build infra / gradle update| Apr 21, 2024  \n  \n### gradlew.bat\n\n|\n\n### gradlew.bat\n\n| build infra / gradle update| Apr 21, 2024  \n  \n### settings.gradle.kts\n\n|\n\n### settings.gradle.kts\n\n| build infra / gradle update| Apr 21, 2024  \n  \n## Repository files navigation\n\n# A Kotlin DSL for WebAssembly\n\n## But Why?\n\nThe initial motivation for this project was just to see how far one can take\nKotlin DSLs.\n\nThat said, it might be useful for situations where one needs to generate Wasm\ncode in a general Kotlin context.\n\nIn a way, this project constitutes a Wasm \"macro assembler\" with the Kotlin as\nthe \"macro language\" -- at the price of an \"unusual\" syntax.\n\n## \"Hello World\"\n\nTo run our \"Hello World\" example, start with checking out the project from\ngithub using the following command:\n\n    \n    \n    git clone https://github.com/kobjects/greenspun.git\n\nTo check that everything works as expected, run the \"HelloWorld\" demo using\nthe following command line:\n\n    \n    \n    ./gradlew jvmRun -DmainClass=org.kobjects.greenspun.demo.HelloWorldKt\n\nThe output should look as follows:\n\n    \n    \n    Instantiating module: Hello World HelloWorld wasm binary code: 0061736d01000000010c0260047f7f7f 7f017f60000002230116776173695f73 6e617073686f745f7072657669657731 0866645f777269746500000302010105 030100010801010c01020a0f010d0041 014100410c410c10001a0b0b1b020041 000b0c48656c6c6f20576f726c640a00 410c0b0431323334\n\n### Examining the Example\n\nTo play with the example, open the project in a Kotlin IDE, e.g. IntelliJ or\nAndroid Studio.\n\nThe \"Hello World\" example is located in\n\n    \n    \n    core/src/commonMain/kotlin/org/kobjects/greenspun/demo\n\nThe core of this example looks as follows:\n\n    \n    \n    val module = Module { val memory = Export(\"memory\", Memory(1)) // Leave some space for the fd_write data vector and return value val helloWorld = memory.data(16, \"Hello World\\n\") val fd_write = ImportFunc(\"wasi_snapshot_preview1\", \"fd_write\", I32) { Param(I32, I32, I32, I32) } val hello = Func { memory.i32[0] = helloWorld memory.i32[4] = helloWorld.len Drop(fd_write(1, 0, 1, 8)) } Start(hello) }\n\nHere, we first declare memory and then use the data method to declare some\npre-filled memory locations.\n\nNext, we import the fd_write-function form WASI in order to be able to write\nto stdout. Unfortunately, the funtion signature is a bit complex and takes\nfour I32 parameters: The file descriptor (1 for stdout), the address of a\nvector of data to write, the length of the vector and an address to store the\nnumbers of bytes written. The return value is an error code -- which is zero\nif there was no error.\n\nThen we declare our own hello function which setS up the data vector for\nfd_write and then calls it.\n\nFinally, we declare that hello is the \"start\" function of the module -- which\nmeans that it's automatically run on instantiation.\n\n### Running \"Hello World\" with the built-in Wasm Interpreter\n\nThe simplest way to run the example is to use the built-in interpreter:\n\n    \n    \n    val importObject = ImportObject() importObject.addStdIoImpl() module.instantiate(importObject)\n\nTo use our WASI stdout implementation, we first need to add it to the import\nobject. As our \"Hello World\" function is the \"start\" function of our module,\nit will run automatically when we instnantiate the module.\n\nTo run the example from the command line, use the following command in the\nproject root directory:\n\n### Getting the WASM binary code and running it elsewhere\n\nThe example used the following lines to print the binary wasm code:\n\n    \n    \n    0061736d01000000010c0260047f7f7f 7f017f60000002230116776173695f73 6e617073686f745f7072657669657731 0866645f777269746500000302010105 03010001070a01066d656d6f72790200 0801010c01010a1d011b004100411036 00004104410c36000041014100410141 0810001a0b0b12010041100b0c48656c 6c6f20576f726c640a\n\nThis can be converted to a binary file using a tool like tomeko.net's online\nhex to file converter.\n\nThe binary can then be run with wasmtime:\n\n    \n    \n    > wasmtime run hello.wasm Hello World\n\nWhen disassembling this code (e.g. using wasm2wat), we get the following\noutput in regulare Wasm text format:\n\n    \n    \n    (module (type $t0 (func (param i32 i32 i32 i32) (result i32))) (type $t1 (func)) (import \"wasi_snapshot_preview1\" \"fd_write\" (func $wasi_snapshot_preview1.fd_write (type $t0))) (func $f1 (type $t1) (i32.store align=1 (i32.const 0) (i32.const 0)) (i32.store align=1 (i32.const 4) (i32.const 12)) (drop (call $wasi_snapshot_preview1.fd_write (i32.const 1) (i32.const 0) (i32.const 1) (i32.const 12)))) (memory $memory (export \"memory\") 1) (start $f1) (data $d0 (i32.const 16) \"Hello World\\0a\"))\n\n## DSL Description\n\n### Modules\n\nModules are declared using the \"Module\" function. The DSL parameter contains\nthe declarations of all the sections. Example:\n\n    \n    \n    val module = Module { }\n\n### Functions\n\nFunctions are declared using the \"Func\" function inside a module, taking the\nreturn value type as a direct argument and the function body as a DSL\nparameter. Example:\n\n    \n    \n    val module = Module { val answer = Func(I32) { Return (42) } }\n\n#### Function Parameters\n\nFunction parameters are declared inside the \"body\" using the \"Param\" function.\nExample:\n\n    \n    \n    val sqr = Func(I32) { val x = Param(I32) Return (x * x) }\n\n#### Function Exports\n\nFunctions (and other constructs) can be exported using Export(). A full\nexample for a WebAssembly module exporting a function \"sqr\" for calculating\nthe square of 32 bit integers is:\n\n    \n    \n    val module = Module { Export(\"sqr\", Func(I32) { val x = Param(I32) Return (x * x) }) }\n\n#### Invocation from Kotlin\n\nThe exported sqr()-function can be invoked from Kotlin by instantiating the\nmodule and then invoking the exported function:\n\n    \n    \n    val instance = module.instantiate() val sqr4 = instance.invoke(\"sqr\", 4) println(\"The square of 4 is: $sqr4\")\n\n#### Local Variables\n\nLocal variables are declared similar to parameters using Var() or Const().\nInstead of the type argument, they take an expression defining the initial\nvalue.\n\nImmutable local variables are not supported by Wasm directly -- the mutability\nproperty is checked by the DSL only.\n\nMutable local variables can be assigned new values by calling .set().\n\n#### Function imports\n\nFunctions can be imported using the ImportFunc() function.\n\n    \n    \n    val LogStr = ImportFunc(\"console\", \"logStr\") { Param(I32, I32) }\n\n### Instructions, Expressions and Statements\n\nTo avoid confusion with \"regular\" Kotlin, all top level constructs use camel\ncase starting with an uppercase letter, e.g. Wasm if becomes If in the DSL.\n\nFor mapping Wasm instructions to our DSL, we divide them into two groups:\n\n  * We'll call instructions that push a value on the stack \"expressions\".\n  * Instructions that don't push a value on the stack we'll call \"statements\".\n\nExpressions can be nested and statements can take expressions as parameters,\nbut a line of code always has to be a statement.\n\nExpressions can be turned into statements by either dropping their return\nvalue using the Drop() statement -- or by putting their return value on the\nstack using Push(). Push isn't really a Wasm instructions, it just makes\npushing the result of an expression on the stack explicit for our Kotlin DSL.\nThe unary plus operator can be used as a shorthand for Push().\n\n#### Literals and number types\n\nLiteral values -- or kotlin numbers in general -- are mapped as follows to\nWasm types:\n\nKotlin type| Wasm type  \n---|---  \nBoolean, Int| I32  \nLong| I64  \nFloat| F32  \nDouble| F64  \n  \nTypically, Kotlin numbers can be used directly and will be converted to\nexpressions implicitly. The main exception is the first parameter of an\noperator: in this case, they need to be wrapped in a Const() call.\n\n#### Mathematical and bitwise operations\n\nMathematical operations that match an overloadable Kotlin operator are mapped\naccordingly. If there are signed and unsigned variants of the operation, the\nsigned variant is mapped to the operator and the unsigned operation is mapped\nto a Kotlin infix function.\n\nWe have already seen I32.mul mapped to the multiplication operator in the\nsquare example above.\n\nOther binary operations such as shl, xor and or are mapped to kotlin infix\noperations, starting with an uppercase letter.\n\n#### Relational Operations and Bool\n\nUnfortunately, Kotlin operator overloading for relational operations doesn't\nallow us to change the return type, so we map them to infix functions named\nafter the corresponding Wasm instructions.\n\nTo simplify combining comparisons, we provide a special type named Bool that\nmaps to I32 but only can hold the values 0 (false) and 1 (true) .\n\n#### Blocks and Control instructions\n\nBlocks are mapped to Kotlin functions with \"builder\" parameters. Branch labels\nare created using the Label() constructor immediately preceding the target\nblock.\n\nFor instance, a simple loop counting a variable i down looks as follows:\n\n    \n    \n    val i = Var(5) val cont = Label() Loop { i.set(i - 1) BrIf (cont, i Gt 1) }\n\n##### Conditions\n\nFor conditional statements, an optional else block can be provided via the\n.Else() method:\n\n    \n    \n    If (condition) { // Do something }.Else { // Do something else }\n\n##### Blocks returning a value\n\nBlocks returning a value take the return type as a parameter and are treated\nas expressions:\n\n    \n    \n    Return (Block(I32) { Push(42) })\n\nFor \"If\", there is an \"expression\" variant that doesn't have an explicit\nreturn type but works much like ternaries in other languages:\n\n    \n    \n    Return (If(condition, 42, 43))\n\n##### Convenience Control instructions: While and For\n\nIn addition to the Wasm Loop block, our DSL provides convenience While() and\nFor() functions.\n\nWhile() will iterate the following block of instructions until the condition\nexpression is false.\n\nFor() takes two to three arguments:\n\n  * The initial loop variable value\n  * The maximum loop variable value. The iteration will continue until this value is reached, exluding the maximum value.\n  * An optional step value\n\nBoth constructs will map to a Wasm loop inside a block with some additional\ninstructions for the condition and correspdonding branch.\n\n### Forward Declarations\n\nThe mappings described so far allow us to port a slightly more complex example\nthan sqr()from the Wasm test suite:\n\n    \n    \n    val factorialIterative = Func(I64) { val n = Param(I64) val res = Var(n) For (2L, n) { res.set(res * it) } Return(res) }\n\nUnfortuantely, assigning function declarations to kotlin variables means that\nthe variable is not available inside the function declaration. We need to use\nforward declarations to work around this limitation:\n\n    \n    \n    val factorialRecursive = ForwardDecl(I64) { Param(I64) } Implementation(factorialRecursive) { val n = Param(I64) Return(If(n Eq 0L, 1L, n * factorialRecursive(n - 1L))) }\n\n### Memory and Data\n\nMemory is declared using the Memory function, taking the minimum and optional\nmaximum size as parameters.\n\nAlthough there is currently only one \"memory\", all memory access is based on\nthe reference returned from the memory declaration, so it makes sense to keep\nhold of it in a variable.\n\n    \n    \n    val module = Module { val mem = Memory(1) }\n\n#### Data\n\nMemory can be statically initialized with data. If no offset is provided, the\nend of the previous data will be used as the start offset. The reference\nreturned from the data declaration will refer to its offset. This reference\nalso has a \"len\" property which will provide the byte size of the corrsponding\ndata item.\n\n    \n    \n    val module = Module { val LogStr = ImportFunc(\"console\", \"logStr\") { Param(I32, I32) } val mem = Memory(1) val message = mem.data(\"FizzBuzz\") val f = Func() { LogStr(message, message.len) } }\n\n#### Memory Access Instructions\n\nWasm memory load and store instructions are mapped to array access on a memory\nproperty indicating the access width, offset and align.\n\nThe following example implements two functions providing bytewise memory read\nand write acces via peek and poke functions.\n\n    \n    \n    val module = Module { val mem = Memory(1) val peek = Func(I32) { val address = Param(I32) Return (mem.i32U8[address]) } val poke = Func() { val address = Param(I32) val value = Param(I32) mem.i32U8[address] = value } }\n\nIt's possible to hold on to references with a given width, align and offset:\n\n    \n    \n    val mem8 = mem.i32U8(offset = 1000)\n\nIt's also possible to provide an alignment and offset on access. The access\nalignment overrides the general offset of the access type property while the\ntwo offsets are added.\n\n### Tables and Elements\n\nTables declarations are similar to memory declarations, but they take an\nadditional type parameter -- which is required to be FuncRef for Wasm 1.\n\n    \n    \n    val table = Table(FuncRef, 10)\n\nSimilar to data declarations, the elem method on table references can be used\nto pre-fill table elements:\n\n    \n    \n    val constI32A = Func(I32) { Return(65) } table.elem(7, constI32A)\n\nIn order to call functions stored in tables, their type must be supplied\nexplicitly. For this purpose, we declare a function type returning an I32\nvalue and not taking any parameters:\n\n    \n    \n    val outI32 = Type(I32) {}\n\nWe can now call this function by invoking the table with the function index,\nthe expected type and the function parameters (which we don't have in this\nsimple case):\n\n    \n    \n    val call7 = Func(I32) { Return(table(7, outI32)) }\n\n## More Examples\n\nUsage Examples can be found in the test directory of the project.\n\n## Known Issues\n\n  * There are no releases yet that can be directly referenced from Maven / Gradle. Given that there are very likely still some serious bugs in Wasm binary code generation, it's probably best to check out the full project anyway, simplifying fixes.\n\n## Plans\n\n  * Port more Wasm tests\n  * Find a nice clean way to test the generated binary code\n  * Support various extensions (multiple return values is partially done except for block parameters and a proper \"feature flag\")\n  * Perhaps support loading modules (would probably be useful to import trigonometric functions)\n  * Extend WASI coverage\n\n## Appendix\n\n### Appendix A: Instruction Name Mapping\n\n#### Built-in infix functions\n\nKt DSL| Wasm I32| Wasm I64| Wasm F32| Wasm F64  \n---|---|---|---|---  \n+| I32.add| I64.add| F32.mul| F64.mul  \n-| I32.sub| I64.sub| F32.mul| F64.mul  \n*| I32.mul| I64.mul| F32.mul| F64.mul  \n/| I32.div_s| I64.div_s| F32.div| F64.div  \n%| I32.rem_s| I64.rem_s| F32.rem| F64.rem  \nAnd| I32.and| I64.and  \nDivU| I32.div_u| I64.div_u  \nOr| I32.or| I64.or  \nRemU| I32.rem_u| I64.rem_u  \nRotl| I32.rotl| I64.rotl  \nShl| I32.shl| I64.shl  \nShr| I32.shr_s| I64.shr_s  \nShrU| I32.shr_u| I64.shr_u  \nXor| I32.xor| I64.xor  \n  \n#### Built-in functions with two arguments\n\nKt DSL| F32| F64  \n---|---|---  \nCopySign| F32.copysign| F64.copysign  \nMax| F32.max| F64.max  \nMin| F32.min| F64.min  \n  \n#### Built-in single argument operator and functions\n\nKt DSL| Wasm I32| Wasm I64| Wasm F32| Wasm F64  \n---|---|---|---|---  \nUnary -| *| *| F32.neg| F64.neg  \nAbs| F32.abs| F64.abs  \nCeil| F32.ceil| F64.ceil  \nClz| I32.clz| I64.clz  \nCtz| I32.ctz| I64.ctz  \nFloor| F32.floor| F64.floor  \nPopcnt| I32.popcnt| I64.popcnt  \n  \n*) Mapped to multiple Wasm instructions for convenience.\n\n#### Relational Operations\n\nKt DSL| Wasm I32| Wasm I64| Wasm F32| Wasm F64  \n---|---|---|---|---  \nEq| I32.eq| I64.eq| F32.eq| F64.eq  \nGe| I32.ge_s| I64.ge_s| F32.ge| F64.ge  \nGeU| I32.ge_u| I64.ge_u  \nGt| I32.gt_s| I64.gt_s| F32.gt| F64.gt  \nGtU| I32.gt_u| I64.gt_u  \nLe| I32.le_s| I64.le_s| F32.le| F64.le  \nLeU| I32.le_u| I64.le_u  \nLt| I32.lt_s| I64.lt_s| F32.lt| F64.lt  \nLtU| I32.lt_u| I64.lt_u  \nNe| I32.ne| I64.ne| F32.ne| F64.ne  \n  \n#### Type Conversions\n\nTo \\ From| I32| I64| F32| F64  \n---|---|---|---|---  \nI32| I32.wrap_i64| I32.Reinterpret_f32  \n\\- DSL| Wrap| Reinterpret  \nI32 (S)| I32.trunc_f32_s| I32.trunc_f64_s  \n\\- DSL| TruncToI32| TruncToI32  \nI32 (U)| I32.trunc_f32_u| I32.trunc_f64_u  \n\\- DSL| TruncToI32U| TruncToI32U  \nI64| I64.Reinterpret_f64  \n\\- DSL| Reinterpret  \nI64 (S)| I64.extend_i32_s| I64.trunc_f32_s| I64.trunc_f64_s  \n\\- DSL| TruncToI64| TruncToI64  \nI64 (U)| I64.extend_i32_u| I64.trunc_f32_u| I64.trunc_f64_u  \n\\- DSL| TruncToI64U| TruncToI64U  \nF32| F32.convert_i32_s| F32.convert_i64_s| F32.demote_f64  \n-DSL| ConvertToF32| ConvertToF32| Demote  \nF32.convert_i32_u| F32.convert_i64_u  \nConvertToF32U| ConvertToF32U  \nF64| F64.convert_i32_s| F64.convert_i64_s| F63.promote_f32  \n-DSL| ConvertToF64| ConvertToF64| Promote  \nF64.convert_i32_u| F64.convert_i64_u  \nConvertToF64U| ConvertToF64U  \n  \n## About\n\nNo description, website, or topics provided.\n\n### Resources\n\nReadme\n\n### License\n\nApache-2.0 license\n\nActivity\n\nCustom properties\n\n### Stars\n\n0 stars\n\n### Watchers\n\n1 watching\n\n### Forks\n\n0 forks\n\nReport repository\n\n## Releases\n\nNo releases published\n\n## Packages 0\n\nNo packages published\n\n## Languages\n\n  * Kotlin 100.0%\n\n## Footer\n\n\u00a9 2024 GitHub, Inc.\n\nYou can\u2019t perform that action at this time.\n\n", "frontpage": false}
