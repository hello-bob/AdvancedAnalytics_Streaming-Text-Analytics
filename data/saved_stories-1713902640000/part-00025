{"aid": "40130075", "title": "The Optimizations in Erlang/OTP 27", "url": "https://www.erlang.org/blog/optimizations/", "domain": "erlang.org", "votes": 1, "user": "asabil", "posted_at": "2024-04-23 09:21:56", "comments": 0, "source_title": "The Optimizations in Erlang/OTP 27 - Erlang/OTP", "source_text": "The Optimizations in Erlang/OTP 27 - Erlang/OTP\n\n### The Optimizations in Erlang/OTP 27\n\nApril 23, 2024 \u00b7 by Bj\u00f6rn Gustavsson\n\nThis post explores the new optimizations for record updates as well as some of\nthe other improvements. It also gives a brief historic overview of recent\noptimizations leading up to Erlang/OTP 27.\n\n### A brief history of recent optimizations #\n\nThe modern history of optimizations for Erlang begins in January 2018. We had\nrealized that we had reached the limit of the optimizations that were possible\nworking on BEAM code in the Erlang compiler.\n\n  * Erlang/OTP 22 introduced a new SSA-based intermediate representation in the compiler. Read the full story in SSA History.\n\n  * Erlang/OTP 24 introduced the JIT (Just In Time compiler), which improved performance by emitting native code for BEAM instructions at load-time.\n\n  * Erlang/OTP 25 introduced type-based optimization in the JIT, which allowed the Erlang compiler to pass type information to the JIT to help it emit better native code. While that improved the native code emitted by the JIT, limitations in both the compiler and the JIT prevented the JIT to take full advantage of the type information.\n\n  * Erlang/OTP 26 improved the type-based optimizations. The most noticeable performance improvements were matching and construction of binaries using the bit syntax. Those improvements, combined with changes to the base64 module itself, made encoding to Base64 about 4 times as fast and decoding from Base64 more than 3 times as fast.\n\n### What to expect of the JIT in Erlang/OTP 27 #\n\nThe major compiler and JIT improvement in Erlang/OTP 27 is optimization of\nrecord operations, but there are also many smaller optimizations that make the\ncode smaller and/or faster.\n\n### Please try this at home! #\n\nWhile this blog post will show many examples of generated code, I have\nattempted to explain the optimizations in English as well. Feel free to skip\nthe code examples.\n\nOn the other hand, if you want more code examples...\n\nTo examine the native code for loaded modules, start the runtime system like\nthis:\n\n    \n    \n    erl +JDdump true\n\nThe native code for all modules that are loaded will be dumped to files with\nthe extension .asm.\n\nTo examine the BEAM code for a module, use the -S option when compiling. For\nexample:\n\n    \n    \n    erlc -S base64.erl\n\n### A simple record optimization #\n\nTo get started, let\u2019s look at a simple record optimization that was not done\nin Erlang/OTP 26 and earlier. Suppose we have this module:\n\n    \n    \n    -record(foo, {a,b,c,d,e}). update(N) -> R0 = #foo{}, R1 = R0#foo{a=N}, R2 = R1#foo{b=2}, R2#foo{c=3}.\n\nHere is BEAM code for the record operations:\n\n    \n    \n    {update_record,{atom,reuse}, 6, {literal,{foo,undefined,undefined,undefined,undefined, undefined}}, {x,0}, {list,[2,{x,0}]}}. {update_record,{atom,copy},6,{x,0},{x,0},{list,[3,{integer,2}]}}. {update_record,{atom,copy},6,{x,0},{x,0},{list,[4,{integer,3}]}}.\n\nThat is, all three record update operations have been retained as separate\nupdate_record instructions. Each operation creates a new record by copying the\nunchanged parts of the record and filling in the new values in the correct\nposition.\n\nThe compiler in Erlang/OTP 27 will essentially rewrite update/1 to:\n\n    \n    \n    update(N) -> #foo{a=N,b=2,c=3}.\n\nwhich will produce the following BEAM code for the record creation:\n\n    \n    \n    {put_tuple2,{x,0}, {list,[{atom,foo}, {x,0}, {integer,2}, {integer,3}, {atom,undefined}, {atom,undefined}]}}.\n\nThose optimizations were implemented in the following pull requests:\n\n  * #7491: Merge consecutive record updates\n\n  * #8086: Combine creation of a record with subsequent record updates\n\n### Updating records in place #\n\nTo explore the more sophisticated record optimization introduced in Erlang/OTP\n27, consider this example:\n\n    \n    \n    -module(count1). -export([count/1]). -record(s, {atoms=0,other=0}). count(L) -> count(L, #s{}). count([X|Xs], #s{atoms=C}=S) when is_atom(X) -> count(Xs, S#s{atoms=C+1}); count([_|Xs], #s{other=C}=S) -> count(Xs, S#s{other=C+1}); count([], S) -> S.\n\ncount(List) counts the number of atoms and the number of other terms in the\ngiven list. For example:\n\n    \n    \n    1> -record(s, {atoms=0,other=0}). ok 2> count1:count([a,b,c,1,2,3,4,5]). #s{atoms = 3,other = 5}\n\nHere follows the BEAM code emitted for count/2:\n\n    \n    \n    {test,is_nonempty_list,{f,6},[{x,0}]}. {get_list,{x,0},{x,2},{x,0}}. {test,is_atom,{f,5},[{x,2}]}. {get_tuple_element,{x,1},1,{x,2}}. {gc_bif,'+',{f,0},3,[{tr,{x,2},{t_integer,{0,'+inf'}}},{integer,1}],{x,2}}. {test_heap,4,3}. {update_record,{atom,inplace}, 3, {tr,{x,1}, {t_tuple,3,true, #{1 => {t_atom,[s]}, 2 => {t_integer,{0,'+inf'}}, 3 => {t_integer,{0,'+inf'}}}}}, {x,1}, {list,[2,{tr,{x,2},{t_integer,{1,'+inf'}}}]}}. {call_only,2,{f,4}}. % count/2 {label,5}. {get_tuple_element,{x,1},2,{x,2}}. {gc_bif,'+',{f,0},3,[{tr,{x,2},{t_integer,{0,'+inf'}}},{integer,1}],{x,2}}. {test_heap,4,3}. {update_record,{atom,inplace}, 3, {tr,{x,1}, {t_tuple,3,true, #{1 => {t_atom,[s]}, 2 => {t_integer,{0,'+inf'}}, 3 => {t_integer,{0,'+inf'}}}}}, {x,1}, {list,[3,{tr,{x,2},{t_integer,{1,'+inf'}}}]}}. {call_only,2,{f,4}}. % count/2 {label,6}. {test,is_nil,{f,3},[{x,0}]}. {move,{x,1},{x,0}}. return.\n\nThe first two instructions test whether the first argument in {x,0} is a non-\nempty list and if so extracts the first element of the list:\n\n    \n    \n    {test,is_nonempty_list,{f,6},[{x,0}]}. {get_list,{x,0},{x,2},{x,0}}.\n\nThe next instruction tests whether the first element is an atom. If not, a\njump is made to the code for the second clause.\n\n    \n    \n    {test,is_atom,{f,5},[{x,2}]}.\n\nNext the counter for the number of atoms seen is fetched from the record and\nincremented by one:\n\n    \n    \n    {get_tuple_element,{x,1},2,{x,2}}. {gc_bif,'+',{f,0},3,[{tr,{x,2},{t_integer,{0,'+inf'}}},{integer,1}],{x,2}}.\n\nNext follows allocation of heap space and the updating of the record:\n\n    \n    \n    {test_heap,4,3}. {update_record,{atom,inplace}, 3, {tr,{x,1}, {t_tuple,3,true, #{1 => {t_atom,[s]}, 2 => {t_integer,{0,'+inf'}}, 3 => {t_integer,{0,'+inf'}}}}}, {x,1}, {list,[3,{tr,{x,2},{t_integer,{1,'+inf'}}}]}}.\n\nThe test_heap instruction ensures that there is sufficient room on the heap\nfor copying the record (4 words).\n\nThe update_record instruction was introduced in Erlang/OTP 26. Its first\noperand is an atom that is a hint from the compiler to help the JIT emit\nbetter code. In Erlang/OTP 26 the hints reuse and copy are used. For more\nabout those hints, see Updating records in OTP 26.\n\nIn Erlang/OTP 27, there is a new hint called inplace. The compiler emits that\nhint when it has determined that nowhere in the runtime system is there\nanother reference to the tuple except for the reference used for the\nupdate_record instruction. In other words, from the compiler\u2019s point of view,\nif the runtime system were to directly update the existing record without\nfirst copying it, the observable behavior of the program would not change. As\nsoon will be seen, from the runtime system\u2019s point of view, directly updating\nthe record is not always safe.\n\nThis new optimization was implemented by Frej Drejhammar. It builds on and\nextends the compiler passes added in Erlang/OTP 26 for appending to a binary.\n\nNow let\u2019s see what the JIT will do when a record_update instruction has an\ninplace hint. Here is the complete native code for the instruction:\n\n    \n    \n    # update_record_in_place_IsdI mov rax, qword ptr [rbx+8] mov rcx, qword ptr [rbx+16] test cl, 1 short je L38 ; Update directly if small integer. ; The new value is a bignum. ; Test whether the tuple is in the safe part of the heap. mov rdi, [r13+480] ; Get the high water mark cmp rax, r15 ; Compare tuple pointer to heap top short jae L39 ; Jump and copy if above cmp rax, rdi ; Compare tuple pointer to high water short jae L38 ; Jump and overwrite if above high water ; The tuple is not in the safe part of the heap. ; Fall through to the copy code. L39: ; Copy the current record vmovups ymm0, [rax-2] vmovups [r15], ymm0 lea rax, qword ptr [r15+2] ; Set up tagged pointer to copy add r15, 32 ; Advance heap top past the copy L38: mov rdi, rcx ; Get new value for atoms field mov qword ptr [rax+22], rdi mov qword ptr [rbx+8], rax\n\n(Lines starting with # are comments emitted by the JIT, while the text that\nfollows ; is a comment added by me for clarification.)\n\nThe BEAM loader renames an update_record instruction with an inplace hint to\nupdate_record_in_place.\n\nThe first two instructions load the tuple to be update into CPU register rax\nand the new counter value (C + 1) into rcx.\n\n    \n    \n    mov rax, qword ptr [rbx+8] mov rcx, qword ptr [rbx+16]\n\nThe next two instructions test whether the new counter value is a small\ninteger that fits into a word. The test has been simplified to a more\nefficient test that is only safe when the value is known to be an integer. If\nit is a small integer, it is always safe to jump to the code that updates the\nexisting tuple:\n\n    \n    \n    test cl, 1 short je L38 ; Update directly if small integer.\n\nIf it is not a small integer, it must be a bignum, that is a signed integer\nthat does not fit in 60 bits and therefore have to be stored on the heap with\nrcx containing a tagged pointer to the bignum on the heap.\n\nIf rcx is a pointer to a term on the heap, it is not always safe to directly\nupdating the existing tuple. That is because of the way the Erlang\ngenerational garbage collector works. Each Erlang process has two heaps for\nkeeping Erlang terms: the young heap and the old heap. Terms on the young heap\nare allowed to reference terms on the old heap, but not vice versa. That means\nthat if the tuple to be updated resides on the old heap, it is not safe to\nupdate one of its elements so that it will reference a term on the young heap.\n\nTherefore, the JIT needs to emit code to ensure that the pointer to the tuple\nresides in the \u201csafe part\u201d of the young heap:\n\n    \n    \n    mov rdi, [r13+480] ; Get the high water mark cmp rax, r15 ; Compare tuple pointer to heap top short jae L39 ; Jump and copy if above cmp rax, rdi ; Compare tuple pointer to high water short jae L38 ; Jump and overwrite if above high water\n\nThe safe part of the heap is between the high water mark and the heap top. If\nthe tuple is below the high water mark, if it is still alive, it will be\ncopied to the old heap in the next garbage collection.\n\nIf the tuple is in the safe part, the copy code is skipped by jumping to the\ncode that stores the new value into the existing tuple.\n\nIf not, the next part will copy the existing record to the heap.\n\n    \n    \n    L39: ; Copy the current record vmovups ymm0, [rax-2] vmovups [r15], ymm0 lea rax, qword ptr [r15+2] ; Set up tagged pointer to copy add r15, 32 ; Advance heap top past the copy\n\nThe copying is done using AVX instructions.\n\nNext follows the code that writes the new value into the tuple:\n\n    \n    \n    L38: mov rdi, rcx ; Get new value for atoms field mov qword ptr [rax+22], rdi mov qword ptr [rbx+8], rax\n\nIf all the new values being written into the existing record are known never\nto be tagged pointers, the native instructions can be simplified. Consider\nthis module:\n\n    \n    \n    -module(whatever). -export([main/1]). -record(bar, {bool,pid}). main(Bool) when is_boolean(Bool) -> flip_state(#bar{bool=Bool,pid=self()}). flip_state(R) -> R#bar{bool=not R#bar.bool}.\n\nThe update_record instruction looks like this:\n\n    \n    \n    {update_record,{atom,inplace}, 3, {tr,{x,0}, {t_tuple,3,true, #{1 => {t_atom,[bar]}, 2 => {t_atom,[false,true]}, 3 => pid}}}, {x,0}, {list,[2,{tr,{x,1},{t_atom,[false,true]}}]}}.\n\nBased on the type for the new value, {t_atom,[false,true]}, the JIT is able to\ngenerate much shorter code than for the previous example:\n\n    \n    \n    # update_record_in_place_IsdI mov rax, qword ptr [rbx] # skipped copy fallback because all new values are safe mov rdi, qword ptr [rbx+8] mov qword ptr [rax+14], rdi mov qword ptr [rbx], rax\n\nReferences to literals (such as [1,2,3]) are also safe, because literals are\nstored in a special literal area, and the garbage collector handles them\nspecially. Consider this code:\n\n    \n    \n    -record(state, {op, data}). update_state(R0, Op0, Data) -> R = R0#state{data=Data}, case Op0 of add -> R#state{op=fun erlang:'+'/2}; sub -> R#state{op=fun erlang:'-'/2} end.\n\nBoth of the record updates in the case can be done in place. Here is the BEAM\ncode for the record update in the first clause:\n\n    \n    \n    {update_record,{atom,inplace}, 3, {tr,{x,0},{t_tuple,3,true,#{1 => {t_atom,[state]}}}}, {x,0}, {list,[2,{literal,fun erlang:'+'/2}]}}.\n\nSince the value to be written is a literal, the JIT emits simpler code without\nthe copy fallback:\n\n    \n    \n    # update_record_in_place_IsdI mov rax, qword ptr [rbx] # skipped copy fallback because all new values are safe long mov rdi, 9223372036854775807 ; Placeholder for address to fun mov qword ptr [rax+14], rdi mov qword ptr [rbx], rax\n\nThe large integer 9223372036854775807 is a placeholder that will be patched\nlater when the address of the literal fun will be known.\n\nHere is the pull request for updating tuples in place:\n\n  * #8090: Destructive tuple update\n\n### Optimizing by generating less garbage #\n\nWhen updating a record in place, omitting the copying of the existing record\nshould be a clear win, except perhaps for very small records.\n\nWhat is less clear is the effect on garbage collection. Updating a tuple in\nplace is an example of optimizing by generating less garbage. By creating less\ngarbage, the expectation is that garbage collections should occur less often,\nwhich should improve the performance of the program.\n\nBecause of the highly variable execution time for doing a garbage collection,\nit is notoriously difficult to benchmark optimizations that reduce the amount\nof garbage created. Often the outcomes of benchmarks do not apply to\nperforming the same tasks in a real application.\n\nMy own anecdotal evidence suggests that in most cases there are no measurable\nperformance wins by producing less garbage.\n\nI also remember when an optimization that reduced the size of an Erlang term\nresulted in a benchmark being consistently slower. It took the author of that\noptimization several days of investigation to confirm that the slowdown in the\nbenchmark was not the fault of his optimization, but by creating less garbage,\ngarbage collection happened at a later time when it happened to be much more\nexpensive.\n\nOn average we expect that this optimization should improve performance,\nespecially for large records.\n\n### Optimization of funs #\n\nThe internal representation of funs in the runtime system has changed in\nErlang/OTP 27, making possible several new optimizations.\n\nAs an example, consider this function:\n\n    \n    \n    madd(A, C) -> fun(B) -> A * B + C end.\n\nIn Erlang/OTP 26, the native code for creating the fun looks like so:\n\n    \n    \n    # i_make_fun3_FStt L38: long mov rsi, 9223372036854775807 ; Placeholder for dispatch table mov edx, 1 mov ecx, 2 mov qword ptr [r13+80], r15 mov rbp, rsp lea rsp, qword ptr [rbx-128] vzeroupper mov rdi, r13 call 4337160320 ; Call helper function in runtime system mov rsp, rbp mov r15, qword ptr [r13+80] # Move fun environment mov rdi, qword ptr [rbx] mov qword ptr [rax+40], rdi mov rdi, qword ptr [rbx+8] mov qword ptr [rax+48], rdi # Create boxed ptr or al, 2 mov qword ptr [rbx], rax\n\nThe large integer 9223372036854775807 is a placeholder for a value that will\nbe filled in later.\n\nMost of the work of actually creating the fun object is done by calling a\nhelper function (the call 4337160320 instruction) in the runtime system.\n\nIn Erlang/OTP 27, the part of fun that resides on the heap of the calling\nprocess has been simplified so that it is now smaller than in Erlang/OTP 26,\nand most importantly does not contain anything that is too tricky to\ninitialize in inline code.\n\nThe code for creating the fun is not only shorter, but it also doesn\u2019t need to\ncall any function in the runtime system:\n\n    \n    \n    # i_make_fun3_FStt L38: long mov rax, 9223372036854775807 ; Placeholder for dispatch table # Create fun thing mov qword ptr [r15], 196884 mov qword ptr [r15+8], rax # Move fun environment # (moving two items) vmovups xmm0, xmmword ptr [rbx] vmovups xmmword ptr [r15+16], xmm0 L39: long mov rdi, 9223372036854775807 ; Placeholder for fun reference mov qword ptr [r15+32], rdi # Create boxed ptr lea rax, qword ptr [r15+2] add r15, 40 mov qword ptr [rbx], rax\n\nThe difference from Erlang/OTP 26 is that the parts of the fun that is only\nneeded when loading and unloading code are no longer stored on the heap.\nInstead those parts are stored in the literal pool area belonging to the\nloaded code for the module, and are shared by all instances of the same fun.\n\nThe part of the fun that resides on the process heap is two words smaller\ncompared to Erlang/OTP 26.\n\nThe creation of the fun environment has also been optimized. In Erlang/OTP 26,\nfour instructions were needed:\n\n    \n    \n    # Move fun environment mov rdi, qword ptr [rbx] mov qword ptr [rax+40], rdi mov rdi, qword ptr [rbx+8] mov qword ptr [rax+48], rdi\n\nIn Erlang/OTP 27, using AVX instructions both variables (A and C) can be moved\nusing only two instructions:\n\n    \n    \n    # Move fun environment # (moving two items) vmovups xmm0, xmmword ptr [rbx] vmovups xmmword ptr [r15+16], xmm0\n\nAnother optimization made possible by the changed fun representation is\ntesting for a fun having a specific arity (the number of expected arguments\nwhen calling it). For example:\n\n    \n    \n    ensure_fun_0(F) when is_function(F, 0) -> ok.\n\nHere is the native code emitted by the JIT in Erlang/OTP 26:\n\n    \n    \n    # is_function2_fss mov rdi, qword ptr [rbx] ; Fetch `F` from {x,0}. rex test dil, 1 ; Test whether the term is a tagged pointer... short jne label_3 ; ... otherwise fail. mov eax, dword ptr [rdi-2] ; Pick up the header word. cmp eax, 212 ; Test whether it is a fun... short jne label_3 ; ... otherwise fail. cmp byte ptr [rdi+22], 0 ; Test whether the arity is 0... short jne label_3 ; ... otherwise fail.\n\nIn Erlang/OTP 27, the arity for the fun (the number of expected arguments) is\nstored in the header word of the fun term, which means that the test for a fun\ncan be combined with the test for its arity:\n\n    \n    \n    # is_function2_fss mov rdi, qword ptr [rbx] ; Fetch `F` from {x,0}. rex test dil, 1 ; Test whether the term is a tagged pointer... short jne label_3 ; ... otherwise fail. cmp word ptr [rdi-2], 20 ; Test whether this is a fun with arity 0... short jne label_3 ; ... otherwise fail.\n\nAll external funs are now literals stored outside all process heaps. As an\nexample, consider the following functions:\n\n    \n    \n    my_fun() -> fun ?MODULE:some_function/0. mfa(M, F, A) -> fun M:F/A.\n\nIn Erlang/OTP 26, the external fun returned by my_fun/0 would not occupy any\nroom on the heap of the calling process, while the dynamic external fun\nreturned by mfa/3 would need 5 words on the heap of the calling process.\n\nIn Erlang/OTP 27, neither of the funs will require any room on the heap of the\ncalling process.\n\nThose optimizations were implemented in the following pull requests:\n\n  * #7948: Optimize reference counting of local funs\n\n  * #7314: Shrink and optimize funs (again)\n\n  * #7894: Share external funs globally\n\n  * x86_64: Optimize creation of fun environment (part of #7713)\n\n### Integer arithmetic improvements #\n\nIn the end of June last year, we released the OTP 26.0.2 patch for Erlang/OTP\n26 that made binary_to_integer/1 faster.\n\nTo find out how much faster, run this benchmark:\n\n    \n    \n    bench() -> Size = 1_262_000, String = binary:copy(<<\"9\">>, Size), {Time, _Val} = timer:tc(erlang, binary_to_integer, [String]), io:format(\"Size: ~p, seconds: ~p\\n\", [Size, Time / 1_000_000]).\n\nIt measures the time to convert a binary holding 1,262,000 digits to an\ninteger.\n\nRunning an unpatched Erlang/OTP 26 on my Intel-based iMac from 2017, the\nbenchmark finishes in about 10 seconds.\n\nThe same benchmark run using Erlang/OTP 26.0.2 finishes in about 0.4 seconds.\n\nThe speed-up was achieved by three separate optimizations:\n\n  * binary_to_integer/1 was implemented as a BIF in C using a naive algorithm that didn\u2019t scale well. It was replaced with a divide-and-conquer algorithm implemented in Erlang. (Implementing the new algorithm as a BIF wasn\u2019t faster than the Erlang version.)\n\n  * The runtime system\u2019s function for doing multiplication of large integers was modified to use the Karatsuba algorithm, which is a divide-and-conquer multiplication algorithm invented in the 1960s.\n\n  * Some of the low-level helper functions for arithmetic with large integers (bignums) were modified to take advantage of a 128-bit integer data type on 64-bit CPUs when supported by the C compiler.\n\nThose improvements were implemented in the following pull request:\n\n  * #7426: Optimize binary_to_integer/1 and friends\n\nIn Erlang/OTP 27, some additional improvement of integer arithemetic were\nimplemented. That reduced the execution time for the binary_to_integer/1\nbenchmark to about 0.3 seconds.\n\nThose improvements are found in the following pull request:\n\n  * #7553: Optimize integer arithmetic\n\nThose arithmetic enchancements improve the running times for the pidigits\nbenchmark:\n\nVersion| Seconds  \n---|---  \n26.0| 7.635  \n26.2.1| 2.959  \n27.0| 2.782  \n  \n(Run on my M1 MacBook Pro.)\n\n### Numerous miscellaneous enhancements #\n\nMany enhancements have been made to the code generation for many instructions,\nas well as a few to the Erlang compiler. Here follows a single example to show\none of the improvements to the =:= operator:\n\n    \n    \n    ensure_empty_map(Map) when Map =:= #{} -> ok.\n\nHere is the BEAM code for the =:= operator as used in this example:\n\n    \n    \n    {test,is_eq_exact,{f,1},[{x,0},{literal,#{}}]}.\n\nHere is the native code for Erlang/OTP 26:\n\n    \n    \n    # is_eq_exact_fss L45: long mov rsi, 9223372036854775807 mov rdi, qword ptr [rbx] cmp rdi, rsi short je L44 ; Succeeded if the same term. rex test dil, 1 short jne label_1 ; Fail quickly if not a tagged pointer. ; Call the general runtime function for comparing two terms. mov rbp, rsp lea rsp, qword ptr [rbx-128] vzeroupper call 4549723200 mov rsp, rbp test eax, eax short je label_1 ; Fail if unequal. L44:\n\nThe code begins with a few tests to quickly succeed or fail, but in practice\nthose are unlikely to trigger for this example, which means that the call to\nthe general routine in the runtime system for comparing two terms will almost\nalways be called.\n\nIn Erlang/OTP 27, the JIT emits special code for testing whether a term is an\nempty map:\n\n    \n    \n    # is_eq_exact_fss # optimized equality test with empty map mov rdi, qword ptr [rbx] rex test dil, 1 short jne label_1 ; Fail if not a tagged pointer. cmp dword ptr [rdi-2], 300 short jne label_1 ; Fail if not a map. cmp dword ptr [rdi+6], 0 short jne label_1 ; Fail if size is not zero.\n\nHere follows the main pull requests for miscellaneous enhancements in\nErlang/OTP 27:\n\n  * #7563: Enhance type analysis\n\n  * #7956: Do some minor enhancements of the code generation in the JIT\n\n  * #7713: Improve code generation for the JIT\n\n  * #8040: Improve caching of BEAM registers\n\n", "frontpage": false}
