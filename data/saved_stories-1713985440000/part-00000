{"aid": "40143857", "title": "Sized, DynSized, and Unsized", "url": "https://smallcultfollowing.com/babysteps/blog/2024/04/23/dynsized-unsized/", "domain": "smallcultfollowing.com", "votes": 1, "user": "asicsp", "posted_at": "2024-04-24 13:02:29", "comments": 0, "source_title": "baby steps", "source_text": "Sized, DynSized, and Unsized \u00b7 baby steps\n\n# Sized, DynSized, and Unsized\n\n23 April 2024\n\nExtern types have been blocked for an unreasonably long time on a fairly\nnarrow, specialized question: Rust today divides all types into two categories\n\u2014 sized, whose size can be statically computed, and unsized, whose size can\nonly be computed at runtime. But for external types what we really want is a\nthird category, types whose size can never be known, even at runtime (in C,\nyou can model this by defining structs with an unknown set of fields). The\nproblem is that Rust\u2019s ?Sized notation does not naturally scale to this third\ncase. I think it\u2019s time we fixed this. At some point I read a proposal \u2014 I no\nlonger remember where \u2014 that seems like the obvious way forward and which I\nthink is a win on several levels. So I thought I would take a bit of time to\nfloat the idea again, explain the tradeoffs I see with it, and explain why I\nthink the idea is a good change.\n\n## TL;DR: write T: Unsized in place of T: ?Sized (and sometimes T: DynSized)\n\nThe basic idea is to deprecate the ?Sized notation and instead have a family\nof Sized supertraits. As today, the default is that every type parameter T\ngets a T: Sized bound unless the user explicitly chooses one of the other\nsupertraits:\n\n    \n    \n    /// Types whose size is known at compilation time (statically). /// Implemented by (e.g.) `u32`. References to `Sized` types /// are \"thin pointers\" -- just a pointer. trait Sized: DynSized { } /// Types whose size can be computed at runtime (dynamically). /// Implemented by (e.g.) `[u32]` or `dyn Trait`. /// References to these types are \"wide pointers\", /// with the extra metadata making it possible to compute the size /// at runtime. trait DynSized: Unsized { } /// Types that may not have a knowable size at all (either statically or dynamically). /// All types implement this, but extern types **only** implement this. trait Unsized { }\n\nUnder this proposal, T: ?Sized notation could be converted to T: DynSized or\nT: Unsized. T: DynSized matches the current semantics precisely, but T:\nUnsized is probably what most uses actually want. This is because most users\nof T: ?Sized never compute the size of T but rather just refer to existing\nvalues of T by pointer.\n\n### Credit where credit is due?\n\nFor the record, this design is not my idea, but I\u2019m not sure where I saw it. I\nwould appreciate a link so I can properly give credit.\n\n## Why do we have a default T: Sized bound in the first place?\n\nIt\u2019s natural to wonder why we have this T: Sized default in the first place.\nThe short version is that Rust would be very annoying to use without it. If\nthe compiler doesn\u2019t know the size of a value at compilation time, it cannot\n(at least, cannot easily) generate code to do a number of common things, such\nas store a value of type T on the stack or have structs with fields of type T.\nThis means that a very large fraction of generic type parameters would wind up\nwith T: Sized.\n\n## So why the ?Sized notation?\n\nThe ?Sized notation was the result of a lot of discussion. It satisfied a\nnumber of criteria.\n\n### ? signals that the bound operates in reverse\n\nThe ? is meant to signal that a bound like ?Sized actually works in reverse\nfrom a normal bound. When you have T: Clone, you are saying \u201ctype T must\nimplement Clone\u201d. So you are narrowing the set of types that T could be:\nbefore, it could have been both types that implement Clone and those that do\nnot. After, it can only be types that implement Clone. T: ?Sized does the\nreverse: before, it can only be types that implement Sized (like u32), but\nafter, it can also be types that do not (like [u32] or dyn Debug). Hence the\n?, which can be read as \u201cmaybe\u201d \u2014 i.e., T is \u201cmaybe\u201d Sized.\n\n### ? can be extended to other default bounds\n\nThe ? notation also scales to other default traits. Although we\u2019ve been\nreluctant to exercise this ability, we wanted to leave room to add a new\ndefault bound. This power will be needed if we ever adopt \u201cmust move\u201d types^1\nor add a bound like ?Leak to signal a value that cannot be leaked.\n\n## But ? doesn\u2019t scale well to \u201cdifferences in degree\u201d\n\nWhen we debated the ? notation, we thought a lot about extensibility to other\northogonal defaults (like ?Leak), but we didn\u2019t consider extending a single\ndimension (like Sized) to multiple levels. There is no theoretical challenge.\nIn principle we could say...\n\n  * T means T: Sized + DynSized\n  * T: ?Sized drops the Sized default, leaving T: DynSized\n  * T: ?DynSized drops both, leaving any type T\n\n...but I personally find that very confusing. To me, saying something \u201cmight\nbe statically sized\u201d does not signify that it is dynamically sized.\n\n## And ? looks \u201cmore magical\u201d than it needs to\n\nDespite knowing that T: ?Sized operates in reverse, I find that in practice it\nstill feels very much like other bounds. Just like T: Debug gives the function\nthe extra capability of generating debug info, T: ?Sized feels to me like it\ngives the function an extra capability: the ability to be used on unsized\ntypes. This logic is specious, these are different kinds of capabilities, but,\nas I said, it\u2019s how I find myself thinking about it.\n\nMoreover, even though I know that T: ?Sized \u201cmost properly\u201d means \u201ca type that\nmay or may not be Sized\u201d, I find it wind up thinking about it as \u201ca type that\nis unsized\u201d, just as I think about T: Debug as a \u201ctype that is Debug\u201d. Why is\nthat? Well, beacuse ?Sized types may be unsized, I have to treat them as if\nthey are unsized \u2013 i.e., refer to them only by pointer. So the fact that they\nmight also be sized isn\u2019t very relevant.\n\n## How would we use these new traits?\n\nSo if we adopted the \u201cfamily of sized traits\u201d proposal, how would we use it?\nWell, for starters, the size_of methods would no longer be defined as T and T:\n?Sized...\n\n    \n    \n    fn size_of<T>() -> usize {} fn size_of_val<T: ?Sized>(t: &T) -> usize {}\n\n... but instead as T and T: DynSized ...\n\n    \n    \n    fn size_of<T>() -> usize {} fn size_of_val<T: DynSized>(t: &T) -> usize {}\n\nThat said, most uses of ?Sized today do not need to compute the size of the\nvalue, and would be better translated to Unsized...\n\n    \n    \n    impl<T: Unsized> Debug for &T { fn fmt(&self, f: &mut std::fmt::Formatter<\u2018_>) { .. } }\n\n## Option: Defaults could also be disabled by supertraits?\n\nAs an interesting extension to today\u2019s system, we could say that every type\nparameter T gets an implicit Sized bound unless either...\n\n  1. There is an explicit weaker alternative(like T: DynSized or T: Unsized);\n  2. Or some other bound T: Trait has an explicit supertrait DynSized or Unsized.\n\nThis would clarify that trait aliases can be used to disable the Sized\ndefault. For example, today, one might create a Value trait is equivalent to\nDebug + Hash + Org, roughly like this:\n\n    \n    \n    trait Value: Debug + Hash + Ord { // Note that `Self` is the *only* type parameter that does NOT get `Sized` by default } impl<T: ?Sized + Debug + Hash + Ord> Value for T {}\n\nBut what if, in your particular data structure, all values are boxed and hence\ncan be unsized. Today, you have to repeat ?Sized everywhere:\n\n    \n    \n    struct Tree<V: ?Sized + Value> { value: Box<V>, children: Vec<Tree<V>>, } impl<V: ?Sized + Value> Tree<V> { ... }\n\nWith this proposal, the explicit Unsized bound could be signaled on the trait:\n\n    \n    \n    trait Value: Debug + Hash + Ord + Unsized { // Note that `Self` is the *only* type parameter that does NOT get `Sized` by default } impl<T: Unsized + Debug + Hash + Ord> Value for T {}\n\nwhich would mean that\n\n    \n    \n    struct Tree<V: Value> { ... }\n\nwould imply V: Unsized.\n\n## Alternatives\n\n### Different names\n\nThe name of the Unsized trait in particular is a bit odd. It means \u201cyou can\ntreat this type as unsized\u201d, which is true of all types, but it sounds like\nthe type is definitely unsized. I\u2019m open to alternative names, but I haven\u2019t\ncome up with one I like yet. Here are some alternatives and the problems with\nthem I see:\n\n  * Unsizeable \u2014 doesn\u2019t meet our typical name conventions, has overlap with the Unsize trait\n  * NoSize, UnknownSize \u2014 same general problem as Unsize\n  * ByPointer \u2014 in some ways, I kind of like this, because it says \u201cyou can work with this type by pointer\u201d, which is clearly true of all types. But it doesn\u2019t align well with the existing Sized trait \u2014 what would we call that, ByValue? And it seems too tied to today\u2019s limitations: there are, after all, ways that we can make DynSized types work by value, at least in some places.\n  * MaybeSized \u2014 just seems awkward, and should it be MaybeDynSized?\n\nAll told, I think Unsized is the best name. It\u2019s a bit wrong, but I think you\ncan understand it, and to me it fits the intuition I have, which is that I\nmark type parameters as Unsized and then I tend to just think of them as being\nunsized (since I have to).\n\n### Some sigil\n\nUnder this proposal, the DynSized and Unsized traits are \u201cmagic\u201d in that\nexplicitly declaring them as a bound has the impact of disabling a default T:\nSized bound. We could signify that in their names by having their name be\nprefixed with some sort of sigil. I\u2019m not really sure what that sigil would be\n\u2014 T: %Unsized? T: ?Unsized? It all seems unnecessary.\n\n### Drop the implicit bound altogether\n\nThe purist in me is tempted to question whether we need the default bound.\nMaybe in Rust 2027 we should try to drop it altogether. Then people could\nwrite\n\n    \n    \n    fn size_of<T: Sized>() -> usize {} fn size_of_val<T: DynSized>(t: &T) -> usize {}\n\nand\n\n    \n    \n    impl<T> Debug for &T { fn fmt(&self, f: &mut std::fmt::Formatter<\u2018_>) { .. } }\n\nOf course, it would also mean a lot of Sized bounds cropping up in surprising\nplaces. Beyond random functions, consider that every associated type today has\na default Sized bound, so you would need\n\n    \n    \n    trait Iterator { type Item: Sized; }\n\nOverall, I doubt this idea is worth it. Not surprising: it was deemed too\nannoying before, and now it has the added problem of being hugely disruptive.\n\n## Conclusion\n\nI\u2019ve covered a design to move away from ?Sized bounds and towards specialized\ntraits. There are avrious \u201cpros and cons\u201d to this proposal but one aspect in\nparticular feels common to this question and many others: when do you make two\n\u201csimilar but different\u201d concepts feel very different \u2014 e.g., via special\nsyntax like T: ?Sized \u2014 and when do you make them feel very similar \u2014 e.g.,\nvia the idea of \u201cspecial traits\u201d where a bound like T: Unsized has extra\nmeaning (disabling defaults).\n\nThere is a definite trade-off here. Distinct syntax help avoid potential\nconfusion, but it forces people to recognize that something special is going\non even when that may not be relevant or important to them. This can deter\nfolks early on, when they are most \u201cdeter-able\u201d. I think it can also\ncontribute to a general sense of \u201cbig-ness\u201d that makes it feel like\nunderstanding the entire language is harder.\n\nOver time, I\u2019ve started to believe that it\u2019s generally better to make things\nfeel similar, letting people push off the time at which they have to learn a\nnew concept. In this case, this lessens my fears around the idea that Unsized\nand DynSized traits would be confusing because they behave differently than\nother traits. In this particular case, I also feel that ?Sized doesn\u2019t \u201cscale\nwell\u201d to default bounds where you want to pick from one of many options, so\nit\u2019s kind of the worst of both worlds \u2013 distinct syntax that shouts at you but\nwhich also fails to add clarity.\n\nUltimately, though, I\u2019m not wedded to this idea, but I am interested in\nkicking off a discussion of how we can unblock extern types. I think by now\nwe\u2019ve no doubt covered the space pretty well and we should pick a direction\nand go for it (or else just give up on extern types).\n\n  1. I still think \u201cmust move\u201d types are a good idea \u2014 but that\u2019s a topic for another post. \u21a9\ufe0e\n\n", "frontpage": false}
