{"aid": "40113543", "title": "Default Azure Credentials Under the Hood", "url": "https://nestenius.se/2024/04/18/default-azure-credentials-under-the-hood/", "domain": "nestenius.se", "votes": 1, "user": "tndata", "posted_at": "2024-04-22 12:06:07", "comments": 0, "source_title": "Default Azure Credentials Under the Hood \u2013 Tore Nestenius | Trainer and Senior Software Developer", "source_text": "Default Azure Credentials Under the Hood \u2013 Tore Nestenius | Trainer and Senior Software Developer\n\nSkip to content\n\nPrevPrevious\n\n# Default Azure Credentials Under the Hood\n\n  * April 18, 2024\n\nThe DefaultAzureCredentials is key for using Azure services, but how exactly\ndoes it work and when should you use it? In this post, we\u2019ll break down how it\noperates, its challenges, and other ways to access Azure services. This guide\nwill help you get a clearer picture of how to handle Azure authentication\nsimply and effectively.\n\n## Authenticating to Azure\n\nWhen an application wants to access resources in Azure such as storage or\ndatabases, it needs to authenticate itself. To do this, the application must\nobtain an access token from Entra ID. This token allows the application to\nsecurely access resources in Azure, such as your Azure Storage Account.\n\nAlternative ways to access resources exist, such as using Shared Access\nSignature (SAS) tokens, but that is beyond the scope of this blog post.\n\nFor example, to access Azure BlobStorage, a TokenCredential is required during\nclient creation. This ensures secure access by authorized users. Here\u2019s an\nexample of that:\n\n    \n    \n    TokenCredential credentials = ??HowToCreate??; var client = new BlobServiceClient(new Uri(\"https://myblogstorage.blob.core.windows.net\"), credentials);\n\n## What does the TokenCredential class represent?\n\nThe TokenCredentials type in C# is an abstract base class that contains two\nmethods to request an access token:\n\n    \n    \n    /// <summary> /// Represents a credential capable of providing an OAuth token. /// </summary> public abstract class TokenCredential { /// <summary> /// Gets an Azure.Core.AccessToken for the specified set of scopes. /// </summary> /// <returns>A valid Azure.Core.AccessToken.</returns> public abstract ValueTask<AccessToken> GetTokenAsync(TokenRequestContext requestContext, CancellationToken cancellationToken); public abstract AccessToken GetToken(TokenRequestContext requestContext, CancellationToken cancellationToken); }\n\nMicrosoft provides many types that implement this abstract class, including:\n\n    \n    \n    var c1 = new AuthorizationCodeCredential(tenantId: \"\", clientId: \"\", clientSecret: \"\", authorizationCode: \"\"); var c2 = new AzureCliCredential(); var c3 = new AzureDeveloperCliCredential(); var c4 = new AzurePowerShellCredential(); var c5 = new ChainedTokenCredential(); var c6 = new ClientAssertionCredential(tenantId: \"\", clientId: \"\", assertionCallback: x => Task.FromResult(\"\")); var c7 = new ClientCertificateCredential(tenantId: \"\", clientId: \"\", clientCertificatePath: \"\"); var c8 = new ClientSecretCredential(tenantId: \"\", clientId: \"\", clientSecret: \"\"); var c9 = new DefaultAzureCredential(); var c10 = new DeviceCodeCredential(); var c11 = new EnvironmentCredential(); var c12 = new InteractiveBrowserCredential(); var c13 = new ManagedIdentityCredential(); var c14 = new OnBehalfOfCredential(tenantId: \"\", clientId: \"\", clientSecret: \"\", userAssertion: \"\"); var c15 = new SharedTokenCacheCredential(); var c16 = new UsernamePasswordCredential(username: \"\", password: \"\", tenantId: \"\", clientId: \"\"); var c17 = new VisualStudioCodeCredential(); var c18 = new VisualStudioCredential(); var c19 = new WorkloadIdentityCredential();\n\n## What do all these types do?\n\nEach TokenCredential type employs its own approach to acquiring the access\ntoken needed to access services in Azure. Whether searching for credentials in\nyour system or launching a separate program, the key aim is to obtain this\ntoken safely and effectively, ensuring smooth and reliable access to Azure.\n\nFor example, the EnvironmentCredential type will look for credentials in one\nof these sets of environment variables:\n\n  * ClientSecret based\n\n    * AZURE_TENANT_ID\n    * AZURE_CLIENT_ID\n    * AZURE_CLIENT_SECRET\n  * UserName/Password based\n\n    * AZURE_TENANT_ID\n    * AZURE_CLIENT_ID\n    * AZURE_USERNAME\n    * AZURE_PASSWORD\n  * Certificate based\n\n    * AZURE_TENANT_ID\n    * AZURE_CLIENT_ID\n    * AZURE_CLIENT_CERTIFICATE_PATH\n    * AZURE_CLIENT_CERTIFICATE_PASSWORD\n\nThen it will use these credentials to try to acquire an access token from\nEntra ID.\n\nVisualStudioCredential is another type that attempts to launch\nMicrosoft.Asal.TokenService.exe, which is an application located in this\nfolder:\n\nC:\\Program Files\\Microsoft Visual\nStudio\\2022\\Community\\Common7\\IDE\\CommonExtensions\\Microsoft\\Asal\\TokenService\\\n\nIt is an executable that manages token-based authentication for Microsoft\nservices. It\u2019s essential for enabling secure user access to Microsoft Azure\nand Office 365, and it is also utilized by Visual Studio to authenticate users\nwith Microsoft accounts. This component facilitates secure single sign-on and\nintegrates with Entra ID.\n\nThis means that the BlobServiceClient shown before accepts any of the above\ncredentials. For example:\n\n    \n    \n    var blobUri = new Uri(\"https://myblogstorage.blob.core.windows.net\"); var client1 = new BlobServiceClient(blobUri, new AzureCliCredential()); var client2 = new BlobServiceClient(blobUri, new AzureDeveloperCliCredential()); var client3 = new BlobServiceClient(blobUri, new EnvironmentCredential()); var client4 = new BlobServiceClient(blobUri, new WorkloadIdentityCredential());\n\n## TokenCredentials in practice\n\nWe have a problem: depending on where our app executes, we need to use\ndifferent TokenCredentials, depending on where it runs. This means that our\ncode might look something like this:\n\n    \n    \n    TokenCredential credentials = null; switch (environment) { case \"dev-visualstudio\": credentials = new VisualStudioCredential(); break; case \"dev-visualstudiocode\": credentials = new VisualStudioCodeCredential(); break; case \"production\": credentials = new ManagedIdentityCredential(); break; default: credentials = new AzurePowerShellCredential(); break;\n\nThis works, but it\u2019s hard to maintain; especially if we want to add more\noptions in the future, like using Azure CLI or WorkloadIdentity with\nKubernetes. We need a simpler approach that can work across different\nenvironments.\n\n## Introducing the DefaultAzureCredential type\n\nTo solve the above problem, Microsoft introduced the DefaultAzureCredential\ntype. How does it work?\n\nIt contains a predefined list of TokenCredential types, which it calls in a\nspecific sequence. DefaultAzureCredential systematically checks each one on\nthis list until it successfully finds a matching set of credentials in your\nenvironment, as shown in the following picture:\n\nBy using this credential type instead of the others, you don\u2019t need to worry\nabout having to specify what credentials to use, as shown in this example\nbelow:\n\n    \n    \n    var client = new BlobServiceClient( new Uri(\"https://myblogstorage.blob.core.windows.net\"), new DefaultAzureCredential());\n\nThe above code will automatically work well in most environments because it\ntries to locate a valid set of credentials and then retrieve a valid access\ntoken.\n\n## What happens if it can\u2019t find any credentials?\n\nThe first thing you notice is that it is slow! It will take 3-8 seconds to\nexecute all the TokenCredentials on a machine without credentials.\n\nAn exception is thrown when it can\u2019t find any valid credentials, and you can\nsee the details in the debugger foreach failed attempt:\n\nThere is a built-in option to disable specific TokenCredentials, like this:\n\n    \n    \n    var options = new DefaultAzureCredentialOptions { ExcludeAzureCliCredential = true, ExcludeVisualStudioCodeCredential = true //.. }; var cred = new DefaultAzureCredential(options); ...\n\n## Caching of the access token\n\nIt\u2019s best to create a single instance of DefaultAzureCredential and reuse it\nthroughout your application. This approach is more efficient because it\nleverages the credential\u2019s internal token cache, reducing the need for\nrepeated authentication calls.\n\nFor example:\n\n    \n    \n    // Create a shared DefaultAzureCredential instance var sharedCredential = new DefaultAzureCredential(); // Use this shared instance wherever needed var client1 = new BlobServiceClient(new Uri(\"https://example.blob.core.windows.net\"), sharedCredential); var client2 = new SecretClient(new Uri(\"https://example.vault.azure.net\"), sharedCredential); ...\n\n## What does the access token look like?\n\nA sample access token can look like this:\n\n    \n    \n    { \"aud\": \"https://storage.azure.com/\", \"iss\": \"https://sts.windows.net/567d82a1-7f61-4da2-b955-xxxxxxxxxxxx/\", \"iat\": 1712047403, \"nbf\": 1712047403, \"exp\": 1712051303, \"aio\": \"E2NgYKh17fZg9vvfwCmWxW+7xxxxxx==\", \"appid\": \"9bfc7d58-9841-415c-9b60-xxxxxxxxxxxx\", \"appidacr\": \"1\", \"idp\": \"https://sts.windows.net/567d82a1-7f61-4da2-b955-xxxxxxxxxxxx/\", \"oid\": \"1e7e2541-1297-4e1a-8b15-xxxxxxxxxxxx\", \"rh\": \"0.AQwAoYJ9VmF_ok25VdMkTqbpdoGmBuTU86hCkLxxxxxxxxxxxx.\", \"sub\": \"1e7e2541-1297-4e1a-8b15-xxxxxxxxxxxx\", \"tid\": \"567d82a1-7f61-4da2-b955-xxxxxxxxxxxx\", \"uti\": \"NpJBNp_iWUql96nbQP4xQA\", \"ver\": \"1.0\", \"xms_tdbr\": \"EU\" }\n\nThe access token above has a lifetime of 65 minutes, and the library will be\nin charge of refreshing it when needed.\n\n## How do I know which credential was used?\n\nYou might have several credentials saved on your computer. Sometimes, this can\ncause a problem where the wrong one gets used, leading to access issues that\ncan be tricky to figure out. Enabling logging is one approach to knowing which\none was used.\n\nBut digging through the logs is perhaps not the most optimal approach.\nUnfortunately, it does not provide any official other way to tell which\ncredential was actually used. However, using some reflection magic, we can\nextract this information using the following hack:\n\n    \n    \n    TokenCredential? GetSelectedCredentials(DefaultAzureCredential? credential) { // This is a hack to get the selected token from DefaultAzureCredential. // The goal is to get the value from this private field found inside DefaultAzureCredential: //private readonly AsyncLockWithValue<TokenCredential> _credentialLock; try { var credType = credential?.GetType(); if (credType != null) { var _credentialLockField = credType.GetField(\"_credentialLock\", System.Reflection.BindingFlags.NonPublic | System.Reflection.BindingFlags.Instance); if (_credentialLockField != null) { var _credentialLock = _credentialLockField.GetValue(cred); var _credentialLockType = _credentialLock?.GetType(); if (_credentialLockType != null) { var _valueField = _credentialLockType.GetField(\"_value\", System.Reflection.BindingFlags.NonPublic | System.Reflection.BindingFlags.Instance); if (_valueField != null) { var selectedCredential = _valueField.GetValue(_credentialLock); // Use selectedCredential here return selectedCredential as TokenCredential; } } } } return null; } catch (Exception ex) { Console.WriteLine(\"Failed to get selected credential\"); return null; } }\n\nThe above method can then be used like this:\n\n    \n    \n    var credentials = new DefaultAzureCredential(); TokenCredential? selectedCredential = GetSelectedCredentials(cred); Console.WriteLine(\"selectedCredential \" + selectedCredential.GetType().Name);\n\n## What are the problems with DefaultAzureCredential?\n\nWhile it is highly convenient and user-friendly, it also has its drawbacks. A\nnotable issue arises in debugging: pinpointing which one was used becomes\nchallenging if it selects an incorrect or unexpected credential.\n\n## What are the alternatives to DefaultAzureCredential?\n\nAn alternative is the ChainedTokenCredential type. It functions similarly to\nDefaultAzureCredential, with the key difference being that it starts with an\nempty list of TokenCredentials. With ChainedTokenCredential, you can add only\nthe credential types relevant to your needs in the order that works best for\nyou.\n\nThis approach can be particularly advantageous for production environments, as\nit puts you in complete control and limits the credentials to only those you\nactively use.\n\nFor instance, you could set it up like this:\n\n    \n    \n    var cred = new ChainedTokenCredential(new EnvironmentCredential(), new ManagedIdentityCredential(), new VisualStudioCodeCredential()); ...\n\n## Logging and diagnostics\n\nA simple way to get insights into what happens under the hood is to add the\nfollowing code to the start of your application:\n\n    \n    \n    var listener = new AzureEventSourceListener((e, message) => { Console.WriteLine(e.EventSource.Name); if (e.EventSource.Name.StartsWith(\"Azure\")) { Console.WriteLine($\"{DateTime.Now} {message}\"); } }, level: EventLevel.Verbose); var totalTimeSw = new Stopwatch(); totalTimeSw.Start();\n\nThis allows you to capture the internal events produced by the Azure\nlibraries, which can give you valuable insights into their inner workings.\n\n## Final gotcha\n\nA common issue encountered with these credential helpers revolves around the\nTenantId. Often, difficulties with these types stem from a missing TenantId.\nTo mitigate this, the TenantId can typically be specified through an optional\noptions object or by setting environment variables. For instance, when using\nVisualStudioCredential:\n\n    \n    \n    var options = new VisualStudioCredentialOptions() { TenantId = \"xxxxx\" }; var credentials = new VisualStudioCredential(options);\n\n## Summary\n\nWriting this blog post has been a great learning experience for me. It\u2019s\nhelped me better understand TokenCredential types, especially about when to\nuse DefaultAzureCredential and ChainedTokenCredential.\n\nI gained deeper insights by downloading the Azure Identity source code from\nGitHub and turning it into my own class library. With this in place, I could\nadd my own logging and diagnostic code. These additions really helped me get a\nbetter grasp of how everything functions.\n\n## Feedback, comments, found any bugs?\n\nLet me know if you have any feedback, anything I missed or any bugs/typos. You\ncan find my contact details here.\n\n## About the author\n\nHi, I\u2019m Tore! I have been fascinated by computers since I unpacked my first\nCommodore VIC-20. Today, I enjoy providing freelance development and developer\ntraining services, focusing on ASP.NET Core, IdentityServer, OpenID Connect,\nArchitecture, and Web Security. You can connect with me on LinkedIn and\nTwitter, and you can find out more about me and my services here, as well as\nmy courses for developers, including my course, Introduction to IdentityServer\nand OpenID-Connect.\n\n## Related posts by me:\n\n  * Persisting the ASP.NET Core Data Protection Keys Ring in Azure Key Vault\n  * Exploring what is inside the ASP.NET Core cookies\n  * Demystifying OpenID Connect\u2019s State and Nonce Parameters in ASP.NET Core\n\nShare This Story\n\nShare on linkedin\n\nShare on twitter\n\nShare on facebook\n\nShare on pinterest\n\nShare on email\n\n## Related Posts\n\n### Introducing the Data Protection API Key Ring Debugger\n\nRead More \u00bb\n\n### Persisting the ASP.NET Core Data Protection Key Ring in Azure Key Vault\n\nRead More \u00bb\n\n### Improving ASP.NET Core Security By Putting Your Cookies On A Diet\n\nRead More \u00bb\n\n## About me\n\nMy name is Tore Nestenius and I\u2019m a trainer and senior software developer\nfocusing on Architecture, Security and Identity, .NET, C#, Backend, and Cloud,\namong other things.\n\n## Do You Want Tore To Be Your Mentor?\n\nHire Me\n\n##### Categories\n\nCopyright \u00a9 Tore Nestenius\n\n", "frontpage": false}
