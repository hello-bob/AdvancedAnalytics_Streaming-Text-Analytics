{"aid": "40247574", "title": "A tale of making a company-wide psqlrc to use with pgbouncer. (2021)", "url": "https://www.depesz.com/2021/06/23/a-tale-of-making-company-wide-standard-psqlrc/", "domain": "depesz.com", "votes": 2, "user": "fanf2", "posted_at": "2024-05-03 13:42:03", "comments": 0, "source_title": "A tale of making company-wide standard psqlrc", "source_text": "A tale of making company-wide standard psqlrc \u2013 select * from depesz;\n\nSkip to content\n\n#\n\n=$\n\n|\n\n# A tale of making company-wide standard psqlrc\n\nAt a company we have literally thousands of Pg servers. The layout is also\nkinda non-obvious. Each database is named the same, but contains different\ndata. And in front of it all, we have pgbouncers.\n\nAfter some talk, it was suggested that perhaps we could make psql prompt show\nwhich database it is connected to. And perhaps some more information, like\nbackend pid. I thought it will be simple...\n\nFor starters \u2013 we have a function defined, named dba.smi which returns a bit\nof trivia about the server we run it on. It's based on text files that exist\non the filesystem and contain information like:\n\n  * project name\n  * environment (production, beta, test)\n  * cluster (in our case cluster is simply a number (usually). Each cluster means at least 3 separate databases: primary, secondary, and report. For historical reasons source data is using old vocabulary: master, slave, and backup.\n\nAll of these can be fetched with calls to dba.smi(), and every user in system\ncan call this function. Great. Trivial task. Wrote psqlrc like this:\n\n    \n    \n    SELECT dba.smi('aws_tag_project') AS project, dba.smi('aws_tag_environment') AS env, dba.smi('aws_tag_cluster') AS cluster, dba.smi('aws_tag_pgrole') AS pgrole \\gset smi_ \\SET PROMPT1 '%`date +%H:%M:%S` %:smi_project: %:smi_env:, cluster %:smi_cluster:, %:smi_pgrole: db: %n@%/, pid:%p\\n%x%R%# '\n\nAfter loading it, I got beautiful prompt:\n\n    \n    \n    15:39:31 magic production, cluster 1, backup db: depesz-rw@appdb, pid:22025 =>\n\nTested it on database server connected to app database, all works well.\nSuccess.\n\nWell, no. when I connected to another database, like postgres, I got:\n\n    \n    \n    psql:/home/depesz/.psqlrc:5: ERROR: schema \"dba\" does NOT exist LINE 2: dba.smi('aws_tag_project') AS project, ^ 15:41:22 , cluster , db: depesz-rw@postgres, pid:23229 =>\n\nWell, that ain't nice. I tried to hide it with adding \\set QUIET in the\nbeginning, and \\unset QUIET at the end, but it didn't help.\n\nLuckily, psql has conditionals. So I can first check if the function is there.\nWhile working on it I also discovered that smi returns old names of pgroles,\nso I have to map it to new ones. Trivial. New version:\n\n    \n    \n    \\SET QUIET SELECT EXISTS( SELECT 1 FROM pg_proc p JOIN pg_namespace n ON p.pronamespace = n.oid WHERE p.proname = 'smi' AND n.nspname = 'dba' ) \\gset smi_ \\IF :smi_exists SELECT dba.smi('aws_tag_project') AS project, dba.smi('aws_tag_environment') AS env, dba.smi('aws_tag_cluster') AS cluster, CASE dba.smi('aws_tag_pgrole') WHEN 'master' THEN 'primary' WHEN 'slave' THEN 'secondary' WHEN 'backup' THEN 'report' ELSE dba.smi('aws_tag_pgrole') END AS pgrole \\gset smi_ \\SET PROMPT1 '%`date +%H:%M:%S` %:smi_project: %:smi_env:, cluster %:smi_cluster:, %:smi_pgrole: db: %n@%/, pid:%p\\n%x%R%# ' \\ELSE \\SET PROMPT1 '%`date +%H:%M:%S` db: %n@%/, pid:%p\\n%x%R%# ' \\endif \\unset QUIET\n\nAmazing. Now, when I try to connect to database that doesn't have dba.smi(), I\njust get plain prompt:\n\n    \n    \n    16:04:14 db: depesz-rw@postgres, pid:5144 =>\n\nAll is well, and am ready to push to production. Just sanity check, I'll\nconnect, like any user would, through a pgbouncer, that's just formality.\nRight? Not quite:\n\n    \n    \n    16:05:40 magic production, cluster 1, report db: depesz-rw@appdb, pid:830285059 =>\n\nWell, it looks OK, but the pid is definitely incorrect. Apparently whatever\npsql displays as pid (%p) is not really pid when connecting through pgBouncer.\n\nLuckily, that is simple to work around. I will just get the pid using select\nquery:\n\n    \n    \n    SELECT pg_backend_pid() \\gset\n\nand then, instead of %p, will use %:pg_backend_pid:.\n\nSimple, and works.\n\nBut then it hit me: what will happen if I will connect to the special,\nmagical, pgbouncer database? Users don't do it, but I might. In case you don't\nknow \u2013 when you connect through pgbouncer, there is special \u201cdatabase\" named\npgbouncer where you can connect, and display some info from pgbouncer itself.\nBasically admin interface for pgbouncer.\n\nSurely it will work, right? Well, no:\n\n    \n    \n    psql:/home/depesz/.psqlrc:3: ERROR: invalid command 'SELECT pg_backend_pid() ', USE SHOW HELP; psql:/home/depesz/.psqlrc:10: ERROR: invalid command 'select EXISTS( SELECT 1 from pg_proc p join pg_namespace n on p.pronamespace = n.oid where p.proname = 'smi' and n.nspname = 'dba' ) ', USE SHOW HELP; psql:/home/depesz/.psqlrc:12: error: unrecognized VALUE \":smi_exists\" FOR \"\\if expression\": BOOLEAN expected\n\nApparently this magical pgbouncer database doesn't handle selects. At all:\n\n    \n    \n    =# SELECT 1; ERROR: invalid command 'select 1;', USE SHOW HELP;\n\nWell, OK. But that's simple. I will just check if database name is pgbouncer,\nand if yes \u2013 use simpler prompt. And when it's not \u2013 use normal code.\n\npsql even helpfully has DBNAME variable, so it should be easy. Right?\n\n    \n    \n    =# \\IF :DBNAME = pgbouncer unrecognized VALUE \"pgbouncer = pgbouncer\" FOR \"\\if expression\": BOOLEAN expected\n\nApparently psql's \\if expression can only parse single value, and it has to be\none of: true, false, 1, 0, on, off, yes, no.\n\nSo, how to get one of these, let's say 1/0, if the dbname is pgbouncer? I\ncan't use select. I can't use logic in \\if.... cue despair.\n\nLuckily, in docs I found this bit:\n\n> The expression argument of an \\if or \\elif command is subject to variable\n> interpolation and backquote expansion\n\nbackquote. So I can call shell! Solution became obvious:\n\n    \n    \n    \\IF `test :DBNAME = pgbouncer && echo 1 || echo 0`\n\nthis requires that we have test program installed, but it's by default\neverywhere, so I don't care. Much.\n\nSo, all things said, finally the psqlrc is:\n\n    \n    \n    -- Hide confirmation messages \\SET QUIET -- Check if we're connecting to database pgbouncer. It is very limited, and can't run SELECT's \\IF `test :DBNAME = pgbouncer && echo 1 || echo 0` -- This is pgbouncer. User plain prompt \\SET PROMPT1 '%`date +%H:%M:%S` db: %n@%/\\n%x%R%# ' \\ELSE -- This isn't pgbouncer. So we should have SELECTs available -- If we're connecting through pgbouncer, then prompt's %p is not real, so get real PID SELECT pg_backend_pid() \\gset -- Check if there is dba.smi() function SELECT EXISTS(SELECT 1 FROM pg_proc p JOIN pg_namespace n ON p.pronamespace = n.oid WHERE p.proname = 'smi' AND n.nspname = 'dba') \\gset smi_ \\IF :smi_exists -- If dba.smi() exists, get data from it, and put it in prompt. SELECT dba.smi('aws_tag_project') AS project, dba.smi('aws_tag_environment') AS env, dba.smi('aws_tag_cluster') AS cluster, CASE dba.smi('aws_tag_pgrole') WHEN 'master' THEN 'primary' WHEN 'slave' THEN 'secondary' WHEN 'backup' THEN 'report' ELSE dba.smi('aws_tag_pgrole') END AS pgrole \\gset smi_ \\SET PROMPT1 '%`date +%H:%M:%S` %:smi_project: %:smi_env:, cluster %:smi_cluster:, %:smi_pgrole: db: %n@%/, pid:%:pg_backend_pid:\\n%x%R%# ' \\ELSE -- If dba.smi() is not available, pick simpler prompt \\SET PROMPT1 '%`date +%H:%M:%S` db: %n@%/, pid:%:pg_backend_pid:\\n%x%R%# ' \\endif \\endif -- Common settings, regardless of dba.smi() existence \\SET PROMPT2 '%R%# ' \\pset NULL '[null]' -- Use sensible pager \\pset pager always \\setenv PAGER 'less -iMFXSx4R' -- It's 21st century, let's use unicode for borders \\pset linestyle unicode -- Stop hiding confirmation messages \\unset QUIET -- vim: set ft=sql:\n\nand it does what I wanted it to do. Installed it as /etc/postgresql-\ncommon/psqlrc everywhere, and it works.\n\nWhen I showed it to colleague, he said: I had no idea psqlrc files could be so\ncomplex. And this kinda prompted me to write this blogpost. They (psqlrcs)\ncan. They can do a lot of things, and if writing them doesn't seem simple \u2013\nit's because we rarely do. But, I think, it's worth it.\n\nPosted on 2021-06-232021-06-23|Tags pgbouncer, postgresql, psql, psqlrc|\n\n## 4 thoughts on \u201cA tale of making company-wide standard psqlrc\u201d\n\n  1. Ale\u0161 says:\n\n2021-06-25 at 07:47\n\nExcellent article!\n\n  2. Berend de Boer says:\n\n2021-06-26 at 07:44\n\nLooked really cool, but when I tried this I got:\n\npsql:/etc/postgresql-common/psqlrc:2: error: invalid command \\SET\npsql:/etc/postgresql-common/psqlrc:5: error: invalid command \\IF\npsql:/etc/postgresql-common/psqlrc:8: error: invalid command \\SET\npsql:/etc/postgresql-common/psqlrc:10: error: invalid command \\ELSE\npsql:/etc/postgresql-common/psqlrc:20: error: invalid command \\IF\npsql:/etc/postgresql-common/psqlrc:31: ERROR: schema \u201cdba\u201d does not exist LINE\n2: dba.smi(\u2018aws_tag_project\u2019) AS project, ^ psql:/etc/postgresql-\ncommon/psqlrc:32: error: invalid command \\SET psql:/etc/postgresql-\ncommon/psqlrc:33: error: invalid command \\ELSE psql:/etc/postgresql-\ncommon/psqlrc:35: error: invalid command \\SET psql:/etc/postgresql-\ncommon/psqlrc:36: error: \\endif: no matching \\if psql:/etc/postgresql-\ncommon/psqlrc:38: error: \\endif: no matching \\if psql:/etc/postgresql-\ncommon/psqlrc:41: error: invalid command \\SET psql:/etc/postgresql-\ncommon/psqlrc:42: error: \\pset: unknown option: NULL Pager is always used.\nLine style is unicode. psql (13.3 (Ubuntu 13.3-0ubuntu0.21.04.1), server 12.6\n(Ubuntu 12.6-0ubuntu0.20.10.1))\n\n  3. Berend de Boer says:\n\n2021-06-26 at 07:50\n\nOK figured it out, your code use \\SET where it should say \\set lowercase.\n\n  4. depesz says:\n\n2021-06-27 at 10:26\n\n@Berend: sorry, this is becaue of wp-geshi-syntax plugin for syntax\nhighlighting. Looked for solution, and I think I found it. It should no longer\nbe broken.\n\nIn case someone found this by googling \u2013 to disable uppercaseing of keywords\nin wp-geshi-syntax, you have to edit file wp-content/plugins/wp-geshi-\nhighlight/geshi/geshi/sql.php (or whatever the language you want to disable it\nfor), and change CASE_KEYWORDS to 0 or GESHI_CAPS_NO_CHANGE.\n\nComments are closed.\n\n## Search\n\n## Follow me\n\n  * Comments RSS\n  * Posts RSS\n\n## PostgreSQL\n\n  * Documentation\n  * Explain Analyze analyzer\n  * IRC help channel\n  * Mailing Lists search\n  * PG Planet\n  * PostgreSQL Home Page\n\n## About me\n\n  * CPAN\n  * GitLab\n  * Linked In\n\n", "frontpage": false}
