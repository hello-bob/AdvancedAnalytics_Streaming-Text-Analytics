{"aid": "40070203", "title": "Deep Dive into Rspack and Webpack Tree Shaking \u00b7 web-infra-dev \u00b7 Discussion #17", "url": "https://github.com/orgs/web-infra-dev/discussions/17", "domain": "github.com/orgs", "votes": 1, "user": "todsacerdoti", "posted_at": "2024-04-17 21:25:10", "comments": 0, "source_title": "Deep Dive into Rspack & Webpack Tree Shaking \u00b7 web-infra-dev \u00b7 Discussion #17", "source_text": "Deep Dive into Rspack & Webpack Tree Shaking \u00b7 web-infra-dev \u00b7 Discussion #17\n\u00b7 GitHub\n\nSkip to content\n\nSign in\n\nweb-infra-dev\n\n# Search code, repositories, users, issues, pull requests...\n\nSearch syntax tips\n\nSign in\n\nSign up\n\nYou signed in with another tab or window. Reload to refresh your session. You\nsigned out in another tab or window. Reload to refresh your session. You\nswitched accounts on another tab or window. Reload to refresh your session.\nDismiss alert\n\n# Web Infra\n\n# Deep Dive into Rspack & Webpack Tree Shaking #17\n\nhardfist started this conversation in Deep Dive\n\nDeep Dive into Rspack & Webpack Tree Shaking #17\n\nhardfist\n\nApr 17, 2024 \u00b7 0 comments\n\nReturn to top\n\nDiscussion options\n\n##\n\nhardfist\n\nApr 17, 2024\n\nMaintainer\n\nOriginal comment in English -\n\nThis article primarily focuses on understanding the concept of Webpack Tree\nShaking rather than delving deeply into the underlying code implementation.\nCode examples can be found at https://github.com/hardfist/treeshaking-\ncases.One of the challenging aspects of Webpack Tree Shaking is that it\ninvolves multiple optimizations working together. Webpack's own use of the\nterm \"Tree Shaking\" is somewhat inconsistent, often broadly referring to\noptimizations for dead code elimination. Tree Shaking is defined as:\n\n    \n    \n    Tree shaking is a term commonly used in the JavaScript context for dead-code elimination. It relies on the static structure of ES2015 module syntax, i.e. import and export. The name and concept have been popularized by the ES2015 module bundler rollup.\n\nIn some contexts, optimizations like usedExports are referred to under the\numbrella of tree shaking & sideEffects:\n\n    \n    \n    The sideEffects and usedExports (more known as tree shaking) optimizations are two different things.\n\nTo avoid any ambiguity in understanding Tree Shaking, this discussion will not\nfocus on Tree Shaking itself but rather on the various code optimizations\nunder the category of Webpack Tree Shaking.Webpack Tree Shaking primarily\ninvolves three types of optimizations:\n\n  1. usedExports Optimization: This involves removing unused export variables from modules, thereby further eliminating related side-effect-free statements.\n  2. sideEffects Optimization: This removes modules from the module graph where export variables are not used.\n  3. DCE (Dead Code Elimination) Optimization: This is typically implemented by general minification tools to remove dead code, although similar functionalities can also be achieved by tools like Webpack's ConstPlugin.\n\nThese optimizations operate on different dimensions: usedExports focuses on\nexport variables, sideEffects on entire modules, and DCE on JavaScript\nstatements.Consider the following example:\n\n  * In lib.js, variable b is unused, and related code does not appear in the final output due to usedExports optimization.\n  * In util.js, no export variables are used, resulting in the absence of the util module in the final output, which is a result of sideEffects optimization.\n  * In bootstrap.js, the console.log statement will not execute, and thus is removed in the final output, demonstrating DCE optimization.\n\n    \n    \n    // index.js import { a } from './lib'; import { c } from './util'; import './bootstrap'; console.log(a); // lib.js export const a = 1; export const b = 2; // util.js export const c = 3; export const d = 4; // bootstrap.js console.log('bootstrap'); if(false){ console.log('bad'); }else { console.log('good'); }\n\nThese optimizations are implemented independently but can influence each\nother. Below, we detail these optimizations and their interrelationships.\n\n## DCE Optimization\n\nDCE is relatively straightforward in Webpack, with two important scenarios:\n\n### False Branch\n\n    \n    \n    if(false){ false_branch; } else { true_branch; }\n\nHere, because the false_branch will never execute, it can be directly removed.\nThis has two effects: reducing the final code size and affecting the usage\nrelationships of variables. Consider the following example:\n\n    \n    \n    import { a } from './a'; if(false){ console.log(a); }else { }\n\nIf the false_branch is not removed, variable a would be considered used.\nRemoving it marks a as unused, which can further influence analyses for\nusedExports and sideEffects. To address this, Webpack offers two opportunities\nfor DCE:\n\n  * Through the ConstPlugin during the parsing stage, which performs a basic DCE to determine as much as possible about the usage of imported and exported variables, thereby enhancing subsequent sideEffect and usedExport optimizations.\n  * Through Terser's minify during the processAssets stage for more complex DCE, primarily aimed at reducing code size.\n\nTerser's DCE is more time-consuming and intricate, whereas the ConstPlugin's\noptimization is simpler. For example, a false branch handled by Terser can be\nsuccessfully removed, but the ConstPlugin might not manage it.\n\n    \n    \n    function get_one(){ return 1; } let res = get_one() + get_one(); if(res != 2){ console.log(c); }\n\n### Unused Top Level Statement\n\nIn modules, if a top-level statement is not exported, it can also be removed\nbecause it does not bring additional side effects. For example, b and test in\nthe following can be safely deleted (assuming this is a module and not a\nscript, as scripts would pollute the global scope and cannot be safely\nremoved). Webpack's usedExports optimization leverages this characteristic to\nsimplify its implementation.\n\n    \n    \n    // index.js export const a = 10; const b = 20; function test(){ }\n\n## usedExports Optimization\n\nCompared to similar optimizations by other bundlers, Webpack's usedExports\noptimization is quite clever. It uses the active status of dependencies to\ndetermine whether variables within a module are used. Then, during the code\ngeneration phase, if an export variable is unused, it does not generate\ncorresponding export properties, thereby making the code segments that depend\non the export variable dead code. This is further aided by subsequent\nminification for DCE.Webpack enables usedExports optimization through the\noptimization.usedExports configuration. Consider the following example:\n\n    \n    \n    // index.js import { a } from './lib'; console.log({a}); // lib.js export const a = 1; export const b = 2;\n\nWithout tree shaking enabled, you can see that the output contains information\nabout b:\n\n    \n    \n    var __webpack_modules__ = [ , (__unused_webpack_module, __webpack_exports__, __webpack_require__) => { __webpack_require__.r(__webpack_exports__); __webpack_require__.d(__webpack_exports__, { a: () => a, b: () => b // b is not removed }); const a = 1; const b = 2; } ];\n\nWhen optimization.usedExports is enabled, you see that the export of b is\nremoved, but const b = 1 still exists. However, since b is unused, const b = 1\nalso becomes dead code:\n\n    \n    \n    /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => { /* harmony export */ __webpack_require__.d(__webpack_exports__, { /* harmony export */ a: () => (/* binding */ a) /* harmony export */ }); /* unused harmony export b */ const a = 1; const b = 2; // this is actually dead code /***/ })\n\nFurther enabling compression with optimization.usedExports, the const b = 1 is\nremoved because it is dead code:\n\n    \n    \n    (__unused_webpack_module, __webpack_exports__, __webpack_require__) => { __webpack_require__.d(__webpack_exports__, { a: () => a }); const a = 1; }, __webpack_module_cache__ = {};\n\nHowever, analyzing whether b is used is not always straightforward. Consider\nthe following case:\n\n    \n    \n    // index.js import { a,b } from './lib'; console.log({a}); function test(){ console.log(b); } function test1(){ test(); } // lib.js export const a = 1; export const b = 2;\n\nHere, b is used by the function test, so we find that b is not directly\nremoved from the output. This is because Webpack does not perform deep static\nanalysis by default. Although test is unused, implying b is also unused,\nWebpack does not deduce this relationship:\n\n    \n    \n    (__unused_webpack_module, __webpack_exports__, __webpack_require__) => { __webpack_require__.d(__webpack_exports__, { a: () => a, b: () => b }); const a = 1, b = 2; }, __webpack_module_cache__ = {}\n\nFortunately, Webpack offers another configuration, optimization.innerGraph,\nwhich allows for deeper static analysis of the code. This can determine that b\nis not used, thus successfully removing the export property of b:\n\n    \n    \n    ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => { /* harmony export */ __webpack_require__.d(__webpack_exports__, { /* harmony export */ a: () => (/* binding */ a) /* harmony export */ }); /* unused harmony export b */ const a = 1; const b = 2; /***/ })\n\nDCE also impacts usedExports optimization. Consider the following case:\n\n    \n    \n    // index.js import { a, b, c } from './lib'; console.log({a}); if(false){ console.log(b); } function get_one(){ return 1; } let res = get_one() + get_one(); if(res != 2){ console.log(c); } // lib.js export const a = 1; export const b = 2; export const c = 3;\n\nReliant on Webpack's internal ConstPlugin for DCE, it successfully removes b,\nbut due to the limited capability of ConstPlugin, it fails to remove c.\n\n    \n    \n    ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => { /* harmony export */ __webpack_require__.d(__webpack_exports__, { /* harmony export */ a: () => (/* binding */ a), /* harmony export */ c: () => (/* binding */ c) /* harmony export */ }); /* unused harmony export b */ const a = 1; const b = 2; const c = 3; /***/ })\n\n## sideEffects Optimization\n\nWhile usedExports optimization focuses on optimizing export variables,\nsideEffects optimization is more thorough and efficient, targeting the removal\nof entire modules. For a module to be safely removed, it must meet two\nconditions: none of its export variables are used, and the module must be\nside-effect-free.Webpack enables sideEffects optimization through the\noptimization.sideEffects configuration. Let's look at a simple example:\n\n    \n    \n    // index.js import { a } from './lib'; import { c } from './util'; console.log({a}); // lib.js export const a = 1; export const b = 2; // util.js export const c = 123; export const d = 456;\n\nWithout optimization.sideEffects enabled, the output retains the util module:\n\n    \n    \n    /***/ \"./src/lib.js\": /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => { __webpack_require__.r(__webpack_exports__); /* harmony export */ __webpack_require__.d(__webpack_exports__, { /* harmony export */ a: () => (/* binding */ a), /* harmony export */ b: () => (/* binding */ b) /* harmony export */ }); const a = 1; const b = 2; /***/ }), /***/ \"./src/util.js\": /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => { __webpack_require__.r(__webpack_exports__); /* harmony export */ __webpack_require__.d(__webpack_exports__, { /* harmony export */ c: () => (/* binding */ c), /* harmony export */ d: () => (/* binding */ d) /* harmony export */ }); const c = 123; const d = 456; /***/ })\n\nWhen optimization.sideEffects is enabled, util.js is removed from the output.\nThis occurs because util meets both conditions required for removal. Let's\nexplore what happens when we violate each condition:First, introduce side\neffects in util.js:\n\n    \n    \n    export const c = 123; export const d = 456; console.log('hello');\n\nThis change causes util.js to reappear in the output. Now, revert that change\nand modify index.js to use variable c from util.js:\n\n    \n    \n    import { a } from './lib'; import { c } from './util'; console.log({a}, c);\n\nThis modification also causes util.js to reappear in the output. These\nexperiments demonstrate that both conditions must be met for a module to be\nsafely removed. Ensuring these conditions are met is crucial for effectively\nleveraging sideEffect optimizations in practical applications.Let's revisit\nthe two conditions necessary for the safe removal of a module:\n\n### Unused Export Variables\n\nThis condition, while seemingly straightforward, encounters similar challenges\nto those found in usedExports optimization and may require extensive analysis\nto determine how a variable is used.Consider the following example, where c is\nused within the function test, preventing the successful removal of util.js:\n\n    \n    \n    // index.js import { a } from './lib'; import { c } from './util'; console.log({a}); function test(){ console.log(c); } // lib.js export const a = 1; export const b = 2; // util.js export const c = 123; export constd = 456;\n\nWhen we enable optimization.innerGraph, Webpack conducts a deeper analysis and\ndetermines that test is also unused, which implies that c is unused as well,\nallowing for the correct removal of util.js.\n\n### sideEffects Property\n\nCompared to whether a variable is used, determining if a module has side\neffects is a more complex process. Consider the following modification to\nutil.js:\n\n    \n    \n    export const c = 123; export const d = test(); function test(){ return 456; }\n\nIn this case, although the function test is a side-effect-free function call,\nWebpack is unable to determine this and still considers the module as\npotentially having side effects. As a result, util.js is included in the final\noutput.To inform Webpack that test has no side effects, two approaches are\navailable:\n\n  1. Pure Annotation: By marking the function call with a pure annotation, you indicate that the function has no side effects:\n\n    \n    \n    export const c = 123; export const d = /*#__PURE__*/ test(); function test(){ return 456; }\n\n  2. sideEffects Property: When a module contains numerous top-level statements, marking each with a pure annotation can be cumbersome and error-prone. Thus, Webpack introduced the sideEffects property to label the entire module as side-effect-free. Adding \"sideEffects\": false to the module's package.json allows util.js to be safely removed:\n\n    \n    \n    // package.json { \"sideEffects\": false }\n\nHowever, a challenge arises when a module marked as sideEffect: false depends\non another module marked as sideEffect: true. Consider the scenario where\nbutton.js imports button.css, with button.js being sideEffects: false and\nbutton.css being sideEffects: true:\n\n    \n    \n    // package.json { \"sideEffects\": [\"**/*.css\", \"**/side-effect.js\"] } // a.js import { Button } from 'antd'; // index.js import { Button } from './button'; // button.js import './button.css'; import './side-effect'; export const Button = () => { return `<div class=\"button\">btn</div>` } // button.css .button { background-color: red; } // side-effects.js console.log('side-effect');\n\nIf sideEffects were only marking the current module for side effects,\naccording to ESM standards, because button.css and side-effect.js have side\neffects, they should be bundled. However, Webpack's output does not include\nbutton.css or side-effect.js.Therefore, the true meaning of the sideEffects\nfield is:sideEffects is much more effective since it allows to skip whole\nmodules/files and the complete subtree. -> sideEffectIf a module is marked as\nsideEffect: false, it implies that if the module's export variables are\nunused, then the module and its entire subtree can be safely removed. This\nexplanation clarifies why, in the given example, both button.js and its\nsubtree (including button.css and side-effect.js) can be safely deleted, which\nis particularly useful in the context of component libraries.Unfortunately,\nthis behavior varies across different bundlers. Testing has shown:\n\n  * Webpack: Safely deletes side-effect-laden CSS and JS in the subtree.\n  * esbuild: Deletes side-effect-laden JS in the subtree but not CSS.\n  * Rollup: Does not delete side-effect-laden JS in the subtree (does not handle CSS).\n\n### Barrel Module\n\nSideEffects optimization can optimize not only leaf node modules but also\nintermediate nodes. Consider a common pattern where a module re-exports the\ncontents of other modules. If such a module itself (here referred to as mid)\ndoes not have any of its export variables used and only serves to re-export\nother modules' content, is it necessary to retain the re-export module?\n\n    \n    \n    // index.js import { Button } from './components'; console.log('button:', Button); // components/index.js export * from './button'; export * from './tab'; export const mid = 'middle'; // components/button.js export const Button = () => 'button';\n\nTesting shows that Webpack directly deletes the re-export module, and in\nindex.js, it directly imports the content from button.js\n\n    \n    \n    (() => { __webpack_require__.r(__webpack_exports__); var _components__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(\"./src/components/button.js\"); console.log(\"button:\", _components__WEBPACK_IMPORTED_MODULE_0__.Button); })();\n\nThis behavior appears as if the source code's import path was directly\nmodified:\n\n    \n    \n    - import { Button } from './components'; + import { Button } from './components/button';\n\nFrameworks like Next.js and UmiJS also offer similar optimizations Optimize\nPackage Imports. Their approach involves rewriting these paths at the loader\nstage. It\u2019s important to note that while Webpack\u2019s barrel optimization focuses\non the output, it still builds components/index.js and its sub-dependencies\nduring the build phase. However, techniques used by Next.js and others modify\nthe source code directly, meaning components/index.js does not participate in\nthe build. This can significantly optimize libraries that re-export hundreds\nor thousands of sub-modules.We also tested the behavior of esbuild and Rollup\nregarding this:\n\n  * esbuild: Deletes side effects within the barrel module. See example\n  * Rollup: Does not delete side effects within the barrel module. See example\n\n## Investigating Webpack Tree Shaking Issues\n\nA frequent issue encountered during on-call duties is \"Why has my tree shaking\nfailed?\" Troubleshooting such issues can be quite challenging. When faced with\nthis question, the first thought is typically \"Which of the tree shaking\noptimizations has failed?\" This generally falls into one of three categories:\n\n### SideEffect Optimization Failure\n\nThe failure of sideEffect optimization is typically indicated by a module,\nwhose export variables are not used, being included in the bundle.A lesser-\nknown feature of Webpack is its ability to debug various optimization bailouts\nthrough stats.optimizationBailout, including reasons for sideEffect bailouts.\nConsider the following example:\n\n    \n    \n    // index.js import { a } from './lib'; import { abc } from './util'; console.log({a}); // lib.js export const a = 1; export const b = 2; // util.js export function abc(){ console.log('abc'); } export function def(){ console.log('def') } console.log('xxx');\n\nCompile with optimization.sideEffects=true and\nstats.optimizationBailout:true:Webpack's logs clearly indicate that the\nconsole.log('xxx') on line 7 of util.js caused the sideEffect optimization to\nfail, resulting in the module being included in the bundle.If we further\nconfigure sideEffects: false in package.json, this warning disappears because,\nwith the sideEffect Property set, Webpack ceases side effect analysis and\ndirectly bases sideEffect optimization on the sideEffects field.\n\n### usedExports Optimization Failure\n\nA failure in usedExports optimization manifests when an unused export variable\nstill generates export properties.In such cases, it is necessary toidentify\nwhere the export properties are being used:However, determining why and where\na variable is used can be unclear, as Webpack does not provide detailed\nrecords of this. A possible improvement for Webpack could be to track and\nreport where in the module tree specific export variables are used. This would\ngreatly facilitate the analysis and troubleshooting of usedExports\noptimization issues.\n\n### DCE (Dead Code Elimination) Optimization Failure\n\nBeyond the issues with sideEffect and usedExports optimizations, most other\ntree shaking failures can be attributed to failures in DCE. Common causes of\nDCE failure include dynamic code constructs like eval and new Function, which\ncan lead to bailout during minification. Troubleshooting these issues\ntypically relates to the minifier used and often requires bisecting the output\ncode to identify the problem. Unfortunately, current minifiers seldom provide\ndetailed reasons for bailouts, which is an area where future enhancements\ncould be beneficial.In conclusion, effective tree shaking in Webpack requires\na deep understanding of the various optimizations involved and how they\ninteract. By correctly configuring and applying these optimizations,\ndevelopers can significantly reduce the size of their bundles, enhancing\nperformance and efficiency. As Webpack and other bundling tools evolve,\nongoing learning and adjustment will be necessary to maintain optimal\napplication performance  \n---  \n  \nBeta Was this translation helpful? Give feedback.\n\nYou must be logged in to vote\n\n## Replies: 0 comments\n\nSign up for free to join this conversation on GitHub. Already have an account?\nSign in to comment\n\nCategory\n\nDeep Dive\n\nLabels\n\nNone yet\n\n1 participant\n\n## Footer\n\n\u00a9 2024 GitHub, Inc.\n\nYou can\u2019t perform that action at this time.\n\n", "frontpage": false}
