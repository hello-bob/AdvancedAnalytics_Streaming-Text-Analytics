{"aid": "40222436", "title": "Turing's Maze", "url": "https://meatfighter.com/turings-maze/", "domain": "meatfighter.com", "votes": 1, "user": "marvinborner", "posted_at": "2024-05-01 12:50:12", "comments": 0, "source_title": "Turing's Maze", "source_text": "Turing's Maze\n\nTuring\u2019s Maze\n\n[ Abstract | Description | Formal Definition | Circuits | Logic Gates | Sequential Logic | Software | Mandelbrot Set Circuit | Other Representations | Reversibility ]\n\n# Abstract\n\nTuring\u2019s Maze is a discrete-event simulation of a mouse on a two-dimensional\nsquare lattice of black, gray, red, and green cells. As the mouse interacts\nwith cells through a very simple set of rules, behaviors emerge particularly\nsuited for emulating Boolean circuits. Consequently, any algorithm can be\nimplemented as a maze traversed by the mouse.\n\nThis article describes the rules of Turing\u2019s Maze. It explains how to build\ngates, combinational logic, and sequential logic. And it demonstrates the\nmouse\u2019s ability to compute with an implementation of the Mandelbrot set\nalgorithm.\n\n# Description\n\nEach simulation state consists of the mouse on a cell, facing a cardinal\ndirection (north, east, south, or west). The mouse may change direction and\nits cell color according to rules described below. Then the mouse moves\nforward to an adjacent cell, transitioning the simulation to the next state.\n\nThe mouse can move to cells of any color except for gray, which act as the\nwalls of the maze. Passages primarily consist of black cells. Red and green\ncells operate something like traffic lights.\n\nThe mouse enters a maze from a lone black cell in some column of the\nsouthernmost row. It exits to a lone black cell in some column of the\nnorthernmost row:\n\nThe mouse traverses the maze by following the right-hand rule. That is, from\nthe start, it keeps its right hand (or paw) in contact with the wall to its\nright, and it follows the wall around corners as it advances. However, if it\nencounters a four-way intersection, it plows straight through:\n\nIf the mouse lands on a green cell while facing east or west, it proceeds as\nif the cell were black:\n\nIf the mouse lands on a red cell while facing east or west, it reverses\ndirection:\n\nIf the mouse lands on a red or green cell while facing south, the cell changes\nto or remains as red, and the mouse turns north:\n\nFinally, if the mouse lands on a red or green cell while facing north, the\ncell changes to or remains as green, and the mouse turns south:\n\n# Formal Definition\n\nThe simulator repeatedly performs these steps until the mouse exits the maze:\n\n  1. The simulator may change the color of the tile the mouse is situated on and the mouse\u2019s direction:\n    \n        if tile = red then if direction = north then tile \u2190 green end direction \u2190 reverse(direction) else if tile = green then if direction = north then direction \u2190 south else if direction = south then direction \u2190 north tile \u2190 red end end\n\n  2. The simulator inspects the tiles immediately left, in front of, and right of the mouse. It uses the table below, where 1 indicates a wall (a gray tile) and 0 indicates a passage (a nongray tile), to abide by the right-hand rule modified to ignore four-way intersections.\n\nWalls| Action  \n---|---  \n000| None (four-way intersection)  \n001| None (right branch ahead)  \n010| Turn 90\u00b0 clockwise (take right branch)  \n011| Turn 90\u00b0 counterclockwise (can only go left)  \n100| Turn 90\u00b0 clockwise (take right branch)  \n101| None (straight passage)  \n110| Turn 90\u00b0 clockwise (can only go right)  \n111| Reverse direction (dead end)  \n  3. The simulator moves the mouse forward to an adjacent tile.\n\n# Circuits\n\nIn the circuits described below, the mouse propagates logic one as it travels.\nPaths of black tiles, separated by gray tiles, direct the mouse between\ncomponents. They function as signal channels analogous to the wires of an\nelectronic circuit. Four-way intersections act as non-connecting, crossing\nwires because the mouse disregards the right-hand rule when it encounters\nthem.\n\nRed and green tiles operate as switching elements. Red represents a switch\nturned off, a disconnected channel that denies east-west signal propagation.\nAnd green represents a switch turned on, a connected channel that permits\neast-way signal propagation.\n\nThe mouse turns a switch off by southwardly stepping onto a green tile. And it\nturns a switch on by northwardly stepping onto a red tile.\n\nSince red and green tiles retain their states after the mouse steps away, they\nalso serve as data storage elements. In the circuits below, red represents a\nstored logic zero, and green represents a stored logic one.\n\nNote: It is possible to build inverted circuits, where the mouse propagates\nlogic zero, or dual-rail circuits, where the mouse propagates logic zero or\nlogic one depending on which of two paths the mouse takes.\n\n# Logic Gates\n\nUnlike traditional logic gates, logic gates implemented in Turing\u2019s maze store\ninput values. They are initialized to logic zeros.\n\nWhen the mouse visits an input terminal\u2014where \u201cvisit\u201d means it enters and it\nsubsequently returns from the terminal\u2014it toggles a stored value to logic one.\nAfter setting the inputs in this way, the mouse enters an express-and-reset\nterminal, which evaluates the logical operation for the stored inputs. If the\nresult is logic one, the mouse visits the output terminal, expressing the\nresult to whatever is wired to the gate. Finally, the mouse resets the stored\nvalues to logic zeros, and it returns from the express-and-reset terminal.\n\nTo make this clear, the image below depicts an AND gate with the input\nterminals, the output terminal, and the express-and-reset terminal labeled.\n\nWhen the mouse visits an input terminal, it switches one of the red tiles to\ngreen. When the mouse enters the express-and-reset terminal, it visits the\noutput terminal only if the mouse switched both red tiles to green. Then it\nflips any green tiles back to red. And it returns from the express-and-reset\nterminal.\n\nThe following animated examples depict logic gates attached to test harnesses\nof the form:\n\nEach harness uses red and green tiles to control which input terminals the\nmouse visits, and a red tile to capture the result of the logical operation\nfor the given input values.\n\n## Buffer\n\n## Inverter\n\n## AND Gate\n\n## OR Gate\n\n## NAND Gate\n\n## NOR Gate\n\n## XOR Gate\n\nThe XOR gate employs combinational logic. It consists of a NAND gate and an OR\ngate whose outputs feed into an AND gate. The XOR\u2019s express-and-reset terminal\ndirects the mouse to the NAND and OR gate\u2019s express-and-reset terminals prior\nto the AND\u2019s express-and-reset terminal, ensuring the logical operations are\nperformed in the correct sequence:\n\n## XNOR Gate\n\nLike XOR, XNOR employs combinational logic. It consists of a NOR gate and an\nAND gate whose outputs feed into an OR gate. As with XOR, XNOR\u2019s express-and-\nreset terminal directs the mouse to evaluate the logical operations in the\nproper order:\n\n## Transmission Gate\n\nA single red or green tile can function as a transmission gate:\n\nThe image below depicts part of the circuit that computes the Mandelbrot set.\nIt shows stacks of transmission gates with common control lines that connect\nor disconnect devices to a bus.\n\n## Demultiplexer\n\nA 1-to-2 demultiplexer steers the mouse from a data input terminal to one of\ntwo output terminals:\n\nHere are test harnesses exercising all possible input values:\n\nThe Mandelbrot set circuit uses a 1-to-256 demultiplexer and a 1-to-512\ndemultiplexer constructed from binary trees of 1-to-2 demultiplexers.\n\n# Sequential Logic\n\nAs shown below, a 1-bit register combines a data storage element, a\ntransmission gate, and a buffer. It provides store and load access through a\nsingle data terminal. The store-enable-and-reset terminal turns the\ntransmission gate on\u2014connecting the data terminal to the data storage\nelement\u2014and it resets the data storage element to red. The store-disable\nterminal turns the transmission gate off\u2014disconnecting the data terminal from\nthe data storage element. The load terminal expresses the data storage element\nto the data terminal through the buffer.\n\nThe Mandelbrot set circuit uses 16-bit registers, where each data terminal\nconnects to an individual line of a bus shared by other registers and devices:\n\nTo load a value from the register, the mouse visits the load terminal. It\nexpresses the data storage elements to the bus.\n\nTo store a value in the register:\n\n  1. The mouse visits the store-enable-and-reset terminal. It connects the data storage elements to the bus, and it reverts them to red.\n  2. The mouse expresses a value to the bus from some other register or device. This causes the mouse to enter some or all this register\u2019s data terminals, changing data storage elements to green.\n  3. The mouse visits the store-disable terminal, disconnecting the data storage elements from the bus.\n\nThe buffers prevent assertions of the shared bus lines from leaking to the\nload terminal through green data storage elements.\n\nThe register load and register store steps described above repeatedly appear\nin the Mandelbrot set circuit. For example, to subtract two registers, the\nmouse visits the control lines of the registers and a 16-bit adder-subtractor\nin a particular sequence:\n\n  1. adder-subtractor \u2013 enable subtraction\n  2. adder-subtractor \u2013 enable minuend store\n  3. minuend register \u2013 load\n  4. adder-subtractor \u2013 disable minuend store\n  5. adder-subtractor \u2013 enable subtrahend store\n  6. subtrahend register \u2013 load\n  7. adder-subtractor \u2013 disable subtrahend store\n  8. difference register \u2013 enable store and reset\n  9. adder-subtractor \u2013 subtract and reset\n  10. difference register \u2013 disable store\n\nThere are no specific minuend, subtrahend, and difference registers. The names\nrefer to any registers playing those roles during a subtraction.\n\nThe sequence above is an example of a microprogram. The Mandelbrot set circuit\nencodes microprograms like this:\n\nThe microprogram runs bottom-up. The mouse asserts control lines through\nbuffers to avoid sharing conflicts.\n\nFor branching, a microprogram uses a circuit of the form:\n\nAfter entering from the southern terminal, the mouse turns the transmission\ngate on, it resets the data storage element to red, and it visits a terminal\nthat evaluates the branch condition. The mouse expresses the branch condition\nresult through the transmission gate to the data storage element. Upon\nreturning, the mouse turns the transmission gate off, and then it attempts to\ntraverse the data storage element. If the stored branch condition is logic\none, the mouse exits the north-east terminal. Otherwise, it exits the north-\nwest terminal.\n\nIf a branch loops back to an earlier part of a microprogram, a diode installed\nalong the return pathway ensures the mouse traverses the loop in the correct\ndirection:\n\n# Software\n\nThis project includes a simulator and an emulator written in Java. They load\nan image of a Turing\u2019s maze, where each pixel represents a tile with these\n24-bit RGB values:\n\nTile| RGB  \n---|---  \nBlack| 000000  \nGray| 808080  \nRed| FF0000  \nGreen| 00FF00  \n  \nThe simulator runs the mouse from the entrance to the exit, and it saves an\nimage of the final maze state.\n\nThe emulator does the same, but it executes much faster. Before it runs the\nmouse from the entrance to the exit, it positions and orients the mouse on\neach red and green tile, and in each cardinal direction. It runs a simulation\nfor those configurations that obtains a list of tiles the mouse turns red and\na list of the tiles the mouse turns green until the mouse arrives at a red or\ngreen tile facing east or west.\n\nAt run-time, the emulator uses that precomputed table to jump the mouse from a\nsource red or green tile, while facing east or west, to a destination red or\ngreen tile, again facing east or west, with the expected tile color changes.\nIf the mouse lands on a red tile, the emulator reverses its direction.\n\nTo download the source code and the compiled binary, clone this repository.\n\nTo run the simulator, navigate to the local repository directory, and execute\nthe following command.\n\njava -cp target/turings-maze.jar turingsmaze.Simulator -i [ input image ] -o [\noutput image ] \u2bba\n\nTo run the emulator, navigate to the local repository directory, and execute\nthe following command.\n\njava -cp target/turings-maze.jar turingsmaze.Emulator -i [ input image ] -o [\noutput image ] \u2bba\n\n# Mandelbrot Set Circuit\n\nAfter running for two hours and twenty minutes on a 51\u20442-year-old desktop PC,\nthe emulator completed this transformation:\n\nClick on the images to view the full-resolution versions (10,149 \u00d7 12,540\npixels).\n\nThe maze contains circuits that calculate the Mandelbrot set and a display\nthat makes it visible:\n\nAs revealed in the high-level diagram below, the Mandelbrot set calculator\nconsists of an adder-subtractor, a multiplier, a point escape time evaluator,\nand a main device that iterates over the points of the region. Demultiplexers\ndrive the display. And everything shares a 16-bit bus.\n\nHere are the actual circuits for the components of the Mandelbrot set\ncalculator:\n\n## Adder-subtractor\n\nThe adder-subtractor performs addition and subtraction on 16-bit, two's\ncomplement numbers. Its conventional ripple carry design consists of cascaded\nfull adder-subtractors that propagate carries or borrows from the least\nsignificant bit to the most significant bit. The carry/borrow-in is constant,\nand the carry/borrow-out is lost. The bus serves as the input and output\ninterface.\n\n## Multiplier\n\nThe multiplier operates on 16-bit fixed-point numbers, where the leading six\nbits represent a signed, two's complement integer, and the remaining ten bits\nrepresent a fraction, permitting values in the range . It contains three\nregisters:\n\nRegister| Description  \n---|---  \nI| 5-bit loop index  \nA| 16-bit multiplicand  \nP| 32-bit product accessible as high and low 16-bit registers, PH and PL,\nrespectively  \n  \nThe multiplier contains three devices that perform the following operations.\n\nOperation| Description  \n---|---  \nPL \u2190 PH| Move PH into PL  \nP \u2190 P >>> 1| Unsigned right-shift P by 1  \nP \u2190 P << 6| Left-shift P by 6  \n  \nThe multiplier\u2019s registers, devices, and microprogram are labeled in the image\nbelow.\n\nThe microprogram implements the following algorithm for multiplicands x and y.\n\n    \n    \n    A \u2190 x PH \u2190 y if y15 then PH \u2190 0 \u2212 PH end PL \u2190 PH I \u2190 0 PH \u2190 0 while true do if PL0 = 1 then PH \u2190 PH + A end P \u2190 P >>> 1 I \u2190 I + 1 if I4 = 1 then break end end P \u2190 P << 6 if y15 then PH \u2190 0 \u2212 PH end\n\nAt completion, PH contains the resultant product.\n\n## Escape Time Evaluator\n\nThe escape time evaluator executes the Mandelbrot set escape time algorithm\nfor a given point. It contains eight registers:\n\nRegister| Description  \n---|---  \nI| 7-bit loop index  \nX0| Evaluation point x-coordinate  \nY0| Evaluation point y-coordinate  \nX| Escaping point x-coordinate  \nY| Escaping point y-coordinate  \nX2| X squared  \nY2| Y squared  \nS| Sum of squares  \n  \nIt also contains a device that left-shifts by 1.\n\nThe escape time evaluator's registers, shifter, and microprogram are labeled\nin the image below.\n\nThe microprogram implements the following algorithm for evaluation point .\n\n    \n    \n    X0 \u2190 a Y0 \u2190 b X \u2190 X0 Y \u2190 Y0 I \u2190 0 while true do Y2 \u2190 Y * Y X2 \u2190 X * X S \u2190 61440 + X2 + Y2 if S15 = 0 then break end I \u2190 I + 1 if I6 = 1 then break end Y \u2190 ((X * Y) << 1) + Y0 X \u2190 X2 \u2212 Y2 + X0 end\n\nThe constant 61440 corresponds to fixed-point value \u22124.\n\nAt completion, register I contains the escape time. It maxes out at 64.\n\n## Main\n\nThe main microprogram plots a 512\u00d7512 pixel region of the Mandelbrot set for\npoints\n\nSince the set is horizontally symmetric within that region, the microprogram\ncomputes only the upper half. The display device reflects the computed region\nto produce the entire image.\n\nThe main microprogram employs four registers:\n\nRegister| Description  \n---|---  \nJ| 10-bit column index  \nI| 9-bit row index  \nX| Evaluation point x-coordinate  \nY| Evaluation point y-coordinate  \n  \nIts components are labeled in the image below.\n\nThe main microprogram implements the following algorithm.\n\n    \n    \n    Y \u2190 64256 I \u2190 0 while true do X \u2190 63488 J \u2190 0 while true do plot(J, I, evalEscapeTime(X, Y)) J \u2190 J + 1 if J9 = 1 then break end X \u2190 X + 5 end I \u2190 I + 1 if I8 = 1 then break end Y \u2190 Y + 5 end\n\nConstants 64256 and 63488 represent fixed-point values \u22121.25 and \u22122,\nrespectively. The constant 5 corresponds to the fixed-point interval between\nevaluation points: .\n\n## Display\n\nThe main microprogram transfers the least-significant bit of each escape time\nto individual cells of a 512\u00d7512 matrix that act as dichromatic pixels capable\nof displaying red or green. The image below depicts a 4\u00d74 submatrix of the\ndisplay.\n\nEach cell primarily consists of red tiles wired together to form a large\nindicator. The AND gate in the lower-left corner of each cell drives the\nindicator. Each AND gate\u2019s inputs are connected to row and column lines. And\nthe express-and-reset terminals of all the AND gates are joined.\n\nTo turn a cell green, the mouse visits a row line, a column line, and the\ncollective express-and-reset lines. Only the AND gate at the intersection of\nthe row and column lines permits the mouse to reach an indicator.\n\nDemultiplexers drive the row and column lines:\n\nAs mentioned, the circuit takes advantage of the Mandelbrot set\u2019s horizontal\nsymmetry. The row demultiplexer reflects the computed upper half into the\nlower half.\n\n# Other Representations\n\nTuring\u2019s maze can be modeled as a cellular automaton with sixteen cell states:\n\nThe rules that produce a new generation\u2014which apply to the entire grid\nsimultaneously\u2014change only those few cells with the mouse in their\nneighborhood.\n\nIt is also possible to model Turing\u2019s maze as a turmite with forty-five\nmetatiles:\n\nSince the metatiles include the proximate maze walls, the turmite needs only\nthe current metatile and the direction it faces to decide what to do.\n\n# Universality\n\nA medium is Turing-complete if it can compute every Turing-computable\nfunction. Put another way, if it can replicate the functionality of all Turing\nmachines. This section considers if Turing\u2019s maze is such a medium.\n\nWhen a Turing machine runs, it allocates a finite amount of tape. But it is\nnot possible to anticipate how much tape an arbitrary algorithm requires. As\nsuch, a Turing machine needs an unlimited supply. And importantly, the region\nof tape not containing the algorithm must be blank. This precludes the\npossibility that the algorithm is just an infinite lookup table that creates\nthe illusion of computation.\n\nTuring\u2019s maze can emulate tape cells and the head with constructs built around\nthe red and green data storage tiles, like the registers described above. But\nit needs infinite cells, which means a maze of infinite width. In such a\nhypothetical maze, if the mouse traverses the entrance to the exit, then it\nstill covers a finite distance. How far it voyages into the limitless tape\ndepends on the algorithm.\n\nConsider the reverse: a Turing machine capable of simulating any Turing\u2019s\nmaze. Encoding an infinitely wide maze onto the tape would fill it up. That\nviolates the rule mentioned above: the algorithm must initially fit on a\nfinite region of tape. However, it is possible to build a Turing machine that\nextends the maze on-demand. If the mouse reaches the maze\u2019s edge, that machine\nwould append more cell constructs. Such a machine would be universal because\nit can be initialized with a Turing\u2019s maze representing any Turing-computable\nfunction.\n\nBut expansion is not an inherent property of Turing\u2019s maze. The mouse cannot\ndig out new passages. The only way to achieve the effect is to impose it\nexternally. Consequently, Turing\u2019s maze is best described as \u201cweakly\nuniversal\u201d rather than Turing-complete. Meaning, it can compute any algorithm,\nbut some algorithms require a maze specified by repeating yet infinite\ninformation.\n\nSince Turing\u2019s maze is universal, mazes exist for which it is not possible to\ndetermine if the mouse can traverse the entrance to the exit. This follows\nfrom the halting problem.\n\n# Reversibility\n\nA Turing's maze is reversible if the mouse can change the color of a red or\ngreen tile at most once. Circuits with that constraint consist of one-time-use\nlogic gates that lack reset paths. They can perform combinational logic, but\nnot sequential logic. The red and green tiles within the gates store applied\ninputs. That enables the mouse to propagate inputs back to their origins in a\nreverse simulation.\n\nWhile reversible Turing\u2019s maze does not permit sequential logic, its effect\ncan be attained by repeating combinational logic. A hypothetical maze\ncontaining an infinite chain of combinational logic could perform any\nalgorithm. This implies that reversible Turing\u2019s maze is also \u201cweakly\nuniversal\u201d.\n\n\u00a9 2023 meatfighter.com This content is licensed under CC BY-SA 4.0| Home  \n---|---\n\n", "frontpage": false}
