{"aid": "40135870", "title": "Implementing Object Expansion on REST APIs with Rails", "url": "https://pocketflows.com/blog/implementing-expand-parameter-rails/", "domain": "pocketflows.com", "votes": 2, "user": "theodoretliu", "posted_at": "2024-04-23 19:05:15", "comments": 0, "source_title": "Implementing the 'expand' Parameter in Rails", "source_text": "Implementing the 'expand' Parameter in Rails \u2014 Pocketflows Blog\n\nPocketflows\n\nBlog\n\nApril 23, 2024\n\n#\n\nexpand Your API's Horizons, Part Two: Implementing the expand Parameter in\nRails\n\nTeddy LiuCo-Founder @ Pocketflows\n\nThe Ruby on Rails logo\n\nIn our previous blog post, we motivated the existence and utility of an expand\nparameter on REST APIs. As a reminder, the expand parameter provides a\nreasonable tradeoff for API callers, sending minimal data while still allowing\nthem to request more information as necessary.\n\nAt Pocketflows, we\u2019re building embedded APIs to help VSaaS companies build\nhigh-quality customer engagement tools faster and better. Our API is built\nwith the endlessly useful Ruby on Rails, and we\u2019d like to share parts of our\nimplementation! This walkthrough does use Ruby syntax and Rails idioms, but\nthe concepts still generalize! We hope this will enable other companies to\nmore easily incorporate the expand parameter into their APIs.\n\n## The Resource Class\n\nAt its core, an API serves response objects or resources to the API caller. In\nour codebase, we represent these as Resources\n\n    \n    \n    # app/models/resource.rb class Resource < ApplicationRecord # note: necessary so that this doesn't try to read the `resources` SQL table self.abstract_class = true def json(expand = []) raise NotImplementedError end end\n\nEach subclass of Resource is expected to implement the json method which will\noptionally receive an array of expand parameters.\n\nTaking an example from our own API, our Member resource (which represents a\nuser belonging to a rewards program) would be defined as\n\n    \n    \n    # app/models/member.rb class Member < Resource belongs_to :rewards_program, autosave: false, optional: true, validate: false belongs_to :user, autosave: false, optional: true, validate: false def json(expand = []) # parsing out the expand parameters that correspond to \"user\" # and \"rewards_program\" user_expand = expand.filter { |x| x.length > 0 && x[0] == :user } rewards_program_expand = expand.filter { |x| x.length > 0 && x[0] == :rewards_program } { id: public_id, user: # deciding to return the id or expand the user resource ( if user_expand.present? user.json(user_expand.map { |x| x[1...] }) else user.public_id end ), rewards_program: # deciding to return the id or expand the rewards program ( if rewards_program_expand.present? rewards_program.json(rewards_program_expand.map { |x| x[1...] }) else rewards_program.public_id end ) } end end\n\nHere we see that we\u2019re filtering the expand variable, ensuring that we\u2019re\npulling out keys that correspond to :user and :rewards_program. If we find\nany, we forward those along the next layer of serialization. This is pretty\nwordy! Also note that we\u2019re not doing any sort of error checking. Before we\nunpack that further, let\u2019s examine how we preprocess the expand parameter.\n\n## Pre-processing expand\n\nRecall that when API callers provide the expand parameter in their HTTP\nrequest, they do so either via GET with URL params\n\n    \n    \n    https://api.pocketflows.com/?expand[]=member.user&expand[]=location\n\nor POST with body params\n\n    \n    \n    { ..., \"expand\": [\"member.user\", \"location\"] }\n\nRails already parses these equivalently, leading to the params variable\ncontaining\n\n    \n    \n    params[:expand] == [\"member.user\", \"location\"]\n\nSo that the Resource class is not responsible for parsing and splitting these\ninputs, we can normalize these into nested arrays of symbols so the above\nbecomes\n\n    \n    \n    expand == [[:member, :user], [:location]]\n\nWe\u2019ll pass this normalized form to the .json method of each of our Resources.\n\nWe can accomplish this in Rails by defining a before_action in\nApplicationController. Simultaneously, we can also add simple error-checking\nthat prevents arbitrarily-deep expansion.\n\n    \n    \n    # app/controllers/application_controller.rb class ApplicationController < ActionController::Base before_action :normalize_expand attr_accessor :expand def normalize_expand @expand = [] if params[:expand].present? if params[:expand].is_a?(Array) && params[:expand].all? { |x| x.is_a?(String) && x.split(\".\").length <= 3 # prevent deep expansion } @expand = params[:expand].map { |x| x.split(\".\") }.map(&:to_sym) else return head :bad_request end end end end\n\n## Improving Our Implementation\n\nIn our first outline of the Member class above, there was a lot of repetitive\ncode, and we also did not take care of error handling. We can handle both by\ndefining some utilities on the base Resource class.\n\nOur goal is to parse out the keys that are actually valid for expansion and\nraise errors if any invalid keys are present. We also want to return a hash\nthat provides simple access to the parsed keys for forwarding. The following\nfunction does the trick:\n\n    \n    \n    # app/models/resource.rb class Resource < ApplicationRecord # ... previous stuff class << self # allowing the class to define which keys are expandable attr_accessor :expandable_keys end # by default, nothing is expandable self.expandable_keys = [].freeze # defining a custom error for expansion class ExpandError < StandardError end def parse_expand!(expand) # if any of the expand parameters start w/ an unexpandable key or other # typo, raise an error if expand.any? { |x| x.length > 0 && !self.class.expandable_keys.include?(x[0]) } raise ExpandError.new end # for each of the possible keys, return the forwardable expansion params # to the next layer. If no expansion was requested, pass `nil` to the # next layer. For an Event being passed [\"member.user\"], would # return { member: [[:user]] } self .class .expandable_keys .each_with_object({}) do |key, hash| result = expand.filter { |x| x.length > 0 && x[0] == key }.map { |x| x[1...] } hash[key] = result.present? ? result : nil hash end end end\n\nThis utility can be used in the Member class as follows:\n\n    \n    \n    # app/models/member.rb class Member < Resource # defining which keys can be expanded! self.expandable_keys = %i[user rewards_program].freeze belongs_to :rewards_program, autosave: false, optional: true, validate: false belongs_to :user, autosave: false, optional: true, validate: false def json(expand = []) # note this early return helps simplify ternaries in nested resources return public_id if expand.nil? # using our expand parsed_expand = parse_expand!(expand) { id: public_id, user: user.json(parsed_expand[:user]), # forwarding things along rewards_program: rewards_program.json(parsed_expand[:rewards_program]) # forwarding things along } end end\n\nDefining new Resources is now simplified to just defining self.expandable_keys\nand passing the parsed expand parameters to the relevant keys. There are still\nsome opportunities to potentially simplify redundancy in this code \u2014 for\nexample, we still manually have to call .json and index parsed_expand \u2014 but\nthe tradeoffs and implementation are left as exercises to the reader \ud83e\udd13.\n\n## Complete Implementation\n\nThe complete code for Resource, Member, and ApplicationController is\nreproduced below\n\n    \n    \n    # app/controllers/application_controller.rb class ApplicationController < ActionController::Base before_action :normalize_expand attr_accessor :expand def normalize_expand @expand = [] if params[:expand].present? if params[:expand].is_a?(Array) && params[:expand].all? { |x| x.is_a?(String) && x.split(\".\").length <= 3 # prevent deep expansion } @expand = params[:expand].map { |x| x.split(\".\") }.map(&:to_sym) else return head :bad_request end end end end\n    \n    \n    # app/models/resource.rb class Resource < ApplicationRecord # note: necessary so that this doesn't try to read the `resources` SQL table self.abstract_class = true class << self # allowing the class to define which keys are expandable attr_accessor :expandable_keys end # by default, nothing is expandable self.expandable_keys = [].freeze # defining a custom error for expansion class ExpandError < StandardError end def parse_expand!(expand) # if any of the expand parameters start w/ an unexpandable key or other # typo, raise an error if expand.any? { |x| x.length > 0 && !self.class.expandable_keys.include?(x[0]) } raise ExpandError.new end # for each of the possible keys, return the forwardable expansion params # to the next layer. If no expansion was requested, pass `nil` to the # next layer. For an Event being passed [\"member.user\"], would # return { member: [[:user]] } self .class .expandable_keys .each_with_object({}) do |key, hash| result = expand.filter { |x| x.length > 0 && x[0] == key }.map { |x| x[1...] } hash[key] = result.present? ? result : nil hash end end end\n    \n    \n    # app/models/member.rb class Member < Resource # defining which keys can be expanded! self.expandable_keys = %i[user rewards_program].freeze belongs_to :rewards_program, autosave: false, optional: true, validate: false belongs_to :user, autosave: false, optional: true, validate: false def json(expand = []) # note this early return helps simplify ternaries in nested resources return public_id if expand.nil? # using our expand parsed_expand = parse_expand!(expand) { id: public_id, user: user.json(parsed_expand[:user]), # forwarding things along rewards_program: rewards_program.json(parsed_expand[:rewards_program]) # forwarding things along } end end\n\n## Conclusion\n\nWe hope this guided implementation of the expand parameter in Ruby on Rails is\nhelpful! It\u2019s our hope that more API providers start to offer this feature and\nimprove developer ergonomics across the board.\n\nAre you looking to build customer engagement for your VSaaS or consumer-facing\nbusiness? At Pocketflows, we're creating embedded APIs to build high-quality\ncustomer engagement products. We're incorporating the best API practices and\ncreating the best developer experience. If you're interested in learning more,\nclick the button below to schedule time with us!\n\nSchedule with us\n\n", "frontpage": false}
