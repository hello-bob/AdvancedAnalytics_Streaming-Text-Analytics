{"aid": "40197607", "title": "How to Compact Acceleration Structures in D3D12", "url": "https://alextardif.com/Compaction.html", "domain": "alextardif.com", "votes": 1, "user": "ibobev", "posted_at": "2024-04-29 12:49:13", "comments": 0, "source_title": "Alex Tardif: Graphics Engineer", "source_text": "Alex Tardif: Graphics Engineer\n\n#\n\nAlex Tardif\n\nGraphics & Game Programmer\n\n## How to Compact Acceleration Structures in D3D12\n\n### Overview\n\nOne of the most important features of acceleration structure management in\nD3D12 is compaction. Compaction uses the information built by the driver\nduring acceleration structure creation to optimize the data to be much\nsmaller, often to 45-50% of the original size! This post details how to do it.\nI will be focusing on implementing this for Bottom Level Acceleration\nStructures (BLAS) as that is the most useful purpose of this feature, but it\napplies to TLASes as well. I also will assume knowledge of how to create\nacceleration structures with D3D12.\n\nDocumentation, DirectX Raytracing (DXR) spec, and samples can be found here,\nif you're looking for a good place to start:\nhttps://github.com/microsoft/DirectX-Graphics-\nSamples/tree/master/Samples/Desktop/D3D12Raytracing\n\n### Modify Acceleration Structure Creation\n\nWhere you are currently creating your acceleration structure that you want to\ncompact, you will need to add the\nD3D12_RAYTRACING_ACCELERATION_STRUCTURE_BUILD_FLAG_ALLOW_COMPACTION flag.\nDoing this will potentially increase the size of the pre-compacted\nacceleration structure, presumably so the driver can create additional\nnecessary information, but that's okay because we're going to compact it\nanyway.\n\n    \n    \n    D3D12_BUILD_RAYTRACING_ACCELERATION_STRUCTURE_INPUTS blasInputs = {}; blasInputs.Type = D3D12_RAYTRACING_ACCELERATION_STRUCTURE_TYPE_BOTTOM_LEVEL; blasInputs.DescsLayout = D3D12_ELEMENTS_LAYOUT_ARRAY; blasInputs.pGeometryDescs = geometryDescs; blasInputs.NumDescs = numGeometryDescs; blasInputs.Flags = D3D12_RAYTRACING_ACCELERATION_STRUCTURE_BUILD_FLAG_PREFER_FAST_TRACE | D3D12_RAYTRACING_ACCELERATION_STRUCTURE_BUILD_FLAG_ALLOW_COMPACTION; //new flag D3D12_RAYTRACING_ACCELERATION_STRUCTURE_PREBUILD_INFO prebuildInfo = {}; mDevice->GetRaytracingAccelerationStructurePrebuildInfo(&blasInputs, &prebuildInfo);\n\n...\n\n    \n    \n    D3D12_BUILD_RAYTRACING_ACCELERATION_STRUCTURE_DESC buildDesc = {}; buildDesc.Inputs = blasInputs; buildDesc.ScratchAccelerationStructureData = scratchBufferAddress; buildDesc.DestAccelerationStructureData = blasAddress; mCommandList->BuildRaytracingAccelerationStructure(&buildDesc, 0, nullptr);\n\n### Query the Compacted Size\n\nNow that we're building with _ALLOW_COMPACTION, we can query for the compacted\nsize. Unlike other operations though, this calculation happens on the GPU and\nwrites to a GPU virtual address. There are two ways to go about doing this\ncalculation (which I will cover), but both require filling out a\nD3D12_RAYTRACING_ACCELERATION_STRUCTURE_POSTBUILD_INFO_DESC, and here we can\nsee the DestBuffer is a D3D12_GPU_VIRTUAL_ADDRESS.\n\nSo we need a buffer to readback that data, and while there are a few ways to\ngo about that, a resource allocated from a heap of type\nD3D12_HEAP_TYPE_READBACK seems most fitting, as it is optimized for exactly\nthis purpose. If you follow this path though, you will be met with an error\nfrom the validation layer, even though the operation may still work on your\nspecific device:\n\nD3D12 ERROR: Invalid heap type for resource. Cannot use readback resources as\na acceleration structure post build info.\n\nIt turns out that D3D12_HEAP_TYPE_READBACK was made with very specific\npurposes in mind, and this was not one of them. This isn't a dead end though,\nwe just need to create a heap with the same properties as\nD3D12_HEAP_TYPE_READBACK and create the resource out of that heap. This can be\ndone with the ID3D12Device function GetCustomHeapProperties:\n\n    \n    \n    D3D12_HEAP_PROPERTIES heapProperties = mDevice->GetCustomHeapProperties(0, D3D12_HEAP_TYPE_READBACK);\n\nYou can then pass this to CreateHeap, CreateCommittedResource, or however you\nallocate your resources. If you use D3D12MemAlloc, you can create a custom\npool using these heap properties by calling CreatePool on your\nD3D12MA::Allocator, and then use the CustomPool member of the\nD3D12MA::ALLOCATION_DESC when you create the resource.\n\nWhen allocating the resource, you will want it to be large enough to store a\n64-bit value, or more specifically a\nD3D12_RAYTRACING_ACCELERATION_STRUCTURE_POSTBUILD_INFO_COMPACTED_SIZE_DESC.\nYou will also need to map the resource via ID3D12Resource::Map and save that\nmapped address for reading later. I choose to persistently map the resource\nand reuse this buffer.\n\nWith the proper destination buffer for the readback operation, we can now\ngenerate the compaction size query description using the virtual address of\nthat buffer:\n\n    \n    \n    D3D12_RAYTRACING_ACCELERATION_STRUCTURE_POSTBUILD_INFO_DESC postBuildInfo; postBuildInfo.InfoType = D3D12_RAYTRACING_ACCELERATION_STRUCTURE_POSTBUILD_INFO_COMPACTED_SIZE; postBuildInfo.DestBuffer = readbackBufferVirtualAddress;\n\nNow we can queue up that calculation on the command list. As previously\nmentioned there are two ways of doing this. The first is to pass this\npostBuildInfo as additional arguments to the BLAS build itself:\n\n    \n    \n    mCommandList->BuildRaytracingAccelerationStructure(&buildDesc, 1, &postBuildInfo);\n\nThe second is to call EmitRaytracingAccelerationStructurePostbuildInfo after\nthe BLAS is built. Note that this will require a UAV barrier in between to\nensure that the BLAS is built before attempting to calculate its compacted\nsize. This may also be more convenient if your plan is to build a number of\nBLASes per frame and then query their compacted sizes all at once with a\nsingle call to this function. Both methods should be just fine.\n\n    \n    \n    mCommandList->EmitRaytracingAccelerationStructurePostbuildInfo(&postBuildInfo, 1, &blasAddress);\n\n### Read Back the Compacted Size\n\nRegardless of how the compaction size is queried, we now need to wait for that\nwork to complete via a fence. I simply wait for the frame buffering to\nguarantee its completion (eg 2 buffered frames means I wait until frame N +\n2), but that's just one way to do it. Once the appropriate wait is complete,\nwe can safely read the compacted size back:\n\n    \n    \n    D3D12_RAYTRACING_ACCELERATION_STRUCTURE_POSTBUILD_INFO_COMPACTED_SIZE_DESC compactedSizeDesc = {}; memcpy_s(&compactedSizeDesc, sizeof(D3D12_RAYTRACING_ACCELERATION_STRUCTURE_POSTBUILD_INFO_COMPACTED_SIZE_DESC), mappedResourceAddress, sizeof(D3D12_RAYTRACING_ACCELERATION_STRUCTURE_POSTBUILD_INFO_COMPACTED_SIZE_DESC));\n\nAnd now we finally have it, the value stored in\ncompactedSizeDesc.CompactedSizeInBytes is the buffer size we need for the\ncompacted acceleration structure.\n\n### Create the Compacted BLAS\n\nWith the compacted size in hand, we simply need to create a new buffer for the\nacceleration structure like any other, but using the compacted size. The last\nstep is convenient and straightforward, by calling\nCopyRaytracingAccelerationStructure with the addresses of our original BLAS,\nand our compacted BLAS:\n\n    \n    \n    mCommandList->CopyRaytracingAccelerationStructure(compactedBlasAddress, sourceBlasAddress, D3D12_RAYTRACING_ACCELERATION_STRUCTURE_COPY_MODE_COMPACT);\n\nThe original BLAS instance can now be replaced in the TLAS with the newly\ncompacted BLAS, with a UAV barrier added between the call to\nCopyRaytracingAccelerationStructure and building the TLAS. The original BLAS\ncan then be deleted, as long as you have confirmed it is no longer in flight\non the GPU (accounting for frame buffering).\n\n### Additional Considerations\n\nIf you dig into the Nvidia resource on compaction and acceleration structure\nmemory management (see bottom of this post), the most important additional\nnote related to compaction is the method used to allocate resources.\nAcceleration structure alignment is\nD3D12_RAYTRACING_ACCELERATION_STRUCTURE_BYTE_ALIGNMENT (256), but buffer\nresources must be allocated with D3D12_DEFAULT_RESOURCE_PLACEMENT_ALIGNMENT,\nwhich is 64KB. That means if resources are allocated naively there is\npotential for a significant amount of waste, and in the compaction case with\nsmall or medium sized meshes, the compaction step might not save much or any\nmemory at all due to alignment.\n\nThe strategy to implement here is out of scope for this post, but here is what\nI recommend:\n\n1) When allocating memory for large pools, start with pages of GPU memory\nwhere each page is an ID3D12Heap. 64MB per page is a decent place to start, as\nit isn't too difficult to run into fragmentation issues on the GPU with\nlimited VRAM.\n\n2) Create a placed ID3D12Resource that encompasses the heap, for each heap:\nhttps://learn.microsoft.com/en-\nus/windows/win32/api/d3d12/nf-d3d12-id3d12device-createplacedresource\n\n3) Use an allocator to suballocate resources out of that ID3D12Resource\n(offsets into that resource). Deriving a TLSF allocator is my personal\npreference: http://www.gii.upv.es/tlsf/index.html\n\nDoing this will allow you to avoid the placed resource alignment requirement\nand take full advantage of compaction. If you use D3D12MA, it turns out that\nit also generously provides a virtual TLSF allocator via CreateVirtualBlock()!\n\nAnother note worth considering is that acceleration structures that use refits\n(for example with skinning) can also be compacted and cloned to save memory,\nwhich could be useful in cases where you know something will stop needing\nrebuilds.\n\nThis is the helpful Nvidia article about Acceleration Structure Compaction:\nhttps://developer.nvidia.com/blog/tips-acceleration-structure-compaction/\n\nHere is the D3D12MA GitHub, if you are looking for the leading open source\nD3D12 memory allocator (Thank you, Adam Sawicki and AMD!)\nhttps://github.com/GPUOpen-LibrariesAndSDKs/D3D12MemoryAllocator\n\n## Contact\n\n  * alexdtardif@gmail.com\n  * LinkedIn\n\n", "frontpage": false}
