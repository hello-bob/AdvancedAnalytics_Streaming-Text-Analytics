{"aid": "40100672", "title": "Bringing Exchange Support to Thunderbird", "url": "https://blog.thunderbird.net/2024/04/adventures-in-rust-bringing-exchange-support-to-thunderbird/", "domain": "thunderbird.net", "votes": 6, "user": "campuscodi", "posted_at": "2024-04-20 20:19:06", "comments": 0, "source_title": "Adventures In Rust: Bringing Exchange Support To Thunderbird", "source_text": "Adventures In Rust: Bringing Exchange Support To Thunderbird\n\nDownload Thunderbird Donate\n\n  * Thunderbird\n\n# Adventures In Rust: Bringing Exchange Support To Thunderbird\n\nApril 19, 2024 Heather Ellsworth 0 responses\n\nMicrosoft Exchange is a popular choice of email service for corporations and\neducational institutions, and so it\u2019s no surprise that there\u2019s demand among\nThunderbird users to support Exchange. Until recently, this functionality was\nonly available through an add-on. But, in the next ESR (Extended Support)\nrelease of Thunderbird in July 2024, we expect to provide this support\nnatively within Thunderbird. Because of the size of this undertaking, the\nfirst roll-out of the Exchange support will initially cover only email, with\ncalendar and address book support coming at a later date.\n\nThis article will go into technical detail on how we are implementing support\nfor the Microsoft Exchange Web Services mail protocol, and some idea of where\nwe\u2019re going next with the knowledge gained from this adventure.\n\nBefore we dive in, just a quick note that Brendan Abolivier, Ikey Doherty, and\nSean Burke are the developers behind this effort, and are the authors of this\npost.\n\n> April 2024 Community Office Hours: Rust and Exchange Support\n\n# Historical context\n\nThunderbird is a long-lived project, which means there\u2019s lots of old code. The\ncurrent architecture for supporting mail protocols predates Thunderbird\nitself, having been developed more than 20 years ago as part of Netscape\nCommunicator. There was also no paid maintainership from about 2012 \u2014 when\nMozilla divested and transferred ownership of Thunderbird to its community \u2014\nuntil 2017, when Thunderbird rejoined the Mozilla Foundation. That means years\nof ad hoc changes without a larger architectural vision and a lot of decaying\nC++ code that was not using modern standards.\n\nFurthermore, in the entire 20 year lifetime of the Thunderbird project, no one\nhas added support for a new mail protocol before. As such, no one has updated\nthe architecture as mail protocols change and adapt to modern usage patterns,\nand a great deal of institutional knowledge has been lost. Implementing this\nmuch-needed feature is the first organization-led effort to actually\nunderstand and address limitations of Thunderbird\u2019s architecture in an\nincremental fashion.\n\n# Why we chose Rust\n\nThunderbird is a large project maintained by a small team, so choosing a\nlanguage for new work cannot be taken lightly. We need powerful tools to\ndevelop complex features relatively quickly, but we absolutely must balance\nthis with long-term maintainability. Selecting Rust as the language for our\nnew protocol support brings some important benefits:\n\n  1. Memory safety. Thunderbird takes input from anyone who sends an email, so we need to be diligent about keeping security bugs out.\n  2. Performance. Rust runs as native code with all of the associated performance benefits.\n  3. Modularity and Ecosystem. The built-in modularity of Rust gives us access to a large ecosystem where there are already a lot of people doing things related to email which we can benefit from.\n\nThe above are all on the standard list of benefits when discussing Rust.\nHowever, there are some additional considerations for Thunderbird:\n\n  1. Firefox. Thunderbird is built on top of Firefox code and we use a shared CI infrastructure with Firefox which already enables Rust. Additionally, Firefox provides a language interop layer called XPCOM (Cross-Platform Component Object Model), which has Rust support and allows us to call between Rust, C++, and JavaScript.\n  2. Powerful tools. Rust gives us a large toolbox for building APIs which are difficult to misuse by pushing logical errors into the domain of the compiler. We can easily avoid circular references or provide functions which simply cannot be called with values which don\u2019t make sense, letting us have a high degree of confidence in features with a large scope. Rust also provides first-class tooling for documentation, which is critically important on a small team.\n  3. Addressing architectural technical debt. Introducing a new language gives us a chance to reconsider some aging architectures while benefiting from a growing language community.\n  4. Platform support and portability. Rust supports a broad set of host platforms. By building modular crates, we can reuse our work in other projects, such as Thunderbird for Android/K-9 Mail.\n\n## Some mishaps along the way\n\nOf course, the endeavor to introduce our first Rust component in Thunderbird\nis not without its challenges, mostly related to the size of the Thunderbird\ncodebase. For example, there is a lot of existing code with idiosyncratic\nasynchronous patterns that don\u2019t integrate nicely with idiomatic Rust. There\nare also lots of features and capabilities in the Firefox and Thunderbird\ncodebase that don\u2019t have any existing Rust bindings.\n\n### The first roadblock: the build system\n\nOur first hurdle came with getting any Rust code to run in Thunderbird at all.\nThere are two things you need to know to understand why:\n\nFirst, since the Firefox code is a dependency of Thunderbird, you might expect\nthat we pull in their code as a subtree of our own, or some similar mechanism.\nHowever, for historical reasons, it\u2019s the other way around: building\nThunderbird requires fetching Firefox\u2019s code, fetching Thunderbird\u2019s code as a\nsubtree of Firefox\u2019s, and using a build configuration file to point into that\nsubtree.\n\nSecond, because Firefox\u2019s entrypoint is written in C++ and Rust calls happen\nvia an interoperability layer, there is no single point of entry for Rust. In\norder to create a tree-wide dependency graph for Cargo and avoid duplicate\nbuilds or version/feature conflicts, Firefox introduced a hack to generate a\nsingle Cargo workspace which aggregates all the individual crates in the tree.\n\nIn isolation, neither of these is a problem in itself. However, in order to\nbuild Rust into Thunderbird, we needed to define our own Cargo workspace which\nlives in our tree, and Cargo does not allow nesting workspaces. To solve this\nissue, we had to define our own workspace and add configuration to the\nupstream build tool, mach, to build from this workspace instead of Firefox\u2019s.\nWe then use a newly-added mach subcommand to sync our dependencies and\nlockfile with upstream and to vendor the resulting superset.\n\n### XPCOM\n\nWhile the availability of language interop through XPCOM is important for\nintegrating our frontend and backend, the developer experience has presented\nsome challenges. Because XPCOM was originally designed with C++ in mind,\nimplementing or consuming an XPCOM interface requires a lot of boilerplate and\nprevents us from taking full advantage of tools like rust-analyzer. Over time,\nFirefox has significantly reduced its reliance on XPCOM, making a clunky\nRust+XPCOM experience a relatively minor consideration. However, as part of\nthe previously-discussed maintenance gap, Thunderbird never undertook a\nsimilar project, and supporting a new mail protocol requires implementing\nhundreds of functions defined in XPCOM.\n\nExisting protocol implementations ease this burden by inheriting C++ classes\nwhich provide the basis for most of the shared behavior. Since we can\u2019t do\nthis directly, we are instead implementing our protocol-specific logic in Rust\nand communicating with a bridge class in C++ which combines our Rust\nimplementations (an internal crate called ews_xpcom) with the existing code\nfor shared behavior, with as small an interface between the two as we can\nmanage.\n\nPlease visit our documentation to learn more about how to create Rust\ncomponents in Thunderbird.\n\n# Implementing Exchange support with Rust\n\nDespite the technical hiccups experienced along the way, we were able to clear\nthe hurdles, use, and build Rust within Thunderbird. Now we can talk about how\nwe\u2019re using it and the tools we\u2019re building. Remember all the way back to the\nbeginning of this blog post, where we stated that our goal is to support\nMicrosoft\u2019s Exchange Web Services (EWS) API. EWS communicates over HTTP with\nrequest and response bodies in XML.\n\n## Sending HTTP requests\n\nFirefox already includes a full-featured HTTP stack via its necko networking\ncomponent. However, necko is written in C++ and exposed over XPCOM, which as\npreviously stated does not make for nice, idiomatic Rust. Simply sending a GET\nrequest requires a great deal of boilerplate, including nasty-looking unsafe\nblocks where we call into XPCOM. (XPCOM manages the lifetime of pointers and\ntheir referents, ensuring memory safety, but the Rust compiler doesn\u2019t know\nthis.) Additionally, the interfaces we need are callback-based. For making\nHTTP requests to be simple for developers, we need to do two things:\n\n  1. Support native Rust async/await syntax. For this, we added a new Thunderbird-internal crate, xpcom_async. This is a low-level crate which translates asynchronous operations in XPCOM into Rust\u2019s native async syntax by defining callbacks to buffer incoming data and expose it by implementing Rust\u2019s Future trait so that it can be awaited by consumers. (If you\u2019re not familiar with the Future concept in Rust, it is similar to a JS Promise or a Python coroutine.)\n  2. Provide an idiomatic HTTP API. Now that we had native async/await support, we created another internal crate (moz_http) which provides an HTTP client inspired by reqwest. This crate handles creating all of the necessary XPCOM objects and providing Rustic error handling (much nicer than the standard XPCOM error handling).\n\n## Handling XML requests and responses\n\nThe hardest task in working with EWS is translating between our code\u2019s own\ndata structures and the XML expected/provided by EWS. Existing crates for\nserializing/deserializing XML didn\u2019t meet our needs. serde\u2019s data model\ndoesn\u2019t align well with XML, making distinguishing XML attributes and elements\ndifficult. EWS is also sensitive to XML namespaces, which are completely\nforeign to serde. Various serde-inspired crates designed for XML exist, but\nthese require explicit annotation of how to serialize every field. EWS defines\nhundreds of types which can have dozens of fields, making that amount of\nboilerplate untenable.\n\nUltimately, we found that existing serde-based implementations worked fine for\ndeserializing XML into Rust, but we were unable to find a satisfactory tool\nfor serialization. To that end, we introduced another new crate, xml_struct.\nThis crate defines traits governing serialization behavior and uses Rust\u2019s\nprocedural derive macros to automatically generate implementations of these\ntraits for Rust data structures. It is built on top of the existing quick_xml\ncrate and designed to create a low-boilerplate, intuitive mapping between XML\nand Rust. While it is in the early stages of development, it does not make use\nof any Thunderbird/Firefox internals and is available on GitHub.\n\nWe have also introduced one more new crate, ews, which defines types for\nworking with EWS and an API for XML serialization/deserialization, based on\nxml_struct and serde. Like xml_struct, it is in the early stages of\ndevelopment, but is available on GitHub.\n\n## Overall flow chart\n\nBelow, you can find a handy flow chart to help understand the logical flow for\nmaking an Exchange request and handling the response.\n\nFig 1. A bird\u2019s eye view of the flow\n\n# What\u2019s next?\n\n## Testing all the things\n\nBefore landing our next major features, we are taking some time to build out\nour automated tests. In addition to unit tests, we just landed a mock EWS\nserver for integration testing. The current focus on testing is already paying\ndividends, having exposed a couple of crashes and some double-sync issues\nwhich have since been rectified. Going forward, new features can now be easily\ntested and verified.\n\n## Improving error handling\n\nWhile we are working on testing, we are also busy improving the story around\nerror handling. EWS\u2019s error behavior is often poorly documented, and errors\ncan occur at multiple levels (e.g., a request may fail as a whole due to\nthrottling or incorrect structure, or parts of a request may succeed while\nother parts fail due to incorrect IDs). Some errors we can handle at the\nprotocol level, while others may require user intervention or may be\nintractable. In taking the time now to improve error handling, we can provide\na more polished implementation and set ourselves up for easier long-term\nmaintenance.\n\n## Expanding support\n\nWe are working on expanding protocol support for EWS (via ews and the internal\news_xpcom crate) and hooking it into the Thunderbird UI. Earlier this month,\nwe landed a series of patches which allow adding an EWS account to\nThunderbird, syncing the account\u2019s folder hierarchy from the remote server,\nand displaying those folders in the UI. (At present, this alpha-state\nfunctionality is gated behind a build flag and a preference.) Next up, we\u2019ll\nwork on fetching message lists from the remote server as well as generalizing\noutgoing mail support in Thunderbird.\n\n## Documentation\n\nOf course, all of our work on maintainability is for naught if no one\nunderstands what the code does. To that end, we\u2019re producing documentation on\nhow all of the bits we have talked about here come together, as well as\ndescribing the existing architecture of mail protocols in Thunderbird and\nthoughts on future improvements, so that once the work of supporting EWS is\ndone, we can continue building and improving on the Thunderbird you know and\nlove.\n\nTags: Development Exchange Rust\n\n## 0 responses\n\n### Leave a Reply Cancel reply\n\n", "frontpage": true}
