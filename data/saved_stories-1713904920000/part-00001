{"aid": "40132517", "title": "Bloom Filter Indexes in PostgreSQL", "url": "https://www.postgresql.org/docs/current/bloom.html", "domain": "postgresql.org", "votes": 22, "user": "kaashmonee", "posted_at": "2024-04-23 14:41:05", "comments": 5, "source_title": "F.7. bloom \u2014 bloom filter index access method", "source_text": "PostgreSQL: Documentation: 16: F.7. bloom \u2014 bloom filter index access method\n\n8th February 2024: PostgreSQL 16.2, 15.6, 14.11, 13.14, and 12.18 Released!\n\nDocumentation \u2192 PostgreSQL 16\n\nSupported Versions: Current (16) / 15 / 14 / 13 / 12\n\nDevelopment Versions: devel\n\nUnsupported versions: 11 / 10 / 9.6\n\nF.7. bloom \u2014 bloom filter index access method  \n---  \nPrev| Up| Appendix F. Additional Supplied Modules and Extensions| Home| Next  \n  \n## F.7. bloom \u2014 bloom filter index access method #\n\nF.7.1. Parameters\n\nF.7.2. Examples\n\nF.7.3. Operator Class Interface\n\nF.7.4. Limitations\n\nF.7.5. Authors\n\nbloom provides an index access method based on Bloom filters.\n\nA Bloom filter is a space-efficient data structure that is used to test\nwhether an element is a member of a set. In the case of an index access\nmethod, it allows fast exclusion of non-matching tuples via signatures whose\nsize is determined at index creation.\n\nA signature is a lossy representation of the indexed attribute(s), and as such\nis prone to reporting false positives; that is, it may be reported that an\nelement is in the set, when it is not. So index search results must always be\nrechecked using the actual attribute values from the heap entry. Larger\nsignatures reduce the odds of a false positive and thus reduce the number of\nuseless heap visits, but of course also make the index larger and hence slower\nto scan.\n\nThis type of index is most useful when a table has many attributes and queries\ntest arbitrary combinations of them. A traditional btree index is faster than\na bloom index, but it can require many btree indexes to support all possible\nqueries where one needs only a single bloom index. Note however that bloom\nindexes only support equality queries, whereas btree indexes can also perform\ninequality and range searches.\n\n### F.7.1. Parameters #\n\nA bloom index accepts the following parameters in its WITH clause:\n\nlength\n\n    \n\nLength of each signature (index entry) in bits. It is rounded up to the\nnearest multiple of 16. The default is 80 bits and the maximum is 4096.\n\ncol1 \u2014 col32\n\n    \n\nNumber of bits generated for each index column. Each parameter's name refers\nto the number of the index column that it controls. The default is 2 bits and\nthe maximum is 4095. Parameters for index columns not actually used are\nignored.\n\n### F.7.2. Examples #\n\nThis is an example of creating a bloom index:\n\n    \n    \n    CREATE INDEX bloomidx ON tbloom USING bloom (i1,i2,i3) WITH (length=80, col1=2, col2=2, col3=4);\n\nThe index is created with a signature length of 80 bits, with attributes i1\nand i2 mapped to 2 bits, and attribute i3 mapped to 4 bits. We could have\nomitted the length, col1, and col2 specifications since those have the default\nvalues.\n\nHere is a more complete example of bloom index definition and usage, as well\nas a comparison with equivalent btree indexes. The bloom index is considerably\nsmaller than the btree index, and can perform better.\n\n    \n    \n    =# CREATE TABLE tbloom AS SELECT (random() * 1000000)::int as i1, (random() * 1000000)::int as i2, (random() * 1000000)::int as i3, (random() * 1000000)::int as i4, (random() * 1000000)::int as i5, (random() * 1000000)::int as i6 FROM generate_series(1,10000000); SELECT 10000000\n\nA sequential scan over this large table takes a long time:\n\n    \n    \n    =# EXPLAIN ANALYZE SELECT * FROM tbloom WHERE i2 = 898732 AND i5 = 123451; QUERY PLAN ------------------------------------------------------------------------------------------------------ Seq Scan on tbloom (cost=0.00..2137.14 rows=3 width=24) (actual time=16.971..16.971 rows=0 loops=1) Filter: ((i2 = 898732) AND (i5 = 123451)) Rows Removed by Filter: 100000 Planning Time: 0.346 ms Execution Time: 16.988 ms (5 rows)\n\nEven with the btree index defined the result will still be a sequential scan:\n\n    \n    \n    =# CREATE INDEX btreeidx ON tbloom (i1, i2, i3, i4, i5, i6); CREATE INDEX =# SELECT pg_size_pretty(pg_relation_size('btreeidx')); pg_size_pretty ---------------- 3976 kB (1 row) =# EXPLAIN ANALYZE SELECT * FROM tbloom WHERE i2 = 898732 AND i5 = 123451; QUERY PLAN ------------------------------------------------------------------------------------------------------ Seq Scan on tbloom (cost=0.00..2137.00 rows=2 width=24) (actual time=12.805..12.805 rows=0 loops=1) Filter: ((i2 = 898732) AND (i5 = 123451)) Rows Removed by Filter: 100000 Planning Time: 0.138 ms Execution Time: 12.817 ms (5 rows)\n\nHaving the bloom index defined on the table is better than btree in handling\nthis type of search:\n\n    \n    \n    =# CREATE INDEX bloomidx ON tbloom USING bloom (i1, i2, i3, i4, i5, i6); CREATE INDEX =# SELECT pg_size_pretty(pg_relation_size('bloomidx')); pg_size_pretty ---------------- 1584 kB (1 row) =# EXPLAIN ANALYZE SELECT * FROM tbloom WHERE i2 = 898732 AND i5 = 123451; QUERY PLAN --------------------------------------------------------------------------------------------------------------------- Bitmap Heap Scan on tbloom (cost=1792.00..1799.69 rows=2 width=24) (actual time=0.388..0.388 rows=0 loops=1) Recheck Cond: ((i2 = 898732) AND (i5 = 123451)) Rows Removed by Index Recheck: 29 Heap Blocks: exact=28 -> Bitmap Index Scan on bloomidx (cost=0.00..1792.00 rows=2 width=0) (actual time=0.356..0.356 rows=29 loops=1) Index Cond: ((i2 = 898732) AND (i5 = 123451)) Planning Time: 0.099 ms Execution Time: 0.408 ms (8 rows)\n\nNow, the main problem with the btree search is that btree is inefficient when\nthe search conditions do not constrain the leading index column(s). A better\nstrategy for btree is to create a separate index on each column. Then the\nplanner will choose something like this:\n\n    \n    \n    =# CREATE INDEX btreeidx1 ON tbloom (i1); CREATE INDEX =# CREATE INDEX btreeidx2 ON tbloom (i2); CREATE INDEX =# CREATE INDEX btreeidx3 ON tbloom (i3); CREATE INDEX =# CREATE INDEX btreeidx4 ON tbloom (i4); CREATE INDEX =# CREATE INDEX btreeidx5 ON tbloom (i5); CREATE INDEX =# CREATE INDEX btreeidx6 ON tbloom (i6); CREATE INDEX =# EXPLAIN ANALYZE SELECT * FROM tbloom WHERE i2 = 898732 AND i5 = 123451; QUERY PLAN --------------------------------------------------------------------------------------------------------------------------- Bitmap Heap Scan on tbloom (cost=24.34..32.03 rows=2 width=24) (actual time=0.028..0.029 rows=0 loops=1) Recheck Cond: ((i5 = 123451) AND (i2 = 898732)) -> BitmapAnd (cost=24.34..24.34 rows=2 width=0) (actual time=0.027..0.027 rows=0 loops=1) -> Bitmap Index Scan on btreeidx5 (cost=0.00..12.04 rows=500 width=0) (actual time=0.026..0.026 rows=0 loops=1) Index Cond: (i5 = 123451) -> Bitmap Index Scan on btreeidx2 (cost=0.00..12.04 rows=500 width=0) (never executed) Index Cond: (i2 = 898732) Planning Time: 0.491 ms Execution Time: 0.055 ms (9 rows)\n\nAlthough this query runs much faster than with either of the single indexes,\nwe pay a penalty in index size. Each of the single-column btree indexes\noccupies 2 MB, so the total space needed is 12 MB, eight times the space used\nby the bloom index.\n\n### F.7.3. Operator Class Interface #\n\nAn operator class for bloom indexes requires only a hash function for the\nindexed data type and an equality operator for searching. This example shows\nthe operator class definition for the text data type:\n\n    \n    \n    CREATE OPERATOR CLASS text_ops DEFAULT FOR TYPE text USING bloom AS OPERATOR 1 =(text, text), FUNCTION 1 hashtext(text);\n\n### F.7.4. Limitations #\n\n  * Only operator classes for int4 and text are included with the module.\n\n  * Only the = operator is supported for search. But it is possible to add support for arrays with union and intersection operations in the future.\n\n  * bloom access method doesn't support UNIQUE indexes.\n\n  * bloom access method doesn't support searching for NULL values.\n\n### F.7.5. Authors #\n\nTeodor Sigaev <teodor@postgrespro.ru>, Postgres Professional, Moscow, Russia\n\nAlexander Korotkov <a.korotkov@postgrespro.ru>, Postgres Professional, Moscow,\nRussia\n\nOleg Bartunov <obartunov@postgrespro.ru>, Postgres Professional, Moscow,\nRussia\n\nPrev| Up| Next  \n---|---|---  \nF.6. basic_archive \u2014 an example WAL archive module| Home| F.8. btree_gin \u2014 GIN\noperator classes with B-tree behavior  \n  \n## Submit correction\n\nIf you see anything in the documentation that is not correct, does not match\nyour experience with the particular feature or requires further clarification,\nplease use this form to report a documentation issue.\n\nPrivacy Policy | Code of Conduct | About PostgreSQL | Contact\n\nCopyright \u00a9 1996-2024 The PostgreSQL Global Development Group\n\n", "frontpage": true}
