{"aid": "40169567", "title": "HNSW in DuckDB", "url": "https://github.com/duckdb/duckdb_vss", "domain": "github.com/duckdb", "votes": 1, "user": "krishadi", "posted_at": "2024-04-26 14:04:26", "comments": 0, "source_title": "GitHub - duckdb/duckdb_vss", "source_text": "GitHub - duckdb/duckdb_vss\n\nSkip to content\n\n## Navigation Menu\n\nSign in\n\n# Search code, repositories, users, issues, pull requests...\n\nSearch syntax tips\n\nSign in\n\nSign up\n\nYou signed in with another tab or window. Reload to refresh your session. You\nsigned out in another tab or window. Reload to refresh your session. You\nswitched accounts on another tab or window. Reload to refresh your session.\nDismiss alert\n\nduckdb / duckdb_vss Public\n\ngenerated from duckdb/extension-template\n\n  * Notifications\n  * Fork 3\n  * Star 20\n\n### License\n\nMIT license\n\n20 stars 3 forks Branches Tags Activity\n\nStar\n\nNotifications\n\n# duckdb/duckdb_vss\n\nThis commit does not belong to any branch on this repository, and may belong\nto a fork outside of the repository.\n\n1 Branch\n\n0 Tags\n\n## Folders and files\n\nName| Name| Last commit message| Last commit date  \n---|---|---|---  \n  \n## Latest commit\n\nMaxxenMerge pull request #6 from Maxxen/devApr 16, 20248145f41 \u00b7 Apr 16,\n2024Apr 16, 2024\n\n## History\n\n46 Commits  \n  \n### .github/workflows\n\n|\n\n### .github/workflows\n\n| Merge pull request #5 from carlopi/patch| Apr 15, 2024  \n  \n### docs\n\n|\n\n### docs\n\n| Initial commit| Jan 12, 2024  \n  \n### duckdb @ 5bcfd74\n\n|\n\n### duckdb @ 5bcfd74\n\n| update duckdb| Apr 16, 2024  \n  \n### scripts\n\n|\n\n### scripts\n\n| Initial commit| Jan 12, 2024  \n  \n### src\n\n|\n\n### src\n\n| dont store vectors in the index, expose tuning options during index c...|\nApr 16, 2024  \n  \n### test\n\n|\n\n### test\n\n| dont store vectors in the index, expose tuning options during index c...|\nApr 16, 2024  \n  \n### .clang-format\n\n|\n\n### .clang-format\n\n| replace metadata writer with new linked blocks index writer, format code|\nJan 19, 2024  \n  \n### .gitignore\n\n|\n\n### .gitignore\n\n| Initial commit| Jan 12, 2024  \n  \n### .gitmodules\n\n|\n\n### .gitmodules\n\n| Initial commit| Jan 12, 2024  \n  \n### CMakeLists.txt\n\n|\n\n### CMakeLists.txt\n\n| initial commit| Jan 15, 2024  \n  \n### LICENSE\n\n|\n\n### LICENSE\n\n| Initial commit| Jan 12, 2024  \n  \n### Makefile\n\n|\n\n### Makefile\n\n| Fix paths in duckdb-wasm| Feb 14, 2024  \n  \n### README.md\n\n|\n\n### README.md\n\n| minor tweaks| Mar 20, 2024  \n  \n### vcpkg.json\n\n|\n\n### vcpkg.json\n\n| initial commit| Jan 15, 2024  \n  \n## Repository files navigation\n\n# DuckDB-VSS\n\nVector Similarity Search for DuckDB\n\nThis is an experimental extension for DuckDB that adds indexing support to\naccelerate Vector Similarity Search using DuckDB's new fixed-size ARRAY type\nadded in version v0.10.0. This extension is based on the usearch library and\nserves as a proof of concept for providing a custom index type, in this case a\nHNSW index, from within an extension and exposing it to DuckDB.\n\n## Usage\n\nTo create a new HNSW index on a table with an ARRAY column, use the CREATE\nINDEX statement with the USING HNSW clause. For example:\n\n    \n    \n    CREATE TABLE my_vector_table (vec FLOAT[3]); INSERT INTO my_vector_table SELECT array_value(a,b,c) FROM range(1,10) ra(a), range(1,10) rb(b), range(1,10) rc(c); CREATE INDEX my_hnsw_index ON my_vector_table USING HNSW (vec);\n\nThe index will then be used to accelerate queries that use a ORDER BY clause\nevaluating one of the supported distance metric functions against the indexed\ncolumns and a constant vector, followed by a LIMIT clause. For example:\n\n    \n    \n    SELECT * FROM my_vector_table ORDER BY array_distance(vec, [1,2,3]::FLOAT[3]) LIMIT 3; # We can verify that the index is being used by checking the EXPLAIN output # and looking for the HNSW_INDEX_SCAN node in the plan EXPLAIN SELECT * FROM my_vector_table ORDER BY array_distance(vec, [1,2,3]::FLOAT[3]) LIMIT 3; \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 PROJECTION \u2502 \u2502 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2502 \u2502 #0 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 PROJECTION \u2502 \u2502 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2502 \u2502 vec \u2502 \u2502array_distance(vec, [1.0, 2\u2502 \u2502 .0, 3.0]) \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 HNSW_INDEX_SCAN \u2502 \u2502 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2502 \u2502 t1 (HNSW INDEX SCAN : \u2502 \u2502 my_idx) \u2502 \u2502 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2502 \u2502 vec \u2502 \u2502 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2502 \u2502 EC: 3 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\nBy default the HNSW index will be created using the euclidean distance l2sq\n(L2-norm squared) metric, matching DuckDBs array_distance function, but other\ndistance metrics can be used by specifying the metric option during index\ncreation. For example:\n\n    \n    \n    CREATE INDEX my_hnsw_cosine_index ON my_vector_table USING HNSW (vec) WITH (metric = 'cosine');\n\nThe following table shows the supported distance metrics and their\ncorresponding DuckDB functions\n\nDescription| Metric| Function  \n---|---|---  \nEuclidean distance| l2sq| array_distance  \nCosine similarity| cosine| array_cosine_similarity  \nInner product| ip| array_inner_product  \n  \n## Inserts, Updates, Deletes and Re-Compaction\n\nThe HNSW index does support inserting, updating and deleting rows from the\ntable after index creation. However, there are two things to keep in mind:\n\n  * Its faster to create the index after the table has been populated with data as the initial bulk load can make better use of parallelism on large tables.\n  * Deletes are not immediately reflected in the index, but are instead \"marked\" as deleted, which can cause the index to grow stale over time and negatively impact query quality and performance.\n\nTo address this, you can call the PRAGMA hnsw_compact_index('<index name>')\npragma function to trigger a re-compaction of the index pruning deleted items,\nor re-create the index after a significant number of updates.\n\n## Limitations\n\n  * Only vectors consisting of FLOATs are supported at the moment.\n  * The index itself is not buffer managed and must be able to fit into RAM memory.\n\nWith that said, the index will be persisted into the database if you run\nDuckDB with a disk-backed database file. But there is no incremental updates,\nso every time DuckDB performs a checkpoint the entire index will be serialized\nto disk and overwrite its previous blocks. Similarly, the index will be\ndeserialized back into main memory in its entirety after a restart of the\ndatabase, although this will be deferred until you first access the table\nassociated with the index. Depending on how large the index is, the\ndeserialization process may take some time, but it should be faster than\nsimply dropping and re-creating the index.\n\n## Building the extension\n\n### Build steps\n\nTo build the extension, run:\n\n    \n    \n    make\n\nThe main binaries that will be built are:\n\n    \n    \n    ./build/release/duckdb ./build/release/test/unittest ./build/release/extension/vss/vss.duckdb_extension\n\n  * duckdb is the binary for the duckdb shell with the extension code automatically loaded.\n  * unittest is the test runner of duckdb. Again, the extension is already linked into the binary.\n  * vss.duckdb_extension is the loadable binary as it would be distributed.\n\n## Running the extension\n\nTo run the extension code, simply start the shell with ./build/release/duckdb.\n\n## Running the tests\n\nThes SQL tests can be run using:\n\n    \n    \n    make test\n\n## About\n\nNo description, website, or topics provided.\n\n### Resources\n\nReadme\n\n### License\n\nMIT license\n\nActivity\n\nCustom properties\n\n### Stars\n\n20 stars\n\n### Watchers\n\n4 watching\n\n### Forks\n\n3 forks\n\nReport repository\n\n## Releases\n\nNo releases published\n\n## Packages 0\n\nNo packages published\n\n## Contributors 2\n\n  * Maxxen Max Gabrielsson\n  * carlopi Carlo Piovesan\n\n## Languages\n\n  * C++ 96.1%\n  * Makefile 1.5%\n  * Other 2.4%\n\n## Footer\n\n\u00a9 2024 GitHub, Inc.\n\nYou can\u2019t perform that action at this time.\n\n", "frontpage": false}
