{"aid": "40104430", "title": "Leverage Lua Scripting with Nginx Using OpenResty", "url": "https://www.vladsiv.com/nginx-reverse-proxy-lua-scripting/", "domain": "vladsiv.com", "votes": 2, "user": "vladsiv", "posted_at": "2024-04-21 09:59:12", "comments": 0, "source_title": "Nginx Reverse Proxy and Lua Scripting", "source_text": "Nginx Reverse Proxy and Lua Scripting - vladsiv\n\n# Nginx Reverse Proxy and Lua Scripting\n\nApril 9, 2024 13 minute read\n\nImage Source: Pexels\n\n## IntroductionPermalink\n\nRecently, I\u2019ve had the opportunity to work on a very interesting topic. The\nobjective was to modify HTTP requests at the proxy level, as we lacked control\nover both the source and destination services. I\u2019ve configured Nginx as a\nreverse proxy many times, so setting it up was straightforward. After brief\nresearch I\u2019ve found that I can use Lua scripting to write some custom code\nusing ngx_http_lua_module which embeds the power of Lua into Nginx HTTP\nServers.\n\nThis module is not distributed with Nginx source but is a core component of\nOpenResty\u00ae.\n\nUsing Lua together with Nginx allows us to:\n\n  * perform arbitrary complex access control and security checks in Lua before requests reach the upstream backends\n  * manipulate request headers and body using a custom Lua code within Nginx\n  * fetching information in-flight from different storage backends before processing the request\n  * implementing custom logic for caching mechanisms within Nginx using Lua\n\nand many more. We have endless possibilities thanks to our ability to utilize\ncustom Lua code for achieving our desired outcomes.\n\n## LuaPermalink\n\nIt was my first time using Lua, leading me to invest time in exploring and\nunderstanding the language.\n\nThe motivation for the language is quite interesting. It was created in 1993\nby members of the Computer Graphics Technology Group at the Pontifical\nCatholic University of Rio de Janeiro, in Brazil. It was developed to be\nextremely lightweight, simple, and portable. The motivation for the language\narose from the need for a flexible and efficient scripting language that could\nbe easily integrated into various applications. This is achieved by making Lua\ncross-platform by writing the interpreter of compiled bytecodes in ANSI C, and\nimplementing a simple C API which can be easily embedded into different\napplications.\n\nOver the years, Lua gained popularity in many industries, particularly in the\ngaming industry, notably for its simplicity, flexibility, and portability,\nmaking it a preferred choice for scripting in video games. If you\u2019ve ever used\na user-created modification or scenario in games like Roblox, World of\nWarcraft, Dota 2, etc., chances are it\u2019s built using Lua scripting.\n\nLua can be also embedded in any other application as well. In this post we\u2019ll\nfocus on how to use Lua scripting with Nginx. The OpenResty\u00ae project provides\nan enhanced version of Nginx together with embedded LuaJIT and many other Lua\nlibraries.\n\nIf you\u2019d like to get a quick grasp of some Lua basics, I suggest the following\nYouTube video\n\n## OpenResty\u00aePermalink\n\nAs stated on the official OpenResty\u00ae website\n\n> OpenResty\u00ae is a full-fledged web platform that integrates our enhanced\n> version of the Nginx core, our enhanced version of LuaJIT, many carefully\n> written Lua libraries, lots of high quality 3rd-party Nginx modules, and\n> most of their external dependencies. It is designed to help developers\n> easily build scalable web applications, web services, and dynamic web\n> gateways\n\nOpenResty\u00ae is not an Nginx fork, it\u2019s a higher level application and gateway\nplatform that uses Nginx as a component. It constantly imports the latest\nfeatures and bug fixes from official Nginx, LuaJIT, and other 3rd party\nrepositories keeping it up-to-date. We can also develop our own Lua modules\nand use it directly in Nginx, check Custom Lua Modules for more information.\n\nThe main building blocks of scripting custom Lua code within Nginx are\nDirectives. The directives are used to define the timing of custom Lua code\nexecution and how the result will be used.\n\nFor example, the directive init_by_lua_block is executed when a new Lua VM is\ncreated. This block won\u2019t be executed upon every request if the caching mode\nis turned on, which allows us to preload the Lua modules in Lua VM. It will\nleverage Copy-on-write making it more memory efficient.\n\n    \n    \n    init_by_lua_block { require \"cjson\" } server { location = /api { content_by_lua_block { -- the following require() will just return -- the already loaded module from package.loaded: ngx.say(require \"cjson\".encode{dog = 5, cat = 6}) } } }\n\n> This example has been taken from init_by_lua_block\n\nAnother very important directive is access_by_lua_block. This directive will\nexecute the Lua code, provided in the block, for every request. It runs during\nthe Rewrite/Access phase allowing us to access and rewrite the request. Using\nthis directive we can modify the request headers and body, among many other\nthings.\n\n> See examples provided in Modifying Headers and Modifying Body sections for\n> more information on how to use this directive.\n\nThe following diagram represents the order of directives\n\nImage Source: Directives\n\n> Make sure to explore the official website OpenResty\u00ae and lua-nginx-module\n> repository for a deeper dive into how OpenResty\u00ae incorporates Lua with Nginx\n\n## PlaygroundPermalink\n\nIn order to demonstrate how we can modify requests in-flight we\u2019ll create an\nNginx proxy server using OpenResty\u00ae and set up a simple local environment to\nplay around with its configuration.\n\nYou can install official prebuilt packages for some of the common Linux\ndistributions, or build it from source on your own. Please see Installation\nfor more information.\n\nHowever, I find it easier to just spin up a Docker container and configure\nDocker bridge network in order to use proxy server together with a local test\nAPI which will serve as a proxy destination.\n\nFortunately, OpenResty\u00ae already provides everything that\u2019s needed for running\nOpenResty\u00ae in a Docker container. Repository docker-openresty is quite\nextensive and specifies how we can build our own Docker image with different\nconfigurations depending on the use case.\n\nAs a simple test, we\u2019ll just pull a prebuilt image from a Docker Hub\nopenresty/openresty and use docker compose to set the bridge network\nconfigurations.\n\nThe idea here is to have an OpenResty\u00ae running in a docker container and\nserving as a proxy to our test API running in the localhost. By doing this, we\ncan send requests to the proxy, make modifications, and inspect them on the\ntest API\u2019s end.\n\nThe implementation of test API is not important here, but if you want a simple\nand fast solution I propose FastAPI. The following two files is everything we\nneed to start playing around\n\n    \n    \n    # app.py from fastapi import FastAPI, Request app = FastAPI() @app.post(\"/\") async def root(request: Request): request_body = await request.json() request_headers = request.headers return { \"body\": request_body, \"headers\": request_headers, }\n    \n    \n    # main.py import uvicorn from app import app if __name__ == \"__main__\": uvicorn.run( \"main:app\", port=8000, host=\"172.17.0.1\", reload=True )\n\nNext, we need to configure OpenResty\u00ae service. You can do it directly on the\ncommand line or using a compose yml, the result should be the same. Two\nparameters are important:\n\n  * volumes - Create the templates folder and place nginx.conf in it. This folder will be mounted as conf.d, overwriting the default Nginx configuration. Doing so, we can play around with Nginx\u2019s configuration without entering the running Docker container\n  * extra_hosts - The Docker daemon supports a special host-gateway value which resolves to the host\u2019s gateway IP and lets containers connect to services running on the host. Adding host.docker.internal:host-gateway as extra_hosts (or --add-host if specified on the command line) corresponds to an entry with the IP address and hostname in /etc/hosts inside containers for this service i.e. it will know how to resolve the IP and reach our localhost.\n\n    \n    \n    services: proxy: image: openresty/openresty ports: - 8080:80 volumes: - ./templates:/etc/nginx/conf.d extra_hosts: - \"host.docker.internal:host-gateway\"\n\nPlace the following content in nginx.conf file in templates folder\n\n    \n    \n    server { listen 80; location / { default_type application/json; proxy_pass http://host.docker.internal:8000; } }\n\nAfter running API and Docker compose up, try to send a request to OpenResty\u00ae\nservice i.e. Nginx:\n\n    \n    \n    curl -X POST -d '{\"a\": \"c\"}' http://localhost:8080\n\nYou should see a request going to reverse proxy\n\n    \n    \n    proxy-1 | 172.27.0.1 - - [09/Apr/2024:10:46:03 +0000] \"POST / HTTP/1.1\" 200 200 \"-\" \"curl/8.5.0\"\n\nThen to API\n\n    \n    \n    INFO: 172.27.0.2:39870 - \"POST / HTTP/1.0\" 200 OK\n\nand response coming back as\n\n    \n    \n    {\"body\":{\"a\":\"c\"},\"headers\":{\"host\":\"host.docker.internal:8000\",\"connection\":\"close\",\"content-length\":\"10\",\"user-agent\":\"curl/8.5.0\",\"accept\":\"*/*\",\"content-type\":\"application/x-www-form-urlencoded\"}}\n\n> Note: Local IPs will be different in your case. Check the Docker gateway and\n> modify the uvicorn host, if needed.\n\nNow that we have everything up and running, we can start playing around with\nLua scripting in Nginx.\n\n## Modifying HeadersPermalink\n\n### Clearing and Setting ValuesPermalink\n\nModifying headers using Lua can be easily implemented by extending the\nnginx.conf and defining access_by_lua_block. As mentioned before, this will\nallow us to access and rewrite the request.\n\nWe can read and write Nginx variable values by simple referencing\nngx.var.some_nginx_variable_name inside the Lua block.\n\nFor example ngx.var.request_method gives us access to the request method.\n\nThe following configuration checks if the request method is POST, clears the\nuser-agent header value, and sets a custom test value.\n\n    \n    \n    server { listen 80; location / { default_type application/json; access_by_lua_block { if ngx.var.request_method == \"POST\" then ngx.req.clear_header(\"user-agent\") ngx.req.set_header(\"test\", \"123\") end } proxy_pass http://host.docker.internal:8000; } }\n\nIf you compare the response with the previous example, you\u2019ll see that user-\nagent value is no longer present and we have \"test\":\"123\" in header.\n\n### Dynamic Header ValuesPermalink\n\nHardcoding the header values is fine, but we can do it dynamically by sending\nheader values inside a body request.\n\nFirst we need to parse the request body, gather values, and then modify the\nheader. Body parsing is done using cjson, Lua module which implements a fast\nJSON encoding/parsing module for Lua.\n\nBefore we define server we should preload the cjson module, as aforementioned.\nEven if we use require \"cjson\" later in the Lua block it will be preloaded, so\nit will be only retrieved, not loaded again.\n\nIn order to get request body data we use ngx.req.get_body_data(). However, we\nshould be careful since this function may return nil if the request body has\nnot been read. To avoid this, we use ngx.req.read_body() which forces the\nmodule to read the body before we try to access it.\n\n> We can also turn on lua_need_request_body which will read the body by\n> default. Please not that this is not recommended. The OpenResty\u00ae suggest\n> using ngx.req.read_body and ngx.req.discard_body for finer control over the\n> request body reading process instead. Check lua_need_request_body for more\n> details.\n\nFinally, we can parse the request body and loop over header values that we\nwant to remove.\n\n    \n    \n    init_by_lua_block { require \"cjson\" } server { listen 80; location / { default_type application/json; access_by_lua_block { if ngx.var.request_method == \"POST\" then local cjson = require \"cjson\" ngx.req.read_body() local body = cjson.decode(ngx.req.get_body_data()) for k,v in pairs(body[\"remove_headers\"]) do ngx.log(ngx.ERR, \"Clearing header \" .. v) ngx.req.clear_header(v) end end } proxy_pass http://host.docker.internal:8000; } }\n\n> Note that I used ngx.ERR for logging. This is fine since we are playing\n> around, but in real-world application you\u2019d implement a comprehensive\n> logging using ngx.errlog Lua module. Check lua-resty-core.ngx.errlog for\n> some guidelines.\n\nObviously, in the same fashion, we could specify add_headers values in a\nrequest body, loop over them, and add them using ngx.req.set_header(<key>,\n<value>). The possibilities are endless, depending entirely on your objectives\nand the requirements you need to fulfill.\n\nThere are many other function for request manipulation, check the full list\nNginx API for Lua and try something out.\n\n## Modifying BodyPermalink\n\n### Clearing and Setting BodyPermalink\n\nStraight-forward example is to just drop the whole body or set something new.\nThis could be easily done using ngx.req.discard_body() and\nngx.req.set_body_data().\n\nHowever, there\u2019s a little catch. The ngx.req.discard_body() discards the body\nimmediately when the data is read on the connection. If we use it after the\nngx.req.read_body() this function does nothing and returns immediately. In the\nsame fashion, if we use ngx.req.read_body() after we discard the body the read\nfunction does nothing and returns immediately. Therefore, either we discard\nthe body completely or use it for further processing.\n\nSimilarly, ngx.req.set_body_data() can work only if read the body using\nngx.req.read_body() and we don\u2019t discard the body before using it.\n\nThe following block reads the body and replaces it with a hardcoded example.\n\n    \n    \n    init_by_lua_block { require \"cjson\" } server { listen 80; location / { default_type application/json; access_by_lua_block { if ngx.var.request_method == \"POST\" then local cjson = require \"cjson\" ngx.req.read_body() local data = { a = 1, b = \"2\" } local body = cjson.encode(data) ngx.req.set_body_data(body) end } proxy_pass http://host.docker.internal:8000; } }\n\n### Dynamic BodyPermalink\n\nSince we can read all the request parameters, we could also extract, modify,\nenrich, and construct a new body.\n\nFor example, concatenating body values and extracting values from headers\n\n    \n    \n    init_by_lua_block { require \"cjson\" } server { listen 80; location / { default_type application/json; access_by_lua_block { if ngx.var.request_method == \"POST\" then local cjson = require \"cjson\" ngx.req.read_body() local body = cjson.decode(ngx.req.get_body_data()) local headers = ngx.req.get_headers() ngx.req.discard_body() local data = { c = body[\"a\"] + body[\"b\"], method = ngx.var.request_method, host = headers[\"host\"] } local new_body = cjson.encode(data) ngx.req.set_body_data(new_body) end } proxy_pass http://host.docker.internal:8000; } }\n\nThis example can be extended by issuing a synchronous but non-blocking Nginx\nsubrequest using ngx.location.capture() to get additional data from other\nlocal Nginx locations:\n\n    \n    \n    res = ngx.location.capture('/foo/bar?a=3&b=4')\n\nKeep in mind that this is not ordinary HTTP/TCP request, everything is\nhappening internally, on C level.\n\nIf we want to make actual HTTP requests to external services, we would use\nlua-resty-http which implements Lua HTTP client cosocket driver for OpenResty\u00ae\n/ ngx_lua.\n\n    \n    \n    local httpc = require(\"resty.http\").new() local res, err = httpc:request_uri(\"http://www.example.com\", {method=\"GET\"})\n\n> Note: Be aware that you need to set resolver which will configure name\n> servers used to resolve names of upstream servers into addresses. Please see\n> resolver for more information.\n\n## Custom Lua ModulesPermalink\n\nAs our Lua code block gets bigger, its maintainability decreases. In that\ncase, we prefer to divide the block into several custom Lua modules.\n\nBefore we start requesting a Lua module, we need to define the path that will\nbe searched. This is done using lua_package_path, before we define the Lua\ncode block.\n\n    \n    \n    lua_package_path \"$prefix/lua/?.lua;;\";\n\nThe $prefix is used in the search path string to indicate the path of the\nserver prefix usually specified using -p PATH command-line option while\nstarting the Nginx server.\n\nSince we are working with OpenResty\u00ae docker image and we use docker compose,\nwe should create a lua folder, just like templates, mount it as additional\nvolume and define the search path for $prefix. For simplicity\u2019s sake, we\u2019ll\njust set it to the root.\n\nCompose yml now looks like:\n\n    \n    \n    services: proxy: image: openresty/openresty ports: - 8080:80 volumes: - ./templates:/etc/nginx/conf.d - ./lua:/custom-lua extra_hosts: - \"host.docker.internal:host-gateway\"\n\nwhere ./lua is a folder, next to templates, which contains process.lua file\nwith the following content\n\n    \n    \n    local cjson = require \"cjson\" local _M = {} function _M.get_remove_headers() ngx.req.read_body() local body = cjson.decode(ngx.req.get_body_data()) return body[\"remove_headers\"] end function _M.remove_headers(headers) for k,v in pairs(headers) do ngx.req.clear_header(v) end end function _M.set_response_body() local data = { result = \"SUCCESS\" } local body = cjson.encode(data) ngx.req.set_body_data(body) end return _M\n\nThis module contains get_remove_headers, remove_headers, and set_response_body\nfunctions. Just like we did in the previous example, but now in a dedicated\nLua module.\n\nFinally, nginx.conf looks like\n\n    \n    \n    lua_package_path \"/custom-lua/?.lua;;\"; init_by_lua_block { require \"process\" } server { listen 80; location / { default_type application/json; access_by_lua_block { local process = require \"process\" remove_headers = process.get_remove_headers() process.remove_headers(remove_headers) process.set_response_body() } proxy_pass http://host.docker.internal:8000; } }\n\nIf you run the following curl\n\n    \n    \n    curl -X POST -d '{\"remove_headers\": [\"user-agent\", \"accept\", \"content-type\"]}' http://localhost:8080\n\nThe response should be\n\n    \n    \n    {\"body\":{\"result\":\"SUCCESS\"},\"headers\":{\"host\":\"host.docker.internal:8000\",\"connection\":\"close\",\"content-length\":\"20\"}}\n\nClearly, this represents a significantly cleaner and more maintainable\napproach. I haven\u2019t delved into error handling in this instance, as this post\npresents straightforward examples and serves solely as an experiment. However,\norganizing the code into distinct modules will facilitate the development of\nrobust and maintainable software if you are building a real-world application.\n\nIf this is your first time playing with Lua in Nginx, I hope this post gave\nyou a nice introduction of what\u2019s possible and how to get started. As you can\nsee, the possibilities are endless and all comes down to what you actually\nwant to accomplish.\n\nThe documentation on the OpenResty\u00ae official website and GitHub repositories\nis pretty extensive and detailed. There are tons of examples and guidelines on\nhow to build dynamic and scalable web services using Lua with Nginx.\nDefinitely give it a look, and enjoy coding in Lua!\n\n## ResourcesPermalink\n\n  * OpenResty\u00ae\n  * GitHub - openresty/lua-nginx-module\n  * DockerHub - openresty/openresty\n  * Write Your Own Lua Modules for OpenResty Applications\n\nUpdated: April 9, 2024\n\n#### Leave a comment\n\nCC BY 4.0 - 2024 vladsiv. Powered by Jekyll & Minimal Mistakes.\n\n", "frontpage": false}
