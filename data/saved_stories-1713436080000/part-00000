{"aid": "40072937", "title": "Databases Are Spreadsheets", "url": "https://stack.convex.dev/databases-are-spreadsheets", "domain": "convex.dev", "votes": 4, "user": "ArboretumGuy", "posted_at": "2024-04-18 04:25:40", "comments": 0, "source_title": "Databases are Spreadsheets", "source_text": "Databases are Spreadsheets\n\nPatternsPerspectivesWalkthroughsAI\n\nBright ideas and techniques for building with Convex.\n\nSarah Shader\n\n2 days ago\n\n# Databases are Spreadsheets\n\nThis is my mental model of databases, which I learned during an internship\ninterview and has stuck with me through 5+ years of working professionally on\ndata loading platforms.\n\n  * Databases are just big spreadsheets\n  * An index is just a view of the spreadsheet sorted by one or more columns\n  * Binary search^1 over a sorted list is faster than a linear scan (for large lists)\n\nImagine storing movies in a spreadsheet. It might look something like this:\n\nWe want to store this with some order, so this spreadsheet is sorted by the\nfirst column -- a unique _id field.^2 This means we can quickly find a\ndocument from this table given its ID because we can binary search.\n\nLet\u2019s say we want to build a way for users to see all the movies for a given\ndirector like this (here, sorted by release date):\n\nWe might want a view that sorts by the director, and then the year:\n\nThis is an index! We could define it with convex like so:\n\n    \n    \n    Movies: defineTable(...).index(\"ByDirectorAndYear\", [\"director\", \"year\"])\n\nThis is like another tab in our spreadsheet, and we use the _id to reference\nthe document in the first tab to avoid needing to include the full document in\neach tab of the spreadsheet (the movie names are shown to the side for\nconvenience).\n\nWe can use it to make the following query:\n\nGoal: Get all movies directed by Nolan.\n\nCode: db.query(\u201dMovies\u201d).withIndex(\u201dByDirectorAndYear\u201d, q => q.eq(\"director\",\n\"Nolan\"))\n\nPicture:\n\nWe use the Movies.ByDirectorAndYear tab to binary search for the first entry\nwith \u201cNolan\u201d, and keep grabbing rows until we reach a new director. Once we\nhave all these IDs, we can grab the full documents from the first table\nMovies.ById, binary searching for each ID. This means we can efficiently grab\nany contiguous chunk from our spreadsheet.\n\nOne thing we can observe right away is that when a new movie gets added or\nupdated in the first tab, we also need to add an entry to each tab in our\nspreadsheet. This means each index has a bit of write overhead and also\nrequires some additional storage.\n\nBut the Movies.ByDirectorAndYear tab is useful for making fast queries that\ntake advantage of the sorted order in that tab, so if we're making a lot of\nqueries that use this ordering, the write overhead + additional storage for\nmaintaining this extra tab is worth it.\n\nWe can use this mental model to go through a few more queries and make some\nobservations:\n\n#### We must go through columns in index order\n\nGoal: Get all movies from 2023.\n\nCode: \u274c db.query(\u201dMovies\u201d).withIndex(\u201dByDirectorAndYear\u201d, q => q.eq(\"year\",\n2023))\n\nPicture:\n\nThis query does not select a contiguous chunk from the spreadsheet \u2014 to find\nall the movies from 2023, we\u2019d have to look at every single row and can\u2019t use\nthe sorted columns in this tab to our advantage.\n\n#### Inequalities\n\nNow let\u2019s consider a new index ByYearAndDirector (which would be a better\nchoice for the example above).\n\nGoal: Get all movies created in 2018 or later.\n\nCode: \u2705 db.query(\u201dMovies\u201d).withIndex(\u201dByYearAndDirector\u201d, q => q.gte(\"year\",\n2018))\n\nPicture:\n\nEven though this isn\u2019t an \u201cequals\u201d, we can still binary search and select a\ncontiguous block with \u201cgreater than\u201d or \u201cless than\u201d.\n\n...But we can only use \u201cgreater than\u201d at the end.\n\nGoal: Get all movies created in in 2000 or later with directed by Nolan.\n\nCode: \u274c db.query(\u201dMovies\u201d).withIndex(\u201dByYearAndDirector\u201d, q => q.gte(\"year\",\n2000).eq(\"director\", \"Nolan\")\n\nPicture:\n\nWe can\u2019t do \u201cnot equals\u201d in a single efficient query \u2014 we need to do two\nbinary searches.\n\nGoal: Get all movies not made in 2018.\n\nCode:\n\n\u274c db.query(\u201dMovies\u201d).withIndex(\u201dByYearAndDirector\u201d, q => q.neq(\"year\", 2018))\n\n\u2705 db.query(\u201dMovies\u201d).withIndex(\u201dByYearAndDirector\u201d, q => q.gt(\"year\", 2018))\nand db.query(\u201dMovies\u201d).withIndex(\u201dByYearAndDirector\u201d, q => q.lt(\"year\", 2018))\n\nPicture:\n\n#### No efficient \u201cin\u201d / \u201cor\u201d\n\nGoal: Get movies directed by Nolan or Gerwig.\n\nCode:\n\n\u274c db.query(\u201dMovies\u201d).withIndex(\u201dByDirectorAndYear\u201d, q => q.in(\"director\",\n[\"Nolan\", \"Gerwig\"]))\n\n\u2705 db.query(\u201dMovies\u201d).withIndex(\u201dByDirectorAndYear\u201d, q => q.eq(\"director\",\n\"Nolan\")) and db.query(\u201dMovies\u201d).withIndex(\u201dByDirectorAndYear\u201d, q =>\nq.eq(\"director\", \"Gerwig\"))\n\nPicture:\n\nThis is really a separate query for each element in the \u201cin\u201d / \u201cor\u201d expression\nand cannot be done in a single efficient query.\n\n### Convex\u2019s query syntax\n\nConvex's syntax aims to make it clear what's efficient vs. what's not. Things\nin withIndex will be more efficient binary searches, things in filter or in\nplain JavaScript are not.\n\nGoing through the examples above:\n\n  * We prevent .withIndex(\"ByDirectorAndYear\", q => q.eq(\"year\", 2023)) (skipping fields)\n  * We prevent .withIndex(\"ByYearAndDirector\"), q => q.gte(\"year\", 0).eq(\"director\", \"Gerwig\") (non-final inequalities)\n  * There's no or, in, neq for withIndex\n\nIn comparison, it\u2019s easy to write all of these as a SQL query without\nrealizing they\u2019re slow. Just because it is possible to write a query in SQL\ndoesn't mean it'll be fast -- SQL's query planner will just try its best to\nchoose from the indexes you have and do a linear scan of the table if there's\nno better option.\n\nSomething like SELECT * from Movies WHERE title = \"Barbie\" LIMIT 1 might look\ninnocent enough, but if there's no index on title, the query planner will\niterate over the entire table. Even knowing all the indexes on a table, it\u2019s\noften hard to tell whether a SQL query is efficient or not by looking at it\nsince it's difficult to predict exactly what the query planner will choose to\ndo.\n\n### Why should I choose my indexes?\n\nNow we have a mental model of how indexes and databases work, but you might be\nasking why it\u2019s valuable to think about this or why you should be the one\ndeciding exactly which indexes you want.\n\nIf we keep applying the \u201cdatabases are spreadsheets\u201d mental model to different\nqueries and indexes, we\u2019ll find that some indexes aren\u2019t actually that useful\n...and it's usually specific to the product you're designing.\n\nAs an example, most directors only have a few movies (<20). Once we've\nnarrowed down to the movies for a single director, binary searching within\nthose ~20 for movies in a certain year or with a certain rating isn\u2019t much\nmore efficient than scanning all of them. Instead of a ByDirectorAndYear\nindex, we might just want ByDirector, and do any sorting and filtering we want\nwithout an index (in JavaScript):\n\n    \n    \n    const nolanMovies = await db.query(\"Movies\") .withIndex(\"ByDirector\", q => q.eq(\"director\", \"Nolan\")) .collect(); // sort by release date nolanMovies.sort((a, b) => a.year - b.year))\n\nIf we wanted to allow a bunch of different sorts and filters for a single\ndirector\u2019s movies, we probably can just do all the sorting and filtering in\nJavaScript and don\u2019t need an index. (e.g. \u201cGet movies directed by Nolan sorted\nby title\u201d, \u201cGet movies directed by Nolan available on Hulu\u201d).\n\nOn the other hand, we might want a ByGenreAndYear or a ByGenreAndRating index,\nsince there are many movies in a genre, so it\u2019s useful to be able to\nefficiently narrow down the results further (e.g. \u201cGet the top 50 rated horror\nmovies\u201d, \u201cGet comedy movies released in the last 5 years\u201d). We might even\ndesign our product to have fewer sorts and filters for the genre pages than\nfor the director pages to avoid needing a bunch of indexes.\n\nAs another example, an index like ByTitle also might not be that useful. Your\nusers probably won\u2019t want a list of all movies ever listed alphabetically and\nprobably won\u2019t look up a movie with the exact title. Instead you might want a\nfull text search index^3 on the title (so users can type \u201cthe dark kni\u201d to\nfind a movie), or you might want an index like ByTitleSlug where each movie\nhas a unique slug (e.g. little-women, little-women-2019) that can be used in\nURLs.\n\n## Summary\n\nTo repeat the mental model:\n\n  * Databases are just big spreadsheets\n  * An index is just a view of the spreadsheet sorted by one or more columns\n  * Binary search over a sorted list is faster than a linear scan (for large lists)\n\nDatabase indexes can be thought of as separate spreadsheet tabs that we keep\nin a specific sorted order, and keep up to date on every addition or update to\nthe original data. Indexes are useful for making queries fast as long as we\ncan select a contiguous chunk from the spreadsheet tab, using binary search\ninstead of scanning the entire spreadsheet.\n\nHopefully thinking of databases as spreadsheets is helpful for thinking about\nwhen and how to define an index based on the data you\u2019re storing and the\nproduct you\u2019re building. Convex is designed to make performance of queries\nclear by only supporting the operations that can be done efficiently in our\nquery syntax.\n\n### Footnotes\n\n  1. This is actually a B-Tree look up in a real database since they're designed to work efficiently with hard drives, but the mental model of binary search is pretty similar (O(log n) search on a sorted list). \u21a9\n\n  2. This is called the \"primary key\" in databases. \u21a9\n\n  3. How search indexes work probably merits an entirely separate post, but they're similar to the \"spreadsheet tab\" mental model in the sense that they require extra storage + write overhead, and that the parts of the query in withSearchIndex will be efficient compared to filter or plain JavaScript. \u21a9\n\nBuild in minutes, scale forever.\n\nConvex is the backend application platform with everything you need to build\nyour project. Cloud functions, a database, file storage, scheduling, search,\nand realtime updates fit together seamlessly.\n\nGet started\n\nJoin the Convex Community\n\nAsk the team questions, learn from others, and stay up-to-date on the latest\nwith Convex.\n\nJoin the Discord community\n\nShare this article\n\nRead next\n\nHow Convex Works\n\nThe full, unabridged story on how the Convex internals work.\n\nSujay Jayakar\n\nConvex: The Software-Defined Database\n\nWhich to choose, the expressive power of code, or the robustness of built-in\ndatabase features? With Convex, you can have both. By eliminating the boundary\nbetween the application and the database, Convex provides a uniform and\npowerful way to model your entire backend data flow and security using plain\nol' code.\n\nJamie Turner\n\nAutomatically Retry Actions\n\nLearn how to automatically retry actions in Convex while also learning a\nlittle about scheduling, system tables, and function references.\n\nJames Cowling\n\nStateful Migrations using Mutations\n\nOnline migrations in Convex using mutations. Including a helper to track\nmigration state!\n\nIan Macartney\n\nConvexDocsGitHubDashboardJobsLegal\n\n\u00a92024 Convex, Inc.\n\n", "frontpage": false}
