{"aid": "40065153", "title": "A MPA, no-bundler JavaScript meta-framework separating client- and server-code", "url": "https://mb21.github.io/blog/2024/04/13/mpa-no-bundler-javascript-meta-framework-separating-client-server-code", "domain": "mb21.github.io", "votes": 1, "user": "mb2100", "posted_at": "2024-04-17 14:29:17", "comments": 0, "source_title": "A MPA, no-bundler JavaScript meta-framework separating client- and server-code", "source_text": "A MPA, no-bundler JavaScript meta-framework separating client- and server-code\n\nmb21\u2019s blog\n\n# A MPA, no-bundler JavaScript meta-framework separating client- and server-\ncode\n\nApr 13, 2024\n\nModern JavaScript meta-frameworks like Next.js, Nuxt, Astro, SolidStart,\nSvelteKit and Qwik all use a bundler/transpiler (like Vite or Webpack), and\nwith the exception of Astro and Qwik, all of them are SPAs.\n\nI would love to have a modern JS meta-framework that does away with these two\nconventions, but instead chooses to optimize for simplicity and leveraging\nbrowser-built-ins over client-side JavaScript:\n\n  1. MPA over SPA. See the Single-Page App (SPA) vs. Multi-Page App (MPA) section of my previous blog post, but the gist is that for most use-cases, modern browsers can do client-side routing better than JS. This would also allow a simpler solution to what the Solid folks call the double data problem: that the complete template and associated data often ends up being sent to the client twice, as initial HTML and as JavaScript (because you may need it in JavaScript format for hydration or on client-side page navigation).\n  2. No bundler. Instead using browser-native Import maps and modulepreload links (i.e. the same approach that importmap-rails took). A very simple asset pipeline would still do two things: add a hash to the filename to enable long caching in a CDN, and converting TypeScript and JSX to plain JavaScript (TS and JSX now being so engrained in the ecosystem that it\u2019s built into both Deno and Bun).\n\nWhy? I think that for most use-cases (i.e. if you\u2019re not building the next\nFigma or Google Docs), this will provide both superiour UX and superior\ndeveloper-experience.\n\nA bundler (and related tooling) is just such a massive addition in complexity\nthat the developer needs to understand in order to debug certain issues. It\nseems to be a historical accident (because bundlers have their roots in\ntooling for client-side-only SPAs) that lots of functionality is implemented\nin bundlers instead of in plain JavaScript functions, which you would call\neither during static site generation or during server-side rendering: like how\nimport.meta.env is replaced in the build step and not accessing the env\nvariable when you run the server, or how CSS or SVG files are included into a\ncomponent. This makes it unnecessarily difficult to call the vite-based code,\nthat you wrote to render some HTML on your webiste, in a script (e.g. in a\ncron job to send an email). Also, the newcomers to modern JS-tooling that\nAstro targets routinely struggle with what exactly the behaviour of <script>\nand <script is:inline> is (in addition to forgetting to add client:load to\nhydrate islands).\n\nFinally, with the exception of Astro, all the modern meta-frameworks ship with\nsome kind of RPC functionality that doesn\u2019t make the network request explicit,\nand without forcing the developer to handle network errors: use server in\nReact/Next.js and SolidStart, as well as server$ in Qwik.\n\nAnd even in Astro, it\u2019s very easy to accidentally bundle some big npm package,\nthat you meant to use only on the server, into the client-side bundle. For\nexample, this can happen if you just import a self-contained pure helper\nfunction into the client, and that function happens to be in the same file\nthat imports some server code. That\u2019s why I\u2019ve started even in Astro projects,\nto name my files *.client.ts and *.server.ts. I\u2019d like the framework to\nenforce such a rule:\n\n  3. Strict separation of client-side and server-side code. To make sure that server-code never accidentally ends up on the client.\n\nThe reverse, client-code running on the server, is sometimes needed (to\nserver-side-render components), and is less problematic, since you will\nimmediately notice if you try to access window on the server, because it will\njust crash.\n\nWith these three constraints set, I\u2019m not sure what the best architecture\nwould look like.^1\n\nDo you know of any such framework and/or would be willing to collaborate on\ncreating one? Feel free to open a mastro issue.\n\n  1. Explicit islands? But then you\u2019re still sending the whole code of client-side components to the browser. We could do even better by just sending the interactive parts. \u21a9\n\nText by mb21, licensed as CC-by-sa.\n\n  * mb21\n  * mb2100\n\nSubscribe via RSS.\n\n", "frontpage": false}
