{"aid": "40253899", "title": "Rust to .NET compiler \u2013 Progress update", "url": "https://fractalfir.github.io/generated_html/rustc_codegen_clr_v0_1_2.html", "domain": "fractalfir.github.io", "votes": 29, "user": "sbt567", "posted_at": "2024-05-04 00:51:05", "comments": 9, "source_title": "Rust to .NET compiler - Progress update", "source_text": "Rust to .NET compiler - Progress update\n\n# Rust to .NET compiler - Progress update\n\nPublished on 22 Apr 2024 11 - 18 minute read\n\nThe past few months have been quite chaotic, both for the Rust to .NET\ncompiler backend I am working on, and for me personally. As I am writing this\narticle, I am in the metaphorical eye of the hurricane - I have just graduated\nhigh school, and I will be writing my national final exams in about a week.\nStill, since I have a bit of free time, I will try to write about some of the\nprogress I have made!\n\n### Tiny recap - what is rustc_codegen_clr?\n\nrustc_codegen_clr is a compiler backend, which allows the Rust compiler to\nturn Rust code into .NET assemblies. You can imagine it as a plugin, replacing\nthe very last stage of Rust compilation.\n\n# Big news - the project got accepted into GSoC.\n\nOne of the things I have worked on recently was submitting a proposal related\nto this project to Google Summer of Code. And, today I am proud to announce\nthat it has been accepted!\n\nWhat does this mean for the project? Well, first of all, I will be able to\nfocus solely on rustc_codegen_clr for the following months. Before that, I had\nbeen working on the project in my free time - in the evenings or weekends. So,\nthe speed of development should increase.\n\nMy proposal will also be mentored by Jack Huey, a member of the Rust language\nteam. Having an outside perspective, from someone experienced, should allow me\nto increase the quality of my project.\n\nSo, what is the proposal about, specifically?\n\n## Trouble with tests\n\nCurrently, my project relies on custom-written test executables. If the test\ncrashes, then it fails, if it does not, then it passes.\n\n    \n    \n    fn main(){  \n    ---  \n    let a = b\"Hello, Bob!\\n\\0\";  \n    let b = \"Hello, Bob!\\n\\0\";  \n    if black_box(a) != black_box(b).as_bytes(){  \n    core::intrinsics::abort();  \n    }  \n    let a:&[u8] = &b\"Hello, Bob!\\n\\0\"[..];  \n    let b:&[u8] = &b\"Hello, Bob!\\n\\0\"[..];  \n    if black_box(a) != black_box(b){  \n    core::intrinsics::abort();  \n    }  \n    }  \n  \nThis works, but it certainly is not the way Rust is usually tested. As many of\nyou probably know, Rust has built-in test support:\n\n    \n    \n    #[test]  \n    ---  \n    fn should_pass(){  \n    }  \n    #[test]  \n    #[should_panic]  \n    fn should_fail(){  \n    panic!();  \n    }  \n  \nYou can run those tests using the cargo test command.\n\nCurrently, the codegen is not able to compile & run the test shown above. At\nthe moment of writing, the test harness crashes when trying to parse the\ncommand line arguments. While this test program looks ridiculously simple, the\nharness generated by the compiler is not.\n\nMy GSoC proposal is simple: I want to get the test presented above to run\ncorrectly within the .NET runtime.\n\n### Why work on tests?\n\nYou may wonder: why focus on adding support for a different way of testing if\nI already have a way to write tests?\n\nFirst of all, I would be able to run tests not written with my project in\nmind. Things like the Rust test suite rely on this feature. While running the\nwhole compiler test suite is a whole other can of worms, this is a good first\nstep.\n\nI could also test individual crates(Rust libraries), or try to use something\nlike crater. crater is a Rust tool, that tests every single Rust library - all\n100 000 of them. With this kind of testing, I would be able to find almost any\nissue with this project. That is still far off in the future, but still - you\ncan see why better tests could be really useful.\n\nThe Rust tests would also run faster than my crappy, custom ones. Currently, I\nbuild a separate test binary for each test case - and that adds up quickly. At\nthe time of writing, my test suite takes 44.461 seconds to run, on my machine.\nOn gihub actions, the tests are even solwer - takning 4m to run. With cargo\ntests, I could build one big binary for all tests - cutting down the build\ntimes significantly.\n\nSo, you probably can understand why I feel this is a good goal for the near\nfuture.\n\n### What is needed for running better tests?\n\nThis is a small list of the work needed to get tests to work:\n\n  1. Command Line Argument Support - this one is partially done, but it is surprisingly complex.\n  2. Support for Atomic Intrinsics - The test harness is multithreaded, so it needs atomics for synchronization.\n  3. Support for multiple threads - This is kind of self-explanatory, this includes support for launching/handling multiple threads.\n  4. Better interop - necessary to implement multi-threading properly. Storing thread safely handles off-stack requires a lot more work, like adding first-class support for GCHandles.\n  5. Support for dyn Trait objects - while I personally almost never use them, and I don't like them, they undeniably have their uses. Since the standard library needs them to properly function, I will need to deal with them.\n  6. The ability to catch panics - Rust has a concept of panicking and unwinding. This way of handling errors is remarkably similar to .NET exceptions(I implement unwinds using .NET exceptions). Since the failing test cases will unwind(or throw exceptions), I will need to add support for catching them.\n\nAs you can see, the work I will need to put in was needed anyway - and getting\nbetter, faster tests is just the cherry on top.\n\nIf you have any questions/suggestions/whatever regarding my GSoC work, feel\nfree to ask me on Rust Zulip, or in the Reddit comments. Currently, I am in\nthe \"Community bonding\" GSoC phase - the point at which any feedback will be\nappreciated.\n\n# Command line arguments\n\nYou might have noticed I said that support for command line arguments \"is\nsurprisingly complex\". Why, tough? This seems like something that should be\nvery simple, borderline trivial. Well, it turns out Rust uses something\nunusual to get the command line arguments: weird linker tricks.\n\n# Getting command-line arguments the cool way\n\nIn most languages, command line arguments are passed to the main function of\nyour program, like this:\n\n    \n    \n    public static void Main(string[] args){  \n    ---  \n    // handle the args here  \n    }  \n  \nOr this:\n\n    \n    \n    int main(int argc, char** argv){  \n    ---  \n    // handle the args here  \n    }  \n  \nThis makes a lot of sense: most OSs pass arguments to the program this way.\nYour programming language only inserts a thin wrapper around the OS entry\npoint and passes the OS-provided arguments to your app. Parsing command line\narguments is a bit different in Rust:\n\n    \n    \n    fn main(){  \n    ---  \n    let args = std::env::args();  \n    }  \n  \nThe arguments are not directly passed to the main function, and you retrieve\nthem by calling std::env::args. You may assume this is implemented roughly\nlike this:\n\n    \n    \n    // OS-args are stored here.  \n    ---  \n    static mut ARGS:Option<Vec<String>> = None;  \n    unsafe fn _start(argc:c_int,argv:*const *const c_char){  \n    // Set the args  \n    ARGS = Some(convert_args(argc,argv));  \n    // call main  \n    main();  \n    // tell the OS that this program has finished.  \n    exit(0);  \n    }  \n    fn main(){  \n    // Just gets the value of `ARGS`.  \n    let args = std::env::args();  \n    }  \n  \nAnd you would be partially correct: the command line arguments are indeed\nstored in a static variable. But they are retrieved from the OS before your\nprogram even fully loads.\n\n## Dynamic linkers and init_array\n\nFor most OSs, the Rust standard library uses a function named really_init to\ninitialize the static variables containing command-line arguments.\n\n    \n    \n    static ARGC: AtomicIsize = AtomicIsize::new(0);  \n    ---  \n    static ARGV: AtomicPtr<*const u8> = AtomicPtr::new(ptr::null_mut());  \n    unsafe fn really_init(argc: isize, argv: *const *const u8) {  \n    // These don't need to be ordered with each other or other stores,  \n    // because they only hold the unmodified system-provide argv/argc.  \n    ARGC.store(argc, Ordering::Relaxed);  \n    ARGV.store(argv as *mut _, Ordering::Relaxed);  \n    }  \n  \nOk, that makes sense. But what calls really_init? really_init is called by a\n\"static initialzier\" - on GNU Linux, it uses '.init_array'.\n\n    \n    \n    #[used]  \n    ---  \n    #[link_section = \".init_array.00099\"]  \n    static ARGV_INIT_ARRAY: extern \"C\" fn(  \n    crate::os::raw::c_int,  \n    *const *const u8,  \n    *const *const u8,  \n    ) = {  \n    extern \"C\" fn init_wrapper(  \n    argc: crate::os::raw::c_int,  \n    argv: *const *const u8,  \n    _envp: *const *const u8,  \n    ) {  \n    unsafe {  \n    really_init(argc as isize, argv);  \n    }  \n    }  \n    init_wrapper  \n    };  \n  \nThe purpose of a static initializer is pretty self-explanatory: it is supposed\nto initialize static variables. The really interesting thing about static\ninitializers is that they run before your program even starts.\n\nA static initializer is called by a \"dynamic linker\" - the part of your OS\nresponsible for loading executables. This has a really interesting\nconsequence: a static initializer will also run when you load a library. This\nmeans that you can write something like this:\n\n    \n    \n    extern \"C\" fn can_be_called_by_other_langs(){  \n    ---  \n    // Can get OS args, even in a shared library  \n    let args = std::env::args();  \n    }  \n  \nin a shared library(a.k .a. dynamic library), and it will still work just\nfine.\n\nOk, all of that is pretty nice, but how can something like this be implemented\nin .NET?\n\n## Implementing GNU-style static initializers in .NET\n\nImplementing static initializers may seem like quite the task at first glance.\nI would have to handle the linker directives passed to me by the frontend, and\nthen call those static functions with proper arguments, and in the right\norder.\n\nThat would be complicated, but I have been able to take a very big shortcut.\nYou see, at least on GNU Linux, there is only 1 static initializer used in the\nwhole Rust standard library.\n\nThis makes my job a whole lot easier: I can \"just\" call really_init directly,\nand not worry about anything else.\n\n## .cctor\n\n.NET has a pretty nice feature, that allows me to easily emulate the behavior\nof .init_arrays: static constructors. They are pieces of code, which run while\na type is being initialized. I store my Rust code in a class called\nRustModule. It contains all the compiled functions, static allocations, and\nother stuff like that.\n\nSince a static constructor will run before the RustModule class is used, I can\nguarantee all static data is properly initialized.\n\nI can also use the static constructor to retrieve the command line arguments\nand call really_init directly. This is relatively easy since the static\nconstructor is just an ordinary static method, with a funny name(.cctor). So,\nI don't need all that much code to handle all of that properly.\n\nThe exact implementation is not as simple as this, but this should give you a\nrough idea about what is happening.\n\n# 100(+1) test cases\n\nSome time ago(4 months to be exact), I started using a slightly modified\nversion of a tool called rustlantis to fuzz test my compiler. Rustlantis is a\npretty amazing tool: it can automatically creates complex, but UB-free Rust\nprograms, extensively testing the Rust compiler. It is a really marvelous\nthing, and I can't stress enough how helpful it has been.\n\nWith my minor changes, I have been able to hook this amazing tool into my\ncompiler - and generate 101 failing test cases for me to fix.\n\nNo, this is not an elaborate reference to One Hundred and One Dalmatians - I\nam just stupid and made an off-by-one error.\n\nI saved failing test cases from 0 to 100, instead of from 1 to 100, and I just\ndecided to keep all of them, and live with my mistakes.\n\nAnyway, I have made some big progress fixing those issues - currently, only 3\nof them remain(cases 16, 47, and 58)!\n\nThis means I am 97.0297% done!\n\nYes, the percentage is all messed up - 101 is prime, so no nice percentages\nfor me :(.\n\nThe test cases are compiled with and without optimizations, and the behavior\nof the resulting program is compared between \"standard\" Rust and the .NET\nversion.\n\nWhile fixing those cases, I have discovered some interesting consequences of\ncertain... quirks of .NET.\n\n# .NETs selective sign dementia\n\nIf I asked you this simple question:\n\n> Does the .NET runtime have an unsigned integer type?\n\nYour answer would probably be:\n\n> Yes, of course! What a silly question!\n\nMy answer would be:\n\n> Yes, but no, but also yes.\n\nYou see, the .NET runtime obviously has support for unsigned integer types:\n\n    \n    \n    uint unsigned = 0;\n\n.NET clearly separates signed and unsigned integers almost everywhere, besides\nthe evaluation stack. As soon as an integer lands on the evaluation stack, the\nruntime gets a weird case of sign amnesia, and instantly forgets if it is\nsupposed to be signed.\n\nLet me show you an example. Look at this C# function:\n\n    \n    \n    public static int Add(int signed, uint unsigned){  \n    ---  \n    // Requires an explicit sign cast!  \n    return signed + (int)unsigned;  \n    }  \n  \nThis C# function then gets compiled into CIL - .NET's bytecode, which works by\npushing and popping values from the evaluation stack. You would expect the CIL\nthis function compiled into to look like this:\n\n    \n    \n    .method static  \n    ---  \n    int32 Add(  \n    int32 'signed',  \n    uint32 'unsigned'  \n    )  \n    {  \n    // Load argument 0(int signed)  \n    ldarg.0  \n    // Load argument 1(uint unsigned)  \n    ldarg.1  \n    // Convert uint to int  \n    conv.u4  \n    // Add them together  \n    add  \n    // Return their sum.  \n    ret  \n    }  \n  \nThe arguments get pushed onto the evaluation stack, the second one gets\nconverted from signed to unsigned, and then they get added together. Nope! The\nsign conversion is not needed.\n\n    \n    \n    .method static  \n    ---  \n    int32 Add(  \n    int32 'signed',  \n    uint32 'unsigned'  \n    )  \n    {  \n    // Load argument 0(int signed)  \n    ldarg.0  \n    // Load argument 1(uint unsigned)  \n    ldarg.1  \n    // Add them together(even though they have different signs)  \n    add  \n    // Return their sum.  \n    ret  \n    }  \n  \nOk, so what is the problem here?\n\nOh no, I don't have to use one more instruction to convert some integers, what\na terrible tragedy!\n\nWell, while it may not seem that bad, this makes some things... less than\nintuitive.\n\nI will now ask you a seemingly trivial question. If you had to convert a\n32-bit unsigned value(uint) to a 64-bit signed type(long), which one of those\ninstructions would you use?\n\nconv.i8 - Convert to int64, pushing int64 on stack.\n\nconv.u8 - Convert to unsigned int64, pushing int64 on stack.\n\nAt first, your intuition would suggest using conv.i8 - it is supposed to\nconvert a value to signed int64(long). Your intuition would be, however,\nwrong.\n\nThis C# function:\n\n    \n    \n    static long UIntToLong(uint input){  \n    ---  \n    return (long)input;  \n    }  \n  \nCompiles into the following CIL:\n\n    \n    \n    .method assembly hidebysig static  \n    ---  \n    int64 'UIntToLong' (  \n    uint32 input  \n    )  \n    {  \n    .maxstack 8  \n    ldarg.0  \n    conv.u8  \n    ret  \n    }  \n  \nLet me explain what is exactly happening, and why on earth is the instruction\nfor unsigned conversion used here. The real difference between conv.u8 and\nconv.i8 is the kind of conversion they use.\n\nconv.i8 uses sign extension - meaning it tries to preserve the sign bit of the\ninput value.\n\nSo, when its input is an unsigned integer, it treats its last bit as a sign,\neven when we don't want it to. conv.u8 uses zero extension - it does not try\nto preserve the sign, and simply fills all the \"new\" bits with 0s.\n\nYou can imagine this as conv.i8 assuming its input is signed, and conv.u8\nassuming its input is unsigned.\n\nThey are named in a pretty confusing way, but this is not a big issue, since\nit at least supports unsigned integers, unlike certain languages(I am looking\nat you, Java!).\n\nNow, this is not a problem in all the languages using .NET. You don't have to\nthink about, or even know this stuff. The smart people developing your\ncompiler have you covered!\n\n(Un) fortunately, I am the (allegedly smart person writing the Rust to .NET\ncompiler. So, this, and other \"small\" details and edge cases are sadly my\nproblem.\n\nSeeing as I can't count 100 test cases without messing up, I don't have big\nhopes ;).\n\n# .NETs magic 3rd variable-sized binary floating-point format\n\nDid you know that .NET has a 3rd binary floating-point type(and no, I am not\ntalking about decimal)? In CIL, you have direct equivalents to float and\ndouble - float32 and float64, but there is also a 3rd type.\n\nWell, what is it?\n\nThe confusingly named F type is supposed to be an internal implementation\ndetail. The spec says:\n\n> The internal representation shall have precision and range greater than or\n> equal to the nominal type. Conversions to and from the internal\n> representation shall preserve value.\n\nSo, its size may vary across implementations. Ok, so what? Why does this\ninternal type even matter? Well, it turns out that it (sometimes) matters\nquite a lot.\n\nFirst of all, all floating-point instructions operate on this \"F\" type - when\nyou load a float or a double onto the evaluation stack, it gets converted to\nthe F type.\n\nStill, most of the time, you can just pretend it does not exist - since its\nsize depends on the context. In practice, it is 32-bit when you operate on\nfloats, and 64-bit when you operate on doubles.\n\nYou can imagine you are directly operating on float32 and float64, and the \"F\"\ntype never bothers you.\n\nThe \"F\" type always has just the right size for your operation: never too\nsmall, never too big. So, it should not be noticeable.\n\nAll right, it is a weird type whose size depends on the context, but none is\nperfect. Of course, it may look odd, but it is just an implementation detail.\nSurely, it won't suddenly rear its ugly head and cause weird precision issues\nin one, very specific case?\n\n## Meet conv.r.un\n\nThere are 3 .NET instructions used for converting values to floating-point\ntypes: conv.r4 - Convert to float32, pushing F on stack. conv.r8- Convert to\nfloat64, pushing F on stack. conv.r.un - Convert unsigned integer to floating-\npoint, pushing F on stack\n\nCan you spot the odd one out?\n\nconv.r.un does not specify the size of its result. So, what is the size of the\ntype it pushes onto the stack? The answer is... it depends. Could you spot the\nissue with this snippet of code:\n\n    \n    \n    .method static float64 ULongToDouble(uint64 'ulong'){  \n    ---  \n    ldarg.0  \n    conv.r.un  \n    ret  \n    }  \n  \nThis code will convert the uint64 to a 32bit float type and then it will\nconvert that float into a double(float64). This will result in a loss of\nprecision. What is even worse is that this behavior is not very consistent:\nsometimes I can reproduce it, sometimes I can't.\n\nWell, there is one instruction missing: conv.r.un should be followed by\nconv.r8. Even though it seems like it is unnecessary, it is actually crucial\nthis instruction is there.\n\nThis looks weird, but this is what the C# compiler would do. So, I just have\nto stick a conv.r8 there, and everything is fine again.\n\n    \n    \n    .method static float64 ULongToDouble(uint64 'ulong'){  \n    ---  \n    ldarg.0  \n    conv.r.un  \n    conv.r8  \n    ret  \n    }  \n  \nOnce again, this is something that you are extremely unlikely to ever\nencounter. This is just an \"invisible\" implementation detail - but it is still\ninteresting to see it pop up.\n\nOne of my favorite things about this project is just learning about the inner\nworkings of Rust and .NET. As another example: did you know there is a cap on\nthe total length of the strings in a .NET assembly?\n\n# Strings, strings, more strings\n\nYou can\u2019t store more than 4GBs worth of strings in a .NET assembly. You may\nwonder: how on earth would you encounter that?\n\nThe answer is quite simple: a dumb approach to debugging.\n\nYou see, there are some things that make the runtime just... crash. No\nexception, no message, nothing. It just kind of... dies.\n\nAs an example, calling a null pointer using calli will just crash the runtime.\n\n    \n    \n    ldnull  \n    ---  \n    conv.i  \n    calli void ()  \n  \nSo, we can't get a backtrace and check what caused the problem.\n\nHow do we solve that?\n\nWell, we can \"simply\" log to the console the name of every single function we\ncall: this way, we can at least know where we crashed. We can also log\nmessages on who called the function, and provide yet entry and exit,\n\nOriginally, I did something dumb: I stored the whole message for each function\ncall. So, the total string length was:\n\nThe number of function calls \u00d7 2 \u00d7 40+ bytes per message.\n\nYou can see how quickly things will start to add up.\n\nThe solution turned out to be quite simple: split the stored strings, and\nreassemble them at runtime. We can change this message:\n\n> Calling FN1 from FN2\n\ninto 4 strings: \"Calling \", FN1, \" from \" and FN2.\n\nSo, now our total string length will just be:\n\nNumber of functions \u00d7 function name length + \"Calling \" and \" from \"\n\nMuch better.\n\nThis incredibly \"advanced\" debugging solution is, of course, disabled by\ndefault and only meant for diagnosing very weird edge cases, such as the\nruntime crashing without any messages.\n\nHowever stupid it may be, it works.\n\n# Suprise for the end\n\nOh, did I forget to mention that rustc_codegen_clr can also compiler Rust to\nC?\n\nI don't know how to integrate that nicely into the article, but the project\ncan also serve as a Rust to C compiler when you set the C_MODE config flag.\n\nWhy???\n\nWell, it all circles back to GSoC. I was not sure if my main proposal would be\naccepted, so I thought about submitting another, \"safer\" one.\n\nAfter a particularly bad migraine, I realized my internal IR(CIL trees) is\nbasically just an AST. And I can convert it to C without major issues.\n\nSo, I kind of.. did that? I wrote around 1K loc, and my Rust to .NET compiler\nnow outputs C for some reason. Cool.\n\nA lot of my tests already pass for the \"C_MODE\", and it can compile & run a\nvery broken version of the Rust standard library.\n\nThe whole thing works by just pretending the C language is a very weird .NET\nruntime. I know this sounds very funny - but hey, this was just a weird side\nproject.\n\nI will probably write a bit more about it in the future, but this article is\nalready a bit too long for my taste.\n\nIt was a nice experiment, is relatively easy to maintain, and it helped a lot\nwith debugging - so it will probably stay for now.\n\n# Mixed-mode assemblies, NATIVE_PASSTROUGH, and my linker\n\nSome people have asked me about mixed-mode assemblies: assemblies containing\nboth native code and .NET CIL.\n\nI have made some progress toward that too. First of all, my linker can now\nlink assemblies with shared libraries: it will emit all the info the .NET\nruntime needs to load the functions from such a library. It can also link\nstatic native libraries. They will come bundled with the final executable, and\nwill too be loaded by the .NET runtime. So, my linker, cleverly named\n\"linker\", will now enable you to bundle native code with your Rust compiled\nfor .NET.\n\nI call this(experimental) feature NATIVE_PASSTROUGH.\n\nNow, this feature is not perfect by any means(it crashes when you try to use\ncalling conventions other than \"C\"), but this is a significant step towards\nfuture Mixed-mode assemblies.\n\n# Wrapping stuff up\n\nOriginally, I had more stuff to talk about, but I didn't want this article to\nbecome an unreadable wall of text.\n\nOnce again, if you have any questions, feel free to ask. You can use the Rust\nZulip, open a discussion on the project GitHub, or just ask in the Reddit\ncomments. I will try to respond to all the feedback I recive.\n\nSo, goodbye, and see you next time!\n\n###### You can also sposor me on GitHub, if you want to.\n\n", "frontpage": true}
