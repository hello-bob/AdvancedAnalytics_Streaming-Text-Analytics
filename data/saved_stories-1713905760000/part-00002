{"aid": "40132667", "title": "Abstraction Engineering at Ramp", "url": "https://engineering.ramp.com/workflows", "domain": "ramp.com", "votes": 1, "user": "codeAligned", "posted_at": "2024-04-23 14:53:22", "comments": 0, "source_title": "Abstraction Engineering", "source_text": "Abstraction Engineering \u2014 Ramp Engineering\n\nEngineering\n\nHome\n\nWe're hiring!\n\n## Abstraction Engineering\n\nRodda John and Jared Wasserman\n\n\u2013\n\nOctober 31, 2023\n\nThe key to some of Ramp\u2019s early growth was our then opinionated product. The\nopinions represented both best practices for customers we were selling to, but\nalso tradeoffs that we had made early in the product\u2019s development. For\nexample, all approval policies were conditionally determined solely based on\namount. While it was possible to require one group of people for a request\nabove $100 and a different for a request below, it was impossible to alter\napprovers based on department, accounting field, subsidiary, or any other\nfield. This was a velocity tradeoff in the early days. However, in the fall of\n2022, customers onboarding onto Ramp were breaking the assumptions made across\nthe product early on and requesting significantly more configuration.\n\nWe solved this problem as most organizations would, by spinning up feature\nworkstreams dedicated to solving specific versions of this problem: approvals,\naccounting field visibility, submission policies, custom expense\nnotifications, and more. For certain, often larger customers, we went so far\nas to conditionalize logic based on the customer (or group of customers) in\nthe codebase itself. Pavel Asparohouv (see his article on scaling bill pay)\nand I were tasked with improving approvals functionality for our nascent\nprocurement product before we quickly realized that we were examining a\nspecific case of an underlying problem. Continued iterative solutions would\nhave led to increasing state complexity, operational difficulty, and features\nbuilt on incorrect and imprecise abstractions.\n\nIn the approvals case, feature requests were diverse: some customers wanted to\nroute approvals based on budget, others on department, and some on HRIS\nfields. We could have embarked on each build individually, or, we could have\nsolved the underlying problem and built a more powerful generic solution. We\ndecided to slow down, in order to go fast.\n\nThe approvals case was not unique. We asked others about instances where the\nbusiness logic customization Ramp offered was limited and causing pain. From\nthis, we accumulated a lengthy document of related instances.\n\nThe process of building a generic workflows platform resulted in code now used\nacross the product enabling everything from low level transactional\nasynchronous task management up to complex workflow builder UI. Most\nimportantly, though, it solidified Ramp\u2019s transition from a collection of\nexcellent point-solutions to a unified platform where a customer codifies\ntheir expense policy, and Ramp does the rest.\n\n#### Workflows Core\n\nUnlike most features, where most of the underlying implementation decisions\nare clear (e.g. a new set of CRUD endpoints), we did not know where to begin.\nWe worked to understand versions of the same problem, partial solutions\npresent in the codebase already, and define requirements.\n\nWe viewed this as an orchestration problem: snippets of code (what we later\ntermed \u201cactions\u201d) were dependent on boolean expressions (\u201cconditions\u201d). Sets\nof these dependencies could be assembled to create chunks of logic\n(\u201cworkflows\u201d). We also knew that what we were developing would be a platform\nfor significant future development. Thus, ease of development on the platform\nwas of significant importance.\n\nWhen validating the above architecture, we discovered a few vectors of\ncomplexity: actions could be synchronous or asynchronous (and our existing\ntask framework, celery, was unreliable about at a rate of about 7 tasks per\n10,000), actions could be in parallel or in a series, and the return value\nfrom actions needed to be available for use in subsequent actions.\n\n##### First Solution\n\nOur first attempt at system design was to have actions (with a synchronous\nflag), conditions (that persisted a recursive boolean expression), and\ndependencies (requiring a condition to be true for the action to be run). The\n\u2018state\u2019 of a workflow was a dictionary of key value pairs and could be updated\nwhile running a workflow. A return value could then be entered into state and\nupdated when the specific function is run.\n\nTo illustrate:\n\n    \n    \n    if A: B if C: D\n\nThis would generate A and C as conditions, B and D as actions, and establish\nthe following dependencies (D => C, D => A, B => A).\n\nWe then took this proposed solution and validated it with all known\napplications of the platform and sketched outlines of code. We discarded this\napproach for two reasons. First, we would have had to write translation code\nto go from a linear representation of logic (how the examples are rendered) to\na rule representation of logic; a theoretically possible, but unnecessary\nprocess. Second, action-action dependencies were exceedingly difficult to\nrepresent; they would have either required new edges (making the translation\nstep even more complex), or adding \u201caction-has-run\u201d conditions to the\ndependency tree. This solution was no longer elegant.\n\n##### Second Solution\n\nWe returned to the drawing board. The abstractions we had chosen were too\nspecific. We re-envisioned the project as a graph. The building blocks then\nbecame vertices and edges, a vertex being either an action or a condition.\n\u201cExecuting\u201d the workflow became traversing the graph, performing (or\nenqueuing) any action found, and waiting conditions to be true. A workflow\nonly needed to be \u201crun\u201d on initiation and whenever state was updated.\n\nThis solution was significantly simpler than the first, but more difficult to\nenvision because it is significantly more abstract. Persisting a workflow as a\ntree in this way can be viewed as persisting a (simplified) abstract syntax\ntree into Postgres.\n\nThis solution worked on all use cases we had examined, so we began to build.\nBuilding before validating all solutions would have been a mistake, and led to\na number of smaller tweaks to the design. The engine\u2019s logic was trivially\neasy (load the graph, topologically sort it, execute each node on the\nfrontier, if a node is an action, mark it as visited, and if a condition, mark\nas visited only if the condition is true). This logical simplicity gave us\nfaith that our selected abstractions were proper.\n\nAs mentioned prior, our asynchronous task framework was brittle and failed at\na small but significant rate (7 tasks / 10,000). For workflows, we did not\nwant consumers of the platform to be concerned with retries or dropped tasks.\nTo solve this, we built a Postgres backed queue (to replace Redis or RabbitMQ)\ncompatible with our celery deployment that would retry tasks appropriately\nuntil success was reported. Because workflows operated at such a high layer of\nabstraction (an \u201caction\u201d was a Python function), we were able to build a\nsolution that worked for workflows, but also solved the problem generally for\nRamp. In fact, many entirely internal use-cases are now using this workflows\ninfrastructure to link Postgres transactions to asynchronous task management.\nSidequests like these should be encouraged and pursued: they are difficult to\npredict but their upside is immense. Often, correct abstractions solve\nseemingly unrelated problems: previously difficult tasks become special cases\nof a more general solution.\n\n#### The Workflows SDK\n\nAfter writing the core engine, we attempted to implement features utilizing\nthe platform. We ran into a number of problems.\n\nLogic customers might define would not rely solely on if statements, but may\ninclude elif or else statements. This posed an interesting challenge: the\nlogic intrinsic to these operations was certainly supported by the core\nengine, but the ergonomics were poor. It is in theory possible to convert\nelifs to if statements, but doing so would be a ridiculous burden to place on\nconsumers.\n\nTo solve this and similar problems, we wrote an SDK. The SDK served as a set\nof transformations from easier to use dataclasses into core workflows.\n\nE.g.\n\n    \n    \n    if a elif b elif c else => if a if !a && b if !(a || b) && c if !(a || b || c)\n\nIf we could determine the general case for a transformation, the SDK could\nperform the substitution. This allowed us to expose functions, elifs, and more\ncomplex control structures to end consumers.\n\nWriting the SDK brought clarity to the project. A workflow as it exists in\nPostgres is akin to assembly: code that is easy to execute but difficult to\ncreate. A \u201ccore\u201d workflow is harder to execute but easier to create; an SDK\nworkflow is even harder to execute but easier to create, and so on. The\nprocess of taking a higher order workflow and converting it to Postgres we\ndescribed as \u201ccompilation\u201d, equating the process to that of code itself.\n\nThe first workflow was ridiculously slow, writing it to the database took over\ntwenty seconds. Writing a workflow involved issuing dozens of queries to about\nten database tables and incurred multiple N+1s. To solve this, Pavel rewrote\nthe logic to write a workflow from dozens of queries to a single massive query\n(complete with INSERT CTEs). Such an optimization would have been premature\nbefore testing it, and was prudent once the harm was measurable and optimize-\nable. Writing workflows now takes under 200ms.\n\nThe trade of write complexity for execution complexity meant that the most\nimportant logic was simple and performant. Regardless of whether a workflow\nrun is persisted or not, executing a workflow takes on average around 100ms.\n\nOnce we understood that what the SDK exposed was fully functional, we took to\nsketching workflows as a limited Python lexicon: supporting specific variable\ntypes and limited control structures \u2014 but equivalently powerful.\n\n##### Workflow Execution Visualization\n\nThis is a visualization of executing a workflow; red blocks are conditions and\norange blocks are actions. In this example, block 3 does not become true until\nthe penultimate workflow run.\n\n##### The Workflows API and UI\n\nAt this phase, we had built a workflows engine capable of persisting complex\nlogical constructions into Postgres and executing them performantly. We had\nnot built an interface that allowed customers to create these structures. To\ndo so, we partnered with Jared Wasserman (engineer) and Andy Lucas (designer).\n\nMuch of the design thinking that underpins the product deserving of immense\ncredit but out of scope for the article. The design principles most relevant\nwere a prioritization on legibility and constrained optionality. Many early\nideas were discarded when applied against this framework.\n\nBuilding the UI and its accompanying API was a new challenge: how do we take a\nworkflows compilation and execution engine, inject relevant business context,\nand expose an easy-to-use component for engineers across the company?\n\nInjecting business context into a workflow is non-trivial. Consider the\ncondition entity is Rodda\u2019s taco joint. Such a condition is common: objects in\nRamp\u2019s database are almost always more useful for customers than literals.\nSome literals (e.g. amount) are useful, but trivial to implement. Conditions\nthat contain \u201cobjects\u201d can easily be supported by the workflows engine through\nconverting it to entity_uuid HAS_INTERSECTION [\u201c<some_uuid>\u201d]. <some_uuid> is\nselected by the user in the UI, and the entity_uuid variable refers to a value\ntracked in state. To support this generically, we built a workflows\n\u201cconfiguration\u201d that allows engineers to define objects tracked in the UI, how\nthey are converted to workflows values, and what operators can be used on\nthem.\n\nSome changes we made while iterating on the UI with customers required\naltering core workflows constructions. Up to this point, all vertices were\nconstructed in a linear form, with vertices at the same level considered in\nparallel. This is not how users view workflows.\n\nConsider:\n\n    \n    \n    if A: B C\n\nIn this instance, if A and C are not in parallel. In fact, to convert this to\na graph, there is an implicit not A condition, resulting in:\n\nThese two if statements are now in parallel, and can be translated into the\ngraph form. In order to handle this case, we needed to change workflows core\nto allow for multiple edges to be constructed to a single vertex. This\nrepresented a (predicted but necessary) change to the internal API from a\nsimpler linear input structure to a more fully featured vertex-edge structure.\n\nAll of the constrained UI as it exists today is configured generically in\nworkflows. This contains much of the general case on how to convert between UI\nand customer concepts to workflows concepts. A central configuration allows\nalmost no changes to the code itself to support new use cases, only changes to\nthe config are required.\n\nWe launched workflows to a small number of customers initially and watched\nthem use the product intently. This process was crucial to arriving at a\npolished product. All product before a customer uses it is a guess, only once\na feature is released can you iterate. Optimizing for speed of iteration, and\nnot quality of guessing, is a crucial tradeoff.\n\n#### Current State\n\nToday, almost every surface of the product is run by workflows. Workflows\npowers who is required to approve card requests, reimbursements, bills,\ntransactions; whether receipts, memos, accounting fields are required on\ntransactions or reimbursements; whether given accounting options are visible\nto users or whether a transaction is flagged as being out of policy. Some of\nour most complex newer functionality like a conditional form builder are\npowered under the hood by the workflows engine. Even more is run internally on\nthe workflows celery infrastructure that is opaque externally.\n\nWe have yet to discover a use case that is not handled as originally\nenvisioned when we built the platform. Not only have the abstractions scaled\nto support use cases we had not predicted, the code has as well. Because of\nour reliance on the lowest level possible (Postgres) for much of our\ncomplexity, and the simplicity of the engine itself, over 45 million workflows\nhave been run with over a million a day, and the core engine has not been\nchanged since launch. Dozens of workflows are run on transaction swipe and\nreimbursement or bill submission. Every action or flow on the product runs a\nworkflow, and we\u2019re just getting started.\n\n##### Examples\n\nTo illustrate the diversity of usecases supported, below are four examples of\nwhere this platform is leveraged in the product today.\n\nThis workflow governs when receipts, memos, and accounting fields are required\nfor transactions and reimbursements.\n\nThis example governs which users (or user groups) must approve a bill before\nit is paid.\n\nThis is a constrained usage of workflows to allow for the configuration of\nadvanced alerts and flags on transactions.\n\nThis workflow controls which accounting fields are visible based on user and\nother accounting attributes.\n\n#### Conclusions\n\nThe workflows project represents the most extreme application of the\nphilosophy Shreyan describes yet applied at Ramp. The targeted abstraction is\nbroad: any customer-defined logic intended be handled by Ramp.\n\nWe got a lot wrong: we should have built using vertex-edge from the beginning\nand we could have predicted some issues that slowed us down while building the\nAPI earlier.\n\nThe up front investment was weeks of effort. Any individual application of\nworkflows could have been built in some fraction of that time. However, when\nmeasured in the medium term, workflows has saved the engineering organization\ncollectively months of effort. Incredibly complex and requested features are\nnow able to ship significantly faster by leveraging workflows.\n\nIn building workflows, we measured twice and cut once. Our first attempt at\nabstractions was wrong. We discovered this before writing a line of code,\nsimply by imagining what an implementation would resemble. Once the\nabstractions were written, nothing has proved them incomplete. The most\nconsequential changes were to internal API interfaces (from a linear to a\nvertex-edge data structure), and were envisioned before code was written. This\nwas accomplished through constant re-evaluation of assumptions, and validation\nof abstractions against real-world examples.\n\nSome of workflows remains to be built. The original specification Pavel and I\nwrote included concepts that support looping and generic triggers (a pub/sub\nmodel across the entire application). Deprioritized due to lack of demand, the\nplatform will easily support such functionality when its needed. See the end\nvision and work towards it, even if it will not be completed immediately.\n\nAt Ramp, we view engineering not as the writing of code to accomplish some\ntask, though that is one tool we leverage. We view engineering as the creation\nand implementation of technical abstractions intended to solve customer pain.\nThese abstractions are always lossy: the real world has almost infinite\ncomplexity. And like philosophy, the creation of such abstractions is as\nimprecise as art, reliant on our ability to ingest as much context as possible\nand make asymmetric trade offs where necessary. When executed well,\nabstractions are a velocity accelerator and allow a complex product to be\nsimple for users.\n\nIf any of this interests you, we\u2019d love to have you join us.\n\nRodda John Jared Wasserman\n\n##### Like what you see? Join us \u2192\n\nCome build the future of finance automation that increases the lifespan of\nbusinesses.\n\n\u00a9 2024 Ramp Business Corporation. \u201cRamp,\u201d \"Ramp Financial\" and the Ramp logo\nare trademarks of the company.\n\nThe Ramp Visa Commercial Card and the Ramp Visa Corporate Card are issued by\nSutton Bank and Celtic Bank (Members FDIC), respectively. Please visit our\nTerms of Service for more details.\n\n", "frontpage": false}
