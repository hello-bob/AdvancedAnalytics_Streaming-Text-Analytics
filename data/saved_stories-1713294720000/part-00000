{"aid": "40051436", "title": "Does x86 Need to Die?", "url": "https://www.computerenhance.com/p/does-x86-need-to-die", "domain": "computerenhance.com", "votes": 3, "user": "ibobev", "posted_at": "2024-04-16 13:10:39", "comments": 0, "source_title": "Does x86 Need to Die?", "source_text": "Does x86 Need to Die? - by Casey Muratori\n\n# Computer, Enhance!\n\nShare this post\n\n#### Does x86 Need to Die?\n\nwww.computerenhance.com\n\n#### Discover more from Computer, Enhance!\n\nProgramming courses, interviews, commentary.\n\nOver 24,000 subscribers\n\nContinue reading\n\nSign in\n\n# Does x86 Need to Die?\n\n### A recent article claimed that \"x86 needs to die\". Does it? I was on\nThePrimeagen's live stream last week to talk about it.\n\nCasey Muratori\n\nApr 15, 2024\n\n44\n\nShare this post\n\n#### Does x86 Need to Die?\n\nwww.computerenhance.com\n\n7\n\nShare\n\nAs many of you already know, I am a big fan of ThePrimeagen\u2019s Twitch channel.\nI\u2019ve been on it a few times now, and at least from my point of view as a\nguest, it consistently has the best energy of any show I\u2019ve done.\n\nLast week, I joined Prime to discuss a recent article called, \u201cWhy x86 Needs\nto Die\u201d. You can watch a (very lightly) edited VOD of the complete stream\nhere:\n\nPrime\u2019s show is intended for a general programming audience, and as such, we\ndidn\u2019t go into too much detail. But I feel like we did a good job covering the\nbasics, and explaining why the article was \u2014 at best \u2014 misleading.\n\nAs I say at the end of the stream, I do think there are things about x641 that\ncan be improved. But the article seems to be suggesting that the bad parts of\nx64 are caused by things that have little or nothing to do with the actual\nproblems facing today\u2019s x64 chip architects as I understand them.\n\nAlong those lines, folks who subscribe to my performance-aware programming\ncourse know a lot about microarchitecture analysis already, and may want to go\na bit deeper on this topic. For those interested, I\u2019ve written up some\nadditional context below.\n\n###\n\nMemory Addressing\n\nAt the beginning of the stream, I object to the suggestion that the CPU\u2019s\nability to \u201caddress memory directly\u201d (the author\u2019s words, not mine) in Real\nMode is somehow creating a lot of legacy maintenance for modern x64.\nImmediately after, I make an off-hand comment that if you were going to\ncomplain about maintaining something from the x86 memory model, you\u2019d complain\nabout segmenting (or something to that effect).\n\nIf you\u2019re wondering what I was talking about, the main 8086 Real Mode\n\u201cbackwards compatibility\u201d things that create potential problems for x64 have\nlittle to do with direct memory access. To the extent they involve memory\naccess at all, it\u2019s because the memory address calculation model was\ndifferent, and involved more, 16-bit segment registers (with 16-bit wrapping).\nRemoving the requirement to maintain and correctly compute addresses with\nthese registers is a potential simplification, and that\u2019s what I was referring\nto.\n\nBut you don\u2019t have to take my word for it. Intel has already told us what it\nwould like to simplify in x64 by removing 16- and 32-bit compatibility. We\ndon\u2019t have to guess!\n\nIf you read Envisioning A Simplified Intel Architecture, and the companion\narchitecture proposal, you can see precisely what Intel thinks they would\nbenefit from removing. The older style of segmented addressing is one of the\nthings they listed. Others are things like unused privilege ring levels and so\non. From the summary:\n\nSo that\u2019s what I was talking about. And of course, to my knowledge, removing\nthe ability to \u201caddress memory directly\u201d appears nowhere in the document.\n\nIf you read this Intel proposal (which I did, back around when it was\noriginally posted), hopefully you can see why the \u201cWhy x86 Needs to Die\u201d\ndiscussion of Real Mode sounds fishy. Not only has Intel already proposed a\nrelatively straightforward path to removing it, but it\u2019s not really a big\npriority for anyone with respect to CPU performance. Removing some microcode,\nsimplifying the init sequence, etc., are all things that probably should be\ndone, but nobody expects this to make x64 CPUs perform significantly faster\nthan they already do on most workloads2.\n\nAnd more importantly, as I just linked to, there is already a proposal to\ncleanly remove them from x64 \u2014 without x86 \u201cdying\u201d and being replaced by ARM\nand RISC-V as the article suggests.\n\n###\n\nShifts Affecting Flags\n\nAt another point in the video, I talk about how there are issues with x64\ninstruction encoding that make it less efficient to decode large numbers of\ninstructions at the same time. I talk about this being the main thing that you\nwould want to fix about x64: rearranging some of the bit patterns to make it\nsimpler to decode a large number of sequential instructions in parallel.\n\nBut when I say that, I also say there are a handful of other things you might\nfix, like \u201cshifts affecting flags\u201d. All I meant to do here was suggest an\nexample of a simplification you could do to x64 that would remove some\nunnecessary complexity on the hardware (and software) side.\n\nTo be specific, as many of my viewers already know from Part 1 of the course,\nconditional instructions are often based on a \u201cflags\u201d model. Instructions set\nflags indicating the results of their operations, like ZF (the result was\nzero) or CF (the result overflowed). Later instructions can take action based\non these flags, like conditionally jumping to another part of the code.\n\nThis design creates a lot of \u201cunnecessary dependencies\u201d, in that many\ninstructions you might do (such as shifting a value) are defined to modify the\nflags whether you intended to use the resulting flag value or not. So not only\ndoes the CPU have to track the changes to the flags across operations even\nthough you may not have cared about those changes, you (or more likely, the\ncompiler) also have to be careful not to use an instruction that overwrites\nthe flags in between a flag change you did care about and the subsequent\nconditional instruction that depends on it.\n\nSo, one potential modification to the x64 architecture that would eliminate\nthis unnecessary complexity is to provide instructions for things like shifts\nthat don\u2019t affect the flags. That way, when a programmer doesn\u2019t intend to\nmodify the flags, they use the variant of shift that leaves the flags alone.\n\nOnce again, though, you don\u2019t have to take my word for this! As before, Intel\nalready proposed an instruction set extension which fixes this, among other\nthings. These changes to x64 are called the Advanced Performance Extensions,\nand they already have a complete architecture specification. It includes the\nability to suppress flag writes for many common instructions, as well as a\nhost of other performance-targeted features, many of which have far more\npotential to improve performance than flag suppression.\n\n###\n\nSo, Does x86 Need to Die?\n\nFor the most part, I don\u2019t really care about the answer to this question. I\nwanted to join Prime in \u201creacting\u201d to the original article primarily because I\nthought it misrepresented a lot of aspects of modern CPU architecture, at\nleast insofar as we software developers understand them. I also wanted to push\nback on the suggestion that \u201cCISC vs. RISC\u201d was a useful analysis framework\n(it\u2019s not, as Chips and Cheese explained very well in their own response to\nthe original article).\n\nWhat I do care about is being clearer about how modern microarchitectures\nwork, and making sure people understand that although there are issues with\nx64 (as there are with any instruction set), they have surprisingly little to\ndo with a \u201cRISC good, CISC bad\u201d \u2014 or even a \u201clegacy vs. modern\u201d \u2014 dichotomy.\n\nThat said, on the measure, I would disagree that x86 \u201cneeds to die\u201d. The\nreason I say that is because x86 (now x64) has done a remarkable job\nstabilizing software development over the past forty years. Sure, you can call\nthat \u201clegacy\u201d or a \u201cmaintenance problem\u201d if you want to look at the downsides.\nBut you could also call it a remarkably flexible instruction set if you\u2019d like\nto look at the upsides.\n\nIf, for example, we were to turn the \u201ccrapping on someone else\u2019s ISA\u201d hose\naround, and point it at RISC-V, we certainly could. Even though it is\nessentially brand new, we can already see it failing to do something x86 has\ndone trivially many times.\n\nIn their recent RISC-V V extension \u2014 a crucial extension that finally adds\nvector support to the ISA so that it can try to be competitive in\ncomputationally intensive workloads \u2014 they already ended up with a fairly bad\ninstruction set in version 1. This was at least in part because they decided\nnot to use variable-length encodings for the instructions.\n\nAs a result, despite all modern SIMD/vector instruction sets (AVX-512, ARM\nSVE, your favorite GPU\u2019s custom ISA, etc.) having the ability to mask\ninstructions against your choice of mask register, RISC-V V only allows\nmasking to be toggled on or off. When on, the mask is always read from v0, and\nno other masks are available.\n\nWhy? Because they couldn\u2019t find enough bits in their 32-bit instruction\nencoding to reference any more than that! So instructions are either masked or\nnot, based on the single bit they had room to encode. By contrast, when\nAVX-512 introduced masking into the x64 instruction set, it supported\nselecting from 8 mask registers. As usual, x64 architects just ate the cost of\nhaving to support more elaborate instruction decoding.\n\nSo rather than thinking of it as \u201cfixed-size instructions good, variable-\nlength instructions bad\u201d, I would encourage people to think of this as what it\nis: a tradeoff. There is a cost to maintaining a compact, consistent\ninstruction encoding. It makes it significantly harder to respond to changes\nin the industry and the computing landscape. It makes it harder for IHVs to\nprovide their customers with timely new instructions that properly reflect the\nneeds of emerging high-performance software domains. Either you sacrifice\ninstruction quality (like RISC-V V did), or you go the same route as x86/x64\nand require more complex decoder logic.\n\nI strongly suspect an eventual RISC-V V revision will do precisely this, in\nfact! RISC-V does support variable-length encoding, and I wouldn\u2019t be\nsurprised if, once it\u2019s around for even a fraction of the lifespan of x86, it\nwill need to make heavier use of its variable-length encoding scheme if it\nwants to become performance-competitive.\n\nFor those who aren\u2019t familiar with RISC-V, although it does attempt to have\nmany instructions align to exactly 32-bits, it is technically a variable-\nlength instruction format as illustrated in the diagram above.\n\nAs I say in the video, none of this is to suggest that x64 is some kind of\noptimal instruction encoding. Far from it. Anything that has to evolve slowly\nover many years is destined to have concessions to that evolutionary process,\nand as the APX specification itself demonstrates, x64 architects themselves\nare well aware of that.\n\nBut I do think the original article was way off base. ARM and RISC-V aren\u2019t\nparticularly special. They\u2019re not dramatically better than x64, and in some\nways, you could argue that they are worse (especially RISC-V, despite it\nhaving the benefit of both x64 and ARM having already gone before it). There\nare plenty of things that could be improved in x64, but there are constantly\nextensions that do just that. Similarly, there are a lot of ways that new\ninstruction sets like RISC-V could lose their simplicity over time if they\nneed to make changes to become competitive in higher performance classes.\n\nFurthermore, if x86/64 does end up dying out, I don\u2019t think it will have much\nto do with its design. The much more likely reason that x64 processors could\nget phased out over the next few decades is much more about licensing than it\nis about anything else.\n\nARM can be licensed by anyone, and RISC-V is effectively free. Those are\ncompelling business reasons to choose either over x64, and have already lead\nto many more IHVs providing ARM and RISC-V processors than currently provide\nx64 processors.\n\nSo do I think x64 \u201cneeds to die\u201d? Definitely not. But more importantly, if it\ndoes, I don\u2019t think it will be because the ISA couldn\u2019t evolve. I strongly\nsuspect x64\u2019s eventual demise will be for business reasons, not technical\nones.\n\nIf you like the sort of architectural explanations I provided on the stream\nwith Prime, that\u2019s precisely the sort of thing I do here every week! You can\nsubscribe to the free version of this site, and also see paid subscription\noptions, using the email box below:\n\n1\n\nConfusingly, the original article says \u201cWhy x86 Needs to Die\u201d, but is\nspecifically about why x64 needs to die and be replaced by ARM and RISC-V.\nThis makes it a little hard to refer to the article and also be precise about\nwhat I\u2019m referring to in this article. To avoid confusion, I\u2019m going to use\nx64 everywhere, since that\u2019s generally what we\u2019re talking about, and also what\nthe original article was talking about even though they keep referring to\nmodern x64 as \u201cx86\u201d.\n\n2\n\nWithout getting too far into the weeds, the security concerns mentioned in the\noriginal article also seem pretty far off base. The author claims that things\nlike \u201cspeculative execution\u201d are a problem for x64, as if that has something\nto do with the legacy of the x86 instruction set. But all high-performance\nCPUs now use speculative execution, including the high-performance ARM core\nyou probably have in your mobile phone.\n\nRather, the kinds of security concerns that one could imagine alleviating\nwould be things like simplifying the APIC by removing legacy options. This\nmight decrease the likelihood of APIC-related security vulnerabilities (of\nwhich there have been several), since there\u2019d be less total surface area to\nthink about. Again, precisely such a simplification is already contemplated by\nthe \u201cEnvisioning a Simplified Intel Architecture\u201d proposal.\n\n### Subscribe to Computer, Enhance!\n\nBy Casey Muratori \u00b7 Thousands of paid subscribers\n\nProgramming courses, interviews, commentary.\n\n44 Likes\n\n\u00b7\n\n3 Restacks\n\n44\n\nShare this post\n\n#### Does x86 Need to Die?\n\nwww.computerenhance.com\n\n7\n\nShare\n\n7 Comments\n\nMartins16 hrs agoLiked by Casey MuratoriOriginal Spectre paper explicitly\nmentions ARM and RISC-V as ISA's that can be vulnerable to speculative\nattacks: https://spectreattack.com/spectre.pdfOf course actual hw\nimplementation matters, it is not a property of ISA.Expand full commentLike\n(6)ReplyShare  \n---  \n  \n1 reply by Casey Muratori\n\nrobert hickman2 hrs ago\u00b7edited 2 hrs agoI wish to state that the opening\nimplication that \"a website not providing video / audio of their content is\nlazy\", is dismissive of creators who for a range of reasons may be unable to\ndo so, including but not exclusively disibility, time and / or financial.I\ncreate written content relating to a different subject area, and creating\naudio or video versons of it is absolutely not possible for me because I am\nautistic and have disibilities related to speach and body language.My speach\nsounds come across as disjointed and many people misunderstand me. I also\nstruggle to form scentances in real time, generally speak very slowly, do not\nemote much in body language, and tend to 'stare'.The above points mean that if\nI make spoken or video content, people dismiss it without even considering the\npoints being rased, and I get bombarded with offensive comments or people\nasking if I'm drunk.This shift towards video / audio content on the web has\nleft me in a position where I am increasingly unable to function at all due to\nthings I have no control over.Expand full commentLikeReplyShare  \n---  \n  \n5 more comments...\n\nWelcome to the Performance-Aware Programming Series!\n\nA brief introduction explaining what \"performance-aware programming\" is, and\nwhat the course will be about.\n\nFeb 1, 2023 \u2022\n\nCasey Muratori\n\n22:05\n\n669\n\nShare this post\n\n#### Welcome to the Performance-Aware Programming Series!\n\nwww.computerenhance.com\n\n93\n\nWaste\n\nWatch now (33 min) | How many CPU instructions does Python take to do one CPU instruction?\n\nFeb 2, 2023 \u2022\n\nCasey Muratori\n\n32:56\n\n591\n\nShare this post\n\n#### Waste\n\nwww.computerenhance.com\n\n172\n\n\"Clean\" Code, Horrible Performance\n\nMany programming \"best practices\" taught today are performance disasters\nwaiting to happen.\n\nFeb 28, 2023 \u2022\n\nCasey Muratori\n\n463\n\nShare this post\n\n#### \"Clean\" Code, Horrible Performance\n\nwww.computerenhance.com\n\n129\n\nReady for more?\n\n\u00a9 2024 Casey Muratori\n\nPrivacy \u2219 Terms \u2219 Collection notice\n\nStart WritingGet the app\n\nSubstack is the home for great culture\n\nShare\n\n## Create your profile\n\n## Only paid subscribers can comment on this post\n\nAlready a paid subscriber? Sign in\n\n#### Check your email\n\nFor your security, we need to re-authenticate you.\n\nClick the link we sent to , or click here to sign in.\n\n", "frontpage": false}
