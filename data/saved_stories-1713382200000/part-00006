{"aid": "40063742", "title": "Express-zod-API \u2013 Zod based Node.js framework", "url": "https://github.com/RobinTail/express-zod-api", "domain": "github.com/robintail", "votes": 1, "user": "ianberdin", "posted_at": "2024-04-17 12:33:38", "comments": 0, "source_title": "GitHub - RobinTail/express-zod-api: A Typescript library to help you get an API server up and running with I/O schema validation and custom middlewares in minutes.", "source_text": "GitHub - RobinTail/express-zod-api: A Typescript library to help you get an\nAPI server up and running with I/O schema validation and custom middlewares in\nminutes.\n\nSkip to content\n\nSign in\n\n# Search code, repositories, users, issues, pull requests...\n\nSearch syntax tips\n\nSign in\n\nSign up\n\nYou signed in with another tab or window. Reload to refresh your session. You\nsigned out in another tab or window. Reload to refresh your session. You\nswitched accounts on another tab or window. Reload to refresh your session.\nDismiss alert\n\nRobinTail / express-zod-api Public\n\n  * Notifications\n  * Fork 26\n  * Star 542\n\nA Typescript library to help you get an API server up and running with I/O\nschema validation and custom middlewares in minutes.\n\nez.robintail.cz\n\n### License\n\nMIT license\n\n542 stars 26 forks Branches Tags Activity\n\nStar\n\nNotifications\n\n# RobinTail/express-zod-api\n\nThis commit does not belong to any branch on this repository, and may belong\nto a fork outside of the repository.\n\n49 Branches\n\n304 Tags\n\n## Folders and files\n\nName| Name| Last commit message| Last commit date  \n---|---|---|---  \n  \n## Latest commit\n\ndependabot[bot]Bump the typescript-eslint group with 2 updates (#1683)Apr 15,\n20241b14910 \u00b7 Apr 15, 2024Apr 15, 2024\n\n## History\n\n1,961 Commits  \n  \n### .github\n\n|\n\n### .github\n\n| CI: retry on timeout too (#1679)| Apr 10, 2024  \n  \n### .husky\n\n|\n\n### .husky\n\n| Bump husky from 8.0.3 to 9.0.5 (#1509)| Jan 25, 2024  \n  \n### example\n\n|\n\n### example\n\n| 17.7.0| Apr 9, 2024  \n  \n### src\n\n|\n\n### src\n\n| Integration: add missing z.tuple().rest() type (#1660)| Apr 1, 2024  \n  \n### tests\n\n|\n\n### tests\n\n| Integration: add missing z.tuple().rest() type (#1660)| Apr 1, 2024  \n  \n### tools\n\n|\n\n### tools\n\n| Fix logo for terminals that support only 256 colors. (#1582)| Feb 23, 2024  \n  \n### .eslintrc.json\n\n|\n\n### .eslintrc.json\n\n| Feat: beforeRouting option (#1549)| Feb 6, 2024  \n  \n### .gitignore\n\n|\n\n### .gitignore\n\n| Ref: dedicated environment for issue #952 test (#1356)| Dec 5, 2023  \n  \n### .prettierignore\n\n|\n\n### .prettierignore\n\n| Ref: dedicated environment for issue #952 test (#1356)| Dec 5, 2023  \n  \n### CHANGELOG.md\n\n|\n\n### CHANGELOG.md\n\n| Feat: provenance (#1676)| Apr 9, 2024  \n  \n### CODE_OF_CONDUCT.md\n\n|\n\n### CODE_OF_CONDUCT.md\n\n| Update CODE_OF_CONDUCT.md| Dec 19, 2023  \n  \n### CONTRIBUTING.md\n\n|\n\n### CONTRIBUTING.md\n\n| Introducing contribution guidelines (#1395)| Dec 19, 2023  \n  \n### LICENSE\n\n|\n\n### LICENSE\n\n| Bump license year.| Jan 1, 2024  \n  \n### LICENSE-3RD-PARTY.md\n\n|\n\n### LICENSE-3RD-PARTY.md\n\n| Third party licenses files (#1420)| Dec 25, 2023  \n  \n### README.md\n\n|\n\n### README.md\n\n| Readme: shortening.| Mar 17, 2024  \n  \n### SECURITY.md\n\n|\n\n### SECURITY.md\n\n| Security: fix duplicated row| Feb 23, 2024  \n  \n### coverage.svg\n\n|\n\n### coverage.svg\n\n| Coverage! (#134)| Sep 19, 2021  \n  \n### dataflow.svg\n\n|\n\n### dataflow.svg\n\n| Rev: options flow origin (for clarity)| Mar 16, 2024  \n  \n### logo.svg\n\n|\n\n### logo.svg\n\n| Logo and sketchy diagram (#11)| May 9, 2021  \n  \n### package.json\n\n|\n\n### package.json\n\n| Bump vitest and @vitest/coverage-istanbul (#1682)| Apr 12, 2024  \n  \n### tsconfig.base.json\n\n|\n\n### tsconfig.base.json\n\n| Moving resolveJsonModule into the package tsconfig solely (#1413)| Dec 23,\n2023  \n  \n### tsconfig.json\n\n|\n\n### tsconfig.json\n\n| Dev: Benchmarking (#1499)| Jan 24, 2024  \n  \n### tsup.config.ts\n\n|\n\n### tsup.config.ts\n\n| Debug line with build id running (#1380)| Dec 13, 2023  \n  \n### vitest.config.ts\n\n|\n\n### vitest.config.ts\n\n| Expanding the CLI coverage report width.| Jan 12, 2024  \n  \n### yarn.lock\n\n|\n\n### yarn.lock\n\n| Bump the typescript-eslint group with 2 updates (#1683)| Apr 15, 2024  \n  \n## Repository files navigation\n\n# Express Zod API\n\nStart your API server with I/O schema validation and custom middlewares in\nminutes.\n\n  1. Why and what is it for\n  2. How it works\n\n    1. Technologies\n    2. Concept\n  3. Quick start \u2014 Fast Track\n\n    1. Installation\n    2. Set up config\n    3. Create an endpoints factory\n    4. Create your first endpoint\n    5. Set up routing\n    6. Create your server\n    7. Try it\n  4. Basic features\n\n    1. Middlewares\n    2. Options\n    3. Using native express middlewares\n    4. Refinements\n    5. Transformations\n    6. Dealing with dates\n    7. Cross-Origin Resource Sharing (CORS)\n    8. Enabling HTTPS\n    9. Customizing logger\n    10. Child logger\n    11. Enabling compression\n  5. Advanced features\n\n    1. Customizing input sources\n    2. Route path params\n    3. Multiple schemas for one route\n    4. Response customization\n    5. Non-object response including file downloads\n    6. File uploads\n    7. Serving static files\n    8. Connect to your own express app\n  6. Special needs\n\n    1. Different responses for different status codes\n    2. Array response for migrating legacy APIs\n    3. Headers as input source\n    4. Accepting raw data\n    5. Resources cleanup\n  7. Integration and Documentation\n\n    1. Generating a Frontend Client\n    2. Creating a documentation\n    3. Tagging the endpoints\n    4. How to test endpoints\n  8. Caveats\n\n    1. Coercive schema of Zod\n    2. Excessive properties in endpoint output\n  9. Your input to my output\n\nYou can find the release notes and migration guides in Changelog.\n\n# Why and what is it for\n\nI made this library because of the often repetitive tasks of starting a web\nserver APIs with the need to validate input data. It integrates and provides\nthe capabilities of popular web server, logging, validation and documenting\nsolutions. Therefore, many basic tasks can be accomplished faster and easier,\nin particular:\n\n  * You can describe web server routes as a hierarchical object.\n  * You can keep the endpoint's input and output type declarations right next to its handler.\n  * All input and output data types are validated, so it ensures you won't have an empty string, null or undefined where you expect a number.\n  * Variables within an endpoint handler have types according to the declared schema, so your IDE and Typescript will provide you with necessary hints to focus on bringing your vision to life.\n  * All of your endpoints can respond in a consistent way.\n  * The expected endpoint input and response types can be exported to the frontend, so you don't get confused about the field names when you implement the client for your API.\n  * You can generate your API documentation in OpenAPI 3.1 and JSON Schema compatible format.\n\n# How it works\n\n## Technologies\n\n  * Typescript first.\n  * Web server \u2014 Express.js.\n  * Schema validation \u2014 Zod 3.x.\n  * Supports any logger having info(), debug(), error() and warn() methods;\n\n    * Winston is default.\n  * Generators:\n\n    * Documentation \u2014 OpenAPI 3.1 (former Swagger);\n    * Client side types \u2014 inspired by zod-to-ts.\n  * File uploads \u2014 Express-FileUpload (based on Busboy).\n  * Supports any testing framework having a function mocking method;\n\n    * Jest and Vitest are both supported automatically.\n\n## Concept\n\nThe API operates object schemas for input and output validation. The object\nbeing validated is the combination of certain request properties. It is\navailable to the endpoint handler as the input parameter. Middlewares have\naccess to all request properties, they can provide endpoints with options. The\nobject returned by the endpoint handler is called output. It goes to the\nResultHandler which is responsible for transmitting consistent responses\ncontaining the output or possible error. Much can be customized to fit your\nneeds.\n\n# Quick start\n\n## Installation\n\nRun one of the following commands to install the library, its peer\ndependencies and packages for types assistance.\n\n    \n    \n    yarn add express-zod-api express zod winston typescript http-errors yarn add --dev @types/express @types/node @types/http-errors\n\nor\n\n    \n    \n    npm install express-zod-api express zod winston typescript http-errors npm install -D @types/express @types/node @types/http-errors\n\nAdd the following option to your tsconfig.json file in order to make it work\nas expected:\n\n    \n    \n    { \"compilerOptions\": { \"strict\": true } }\n\n## Set up config\n\nCreate a minimal configuration. See all available options in sources.\n\n    \n    \n    import { createConfig } from \"express-zod-api\"; import type { Logger } from \"winston\"; const config = createConfig({ server: { listen: 8090, // port, UNIX socket or options }, cors: true, logger: { level: \"debug\", color: true }, }); // Setting the type of the logger used declare module \"express-zod-api\" { interface LoggerOverrides extends Logger {} }\n\n## Create an endpoints factory\n\nIn the basic case, you can just import and use the default factory. See also\nMiddlewares and Response customization.\n\n    \n    \n    import { defaultEndpointsFactory } from \"express-zod-api\";\n\n## Create your first endpoint\n\nThe endpoint responds with \"Hello, World\" or \"Hello, {name}\" if the name is\nsupplied within GET request payload.\n\n    \n    \n    import { z } from \"zod\"; const helloWorldEndpoint = defaultEndpointsFactory.build({ method: \"get\", // or methods: [\"get\", \"post\", ...] input: z.object({ // for empty input use z.object({}) name: z.string().optional(), }), output: z.object({ greetings: z.string(), }), handler: async ({ input: { name }, options, logger }) => { logger.debug(\"Options:\", options); // middlewares provide options return { greetings: `Hello, ${name || \"World\"}. Happy coding!` }; }, });\n\n## Set up routing\n\nConnect your endpoint to the /v1/hello route:\n\n    \n    \n    import { Routing } from \"express-zod-api\"; const routing: Routing = { v1: { hello: helloWorldEndpoint, }, };\n\n## Create your server\n\nSee the complete implementation example.\n\n    \n    \n    import { createServer } from \"express-zod-api\"; createServer(config, routing);\n\n## Try it\n\nStart your application and execute the following command:\n\n    \n    \n    curl -L -X GET 'localhost:8090/v1/hello?name=Rick'\n\nYou should receive the following response:\n\n    \n    \n    { \"status\": \"success\", \"data\": { \"greetings\": \"Hello, Rick. Happy coding!\" } }\n\n# Basic features\n\n## Middlewares\n\nMiddleware can authenticate using input or request headers, and can provide\nendpoint handlers with options. Inputs of middlewares are also available to\nendpoint handlers within input.\n\nHere is an example of the authentication middleware, that checks a key from\ninput and token from headers:\n\n    \n    \n    import { z } from \"zod\"; import createHttpError from \"http-errors\"; import { createMiddleware } from \"express-zod-api\"; const authMiddleware = createMiddleware({ security: { // this information is optional and used for generating documentation and: [ { type: \"input\", name: \"key\" }, { type: \"header\", name: \"token\" }, ], }, input: z.object({ key: z.string().min(1), }), middleware: async ({ input: { key }, request, logger }) => { logger.debug(\"Checking the key and token\"); const user = await db.Users.findOne({ key }); if (!user) { throw createHttpError(401, \"Invalid key\"); } if (request.headers.token !== user.token) { throw createHttpError(401, \"Invalid token\"); } return { user }; // provides endpoints with options.user }, });\n\nBy using .addMiddleware() method before .build() you can connect it to the\nendpoint:\n\n    \n    \n    const yourEndpoint = defaultEndpointsFactory .addMiddleware(authMiddleware) .build({ // ..., handler: async ({ options }) => { // options.user is the user returned by authMiddleware }, });\n\nYou can connect the middleware to endpoints factory right away, making it kind\nof global:\n\n    \n    \n    import { defaultEndpointsFactory } from \"express-zod-api\"; const endpointsFactory = defaultEndpointsFactory.addMiddleware(authMiddleware);\n\nYou can connect as many middlewares as you want, they will be executed in\norder.\n\n## Options\n\nIn case you'd like to provide your endpoints with options that do not depend\non Request, like database connection instance, consider shorthand method\naddOptions.\n\n    \n    \n    import { defaultEndpointsFactory } from \"express-zod-api\"; const endpointsFactory = defaultEndpointsFactory.addOptions({ db: mongoose.connect(\"mongodb://connection.string\"), privateKey: fs.readFileSync(\"private-key.pem\", \"utf-8\"), });\n\n## Using native express middlewares\n\nThere are two ways of connecting the native express middlewares depending on\ntheir nature and your objective.\n\nIn case it's a middleware establishing and serving its own routes, or somehow\nglobally modifying the behaviour, or being an additional request parser (like\ncookie-parser), use the beforeRouting option. However, it might be better to\navoid cors here \u2014 the library handles it on its own.\n\n    \n    \n    import { createConfig } from \"express-zod-api\"; import ui from \"swagger-ui-express\"; const config = createConfig({ server: { listen: 80, beforeRouting: ({ app, logger }) => { logger.info(\"Serving the API documentation at https://example.com/docs\"); app.use(\"/docs\", ui.serve, ui.setup(documentation)); }, }, });\n\nIn case you need a special processing of request, or to modify the response\nfor selected endpoints, use the method addExpressMiddleware() of\nEndpointsFactory (or its alias use()). The method has two optional features: a\nprovider of options and an error transformer for adjusting the response status\ncode.\n\n    \n    \n    import { defaultEndpointsFactory } from \"express-zod-api\"; import createHttpError from \"http-errors\"; import { auth } from \"express-oauth2-jwt-bearer\"; const factory = defaultEndpointsFactory.use(auth(), { provider: (req) => ({ auth: req.auth }), // optional, can be async transformer: (err) => createHttpError(401, err.message), // optional });\n\n## Refinements\n\nYou can implement additional validations within schemas using refinements.\nValidation errors are reported in a response with a status code 400.\n\n    \n    \n    import { z } from \"zod\"; import { createMiddleware } from \"express-zod-api\"; const nicknameConstraintMiddleware = createMiddleware({ input: z.object({ nickname: z .string() .min(1) .refine( (nick) => !/^\\d.*$/.test(nick), \"Nickname cannot start with a digit\", ), }), // ..., });\n\nBy the way, you can also refine the whole I/O object, for example in case you\nneed a complex validation of its props.\n\n    \n    \n    const endpoint = endpointsFactory.build({ input: z .object({ email: z.string().email().optional(), id: z.string().optional(), otherThing: z.string().optional(), }) .refine( (inputs) => Object.keys(inputs).length >= 1, \"Please provide at least one property\", ), // ..., });\n\n## Transformations\n\nSince parameters of GET requests come in the form of strings, there is often a\nneed to transform them into numbers or arrays of numbers.\n\n    \n    \n    import { z } from \"zod\"; const getUserEndpoint = endpointsFactory.build({ method: \"get\", input: z.object({ id: z.string().transform((id) => parseInt(id, 10)), ids: z .string() .transform((ids) => ids.split(\",\").map((id) => parseInt(id, 10))), }), output: z.object({ /* ... */ }), handler: async ({ input: { id, ids }, logger }) => { logger.debug(\"id\", id); // type: number logger.debug(\"ids\", ids); // type: number[] }, });\n\n## Dealing with dates\n\nDates in Javascript are one of the most troublesome entities. In addition,\nDate cannot be passed directly in JSON format. Therefore, attempting to return\nDate from the endpoint handler results in it being converted to an ISO string\nin actual response by calling toJSON(), which in turn calls toISOString(). It\nis also impossible to transmit the Date in its original form to your endpoints\nwithin JSON. Therefore, there is confusion with original method z.date() that\nshould not be used within IO schemas of your API.\n\nIn order to solve this problem, the library provides two custom methods for\ndealing with dates: ez.dateIn() and ez.dateOut() for using within input and\noutput schemas accordingly.\n\nez.dateIn() is a transforming schema that accepts an ISO string representation\nof a Date, validates it, and provides your endpoint handler or middleware with\na Date. It supports the following formats:\n\n    \n    \n    2021-12-31T23:59:59.000Z 2021-12-31T23:59:59Z 2021-12-31T23:59:59 2021-12-31\n\nez.dateOut(), on the contrary, accepts a Date and provides ResultHanlder with\na string representation in ISO format for the response transmission. Consider\nthe following simplified example for better understanding:\n\n    \n    \n    import { z } from \"zod\"; import { ez, defaultEndpointsFactory } from \"express-zod-api\"; const updateUserEndpoint = defaultEndpointsFactory.build({ method: \"post\", input: z.object({ userId: z.string(), birthday: ez.dateIn(), // string -> Date }), output: z.object({ createdAt: ez.dateOut(), // Date -> string }), handler: async ({ input }) => { // input.birthday is Date return { // transmitted as \"2022-01-22T00:00:00.000Z\" createdAt: new Date(\"2022-01-22\"), }; }, });\n\n## Cross-Origin Resource Sharing\n\nYou can enable your API for other domains using the corresponding\nconfiguration option cors. It's not optional to draw your attention to making\nthe appropriate decision, however, it's enabled in the Quick start example\nabove, assuming that in most cases you will want to enable this feature. See\nMDN article for more information.\n\nIn addition to being a boolean, cors can also be assigned a function that\noverrides default CORS headers. That function has several parameters and can\nbe asynchronous.\n\n    \n    \n    import { createConfig } from \"express-zod-api\"; const config = createConfig({ // ... other options cors: ({ defaultHeaders, request, endpoint, logger }) => ({ ...defaultHeaders, \"Access-Control-Max-Age\": \"5000\", }), });\n\nPlease note: If you only want to send specific headers on requests to a\nspecific endpoint, consider the Middlewares or response customization\napproach.\n\n## Enabling HTTPS\n\nThe modern API standard often assumes the use of a secure data transfer\nprotocol, confirmed by a TLS certificate, also often called an SSL certificate\nin habit. When using the createServer() method, you can additionally configure\nand run the HTTPS server.\n\n    \n    \n    import { createConfig, createServer } from \"express-zod-api\"; const config = createConfig({ server: { listen: 80, }, https: { options: { cert: fs.readFileSync(\"fullchain.pem\", \"utf-8\"), key: fs.readFileSync(\"privkey.pem\", \"utf-8\"), }, listen: 443, // port, UNIX socket or options }, // ... cors, logger, etc }); // 'await' is only needed if you're going to use the returned entities. // For top level CJS you can wrap you code with (async () => { ... })() const { app, httpServer, httpsServer, logger } = await createServer( config, routing, );\n\nEnsure having @types/node package installed. At least you need to specify the\nport (usually it is 443) or UNIX socket, certificate and the key, issued by\nthe certifying authority. For example, you can acquire a free TLS certificate\nfor your API at Let's Encrypt.\n\n## Customizing logger\n\nYou can uninstall winston (which is the default and recommended logger) and\nuse another compatible one, having info(), debug(), error() and warn()\nmethods. For example, pino logger with pino-pretty extension:\n\n    \n    \n    import pino, { Logger } from \"pino\"; import { createConfig } from \"express-zod-api\"; const logger = pino({ transport: { target: \"pino-pretty\", options: { colorize: true }, }, }); const config = createConfig({ logger }); // Setting the type of logger used declare module \"express-zod-api\" { interface LoggerOverrides extends Logger {} }\n\n## Child logger\n\nIn case you need a dedicated logger for each request (for example, equipped\nwith a request ID), you can specify the childLoggerProvider option in your\nconfiguration. The function accepts the initially defined logger and the\nrequest, it can also be asynchronous. The child logger returned by that\nfunction will replace the logger in all handlers.\n\n    \n    \n    import { createConfig } from \"express-zod-api\"; import { randomUUID } from \"node:crypto\"; const config = createConfig({ // logger: ..., childLoggerProvider: ({ parent, request }) => parent.child({ requestId: randomUUID() }), });\n\n## Enabling compression\n\nAccording to Express.js best practices guide it might be a good idea to enable\nGZIP compression of your API responses.\n\nInstall the following additional packages: compression and @types/compression,\nand enable or configure compression:\n\n    \n    \n    import { createConfig } from \"express-zod-api\"; const config = createConfig({ server: { /** @link https://www.npmjs.com/package/compression#options */ compression: { threshold: \"1kb\" }, // or true }, });\n\nIn order to receive a compressed response the client should include the\nfollowing header in the request: Accept-Encoding: gzip, deflate. Only\nresponses with compressible content types are subject to compression.\n\n# Advanced features\n\n## Customizing input sources\n\nYou can customize the list of request properties that are combined into input\nthat is being validated and available to your endpoints and middlewares. The\norder here matters: each next item in the array has a higher priority than its\nprevious sibling.\n\n    \n    \n    import { createConfig } from \"express-zod-api\"; createConfig({ inputSources: { // the defaults are: get: [\"query\", \"params\"], post: [\"body\", \"params\", \"files\"], put: [\"body\", \"params\"], patch: [\"body\", \"params\"], delete: [\"query\", \"params\"], }, // ... });\n\n## Route path params\n\nYou can describe the route of the endpoint using parameters:\n\n    \n    \n    import { Routing } from \"express-zod-api\"; const routing: Routing = { v1: { user: { // route path /v1/user/:id, where :id is the path param \":id\": getUserEndpoint, // use the empty string to represent /v1/user if needed: // \"\": listAllUsersEndpoint, }, }, };\n\nYou then need to specify these parameters in the endpoint input schema in the\nusual way:\n\n    \n    \n    const getUserEndpoint = endpointsFactory.build({ method: \"get\", input: z.object({ // id is the route path param, always string id: z.string().transform((value) => parseInt(value, 10)), // other inputs (in query): withExtendedInformation: z.boolean().optional(), }), output: z.object({ /* ... */ }), handler: async ({ input: { id } }) => { // id is the route path param, number }, });\n\n## Multiple schemas for one route\n\nThanks to the DependsOnMethod class a route may have multiple Endpoints\nattached depending on different methods. It can also be the same Endpoint that\nhandles multiple methods as well.\n\n    \n    \n    import { DependsOnMethod } from \"express-zod-api\"; // the route /v1/user has two Endpoints // which handle a couple of methods each const routing: Routing = { v1: { user: new DependsOnMethod({ get: yourEndpointA, delete: yourEndpointA, post: yourEndpointB, patch: yourEndpointB, }), }, };\n\nSee also Different responses for different status codes.\n\n## Response customization\n\nResultHandler is responsible for transmitting consistent responses containing\nthe endpoint output or an error. The defaultResultHandler sets the HTTP status\ncode and ensures the following type of the response:\n\n    \n    \n    type DefaultResponse<OUT> = | { // Positive response status: \"success\"; data: OUT; } | { // or Negative response status: \"error\"; error: { message: string; }; };\n\nYou can create your own result handler by using this example as a template:\n\n    \n    \n    import { z } from \"zod\"; import { createResultHandler, IOSchema, getStatusCodeFromError, getMessageFromError, } from \"express-zod-api\"; const yourResultHandler = createResultHandler({ getPositiveResponse: (output: IOSchema) => ({ schema: z.object({ data: output }), mimeType: \"application/json\", // optinal, or mimeTypes for array }), getNegativeResponse: () => z.object({ error: z.string() }), handler: ({ error, input, output, request, response, logger }) => { if (!error) { // your implementation return; } const statusCode = getStatusCodeFromError(error); const message = getMessageFromError(error); // your implementation }, });\n\nNote: OutputValidationError and InputValidationError are also available for\nyour custom error handling. See also Different responses for different status\ncodes.\n\nAfter creating your custom ResultHandler you can use it as an argument for\nEndpointsFactory instance creation:\n\n    \n    \n    import { EndpointsFactory } from \"express-zod-api\"; const endpointsFactory = new EndpointsFactory(yourResultHandler);\n\nPlease note: ResultHandler must handle any errors and not throw its own.\nOtherwise, the case will be passed to the LastResortHandler, which will set\nthe status code to 500 and send the error message as plain text.\n\n## Non-object response\n\nThus, you can configure non-object responses too, for example, to send an\nimage file.\n\nYou can find two approaches to EndpointsFactory and ResultHandler\nimplementation in this example. One of them implements file streaming, in this\ncase the endpoint just has to provide the filename. The response schema\ngenerally may be just z.string(), but I made more specific ez.file() that also\nsupports ez.file(\"binary\") and ez.file(\"base64\") variants which are reflected\nin the generated documentation.\n\n    \n    \n    const fileStreamingEndpointsFactory = new EndpointsFactory( createResultHandler({ getPositiveResponse: () => ({ schema: ez.file(\"buffer\"), mimeType: \"image/*\", }), getNegativeResponse: () => ({ schema: z.string(), mimeType: \"text/plain\" }), handler: ({ response, error, output }) => { if (error) { response.status(400).send(error.message); return; } if (\"filename\" in output) { fs.createReadStream(output.filename).pipe( response.type(output.filename), ); } else { response.status(400).send(\"Filename is missing\"); } }, }), );\n\n## File uploads\n\nInstall the following additional packages: express-fileupload and\n@types/express-fileupload, and enable or configure file uploads:\n\n    \n    \n    import { createConfig } from \"express-zod-api\"; const config = createConfig({ server: { upload: true, // or options }, });\n\nRefer to documentation on available options. Some options are forced in order\nto ensure the correct workflow:\n\n    \n    \n    { abortOnLimit: false, parseNested: true, logger: {}, // the configured logger (default: winston), using its .debug() method }\n\nThe limitHandler option is replaced by the limitError one. You can also\nconnect an additional middleware for restricting the ability to upload using\nthe beforeUpload option. So the configuration for the limited and restricted\nupload might look this way:\n\n    \n    \n    import createHttpError from \"http-errors\"; const config = createConfig({ server: { upload: { limits: { fileSize: 51200 }, // 50 KB limitError: createHttpError(413, \"The file is too large\"), // handled by errorHandler in config beforeUpload: ({ app, logger }) => { app.use((req, res, next) => { if (req.is(\"multipart/form-data\") && !canUpload(req)) { return next(createHttpError(403, \"Not authorized\")); } next(); }); }, }, }, });\n\nThen you can change the Endpoint to handle requests having the multipart/form-\ndata content type instead of JSON by using ez.upload() schema. Together with a\ncorresponding configuration option, this makes it possible to handle file\nuploads. Here is a simplified example:\n\n    \n    \n    import { z } from \"zod\"; import { ez, defaultEndpointsFactory } from \"express-zod-api\"; const fileUploadEndpoint = defaultEndpointsFactory.build({ method: \"post\", input: z.object({ avatar: ez.upload(), // <-- }), output: z.object({}), handler: async ({ input: { avatar } }) => { // avatar: {name, mv(), mimetype, data, size, etc} // avatar.truncated is true on failure when limitError option is not set }, });\n\nYou can still send other data and specify additional input parameters,\nincluding arrays and objects.\n\n## Serving static files\n\nIn case you want your server to serve static files, you can use new\nServeStatic() in Routing using the arguments similar to express.static(). The\ndocumentation on these arguments you may find here.\n\n    \n    \n    import { Routing, ServeStatic } from \"express-zod-api\"; import { join } from \"node:path\"; const routing: Routing = { // path /public serves static files from ./assets public: new ServeStatic(join(__dirname, \"assets\"), { dotfiles: \"deny\", index: false, redirect: false, }), };\n\n## Connect to your own express app\n\nIf you already have your own configured express application, or you find the\nlibrary settings not enough, you can connect the endpoints to your app or any\nexpress router using the attachRouting() method:\n\n    \n    \n    import express from \"express\"; import { createConfig, attachRouting, Routing } from \"express-zod-api\"; const app = express(); // or express.Router() const config = createConfig({ app /* cors, logger, ... */ }); const routing: Routing = {}; // your endpoints go here // This async IIFE is only required for the top level CommonJS (async () => { const { notFoundHandler, logger } = await attachRouting(config, routing); app.use(notFoundHandler); // optional app.listen(); logger.info(\"Glory to science!\"); })();\n\nPlease note that in this case you probably need to parse request.body, call\napp.listen() and handle 404 errors yourself. In this regard attachRouting()\nprovides you with notFoundHandler which you can optionally connect to your\ncustom express app.\n\nBesides that, if you're looking to include additional request parsers, or a\nmiddleware that establishes its own routes, then consider using the\nbeforeRouting option in config instead.\n\n# Special needs\n\n## Different responses for different status codes\n\nIn some special cases you may want the ResultHandler to respond slightly\ndifferently depending on the status code, for example if your API strictly\nfollows REST standards. It may also be necessary to reflect this difference in\nthe generated Documentation. To implement this functionality, the\ncreateResultHandler method supports a flexible declaration of possible\nresponse schemas and their corresponding status codes.\n\n    \n    \n    import { createResultHandler } from \"express-zod-api\"; createResultHandler({ getPositiveResponse: (output) => ({ statusCodes: [201, 202], // created or will be created schema: z.object({ status: z.literal(\"created\"), data: output }), }), getNegativeResponse: () => [ { statusCode: 409, // conflict: entity already exists schema: z.object({ status: z.literal(\"exists\"), id: z.number().int() }), }, { statusCodes: [400, 500], // validation or internal error schema: z.object({ status: z.literal(\"error\"), reason: z.string() }), }, ], handler: ({ error, response, output }) => { // your implementation here }, });\n\n## Array response\n\nPlease avoid doing this in new projects: responding with array is a bad\npractice keeping your endpoints from evolving in backward compatible way\n(without making breaking changes). Nevertheless, for the purpose of easier\nmigration of legacy APIs to this library consider using arrayResultHandler or\narrayEndpointsFactory instead of default ones, or implement your own ones in a\nsimilar way. The arrayResultHandler expects your endpoint to have items\nproperty in the output object schema. The array assigned to that property is\nused as the response. This approach also supports examples, as well as\ndocumentation and client generation. Check out the example endpoint for more\ndetails.\n\n## Headers as input source\n\nIn a similar way you can enable the inclusion of request headers into the\ninput sources. This is an opt-in feature. Please note:\n\n  * only the custom headers (the ones having x- prefix) will be combined into the input,\n  * the request headers acquired that way are lowercase when describing their validation schemas.\n\n    \n    \n    import { createConfig, defaultEndpointsFactory } from \"express-zod-api\"; import { z } from \"zod\"; createConfig({ inputSources: { get: [\"query\", \"headers\"], }, // ... }); defaultEndpointsFactory.build({ method: \"get\", input: z.object({ \"x-request-id\": z.string(), // this one is from request.headers id: z.string(), // this one is from request.query }), // ... });\n\n## Accepting raw data\n\nSome APIs may require an endpoint to be able to accept and process raw data,\nsuch as streaming or uploading a binary file as an entire body of request. In\norder to enable this feature you need to set the rawParser config feature to\nexpress.raw(). See also its options in Express.js documentation. The raw data\nis placed into request.body.raw property, having type Buffer. Then use the\nproprietary ez.raw() schema (which is an alias for z.object({ raw:\nez.file(\"buffer\") })) as the input schema of your endpoint.\n\n    \n    \n    import express from \"express\"; import { createConfig, defaultEndpointsFactory, ez } from \"express-zod-api\"; const config = createConfig({ server: { rawParser: express.raw(), // enables the feature }, }); const rawAcceptingEndpoint = defaultEndpointsFactory.build({ method: \"post\", input: ez .raw() // accepts the featured { raw: Buffer } .extend({}), // for additional inputs, like route params, if needed output: z.object({ length: z.number().int().nonnegative() }), handler: async ({ input: { raw } }) => ({ length: raw.length, // raw is Buffer }), });\n\n## Resources cleanup\n\nIf some entities (database clients for example) do not care about\nautomatically releasing their resources when their instances are destroyed,\nyou can do the following. Return these instances in a middleware so that they\nbecome options for Endpoint's handler. Those options are also available as an\nargument to a Result Handler. Create your own one and clean up resources in\naccordance with the documentation of that software. The options may however be\nempty or incomplete in case of errors or failures, so it is necessary to check\nfor their presence programmatically.\n\n    \n    \n    import { createResultHandler, EndpointsFactory, createMiddleware, } from \"express-zod-api\"; const resultHandlerWithCleanup = createResultHandler({ handler: ({ options }) => { if (\"dbClient\" in options && options.dbClient) { (options.dbClient as DBClient).close(); // sample cleanup } // your implementation }, }); const dbProvider = createMiddleware({ handler: async () => ({ dbClient: new DBClient(), // sample entity that requires cleanup }), }); const dbEquippedFactory = new EndpointsFactory( resultHandlerWithCleanup, ).addMiddleware(dbProvider);\n\n# Integration and Documentation\n\n## Generating a Frontend Client\n\nYou can generate a Typescript file containing the IO types of your API and a\nclient for it. Consider installing prettier and using the async\nprintFormatted() method.\n\n    \n    \n    import { Integration } from \"express-zod-api\"; const client = new Integration({ routing, variant: \"client\", // <\u2014 optional, see also \"types\" for a DIY solution optionalPropStyle: { withQuestionMark: true, withUndefined: true }, // optional splitResponse: false, // optional, prints the positive and negative response types separately }); const prettierFormattedTypescriptCode = await client.printFormatted(); // or just .print() for unformatted\n\nAlternatively, you can supply your own format function into that method or use\na regular print() method instead. The generated client is flexibly\nconfigurable on the frontend side using an implementation function that\ndirectly makes requests to an endpoint using the libraries and methods of your\nchoice. The client asserts the type of request parameters and response.\nConsuming the generated client requires Typescript version 4.1 or higher.\n\n    \n    \n    // example frontend, simple implementation based on fetch() import { ExpressZodAPIClient } from \"./client.ts\"; // the generated file const client = new ExpressZodAPIClient(async (method, path, params) => { const hasBody = ![\"get\", \"delete\"].includes(method); const searchParams = hasBody ? \"\" : `?${new URLSearchParams(params)}`; const response = await fetch(`https://example.com${path}${searchParams}`, { method: method.toUpperCase(), headers: hasBody ? { \"Content-Type\": \"application/json\" } : undefined, body: hasBody ? JSON.stringify(params) : undefined, }); return response.json(); }); client.provide(\"get\", \"/v1/user/retrieve\", { id: \"10\" }); client.provide(\"post\", \"/v1/user/:id\", { id: \"10\" }); // it also substitues path params\n\n## Creating a documentation\n\nYou can generate the specification of your API and write it to a .yaml file,\nthat can be used as the documentation:\n\n    \n    \n    import { Documentation } from \"express-zod-api\"; const yamlString = new Documentation({ routing, // the same routing and config that you use to start the server config, version: \"1.2.3\", title: \"Example API\", serverUrl: \"https://example.com\", composition: \"inline\", // optional, or \"components\" for keeping schemas in a separate dedicated section using refs // descriptions: { positiveResponse, negativeResponse, requestParameter, requestBody } // check out these features }).getSpecAsYaml();\n\nYou can add descriptions and examples to your endpoints, their I/O schemas and\ntheir properties. It will be included into the generated documentation of your\nAPI. Consider the following example:\n\n    \n    \n    import { defaultEndpointsFactory, withMeta } from \"express-zod-api\"; const exampleEndpoint = defaultEndpointsFactory.build({ shortDescription: \"Retrieves the user.\", // <\u2014\u2014 this becomes the summary line description: \"The detailed explanaition on what this endpoint does.\", input: withMeta( z.object({ id: z.number().describe(\"the ID of the user\"), }), ).example({ id: 123, }), // ..., similarly for output and middlewares });\n\nSee the example of the generated documentation here\n\n## Tagging the endpoints\n\nWhen generating documentation, you may find it necessary to classify endpoints\ninto groups. For this, the possibility of tagging endpoints is provided. In\norder to achieve the consistency of tags across all endpoints, the possible\ntags should be declared in the configuration first and another instantiation\napproach of the EndpointsFactory is required. Consider the following example:\n\n    \n    \n    import { createConfig, EndpointsFactory, defaultResultHandler, } from \"express-zod-api\"; const config = createConfig({ // ..., use the simple or the advanced syntax: tags: { users: \"Everything about the users\", files: { description: \"Everything about the files processing\", url: \"https://example.com\", }, }, }); // instead of defaultEndpointsFactory use the following approach: const taggedEndpointsFactory = new EndpointsFactory({ resultHandler: defaultResultHandler, // or use your custom one config, // <\u2014\u2014 supply your config here }); const exampleEndpoint = taggedEndpointsFactory.build({ // ... tag: \"users\", // or tags: [\"users\", \"files\"] });\n\n## How to test endpoints\n\nThe way to test endpoints is to mock the request, response, and logger\nobjects, invoke the execute() method, and assert the expectations for calls of\ncertain mocked methods. The library provides a special method testEndpoint\nthat makes mocking easier. It requires you either to install jest (with\n@types/jest) or vitest (detects automatically), or to specify the fnMethod\nproperty assigned with a function mocking method of your testing framework,\nwhich can also be node:test module of most modern Node.js versions. However,\nin order to have proper mocking types in your own tests, you also need to\nspecify MockOverrides once in your tests excplicitly, so the tests should look\nthis way:\n\n    \n    \n    import { testEndpoint } from \"express-zod-api\"; // place it once anywhere in your tests declare module \"express-zod-api\" { interface MockOverrides extends jest.Mock {} // or Mock from vitest } test(\"should respond successfully\", async () => { const { responseMock, loggerMock } = await testEndpoint({ endpoint: yourEndpoint, requestProps: { method: \"POST\", // default: GET body: {}, // incoming data as if after parsing (JSON) }, // fnMethod \u2014 for testing frameworks other than jest or vitest // responseProps, configProps, loggerProps }); expect(loggerMock.error).toHaveBeenCalledTimes(0); expect(responseMock.status).toHaveBeenCalledWith(200); expect(responseMock.json).toHaveBeenCalledWith({ status: \"success\", data: {}, }); });\n\nThis method is optimized for the defaultResultHandler. With the flexibility to\ncustomize, you can add additional properties as needed.\n\n# Caveats\n\nThere are some well-known issues and limitations, or third party bugs that\ncannot be fixed in the usual way, but you should be aware of them.\n\n## Coercive schema of Zod\n\nDespite being supported by the library, z.coerce.* schema does not work\nintuitively. Please be aware that z.coerce.number() and z.number({ coerce:\ntrue }) (being typed not well) still will NOT allow you to assign anything but\nnumber. Moreover, coercive schemas are not fail-safe and their methods\n.isOptional() and .isNullable() are buggy. If possible, try to avoid using\nthis type of schema. This issue will NOT be fixed in Zod version 3.x.\n\n## Excessive properties in endpoint output\n\nThe schema validator removes excessive properties by default. However,\nTypescript does not yet display errors in this case during development. You\ncan achieve this verification by assigning the output schema to a constant and\nreusing it in forced type of the output:\n\n    \n    \n    import { z } from \"zod\"; const output = z.object({ anything: z.number(), }); endpointsFactory.build({ methods, input, output, handler: async (): Promise<z.input<typeof output>> => ({ anything: 123, excessive: \"something\", // error TS2322, ok! }), });\n\n# Your input to my output\n\nIf you have a question or idea, or you found a bug, or vulnerability, or\nsecurity issue, or want to make a PR: please refer to Contributing Guidelines.\n\n## About\n\nA Typescript library to help you get an API server up and running with I/O\nschema validation and custom middlewares in minutes.\n\nez.robintail.cz\n\n### Topics\n\nnodejs api http middleware documentation json express typescript schema\nvalidation server swagger documentation-tool openapi schema-validation\nendpoint hacktoberfest openapi-specification swagger-documentation zod\n\n### Resources\n\nReadme\n\n### License\n\nMIT license\n\n### Code of conduct\n\nCode of conduct\n\n### Security policy\n\nSecurity policy\n\nActivity\n\n### Stars\n\n542 stars\n\n### Watchers\n\n4 watching\n\n### Forks\n\n26 forks\n\nReport repository\n\n## Releases 71\n\nv17.7.0 Latest\n\nApr 10, 2024\n\n\\+ 70 releases\n\n## Contributors 9\n\n## Languages\n\n  * TypeScript 100.0%\n\n## Footer\n\n\u00a9 2024 GitHub, Inc.\n\nYou can\u2019t perform that action at this time.\n\n", "frontpage": false}
