{"aid": "40064903", "title": "SEO mistakes I've made and how I fixed them (2020)", "url": "https://blog.maximeheckel.com/posts/seo-mistakes-i-have-made-and-how-i-fixed-them/", "domain": "maximeheckel.com", "votes": 2, "user": "tosh", "posted_at": "2024-04-17 14:13:23", "comments": 0, "source_title": "SEO mistakes I've made and how I fixed them - Maxime Heckel's Blog", "source_text": "SEO mistakes I've made and how I fixed them - Maxime Heckel's Blog\n\n@MaximeHeckel\n\nSEO mistakes I've made and how I fixed them\n\nHome\n\n# SEO mistakes I've made and how I fixed them\n\nOctober 13, 2020 / 15 min read\n\nLast Updated: June 14, 2021\n\nFrom 0 to 90k impressions in about a year, following Search Engine\nOptimization good practices was key to help to grow my blog and my audience.\nHowever, when I started it, I made terrible mistakes that some SEO literate\npeople could almost qualify as self-sabotage.\n\nThus, I want to dedicate this blog post to look back at 3 issues that caused\nme, and many others, countless headaches when dealing with SEO and Gatsby and\nthe steps I took to fix them. I hope that this will help to fix some issues\nyou might currently have on your awesome blog or portfolio without even being\naware of them, kick-off your audience growth, and get discovered online \ud83d\ude80.\n\n## Why SEO is so important?\n\nYou might know very little about what SEO does behind the scenes. To me, at\nleast, it looked like an obscure, inconsistent, pseudo-science that only\nmarketing people could understand (spoiler alert, it still kind of is).\nHowever, after getting @monicalent's awesome course bloggingfordevs, it made\nthe inner workings and good practices related to SEO a bit clearer to me. To\nquote her from her first newsletter\n\n> SEO is a way of making sure that search engines can understand what your\n> page is about, that it contains quality up-to-date information from an\n> authoritative source, and will answer the question that the searcher had in\n> mind.\n\nWith good SEO, search engines can know what your content is about, discover\nall the blog posts you've written and, if you're lucky, catapult you to the\ntop search result for a given set of keywords. Moreover, where sharing my\nnewest articles on Twitter and Reddit would just cause a spike in traffic for\na few days, SEO helps you get a more consistent traffic on your website, and\nfor a longer time. The latter is what I was lacking for the longest time,\ndespite having set up my Gatsby website and SEO component properly (or at\nleast I thought so).\n\nGatsby's documentation has an incredibly well-written section on how to build\nan SEO component to help you get started. However, that alone wasn't enough to\nmake my blog discoverable early on, as you can see in the chart below\nrepresenting the number of daily impressions I got since starting this blog:\n\nChart representing the number of impressions per day of this blog on Google\nSearch from August 2019 to the October 2020 (hover to see the data)\n\nFor most of its first year, my blog was getting less than 50 daily\nimpressions. Today, after fixing the issues I'm about to talk about, I get\nover 1000 daily impressions and it's still growing! Of course, SEO is not the\nonly component here, I also created more content this year and choose a better\nway to promote them, but it is still a significant driver to the growth you\ncan see above.\n\n## Trailing slashes chaos\n\nThe blog you're reading this article on is built with Gatsby and hosted on\nNetlify. Sadly, using these two tools together without taking care of\ninconsistent trailing slash / at the end of your URLs can result in some\nundesirable outcomes.\n\nOne of these outcomes was that I was seeing a lot of 301 redirects logged in\nmy analytics as readers were navigating to my articles. On my blog, a link to\none of my blog posts would typically look like this: /posts/learning-in-public\nbut when a reader clicked on it Netlify would append a trailing slash at the\nend of it thus redirecting the user.\n\nThat, my friends, is extremely bad for SEO. It impacted several unrelated\nareas of my website, such as:\n\n  * Opengraph images or Twitter cards not being rendered consistently: readers would share a link sometimes with or without the trailing slash which would make it hard for some services to get the proper metadata and thus render a simple link instead of a proper preview card.\n\n  * Invalid URLs in sitemap: my sitemap is generated automatically at build time with a Gatsby plugin based on the URLs and pages of my website. Since I did not have trailing slashes at the end of my URLs it would generate my sitemap without them which once uploaded to Google Search Console would result in tons of warnings about invalid URLs since Google referenced the ones with the trailing slashes.\n\n### How I fixed this\n\nI could have fixed this in two different ways:\n\n  1. Disable the \"Pretty URLs\" option in Netlify's asset optimization settings. (see screenshot below)\n\n  2. Add a trailing slash to all my URLs on my blog.\n\nImage showcasing the asset optimizations options available in the Netlify\nproject settings. Here you can see that I have the pretty URL option turned on\nwhich will add a trailing slash at the end of my URLs on this project.\n\nAs Google already referenced my blog posts with a trailing slash, I decided to\ngo with option number 2.\n\nThat change might look insignificant, but it resulted in a lot of weird issues\nsuddenly disappearing. Additionally, it was essential for me to fix this\nbefore addressing the issue I'm just about to start talking about \ud83d\ude04!\n\n## Canonical links\n\nIf you've been following me for a while, you might have started reading my\ncontent on Medium. I started blog.maximeheckel.com just about a year ago as of\nthe time I'm writing these words. All the content on this site that dates back\nto before August 2019, was originally published on Medium.\n\nOn top of that, I did not edit the articles when migrating them to this\nwebsite, nor did I delete the Medium ones. This resulted in duplicated\ncontent, which meant that my newly deployed blog was in competition with\nMedium on the same keyword, the same content, from the same author when it\ncomes to ranking on Google.\n\nThankfully there's a way to avoid this: setting canonical URLs. These URLs are\nplaced in the <head> of your blog posts source code and designate that this\npost is the \"original\" post with that given content.\n\nThere are 2 steps to add valid canonical URLs to your website:\n\n  1. You need to add them to the <head> of your post. See example below\n\n  2. Head over to any third party platform you used in the past that has the content and add this canonical URL into the setting page of your post. I followed this guide on Medium to update my old blog post.\n\nExample of canonical URL\n\n    \n    \n    1\n    \n    <link\n    \n    2\n    \n    rel=\"canonical\"\n    \n    3\n    \n    href=\"https://blog.maximeheckel.com/posts/learning-in-public/\"\n    \n    4\n    \n    />\n\nOf course, you cannot do the first step until you've fixed any potential\ntrailing slashes issues you may have like the ones I shared just above.\n\nIf like me you're a Gatsby user, you might be tempted to use gatsby-plugin-\ncanonical-urls which adds canonical URLs to your site's HTML pages at build\ntime.\n\nI do not recommend this plugin for complex setups.\n\nI tried it and it would consistently fail to put the proper URL, especially\nsince my website as offline support it would sometimes write the offline\nfallback url in the <head/> of my HTML pages. You'll be safer to add your\ncanonical links programmatically in your own SEO component. See the code\nsnippet below for an example.\n\nSimplied version of the SEO component I built with support for canonical URLs\n\n    \n    \n    1\n    \n    import { graphql, StaticQuery } from 'gatsby';\n    \n    2\n    \n    import React from 'react';\n    \n    3\n    \n    import Helmet from 'react-helmet';\n    \n    4\n    \n    5\n    \n    const query = graphql`\n    \n    6\n    \n    query SEO {\n    \n    7\n    \n    site {\n    \n    8\n    \n    siteMetadata {\n    \n    9\n    \n    defaultTitle: title\n    \n    10\n    \n    author\n    \n    11\n    \n    keywords\n    \n    12\n    \n    siteUrl: url\n    \n    13\n    \n    defaultDescription: description\n    \n    14\n    \n    twitter\n    \n    15\n    \n    }\n    \n    16\n    \n    }\n    \n    17\n    \n    }\n    \n    18\n    \n    `;\n    \n    19\n    \n    20\n    \n    const SEO = ({ title, desc, image, pathname, date }) => (\n    \n    21\n    \n    <StaticQuery\n    \n    22\n    \n    query={query}\n    \n    23\n    \n    render={({\n    \n    24\n    \n    site: {\n    \n    25\n    \n    siteMetadata: {\n    \n    26\n    \n    author,\n    \n    27\n    \n    defaultTitle,\n    \n    28\n    \n    siteUrl,\n    \n    29\n    \n    keywords,\n    \n    30\n    \n    defaultDescription,\n    \n    31\n    \n    twitter,\n    \n    32\n    \n    },\n    \n    33\n    \n    },\n    \n    34\n    \n    }) => {\n    \n    35\n    \n    const seo = {\n    \n    36\n    \n    description: desc || defaultDescription,\n    \n    37\n    \n    image: `${siteUrl}${image}`,\n    \n    38\n    \n    date: date ? date : '',\n    \n    39\n    \n    title: title || defaultTitle,\n    \n    40\n    \n    url: `${siteUrl}/${pathname ? `posts/${pathname}` : ''}`,\n    \n    41\n    \n    };\n    \n    42\n    \n    43\n    \n    return (\n    \n    44\n    \n    <Helmet title={seo.title} defer={false}>\n    \n    45\n    \n    <html lang=\"en\" />\n    \n    46\n    \n    <meta name=\"description\" content={seo.description} />\n    \n    47\n    \n    <meta name=\"image\" content={seo.image} />\n    \n    48\n    \n    <link rel=\"canonical\" href={seo.url} />\n    \n    49\n    \n    <meta property=\"og:url\" content={seo.url} />\n    \n    50\n    \n    <meta property=\"og:type\" content=\"article\" />\n    \n    51\n    \n    <meta\n    \n    52\n    \n    name=\"keywords\"\n    \n    53\n    \n    content={keywords && keywords.length > 0 ? keywords.join(`, `) : ''}\n    \n    54\n    \n    />\n    \n    55\n    \n    <meta property=\"og:title\" content={seo.title} />\n    \n    56\n    \n    <meta property=\"og:description\" content={seo.description} />\n    \n    57\n    \n    <meta property=\"og:image\" content={seo.image} />\n    \n    58\n    \n    <meta name=\"twitter:card\" content=\"summary_large_image\" />\n    \n    59\n    \n    <meta name=\"twitter:creator\" content={twitter} />\n    \n    60\n    \n    <meta name=\"twitter:site\" content={twitter} />\n    \n    61\n    \n    <meta name=\"twitter:title\" content={seo.title} />\n    \n    62\n    \n    <meta name=\"twitter:description\" content={seo.description} />\n    \n    63\n    \n    <meta name=\"twitter:image\" content={seo.image} />\n    \n    64\n    \n    </Helmet>\n    \n    65\n    \n    );\n    \n    66\n    \n    }}\n    \n    67\n    \n    />\n    \n    68\n    \n    );\n\n## Server-side rendering and missing meta tags\n\nIn this part, we'll look at the one instance where Gatsby's server-side\nrendering mixed with my carelessness completely broke my SEO. By completely I\nmean all my custom SEO meta tags that I carefully put in my SEO component were\ngone from the server-side rendered version of the website making it almost\ninvisible to any search engine.\n\n### How it happened\n\nThis issue stemmed from what I would qualify as an interrupted static HTML\nbuild.\n\nWhen building your Gatsby site the last steps of the build process involve\nbuilding your production JS files and also generating the HTML for each page.\nIf you're looking for more details you can check out this section of the\nGatsby documentation about the build process.\n\nHowever, I wrote a ThemeProvider that wrapped the whole application. Thus any\ncomponent or page can know which theme (dark or light) is currently enabled\nand the colors to use. This component was added to the gatsby-ssr and gatsby-\nbrowser files.\n\nUnder the hood, this ThemeProvider worked as follow:\n\n  * the state of the theme (dark or light) was injected via a React Provider to the whole app, that's how I can allow users to toggle between each theme.\n\n  * that same state was also saved in the local storage to make sure revisiting the website would keep the previous theme enabled. When a reader loads this blog, the ThemeProvider will check for the presence of a specific variable in localStorage before setting the theme accordingly.\n\nI dedicated a blog post for this: Switching off the lights - Adding dark mode\nto your React app and it actually contains the mistake that triggered the\nmissing meta tags:\n\n  * Getting the variable set to the current theme from local storage was done in a React useEffect. Thus, for a brief instant when loading or refreshing the website, the website would fallback to the default theme as the effect to set the proper theme was only ran after the server-rendered page was already served.\n\n  * To avoid this issue, I added a small tweak to track whether the theme was fetched from local storage or not and render an empty div while the theme was being retrieved.\n\nThe code snippet below is an excerpt of my original implementation for the\nThemeProvider of this blog.\n\nExcerpt of my original ThemeProvider (where I made my dumb mistake)\n\n    \n    \n    1\n    \n    const ThemeProvider = ({ children }: { children: ReactNode }) => {\n    \n    2\n    \n    const [themeState, setThemeState] = useDarkMode();\n    \n    3\n    \n    if (!themeState.hasThemeLoaded) {\n    \n    4\n    \n    /*\n    \n    5\n    \n    If the theme is not yet loaded we don't want to render\n    \n    6\n    \n    this is just a workaround to avoid having the app rendering\n    \n    7\n    \n    in light mode by default and then switch to dark mode while\n    \n    8\n    \n    getting the theme state from localStorage\n    \n    9\n    \n    */\n    \n    10\n    \n    return <div />;\n    \n    11\n    \n    }\n    \n    12\n    \n    const theme = themeState.dark ? theme('dark') : theme('light');\n    \n    13\n    \n    const toggle = () => {\n    \n    14\n    \n    // toogle function goes here\n    \n    15\n    \n    };\n    \n    16\n    \n    17\n    \n    // Once the theme is loaded, render the rest of the DOM\n    \n    18\n    \n    return (\n    \n    19\n    \n    <EmotionThemeProvider theme={theme}>\n    \n    20\n    \n    <ThemeContext.Provider\n    \n    21\n    \n    value={{\n    \n    22\n    \n    dark: themeState.dark,\n    \n    23\n    \n    toggle,\n    \n    24\n    \n    }}\n    \n    25\n    \n    >\n    \n    26\n    \n    {children}\n    \n    27\n    \n    </ThemeContext.Provider>\n    \n    28\n    \n    </EmotionThemeProvider>\n    \n    29\n    \n    );\n    \n    30\n    \n    };\n\nRendering that empty div is what made my SEO meta tags disappear. The static\nHTML build would only generate the tree up to that div since the theme had no\nway to be set at build time, and thus would skip all the rest of the DOM which\nincluded my pages and components, as well as the SEO component \ud83d\ude31. Since, the\ncode of the SEO component was not being reached during that step of the build,\nthe meta tags couldn't be injected in the static HTML.\n\nShoutout to @chrisbiscardi for helping me debugging this one, he helped me a\nlot to go through the Gatsby build process and track down the origin of this\nerror. It would have taken me way longer to solve this issue without his help.\n\nAdditionally, that kind of issue was hard to track because the tags were\nshowing up when inspecting the page with the dev tools client-side, they were\nhowever completely absent from the source of the page (the one you can get by\nright-clicking on a web page and clicking on \"View Page Source\").\n\nHaving SEO tags completely missing from the page source made SEO third-party\nservices like Twitter Card Validator simply unusable with my blog. My articles\nwould only show up as basic links on social media. No cards, no preview, not\neven a title which is very bad when you try to grab the attention of your\naudience!\n\nFYI, I have since changed my implementation of the ThemeProvider component of\nthis blog which fixes this issue. You can find the updated version in Fixing\nthe \"dark mode flash\" issue on server-rendered websites.\n\nMy SEO meta tags disappeared second time earlier this year in July 2020, after\nadding gatsby-plugin-feed and trying to make it work on my blog. Once again,\nbe extremely careful when adding Gatsby plugins that can write on the <head/>\nof your pages. There might create some undesirable outcomes without even you\nknowing!\n\n### The long term solution\n\nAs you can imagine, I was tired of these issues coming out of nowhere and\ndidn't want to manually check every single change I'd make in the future to\nensure meta tags would not be removed. To this problem, I brought a solution\nthat I'd usually bring up at work: I wrote an automated test.\n\nMy SEO tests that I run against every new build to ensure my SEO tags are\nintact\n\n    \n    \n    1\n    \n    const META_RE = /<meta\\s[A-Za-z0-9=\"-:;!@\\/\\s]*/g;\n    \n    2\n    \n    const CANONICAL_RE = /rel=\"canonical\"\\s[A-Za-z0-9=\"-:;!@\\/\\s]*/g;\n    \n    3\n    \n    4\n    \n    describe('SEO: Verify meta tag integrity', () => {\n    \n    5\n    \n    it('has all the meta tags and the expected canonical url set in the landing page head', async () => {\n    \n    6\n    \n    const res = await fetch('/');\n    \n    7\n    \n    const text = await res.text();\n    \n    8\n    \n    9\n    \n    const metaTags = text.match(META_RE) || [];\n    \n    10\n    \n    const canonicalTag = text.match(CANONICAL_RE) || [];\n    \n    11\n    \n    12\n    \n    expect(metaTags).to.have.length(16);\n    \n    13\n    \n    expect(canonicalTag).to.have.length(1);\n    \n    14\n    \n    cy.wrap(metaTags).snapshot();\n    \n    15\n    \n    cy.wrap(canonicalTag).snapshot();\n    \n    16\n    \n    });\n    \n    17\n    \n    18\n    \n    it('has all the meta tags and the expected canonical url set in the blog post head', async () => {\n    \n    19\n    \n    const res = await fetch('/posts/how-to-build-first-eslint-rule');\n    \n    20\n    \n    const text = await res.text();\n    \n    21\n    \n    22\n    \n    const metaTags = text.match(META_RE) || [];\n    \n    23\n    \n    const canonicalTag = text.match(CANONICAL_RE) || [];\n    \n    24\n    \n    25\n    \n    expect(metaTags).to.have.length(19);\n    \n    26\n    \n    expect(canonicalTag).to.have.length(1);\n    \n    27\n    \n    cy.wrap(metaTags).snapshot();\n    \n    28\n    \n    cy.wrap(canonicalTag).snapshot();\n    \n    29\n    \n    });\n    \n    30\n    \n    });\n\n(Don't judge my regex skills \ud83d\ude05)\n\nThe code snippet above is the test that I run with Cypress on every PR without\nexception. This test:\n\n  * fetches the source code of the landing page and a blog post against the built version of the blog\n\n  * looks at the text-based body of the request. That text-based result contains the HTML code for the entire page and thus should contain all the meta tags I set up in my SEO component.\n\n  * compares the obtained string of meta tags to a snapshot. That snapshot contains the source of truth when it comes to the expected state of my meta tags\n\nCypress supports snapshot testing pretty much the same way Jest does! You just\nneed to install the @cypress/snapshot package first and follow these\ninstructions to set it up before you can get snapshot capabilities in your\nintegration and e2e tests.\n\n## Conclusion\n\nIn a nutshell:\n\n  * Be mindful of the consistency of your trailing slashes! Inconsistencies can lead to poor ranking.\n\n  * If you syndicate your content, do not forget to add canonical URLs. I was basically in competition with my own Medium posts up until late this year and missed on a lot more traffic and potential readers.\n\n  * Do not blindly trust gatsby plugins! Especially the ones that inject things in the <head> of your pages. If misused, they can be pretty harmful without even you knowing.\n\n  * Check the page source of your website! Inspecting via the dev tools is sometimes not enough to ensure the meta tags are properly injected in your site.\n\n  * Make sure your meta tags can't be blocked from rendering because of a client side side effect when relying on SSR.\n\n  * When in doubt: Write tests! I dedicated a whole blog post about CI/CD where I showcase how great tests and a great CI/CD pipeline help me keep my peace of mind.\n\nIf you want to go further into how to build an audience, and learn more about\ncreating content and SEO, I would highly encourage you to follow @monicalent\non Twitter as well as her Blogging For Devs course. She's an SEO expert and I\nlearned more about efficient SEO techniques in a single newsletter than I\nwould have otherwise!\n\nLiked this article? Share it with a friend on Twitter or support me to take on\nmore ambitious projects to write about. Have a question, feedback or simply\nwish to contact me privately? Shoot me a DM and I'll do my best to get back to\nyou.\n\nHave a wonderful day.\n\n\u2013 Maxime\n\n2020-10-13T08:00:00.000+01:00\n\nA look back at what I learned fixing my terrible SEO mistakes on my Gatsby\nwebsites\n\nHomeDesignRSS\n\nTwitterGithubBuy me a coffee\n\nPortfolioRoadmapNewsletter\n\n\u00a9 2024 Maxime Heckel \u2014\u2014 New York\n\n", "frontpage": false}
