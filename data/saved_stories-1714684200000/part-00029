{"aid": "40235574", "title": "Rust 1.78.0", "url": "https://blog.rust-lang.org/2024/05/02/Rust-1.78.0.html", "domain": "rust-lang.org", "votes": 1, "user": "HieronymusBosch", "posted_at": "2024-05-02 12:48:57", "comments": 0, "source_title": "Announcing Rust 1.78.0 | Rust Blog", "source_text": "Announcing Rust 1.78.0 | Rust Blog\n\n## Announcing Rust 1.78.0\n\nMay 2, 2024 \u00b7 The Rust Release Team\n\nThe Rust team is happy to announce a new version of Rust, 1.78.0. Rust is a\nprogramming language empowering everyone to build reliable and efficient\nsoftware.\n\nIf you have a previous version of Rust installed via rustup, you can get\n1.78.0 with:\n\n    \n    \n    $ rustup update stable\n\nIf you don't have it already, you can get rustup from the appropriate page on\nour website, and check out the detailed release notes for 1.78.0.\n\nIf you'd like to help us out by testing future releases, you might consider\nupdating locally to use the beta channel (rustup default beta) or the nightly\nchannel (rustup default nightly). Please report any bugs you might come\nacross!\n\n## What's in 1.78.0 stable\n\n### Diagnostic attributes\n\nRust now supports a #[diagnostic] attribute namespace to influence compiler\nerror messages. These are treated as hints which the compiler is not required\nto use, and it is also not an error to provide a diagnostic that the compiler\ndoesn't recognize. This flexibility allows source code to provide diagnostics\neven when they're not supported by all compilers, whether those are different\nversions or entirely different implementations.\n\nWith this namespace comes the first supported attribute,\n#[diagnostic::on_unimplemented], which can be placed on a trait to customize\nthe message when that trait is required but hasn't been implemented on a type.\nConsider the example given in the stabilization pull request:\n\n    \n    \n    #[diagnostic::on_unimplemented( message = \"My Message for `ImportantTrait<{A}>` is not implemented for `{Self}`\", label = \"My Label\", note = \"Note 1\", note = \"Note 2\" )] trait ImportantTrait<A> {} fn use_my_trait(_: impl ImportantTrait<i32>) {} fn main() { use_my_trait(String::new()); }\n\nPreviously, the compiler would give a builtin error like this:\n\n    \n    \n    error[E0277]: the trait bound `String: ImportantTrait<i32>` is not satisfied --> src/main.rs:12:18 | 12 | use_my_trait(String::new()); | ------------ ^^^^^^^^^^^^^ the trait `ImportantTrait<i32>` is not implemented for `String` | | | required by a bound introduced by this call |\n\nWith #[diagnostic::on_unimplemented], its custom message fills the primary\nerror line, and its custom label is placed on the source output. The original\nlabel is still written as help output, and any custom notes are written as\nwell. (These exact details are subject to change.)\n\n    \n    \n    error[E0277]: My Message for `ImportantTrait<i32>` is not implemented for `String` --> src/main.rs:12:18 | 12 | use_my_trait(String::new()); | ------------ ^^^^^^^^^^^^^ My Label | | | required by a bound introduced by this call | = help: the trait `ImportantTrait<i32>` is not implemented for `String` = note: Note 1 = note: Note 2\n\nFor trait authors, this kind of diagnostic is more useful if you can provide a\nbetter hint than just talking about the missing implementation itself. For\nexample, this is an abridged sample from the standard library:\n\n    \n    \n    #[diagnostic::on_unimplemented( message = \"the size for values of type `{Self}` cannot be known at compilation time\", label = \"doesn't have a size known at compile-time\" )] pub trait Sized {}\n\nFor more information, see the reference section on the diagnostic tool\nattribute namespace.\n\n### Asserting unsafe preconditions\n\nThe Rust standard library has a number of assertions for the preconditions of\nunsafe functions, but historically they have only been enabled in\n#[cfg(debug_assertions)] builds of the standard library to avoid affecting\nrelease performance. However, since the standard library is usually compiled\nand distributed in release mode, most Rust developers weren't ever executing\nthese checks at all.\n\nNow, the condition for these assertions is delayed until code generation, so\nthey will be checked depending on the user's own setting for debug assertions\n-- enabled by default in debug and test builds. This change helps users catch\nundefined behavior in their code, though the details of how much is checked\nare generally not stable.\n\nFor example, slice::from_raw_parts requires an aligned non-null pointer. The\nfollowing use of a purposely-misaligned pointer has undefined behavior, and\nwhile if you were unlucky it may have appeared to \"work\" in the past, the\ndebug assertion can now catch it:\n\n    \n    \n    fn main() { let slice: &[u8] = &[1, 2, 3, 4, 5]; let ptr = slice.as_ptr(); // Create an offset from `ptr` that will always be one off from `u16`'s correct alignment let i = usize::from(ptr as usize & 1 == 0); let slice16: &[u16] = unsafe { std::slice::from_raw_parts(ptr.add(i).cast::<u16>(), 2) }; dbg!(slice16); }\n    \n    \n    thread 'main' panicked at library/core/src/panicking.rs:220:5: unsafe precondition(s) violated: slice::from_raw_parts requires the pointer to be aligned and non-null, and the total size of the slice not to exceed `isize::MAX` note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace thread caused non-unwinding panic. aborting.\n\n### Deterministic realignment\n\nThe standard library has a few functions that change the alignment of pointers\nand slices, but they previously had caveats that made them difficult to rely\non in practice, if you followed their documentation precisely. Those caveats\nprimarily existed as a hedge against const evaluation, but they're only stable\nfor non-const use anyway. They are now promised to have consistent runtime\nbehavior according to their actual inputs.\n\n  * pointer::align_offset computes the offset needed to change a pointer to the given alignment. It returns usize::MAX if that is not possible, but it was previously permitted to always return usize::MAX, and now that behavior is removed.\n\n  * slice::align_to and slice::align_to_mut both transmute slices to an aligned middle slice and the remaining unaligned head and tail slices. These methods now promise to return the largest possible middle part, rather than allowing the implementation to return something less optimal like returning everything as the head slice.\n\n### Stabilized APIs\n\n  * impl Read for &Stdin\n  * Accept non 'static lifetimes for several std::error::Error related implementations\n  * Make impl<Fd: AsFd> impl take ?Sized\n  * impl From<TryReserveError> for io::Error\n\nThese APIs are now stable in const contexts:\n\n  * Barrier::new()\n\n### Compatibility notes\n\n  * As previously announced, Rust 1.78 has increased its minimum requirement to Windows 10 for the following targets:\n\n    * x86_64-pc-windows-msvc\n    * i686-pc-windows-msvc\n    * x86_64-pc-windows-gnu\n    * i686-pc-windows-gnu\n    * x86_64-pc-windows-gnullvm\n    * i686-pc-windows-gnullvm\n  * Rust 1.78 has upgraded its bundled LLVM to version 18, completing the announced u128/i128 ABI change for x86-32 and x86-64 targets. Distributors that use their own LLVM older than 18 may still face the calling convention bugs mentioned in that post.\n\n### Other changes\n\nCheck out everything that changed in Rust, Cargo, and Clippy.\n\n## Contributors to 1.78.0\n\nMany people came together to create Rust 1.78.0. We couldn't have done it\nwithout all of you. Thanks!\n\n#### Get help!\n\n  * Documentation\n  * Contact the Rust Team\n\n#### Terms and policies\n\n  * Code of Conduct\n  * Licenses\n  * Logo Policy and Media Guide\n  * Security Disclosures\n  * All Policies\n\n#### Social\n\n#### RSS\n\n  * Main Blog\n  * \"Inside Rust\" Blog\n\nMaintained by the Rust Team. See a typo? Send a fix here!\n\n", "frontpage": false}
