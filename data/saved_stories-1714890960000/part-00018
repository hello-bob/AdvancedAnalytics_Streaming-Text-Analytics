{"aid": "40260972", "title": "Rust Apps on Ox64 BL808 RISC-V SBC and Apache NuttX RTOS", "url": "https://lupyuen.codeberg.page/articles/rust5.html", "domain": "codeberg.page", "votes": 2, "user": "lupyuen", "posted_at": "2024-05-04 22:56:28", "comments": 0, "source_title": "Rust Apps on Ox64 BL808 RISC-V SBC and Apache NuttX RTOS", "source_text": "Rust Apps on Ox64 BL808 RISC-V SBC and Apache NuttX RTOS\n\n# Rust Apps on Ox64 BL808 RISC-V SBC and Apache NuttX RTOS\n\n\ud83d\udcdd 5 May 2024\n\nThanks to cool-retro-term!\n\nWill Rust Apps run on a 64-bit RISC-V SBC? Like Ox64 BL808 SBC? (Pic below)\n\nLet\u2019s find out!\n\n  * We take a Barebones Rust App (\u201cHello World!\u201d)\n\n  * Compile it for QEMU RISC-V Emulator (64-bit)\n\n  * Run it on QEMU Emulator with Apache NuttX RTOS\n\n  * Do the same on Ox64 BL808 SBC (via MicroSD)\n\n  * We\u2019ll discuss the Quirky Workarounds\n\n  * Because NuttX Apps work differently in Kernel Mode vs Flat Mode\n\n# \u00a71 Rust App for NuttX\n\nBelow is the Simplest Rust App that will run on Apache NuttX RTOS.\n\nWe begin with the Rust Declarations: hello_rust_main.rs\n\n    \n    \n    // main() function not needed #![no_main] // Use Rust Core Library (instead of Rust Standard Library) #![no_std] // Import printf() from C into Rust extern \"C\" { pub fn printf( format: *const u8, // Equivalent to `const char *` ... // Optional Arguments ) -> i32; // Returns `int` } // TODO: Standardise `i32` as `c_int`\n\n(Why we use [no_std])\n\nThe code above imports the printf() function from C into Rust.\n\nThis is how we call it in Rust: hello_rust_main.rs\n\n    \n    \n    // Main Function exported by Rust to C. // Don't mangle the Function Name. #[no_mangle] pub extern \"C\" fn hello_rust_main( _argc: i32, // Equivalent to `int argc` _argv: *const *const u8 // Equivalent to `char **argv` ) -> i32 { // Returns `int` // Calling a C Function might have Unsafe consequences unsafe { printf( // Call printf() with... b\"Hello, Rust!!\\n\\0\" // Byte String terminated by null as *const u8 // Cast as `const char *` ); } // Exit with status 0 0 }\n\nRust expects us to provide a Panic Handler. We write a simple one:\nhello_rust_main.rs\n\n    \n    \n    // Import the Panic Info for our Panic Handler use core::panic::PanicInfo; // Handle a Rust Panic. Needed for [no_std] #[panic_handler] fn panic( _panic: &PanicInfo<'_> // Receives the Panic Info and Stack Trace ) -> ! { // Never returns // TODO: Print the Panic Info and Stack Trace // For now, we loop forever loop {} }\n\nThat\u2019s all for our barebones app! Now we compile it...\n\n# \u00a72 Compile for QEMU 64-bit RISC-V\n\nBefore testing on a Real RISC-V SBC, let\u2019s test on QEMU Emulator for RISC-V...\n\n  1. Follow these steps to build NuttX for QEMU Emulator (64-bit RISC-V)...\n\n\u201cBuild NuttX for QEMU\u201d\n\n  2. If we Enable Build Tracing: We\u2019ll see...\n    \n        ## Build NuttX with Tracing Enabled $ make --trace ## Compile \"hello_main.c\" with GCC Compiler riscv64-unknown-elf-gcc \\ -march=rv64imafdc \\ -mabi=lp64d \\ -c \\ -Dmain=hello_main \\ hello_main.c \\ -o hello_main.c...apps.examples.hello.o \\ ... ## Compile \"hello_rust_main.rs\" with Rust Compiler rustc \\ --target riscv64i-unknown-none-elf \\ --edition 2021 \\ --emit obj \\ -g \\ -C panic=abort \\ -O \\ hello_rust_main.rs \\ -o hello_rust_main.rs...apps.examples.hello_rust.o\n\n(See the Build Log)\n\n  3. If the Build Fails:\n\n\u201cCould not find specification for target riscv64i-unknown-none-elf\u201d\n\nThen our Rust Target is incorrect. We run this...\n\n    \n        ## Add the Rust Target for 64-bit RISC-V Hard-Float $ rustup target add riscv64gc-unknown-none-elf $ pushd ../apps/examples/hello_rust ## `$hello` becomes `hello_main.c...apps.examples.hello.o` ## `$hello_rust` becomes `hello_rust_main.rs...apps.examples.hello_rust.o` ## `$hello_rust_1` becomes `hello_rust_main.rs...apps.examples.hello_rust_1.o` $ hello=$(basename ../hello/*hello.o) $ hello_rust=` echo $hello \\ | sed \"s/hello_main.c/hello_rust_main.rs/\" \\ | sed \"s/hello.o/hello_rust.o/\" ` $ hello_rust_1=` echo $hello_rust \\ | sed \"s/hello_rust.o/hello_rust_1.o/\" ` ## Compile our Rust App for 64-bit RISC-V Hard-Float $ rustc \\ --target riscv64gc-unknown-none-elf \\ --edition 2021 \\ --emit obj \\ -g \\ -C panic=abort \\ -O \\ hello_rust_main.rs \\ -o $hello_rust $ cp $hello_rust $hello_rust_1 ## Return to NuttX Folder and complete the build $ popd $ make\n\n(We\u2019ll come back to this)\n\n  4. This produces the NuttX ELF Image nuttx that we\u2019ll boot on QEMU RISC-V Emulator.\n\n# \u00a73 Test on QEMU 64-bit RISC-V\n\nWe\u2019re ready to boot NuttX on QEMU Emulator and run our Rust App!\n\n  1. Download and install QEMU Emulator...\n    \n        ## For macOS: brew install qemu ## For Debian and Ubuntu: sudo apt install qemu-system-riscv64\n\n  2. Start the QEMU RISC-V Emulator (64-bit) with the NuttX ELF Image nuttx from the previous section...\n    \n        qemu-system-riscv64 \\ -semihosting \\ -M virt,aclint=on \\ -cpu rv64 \\ -smp 8 \\ -bios none \\ -kernel nuttx \\ -nographic\n\n  3. NuttX is now running in the QEMU Emulator! (Pic above)\n    \n        NuttShell (NSH) NuttX-12.4.0-RC0 nsh>\n\n  4. Enter \u201chello_rust\u201d to run our Rust Demo App (which will print something)\n    \n        nsh> hello_rust Hello, Rust!!\n\n(See the NuttX Log)\n\n  5. Enter \u201chelp\u201d to see the available commands...\n    \n        nsh> help help usage: help [-v] [<cmd>] . cp exit mkdir rmdir umount [ cmp expr mkrd set unset ? dirname false mount sleep uptime alias dd fdinfo mv source usleep unalias df free pidof test xd basename dmesg help printf time break echo hexdump ps true cat env kill pwd truncate cd exec ls rm uname Builtin Apps: hello hello_rust nsh ostest sh\n\n  6. To Exit QEMU: Press Ctrl-A then x\n\n# \u00a74 Rust Target is Incorrect\n\nEarlier we saw this error. Why did our Rust Build fail?\n\n    \n    \n    $ rustc hello_rust_main.rs --target riscv64i-unknown-none-elf ... Could not find specification for target \"riscv64i-unknown-none-elf\" Run `rustc --print target-list` for a list of built-in targets\n\n(See the Complete Log)\n\nRust Compiler doesn\u2019t recognise riscv64i as a valid Rust Target for 64-bit\nRISC-V...\n\n    \n    \n    ## List the Built-In Rust Targets for RISC-V $ rustup target list | grep riscv ## Nope no riscv64i! riscv32i-unknown-none-elf riscv32imac-unknown-none-elf riscv32imc-unknown-none-elf riscv64gc-unknown-linux-gnu riscv64gc-unknown-none-elf riscv64imac-unknown-none-elf\n\nIs riscv64i the correct target for QEMU?\n\nRemember earlier we saw GCC Compiler and Rust Compiler...\n\nGCC Compiler| Rust Compiler  \n---|---  \nriscv64-unknown-elf-gcc hello_main.c| rustc hello_rust_main.rs  \n-march rv64imafdc| \u2013target riscv64i-unknown-none-elf  \n-mabi lp64d  \n  \nFrom above we see that GCC Compiler uses Hardware Floating-Point, but Rust\nCompiler somehow selected Software Floating-Point! (Pic above)\n\nGCC Compiler| Rust Compiler  \n---|---  \nrv64imafdc| riscv64i  \n\\- I: Integer| \\- I: Integer  \n\\- F: Single Hard-Float| (Default is Soft-Float)  \n\\- D: Double Hard-Float| (Default is Soft-Float)  \n  \nLet\u2019s harmonise Rust Compiler with GCC Compiler: We select rv64gc, since it\u2019s\nclosest to Hardware Floating-Point...\n\n    \n    \n    ## Add the Rust Target for 64-bit RISC-V Hard-Float $ rustup target add riscv64gc-unknown-none-elf $ pushd ../apps/examples/hello_rust ## `$hello` becomes `hello_main.c...apps.examples.hello.o` ## `$hello_rust` becomes `hello_rust_main.rs...apps.examples.hello_rust.o` ## `$hello_rust_1` becomes `hello_rust_main.rs...apps.examples.hello_rust_1.o` $ hello=$(basename ../hello/*hello.o) $ hello_rust=` echo $hello \\ | sed \"s/hello_main.c/hello_rust_main.rs/\" \\ | sed \"s/hello.o/hello_rust.o/\" ` $ hello_rust_1=` echo $hello_rust \\ | sed \"s/hello_rust.o/hello_rust_1.o/\" ` ## Compile our Rust App for 64-bit RISC-V Hard-Float $ rustc \\ --target riscv64gc-unknown-none-elf \\ --edition 2021 \\ --emit obj \\ -g \\ -C panic=abort \\ -O \\ hello_rust_main.rs \\ -o $hello_rust $ cp $hello_rust $hello_rust_1 ## Return to NuttX Folder and complete the build $ popd $ make\n\n(See the Build Log)\n\nThis fixes our build. For now! (Pic below)\n\n(QEMU officially supports rv64gc)\n\n(\u201cgc\u201d in \u201crv64gc\u201d denotes IMAFDC)\n\n# \u00a75 Compile Rust App for Ox64 SBC\n\nOur Rust App runs OK on QEMU RISC-V. What about Ox64 BL808 SBC?\n\nLet\u2019s compile our Rust App for Ox64 BL808 RISC-V SBC (also 64-bit)...\n\n  1. Follow these steps to build NuttX for Ox64...\n\n\u201cBuild NuttX for Ox64 SBC\u201d\n\n  2. Remember to Rename the Main Function. Edit this file...\n    \n        apps/examples/hello_rust/hello_rust_main.rs\n\nLook for this line in hello_rust_main.rs...\n\n    \n        pub extern \"C\" fn hello_rust_main(...)\n\nAnd rename the function to...\n\n    \n        pub extern \"C\" fn main(...)\n\n(We\u2019ll see why)\n\n  3. If we Enable Build Tracing: We\u2019ll see...\n    \n        ## Build NuttX with Tracing Enabled $ make --trace import ## Compile \"hello_main.c\" with GCC Compiler riscv64-unknown-elf-gcc \\ -march=rv64imafdc \\ -mabi=lp64d \\ -c \\ hello_main.c \\ -o hello_main.c...apps.examples.hello.o \\ ... ## But \"hello_rust_main.rs\" won't get compiled by Rust Compiler!\n\n(See the Build Log)\n\n  4. If the Build Fails:\n\n\u201ctarget hello_rust_install does not exist\u201d\n\nThen our Makefile Target is missing. We run this...\n\n    \n        ## Assume the Current Folder is NuttX Apps Folder. ## Add the Rust Target for 64-bit RISC-V Hard-Float $ rustup target add riscv64gc-unknown-none-elf $ pushd ../apps/examples/hello_rust ## `$hello` becomes `hello_main.c...apps.examples.hello.o` ## `$hello_rust` becomes `hello_rust_main.rs...apps.examples.hello_rust.o` $ hello=$(basename ../hello/*hello.o) $ hello_rust=` echo $hello \\ | sed \"s/hello_main.c/hello_rust_main.rs/\" \\ | sed \"s/hello.o/hello_rust.o/\" ` ## Compile our Rust App for 64-bit RISC-V Hard-Float $ rustc \\ --target riscv64gc-unknown-none-elf \\ --edition 2021 \\ --emit obj \\ -g \\ -C panic=abort \\ -O \\ hello_rust_main.rs \\ -o $hello_rust ## Return to NuttX Apps Folder and build the NuttX Apps $ popd $ make import\n\n(We\u2019ll come back to this)\n\n  5. Complete the NuttX Build according to the instructions here.\n\nThis produces Image, containing the NuttX Kernel + NuttX Apps. Which we\u2019ll\nboot on Ox64 SBC.\n\n# \u00a76 Run Rust App on Ox64 SBC\n\nFollow these steps to boot NuttX on Ox64 SBC and run our Rust App...\n\n  1. Flash OpenSBI and U-Boot Bootloader to Ox64\n\n  2. Prepare a Linux microSD for Ox64 as described in the previous article\n\n  3. Copy the Image file from the previous section.\n\nOverwrite the Image in the Linux microSD.\n\n  4. Insert the microSD into Ox64 and power up Ox64\n\n  5. NuttX is now running on Ox64 SBC! (Pic above)\n    \n        NuttShell (NSH) NuttX-12.4.0-RC0 nsh>\n\n  6. Enter \u201chello_rust\u201d to run our Rust Demo App (which will print something)\n    \n        nsh> hello_rust Hello, Rust!!\n\nYep our Rust App works great on Ox64 BL808 RISC-V SBC!\n\n(See the NuttX Log)\n\n  7. If we don\u2019t have an Ox64 SBC: The Ox64 Emulator works OK too...\n\n\u201cRun NuttX on Ox64 Emulator\u201d\n\n# \u00a77 NuttX Flat Mode vs Kernel Mode\n\nWhy the funny fixes for NuttX Ox64?\n\nEarlier we saw 2 workarounds for our Ox64 NuttX Build...\n\n  1. We renamed the Main Function\n\n  2. We fixed the Makefile Target\n\nThat\u2019s because Ox64 Apps are a little more complicated than QEMU Apps...\n\nNuttX QEMU runs in Flat Mode (pic above)\n\n  * NuttX Apps are Statically Linked into NuttX Kernel\n\n  * Main Functions for Apps are named hello_main(), hello_rust_main(), ...\n\n  * No Memory Protection between Apps and Kernel\n\n  * Everything runs in RISC-V Machine Mode\n\n  * A little easier to troubleshoot\n\nNuttX Ox64 runs in Kernel Mode (pic below)\n\n  * NuttX Apps are Separate ELF Files\n\n  * Main Functions for Apps are all named main()\n\n  * Apps and Kernel live in Protected Memory Regions\n\n  * Kernel runs in RISC-V Supervisor Mode\n\n  * Apps run in RISC-V User Mode\n\n  * More realistic for Actual Hardware\n\n(More about NuttX Apps in Kernel Mode)\n\nThat\u2019s why the Rust Build for Ox64 (Kernel Mode) is more complex than QEMU\n(Flat Mode). We\u2019ll fix these issues in Google Summer of Code!\n\n  * \u201cMain Function is Missing\u201d\n\n  * \u201cMakefile Target is Missing\u201d\n\nWhat about Complex Rust Apps? Will they run on Ox64 SBC?\n\nWe\u2019ll do an LED Blinky App in Rust. Also in Google Summer of Code!\n\nCan we run NuttX QEMU in Kernel Mode?\n\nYep we can switch \u201crv-virt:nsh64\u201d to \u201crv-virt:knsh64\u201d. Like this...\n\n    \n    \n    ## Download NuttX git clone https://github.com/apache/nuttx nuttx git clone https://github.com/apache/nuttx-apps apps ## Configure NuttX for Kernel Mode (instead of Flat Mode) cd nuttx ./tools/configure.sh rv-virt:knsh64 ## Build the NuttX Kernel make make export ## Build the NuttX Apps pushd ../apps ./tools/mkimport.sh -z -x ../nuttx/nuttx-export-*.tar.gz make import popd ## Boot NuttX in Kernel Mode (instead of Flat Mode) qemu-system-riscv64 \\ -nographic -semihosting \\ -M virt,aclint=on \\ -cpu rv64 -kernel nuttx\n\n# \u00a78 What\u2019s Next\n\nYes indeed, Rust Apps will run hunky dory on a 64-bit RISC-V SBC. Like Ox64\nBL808 SBC!\n\n  * We took a Barebones Rust App (\u201cHello World!\u201d)\n\n  * Compiled it for QEMU RISC-V Emulator (64-bit)\n\n  * Ran it on QEMU Emulator with Apache NuttX RTOS\n\n  * We did the same on Ox64 BL808 SBC (via MicroSD)\n\n  * Though we used some Quirky Workarounds\n\n  * Because NuttX Apps work differently in Kernel Mode vs Flat Mode\n\n  * We\u2019ll see more Rust Apps on RISC-V, for Google Summer of Code!\n\nMany Thanks to my GitHub Sponsors (and the awesome NuttX Community) for\nsupporting my work! This article wouldn\u2019t have been possible without your\nsupport.\n\n  * Sponsor me a coffee\n\n  * Discuss this article on Hacker News\n\n  * My Current Project: \u201cApache NuttX RTOS for Ox64 BL808\u201d\n\n  * My Other Project: \u201cNuttX for Star64 JH7110\u201d\n\n  * Older Project: \u201cNuttX for PinePhone\u201d\n\n  * Check out my articles\n\n  * RSS Feed\n\nGot a question, comment or suggestion? Create an Issue or submit a Pull\nRequest here...\n\nlupyuen.github.io/src/rust5.md\n\n# \u00a79 Appendix: Build NuttX for QEMU\n\nFollow these steps to build NuttX for QEMU Emulator (64-bit RISC-V)...\n\n  1. Install the Build Prerequisites, skip the RISC-V Toolchain...\n\n\u201cInstall Prerequisites\u201d\n\n  2. Download the RISC-V Toolchain for riscv64-unknown-elf...\n\n\u201cDownload Toolchain for 64-bit RISC-V\u201d\n\n  3. Download and configure NuttX for QEMU RISC-V 64-bit...\n    \n        mkdir nuttx cd nuttx git clone https://github.com/apache/nuttx nuttx git clone https://github.com/apache/nuttx-apps apps cd nuttx tools/configure.sh rv-virt:nsh64 make menuconfig\n\n  4. In menuconfig, browse to \u201cDevice Drivers > System Logging\u201d\n\nDisable this option...\n\n    \n        Prepend Timestamp to Syslog Message\n\n  5. Browse to \u201cBuild Setup > Debug Options\u201d\n\nSelect the following options...\n\n    \n        Enable Debug Features Enable Error Output Enable Warnings Output Enable Informational Debug Output Enable Debug Assertions Enable Debug Assertions Show Expression Scheduler Debug Features Scheduler Error Output Scheduler Warnings Output Scheduler Informational Output\n\n  6. Browse to \u201cApplication Configuration > Examples\u201d\n\nSelect \u201cHello Rust Example\u201d\n\nSelect it Twice so that \u201c<M>\u201d changes to \u201c<*>\u201d\n\n(Source Code for Hello Rust)\n\n  7. Save and exit menuconfig.\n\n(See the NuttX Config)\n\n  8. Build the NuttX Project and dump the RISC-V Disassembly to nuttx.S (for easier troubleshooting)...\n    \n        ## Add the Rust Target for RISC-V 64-bit (Hard-Float) rustup target add riscv64gc-unknown-none-elf ## Build the NuttX Project make ## Dump the NuttX Disassembly to `nuttx.S` riscv64-unknown-elf-objdump \\ -t -S --demangle --line-numbers --wide \\ nuttx \\ >nuttx.S \\ 2>&1\n\n(See the Build Log)\n\n  9. If the Build Fails:\n\n\u201cCould not find specification for target riscv64i-unknown-none-elf\u201d\n\nThen our Rust Target is incorrect. We fix it like this...\n\n\u201cRust Target is Incorrect\u201d\n\n(See the Build Log)\n\n  10. This produces the NuttX ELF Image nuttx that we may boot on QEMU RISC-V Emulator...\n\n\u201cTest on QEMU 64-bit RISC-V\u201d\n\n# \u00a710 Appendix: Build NuttX for Ox64 SBC\n\nFollow these steps to build NuttX for Ox64 BL808 SBC...\n\n  1. Install the Build Prerequisites, skip the RISC-V Toolchain...\n\n\u201cInstall Prerequisites\u201d\n\n  2. Download the RISC-V Toolchain for riscv64-unknown-elf...\n\n\u201cDownload Toolchain for 64-bit RISC-V\u201d\n\n  3. Download and configure NuttX for Ox64 BL808 SBC...\n    \n        mkdir nuttx cd nuttx git clone https://github.com/apache/nuttx nuttx git clone https://github.com/apache/nuttx-apps apps cd nuttx tools/configure.sh ox64:nsh make menuconfig\n\n  4. In menuconfig, browse to \u201cDevice Drivers > System Logging\u201d\n\nDisable this option...\n\n    \n        Prepend Timestamp to Syslog Message\n\n  5. Browse to \u201cBuild Setup > Debug Options\u201d\n\nSelect the following options...\n\n    \n        Enable Debug Features Enable Error Output Enable Warnings Output Enable Informational Debug Output Enable Debug Assertions Enable Debug Assertions Show Expression Scheduler Debug Features Scheduler Error Output Scheduler Warnings Output Scheduler Informational Output\n\n  6. Browse to \u201cApplication Configuration > Examples\u201d\n\nSelect \u201cHello Rust Example\u201d\n\nSelect it Twice so that \u201c<M>\u201d changes to \u201c<*>\u201d\n\n(Source Code for Hello Rust)\n\n  7. Save and exit menuconfig.\n\n(See the NuttX Config)\n\n  8. Rename the Main Function of our Rust App...\n\n\u201cMain Function is Missing\u201d\n\n  9. Build the NuttX Project...\n    \n        ## Add the Rust Target for RISC-V 64-bit (Hard-Float) rustup target add riscv64gc-unknown-none-elf ## Build the NuttX Project make ## Export the NuttX Kernel ## to `nuttx.bin` riscv64-unknown-elf-objcopy \\ -O binary \\ nuttx \\ nuttx.bin ## Dump the disassembly to nuttx.S riscv64-unknown-elf-objdump \\ --syms --source --reloc --demangle --line-numbers --wide \\ --debugging \\ nuttx \\ >nuttx.S \\ 2>&1\n\n(See the Build Log)\n\n  10. Export the NuttX Kernel Interface...\n    \n        ## Export the NuttX Kernel Interface make -j 8 export pushd ../apps ./tools/mkimport.sh -z -x ../nuttx/nuttx-export-*.tar.gz\n\n(See the Build Log)\n\n  11. Build the NuttX Apps...\n    \n        ## Build the NuttX Apps make -j 8 import\n\n(See the Build Log)\n\n  12. If the Build Fails:\n\n\u201ctarget hello_rust_install does not exist\u201d\n\nThen our Makefile Target is missing. We fix it like this...\n\n\u201cMakefile Target is Missing\u201d\n\n(See the Build Log)\n\n  13. Complete the NuttX Build...\n    \n        ## Return to the NuttX Folder popd ## Generate the Initial RAM Disk `initrd` ## in ROMFS Filesystem Format ## from the Apps Filesystem `../apps/bin` ## and label it `NuttXBootVol` genromfs \\ -f initrd \\ -d ../apps/bin \\ -V \"NuttXBootVol\" ## Prepare a Padding with 64 KB of zeroes head -c 65536 /dev/zero >/tmp/nuttx.pad ## Append Padding and Initial RAM Disk to NuttX Kernel cat nuttx.bin /tmp/nuttx.pad initrd \\ >Image\n\n  14. This produces the NuttX Image for Ox64: Image\n\nCopy it to MicroSD and boot on Ox64 SBC...\n\n\u201cRun Rust App on Ox64 SBC\u201d\n\nOr run it on Ox64 Emulator...\n\n\u201cRun NuttX on Ox64 Emulator\u201d\n\n# \u00a711 Appendix: Run NuttX on Ox64 Emulator\n\nEarlier we compiled NuttX for Ox64...\n\n  * \u201cBuild NuttX for Ox64 SBC\u201d\n\nThis is how we boot NuttX and test our Rust App on Ox64 BL808 Emulator...\n\n    \n    \n    ## Build Ox64 Emulator ## https://github.com/lupyuen/nuttx-ox64/blob/main/.github/workflows/ox64-test.yml $ sudo apt -y install \\ expect libcurl4-openssl-dev libssl-dev zlib1g-dev libsdl2-dev wget $ git clone https://github.com/lupyuen/ox64-tinyemu $ pushd ox64-tinyemu $ make $ cp temu .. $ popd ## Run Ox64 Emulator. Assume `Image` is in the Curent Folder. $ wget https://github.com/lupyuen/nuttx-ox64/raw/main/nuttx.cfg $ ./temu nuttx.cfg TinyEMU Emulator for Ox64 BL808 RISC-V SBC NuttShell (NSH) NuttX-12.4.0-RC0 nsh> hello_rust Hello, Rust!!\n\n(nuttx.cfg is here)\n\n(See the Complete Log)\n\n# \u00a712 Appendix: Main Function is Missing\n\nWhy did we rename the Main Function?\n\nEarlier we modified this file...\n\n    \n    \n    apps/examples/hello_rust/hello_rust_main.rs\n\nBy changing this line in hello_rust_main.rs...\n\n    \n    \n    pub extern \"C\" fn hello_rust_main(...)\n\nTo this...\n\n    \n    \n    pub extern \"C\" fn main(...)\n\nBut why? Watch what happens if we don\u2019t rename the Main Function. Let\u2019s test\nwith Ox64 BL808 Emulator...\n\n    \n    \n    ## Omitted: Build Ox64 Emulator ## https://lupyuen.codeberg.page/articles/rust5#appendix-run-nuttx-on-ox64-emulator ## Run Ox64 Emulator. Assume `Image` is in the Curent Folder. $ wget https://github.com/lupyuen/nuttx-ox64/raw/main/nuttx.cfg $ ./temu nuttx.cfg TinyEMU Emulator for Ox64 BL808 RISC-V SBC NuttShell (NSH) NuttX-12.4.0-RC0 nsh> hello_rust nsh: hello_rust: command not found\n\n(nuttx.cfg is here)\n\nHuh? Why is hello_rust not found?\n\nTo find out, we Enable Logging for Binary Loader and Scheduler...\n\n    \n    \n    ## Enable Logging for Binary Loader and Scheduler CONFIG_DEBUG_BINFMT=y CONFIG_DEBUG_BINFMT_ERROR=y CONFIG_DEBUG_BINFMT_WARN=y CONFIG_DEBUG_SCHED=y CONFIG_DEBUG_SCHED_ERROR=y CONFIG_DEBUG_SCHED_INFO=y CONFIG_DEBUG_SCHED_WARN=y\n\nNow it tells us why it failed...\n\n    \n    \n    ## Run Ox64 Emulator. Assume `Image` is in the Curent Folder. $ wget https://github.com/lupyuen/nuttx-ox64/raw/main/nuttx.cfg $ ./temu nuttx.cfg TinyEMU Emulator for Ox64 BL808 RISC-V SBC NuttShell (NSH) NuttX-12.4.0-RC0 nsh> hello_rust elf_symvalue: SHN_UNDEF: Exported symbol \"main\" not found exec_internal: ERROR: Failed to load program 'hello_rust': -2 nsh: hello_rust: command not found\n\n(See the Complete Log)\n\nIt failed because the main() function is missing!\n\nAs explained earlier: NuttX Apps for Ox64 are more complex (than QEMU) because\nthey are compiled as Separate ELF Files...\n\n  * \u201cNuttX Flat Mode vs Kernel Mode\u201d\n\nSomehow the NuttX Makefiles won\u2019t emit the correct Main Function for Rust ELF\nFiles. Thus we edit this file...\n\n    \n    \n    apps/examples/hello_rust/hello_rust_main.rs\n\nChange this line in hello_rust_main.rs...\n\n    \n    \n    pub extern \"C\" fn hello_rust_main(...)\n\nTo this...\n\n    \n    \n    pub extern \"C\" fn main(...)\n\nThen we rebuild NuttX. And it works!\n\n    \n    \n    NuttShell (NSH) NuttX-12.4.0-RC0 nsh> hello_rust Hello, Rust!!\n\nWon\u2019t Flat Mode have the same Main Function problem as Kernel Mode?\n\nRemember earlier we saw this...\n\n    \n    \n    ## Build NuttX with Tracing Enabled $ make --trace ## Compile \"hello_main.c\" with GCC Compiler riscv64-unknown-elf-gcc \\ -march=rv64imafdc \\ -mabi=lp64d \\ -c \\ -Dmain=hello_main \\ hello_main.c \\ -o hello_main.c...apps.examples.hello.o \\ ...\n\nWhich works because GCC Compiler renames the Main Function:\n\u201c-Dmain=hello_main\u201d\n\nSadly we can\u2019t do this in Rust. We\u2019ll seek a solution in Google Summer of\nCode!\n\n# \u00a713 Appendix: Makefile Target is Missing\n\nWhy is the Makefile Target missing for Ox64?\n\n    \n    \n    $ make import Makefile:52: target 'apps/examples/hello_rust_install' does not exist make[3]: *** No rule to make target 'hello_rust_main.rs...apps.examples.hello_rust.o', needed by 'apps/bin/hello_rust'. Stop.\n\n(See the Complete Log)\n\nAs explained earlier: NuttX Apps for Ox64 are more complex (than QEMU) because\nthey are compiled as Separate ELF Files...\n\n  * \u201cNuttX Flat Mode vs Kernel Mode\u201d\n\nSomehow the NuttX Makefiles won\u2019t produce Rust ELF Files correctly. Thus we\nbuild ourselves...\n\n    \n    \n    ## Assume the Current Folder is NuttX Apps Folder. ## Add the Rust Target for 64-bit RISC-V Hard-Float $ rustup target add riscv64gc-unknown-none-elf $ pushd ../apps/examples/hello_rust ## `$hello` becomes `hello_main.c...apps.examples.hello.o` ## `$hello_rust` becomes `hello_rust_main.rs...apps.examples.hello_rust.o` $ hello=$(basename ../hello/*hello.o) $ hello_rust=` echo $hello \\ | sed \"s/hello_main.c/hello_rust_main.rs/\" \\ | sed \"s/hello.o/hello_rust.o/\" ` ## Compile our Rust App for 64-bit RISC-V Hard-Float $ rustc \\ --target riscv64gc-unknown-none-elf \\ --edition 2021 \\ --emit obj \\ -g \\ -C panic=abort \\ -O \\ hello_rust_main.rs \\ -o $hello_rust ## Return to NuttX Apps Folder and build the NuttX Apps $ popd $ make import\n\n(See the Build Log)\n\nComplete the NuttX Build according to the instructions here.\n\nThis produces Image, containing the NuttX Kernel + NuttX Apps. Which we\u2019ll\nboot on Ox64 SBC...\n\n  * \u201cRun Rust App on Ox64 SBC\u201d\n\nOr run on Ox64 Emulator...\n\n  * \u201cRun NuttX on Ox64 Emulator\u201d\n\n", "frontpage": false}
