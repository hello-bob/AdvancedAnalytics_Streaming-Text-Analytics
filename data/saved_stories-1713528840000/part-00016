{"aid": "40082520", "title": "The Windows Registry Adventure", "url": "https://googleprojectzero.blogspot.com/2024/04/the-windows-registry-adventure-1.html", "domain": "googleprojectzero.blogspot.com", "votes": 1, "user": "ShadowRegent", "posted_at": "2024-04-19 01:21:03", "comments": 0, "source_title": "The Windows Registry Adventure #1: Introduction and research results", "source_text": "Project Zero: The Windows Registry Adventure #1: Introduction and research\nresults\n\n# Project Zero\n\nNews and updates from the Project Zero team at Google\n\n## Thursday, April 18, 2024\n\n### The Windows Registry Adventure #1: Introduction and research results\n\nPosted by Mateusz Jurczyk, Google Project Zero\n\nIn the 20-month period between May 2022 and December 2023, I thoroughly\naudited the Windows Registry in search of local privilege escalation bugs. It\nall started unexpectedly: I was in the process of developing a coverage-based\nWindows kernel fuzzer based on the Bochs x86 emulator (one of my favorite\ntools for security research: see Bochspwn, Bochspwn Reloaded, and my earlier\nfont fuzzing infrastructure), and needed some binary formats to test it on. My\nfirst pick were PE files: they are very popular in the Windows environment,\nwhich makes it easy to create an initial corpus of input samples, and a basic\nfuzzing harness is equally easy to develop with just a single\nGetFileVersionInfoSizeW API call. The test was successful: even though I had\npreviously fuzzed PE files in 2019, the new element of code coverage guidance\nallowed me to discover a completely new bug: issue #2281.\n\nFor my next target, I chose the Windows registry. That's because arbitrary\nregistry hives can be loaded from disk without any special privileges via the\nRegLoadAppKey API (since Windows Vista). The hives use a binary format and are\nfully parsed in the kernel, making them a noteworthy local attack surface.\nFurthermore, I was also somewhat familiar with basic harnessing of the\nregistry, having fuzzed it in 2016 together with James Forshaw. Once again,\nthe code coverage support proved useful, leading to the discovery of issue\n#2299. But when I started to perform a root cause analysis of the bug, I\nrealized that:\n\n  * The hive binary format is not very well suited for trivial bitflipping-style fuzzing, because it is structurally simple, and random mutations are much more likely to render (parts of) the hive unusable than to trigger any interesting memory safety violations.\n  * On the other hand, the registry has many properties that make it an attractive attack surface for further research, especially for manual review. It is 30+ years old, written in C, running in kernel space but highly accessible from user-mode, and it implements much more complex logic than I had previously imagined.\n\nAnd that's how the story starts. Instead of further refining the fuzzer, I\nmade a detour to reverse engineer the registry implementation in the Windows\nkernel (internally known as the Configuration Manager) and learn more about\nits inner workings. The more I learned, the more hooked I became, and before\nlong, I was all-in on a journey to audit as much of the registry code as\npossible. This series of blog posts is meant to document what I've learned\nabout the registry, including its basic functionality, advanced features,\nsecurity properties, typical bug classes, case studies of specific\nvulnerabilities, and exploitation techniques.\n\nWhile this blog is one of the first places to announce this effort, I did\nalready give a talk titled \"Exploring the Windows Registry as a powerful LPE\nattack surface\" at Microsoft BlueHat Redmond in October 2023 (see slides and\nvideo recording). The upcoming blog posts will go into much deeper detail than\nthe presentation, but if you're particularly curious and can't wait to find\nout more, feel free to check these resources as a starter. \ud83d\ude42\n\n## Research results\n\nIn the course of the research, I filed 39 bug reports in the Project Zero bug\ntracker, which have been fixed by Microsoft as 44 CVEs. There are a few\nreasons for the discrepancy between these numbers:\n\n  * Some single reports included information about multiple problems, e.g. issue #2375 was addressed by four CVEs,\n  * Some groups of reports were fixed with a single patch, e.g. issues #2392 and #2408 as CVE-2023-23420,\n  * One bug report was closed as WontFix and not addressed in a security bulletin at all (issue #2508).\n\nAll of the reports were submitted under the Project Zero 90-day disclosure\ndeadline policy, and Microsoft successfully met the deadline in all cases. The\naverage time from report to fix was 81 days.\n\nFurthermore, between November 2023 and January 2024, I reported 20 issues that\nhad low or unclear security impact, but I believed the vendor should\nnevertheless be made aware of them. They were sent without a disclosure\ndeadline and weren't put on the PZ tracker; I have since published them on our\nteam's GitHub. Upon assessment, Microsoft decided to fix 6 of them in a\nsecurity bulletin in March 2024, while the other 14 were closed as WontFix\nwith the option of being addressed in a future version of Windows.\n\nThis sums up to a total of 50 CVEs, classified by Microsoft as:\n\n  * 39 \u00d7 Windows Kernel Elevation of Privilege Vulnerability\n  * 9 \u00d7 Windows Kernel Information Disclosure Vulnerability\n  * 1 \u00d7 Windows Kernel Memory Information Disclosure Vulnerability\n  * 1 \u00d7 Windows Kernel Denial of Service Vulnerability\n\nA full summary of the security-serviced bugs is shown below:\n\nGPZ #| CVE| Title| Reported| Fixed  \n---|---|---|---|---  \n2295| CVE-2022-34707| Windows Kernel use-after-free due to refcount overflow\nin registry hive security descriptors| 2022-May-11| 2022-Aug-09  \n2297| CVE-2022-34708| Windows Kernel invalid read/write due to unchecked Blink\ncell index in root security descriptor| 2022-May-17  \n2299| CVE-2022-35768| Windows Kernel multiple memory problems when handling\nincorrectly formatted security descriptors in registry hives| 2022-May-20  \n2318| CVE-2022-37956| Windows Kernel integer overflows in registry subkey\nlists leading to memory corruption| 2022-Jun-22| 2022-Sep-13  \n2330| CVE-2022-37988| Windows Kernel registry use-after-free due to bad\nhandling of failed reallocations under memory pressure| 2022-Jul-8|\n2022-Oct-11  \n2332| CVE-2022-38037| Windows Kernel memory corruption due to type confusion\nof subkey index leaves in registry hives| 2022-Jul-11  \n2341| CVE-2022-37990| Windows Kernel multiple memory corruption issues when\noperating on very long registry paths| 2022-Aug-3  \nCVE-2022-38039  \nCVE-2022-38038  \n2344| CVE-2022-37991| Windows Kernel out-of-bounds reads and other issues when\noperating on long registry key and value names| 2022-Aug-5  \n2359| CVE-2022-44683| Windows Kernel use-after-free due to bad handling of\npredefined keys in NtNotifyChangeMultipleKeys| 2022-Sep-22| 2022-Dec-13  \n2366| CVE-2023-21675| Windows Kernel memory corruption due to insufficient\nhandling of predefined keys in registry virtualization| 2022-Oct-6|\n2023-Jan-10  \n2369| CVE-2023-21747| Windows Kernel use-after-free due to dangling registry\nlink node under paged pool memory pressure| 2022-Oct-13  \n2389| CVE-2023-21748| Windows Kernel registry virtualization incompatible with\ntransactions, leading to inconsistent hive state and memory corruption|\n2022-Nov-30  \n2375| Windows Kernel multiple issues in the key replication feature of\nregistry virtualization| 2022-Oct-25  \nCVE-2023-21772  \nCVE-2023-21773  \nCVE-2023-21774  \n2378| CVE-2023-21749| Windows Kernel registry SID table poisoning leading to\nbad locking and other issues| 2022-Oct-31  \nCVE-2023-21776  \n2379| CVE-2023-21750| Windows Kernel allows deletion of keys in virtualizable\nhives with KEY_READ and KEY_SET_VALUE access rights| 2022-Nov-2  \n2392| CVE-2023-23420| Windows Kernel multiple issues with subkeys of\ntransactionally renamed registry keys| 2022-Dec-7| 2023-Mar-14  \n2408| Windows Kernel insufficient validation of new registry key names in\ntransacted NtRenameKey| 2023-Jan-13  \n2394| CVE-2023-23421| Windows Kernel multiple issues in the prepare/commit\nphase of a transactional registry key rename| 2022-Dec-14  \nCVE-2023-23422  \nCVE-2023-23423  \n2410| CVE-2023-28248| Windows Kernel CmpCleanupLightWeightPrepare registry\nsecurity descriptor refcount leak leading to UAF| 2023-Jan-19| 2023-Apr-11  \n2418| CVE-2023-28271| Windows Kernel disclosure of kernel pointers and\nuninitialized memory through registry KTM transaction log files| 2023-Jan-31  \n2419| CVE-2023-28272| Windows Kernel out-of-bounds reads when operating on\ninvalid registry paths in CmpDoReDoCreateKey/CmpDoReOpenTransKey| 2023-Feb-2  \nCVE-2023-28293  \n2433| CVE-2023-32019| Windows Kernel KTM registry transactions may have non-\natomic outcomes| 2023-Mar-7| 2023-Jun-13  \n2445| CVE-2023-35356| Windows Kernel arbitrary read by accessing predefined\nkeys through differencing hives| 2023-Apr-19| 2023-Jul-11  \n2452| Windows Kernel CmDeleteLayeredKey may delete predefined tombstone keys,\nleading to security descriptor UAF| 2023-May-10  \n2446| CVE-2023-35357| Windows Kernel may reference unbacked layered keys\nthrough registry virtualization| 2023-Apr-20  \n2447| CVE-2023-35358| Windows Kernel may reference rolled-back transacted keys\nthrough differencing hives| 2023-Apr-27  \n2449| CVE-2023-35382| Windows Kernel renaming layered keys doesn't reference\ncount security descriptors, leading to UAF| 2023-May-2| 2023-Aug-8  \n2454| CVE-2023-35386| Windows Kernel out-of-bounds reads due to an integer\noverflow in registry .LOG file parsing| 2023-May-15  \n2456| CVE-2023-38154| Windows Kernel partial success of registry hive log\nrecovery may lead to inconsistent state and memory corruption| 2023-May-22  \n2457| CVE-2023-38139| Windows Kernel doesn't reset security cache during self-\nhealing, leading to refcount overflow and UAF| 2023-May-31| 2023-Sep-12  \n2462| CVE-2023-38141| Windows Kernel passes user-mode pointers to registry\ncallbacks, leading to race conditions and memory corruption| 2023-Jun-26  \n2463| CVE-2023-38140| Windows Kernel paged pool memory disclosure in\nVrpPostEnumerateKey| 2023-Jun-27  \n2464| CVE-2023-36803| Windows Kernel out-of-bounds reads and paged pool memory\ndisclosure in VrpUpdateKeyInformation| 2023-Jun-27  \n2466| CVE-2023-36576| Windows Kernel containerized registry escape through\ninteger overflows in VrpBuildKeyPath and other weaknesses| 2023-Jul-7|\n2023-Oct-10  \n2479| CVE-2023-36404| Windows Kernel time-of-check/time-of-use issue in\nverifying layered key security may lead to information disclosure from\nprivileged registry keys| 2023-Aug-10| 2023-Nov-14  \n2480| CVE-2023-36403| Windows Kernel bad locking in registry virtualization\nleads to race conditions| 2023-Aug-22  \n2492| CVE-2023-35633| Windows registry predefined keys may lead to confused\ndeputy problems and local privilege escalation| 2023-Oct-6| 2023-Dec-12  \n2511| CVE-2024-26182| Windows Kernel subkey list use-after-free due to\nmishandling of partial success in CmpAddSubKeyEx| 2023-Dec-13| 2024-Mar-12  \nNone (MSRC-84131)| CVE-2024-26174| Windows Kernel out-of-bounds read of key\nnode security in CmpValidateHiveSecurityDescriptors when loading corrupted\nhives| 2023-Nov-29  \nNone (MSRC-84149)| CVE-2024-26176| Windows Kernel out-of-bounds read when\nvalidating symbolic links in CmpCheckValueList| 2023-Nov-29  \nNone (MSRC-84046)| CVE-2024-26173| Windows Kernel allows the creation of\nstable subkeys under volatile keys via registry transactions| 2023-Nov-30  \nNone (MSRC-84228)| CVE-2024-26177| Windows Kernel unsafe behavior in\nCmpUndoDeleteKeyForTrans when transactionally re-creating registry keys|\n2023-Dec-1  \nNone (MSRC-84237)| CVE-2024-26178| Windows Kernel security descriptor linked\nlist confusion in CmpLightWeightPrepareSetSecDescUoW| 2023-Dec-1  \nNone (MSRC-84263)| CVE-2024-26181| Windows Kernel registry quota exhaustion\nmay lead to permanent corruption of the SAM database| 2023-Dec-11  \n  \n## Exploitability\n\nSoftware bugs are typically only interesting to either the offensive/defensive\nsides of the security community if they have practical security implications.\nUnfortunately, it is impossible to give a blanket statement regarding the\nexploitability of all registry-related vulnerabilities due to their sheer\ndiversity on a number of levels:\n\n  * Affected platforms: Windows 10, Windows 11, various Windows Server versions (32/64-bit)\n  * Attack targets: the kernel itself, drivers implementing registry callbacks, privileged user-mode applications/services\n  * Entry points: direct registry operations, hive loading, transaction log recovery\n  * End results: memory corruption, broken security guarantees, broken API contracts, memory/pointer disclosure, out-of-bounds reads, invalid/controlled cell index accesses\n  * Root cause of issues: C-specific, logic errors, bad reference counting, locking problems\n  * Nature of memory corruption: temporal (use-after-free), spatial (buffer overflows)\n  * Types of corrupted memory: kernel pools, hive data\n  * Exploitation time: instant, up to several hours\n\nAs we can see, there are multiple factors at play that determine how the bugs\ncame to be and what state they leave the system in after being triggered.\nHowever, to get a better understanding of the impact of the findings, I have\nperformed a cursory analysis of the exploitability of each bug, trying to\nclassify it as either \"easy\", \"moderate\" or \"hard\" to exploit according to my\ncurrent knowledge and experience (this is of course highly subjective). The\nproportions of these exploitability ratings are shown in the chart below:\n\nThe ratings were largely based on the following considerations:\n\n  * Hive-based memory corruption is generally considered easy to exploit, while pool-based memory corruption is considered moderate/hard depending on the specifics of the bug.\n  * Triggering OOM-type conditions in the hive space is easy, but completely exhausting the kernel pools is more difficult and intrusive.\n  * Logic bugs are typically easier and more reliable to exploit than memory corruption.\n  * The kernel itself is typically easier to attack than other user-mode processes (system services etc.).\n  * Direct information disclosure (leaking kernel pointers / uninitialized memory via various channels) is usually straightforward to exploit.\n  * However, random out-of-bounds reads, as well as read access to invalid/controlled cell indexes is generally hard to do anything useful with.\n\nOverall, it seems that more than half of the findings can be feasibly\nexploited for information disclosure or local privilege escalation (rated easy\nor moderate). What is more, many of them exhibit registry-specific bug classes\nwhich can enable particularly unique exploitation primitives. For example,\nhive-based memory corruption can be effectively transformed into both a KASLR\nbypass and a fully reliable arbitrary read/write capability, making it\npossible to use a single bug to compromise the kernel with a data-only attack.\nTo demonstrate this, I have successfully developed exploits for CVE-2022-34707\nand CVE-2023-23420. The outcome of running one of them to elevate privileges\nto SYSTEM on Windows 11 is shown on the screenshot below:\n\nUpcoming posts in this series will introduce you to the Windows registry as a\nsystem mechanism and as an attack surface, and will dive deeper into practical\nexploitation using hive memory corruption, out-of-bounds cell indexes and\nother amusing techniques. Stay tuned!\n\nPosted by\n\nGoogle Project Zero at\n\n9:45 AM\n\nEmail ThisBlogThis!Share to TwitterShare to FacebookShare to Pinterest\n\n#### No comments:\n\n#### Post a Comment\n\nNewer Post Older Post Home\n\nSubscribe to: Post Comments (Atom)\n\n## Search This Blog\n\n## Pages\n\n  * About Project Zero\n  * Working at Project Zero\n  * 0day \"In the Wild\"\n  * 0day Exploit Root Cause Analyses\n  * Vulnerability Disclosure FAQ\n\n## Archives\n\nPowered by Blogger.\n\nDiese Website verwendet Cookies von Google, um Dienste anzubieten und Zugriffe\nzu analysieren. Deine IP-Adresse und dein User-Agent werden zusammen mit\nMesswerten zur Leistung und Sicherheit f\u00fcr Google freigegeben. So k\u00f6nnen\nNutzungsstatistiken generiert, Missbrauchsf\u00e4lle erkannt und behoben und die\nQualit\u00e4t des Dienstes gew\u00e4hrleistet werden.Weitere InformationenOk\n\n", "frontpage": false}
