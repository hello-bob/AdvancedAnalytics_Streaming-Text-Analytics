{"aid": "40059228", "title": "Research Code", "url": "https://nonint.com/2024/03/16/research-code/", "domain": "nonint.com", "votes": 2, "user": "lawrencechen", "posted_at": "2024-04-17 00:53:37", "comments": 0, "source_title": "Research Code", "source_text": "Research Code \u2013 Non_Interactive \u2013 Software & ML\n\nSkip to content\n\nNon_Interactive \u2013 Software & ML\n\nMenu\n\n# Research Code\n\nPosted on March 16, 2024March 16, 2024 by jbetker\n\nAt my job, I\u2019m currently in a cycle that is involving working with software\nengineers quite a bit. One thing that has happened a number of times is that a\nsoftware engineer will bring up \u201cresearch code\u201d with a condescending tone. The\nimplication is that research code is messy, unreadable, and difficult to\nmaintain.\n\nI don\u2019t deny this! It often is those things, but I also think it has a beauty\nto its purpose and prose that is worth acknowledging.\n\nMost code has a purpose from the get go. Someone thinks \u201cwouldn\u2019t it be nice\nif my computer did <x>\u201d, then designs and builds the code to achieve <x>.\nGenerally you know where you want to end up and how to get there fairly early\non in the project. This makes writing design docs, unit tests and a coherent\nsoftware architecture possible.\n\nResearch doesn\u2019t really work in this way. It is similarly goal oriented, but\nthe distinction is that you never really know exactly how you\u2019re going to get\nto the goal. You constantly poke at the unknown until something \u201cworks\u201d. You\nget stuck in iterative loops improving small aspects of your design over weeks\nor months \u2013 which naturally causes it to evolve. At the end of the journey the\ngoalposts have moved, more often than not.\n\nIn such an environment, you take notes rather than write design docs. They\ndescribe where you\u2019ve been and why the things you tried didn\u2019t work. You test\none-off implementations directly rather than write unit tests. If something\nworks, you cement it in place as a beacon marking a step towards your goal. If\nyou\u2019re fortunate enough to be working on a problem that allows evaluation\nmetrics, you might record the eval scores you achieve. It might make sense to\nwrite a unit test here, but it\u2019s often easier just to treat the beacon code as\nimmutable and branch off of it.\n\nI love this way of iterating on a problem. I always have, well before I joined\nthe field. It\u2019s haphazard as hell, but it also feels as close to \u201cart\u201d as I\nthink programming will ever get. Let me explain that a bit: art is more often\nthen not about individual expression. Programming for most large companies is\nexplicitly not that: it\u2019s about writing in common language with your fellow\nprogrammers as well as sharing \u201ccultural norms\u201d like coding conventions,\nreviews and tests. There are good reasons for all of these things! But the end\nproduct is rarely \u201cart\u201d.\n\nBy contrast, the code that a researcher builds is a product of the interaction\nbetween their individual ingenuity and the real world. It\u2019s organic and\ncomplex and two researchers tackling a similar problem rarely come up with the\nsame code at the end of the day. I call that \u201cart\u201d.\n\n\u00a9 2024 Non_Interactive \u2013 Software & ML | Powered by Minimalist Blog WordPress Theme\n\n", "frontpage": false}
