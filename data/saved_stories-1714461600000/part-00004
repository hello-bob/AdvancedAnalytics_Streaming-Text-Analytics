{"aid": "40204415", "title": "Verifying Slack Requests with Phoenix", "url": "https://benreinhart.com/blog/verifying-slack-requests-elixir-phoenix/", "domain": "benreinhart.com", "votes": 1, "user": "nichochar", "posted_at": "2024-04-29 21:37:33", "comments": 0, "source_title": "Verifying Slack Requests in Phoenix", "source_text": "Verifying Slack Requests in Phoenix\n\n# Verifying Slack Requests in Phoenix\n\nDate\n\n    Saturday, April 27, 2024\n\nRemember the chat bot hype circa 2016? Well, seeing as we have the ability to\nimplement chat with far greater capabilities at our disposal, I couldn\u2019t help\nbut create my own Slack bot powered by LLMs. At the moment, it doesn\u2019t do a\nwhole lot, but it is available to shoot the shit in our Slack rooms, summarize\ndiscussions, assign tasks, etc.\n\nPerhaps a low bar, I\u2019m easily nerd sniped by the types of things involved with\nsetting up the chat bot, e.g., integrating with Slack, handling their\noverwhelming-amount-of events, background processing, and verifiying the\nauthenticity of requests\u2014the latter of which is especially fun as it involves\ncryptography. So, this post is about verifying the authenticity of requests\nfrom Slack\u2019s Events API.\n\n## Background\n\nTo follow along, you\u2019d need a Phoenix application and a Slack app that is\nconfigured to receive events from Slack\u2019s Events API. The Phoenix app will\nneed to be hosted somewhere Slack can send those events to. I used Fly.io.\n\n### Initial route and controller\n\nI have a route /api/slack which is where Slack will send events from the\nEvents API.\n\n    \n    \n    # lib/slack_bot_web/router.ex scope \"/api\", SlackBotWeb do post \"/slack\", SlackController, :index end\n    \n    \n    # lib/slack_bot_web/controllers/slack_controller.ex defmodule SlackBotWeb.SlackController do use SlackBotWeb, :controller require Logger def index(conn, %{\"type\" => \"event_callback\", \"event\" => event}) do SlackBot.Events.process(event) # irrelevant for this post ok(conn) end def index(conn, %{\"type\" => \"url_verification\", \"challenge\" => challenge}) do text(conn, challenge) end def index(conn, params) do Logger.warning(\"Unhandled request from Slack: \" <> Jason.encode!(params)) ok(conn) end defp ok(conn) do send_resp(conn, 200, \"\") end end\n\nThe controller currently handles two types of events (ignoring all others):\n\n  * event_callback \u2014 This is the type for pretty much all events I care about, e.g., new message in public or private channels, user joins channel, DM message deleted, etc.\n  * url_verification \u2014 The event Slack uses to verify your URL with the Events API.\n\n## Request verification\n\nAt this point, the controller is not verifying or otherwise authenticating\nrequests. Anyone could send an event impersonating Slack and the controller\nwould happily process it. Instead, we should verify the authenticity of each\nrequest before accepting it.\n\nHere\u2019s a brief overview of how request verification works:\n\n  * Slack issues a \u201csigning secret,\u201d a value known only to you and Slack.\n  * Slack will compute a signature for each request using the signing secret. Slack will include this signature in a request header called x-slack-signature.\n  * You will also compute a signature using the signing secret for each request received.\n  * You will compare the signature you computed with the one they included in their request. If the two signatures match, the request is authentic. Assuming no one else has access to the signing secret, it could only have come from Slack.\n\nSlack includes a timestamp as part of the request (in the x-slack-request-\ntimestamp header) and in the signature computation. In addition to verifying\nthe signatures match, you should verify that the timestamp is \u201crecent\u201d to\nprevent replay attacks.\n\n### Implementing request verification\n\nThe core algorithm is implemented in valid_request_signature?/3:\n\n    \n    \n    defmodule SlackBot.Slack do alias SlackBot.Crypto def valid_request_signature?(signature, raw_body, timestamp) when is_binary(signature) and is_binary(raw_body) and is_binary(timestamp) do signed = signing_secret() |> Crypto.hmac_sha256(\"v0:#{timestamp}:#{raw_body}\") Crypto.secure_compare(\"v0=#{signed}\", signature) end defp signing_secret() do Application.get_env(:slack_bot, :slack)[:signing_secret] end end\n\nThis function takes three arguments:\n\n  1. signature - This is the signature slack included in the x-slack-signature request header, which contains the signature they computed over the request.\n  2. raw_body - The unmodified request body. We will need to tweak Phoenix\u2019s middleware in order to preserve the unmodified request body. This is discussed below in Preserving the unmodified request body.\n  3. timestamp - This is the timestamp slack included in the x-slack-request-timestamp request header and used as part of the signature computation.\n\nSlack\u2019s documentation discusses this proces in detail but, in short, we use\nthe signing secret to compute the HMAC SHA256 signature over the necessary\nvalues. We securely compare that signature with the one Slack sent in the\nrequest header. If they\u2019re the same, the function returns true otherwise\nfalse.\n\nThis code relies on the following module that implements some cryptography\noperations:\n\n    \n    \n    defmodule SlackBot.Crypto do def hmac_sha256(secret, data) when is_binary(secret) and is_binary(data) do :crypto.mac(:hmac, :sha256, secret, data) |> Base.encode16(case: :lower) end def secure_compare(left, right) when is_binary(left) and is_binary(right) do byte_size(left) == byte_size(right) and :crypto.hash_equals(left, right) end end\n\nhmac_sha256/2 computes a signature using HMAC SHA256 and then returns a\nbase16-encoded string (the encoding used by Slack).\n\nsecure_compare/2 performs constant-time comparison to help prevent timing\nattacks.\n\nGiven the sensitivity of this code, we validate the arguments are the expected\ntypes.\n\n## Preserving the unmodified request body\n\nPhoenix uses Plug.Conn.read_body/2 to read the request body from the socket.\nOnce the body is read, it cannot be re-read. Phoenix does not preserve the\nunmodified body, so we must override its default behavior and do so\nexplicitly.\n\nPlug documents a custom body reader for this purpose, though we alter the code\nto run only for the routes that need it (routes starting with /api/slack). We\ncan add this custom body reader within the existing\nlib/slack_bot_web/endpoint.ex file:\n\n    \n    \n    defmodule RawBodyReader do def read_body(conn, opts) do case conn.path_info do [\"api\", \"slack\" | _] -> # We need the original unmodified request body for signature verification, # explicitly store it on the conn for later use. Signature verification is # how we know that the event is legitimately sent from Slack. {:ok, body, conn} = Plug.Conn.read_body(conn, opts) conn = update_in(conn.assigns[:raw_body], &[body | &1 || []]) {:ok, body, conn} _ -> # If this isn't a request that requires signature verification, delegate to the default reader. # This way, we don't consume extra memory by storing the original unmodified body in the conn state. Plug.Conn.read_body(conn, opts) end end end\n\nAlso in lib/slack_bot_web/endpoint.ex, update the Plug.Parsers configuration\nto use our custom body reader:\n\n    \n    \n    plug Plug.Parsers, parsers: [:urlencoded, :multipart, :json], pass: [\"*/*\"], + body_reader: {RawBodyReader, :read_body, []}, json_decoder: Phoenix.json_library()\n\nNow the conn passed to our Slack controller actions will have a raw_body\nassign that we can use to access the unmodified request body.\n\n## Verifying requests\n\nWhen a request comes into slack_controller.ex, we need to do three things:\n\n  1. Assign the required x-slack-request-timestamp and x-slack-signature headers.\n  2. Verify the timestamp is within some reasonable range of what the server considers the current time to prevent replay attacks.\n  3. Verify the request signature.\n\nI used custom plugs that run before our controller action for this purpose.\nThey are configured at the top of the controller:\n\n    \n    \n    plug :assign_request_headers plug :verify_request_timestamp plug :verify_request_signature\n\n### Assigning request headers\n\nThis plug will pluck out the x-slack-request-timestamp and x-slack-signature\nheaders and put them into conn.assigns. If any are missing, it will respond\nwith an error.\n\n    \n    \n    defp assign_request_headers(conn, _opts) do timestamp = conn |> get_req_header(\"x-slack-request-timestamp\") |> List.first() signature = conn |> get_req_header(\"x-slack-signature\") |> List.first() if is_nil(timestamp) or is_nil(signature) do Logger.warning(\"Invalid request signature: missing slack headers\") invalid_request_signature(conn) else conn |> assign(:timestamp, timestamp) |> assign(:signature, signature) end end\n\n### Verify request timestamp\n\nThis plug will ensure that the timestamp from the request is within 5 minutes\nof the server\u2019s current time. This is the same range used in Slack\u2019s\ndocumentation.\n\n    \n    \n    @five_minutes_in_seconds :timer.minutes(5) / 1000 defp verify_request_timestamp(conn, _opts) do now = :os.system_time(:seconds) timestamp = String.to_integer(conn.assigns.timestamp) # Protect against replay attacks by ensuring the server time # is within a 5 minute window of when Slack sent the request if abs(now - timestamp) < @five_minutes_in_seconds do conn else Logger.warning(\"Invalid request signature: timestamp not within acceptable window\") invalid_request_signature(conn) end end\n\n### Verify request signature\n\nIf the first two plugs succeeded, we\u2019ll verify the request signature using the\nvalid_request_signature?/3 function we defined above.\n\nNote that the raw_body is stored as iodata, so we need to convert it to a\nbinary first using IO.iodata_to_binary/1.\n\n    \n    \n    defp verify_request_signature(conn, _opts) do %{raw_body: raw_body, timestamp: timestamp, signature: signature} = conn.assigns raw_body = IO.iodata_to_binary(raw_body) if Slack.valid_request_signature?(signature, raw_body, timestamp) do conn else Logger.warning(\"Invalid request signature: signature invalid\") invalid_request_signature(conn) end end\n\n#### Invalid request signatures\n\nAll of the plugs above make use of the following helper for sending an error\nresponse:\n\n    \n    \n    defp invalid_request_signature(conn) do conn |> put_status(:bad_request) |> json(%{error: \"Invalid request signature\"}) |> halt() end\n\n## Putting it all together\n\nThat\u2019s a lot of pieces, so here is the entire controller.\n\n    \n    \n    defmodule SlackBotWeb.SlackController do use SlackBotWeb, :controller require Logger alias SlackBot.Slack @five_minutes_in_seconds :timer.minutes(5) / 1000 plug :assign_request_headers plug :verify_request_timestamp plug :verify_request_signature def index(conn, %{\"type\" => \"event_callback\", \"event\" => event}) do SlackBot.Events.process(event) # irrelevant for this post ok(conn) end def index(conn, %{\"type\" => \"url_verification\", \"challenge\" => challenge}) do text(conn, challenge) end def index(conn, params) do Logger.warning(\"Unhandled request from Slack: \" <> Jason.encode!(params)) ok(conn) end defp ok(conn) do send_resp(conn, 200, \"\") end defp assign_request_headers(conn, _opts) do timestamp = conn |> get_req_header(\"x-slack-request-timestamp\") |> List.first() signature = conn |> get_req_header(\"x-slack-signature\") |> List.first() if is_nil(timestamp) or is_nil(signature) do Logger.warning(\"Invalid request signature: missing slack headers\") invalid_request_signature(conn) else conn |> assign(:timestamp, timestamp) |> assign(:signature, signature) end end defp verify_request_timestamp(conn, _opts) do now = :os.system_time(:seconds) timestamp = String.to_integer(conn.assigns.timestamp) # Protect against replay attacks by ensuring the server time # is within a 5 minute window of when Slack sent the request if abs(now - timestamp) < @five_minutes_in_seconds do conn else Logger.warning(\"Invalid request signature: timestamp not within acceptable window\") invalid_request_signature(conn) end end defp verify_request_signature(conn, _opts) do %{raw_body: raw_body, timestamp: timestamp, signature: signature} = conn.assigns raw_body = IO.iodata_to_binary(raw_body) if Slack.valid_request_signature?(signature, raw_body, timestamp) do conn else Logger.warning(\"Invalid request signature: signature invalid\") invalid_request_signature(conn) end end defp invalid_request_signature(conn) do conn |> put_status(:bad_request) |> json(%{error: \"Invalid request signature\"}) |> halt() end end\n\nWith that, you\u2019re able to setup a secure server that listens and processes\nevents from Slack\u2019s Events API.\n\nIf you copy an event sent by Slack (timestamp, signature, and raw body), you\ncan ingest it locally with the following curl command assuming you have the\nproduction signing secret configured and the event is within 5 minutes:\n\n    \n    \n    curl -X POST http://localhost:4000/api/slack \\ -H 'content-type: application/json' \\ -H 'x-slack-request-timestamp: 1714166025' \\ -H 'x-slack-signature: v0=06dced75b4f92527a506f38f515bd43f063e718b694e69a8ff77095c05f65afe' \\ -d \"{\\\"token\\\":\\\"npOSq2lAdKsn3yzWyZRqmoum\\\",\\\"team_id\\\":\\\"T05415Z04CT\\\",\\\"context_team_id\\\":\\\"T05415Z04CT\\\",\\\"context_enterprise_id\\\":null,\\\"api_app_id\\\":\\\"A09TB7JESR2\\\",\\\"event\\\":{\\\"type\\\":\\\"message\\\",\\\"subtype\\\":\\\"message_deleted\\\",\\\"previous_message\\\":{\\\"user\\\":\\\"U05AN2SBYRP\\\",\\\"type\\\":\\\"message\\\",\\\"ts\\\":\\\"1714166020.779239\\\",\\\"client_msg_id\\\":\\\"cb8fa544-3a59-44c1-aa75-41aae774aaa8\\\",\\\"text\\\":\\\"Create a new message\\\",\\\"team\\\":\\\"T05415Z04CT\\\",\\\"blocks\\\":[{\\\"type\\\":\\\"rich_text\\\",\\\"block_id\\\":\\\"XJ69k\\\",\\\"elements\\\":[{\\\"type\\\":\\\"rich_text_section\\\",\\\"elements\\\":[{\\\"type\\\":\\\"text\\\",\\\"text\\\":\\\"Create a new message\\\"}]}]}]},\\\"channel\\\":\\\"C05CRST3H52\\\",\\\"hidden\\\":true,\\\"deleted_ts\\\":\\\"1714166020.779239\\\",\\\"event_ts\\\":\\\"1714166024.000400\\\",\\\"ts\\\":\\\"1714166024.000400\\\",\\\"channel_type\\\":\\\"channel\\\"},\\\"type\\\":\\\"event_callback\\\",\\\"event_id\\\":\\\"Ev070QUL2VB8\\\",\\\"event_time\\\":1714166024,\\\"authorizations\\\":[{\\\"enterprise_id\\\":null,\\\"team_id\\\":\\\"T05415Z04CT\\\",\\\"user_id\\\":\\\"U06U8QRTZCY\\\",\\\"is_bot\\\":true,\\\"is_enterprise_install\\\":false}],\\\"is_ext_shared_channel\\\":false,\\\"event_context\\\":\\\"4-eyJldCI6Im1lc3NhZ2UiLCJ0aWQiOiJUMDU4ODdaMDRDVCIsImFpZCI6IkEwNlRON0pEU1IyIiwiY2lkIjoiQzA1Q1ZRVTNINTIifQ\\\"}\"\n\nHappy Slacking!\n\n", "frontpage": false}
