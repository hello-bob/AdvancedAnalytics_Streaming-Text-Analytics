{"aid": "40059185", "title": "Exploring DoltgreSQL Through Type Compatibility", "url": "https://www.dolthub.com/blog/2024-04-16-exploring-doltgres-compatibility/", "domain": "dolthub.com", "votes": 2, "user": "Hydrocharged", "posted_at": "2024-04-17 00:46:28", "comments": 0, "source_title": "Exploring DoltgreSQL through Type Compatibility", "source_text": "Exploring DoltgreSQL through Type Compatibility | DoltHub Blog\n\nBlog\n\n# Exploring DoltgreSQL through Type Compatibility\n\nDaylon Wilkins\n\nApril 16, 2024\n\nDOLTGRESSQLTECHNICAL\n\n5 min read\n\nWe're steadily making progress on DoltgreSQL, which is a version of Dolt built\nto be a drop-in replacement for PostgreSQL. For those that may not know, Dolt\nis the world's first database that is built, from the ground up, with version\ncontrol in mind. That means you can branch, merge, diff, etc. your data and\nschemas. You can even run joins across commits, unlocking a way of interacting\nwith data that has not been seen before.\n\nAs Dolt is battle-tested and used in production across a multitude of\ncompanies, we did not want to start completely from scratch with DoltgreSQL.\nAfter all, the technology underlying Dolt's versioning capabilities works for\nall relational data, regardless of whether it's MySQL or PostgreSQL flavored.\nThat underlying technology (the storage engine), however, is only one part of\nDolt. There are two additional parts to Dolt, which are the MySQL emulation\nlayer and the translation layer between the other two layers.\n\nThis division works great for building Dolt. The MySQL emulation layer is the\ngo-mysql-server (GMS) project, which we inherited from source{d} to become the\nmaintainers. It is strictly focused on MySQL compatibility, including all of\nits quirks and features. There is also our fork of Vitess, which we use to\nimplement MySQL's wire protocol, along with parsing MySQL statements into an\nAST that GMS understands. Both of these create a few problems for DoltgreSQL\nthough.\n\n## PostgreSQL isn't MySQL\n\nThe section header is probably the most obvious thing that you'll read all\nyear, but it's worth mentioning because we all know how many ways that they're\ndifferent. For starting DoltgreSQL though, their similarities meant that we\ncould get a prototype up and running in less than a month. MySQL definitely\nhas its own variant of SQL, but at its heart it is still SQL. A SELECT\nstatement returns results, and an INSERT statement adds rows. As long as we\ncould talk the protocol, we could simply pass queries to Vitess and GMS, and\nconvert those results back into PostgreSQL's protocol.\n\nThis worked for the purposes of a prototype, and showed the feasibility of the\nimplementation (amongst other considerations, such as a foreign data wrapper,\nan extension, etc.). It also showed that this approach really only worked as a\nprototype, as encountering Postgres-specific types would immediately break\ndown. For example, both MySQL and Postgres will happily accept an INT or\nINTEGER since it's in the SQL specification, but Postgres also allows the\nforms INT2, INT4, etc., which would immediately fail to parse in Vitess.\n\nRather than extending Vitess to accept Postgres types, we decided to replace\nVitess with our own parser that outputs its own AST. We then added a\ntranslation layer that converts the Postgres-oriented AST to the Vitess AST\nthat GMS can understand. This greatly moved the needle forward for Doltgres,\nsince it meant that we could now work with a statement's intent rather than\nits exact syntax. Idiomatic Postgres uses ::TYPE for casting, and we could\nsimply translate that into the equivalent CONVERT(VALUE, TYPE) MySQL call.\n\nThis allowed us to build tooling that would allow us to measure our\ncorrectness relative to Postgres, similar to our correctness tracking for\nDolt. Rather than simply knowing that we do not support \"stuff\", we can\nquantify that X statement parses but does not have a translatable equivalent\ninto a Vitess AST, or that Y statement is unsupported by the parser and needs\nto be added, or that Z statement simply returns an incorrect result in some\nscenarios. While this has been great for development, there's still the\nelephant in the room: what do we do for concepts that do not have an\nequivalent in MySQL at all, such as many of the types?\n\n## To Extend or Replace\n\nI mentioned it earlier, but it's worth repeating: the goal of GMS is to act as\nthough it were MySQL. But that's actually its secondary purpose. It's primary\npurpose is to facilitate Dolt's goal of being a drop-in replacement for MySQL.\nThe two statements may seem similar, but the nuance comes from Dolt being the\nprimary driver. Since other projects completely unrelated to our own use GMS\nfor their own purposes, we do our best to stray from breaking changes.\nHowever, if they must be done for Dolt, then they must be done. So how, then,\ndoes DoltgreSQL fit into this picture?\n\nWell, in a way, it kind of doesn't. Types are a great example of this, since\ntypes are one of the core pillars of a relational database. In MySQL, types\nare sort of an abstract concept to define a specific contract with data.\nSaying that a column has the type INTEGER doesn't just mean that it stores\nwhole numbers. It also defines the range of valid numbers, how those numbers\nare ordered, how to interpret those numbers as other types, etc. From a high\nlevel, this doesn't look any different than Postgres, since Postgres also has\nmany of the same functionality with its type. One key difference, however, is\nthat Postgres is explicit in its definitions. You can add a SMALLINT/INT2 and\nan INTEGER/INT4 because there exists the function int24pl. Addition is still\ncommutative because there is the function int42pl. This is all explicitly\ndefined, and of course that is part of what makes Postgres so extensible. Add\na new function to the group, and now you can add two types together where it\nwas previously not possible. In fact, types themselves are just a collection\nof functions, meaning all type functionally is explicitly declared somewhere.\n\nSince GMS is faithful to MySQL, it also models types as these abstract\nconcepts. In a fundamental way, they are not extensible, modifiable, etc.\nDoltgres needs the extensibility because it's core to the definition of a type\nin Postgres, and is a bit at-odds with the abstract nature of MySQL types.\n\nIn order to keep up our rate of progress, we decided to shift as much\nresponsibility for type handling into Doltgres for Postgres types, and\nintroduced a new opaque type in GMS and the translation layer in Dolt. While\nGMS expects specific types in specific situations and will often fail if it\nsees the new opaque type in some scenarios, these scenarios are often\nscenarios where GMS is executing logic that is specific to MySQL. For example,\nGMS knows what to do when adding two integer types, but doesn't know what to\ndo with the opaque type, so that prompted a full reimplementation of operators\nin Doltgres, which properly models operators as functions rather than\nintrinsic properties of types. This means that we're incrementally working our\nway toward complete compatibility with Postgres, while actually being usable\nin some contexts today.\n\n## Strategy Benefits\n\nBesides compatibility, our incremental approach means that you can actually\nuse Doltgres, today, for some use-cases. It's definitely not production ready\n(we still have a ton of work to do), but one great use-case for it is through\nreplication. My coworker wrote an excellent blog demonstrating how to\nimplement it in Golang, which shows some of the knowledge we gained while\nworking on it. As long as the type is supported in Doltgres, then we expect\nreplication to just work. We're also always working on adding new types, and\nwe've added 16 new types in just the latest release. We publish a general\noverview of our types compatibility on our docs.\n\n## Conclusion\n\nDoltgreSQL still has a lot of work left, but everyday we're getting closer to\nour goal of full compatibility! Versioned databases are truly a game-changer,\nand we're excited to bring the concept of Dolt to the PostgreSQL audience.\n\nYou can find us on Twitter/X and chat with us on Discord. We also welcome all\nissue reports! Thank you for reading!\n\nSHARE\n\nBlog\n\nDolt is open source\n\nJOIN THE DATA EVOLUTION\n\n# Get started with Dolt\n\nOr join our mailing list to get product updates.\n\n", "frontpage": false}
