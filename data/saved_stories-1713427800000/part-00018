{"aid": "40069810", "title": "PenroseKiteDart User Guide", "url": "https://readerunner.wordpress.com/2024/04/08/penrosekitedart-user-guides/", "domain": "readerunner.wordpress.com", "votes": 1, "user": "JNRowe", "posted_at": "2024-04-17 20:36:44", "comments": 0, "source_title": "PenroseKiteDart User Guide", "source_text": "PenroseKiteDart User Guide | readerunner\n\n# readerunner\n\n## maths and computing experiments\n\n# PenroseKiteDart User Guide\n\nLeave a reply\n\n## Introduction\n\nPenroseKiteDart is a Haskell package with tools to experiment with finite\ntilings of Penrose\u2019s Kites and Darts. It uses the Haskell Diagrams package for\ndrawing tilings. As well as providing drawing tools, this package introduces\ntile graphs (Tgraphs) for describing finite tilings. (I would like to thank\nStephen Huggett for suggesting planar graphs as a way to reperesent the\ntilings).\n\nThis document summarises the design and use of the PenroseKiteDart package.\n\nPenroseKiteDart package is now available on Hackage.\n\nThe source files are available on GitHub at\nhttps://github.com/chrisreade/PenroseKiteDart.\n\nThere is a small art gallery of examples created with PenroseKiteDart here.\n\nIndex\n\n  1. About Penrose\u2019s Kites and Darts\n  2. Using the PenroseKiteDart Package (initial set up).\n  3. Overview of Types and Operations\n  4. Drawing in more detail\n  5. Forcing in more detail\n  6. Advanced Operations\n  7. Other Reading\n\n## 1\\. About Penrose\u2019s Kites and Darts\n\n### The Tiles\n\nIn figure 1 we show a dart and a kite. All angles are multiples of (a tenth of\na full turn). If the shorter edges are of length 1, then the longer edges are\nof length , where is the golden ratio.\n\nFigure 1: The Dart and Kite Tiles\n\n### Aperiodic Infinite Tilings\n\nWhat is interesting about these tiles is:\n\nAdvertisement\n\nPrivacy Settings\n\nIt is possible to tile the entire plane with kites and darts in an aperiodic\nway.\n\nSuch a tiling is non-periodic and does not contain arbitrarily large periodic\nregions or patches.\n\nThe possibility of aperiodic tilings with kites and darts was discovered by\nSir Roger Penrose in 1974. There are other shapes with this property,\nincluding a chiral aperiodic monotile discovered in 2023 by Smith, Myers,\nKaplan, Goodman-Strauss. (See the Penrose Tiling Wikipedia page for the\nhistory of aperiodic tilings)\n\nThis package is entirely concerned with Penrose\u2019s kite and dart tilings also\nknown as P2 tilings.\n\n### Legal Tilings\n\nIn figure 2 we add a temporary green line marking purely to illustrate a rule\nfor making legal tilings. The purpose of the rule is to exclude the\npossibility of periodic tilings.\n\nIf all tiles are marked as shown, then whenever tiles come together at a\npoint, they must all be marked or must all be unmarked at that meeting point.\nSo, for example, each long edge of a kite can be placed legally on only one of\nthe two long edges of a dart. The kite wing vertex (which is marked) has to go\nnext to the dart tip vertex (which is marked) and cannot go next to the dart\nwing vertex (which is unmarked) for a legal tiling.\n\nFigure 2: Marked Dart and Kite\n\n### Correct Tilings\n\nUnfortunately, having a finite legal tiling is not enough to guarantee you can\ncontinue the tiling without getting stuck. Finite legal tilings which can be\ncontinued to cover the entire plane are called correct and the others (which\nare doomed to get stuck) are called incorrect. This means that decomposition\nand forcing (described later) become important tools for constructing correct\nfinite tilings.\n\n## 2\\. Using the PenroseKiteDart Package\n\nYou will need the Haskell Diagrams package (See Haskell Diagrams) as well as\nthis package (PenroseKiteDart). When these are installed, you can produce\ndiagrams with a Main.hs module. This should import a chosen backend for\ndiagrams such as the default (SVG) along with Diagrams.Prelude.\n\n    \n    \n    module Main (main) where import Diagrams.Backend.SVG.CmdLine import Diagrams.Prelude\n\nFor Penrose\u2019s Kite and Dart tilings, you also need to import the PKD module\nand (optionally) the TgraphExamples module.\n\n    \n    \n    import PKD import TgraphExamples\n\nThen to ouput someExample figure\n\n    \n    \n    fig::Diagram B fig = someExample main :: IO () main = mainWith fig\n\nNote that the token B is used in the diagrams package to represent the chosen\nbackend for output. So a diagram has type Diagram B. In this case B is bound\nto SVG by the import of the SVG backend. When the compiled module is executed\nit will generate an SVG file. (See Haskell Diagrams for more details on\nproducing diagrams and using alternative backends).\n\nAdvertisement\n\nPrivacy Settings\n\n## 3\\. Overview of Types and Operations\n\n### Half-Tiles\n\nIn order to implement operations on tilings (decompose in particular), we work\nwith half-tiles. These are illustrated in figure 3 and labelled RD (right\ndart), LD (left dart), LK (left kite), RK (right kite). The join edges where\nleft and right halves come together are shown with dotted lines, leaving one\nshort edge and one long edge on each half-tile (excluding the join edge). We\nhave shown a red dot at the vertex we regard as the origin of each half-tile\n(the tip of a half-dart and the base of a half-kite).\n\nFigure 3: Half-Tile pieces showing join edges (dashed) and origin vertices\n(red dots)\n\nThe labels are actually data constructors introduced with type operator\nHalfTile which has an argument type (rep) to allow for more than one\nrepresentation of the half-tiles.\n\n    \n    \n    data HalfTile rep = LD rep -- Left Dart | RD rep -- Right Dart | LK rep -- Left Kite | RK rep -- Right Kite deriving (Show,Eq)\n\n### Tgraphs\n\nWe introduce tile graphs (Tgraphs) which provide a simple planar graph\nrepresentation for finite patches of tiles. For Tgraphs we first specialise\nHalfTile with a triple of vertices (positive integers) to make a TileFace such\nas RD(1,2,3), where the vertices go clockwise round the half-tile triangle\nstarting with the origin.\n\n    \n    \n    type TileFace = HalfTile (Vertex,Vertex,Vertex) type Vertex = Int -- must be positive\n\nThe function\n\n    \n    \n    makeTgraph :: [TileFace] -> Tgraph\n\nthen constructs a Tgraph from a TileFace list after checking the TileFaces\nsatisfy certain properties (described below). We also have\n\n    \n    \n    faces :: Tgraph -> [TileFace]\n\nto retrieve the TileFace list from a Tgraph.\n\nAdvertisement\n\nPrivacy Settings\n\nAs an example, the fool (short for fool\u2019s kite and also called an ace in the\nliterature) consists of two kites and a dart (= 4 half-kites and 2 half-\ndarts):\n\n    \n    \n    fool :: Tgraph fool = makeTgraph [RD (1,2,3), LD (1,3,4) -- right and left dart ,LK (5,3,2), RK (5,2,7) -- left and right kite ,RK (5,4,3), LK (5,6,4) -- right and left kite ]\n\nTo produce a diagram, we simply draw the Tgraph\n\n    \n    \n    foolFigure :: Diagram B foolFigure = draw fool\n\nwhich will produce the diagram on the left in figure 4.\n\nAlternatively,\n\n    \n    \n    foolFigure :: Diagram B foolFigure = labelled drawj fool\n\nwill produce the diagram on the right in figure 4 (showing vertex labels and\ndashed join edges).\n\nFigure 4: Diagram of fool without labels and join edges (left), and with\n(right)\n\nWhen any (non-empty) Tgraph is drawn, a default orientation and scale are\nchosen based on the lowest numbered join edge. This is aligned on the positive\nx-axis with length 1 (for darts) or length (for kites).\n\n### Tgraph Properties\n\nTgraphs are actually implemented as\n\n    \n    \n    newtype Tgraph = Tgraph [TileFace] deriving (Show)\n\nbut the data constructor Tgraph is not exported to avoid accidentally by-\npassing checks for the required properties. The properties checked by\nmakeTgraph ensure the Tgraph represents a legal tiling as a planar graph with\npositive vertex numbers, and that the collection of half-tile faces are both\nconnected and have no crossing boundaries (see note below). Finally, there is\na check to ensure two or more distinct vertex numbers are not used to\nrepresent the same vertex of the graph (a touching vertex check). An error is\nraised if there is a problem.\n\nAdvertisement\n\nPrivacy Settings\n\nNote: If the TilFaces are faces of a planar graph there will also be exterior\n(untiled) regions, and in graph theory these would also be called faces of the\ngraph. To avoid confusion, we will refer to these only as exterior regions,\nand unless otherwise stated, face will mean a TileFace. We can then define the\nboundary of a list of TileFaces as the edges of the exterior regions. There is\na crossing boundary if the boundary crosses itself at a vertex. We exclude\ncrossing boundaries from Tgraphs because they prevent us from calculating\nrelative positions of tiles locally and create touching vertex problems.\n\nFor convenience, in addition to makeTgraph, we also have\n\n    \n    \n    makeUncheckedTgraph :: [TileFace] -> Tgraph checkedTgraph :: [TileFace] -> Tgraph\n\nThe first of these (performing no checks) is useful when you know the required\nproperties hold. The second performs the same checks as makeTgraph except that\nit omits the touching vertex check. This could be used, for example, when\nmaking a Tgraph from a sub-collection of TileFaces of another Tgraph.\n\n### Main Tiling Operations\n\nThere are three key operations on finite tilings, namely\n\n    \n    \n    decompose :: Tgraph -> Tgraph force :: Tgraph -> Tgraph compose :: Tgraph -> Tgraph\n\n#### Decompose\n\nDecomposition (also called deflation) works by splitting each half-tile into\neither 2 or 3 new (smaller scale) half-tiles, to produce a new tiling. The\nfact that this is possible, is used to establish the existence of infinite\naperiodic tilings with kites and darts. Since our Tgraphs have abstracted away\nfrom scale, the result of decomposing a Tgraph is just another Tgraph. However\nif we wish to compare before and after with a drawing, the latter should be\nscaled by a factor times the scale of the former, to reflect the change in\nscale.\n\nFigure 5: fool (left) and decompose fool (right)\n\nWe can, of course, iterate decompose to produce an infinite list of finer and\nfiner decompositions of a Tgraph\n\n    \n    \n    decompositions :: Tgraph -> [Tgraph] decompositions = iterate decompose\n\n#### Force\n\nForce works by adding any TileFaces on the boundary edges of a Tgraph which\nare forced. That is, where there is only one legal choice of TileFace addition\nconsistent with the seven possible vertex types. Such additions are continued\nuntil either (i) there are no more forced cases, in which case a final\n(forced) Tgraph is returned, or (ii) the process finds the tiling is stuck, in\nwhich case an error is raised indicating an incorrect tiling. [In the latter\ncase, the argument to force must have been an incorrect tiling, because the\nforced additions cannot produce an incorrect tiling starting from a correct\ntiling.]\n\nAdvertisement\n\nPrivacy Settings\n\nAn example is shown in figure 6. When forced, the Tgraph on the left produces\nthe result on the right. The original is highlighted in red in the result to\nshow what has been added.\n\nFigure 6: A Tgraph (left) and its forced result (right) with the original\nshown red\n\n#### Compose\n\nComposition (also called inflation) is an opposite to decompose but this has\ncomplications for finite tilings, so it is not simply an inverse. (See\nGraphs,Kites and Darts and Theorems for more discussion of the problems).\nFigure 7 shows a Tgraph (left) with the result of composing (right) where we\nhave also shown (in pale green) the faces of the original that are not\nincluded in the composition \u2013 the remainder faces.\n\nFigure 7: A Tgraph (left) and its (part) composed result (right) with the\nremainder faces shown pale green\n\nUnder some circumstances composing can fail to produce a Tgraph because there\nare crossing boundaries in the resulting TileFaces. However, we have\nestablished that\n\n  * If g is a forced Tgraph, then compose g is defined and it is also a forced Tgraph.\n\n### Try Results\n\nIt is convenient to use types of the form Try a for results where we know\nthere can be a failure. For example, compose can fail if the result does not\npass the connected and no crossing boundary check, and force can fail if its\nargument is an incorrect Tgraph. In situations when you would like to continue\nsome computation rather than raise an error when there is a failure, use a try\nversion of a function.\n\n    \n    \n    tryCompose :: Tgraph -> Try Tgraph tryForce :: Tgraph -> Try Tgraph\n\nWe define Try as a synonym for Either String (which is a monad) in module\nTgraph.Try.\n\n    \n    \n    type Try a = Either String a\n\nSuccessful results have the form Right r (for some correct result r) and\nfailure results have the form Left s (where s is a String describing the\nproblem as a failure report).\n\nAdvertisement\n\nPrivacy Settings\n\nThe function\n\n    \n    \n    runTry:: Try a -> a runTry = either error id\n\nwill retrieve a correct result but raise an error for failure cases. This\nmeans we can always derive an error raising version from a try version of a\nfunction by composing with runTry.\n\n    \n    \n    force = runTry . tryForce compose = runTry . tryCompose\n\n### Elementary Tgraph and TileFace Operations\n\nThe module Tgraph.Prelude defines elementary operations on Tgraphs relating\nvertices, directed edges, and faces. We describe a few of them here.\n\nWhen we need to refer to particular vertices of a TileFace we use\n\n    \n    \n    originV :: TileFace -> Vertex -- the first vertex - red dot in figure 2 oppV :: TileFace -> Vertex -- the vertex at the opposite end of the join edge from the origin wingV :: TileFace -> Vertex -- the vertex not on the join edge\n\nA directed edge is represented as a pair of vertices.\n\n    \n    \n    type Dedge = (Vertex,Vertex)\n\nSo (a,b) is regarded as a directed edge from a to b. In the special case that\na list of directed edges is symmetrically closed [(b,a) is in the list\nwhenever (a,b) is in the list] we can think of this as an edge list rather\nthan just a directed edge list.\n\nFor example,\n\n    \n    \n    internalEdges :: Tgraph -> [Dedge]\n\nproduces an edge list, whereas\n\n    \n    \n    graphBoundary :: Tgraph -> [Dedge]\n\nproduces single directions. Each directed edge in the resulting boundary will\nhave a TileFace on the left and an exterior region on the right. The function\n\n    \n    \n    graphDedges :: Tgraph -> [Dedge]\n\nproduces all the directed edges obtained by going clockwise round each\nTileFace so not every edge in the list has an inverse in the list.\n\nAdvertisement\n\nPrivacy Settings\n\nThe above three functions are defined using\n\n    \n    \n    faceDedges :: TileFace -> [Dedge]\n\nwhich produces a list of the three directed edges going clockwise round a\nTileFace starting at the origin vertex.\n\nWhen we need to refer to particular edges of a TileFace we use\n\n    \n    \n    joinE :: TileFace -> Dedge -- shown dotted in figure 2 shortE :: TileFace -> Dedge -- the non-join short edge longE :: TileFace -> Dedge -- the non-join long edge\n\nwhich are all directed clockwise round the TileFace. In contrast, joinOfTile\nis always directed away from the origin vertex, so is not clockwise for right\ndarts or for left kites:\n\n    \n    \n    joinOfTile:: TileFace -> Dedge joinOfTile face = (originV face, oppV face)\n\n### Patches (Scaled and Positioned Tilings)\n\nBehind the scenes, when a Tgraph is drawn, each TileFace is converted to a\nPiece. A Piece is another specialisation of HalfTile using a two dimensional\nvector to indicate the length and direction of the join edge of the half-tile\n(from the originV to the oppV), thus fixing its scale and orientation. The\nwhole Tgraph then becomes a list of located Pieces called a Patch.\n\n    \n    \n    type Piece = HalfTile (V2 Double) type Patch = [Located Piece]\n\nPiece drawing functions derive vectors for other edges of a half-tile piece\nfrom its join edge vector. In particular (in the TileLib module) we have\n\n    \n    \n    drawPiece :: Piece -> Diagram B dashjPiece :: Piece -> Diagram B fillPieceDK :: Colour Double -> Colour Double -> Piece -> Diagram B\n\nwhere the first draws the non-join edges of a Piece, the second does the same\nbut adds a dashed line for the join edge, and the third takes two colours \u2013\none for darts and one for kites, which are used to fill the piece as well as\nusing drawPiece.\n\nPatch is an instances of class Transformable so a Patch can be scaled,\nrotated, and translated.\n\n### Vertex Patches\n\nIt is useful to have an intermediate form between Tgraphs and Patches, that\ncontains information about both the location of vertices (as 2D points), and\nthe abstract TileFaces. This allows us to introduce labelled drawing functions\n(to show the vertex labels) which we then extend to Tgraphs. We call the\nintermediate form a VPatch (short for Vertex Patch).\n\n    \n    \n    type VertexLocMap = IntMap.IntMap (Point V2 Double) data VPatch = VPatch {vLocs :: VertexLocMap, vpFaces::[TileFace]} deriving Show\n\nand\n\n    \n    \n    makeVP :: Tgraph -> VPatch\n\ncalculates vertex locations using a default orientation and scale.\n\nAdvertisement\n\nPrivacy Settings\n\nVPatch is made an instance of class Transformable so a VPatch can also be\nscaled and rotated.\n\nOne essential use of this intermediate form is to be able to draw a Tgraph\nwith labels, rotated but without the labels themselves being rotated. We can\nsimply convert the Tgraph to a VPatch, and rotate that before drawing with\nlabels.\n\n    \n    \n    labelled draw (rotate someAngle (makeVP g))\n\nWe can also align a VPatch using vertex labels.\n\n    \n    \n    alignXaxis :: (Vertex, Vertex) -> VPatch -> VPatch\n\nSo if g is a Tgraph with vertex labels a and b we can align it on the x-axis\nwith a at the origin and b on the positive x-axis (after converting to a\nVPatch), instead of accepting the default orientation.\n\n    \n    \n    labelled draw (alignXaxis (a,b) (makeVP g))\n\nAnother use of VPatches is to share the vertex location map when drawing only\nsubsets of the faces (see Overlaid examples in the next section).\n\n## 4\\. Drawing in More Detail\n\n### Class Drawable\n\nThere is a class Drawable with instances Tgraph, VPatch, Patch. When the token\nB is in scope standing for a fixed backend then we can assume\n\n    \n    \n    draw :: Drawable a => a -> Diagram B -- draws non-join edges drawj :: Drawable a => a -> Diagram B -- as with draw but also draws dashed join edges fillDK :: Drawable a => Colour Double -> Colour Double -> a -> Diagram B -- fills with colours\n\nwhere fillDK clr1 clr2 will fill darts with colour clr1 and kites with colour\nclr2 as well as drawing non-join edges.\n\nThese are the main drawing tools. However they are actually defined for any\nsuitable backend b so have more general types\n\n    \n    \n    draw :: (Drawable a, Renderable (Path V2 Double) b) => a -> Diagram2D b drawj :: (Drawable a, Renderable (Path V2 Double) b) => a -> Diagram2D b fillDK :: (Drawable a, Renderable (Path V2 Double) b) => Colour Double -> Colour Double -> a -> Diagram2D b\n\nwhere\n\n    \n    \n    type Diagram2D b = QDiagram b V2 Double Any\n\ndenotes a 2D diagram using some unknown backend b, and the extra constraint\nrequires b to be able to render 2D paths.\n\nAdvertisement\n\nPrivacy Settings\n\nIn these notes we will generally use the simpler description of types using B\nfor a fixed chosen backend for the sake of clarity.\n\nThe drawing tools are each defined via the class function drawWith using Piece\ndrawing functions.\n\n    \n    \n    class Drawable a where drawWith :: (Piece -> Diagram B) -> a -> Diagram B draw = drawWith drawPiece drawj = drawWith dashjPiece fillDK clr1 clr2 = drawWith (fillPieceDK clr1 clr2)\n\nTo design a new drawing function, you only need to implement a function to\ndraw a Piece, (let us call it newPieceDraw)\n\n    \n    \n    newPieceDraw :: Piece -> Diagram B\n\nThis can then be elevated to draw any Drawable (including Tgraphs, VPatches,\nand Patches) by applying the Drawable class function drawWith:\n\n    \n    \n    newDraw :: Drawable a => a -> Diagram B newDraw = drawWith newPieceDraw\n\n### Class DrawableLabelled\n\nClass DrawableLabelled is defined with instances Tgraph and VPatch, but Patch\nis not an instance (because this does not retain vertex label information).\n\n    \n    \n    class DrawableLabelled a where labelColourSize :: Colour Double -> Measure Double -> (Patch -> Diagram B) -> a -> Diagram B\n\nSo labelColourSize c m modifies a Patch drawing function to add labels (of\ncolour c and size measure m). Measure is defined in Diagrams.Prelude with pre-\ndefined measures tiny, verySmall, small, normal, large, veryLarge, huge. For\nmost of our diagrams of Tgraphs, we use red labels and we also find small is a\ngood default size choice, so we define\n\n    \n    \n    labelSize :: DrawableLabelled a => Measure Double -> (Patch -> Diagram B) -> a -> Diagram B labelSize = labelColourSize red labelled :: DrawableLabelled a => (Patch -> Diagram B) -> a -> Diagram B labelled = labelSize small\n\nand then labelled draw, labelled drawj, labelled (fillDK clr1 clr2) can all be\nused on both Tgraphs and VPatches as well as (for example) labelSize tiny\ndraw, or labelCoulourSize blue normal drawj.\n\n### Further drawing functions\n\nThere are a few extra drawing functions built on top of the above ones. The\nfunction smart is a modifier to add dashed join edges only when they occur on\nthe boundary of a Tgraph\n\n    \n    \n    smart :: (VPatch -> Diagram B) -> Tgraph -> Diagram B\n\nSo smart vpdraw g will draw dashed join edges on the boundary of g before\napplying the drawing function vpdraw to the VPatch for g. For example the\nfollowing all draw dashed join edges only on the boundary for a Tgraph g\n\n    \n    \n    smart draw g smart (labelled draw) g smart (labelSize normal draw) g\n\nWhen using labels, the function rotateBefore allows a Tgraph to be drawn\nrotated without rotating the labels.\n\n    \n    \n    rotateBefore :: (VPatch -> a) -> Angle Double -> Tgraph -> a rotateBefore vpdraw angle = vpdraw . rotate angle . makeVP\n\nSo for example,\n\n    \n    \n    rotateBefore (labelled draw) (90@@deg) g\n\nmakes sense for a Tgraph g. Of course if there are no labels we can simply use\n\n    \n    \n    rotate (90@@deg) (draw g)\n\nSimilarly alignBefore allows a Tgraph to be aligned using a pair of vertex\nnumbers before drawing.\n\n    \n    \n    alignBefore :: (VPatch -> a) -> (Vertex,Vertex) -> Tgraph -> a alignBefore vpdraw (a,b) = vpdraw . alignXaxis (a,b) . makeVP\n\nSo, for example, if Tgraph g has vertices a and b, both\n\n    \n    \n    alignBefore draw (a,b) g alignBefore (labelled draw) (a,b) g\n\nmake sense. Note that the following examples are wrong. Even though they type\ncheck, they re-orient g without repositioning the boundary joins.\n\n    \n    \n    smart (labelled draw . rotate angle) g -- WRONG smart (labelled draw . alignXaxis (a,b)) g -- WRONG\n\nInstead use\n\n    \n    \n    smartRotateBefore (labelled draw) angle g smartAlignBefore (labelled draw) (a,b) g\n\nwhere\n\n    \n    \n    smartRotateBefore :: (VPatch -> Diagram B) -> Angle Double -> Tgraph -> Diagram B smartAlignBefore :: (VPatch -> Diagram B) -> (Vertex,Vertex) -> Tgraph -> Diagram B\n\nare defined using\n\n    \n    \n    restrictSmart :: Tgraph -> (VPatch -> Diagram B) -> VPatch -> Diagram B\n\nHere, restrictSmart g vpdraw vp uses the given vp for drawing boundary joins\nand drawing faces of g (with vpdraw) rather than converting g to a new VPatch.\nThis assumes vp has locations for vertices in g.\n\n### Overlaid examples (location map sharing)\n\nThe function\n\n    \n    \n    drawForce :: Tgraph -> Diagram B\n\nwill (smart) draw a Tgraph g in red overlaid (using <>) on the result of force\ng as in figure 6. Similarly\n\n    \n    \n    drawPCompose :: Tgraph -> Diagram B\n\napplied to a Tgraph g will draw the result of a partial composition of g as in\nfigure 7. That is a drawing of compose g but overlaid with a drawing of the\nremainder faces of g shown in pale green.\n\nAdvertisement\n\nPrivacy Settings\n\nBoth these functions make use of sharing a vertex location map to get correct\nalignments of overlaid diagrams. In the case of drawForce g, we know that a\nVPatch for force g will contain all the vertex locations for g since force\nonly adds to a Tgraph (when it succeeds). So when constructing the diagram for\ng we can use the VPatch created for force g instead of starting afresh.\nSimilarly for drawPCompose g the VPatch for g contains locations for all the\nvertices of compose g so compose g is drawn using the the VPatch for g instead\nof starting afresh.\n\nThe location map sharing is done with\n\n    \n    \n    subVP :: VPatch -> [TileFace] -> VPatch\n\nso that subVP vp fcs is a VPatch with the same vertex locations as vp, but\nreplacing the faces of vp with fcs. [Of course, this can go wrong if the new\nfaces have vertices not in the domain of the vertex location map so this needs\nto be used with care. Any errors would only be discovered when a diagram is\ncreated.]\n\nFor cases where labels are only going to be drawn for certain faces, we need a\nversion of subVP which also gets rid of vertex locations that are not relevant\nto the faces. For this situation we have\n\n    \n    \n    restrictVP:: VPatch -> [TileFace] -> VPatch\n\nwhich filters out un-needed vertex locations from the vertex location map.\nUnlike subVP, restrictVP checks for missing vertex locations, so restrictVP vp\nfcs raises an error if a vertex in fcs is missing from the keys of the vertex\nlocation map of vp.\n\n## 5\\. Forcing in More Detail\n\n### The force rules\n\nThe rules used by our force algorithm are local and derived from the fact that\nthere are seven possible vertex types as depicted in figure 8.\n\nFigure 8: Seven vertex types\n\nOur rules are shown in figure 9 (omitting mirror symmetric versions). In each\ncase the TileFace shown yellow needs to be added in the presence of the other\nTileFaces shown.\n\nFigure 9: Rules for forcing\n\n### Main Forcing Operations\n\nTo make forcing efficient we convert a Tgraph to a BoundaryState to keep track\nof boundary information of the Tgraph, and then calculate a ForceState which\ncombines the BoundaryState with a record of awaiting boundary edge updates (an\nupdate map). Then each face addition is carried out on a ForceState,\nconverting back when all the face additions are complete. It makes sense to\napply force (and related functions) to a Tgraph, a BoundaryState, or a\nForceState, so we define a class Forcible with instances Tgraph,\nBoundaryState, and ForceState.\n\nAdvertisement\n\nPrivacy Settings\n\nThis allows us to define\n\n    \n    \n    force :: Forcible a => a -> a tryForce :: Forcible a => a -> Try a\n\nThe first will raise an error if a stuck tiling is encountered. The second\nuses a Try result which produces a Left string for failures and a Right a for\nsuccessful result a.\n\nThere are several other operations related to forcing including\n\n    \n    \n    stepForce :: Forcible a => Int -> a -> a tryStepForce :: Forcible a => Int -> a -> Try a addHalfDart, addHalfKite :: Forcible a => Dedge -> a -> a tryAddHalfDart, tryAddHalfKite :: Forcible a => Dedge -> a -> Try a\n\nThe first two force (up to) a given number of steps (=face additions) and the\nother four add a half dart/kite on a given boundary edge.\n\n### Update Generators\n\nAn update generator is used to calculate which boundary edges can have a\ncertain update. There is an update generator for each force rule, but also a\ncombined (all update) generator. The force operations mentioned above all use\nthe default all update generator (defaultAllUGen) but there are more general\n(with) versions that can be passed an update generator of choice. For example\n\n    \n    \n    forceWith :: Forcible a => UpdateGenerator -> a -> a tryForceWith :: Forcible a => UpdateGenerator -> a -> Try a\n\nIn fact we defined\n\n    \n    \n    force = forceWith defaultAllUGen tryForce = tryForceWith defaultAllUGen\n\nWe can also define\n\n    \n    \n    wholeTiles :: Forcible a => a -> a wholeTiles = forceWith wholeTileUpdates\n\nwhere wholeTileUpdates is an update generator that just finds boundary join\nedges to complete whole tiles.\n\nAdvertisement\n\nPrivacy Settings\n\nIn addition to defaultAllUGen there is also allUGenerator which does the same\nthing apart from how failures are reported. The reason for keeping both is\nthat they were constructed differently and so are useful for testing.\n\nIn fact UpdateGenerators are functions that take a BoundaryState and a focus\n(list of boundary directed edges) to produce an update map. Each Update is\ncalculated as either a SafeUpdate (where two of the new face edges are on the\nexisting boundary and no new vertex is needed) or an UnsafeUpdate (where only\none edge of the new face is on the boundary and a new vertex needs to be\ncreated for a new face).\n\n    \n    \n    type UpdateGenerator = BoundaryState -> [Dedge] -> Try UpdateMap type UpdateMap = Map.Map Dedge Update data Update = SafeUpdate TileFace | UnsafeUpdate (Vertex -> TileFace)\n\nCompleting (executing) an UnsafeUpdate requires a touching vertex check to\nensure that the new vertex does not clash with an existing boundary vertex.\nUsing an existing (touching) vertex would create a crossing boundary so such\nan update has to be blocked.\n\n### Forcible Class Operations\n\nThe Forcible class operations are higher order and designed to allow for easy\nadditions of further generic operations. They take care of conversions between\nTgraphs, BoundaryStates and ForceStates.\n\n    \n    \n    class Forcible a where tryFSOpWith :: UpdateGenerator -> (ForceState -> Try ForceState) -> a -> Try a tryChangeBoundaryWith :: UpdateGenerator -> (BoundaryState -> Try BoundaryChange) -> a -> Try a tryInitFSWith :: UpdateGenerator -> a -> Try ForceState\n\nFor example, given an update generator ugen and any f:: ForceState -> Try\nForceState , then f can be generalised to work on any Forcible using\ntryFSOpWith ugen f. This is used to define both tryForceWith and\ntryStepForceWith.\n\nWe also specialize tryFSOpWith to use the default update generator\n\n    \n    \n    tryFSOp :: Forcible a => (ForceState -> Try ForceState) -> a -> Try a tryFSOp = tryFSOpWith defaultAllUGen\n\nSimilarly given an update generator ugen and any f:: BoundaryState -> Try\nBoundaryChange , then f can be generalised to work on any Forcible using\ntryChangeBoundaryWith ugen f. This is used to define tryAddHalfDart and\ntryAddHalfKite.\n\nWe also specialize tryChangeBoundaryWith to use the default update generator\n\n    \n    \n    tryChangeBoundary :: Forcible a => (BoundaryState -> Try BoundaryChange) -> a -> Try a tryChangeBoundary = tryChangeBoundaryWith defaultAllUGen\n\nNote that the type BoundaryChange contains a resulting BoundaryState, the\nsingle TileFace that has been added, a list of edges removed from the boundary\n(of the BoundaryState prior to the face addition), and a list of the (3 or 4)\nboundary edges affected around the change that require checking or re-checking\nfor updates.\n\nAdvertisement\n\nPrivacy Settings\n\nThe class function tryInitFSWith will use an update generator to create an\ninitial ForceState for any Forcible. If the Forcible is already a ForceState\nit will do nothing. Otherwise it will calculate updates for the whole\nboundary. We also have the special case\n\n    \n    \n    tryInitFS :: Forcible a => a -> Try ForceState tryInitFS = tryInitFSWith defaultAllUGen\n\n### Efficient chains of forcing operations.\n\nNote that (force . force) does the same as force, but we might want to chain\nother force related steps in a calculation.\n\nFor example, consider the following combination which, after decomposing a\nTgraph, forces, then adds a half dart on a given boundary edge (d) and then\nforces again.\n\n    \n    \n    combo :: Dedge -> Tgraph -> Tgraph combo d = force . addHalfDart d . force . decompose\n\nSince decompose:: Tgraph -> Tgraph, the instances of force and addHalfDart d\nwill have type Tgraph -> Tgraph so each of these operations, will begin and\nend with conversions between Tgraph and ForceState. We would do better to\navoid these wasted intermediate conversions working only with ForceStates and\nkeeping only those necessary conversions at the beginning and end of the whole\nsequence.\n\nThis can be done using tryFSOp. To see this, let us first re-express the\nforcing sequence using the Try monad, so\n\n    \n    \n    force . addHalfDart d . force\n\nbecomes\n\n    \n    \n    tryForce <=< tryAddHalfDart d <=< tryForce\n\nNote that (<=<) is the Kliesli arrow which replaces composition for Monads\n(defined in Control.Monad). (We could also have expressed this right to left\nsequence with a left to right version tryForce >=> tryAddHalfDart d >=>\ntryForce). The definition of combo becomes\n\n    \n    \n    combo :: Dedge -> Tgraph -> Tgraph combo d = runTry . (tryForce <=< tryAddHalfDart d <=< tryForce) . decompose\n\nThis has no performance improvement, but now we can pass the sequence to\ntryFSOp to remove the unnecessary conversions between steps.\n\n    \n    \n    combo :: Dedge -> Tgraph -> Tgraph combo d = runTry . tryFSOp (tryForce <=< tryAddHalfDart d <=< tryForce) . decompose\n\nThe sequence actually has type Forcible a => a -> Try a but when passed to\ntryFSOp it specialises to type ForceState -> Try ForseState. This ensures the\nsequence works on a ForceState and any conversions are confined to the\nbeginning and end of the sequence, avoiding unnecessary intermediate\nconversions.\n\n### A limitation of forcing\n\nTo avoid creating touching vertices (or crossing boundaries) a BoundaryState\nkeeps track of locations of boundary vertices. At around 35,000 face additions\nin a single force operation the calculated positions of boundary vertices can\nbecome too inaccurate to prevent touching vertex problems. In such cases it is\nbetter to use\n\n    \n    \n    recalibratingForce :: Forcible a => a -> a tryRecalibratingForce :: Forcible a => a -> Try a\n\nThese work by recalculating all vertex positions at 20,000 step intervals to\nget more accurate boundary vertex positions. For example, 6 decompositions of\nthe kingGraph has 2,906 faces. Applying force to this should result in 53,574\nfaces but will go wrong before it reaches that. This can be fixed by\ncalculating either\n\n    \n    \n    recalibratingForce (decompositions kingGraph !!6)\n\nor using an extra force before the decompositions\n\n    \n    \n    force (decompositions (force kingGraph) !!6)\n\nIn the latter case, the final force only needs to add 17,864 faces to the\n35,710 produced by decompositions (force kingGraph) !!6.\n\nAdvertisement\n\nPrivacy Settings\n\n## 6\\. Advanced Operations\n\n### Guided comparison of Tgraphs\n\nAsking if two Tgraphs are equivalent (the same apart from choice of vertex\nnumbers) is a an np-complete problem. However, we do have an efficient guided\nway of comparing Tgraphs. In the module Tgraph.Rellabelling we have\n\n    \n    \n    sameGraph :: (Tgraph,Dedge) -> (Tgraph,Dedge) -> Bool\n\nThe expression sameGraph (g1,d1) (g2,d2) asks if g2 can be relabelled to match\ng1 assuming that the directed edge d2 in g2 is identified with d1 in g1. Hence\nthe comparison is guided by the assumption that d2 corresponds to d1.\n\nIt is implemented using\n\n    \n    \n    tryRelabelToMatch :: (Tgraph,Dedge) -> (Tgraph,Dedge) -> Try Tgraph\n\nwhere tryRelabelToMatch (g1,d1) (g2,d2) will either fail with a Left report if\na mismatch is found when relabelling g2 to match g1 or will succeed with Right\ng3 where g3 is a relabelled version of g2. The successful result g3 will match\ng1 in a maximal tile-connected collection of faces containing the face with\nedge d1 and have vertices disjoint from those of g1 elsewhere. The comparison\ntries to grow a suitable relabelling by comparing faces one at a time starting\nfrom the face with edge d1 in g1 and the face with edge d2 in g2. (This relies\non the fact that Tgraphs are connected with no crossing boundaries, and hence\ntile-connected.)\n\nThe above function is also used to implement\n\n    \n    \n    tryFullUnion:: (Tgraph,Dedge) -> (Tgraph,Dedge) -> Try Tgraph\n\nwhich tries to find the union of two Tgraphs guided by a directed edge\nidentification. However, there is an extra complexity arising from the fact\nthat Tgraphs might overlap in more than one tile-connected region. After\ncalculating one overlapping region, the full union uses some geometry\n(calculating vertex locations) to detect further overlaps.\n\nFinally we have\n\n    \n    \n    commonFaces:: (Tgraph,Dedge) -> (Tgraph,Dedge) -> [TileFace]\n\nwhich will find common regions of overlapping faces of two Tgraphs guided by a\ndirected edge identification. The resulting common faces will be a sub-\ncollection of faces from the first Tgraph. These are returned as a list as\nthey may not be a connected collection of faces and therefore not necessarily\na Tgraph.\n\n### Empires and SuperForce\n\nIn Empires and SuperForce we discussed forced boundary coverings which were\nused to implement both a superForce operation\n\n    \n    \n    superForce:: Forcible a => a -> a\n\nand operations to calculate empires.\n\nAdvertisement\n\nPrivacy Settings\n\nWe will not repeat the descriptions here other than to note that\n\n    \n    \n    forcedBoundaryECovering:: Tgraph -> [Tgraph]\n\nfinds boundary edge coverings after forcing a Tgraph. That is,\nforcedBoundaryECovering g will first force g, then (if it succeeds) finds a\ncollection of (forced) extensions to force g such that\n\n  * each extension has the whole boundary of force g as internal edges.\n  * each possible addition to a boundary edge of force g (kite or dart) has been included in the collection.\n\n(possible here means \u2013 not leading to a stuck Tgraph when forced.) There is\nalso\n\n    \n    \n    forcedBoundaryVCovering:: Tgraph -> [Tgraph]\n\nwhich does the same except that the extensions have all boundary vertices\ninternal rather than just the boundary edges.\n\n### Combinations\n\nCombinations such as\n\n    \n    \n    compForce:: Tgraph -> Tgraph -- compose after forcing allCompForce:: Tgraph -> [Tgraph] -- iterated (compose after force) while not emptyTgraph maxCompForce:: Tgraph -> Tgraph -- last item in allCompForce (or emptyTgraph)\n\nmake use of theorems established in Graphs,Kites and Darts and Theorems. For\nexample\n\n    \n    \n    compForce = uncheckedCompose . force\n\nwhich relies on the fact that composition of a forced Tgraph does not need to\nbe checked for connectedness and no crossing boundaries. Similarly, only the\ninitial force is necessary in allCompForce with subsequent iteration of\nuncheckedCompose because composition of a forced Tgraph is necessarily a\nforced Tgraph.\n\n### Tracked Tgraphs\n\nThe type\n\n    \n    \n    data TrackedTgraph = TrackedTgraph { tgraph :: Tgraph , tracked :: [[TileFace]] } deriving Show\n\nhas proven useful in experimentation as well as in producing artwork with\ndarts and kites. The idea is to keep a record of sub-collections of faces of a\nTgraph when doing both force operations and decompositions. A list of the sub-\ncollections forms the tracked list associated with the Tgraph. We make\nTrackedTgraph an instance of class Forcible by having force operations only\naffect the Tgraph and not the tracked list. The significant idea is the\nimplementation of\n\n    \n    \n    decomposeTracked :: TrackedTgraph -> TrackedTgraph\n\nDecomposition of a Tgraph involves introducing a new vertex for each long edge\nand each kite join. These are then used to construct the decomposed faces. For\ndecomposeTracked we do the same for the Tgraph, but when it comes to the\ntracked collections, we decompose them re-using the same new vertex numbers\ncalculated for the edges in the Tgraph. This keeps a consistent numbering\nbetween the Tgraph and tracked faces, so each item in the tracked list remains\na sub-collection of faces in the Tgraph.\n\nAdvertisement\n\nPrivacy Settings\n\nThe function\n\n    \n    \n    drawTrackedTgraph :: [VPatch -> Diagram B] -> TrackedTgraph -> Diagram B\n\nis used to draw a TrackedTgraph. It uses a list of functions to draw VPatches.\nThe first drawing function is applied to a VPatch for any untracked faces.\nSubsequent functions are applied to VPatches for the tracked list in order.\nEach diagram is beneath later ones in the list, with the diagram for the\nuntracked faces at the bottom. The VPatches used are all restrictions of a\nsingle VPatch for the Tgraph, so will be consistent in vertex locations. When\nlabels are used, there is also a drawTrackedTgraphRotated and\ndrawTrackedTgraphAligned for rotating or aligning the VPatch prior to applying\nthe drawing functions.\n\nNote that the result of calculating empires (see Empires and SuperForce ) is\nrepresented as a TrackedTgraph. The result is actually the common faces of a\nforced boundary covering, but a particular element of the covering (the first\none) is chosen as the background Tgraph with the common faces as a tracked\nsub-collection of faces. Hence we have\n\n    \n    \n    empire1, empire2 :: Tgraph -> TrackedTgraph drawEmpire :: TrackedTgraph -> Diagram B\n\nFigure 10 was also created using TrackedTgraphs.\n\nFigure 10: Using a TrackedTgraph for drawing\n\n## 7\\. Other Reading\n\nPrevious related blogs are:\n\n  * Diagrams for Penrose Tiles \u2013 the first blog introduced drawing Pieces and Patches (without using Tgraphs) and provided a version of decomposing for Patches (decompPatch).\n  * Graphs, Kites and Darts intoduced Tgraphs. This gave more details of implementation and results of early explorations. (The class Forcible was introduced subsequently).\n  * Empires and SuperForce \u2013 these new operations were based on observing properties of boundaries of forced Tgraphs.\n  * Graphs,Kites and Darts and Theorems established some important results relating force, compose, decompose.\n\n### Share this:\n\n  * Twitter\n  * Facebook\n\nLike Loading...\n\n### Related\n\nDiagrams for Penrose TilesSeptember 13, 2021In \"Haskell\"\n\nGraphs, Kites and Darts \u2013 Empires and SuperForceApril 26, 2023In \"Haskell\"\n\nGraphs, Kites and DartsJanuary 6, 2022In \"Haskell\"\n\nThis entry was posted in Haskell, Maths and tagged Dart, design, Haskell,\nHaskell Diagrams, Kite, math, Package, Penrose, programming, software, Tilings\non April 8, 2024 by readerunner.\n\n### Leave a comment Cancel reply\n\n### Recent Posts\n\n  * PenroseKiteDart User Guide\n  * Graphs, Kites and Darts \u2013 and Theorems\n  * Graphs, Kites and Darts \u2013 Empires and SuperForce\n  * Graphs, Kites and Darts\n  * Diagrams for Penrose Tiles\n\n### Recent Comments\n\nPenroseKiteDart User... on Graphs, Kites and Darts  \n---  \nPenroseKiteDart User... on Graphs, Kites and Darts...  \nPenroseKiteDart User... on Graphs, Kites and Darts...  \nGraphs, Kites and Da... on Graphs, Kites and Darts  \nGraphs, Kites and Da... on Diagrams for Penrose Tile...  \n  \n### Archives\n\n  * April 2024\n  * September 2023\n  * April 2023\n  * January 2022\n  * September 2021\n  * April 2014\n  * December 2013\n\n### Categories\n\n  * Haskell\n  * Maths\n\n### Meta\n\n  * Register\n  * Log in\n  * Entries feed\n  * Comments feed\n  * WordPress.com\n\nCreate a free website or blog at WordPress.com.\n\n  * Comment\n  * Reblog\n  * Subscribe Subscribed\n\n    * readerunner\n    * Already have a WordPress.com account? Log in now.\n\n  * Privacy\n  *     * readerunner\n    * Customize\n    * Subscribe Subscribed\n    * Sign up\n    * Log in\n    * Copy shortlink\n    * Report this content\n    * View post in Reader\n    * Manage subscriptions\n    * Collapse this bar\n\n%d\n\n", "frontpage": false}
