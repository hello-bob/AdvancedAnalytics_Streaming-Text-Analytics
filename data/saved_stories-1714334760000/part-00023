{"aid": "40187971", "title": "Zed Decoded: Rope and SumTree", "url": "https://zed.dev/blog/zed-decoded-rope-sumtree", "domain": "zed.dev", "votes": 4, "user": "avinassh", "posted_at": "2024-04-28 12:00:44", "comments": 0, "source_title": "Zed Decoded: Rope & SumTree", "source_text": "Zed Decoded: Rope & SumTree\n\n\u2190 Back to Blog\n\n# Zed Decoded: Rope & SumTree\n\nThorsten Ball\n\nNathan Sobo\n\nAntonio Scandurra\n\nMax Brunsfeld\n\nApril 23rd, 2024\n\nFor this second post in Zed Decoded, our blog & video series in which we're\ntaking a closer look at how Zed is built, I've talked to Zed's three co-\nfounders \u2014 Nathan, Max, Antonio \u2014 about the data structure at the heart of\nZed: the rope.\n\nCompanion Video: Rope & SumTree\n\nThis post comes with a 1hr companion video, in which Thorsten, Nathan,\nAntonio, and Max use Zed to look at how Zed uses the Rope and SumTree types.\nIt's a loose conversation in which we write and read a lot of code to\nunderstand how the rope in Zed works and is implemented.\n\nWatch the video here: https://youtu.be/uUu9eFNNbjg\n\nGoing in I knew that data structures to represent text are a favorite topic in\ntext editor circles. I had also used the Rope type in the Zed codebase and\nknew a little bit about ropes.\n\nWhat I didn't really understand was how Zed's rope is implemented and what\nthat implementation enables. So I asked Nathan, Max, and Antonio about it.\nThey've been writing code on top, below and inside the rope for years now.\nAnd, as it turns out, Zed's rope isn't really a rope, at least not in the\nclassical sense. It's very impressive, but first: what's a rope?\n\n## Why not a string?\n\nOne of the most important things a text editor has to do is to represent text\nin memory. When you open a file in a text editor, you expect to see its\ncontents and want to navigate through it, and \u2014 hey, that's where the name\ncomes from \u2014 you also want to edit the text.\n\nTo do that, a text editor has to load the file contents into memory \u2014 you\ncan't just let the user stare at the raw bytes on disk. You also want to keep\nit in memory, because not every change should immediately be saved to disk.\n\nSo the question is: how do you represent the text in memory?\n\nMy naive first choice would be to use a string. Good old string. Our best\nfriend from when we started programming. Why not use a string? It's how we\nrepresent text in memory all the time. It's not immediately obvious that that\nwould be a bad choice, right?\n\nHey, I bet you could go a long way with a string, but there are some problems\nwith strings that prevent them from being the best choice, especially once you\nstart dealing with large files and want your program to still be efficient and\nresponsive.\n\n### Problems with strings\n\nStrings are usually allocated as a continuous block of memory. That can make\nedits inefficient. Say you have a file with 20k lines in a string and you want\nto insert a word right in the middle of that string. In order to do that, you\nhave to make room for the new word in the middle of the string, so that you\nstill end up with a string that's a continuous block of memory. And to make\nroom, you have to move all of the text that would come after your newly\ninserted word. And moving here really means making allocations. In the worst\ncase you have to move everything \u2014 all 20k lines \u2014 to make room for your new\nword.\n\nOr say you want to delete a word: you can't just poke a hole in a string,\nbecause that would mean it isn't a string \u2014 a continuous block of memory \u2014\nanymore. Instead you have to move all the characters except the ones you\ndeleted, so that you end up with a single, continuous block of memory again,\nthis time without the deleted word.\n\nWhen dealing with small files and small strings, these aren't problems. We all\ndo similar string operations all day every day, right? Yes, but most of the\ntime we're talking about relatively small strings. When you're dealing with\nlarge files and thus large strings or a lot of edits (maybe even at the same\ntime \u2014 hello multiple cursors!) these things \u2014 allocations, moving strings in\nmemory \u2014 become problems.\n\nAnd that's not even touching on all the other requirements a text editor might\nhave of its text representation.\n\nNavigation, for example. What if the user wants to jump to line 523? With a\nstring and without any other data, you'd have to go through the string,\ncharacter by character, and count the line breaks in it to find out where in\nthe string line 523 is. And then what if the user presses the down-arrow ten\ntimes to go down ten lines and wants to end up in the same column? You'll\nagain have to start counting line breaks in your string and then find the\nright offset after the last line break.\n\nOr, say you want to draw a horizontal scrollbar at the bottom of your editor.\nTo know how big the scroll thumb has to be, you have to know how long the\nlongest line in the file is. Same thing again: you have to go through the\nstring and count the lines and this time keeping track of the length of each\nline too.\n\nOr what if the text file you want to load into your editor is larger than 1GB\nand the language you used to implement your text editor can only represent\nstrings up to 1GB? You might say \"1GB of string should be enough for\neverybody\" but that only tells me you haven't talked to enough users of text\neditors yet.\n\nKidding aside, I think we've established that strings probably aren't the best\nsolution to represent text in a text editor.\n\nSo what else can we use?\n\n## What's better than a string?\n\nIf you really love strings, you might now be thinking \"better than a string?\neasy: multiple strings.\" And you wouldn't be that far off! Some editors do\nrepresent text as an array-of-lines with each line being a string. VS Code's\nMonaco editor worked that way for quite a while, but an array of strings can\nstill be plagued by the same problems as a single string. Excessive memory\nconsumption and performance issues made the VS Code team look for something\nbetter.\n\nLuckily, there are better things than strings. Builders of text editors have\nlong ago realized that strings aren't the best tool for the job and have come\nup with other data structures to represent text.\n\nThe most popular ones, as far as I can tell, are gap buffers, piece tables,\nand ropes.\n\nThey each have their pros and cons and I'm not here to compare them in detail.\nIt's enough to know that they are all significantly better than strings and\ndifferent editors made different decisions in face of different trade-offs and\nended up with different data structures. To give you a taste: Emacs uses gap\nbuffers, VS Code uses a twist on piece tables, Vim has its own tree data\nstructure, and Helix uses a rope.\n\nZed, too, uses a rope. So let's take a look at the rope and see what\nadvantages that has over a string.\n\n## Ropes\n\nHere's how Wikipedia explains what a rope is:\n\n> A rope is a type of binary tree where each leaf (end node) holds a string\n> and a length (also known as a \"weight\"), and each node further up the tree\n> holds the sum of the lengths of all the leaves in its left subtree.\n\nInstead of a continuous block of memory, a rope is a tree and its leaves are\nthe characters of the text it represents.\n\nHere's what the text \"This is a rope\" would look like in a rope:\n\nA rope representing \"This is a rope\"\n\nYou might now be thinking that this is a lot more complex than a string and\nyou'd be right \u2014 it is. But here's the crucial bit that makes this a rope\ntriumph over strings in many cases: the leaves - \"This\", \" is \", \"a \", \"rope\"\n\u2014 are essentially immutable. Instead of modifying strings, you modify the\ntree. Instead of poking holes in strings and moving parts of it around it\nmemory, you modify the tree to get a new string. And by now, we as programmers\nhave figured out how to efficiently work with trees.\n\nLet's use the example from above again: deleting a word at a certain position\nin the text. With a string, you'd have to reallocate all of the text that\ncomes after the word, possibly the whole string. With a rope, you find the\nstart and end positions of the word you want to delete, then split the tree at\nthese two positions so you have four trees, you throw away the middle two\ntrees (that only contain the deleted word), concatenate the other two, then\nrebalance the tree. Yes, it does sound like a lot and it does require some\nalgorithmic finesse under the hood, but the memory and performance\nimprovements over strings are very real: instead of moving things around in\nmemory, you only have to update a few pointers. That might look silly for a\ntext as short as \"This is a rope\", but it pays off big time when you have very\nlarge texts.\n\nI understand that this is very abstract, so let me show you. Let's take a look\nat Zed's rope implementation.\n\n## Zed's rope implementation\n\nZed has its own rope implementation in its own crate: rope. (One reason for\nwhy Zed has its own implementation instead of using a library is that a lot of\nlibraries didn't exist when the Zed founders laid the groundwork for Zed in\n2017.)\n\nThe main type in the rope crate is Rope. Here's how you'd use it:\n\n    \n    \n    let mut rope = Rope::new(); rope.push(\"Hello World! This is your captain speaking.\");\n\nSo far, so similar to String. Now let's say we have two ropes:\n\n    \n    \n    let mut rope1 = Rope::new(); rope1.push(\"Hello World!\"); let mut rope2 = Rope::new(); rope2.push(\"This is your captain speaking.\");\n\nIf we want to concatenate them, all we have to do is this:\n\n    \n    \n    rope1.append(rope2); assert_eq!( rope1.text(), \"Hello World! This is your captain speaking.\".to_string() );\n\nThe call to rope1.append connects the two trees \u2014 rope1 and rope2 \u2014 by\nbuilding a new tree that contains both. That's barely more than updating a few\npointers. Compare that to strings: if you concatenate two strings, you'll have\nto move at least one of them in memory so that they end up next to each,\nforming a continuous block. Often you have to move both of them, because\nthere's not enough space after the first string. Again: the text in this\nexample is laughably short, but what if someone wants to have ten copies of\nthe 25k line SQLite amalgamation in a single file?\n\nWhat about replacing a word?\n\n    \n    \n    // Construct a rope let mut rope = Rope::new(); rope.push(\"One coffee, please. Black, yes.\"); // Replace characters 4 to 10 (0-indexed) with \"guinness\". rope.replace(4..10, \"guinness\"); assert_eq!(rope.text(), \"One guinness, please. Black, yes.\");\n\nWhat happens under the hood:\n\n  * replace() creates a new rope that contains all of the nodes of the original rope, up until the 5th character (c)\n  * the new text, guinness, is appended to the new rope\n  * the rest of the original rope, everything after character 11, is appended to the new rope\n\nDeleting a word? Just replace it with \"\":\n\n    \n    \n    let mut rope = Rope::new(); rope.push(\"One coffee, please. Black, yes.\"); rope.replace(4..10, \"\");\n\nThese operations are very quick even when dealing with large amounts of text,\nbecause then most of the nodes in the tree can be reused and only have to be\nrewired.\n\nBut what happens with the word that was deleted, \"coffee\"? The leaf nodes that\ncontain these characters will get automatically cleaned up as soon as no other\nnode references them anymore. That's what immutable leaf nodes in ropes\nenable: when a rope is mutated, or a new rope is constructed from an old one,\nor two ropes are merged into a new one, essentially all that's changing are\nreferences to leaf nodes. And those references are counted: as soon as there's\nno reference to a node anymore, the node gets cleaned up, deallocated.\n\nTo be precise and get technical: the leaf nodes, the ones containing the\nactual text, aren't fully immutable in Zed's rope implementation. These leaf\nnodes have a maximum length and if, say, text gets appended to a rope and the\nnew text is short enough to fit into the last leaf node without exceeding its\nmaximum length, then that leaf node will be mutated and the text appended to\nit.\n\nOn a conceptual level, though, you can think of the rope as a persistent data\nstructure and its nodes as reference-counted immutable nodes in a tree. That's\nwhat makes it a better choice than the string and brings us back to the\nquestion we skipped above: why did Zed chose a rope instead of one of the\nother data structures?\n\n## Why use a rope in Zed?\n\nZed's goal is to be a high-performance code editor. Strings, as we saw, won't\nget you to high-performance. So what do you use instead? Gap buffers, ropes,\npiece tables?\n\nThere isn't a single, obvious best choice here. It all comes down to specific\nrequirements and trade-offs you're willing to make to meet those requirements.\n\nMaybe you've heard that gap buffers can be faster than ropes, or that they're\neasier to understand, or that piece tables are more elegant. That may be true,\nyes, but that still doesn't mean they're an obvious choice over, for example,\na rope. Here's what the author of ropey, a popular rope implementation in\nRust, wrote about the performance trade-offs between ropes and gap buffers:\n\n> Ropes make a different performance trade-off, being a sort of \"jack of all\n> trades\". They're not amazing at anything, but they're always solidly good\n> with O(log N) performance. They're not the best choice for an editor that\n> only supports local editing patterns, since they leave a lot of performance\n> on the table compared to gap buffers in that case (again, even for huge\n> documents). But for an editor that encourages non-localized edits, or just\n> wants flexibility in that regard, they're a great choice because they always\n> have good performance, whereas gap buffers degrade poorly with unfavorable\n> editing patterns.\n\nRopes are \"not amazing at anything, but they're always solidly good.\" It\ndepends on what you want to do, or what you want your editor to be able to do.\n\nSo what if you really want to make use of all the cores in your CPU? In \"Text\nshowdown: Gap Buffers vs Ropes\" concurrency is mentioned in a paragraph at the\nend:\n\n> Ropes have other benefits besides good performance. Both Crop and Ropey\n> [note: both are rope implementations in Rust] support concurrent access from\n> multiple threads. This lets you take snapshots to do asynchronous saves,\n> backups, or multi-user edits. This isn't something you could easily do with\n> a gap buffer.\n\nIn the companion video you can hear what Max said about this paragraph: \"Yeah,\nit matters more than any of that other stuff.\" Nathan added that \"we use that\nall over the place\", with \"that\" being concurrent access, snapshots, multi-\nuser edits, asynchronous operations.\n\nIn other words: concurrent access to the text in a buffer was a hard\nrequirement for Zed and that's why the rope ended up being the top choice.\n\nHere's an example of how deeply ingrained concurrent access to text is into\nZed: when you edit a buffer in Zed, with syntax highlighting enabled, a\nsnapshot of the buffer's text content is sent to a background thread in which\nit's re-parsed using Tree-sitter. That happens on every edit and it's very,\nvery fast and efficient, since the snapshots don't require a full copy of the\ntext. All that's needed is to bump a reference count, because the reference-\ncounting for the nodes in Zed's rope is implemented with Arc, Rust's \"thread-\nsafe reference-counting pointer\".\n\nThat brings us to the most important bit: how Zed's rope is implemented.\nBecause it isn't implemented like the classic rope you see on Wikipedia and\nits implementation gives Zed's rope certain properties that other rope\nimplementations might not have and that implementation is actually what put\nthe rope ahead of other data structures.\n\n## It's not a rope, it's a SumTree\n\nZed's rope is not a classic binary-tree rope, it's a SumTree. If you open up\nthe definition of Zed's Rope, you'll see that it's nothing more than a SumTree\nof Chunks:\n\n    \n    \n    struct Rope { chunks: SumTree<Chunk>, } struct Chunk(ArrayString<{ 2 * CHUNK_BASE }>);\n\nA Chunk is an ArrayString, which comes from the arrayvec crate and allows\nstoring strings inline and not on the heap somewhere else. Meaning: a Chunk is\na collection of characters. Chunks are the leafs in the SumTree and contain at\nmost 2 * CHUNK_BASE characters. In release builds of Zed, CHUNK_BASE is 64.\n\nSo then what is a SumTree? Ask Nathan and he'll say that the SumTree is \"the\nsoul of Zed\". But a slightly more technical description of a SumTree is this:\n\nA SumTree<T> is a B+ tree in which each leaf node contains multiple items of\ntype T and a Summary for each Item. Internal nodes contain a Summary of the\nitems in its subtree.\n\nAnd here are the type definitions to match, which you can find in the sum_tree\ncrate:\n\n    \n    \n    struct SumTree<T: Item>(pub Arc<Node<T>>); enum Node<T: Item> { Internal { height: u8, summary: T::Summary, child_summaries: ArrayVec<T::Summary, { 2 * TREE_BASE }>, child_trees: ArrayVec<SumTree<T>, { 2 * TREE_BASE }>, }, Leaf { summary: T::Summary, items: ArrayVec<T, { 2 * TREE_BASE }>, item_summaries: ArrayVec<T::Summary, { 2 * TREE_BASE }>, }, } trait Item: Clone { type Summary: Summary; fn summary(&self) -> Self::Summary; }\n\nSo what's a Summary? Anything you want! The only requirement is that you need\nto be able to add multiple summaries together, to create a sum of summaries:\n\n    \n    \n    trait Summary: Default + Clone + fmt::Debug { type Context; fn add_summary(&mut self, summary: &Self, cx: &Self::Context); }\n\nBut I know you just rolled your eyes at that, so let's make it more concrete.\n\nSince the Rope is a SumTree and each item in the SumTree has to have a\nsummary, here's the Summary that's associated with each node in Zed's Rope:\n\n    \n    \n    struct TextSummary { /// Length in UTF-8 len: usize, /// Length in UTF-16 code units len_utf16: OffsetUtf16, /// A point representing the number of lines and the length of the last line lines: Point, /// How many `char`s are in the first line first_line_chars: u32, /// How many `char`s are in the last line last_line_chars: u32, /// How many UTF-16 code units are in the last line last_line_len_utf16: u32, /// The row idx of the longest row longest_row: u32, /// How many `char`s are in the longest row longest_row_chars: u32, }\n\nAll nodes in the SumTree \u2014 internal and leaf nodes \u2014 have such a summary,\ncontaining information about its subtree. The leaf nodes have a summary of\ntheir Chunks and the internal nodes have a summary that is the sum of the\nsummaries of its child nodes, recursively down the tree.\n\nLet's say we have the following text:\n\n    \n    \n    Hello World! This is your captain speaking. Are you ready for take-off?\n\n5 lines of text. If this is pushed into a Zed Rope, the SumTree beneath the\nRope would look like this, simplified:\n\nA SumTree representing \"Hello World!\\nThis is\\nyour captain speaking.\\nAre\nyou\\nready for take-off?\\n\" with some summary fields left out\n\n(I left out some of the fields of TextSummary to keep the diagram small-ish\nand also adjusted the maximum size of the chunks and maximum number of\nchildren per node. In a release-build of Zed, all five lines of the text would\nfit in a single node.)\n\nEven with only three summary fields \u2014 len, lines, longest_row_chars \u2014 we can\nsee that the summaries of the internal nodes are the sum of their child nodes\nsummaries.\n\nThe root node's summary tells us about the complete text, the complete Rope:\n72 characters, 5 lines, and the longest line has 22 characters (your captain\nspeaking.\\n). The internal nodes tell is about parts of the text. The left\ninternal node here tells us, for example, that it's 38 characters from \"Hell\"\nto \"spea\" (including newline characters) and that there are two line breaks in\nthat part of the text.\n\nOkay, you might be thinking, a B+ tree with summarized summaries \u2014 what does\nthat buy us?\n\n## Traversing a SumTree\n\nThe SumTree is a concurrency-friendly B-tree that not only gives us a\npersistent, copy-on-write data structure to represent text, but through its\nsummaries it also indexes the data in the tree and allows us to traverse the\ntree along dimensions of the summaries in O(log n) time.\n\nIn Max's words, the SumTree is \"not conceptually a map. It's more like a Vec\nthat has these special indexing features where you can store any sequence of\nitems you want. You decide the order and it just provides these capabilities\nto seek and slice.\"\n\nDon't think of it as a tree that allows you to lookup values associated with\nkeys (although it can do that), but think of it as a tree that allows you\nlookup items based on the summaries of each item and all the items that come\nbefore it in the tree.\n\nOr, in other words: the items in a SumTree are ordered. Their summaries are\nalso ordered. The SumTree allows you find any item in the tree in O(log N)\ntime by traversing the tree from root to leaf node and deciding which node to\nvisit based on the node's summary.\n\nSay we have a Rope with three lines of text in it:\n\n    \n    \n    let mut rope = Rope::new(); rope.push(\"Line one.\\n\"); rope.push(\"This is the second line.\\n\"); rope.push(\"This is three.\\n\");\n\nOnce the Rope is constructed, it looks like this:\n\nA SumTree representing \"Line one.\\nThis is the second line.\\nThis is three.\\n\"\nwith some summary fields left out\n\nLike we said above: each leaf node will hold multiple Chunks and each leaf\nnode's summary will contain information about the text in its Chunks. The type\nof that summary is TextSummary from above. That means each node's summary can\ntell us about the len of the text in its chunks, the lines & rows in them, the\nlongest line, and all the other fields of TextSummary. The internal nodes in\nthe SumTree then contain summaries of the summaries.\n\nAnd since the items in the tree \u2014 internal nodes, leaf nodes, chunks \u2014 are\nordered we can traverse that tree very efficiently, because the SumTree allows\nus to traverse the tree based on the values in the summaries. It allows us to\nseek along a single dimension, a single field for example, of a given summary.\n\nSay we want to find out what the line and column in the rope is at the\nabsolute offset 26. Meaning: what's at character 26? In order to find out, we\ncan traverse this three-line rope along the len field of the TextSummary.\nBecause the len field, when added up from left to right, is an absolute\noffset. So in order to find what's at absolute offset 26, we traverse down the\ntree, taking left or right turns, depending on the len value in the summaries\nof the internal nodes, until we end up at the leaf node we want:\n\n    \n    \n    let point = rope.offset_to_point(26); assert_eq!(point.row, 1); assert_eq!(point.column, 16);\n\nOn the surface, the call to rope.offset_to_point(30) converts an absolute\n0-based offset (26) into a row and column (1 and 16). What happens inside of\noffset_to_point is that a cursor traverses the SumTree until it finds the\nitems where the aggregated len of the TextSummary is >= 26. Once it found the\nfirst leaf node where that's true, it finds the exact chunk where the offset\nmatches and parks the cursor there. On the way there, it not only kept\ncounting the len field of the summaries it came across, but it also aggregated\nthe lines field, which contains row and column. Neat, right?\n\nHere's what I just described but in actual code, here's the offset_to_point\nmethod on the Rope:\n\n    \n    \n    fn offset_to_point(&self, offset: usize) -> Point { if offset >= self.summary().len { return self.summary().lines; } let mut cursor = self.chunks.cursor::<(usize, Point)>(); cursor.seek(&offset, Bias::Left, &()); let overshoot = offset - cursor.start().0; cursor.start().1 + cursor .item() .map_or(Point::zero(), |chunk| chunk.offset_to_point(overshoot)) }\n\nWhat it does is the following:\n\n  * sanity checks that the offset isn't past the end of the whole Rope\n  * creates a cursor that seeks along the usize (offset) and Point (a Point is a struct with two fields: row and column) dimensions, aggregating both while doing that\n  * once it found an item at offset, it calculates the overshoot: the offset we're looking for might be in the middle of a single chunk and cursor.start().0 is the usize (offset) at the start of a given chunk\n  * take the lines up to the start of the current chunk (cursor.start().1) \u2014 which is the summary of TextSummary.len of the complete tree to the left of the current item!\n  * add them to the lines at the offset in the, possibly, middle of the chunk (chunk.offset_to_point(overshoot))\n\nThe most interesting bit here is, of course, the cursor that's constructed\nwith self.chunks.cursor::<(usize, Point)>(). This particular cursor has two\ndimensions and allows you to seek to a value on one dimension (usize) in the\ngiven SumTree and in the same operation also get the sum of the second\ndimension, the Point, at a particular cursor position.\n\nThe beauty of that is that it can do that in O(log N) time, because each\ninternal node contains a summary of summaries (meaning: the total len of all\nitems in its subtree in this case) and it can skip over all of those where len\n< 26\\. In the diagram above, you can see that we don't even have to traverse\nthe first two leaf nodes.\n\nIsn't that amazing? There's more.\n\n## Using the SumTree\n\nYou can also traverse the SumTree the other way around, seeking along\nlines/rows and getting the final offset:\n\n    \n    \n    // Go from offset to point: let point = rope.offset_to_point(55); assert_eq!(point.row, 2); assert_eq!(point.column, 6); // Go from point to offset: let offset = rope.point_to_offset(Point::new(2, 6)); assert_eq!(offset, 55);\n\nAnd \u2014 you probably guessed it \u2014 point_to_offset looks exactly like\noffset_to_point, except that the dimensions with which the cursor is\nconstructed are flipped:\n\n    \n    \n    fn point_to_offset(&self, point: Point) -> usize { if point >= self.summary().lines { return self.summary().len; } let mut cursor = self.chunks.cursor::<(Point, usize)>(); cursor.seek(&point, Bias::Left, &()); let overshoot = point - cursor.start().0; cursor.start().1 + cursor .item() .map_or(0, |chunk| chunk.point_to_offset(overshoot)) }\n\nThis seeking along one dimension and aggregating (summarizing!) along multiple\ndimensions is made possible by some very clever Rust code that I won't explain\nin detail, but the short version is this.\n\nGiven a TextSummary like the following (which we already saw in full above)\nand a ChunkSummary that wraps it...\n\n    \n    \n    struct TextSummary { len: usize, lines: Point, // [...] } struct ChunkSummary { text: TextSummary, }\n\n... we can define the len and lines fields as sum_tree::Dimensions:\n\n    \n    \n    impl<'a> sum_tree::Dimension<'a, ChunkSummary> for usize { fn add_summary(&mut self, summary: &'a ChunkSummary, _: &()) { *self += summary.text.len; } } impl<'a> sum_tree::Dimension<'a, ChunkSummary> for Point { fn add_summary(&mut self, summary: &'a ChunkSummary, _: &()) { *self += summary.text.lines; } }\n\nWith that we can then construct cursors for a given sum_tree::Dimension or a\ntuple of dimensions (which is what we did above with (usize, Point)).\n\nOnce constructed, the cursor can then seek along any Dimension we have defined\nand aggregate either the complete TextSummary or just a single Dimension of a\ngiven summary type.\n\nOr we can also seek along a single dimension and then get the whole summary\nonce the cursor has found the target:\n\n    \n    \n    let mut rope = Rope::new(); rope.push(\"This is the first line.\\n\"); rope.push(\"This is the second line.\\n\"); rope.push(\"This is the third line.\\n\"); // Construct cursor: let mut cursor = rope.cursor(0); // Seek it to offset 55 and get the `TextSummary` at that offset: let summary = cursor.summary::<TextSummary>(55); assert_eq!(summary.len, 55); assert_eq!(summary.lines, Point::new(2, 6)); assert_eq!(summary.longest_row_chars, 24);\n\nThe cursor stopped in the middle of line 2, at column 6, and up until that\nlocation the longest_row_chars in the summaries was 24.\n\nThis is very, very powerful stuff. To scratch the surface: it allows us to\neasily convert between UTF8 rows/columns and UTF16 rows/columns, which is\nsometimes required when working with the language server protocol (LSP). Just\nseek to a UTF8 Point and aggregate the UTF16 Points:\n\n    \n    \n    fn point_to_point_utf16(&self, point: Point) -> PointUtf16 { if point >= self.summary().lines { return self.summary().lines_utf16(); } let mut cursor = self.chunks.cursor::<(Point, PointUtf16)>(); cursor.seek(&point, Bias::Left, &()); // ... you know the rest ... }\n\nBut there's more and I could go on and on and on and show more examples or use\nbig words like monoid homomorphism, but I'll stop here. You get the idea \u2014 the\nSumTree, a thread-safe, snapshot-friendly, copy-on-write B+ tree is very\npowerful and can be used for more than \"just\" text, which is why it's\neverywhere in Zed. Yes, literally.\n\n## Everything's a SumTree\n\nCurrently there are over 20 uses of the SumTree in Zed. The SumTree is not\nonly used as the basis for the Rope, but in many different places. The list of\nfiles in a project is a SumTree. The information returned by git blame is\nstored in a SumTree. Messages in the chat channel: SumTree. Diagnostics:\nSumTree.\n\nAt the very core of Zed sits a data structured called DisplayMap that contains\nall the information about how a given buffer of text should be displayed \u2014\nwhere the folds go, which lines wrap, where the inlay hints are displayed, ...\n\u2014 and it looks like this:\n\n    \n    \n    struct DisplayMap { /// The buffer that we are displaying. buffer: Model<MultiBuffer>, /// Decides where the [`Inlay`]s should be displayed. inlay_map: InlayMap, /// Decides where the fold indicators should be and tracks parts of a source file that are currently folded. fold_map: FoldMap, /// Keeps track of hard tabs in a buffer. tab_map: TabMap, /// Handles soft wrapping. wrap_map: Model<WrapMap>, /// Tracks custom blocks such as diagnostics that should be displayed within buffer. block_map: BlockMap, /// Regions of text that should be highlighted. text_highlights: TextHighlights, /// Regions of inlays that should be highlighted. inlay_highlights: InlayHighlights, // [...] }\n\nGuess what? All of these use a SumTree under the hood and in a future post we\nwill explore them, but the point I want to make now is this:\n\nThe Zed co-founders didn't so much decide to use a rope over a gap buffer or\nover a piece table. They started with the SumTree, recognized how powerful it\nis, how it fits Zed's requirements, and then built the rope on top of it.\n\nThe rope may be at the heart of Zed, but the SumTree is, to quote Nathan\nagain, \"the soul of Zed\".\n\n### Looking for a better editor?\n\nYou can try Zed today on macOS. Download now!\n\n### We are hiring!\n\nIf you're passionate about the topics we cover on our blog, please consider\njoining our team to help us ship the future of software development.\n\nThorsten Ball\n\nNathan Sobo\n\nAntonio Scandurra\n\nMax Brunsfeld\n\n04/23/24\n\n\u00a9 2024 Zed Industries.\n\nEULA \u00b7 Attributions \u00b7 Sign in\n\n#### Product\n\n  * Download\n  * FAQ\n  * Roadmap\n  * EULA\n  * CLA\n\n#### Developers\n\n  * Docs\n  * Releases\n  * GitHub\u2197\n  * Status\u2197\n\n#### Community\n\n  * Blog\n  * Feedback\n  * Discussions\u2197\n  * Merch\u2197\n\n#### Company\n\n  * About\n  * Team\n  * Jobs\n  * Twitter\u2197\n\n", "frontpage": true}
