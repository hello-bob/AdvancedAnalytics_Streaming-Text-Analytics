{"aid": "40082704", "title": "Configuration: Prefs, Settings, Features, Switches and Flags", "url": "https://chromium.googlesource.com/chromium/src/+/main/docs/configuration.md", "domain": "googlesource.com", "votes": 2, "user": "keepamovin", "posted_at": "2024-04-19 01:50:01", "comments": 0, "source_title": "Chromium Docs - Configuration: Prefs, Settings, Features, Switches & Flags", "source_text": "Chromium Docs - Configuration: Prefs, Settings, Features, Switches & Flags\n\nChromium Docs\n\n# Configuration: Prefs, Settings, Features, Switches & Flags\n\nThis document outlines all the runtime configuration surfaces of Chromium, and\ndiscusses appropriate uses and standard patterns for each of them. Some of\nthese are intended for use by users, some by developers, and some by system\nadministrators.\n\n## Contents\n\n  * Prefs\n  * Features\n  * Switches\n  * Flags\n  * Settings\n  * Summary Table\n  * Related Documents\n\n## Prefs\n\nExample: prefs::kAllowDinosaurEasterEgg aka \u201callow_dinosaur_easter_egg\u201d\n\nPrefs are implemented by registering them with a central pref service, usually\nvia Profile::RegisterProfilePrefs. They store typed values, which persist\nacross restarts and may be synced between browser instances via the Sync\nservice. There are several pref stores, which are documented in detail in the\nprefs docs. They can be directly configured via enterprise policy.\n\nPrefs:\n\n  * Are not directly surfaced to the user\n  * Are not localized into the user's language\n  * Are configurable via enterprise policy if a policy exists for the pref (there is no catch-all policy that allows setting arbitrary prefs)\n  * Are not reported via UMA when in use\n  * Are not included in chrome://version\n  * Are automatically persistent across restarts (usually)\n\n## Features\n\nExample: base::kDCheckIsFatalFeature\n\nThese are implemented via creating a base::Feature anywhere. These can be\nenabled via server-side experimentation or via the command-line using\n\u201c--enable-features\u201d. Which features are in use is tracked by UMA metrics, and\nis visible in chrome://version as the \u201cVariations\u201d field. Do note that in\nrelease builds, only a series of hashes show up in chrome://version rather\nthan the string names of the variations, but these hashes can be turned back\ninto string names if needed. This is done by consulting the testing config for\nChromium builds, or a Google-internal tool for Chrome builds.\n\nFeatures are the best way to add runtime conditional behavior.\n\nFeatures:\n\n  * Are not directly surfaced to the user\n  * Are not localized into the user's language\n  * Are not configurable via enterprise policy\n  * Are reported via UMA/crash when in use\n  * Are included in chrome://version\n  * Are not automatically persistent across restarts\n\n## Switches\n\nExample: switches::kIncognito aka \u201c--incognito\u201d\n\nThese are implemented by testing anywhere in the codebase for the presence or\nvalue of a switch in base::CommandLine::ForCurrentProcess. There is no\ncentralized registry of switches and they can be used for essentially any\npurpose.\n\nSwitches:\n\n  * Are not directly surfaced to the user\n  * Are not localized into the user's language\n  * Are not configurable via enterprise policy (except on Chrome OS, via FeatureFlagsProto)\n  * Are not reported via UMA when in use\n  * Are included in chrome://version\n  * Are not automatically persistent across restarts\n\nIn general, switches are inferior to use of base::Feature, which has the same\ncapabilities and low engineering overhead but ties into UMA reporting. New\ncode should use base::Feature instead of switches. An exception to this is\nwhen the configuration value is a string, since features can't take an\narbitrary string value.\n\n## Flags\n\nExample: chrome://flags/#ignore-gpu-blocklist\n\nThese are implemented by adding an entry in about_flags.cc describing the\nflag, as well as metadata in flag-metadata. Flags have a name and description,\nand show up in chrome://flags. Flags also have an expiration milestone, after\nwhich they will be hidden from that UI and disabled, then later removed. Flags\nare backed by either a feature or a set of switches, which they enable at\nbrowser startup depending on the value of the flag.\n\nFlags should usually be temporary, to allow for pre-launch testing of a\nfeature. Permanent flags (those with expiration -1) should only be used when\neither:\n\n  * The flag is regularly used for support/debugging purposes, by asking users to flip it to eliminate a possible problem (such as ignore-gpu-blocklist)\n  * The flag is used for ongoing QA/test purposes in environments where command-line switches can't be used (e.g. on mobile)\n\n\u201cUsers might need to turn the feature on/off\u201d is not a sufficient\njustification for a permanent flag. If at all possible, we should design\nfeatures such that users don't want or need to turn them off, but if we need\nto retain that choice, we should promote it to a full setting (see below) with\ntranslations and support. \u201cDevelopers/QA might need to turn the feature\non/off\u201d, on the other hand, is justification for a permanent flag.\n\nFlags:\n\n  * Are directly surfaced to the user\n  * Are not localized into the user's language\n  * Are not configurable via enterprise policy\n  * Are reported via UMA when in use (via Launch.FlagsAtStartup)\n  * Are not included in chrome://version\n  * Are automatically persistent across restarts\n\n## Settings\n\nExample: \u201cShow home button\u201d\n\nSettings are implemented in WebUI, and show up in chrome://settings or one of\nits subpages. They generally are bound to a pref which stores the value of\nthat setting. These are comparatively expensive to add, since they require\nlocalization and some amount of UX involvement to figure out how to fit them\ninto chrome://settings, plus documentation and support material. Many settings\nare implemented via prefs, but not all prefs correspond to settings; some are\nused for tracking internal browser state across restarts.\n\nSettings:\n\n  * Are directly surfaced to the user\n  * Are localized into the user's language\n  * Are not configurable via enterprise policy (but their backing prefs may be)\n  * Are not reported via UMA when in use\n  * Are not included in chrome://version\n  * Are automatically persistent across restarts (via their backing prefs)\n\nYou should add a setting if end-users might want to change this behavior. A\ndecent litmus test for whether something should be a flag or a setting is:\n\u201cwill someone who can't read or write code want to change this?\u201d\n\n## Summary Table\n\nPrefs| Features| Switches| Flags| Settings  \n---|---|---|---|---  \nDirectly surfaced to the user| \u274c| \u274c| \u274c| \u2705| \u2705  \nLocalized into the user's language| \u274c| \u274c| \u274c| \u274c| \u2705  \nConfigurable via enterprise policy| \u2705 if a policy maps to the pref| \u274c| \u274c\nexcept on ChromeOS| \u274c| \u274c but their backing prefs may be  \nReported when in use| \u274c| via UMA/crash| \u274c| via UMA Launch.FlagsAtStartup| \u274c  \nIncluded in chrome://version| \u274c| \u2705| \u2705| \u274c| \u274c  \nAutomatically persistent across restarts| \u2705 usually| \u274c| \u274c| \u2705| \u2705 via backing\nprefs  \n  \n## Related Documents\n\n  * Chromium Feature API & Finch (Googler-only)\n  * Adding a new feature flag in chrome://flags\n  * Runtime Enabled Features\n  * Initialization of Blink runtime features in content layer\n  * Integrating a feature with the origin trials framework\n\nPowered by Gitiles| Privacy| Terms\n\n", "frontpage": false}
