{"aid": "40153721", "title": "Pruning some things out with (GNU) find options", "url": "https://utcc.utoronto.ca/~cks/space/blog/sysadmin/FindPruningThingsOut", "domain": "utcc.utoronto.ca", "votes": 1, "user": "ingve", "posted_at": "2024-04-25 05:19:58", "comments": 0, "source_title": "Chris's Wiki :: blog/sysadmin/FindPruningThingsOut", "source_text": "Chris's Wiki :: blog/sysadmin/FindPruningThingsOut\n\nChris Siebenmann :: CSpace \u00bb blog \u00bb sysadmin \u00bb FindPruningThingsOut\n\nWelcome, guest.\n\n## Pruning some things out with (GNU) find options\n\nApril 24, 2024\n\nSuppose that you need to scan your filesystems and pass some files with\nspecific names, ownerships, or whatever, except that you want to exclude\nscanning under /tmp and /var/tmp (as illustrative examples). Perhaps also\nyou're feeding the file names to a shell script, especially in a pipeline,\nwhich means that you'd like to screen out directory and file names that have\n(common) problem characters in them, like spaces.\n\n(If you can use Bash for your shell script, the latter problem can be dealt\nwith because you can get Bash to read NUL-terminated lines that can be\nproduced by 'find ... -print0'.)\n\nExcluding things from 'find' results is done with find's -prune action, which\nis a little bit tricky to use when you want to exclude absolute paths (well\nokay it's a little bit tricky in general; see this SO question and answers).\nTo start with, you're going to want to generate a list of filesystems and then\nscan them by absolute path:\n\n>\n>     FSES=\"$(... something ...)\" for fs in $FSES; do find \"$fs\" -xdev [...\n> magic ...] done\n\nStarting with an absolute path to the filesystem (instead of cd'ing into the\nroot of the filesystem and doing 'find . -xdev [...]' means that we can now\nuse absolute paths in find's -path argument instead of ones relative to the\nfilesystem root:\n\n>\n>     find \"$fs\" -xdev '(' -path /tmp -o -path /var/tmp ')' -prune -o ....\n\nWith absolute paths, we don't have to worry about what if /var or /tmp (or\n/var/tmp) are separate filesystems, instead of being directories on the root\nfilesystem. Although it's hard to work out without experimentation, -xdev and\n-prune combine the way we want.\n\n(If we're running 'find' on a filesystem that doesn't contain either /tmp or\n/var/tmp, we'll waste a bit of CPU time having 'find' evaluate those -path\narguments all the time despite it never being possible for them to match. This\nis unimportant when compared to having a simpler, less error prone script.)\n\nIf we want to exclude paths with spaces in them, this is easily done with\n'-name \"* *\"'. If we want to get all whitespace, we need GNU Find and its\n'-regex' argument, documented best in \"Regular Expressions\" in the info\ndocumentation. Because we want to use a character class to match whitespace,\nwe need to use one of the regular expression types that include this, so:\n\n>\n>     find \"$fs\" -regextype grep ... -regex '.*[[:space:]].*' ...\n\nOn the whole, 'find' is an awkward tool to use for this sort of filtering.\nUnfortunately it's sometimes what we turn to because our other options involve\nthings like writing programs that consume and filter NUL-terminated file\npaths.\n\n(And having 'find' skip entire directory trees is more efficient than letting\nit descend into them, print all their file paths, and then filtering the file\npaths out later.)\n\nPS: One of the little annoyances of Unix for system administrators is that so\nmany things in a stock Unix environment fall apart the moment people start\nputting odd characters in file names, unless you take extreme care and use\nunusual tools. This often affects sysadmins because we frequently have to deal\nwith other people's almost arbitrary choices of file and directory names, and\nwe may be dealing with actively malicious attackers for extra concern.\n\n### Sidebar: Reading null-terminated lines in Bash\n\nBash's version of the 'read' builtin supports a '-d' argument that can be used\nto read NUL-terminated lines:\n\n>\n>     while IFS= read -r -d'' line; do [ ... use \"$line\" ... ] done\n\nYou still have to properly quote \"$line\" in every single use, especially as\nyou're doing this because you expect your lines to (or filenames) to sometimes\ncontain troublesome characters. You should definitely use Shellcheck and pay\nclose attention to its warnings (they're good for you).\n\nWritten on 24 April 2024.\n\n| \u00ab| Libvirt's virt-viewer and (guest) screen blanking  \n---|---  \n  \nThese are my WanderingThoughts (About the blog)\n\nFull index of entries Recent comments\n\nThis is part of CSpace, and is written by ChrisSiebenmann. Mastodon: @cks\nTwitter @thatcks\n\n* * *\n\nCategories: links, linux, programming, python, snark, solaris, spam, sysadmin,\ntech, unix, web Also: (Sub)topics\n\nThis is a DWiki. GettingAround (Help)\n\nPage tools: View Source, Add Comment.\n\nAtom Syndication: Recent Comments.\n\nLast modified: Wed Apr 24 22:32:26 2024 This dinky wiki is brought to you by\nthe Insane Hackers Guild, Python sub-branch.\n\n", "frontpage": false}
