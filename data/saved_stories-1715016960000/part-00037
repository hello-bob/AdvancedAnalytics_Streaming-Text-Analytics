{"aid": "40273245", "title": "Decompiling Hyper-V Manager to rebuild it from source", "url": "https://awakecoding.com/posts/decompiling-hyper-v-manager-to-rebuild-it-from-source/", "domain": "awakecoding.com", "votes": 1, "user": "password4321", "posted_at": "2024-05-06 11:02:56", "comments": 0, "source_title": "Decompiling Hyper-V Manager to rebuild it from source", "source_text": "AwakeCoding \u2600\ufe0f\ud83d\udcbb | Decompiling Hyper-V Manager to rebuild it from source\n\n# Decompiling Hyper-V Manager to rebuild it from source\n\nMarc-Andr\u00e9 Moreau published on January 02, 2024\n\n22 min, 4376 words\n\nTags: Hyper-V Reversing CTO\n\n## Why Hyper-V Manager?\n\nHyper-V is undeniably a critical component of the Microsoft virtualization\nstack runs on it, but it's also used in Virtualization-Based Security, Windows\nContainers, Windows Subsystem for Linux, Windows Subsystem for Android, and\neven the Xbox.\n\nThen comes the \"regular\" Hyper-V virtual machines, for which Hyper-V Manager\nis the most popular management user interface today, far ahead of Windows\nAdmin Center:\n\nIn theory, Hyper-V Manager has been replaced by Windows Admin Center, but for\nmost users out there, switching to a localhost web application with self-\nsigned certificates feels like a major downgrade. At a bare minimum, wrapping\nWindows Admin Center in a WebView2 \"desktop\" application could help alleviate\nsome of the adoption problems.\n\nThe Hyper-V PowerShell cmdlets that wrap the underlying Hyper-V WMI provider\nare well maintained and provide complete access to many settings not properly\nexposed in Hyper-V Manager. However, while PowerShell is great for automation,\nnobody really wants to manually type in Set-VMProcessor -VMName <VMName>\n-ExposeVirtualizationExtensions $true to enable nested virtualization in a\nvirtual machine: a simple check box in the user interface would be much faster\nfor the same operation.\n\nHere's the problem: while Microsoft thinks Windows Admin Center replaced\nHyper-V Manager, the reality is that it hasn't. Hyper-V Manager, despite being\nused by 80%, is considered \"legacy\" on life support. It receives no\nimprovements, despite its pain points being very well known by the community\nof IT professionals using it. Improvements in Windows Admin Center have\nlimited effect due to its relatively low adoption.\n\nI have one wish for 2024: that Microsoft open sources Hyper-V Manager such\nthat the community can freely improve it.\n\nI, for one, would like to champion such an effort. Hyper-V Manager is a mature\nproduct with a large number of users with a long list of relative minor\nimprovements or fixes that would make a huge difference. Rewriting Hyper-V\nManager is hard, as Hyper-V has a lot of advanced features which most users\ndon't touch unless they're running a production Hyper-V environment. This\nbeing said, the most promising open-source Hyper-V Manager alternative right\nnow is VMPlex Workstation. It is written in WPF and uses a clever trick to\nload the same configuration dialogs and wizards as the original Hyper-V\nManager. Ideally, they would all have to be rewritten, but this makes it\nfunctional from day one.\n\n## Why Bother Decompiling?\n\nHyper-V Manager is written in C# using WinForms, and while it still targets\n.NET Framework and is designed to be hosted in mmc.exe, it is exactly the type\nof application that can decompile well enough to be built from source again.\nAutomatic .NET decompilation of external code is so common that even the\nlatest version of Visual Studio does it by default. However, one should\nunderstand that decompiled code is not open source code: it doesn't have the\nproper legal status granted by an open source license and is therefore not\nsuitable for an open source project.\n\nThe primary goal of decompiling Hyper-V Manager is really to assess its value\nas a potential open source project, which is what I'm hoping Microsoft can be\nconvinced to do. Microsoft has its eyes on Windows Admin Center and has been\nleaving Hyper-V Manager to die a slow death. I think Hyper-V Manager deserves\na better ending with a community-lead project.\n\nThe secondary goal of decompiling a complete .NET application like Hyper-V\nManager to rebuild it from source is really the educational value of the\nexercise. We've all experimented with .NET decompilation in the past one way\nor another, but very few have tried really going all the way to reconstruct a\ncomplete solution with individual projects that can be built from source again\nin Visual Studio. Yes, it is possible to patch .NET assemblies, but building\nthe entire program from decompiled source code makes certain kind of changes\npossible.\n\n## Installing Required Tooling\n\nInstall the .NET SDK and make sure the dotnet CLI works, as we'll use it to\ncreate and edit solution files. I will be using Visual Studio to build the\nproject, but feel free to use any suitable alternative.\n\nFor scripting, we'll be using PowerShell 7. I recommend using VSCode for\nediting and Windows Terminal to run the scripts.\n\nFor .NET decompilation, open an elevated shell and install ILSpy GUI and\ncommand-line tool:\n\n    \n    \n    dotnet tool install ilspycmd -g winget install icsharpcode.ILSpy\n\nFor blazing fast textual search and replace from the command-line, install\nRipGrep:\n\n    \n    \n    winget install BurntSushi.ripgrep.MSVC\n\nYou will also want a good text editor that can do fast textual (no\nIntelliSense please!) search in a directory. Sublime Text is a good choice if\nVScode is not your thing.\n\nDuring our analysis, tools like Process Monitor and Process Explorer will come\nin handy:\n\n    \n    \n    winget install Microsoft.Sysinternals.ProcessMonitor winget install Microsoft.Sysinternals.ProcessExplorer\n\nYou will also need the git command-line tools, and a simple git GUI to view\nthe history of commits like gitk that usually comes built-in:\n\n    \n    \n    winget install Git.Git\n\nLast but not least, ChatGPT as your assistant - it's really good at generating\nPowerShell code snippets and even regular expressions. I also recommend\nregex101 to help visualize regex to get it right instead of just guessing it.\n\n## Finding Assemblies of Interest\n\nOur target is Hyper-V Manager, which can be installed by enabling the Hyper-V\nManagement Tools in Windows. Note that you can use a VM without nested\nvirtualization for this part, since the management tools can be installed\nwithout the virtualization host features:\n\n    \n    \n    Enable-WindowsOptionalFeature -Online -FeatureName Microsoft-Hyper-V-Tools-All\n\nLaunch Process Monitor (procexp) with the following filters:\n\nColumn| Relation| Value| Action  \n---|---|---|---  \nProcess Name| is| mmc.exe| Include  \nOperation| excludes| Reg| Include  \n  \nFrom the Windows start menu, search and launch \"Hyper-V Manager\". In Process\nMonitor, scroll down until you find some file operation that looks like\nsomething interesting. Unfortunately, we seem to be hitting cached assembly\nfiles, and we have no idea where the original ones are.\n\nLaunch Process Explorer (procexp) as an administrator. Right-click on one of\nthe columns in Process Explorer, then click Select Columns, then select Window\nTitle and Command Line:\n\nFind the process that has the \"Hyper-V Manager\" window title. If you can't\nfind it, then Process Explorer was most likely launched without elevation.\n\nLet's now look at the command line behind Hyper-V Manager:\n\n    \n    \n    \"C:\\Windows\\System32\\mmc.exe\" \"C:\\Windows\\System32\\virtmgmt.msc\"\n\nWhat does it mean? With a bit of research, we can figure out that Hyper-V\nManager is a Microsoft Management Console (MMC) snap-in, and the virtmgmt.msc\nfile is the specific management console to load. If we launch mmc.exe\ndirectly, we can manually add Hyper-V Manager to a generic management console\ninstead:\n\nThis complicates our search a little bit, since mmc.exe is a generic\nexecutable that loads specialized management consoles like Hyper-V Manager. We\nstill don't know where the assemblies or interest are located. Let's open\nvirtmgmt.msc in notepad to see if we can find out more:\n\nThankfully, virtmgmt.msc is an XML definition file, and it contains what looks\nlike a COM class id. By searching in the registry for the same id, we have a\nhit under\n[HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\MMC\\SnapIns\\FX:{922180d7-b74e-45f6-8c74-4b560cc100a5}].\nBy looking at the registry keys, we find that \"C:\\Program Files\\Hyper-V\" is\nthe application base path:\n\nBingo, we finally have our files! Create a zip file of the entire Hyper-V\ndirectory as a backup for now. Using regedit, export the registry keys we've\nfound to virtmgmt.reg, as they could be useful later.\n\nA word of caution on trying to patch the original Hyper-V Manager located in\n%ProgramFiles%\\Hyper-V: don't do it. This is what I originally tried, and\nthought I was successful until I realized using Process Explorer that the DLLs\nfrom the global assembly cache were loaded instead, and they can't be removed\nwithout uninstalling Hyper-V Manager. Even if you do this, you will need to\npurge the native image cache as well. For this reason, it is much simpler to\nuse a different COM class ID and register our custom Hyper-V Manager in a\ndifferent location.\n\n## Initial Analysis of Decompilation Target\n\nCreate a workspace for the reversing project. In my case, I copied the\ncontents of \"C:\\Program Files\\Hyper-V\" to \"~\\Documents\\Reversing\\Hyper-V\".\nLet's start with the easy stuff: mmc.exe loads snap-ins, which are library\ncomponents, not executables, yet we see executables:\n\n  * InspectVhdDialog.exe\n  * VMCreate.exe\n  * VMImport.exe\n\nBy launching them directly, we realize that VMCreate.exe is just a helper\nexecutable launched from Hyper-V Manager for the Quick Create feature:\n\nWe can guess that VMImport.exe and InspectVhdDialog.exe serve similar\npurposes. Since they are external executables, they can be built separately\nfrom the core assemblies of interest, so they can be safely scoped out at this\npoint.\n\nNow for the fun part you've been waiting for: launch ILSpy, then drag all the\nDLLs that begin with Microsoft.Virtualization.Client into it:\n\nWhy Microsoft.Virtualization.Client? Because it looks like the assembly\nnamespace used for Hyper-V Manager internally. Newtonsoft.Json.dll is a common\ndependency of low interest. As for SnapInAbout.dll, it is not even .NET - it's\na native library that appears used only for the MMC snap-in registration, so\nlet's put it aside.\n\nFrom a quick look at the information provided by ILSpy, most assemblies target\n.NET Framework 4.6 (!) but two assemblies\n(Microsoft.Virtualization.Client.RdpClientAxHost.dll,\nMicrosoft.Virtualization.Client.RdpClientInterop.dll) target .NET Framework\n4.0 instead, which is so both old and odd:\n\nIt takes a bit more work to figure this one out, but those two assemblies are\nin fact generated .NET Interop DLLs for the RDP ActiveX control interface.\nThose are probably needed for the Hyper-V Manager special RDP client,\nvmconnect.exe, which is currently missing from our decompilation project.\nLet's unload the RDP ActiveX Interop DLLs for now, we'll come back to them\nlater.\n\nWe are now down to 7 .NET assemblies in the Microsoft.Virtualization.Client\nnamespace which we believe is what makes Hyper-V Manager tick. Inspect the\nassembly references to find out the interdependencies, looking for assembly\nthat should be the easiest to rebuild from source:\n\nLet's build a list of dependencies for each of the assemblies, considering\nonly the Microsoft.Virtualization.Client namespace for now:\n\nMicrosoft.Virtualization.Client.Management.dll depends on:\n\n  * Microsoft.Virtualization.Client.Common.Types.dll\n\nMicrosoft.Virtualization.Client.Settings.dll depends on:\n\n  * Microsoft.Virtualization.Client.dll\n  * Microsoft.Virtualization.Client.Common.dll\n  * Microsoft.Virtualization.Client.Common.Types.dll\n  * Microsoft.Virtualization.Client.Management.dll\n  * Microsoft.Virtualization.Client.Wizards.dll\n\nMicrosoft.Virtualization.Client.VMBrowser.dll depends on:\n\n  * Microsoft.Virtualization.Client.dll\n  * Microsoft.Virtualization.Client.Common.dll\n  * Microsoft.Virtualization.Client.Common.Types.dll\n  * Microsoft.Virtualization.Client.Management.dll\n  * Microsoft.Virtualization.Client.Settings.dll\n  * Microsoft.Virtualization.Client.Wizards.dll\n\nMicrosoft.Virtualization.Client.Wizards.dll depends on:\n\n  * Microsoft.Virtualization.Client.dll\n  * Microsoft.Virtualization.Client.Common.dll\n  * Microsoft.Virtualization.Client.Common.Types.dll\n  * Microsoft.Virtualization.Client.Management.dll\n\nMicrosoft.Virtualization.Client.dll depends on:\n\n  * Microsoft.Virtualization.Client.Common.dll\n  * Microsoft.Virtualization.Client.Common.Types.dll\n  * Microsoft.Virtualization.Client.Common.Management.dll\n\nMicrosoft.Virtualization.Client.Common.dll depends on:\n\n  * Microsoft.Virtualization.Client.Common.Types.dll\n\nAnd finally, Microsoft.Virtualization.Client.Common.Types.dll depends on\nnothing except core .NET runtime assemblies, and vmstaging.dll, a native DLL\nfound C:\\Windows\\System32, so the reference probably comes from pinvoke calls.\nThis looks like our best choice to begin decompilation!\n\n## Manual Decompilation Process\n\nOne should always try manual decompilation first, just to get a feel of how\nfar it is possible to go. However, unless the project is relatively simple,\nyou will reach a point where you start to forget some of the steps and need to\nstart over because you've done a risky change that needs to be reverted. Your\ngoal with manual decompilation should be to document steps which you want to\nautomate later. This section is only provided as a partial guide to show what\nit looks like, since we're going to do the full decompilation process with a\nscript right after.\n\nStart by creating a \"Decompiled\" directory, with one directory for each\nassembly (\"Microsoft.Virtualization.Client.Common.Types\" for\nMicrosoft.Virtualization.Client.Common.Types.dll, etc):\n\n    \n    \n    @('Microsoft.Virtualization.Client.Common.Types', 'Microsoft.Virtualization.Client.Common', 'Microsoft.Virtualization.Client', 'Microsoft.Virtualization.Client.Management', 'Microsoft.Virtualization.Client.Settings', 'Microsoft.Virtualization.Client.VMBrowser', 'Microsoft.Virtualization.Client.Wizards') | % { New-Item $_ -ItemType Directory }\n\nWe will now go over each assembly, getting them to compile one by one\naccording to order of dependencies, using the following steps:\n\n  * Fix internal references (project references within current solution)\n  * Fix external references (package references or assembly references)\n  * Fix AssemblyInfo.cs and broken project file (.csproj) properties\n  * Fix compilation issues resulting from broken or changed references\n  * Fix remaining issues resulting from improper decompilation output\n\nThis process is fairly repetitive, manual and error-prone. Some external\nassembly references may have nuget packages, some may not - you can only\nfigure out the proper package replacement through trial and error. In the case\nof Hyper-V Manager, we have a few remaining assembly references directly in\nthe Windows global assembly cache we could not get rid of in favor of a\npublished nuget package.\n\nIn ILSpy, right-click on the assembly, select \"Save Code\" then select the\ncorresponding output directory. Repeat the process for all of the 7\nMicrosoft.Virtualization.Client assemblies we've identified previously:\n\nCreate a new solution file in the \"Decompiled\" directory, then add references\nto the individual project files:\n\n    \n    \n    dotnet new sln -n Microsoft.Virtualization.Client Get-Item *\\*.csproj | ForEach-Object { dotnet sln add (Resolve-Path $_ -Relative) }\n\nOpen Microsoft.Virtualization.Client.sln in Visual Studio, then try building\nthe solution a first time:\n\nDid you really think it would be that easy? Of course not! Let's start by\nfixing the simplest one: assembly signing. We're not Microsoft, but ILSpy\ndecompiled an AssemblyInfo.cs file matching the original assembly signed by\nMicrosoft. Remove the AssemblyKeyFile and AssemblyDelaySign properties from\nAssemblyInfo.cs:\n\nMicrosoft.Virtualization.Client.Common.Types should now build (yipee!) but all\nthe other projects have the same issue. This is where using VSCode textual\nsearch can be much easier and faster than Visual Studio:\n\nBut even after fixing the assembly signing, we can't build\nMicrosoft.Virtualization.Client.Common which depends on\nMicrosoft.Virtualization.Client.Common.Types. This is becauses none of the\nassembly and project references have been manually fixed. Add a project\nreference to Microsoft.Virtualization.Client.Common.Types, then add an\nassembly reference to Microsoft.ManagementConsole.dll using the full path as\nshown in ILSpy:\n\nMicrosoft.ManagementConsole.dll is part of the .NET Global Assembly Cache and\nunfortunately, the modern .csproj format doesn't have a clean way to reference\nthose. The most foolproof approach is to use HintPath with the full path to\nthe assembly.\n\nWhen you try building again, you'll hit errors caused by incorrect\nInternalsVisibleTo assembly properties in AssemblyInfo.cs. Remove the explicit\nPublicKey from all AssemblyInfo.cs files in the solution to fix those:\n\nMove on to fixing Microsoft.Virtualization.Client.Management. Add a project\nreference to Microsoft.Virtualization.Client.Common.Types, then add a package\nreference to PowerShellStandard.Library version 5.1.1 and\nMicrosoft.Management.Infrastructure version 3.0.0:\n\nNext, fix Microsoft.Virtualization.Client. Add a project reference to\nMicrosoft.Virtualization.Client.Common.Types,\nMicrosoft.Virtualization.Client.Common and\nMicrosoft.Virtualization.Client.Management, then add a package reference to\nPowerShellStandard.Library version 5.1.1. Try building again, but this time we\nare not so lucky:\n\nWhat is this \"The type or namespace name 'Pipeline' could not be found\" error\nin Microsoft.Virtualization.Client\\CommonUtilities.cs? The offending code\nlooks simple enough:\n\n    \n    \n    public static ICollection<PSObject> RunPowershellScript(string script) { Runspace runspace = RunspaceFactory.CreateRunspace(); runspace.Open(); try { Pipeline pipeline = runspace.CreatePipeline(); // this is what breaks the build pipeline.Commands.AddScript(script); return pipeline.Invoke(); } finally { runspace.Close(); } }\n\nWe take a look at the original function in ILSpy to figure out where the\nPipeline type is coming from:\n\nWeird, is it coming from System.Management.Automation, the PowerShell SDK.\nWe've replaced the previous assembly reference with a package reference to\nPowerShellStandard.Library and somehow the original code was so old it used a\ntype that's been moved elsewhere. Let's patch this function such that it can\nbuild again:\n\n    \n    \n    public static ICollection<PSObject> RunPowershellScript(string script) { Runspace runspace = RunspaceFactory.CreateRunspace(); runspace.Open(); try { System.Management.Automation.PowerShell powerShell = System.Management.Automation.PowerShell.Create(); powerShell.Runspace = runspace; powerShell.AddScript(script); return powerShell.Invoke(); } finally { runspace.Close(); } }\n\nAnd it builds! Next is Microsoft.Virtualization.Client.Wizards. As usual,\nlet's start by fixing the assembly references to then try building:\n\nNo luck this time! We seem to be hitting problems due to automatic\ndecompilations of accessor functions that look like default implementations.\nMaybe those shouldn't even be decompiled, so let's comment them out:\n\nAnd success, it builds! Now fix Microsoft.Virtualization.Client.Settings\nassembly references, and comment out similar accessor functions that break the\nbuild:\n\nWe're down to the last one: Microsoft.Virtualization.Client.VMBrowser. Fix the\nassembly references:\n\n    \n    \n    <ItemGroup> <ProjectReference Include=\"..\\Microsoft.Virtualization.Client.Common.Types\\Microsoft.Virtualization.Client.Common.Types.csproj\" /> <ProjectReference Include=\"..\\Microsoft.Virtualization.Client.Common\\Microsoft.Virtualization.Client.Common.csproj\" /> <ProjectReference Include=\"..\\Microsoft.Virtualization.Client.Management\\Microsoft.Virtualization.Client.Management.csproj\" /> <ProjectReference Include=\"..\\Microsoft.Virtualization.Client.Settings\\Microsoft.Virtualization.Client.Settings.csproj\" /> <ProjectReference Include=\"..\\Microsoft.Virtualization.Client.Wizards\\Microsoft.Virtualization.Client.Wizards.csproj\" /> <ProjectReference Include=\"..\\Microsoft.Virtualization.Client\\Microsoft.Virtualization.Client.csproj\" /> </ItemGroup> <ItemGroup> <Reference Include=\"Microsoft.ManagementConsole\" HintPath=\"C:\\WINDOWS\\assembly\\GAC_MSIL\\Microsoft.ManagementConsole\\3.0.0.0__31bf3856ad364e35\\Microsoft.ManagementConsole.dll\" /> <Reference Include=\"PresentationFramework\" HintPath=\"C:\\WINDOWS\\assembly\\GAC_MSIL\\PresentationFramework\\v4.0_4.0.0.0__31bf3856ad364e35\\PresentationFramework.dll\" /> <Reference Include=\"WindowBase\" HintPath=\"C:\\WINDOWS\\Microsoft.NET\\assembly\\GAC_MSIL\\WindowsBase\\v4.0_4.0.0.0__31bf3856ad364e35\\WindowsBase.dll\" /> <Reference Include=\"WindowsFormsIntegration\" HintPath=\"C:\\WINDOWS\\Microsoft.NET\\assembly\\GAC_MSIL\\WindowsFormsIntegration\\v4.0_4.0.0.0__31bf3856ad364e35\\WindowsFormsIntegration.dll\" /> </ItemGroup> <ItemGroup> <Reference Include=\"System.Core\" /> <Reference Include=\"PresentationCore\" /> <Reference Include=\"System.Configuration.Install\" /> </ItemGroup>\n\nThen comment out the accessor functions that cause problems (there are a lot\nmore of them, unfortunately). Try building the entire solution this time:\n\nSuccess! Finally, all 7 assemblies of interest can now be built from source.\nAre we done yet? Well... we still have to find a way to run our modified\nHyper-V Manager, and once we do, we'll run into a lot of issues with satellite\nresource assemblies. You know, the assemblies in that 'en-US' directory that\nwe've conveniently ignored at the beginning.\n\n## Automated Decompilation Process\n\nLeave the manually-compiled project aside, and clone my Hyper-V Manager\nautomated decompilation project git repository:\n\n    \n    \n    git clone git@github.com:awakecoding/hyper-v-manager.git\n\nOpen a PowerShell 7 terminal, then run the bootstrap.ps1 script:\n\n    \n    \n    .\\bootstrap.ps1\n\nIf everything went well, you should now have a \"Decompiled\" directory with a\n\"Microsoft.Virtualization.Client.sln\" solution file you can now open and build\nin Visual Studio:\n\nWell, that was too almost easy, wasn't it? Keep in mind that some additional\npost-compilation fixes may be required due to changes in either the original\nassemblies or the way ILSpy decompiles them in the future. However, at the\ntime of writing this blog post, everything builds properly.\n\nThat's why automation works better in the end: too many times I have failed to\nachieve success because I could only get halfway, and then forgot most of the\nsteps by the time I could give it another go. If you structure your\ndecompilation project with a script that deletes the \"Decompiled\" directory to\nstart over from scratch, automating the steps you've discovered work through\nmanual decompilation, it becomes much easier to make incremental progress.\n\nLet's go over the major differences of what the bootstrap.ps1 script does\ndifferently:\n\n  * Copy assemblies of interest in local \"Assemblies\" directory\n  * Use AssemblyInfo.cs files generated from .csproj properties\n  * All .csproj files now include a common build property file\n  * Use \"overlay\" project files that overwrite the decompiled ones\n  * Call ilspycmd from PowerShell to decompile assemblies automatically\n  * Decompile satellite resource assemblies located in 'en-US' directory\n  * Rename decompiled .resx files to remove assembly prefix from file names\n  * Decompile vmconnect.exe and fix it, something we've skipped earlier\n  * Patch executable path detection to use the same directory as the assemblies\n  * Apply many more post-decompilation fixups for all kinds of additional issues\n\nTake the time to look at the script for yourself to study what it does. One\nimportant thing you'll notice is that it creates a local git repository from\nthe \"Decompiled\" directory, and individual commits for all the automated\nchanges done to the code after initial decompilation. You may wonder why\nbother creating a git repository for something that isn't going to be\npublished: git commits make it very easy to track changes at every step of the\nway, and revert them if needed:\n\n## Running recompiled Hyper-V Manager\n\nCreate the \"C:\\Hyper-V\\Manager\" directory, copy the build output there, then\ncopy hvmanager.msc to the same directory. Import hvmanager.reg to register the\nMMC component with a different GUID than the original Hyper-V Manager, and\npoint it to \"C:\\Hyper-V\\Manager\" as the install path.\n\nYou can now try launch mmc.exe with hvmanager.msc:\n\n    \n    \n    mmc.exe \"C:\\Hyper-V\\Manager\\hvmanager.msc\"\n\nAlternatively, you can launch mmc.exe as the current user and avoid the UAC\nprompt, which can come in handy if you want to debug your recompiled project\nin Visual Studio without launching it as an administrator:\n\n    \n    \n    $Env:__COMPAT_LAYER='RunAsInvoker' mmc.exe \"C:\\Hyper-V\\Manager\\hvmanager.msc\"\n\nHowever, this trick requires you to become part of the local Hyper-V\nAdministrators, otherwise you won't be able to manage VMs:\n\n    \n    \n    $CurrentUser = [System.Security.Principal.WindowsIdentity]::GetCurrent().Name if (-Not (Get-LocalGroupMember -Group \"Hyper-V Administrators\" -Member $CurrentUser -ErrorAction SilentlyContinue)) { Add-LocalGroupMember -Group \"Hyper-V Administrators\" -Member @($CurrentUser) }\n\nYou can now create a shortcut on the desktop with C:\\Windows\\System32\\cmd.exe\n/c \"SET __COMPAT_LAYER=RunAsInvoker & START mmc.exe\n\"C:\\Hyper-V\\Manager\\hvmanager.msc\"\" as the target, and\n%ProgramFiles%\\Hyper-V\\SnapInAbout.dll for the Hyper-V Manager icon. Once the\nshortcut is created, you can drag it onto the taskbar, and delete the original\nshortcut if you don't want it on the desktop:\n\nLast but not least, use the new shortcut to launch your custom Hyper-V Manager\nbuild, then use Process Explorer (procexp) to confirm that the .NET assemblies\nloaded are the ones we expect in C:\\Hyper-V\\Manager:\n\nIf it's not using cached assemblies, but really loading the assemblies we've\njust build from source, then congratulations! It works! You can now start\npatching Hyper-V Manager to fix some of the things that annoy you the most.\n\n## Closing Thoughts\n\nEven if we've managed to rebuild and patch Hyper-V Manager from source, this\nis not enough for a real community project to take place. As much as I would\nlike to just upload the decompiled source code to GitHub to start making\nsignificant changes to it, there's no legal standing for this project. I can\nonly go as far as streamlining the process of decompilation such that others\ncan experiment making changes locally.\n\nAre you a Hyper-V Manager user? Do you wish it could be improved? Make\nyourself heard, and help save Hyper-V Manager by convincing Microsoft to open\nsource it!\n\nSearch\n\nBuilt with code and love\n\nPowered by zola\n\n", "frontpage": false}
