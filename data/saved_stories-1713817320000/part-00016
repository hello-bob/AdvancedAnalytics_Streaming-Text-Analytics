{"aid": "40114567", "title": "Py2wasm \u2013 A Python to WASM Compiler", "url": "https://wasmer.io/posts/py2wasm-a-python-to-wasm-compiler", "domain": "wasmer.io", "votes": 49, "user": "fock", "posted_at": "2024-04-22 14:10:56", "comments": 10, "source_title": "Announcing py2wasm: A Python to Wasm compiler \u00b7 Blog \u00b7 Wasmer", "source_text": "Announcing py2wasm: A Python to Wasm compiler \u00b7 Blog \u00b7 Wasmer\n\nWasmer Edge is now generally available\n\nLearn more\n\nBlogTemplates\n\n###### CLI\n\nTools\n\n###### Visual Studio Code Extension\n\n17k\n\nSign in\n\nBack to articles\n\n# Announcing py2wasm: A Python to Wasm compiler\n\npy2wasm converts your Python programs to WebAssembly, running them at 3x\nfaster speeds\n\nsyrusakbary\n\n###### Syrus Akbary\n\nFounder & CEO\n\nApril 18, 2024\n\nBack to articles\n\nSince starting Wasmer five years ago we've been obsessed with empowering more\nlanguages to target the web and beyond through Webassembly.\n\nOne of the most popular languages out there is Python, and while it is\ncertainly possible to run Python programs in WebAssembly, the performance is\nnot ideal to say the least. *benchmark below\n\nToday we are incredibly happy to announce py2wasm: a Python to WebAssembly\ncompiler that transforms your Python programs to WebAssembly (thanks to\nNuitka!) avoiding the interpreter overhead, allowing it to run 3 times faster\nthan with the baseline interpreter!\n\nHere is how you can use it:\n\n    \n    \n    $ pip install py2wasm $ py2wasm myprogram.py -o myprogram.wasm $ wasmer run myprogram.wasm\n\n> Note: py2wasm needs to run in a Python 3.11 environment. You can use pyenv\n> to set Python 3.11 easily in your system: pyenv install 3.11 && pyenv global\n> 3.11.\n\n### Benchmarking\n\nLets try to get the famous pystone.py benchmark running to compare native\nPython, regular WebAssembly and py2wasm.\n\nNote: you can check the code used to benchmark in\nhttps://gist.github.com/syrusakbary/b318c97aaa8de6e8040fdd5d3995cb7c\n\nWhen executing Python natively (387k pystones/second):\n\n    \n    \n    $ python pystone.py Pystone(1.1) time for 50000 passes = 0.129016 This machine benchmarks at 387549 pystones/second\n\nWhen executing the CPython interpreter inside of WebAssembly (89k\npystones/second):\n\n    \n    \n    $ wasmer run python/python --mapdir=/app:. /app/pystone.py Pystone(1.1) time for 50000 passes = 0.557239 This machine benchmarks at 89728.1 pystones/second\n\nWhen using py2wasm via Nuitka (235k pystones/second):\n\n    \n    \n    $ py2wasm pystone.py -o pystone.wasm $ wasmer run pystone.wasm Pystone(1.1) time for 50000 passes = 0.21263 This machine benchmarks at 235150 pystones/second\n\nIn a nutshell: using py2wasm gets about 70% of the Native Python speed... and\nis about 2.5~3x faster than the baseline!\n\nSo, how does this black magic work?\n\nLet's first analyze all the possible strategies that we can think of to\noptimize Python workloads in WebAssembly.\n\n# How to speed up Python in WebAssembly\n\nThere are many ways to optimize runtime speed:\n\n  * Use a Python subset that can be compiled into performant code\n  * Use JIT inside of Python\n  * Use Static Analysis to optimize the generated code\n\nIt's time to analyze each!\n\n## Compile a Python subset to Wasm\n\nInstead of supporting the full Python feature set, we may want to only target\na subset of it that can be optimized much further since not all features need\nto be supported and we can afford to do some shortcuts:\n\n  * \u2705 Can generate incredibly performant code\n  * \u274c Doesn\u2019t support the full syntax or modules\n\nThe most popular choices using this strategy are: CPython, RPython (PyPy) and\nCodon.\n\n### Cython\n\nCython has been around for many years, and is probably the oldest method to\naccelerate Python modules. CPython is not strictly a subset, since it supports\na syntax closer to C. The main goal of Cython is to create performant modules\nthat run next to your Python codebase. However, we want to allow creating\ncompletely standalone WebAssembly binaries from our programs.\n\nSo unfortunately Cython will not work for speeding up Python executables in\nWasm.\n\n### RPython\n\nRPython transforms the typed code into C, and then compiles it with a normal C\ncompiler.\n\nPyPy itself is compiled with RPython, which is able to do all the black magic\nunder the hood.\n\n    \n    \n    def entry_point(argv): print \"Hello, World!\" return 0 def target(*args): return entry_point\n\n$ rpython hello_world.py (\u2192 hello-world-c.c ) \u2192 hello-world (assembly binary)\n\n    \n    \n    $ rpython helloworld.py $ ./hello-world \"Hello, World!\"\n\nHowever, RPython has many restrictions when running Python. For example,\ndictionaries need to be fully typed, and this severly limits the programs that\nwe can use it for.\n\n### Codon\n\nCodon transforms a subset of Python code into LLVM IR.\n\nWhile Codon is one of the most promising alternatives and the one that offers\nthe most speedup (from 10 to 100x faster), the subset of Python they support\nstill has many missing features, which prevents using it for most Python code.\n\n## Python JITs\n\nAnother strategy is to use a JIT inside of Python, so the hot paths of\nexecution are compiled to WebAssembly.\n\n  * \u2705 Really fast speeds\n  * \u274c Needs to warm up\n  * \u274c Not trivial to support with Webassembly (but possible)\n\nOne of the most popular ways (if not the most popular) is PyPy.\n\n### PyPy\n\nPyPy is a Python interpreter that can execute your Python programs at faster\nspeed than the standard CPython interpreter. It speeds up the execution with a\nJust In Time (JIT) compiler that kicks in when doing complex computation.\n\nRunning a JIT in WebAssembly is not trivial, but is possible.\n\nAbout five years ago, the project pypyjs.org showcased this possibility by\ncreating a new backend for PyPy that targeted Javascript/Asm.js (instead of\nx86_64 or arm64/aarch64).\n\n> You can check the PyPy Asm.js backend implementation here:\n> https://github.com/pypyjs/pypy/tree/pypyjs/rpython/jit/backend/asmjs\n\nFor our case, we would need to adapt this backend from outputting Javascript\ncode to Webassembly instead.\n\nIt should be totally possible to implement a Wasm backend in PyPy as Pypy.js\ndemonstrated, but unfortunately is not trivial to do so (it may take from a\nfew weeks to a month of work).\n\n## Static Analysis\n\nThere\u2019s one last strategy that we can try to speed up Python execution speed\ninside of WebAssembly: static analysis. Thanks to static analysis, we can\nanalyze/autodetect the typings of our program ahead of time, so the code can\nbe transpiled into more performant specializations (usually through Python to\nC transpilation).\n\n  * \u2705 Mostly compatible with any Python code and applications\n  * \u274c Only 1.5-3x faster\n  * \u274c Complex to get right (from the static analyzer perspective, many quircks)\n  * \u274c Larger binaries\n\n### mypy & mypy-c\n\nMypy is probably the most popular static analyzer for Python.\n\nThe Mypy team also created a mypy-c , which gets all the typing information\nfrom Mypy and then transforms the Python code into equivalent C code that runs\nmore performantly.\n\nmypy-c is currently specialized on targeting Python modules that can run\ninside native Python. In our case, we want to allow creating new standalone\nWebAssembly binaries from our programs, so unfortunately it seems that mypy-c\ncouldn\u2019t work for our use case.\n\n### Nuitka\n\nNuitka works by transpiling the Python calls that the programs does into C,\nusing the inner CPython API calls. It supports most Python programs, as it\ntranspiles Python code into the corresponding CPython calls.\n\nIt can even work as a code obfuscator (no one will be able to decompile your\nprogram!)\n\nAfter a deep analysis of all the options we realized that probably the fastest\noption to get Python running performantly in WebAssembly was using Nuitka.\n\n# Using Nuitka to compile Python to WebAssembly\n\nNuitka seemed like the easiest option to speed up to Python in WebAssembly\ncontexts, mainly because most of the hard work was already done to transpile\nPython Code into the underlying CPython interpreter calls, so we could\nprobably do some tweaks to get it working to compile to WebAssembly.\n\nNuitka doesn't work (yet) with Python 3.12, so we had to recompile Python to\n3.11 to WASI and use the generated libpython.a archive, so Nuitka could use\nthis library when targeting WebAssembly and WASI to create the executable.\n\nAnd things started working... kind of. Once we tried to run the generated Wasm\nfile we realized another issue: because the Nuitka transpiler is executing in\na 64 bit architecture, but the generated code is running in a 32 bit\narchitecture (WebAssembly), things were not properly working. Nuitka uses a\nserialization/deserialization layer to cache the values of certain constants\n(and accelerate the startup), and while the code was being serialized in 64\nbits, the deserialization was done in 32 bits, so there was a bit of mismatch.\n\nOnce we fixed this two issues, the prototype was fully working! Hurray! \ud83c\udf89\n\nWe have created a PR to upstream the changes into Nuitka, feel free to take a\nlook here: https://github.com/Nuitka/Nuitka/pull/2814\n\n> i\ufe0f Right now py2wasm is using a fork of Nuitka, but once changes are\n> integrated upstream we aim to make py2wasm a thin layer on top of Nuitka.\n\nWe worked on py2wasm to fulfill our own needs first, as we want to accelerate\nPython execution to the maximum, so we can move our Python Django backend from\nGoogle Cloud into Wasmer Edge.\n\npy2wasm brings us (and hopefully many others) one step closer to running\nPython backend apps on Edge at an incredible performance providing a much\ncheaper alternative for hosting these apps than the current cloud providers.\n\n### Future Roadmap\n\nIn the future, we would like to publish py2wasm as a Wasmer package, so you\ncan just simply execute the following command to get it running. Stay tuned!\n\n    \n    \n    wasmer run py2wasm --dir=. -- myfile.py -o myfile.wasm\n\nWe hope you enjoyed the article showcasing py2wasm and we can\u2019t wait to hear\nyour feedback on Hacker News and Github!\n\n> This article is based on the work I presented in the Wasm I/O conference on\n> March 15th, 2024. You can view the slides in SpeakerDeck, or watch the\n> presentation in Youtube: https://www.youtube.com/watch?v=_Gq273qvNMg\n\n##### About the Author\n\nSyrus Akbary is an enterpreneur and programmer. Specifically known for his\ncontributions to the field of WebAssembly. He is the Founder and CEO of\nWasmer, an innovative company that focuses on creating developer tools and\ninfrastructure for running Wasm\n\nSyrus Akbary\n\n###### Syrus Akbary\n\nFounder & CEO\n\nBenchmarking\n\nHow to speed up Python in WebAssembly\n\nCompile a Python subset to Wasm\n\nCython\n\nRPython\n\nCodon\n\nPython JITs\n\nPyPy\n\nStatic Analysis\n\nmypy & mypy-c\n\nNuitka\n\nUsing Nuitka to compile Python to WebAssembly\n\nFuture Roadmap\n\n##### Read more\n\nMaking software universally accessible\n\nTwitterDiscordGitHub\n\n## Explore\n\n  * Packages\n  * Blog\n\n## Products\n\n  * Runtime\n  * Registry\n  * Edge\n\n## Company\n\n  * About\n  * Values & Culture\n\n  * Imprint\n  * Privacy\n  * Terms\n\n", "frontpage": true}
