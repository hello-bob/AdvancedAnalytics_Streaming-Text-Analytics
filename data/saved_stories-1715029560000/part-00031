{"aid": "40275421", "title": "Protobuf Editions Explained", "url": "https://kreya.app/blog/protobuf-editions-explained/", "domain": "kreya.app", "votes": 2, "user": "CommonGuy", "posted_at": "2024-05-06 14:55:34", "comments": 0, "source_title": "Protobuf Editions explained", "source_text": "Protobuf Editions explained | Kreya\n\nSkip to main content\n\n# Protobuf Editions explained\n\nMay 3, 2024\n\nManuel\n\nProtobuf Editions bring a major change in the way Protocol Buffer versions are\nhandled. Currently there are two versions, \"proto2\" and \"proto3\", and the\ndifferences between them aren't always obvious. Migrating from proto2 to\nproto3 isn't easy either. In this blog post we will explore how Protobuf\nEditions are going to improve this.\n\n## Current state of Protobuf Buffers versions\n\nThe first publicly released version of Protobuf was proto2. Since it had some\ndesign flaws (for example the required keyword and custom default values for\nfields), it was decided to create the proto3 version. Proto3 is mainly a\nsimplification of proto2 and fixes most of the design flaws mentioned.\n\nProto2 and proto3 are wire-compatible when using the \"same constructs\":\nMessages serialized with proto2 can be read with proto3 and vice versa.\n\n### Proto2\n\nHere is an example of a proto2 message definition:\n\n    \n    \n    syntax = \"proto2\";\n    \n    message Book { required string name = 1; optional int32 number_of_pages = 2; }\n\nNote the use of required: This is discouraged, as a value MUST be set, which\nimpedes subsequent changes of the message definition. As mentioned above, this\nwas one of the main reasons why proto3 was created.\n\n### Proto3\n\nIn proto3, all fields have \"implicit field presence\". This basically means\nthat all fields are optional by default. During deserialization, if no data is\nprovided for a field, the default value for that data type (e.g. 0 for\nnumbers, empty string for string) is assigned to the field. This is very good\nfor backwards compatibility, as for example adding a new field just works.\nHowever, it does not allow consumers to check whether the default value or\n\"nothing\" was sent over the wire. In a later iteration of proto3, the optional\nkeyword was added, allowing consumers to check whether a value was set.\n\nThe following message is only roughly equivalent to the proto2 definition,\nsince the function of the required keyword cannot be replicated with proto3:\n\n    \n    \n    syntax = \"proto3\";\n    \n    message Book { string name = 1; // Cannot check whether an empty string was set or no value provided optional int32 number_of_pages = 2; // Can check whether 0 was set or no value provided }\n\nNote that all data serialized with the proto2 definition can be read with this\nproto3 definition. The reverse is not necessarily true, for example if name is\nnot set in the proto3 message. Proto2 deserialization would then fail because\nthe name is required but not present in the data.\n\n## Need for better Protobuf Versioning\n\nThe previous handling of Protobuf versions was quite confusing.\n\n  * The official documentation was not very helpful, for example the differences between proto2 and proto3 are still hard to find. Some documentation, e.g. for Custom Options, only exists for proto2, but is still applicable to proto3.\n  * While proto2 message types can be imported in proto3 (and vice versa), there are some restrictions.\n  * In addition, proto3 has several \"implementation versions\". For example the optional keyword was not originally a part of proto3 and was added later.\n\nProbably for these and other reasons, simply creating a proto4 version for\nfuture changes was not an option.\n\n## Protobuf Editions\n\nWith Protobuf Editions, instead of \"hardcoding\" behavior (like required in\nproto2), everything is controlled by features. Features are options that can\nbe set on a file, on a message or even on individual fields.\n\nEditions can be thought of as a collection of features with a specific default\nvalue. The 2023 edition only specifies only a few features, with most of the\ndefaults matching the proto3 version.\n\nOne exception is the features.field_presence feature, which is EXPLICIT by\ndefault in the 2023 edition. It has the following values:\n\n  * LEGACY_REQUIRED: The field is required for parsing and serialization (legacy value to support the behavior of the proto2 required keyword)\n  * EXPLICIT: Explicit tracking whether the field value was sent over the wire, even if it was the default value (matches optional from proto2 and proto3)\n  * IMPLICIT: No presence tracking. Default values are not serialized. If a value is missing on deserialization, set the field to the default value (default behavior of proto3)\n\nWhen a new feature is introduced in future editions, it will be disabled by\ndefault, but can be enabled manually by opting into it. Subsequent editions\nmay then enable the feature by default, and users may need to opt out of it.\n\nTo ease the transition from one edition to another, the Prototiller tool has\nbeen announced.\n\n### Proto2 to edition 2023\n\nUsing the Prototiller tool (yet to be released), one can convert proto2\ndefinitions into the new 2023 edition. The nice thing about Prototiller is\nthat it preserves the features of the old version and overrides the defaults\nof the new version accordingly.\n\nLet's take our proto2 example from above:\n\n    \n    \n    syntax = \"proto2\";\n    \n    message Book { required string name = 1; optional int32 number_of_pages = 2; }\n\nConverting this to edition 2023 with the Prototiller tool would produce the\nfollowing result (comment added for clarity):\n\n    \n    \n    edition = \"2023\";\n    \n    message Book { string name = 1 [features.field_presence = LEGACY_REQUIRED]; int32 number_of_pages = 2; // No annotation needed, optional from proto2 matches the 2023 edition defaults }\n\nThis definition now has exactly the same semantics as the proto2 version. They\nare essentially identical.\n\n### Proto3 to edition 2023\n\nNow let's take our proto3 example from above:\n\n    \n    \n    syntax = \"proto3\";\n    \n    message Book { string name = 1; optional int32 number_of_pages = 2; }\n\nConverting this to edition 2023 with the Prototiller tool would give the\nfollowing result:\n\n    \n    \n    edition = \"2023\";\n    \n    message Book { string name = 1 [features.field_presence = IMPLICIT]; int32 number_of_pages = 2; // No annotation needed, optional from proto3 matches the 2023 edition defaults }\n\nSince the field presence is implicit by default in proto3, but explicit in\nedition 2023, an annotation must be added to the name field to preserve the\nexisting behavior. The converted definitions now make it obvious that the\nproto2 and proto3 definitions were not identical.\n\nWe could also enable the implicit field presence for the whole file while\nkeeping the semantics the same:\n\n    \n    \n    edition = \"2023\";\n    \n    option features.field_presence = IMPLICIT;\n    \n    message Book { string name = 1; int32 number_of_pages = 2 [features.field_presence = EXPLICIT]; }\n\n## Advantages\n\nThe first Protobuf Edition (edition 2023) was explicitly designed to combine\nboth proto2 and proto3 features. This plus the design of the Protobuf Editions\nhave several advantages:\n\n  * Proto2 and proto3 definitions can finally be converted to a version that preserves the old behavior (instead of differences when converting from proto2 to proto3)\n  * An edition is more \"lighter\" than a completely new version \u00e0 la proto4\n\n    * Updating to a newer version while keeping the semantics identical is possible\n    * This makes it easier to release editions more frequently\n    * This in turn makes it easier to introduce new features into the language\n  * Features can be deprecated, giving users time to migrate until the feature is removed in a future edition\n  * Users can easily change the default behavior of the language (this was not possible with proto2 and proto3 because it was hardcoded)\n  * Documentation is easier to read and write\n\n    * Each feature can be documented separately (when it was introduced, what the default is for each edition etc.)\n    * See for example https://protobuf.dev/editions/features/#field_presence\n\n## Closing\n\nOverall, Protobuf Editions will have a positive impact on the Protobuf and\ngRPC ecosystem. It allows the language to move forward and finally introduces\na clear update path for users.\n\nTo allow testing of gRPC APIs that make use of the new Protobuf 2023 edition,\nKreya will add support for edition 2023 in the next release.\n\n  * Current state of Protobuf Buffers versions\n\n    * Proto2\n    * Proto3\n  * Need for better Protobuf Versioning\n  * Protobuf Editions\n\n    * Proto2 to edition 2023\n    * Proto3 to edition 2023\n  * Advantages\n  * Closing\n\nCommunity\n\n  * Blog\n  * Documentation\n  * GitHub\n  * Twitter\n\nComparisons\n\n  * vs Postman\n  * vs Insomnia\n  * vs BloomRPC\n  * vs Bruno\n  * vs SoapUI\n  * vs SwaggerUI\n\nAbout\n\n  * Privacy policy\n  * Terms\n  * riok GmbH\n\nCopyright \u00a9 2024 riok GmbH\n\n", "frontpage": false}
