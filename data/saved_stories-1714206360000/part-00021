{"aid": "40176489", "title": "Prisma now supports SQL joins", "url": "https://www.prisma.io/blog/prisma-orm-now-lets-you-choose-the-best-join-strategy-preview", "domain": "prisma.io", "votes": 2, "user": "andrewray", "posted_at": "2024-04-27 02:08:59", "comments": 0, "source_title": "Prisma ORM Now Lets You Choose the Best Join Strategy (Preview)", "source_text": "Prisma ORM Now Lets You Choose the Best Join Strategy (Preview)\n\nEasily react to database changes with Prisma Pulse-> Try it now!\n\nProducts\n\nORM\n\nTalk to your database easily\n\nAccelerate\n\nUp to 1000x faster queries\n\nPulse\n\nSubscribe to type-safe database events\n\nPricing\n\nResources\n\nDocumentation\n\nGet started\n\nTutorials\n\nExamples\n\nPrisma in your stack\n\nEcosystem\n\nCustomer stories\n\nData guide\n\nPlayground\n\nBlog\n\nLoginGet started\n\nFebruary 21, 2024\n\n# Prisma ORM Now Lets You Choose the Best Join Strategy (Preview)\n\nNikolas Burk\n\n@nikolasburk\n\nFetching related data from multiple tables in SQL databases can get expensive.\nPrisma ORM now lets you choose between database-level and application-level\njoins so that you can pick the most performant approach for your relation\nqueries.\n\n## Contents\n\n  * New in Prisma ORM: Choose the best Join strategy \ud83c\udf89\n  * join vs query \u2014 when to use which?\n  * Understanding relations in SQL databases\n  * What's happening under the hood?\n  * Try it out and share your feedback\n\n## New in Prisma ORM: Choose the best join strategy \ud83c\udf89\n\nSupport for database-level joins has been one of the most requested features\nin Prisma ORM and we're excited to share that it's now available as another\nquery strategy!\n\nFor any relation query with include (or select), there is now a new option on\nthe top-level called relationLoadStrategy. This option accepts one out of two\npossible values:\n\n  * join (default): Uses the database-level join strategy to merge the data in the database.\n  * query: Uses the application-level join strategy by sending multiple queries to individual tables and merging the data in the application layer.\n\nTo enable the new relationLoadStrategy, you'll first need to add the preview\nfeature flag to the generator block of your Prisma Client:\n\n    \n    \n    generator client {\n    \n    provider = \"prisma-client-js\"\n    \n    previewFeatures = [\"relationJoins\"]\n    \n    }\n\n> Note: The relationLoadStrategy is only available for PostgreSQL and MySQL\n> databases.\n\nOnce that's done, you'll need to re-run prisma generate for this change to\ntake effect and pick a relation load strategy in your queries.\n\nHere is an example that uses the new join strategy:\n\n    \n    \n    const usersWithPosts = await prisma.user.findMany({\n    \n    relationLoadStrategy: \"join\", // or \"query\"\n    \n    include: {\n    \n    posts: true,\n    \n    },\n    \n    });\n\nNote that because \"join\" is the default, the relationLoadStrategy option could\ntechnically also be omitted in the code snippet above. We just show it here\nfor illustration purposes.\n\n## join vs query \u2014 when to use which?\n\nNow with these two query strategies, you'll wonder: When to use which?\n\nBecause of the lateral, aggregated JOINs that Prisma ORM uses on PostgreSQL\nand the correlated subqueries on MySQL, the join strategy is likely to be more\nefficient in the majority of cases (a later section will have more details on\nthis). Database engines are very powerful and great at optimizing query plans.\nThis new relation load strategy pays tribute to that.\n\nHowever, there may be cases where you may still want to use the query strategy\nto perform one query per table and merge data at the application-level.\nDepending on the dataset and the indexes that are configured in the schema,\nsending multiple queries could be more performant. Profiling and benchmarking\nyour queries will be crucial to identify these situations.\n\nAnother consideration could be the database load that's incurred by a complex\njoin query. If, for some reason, resources on the database server are scarce,\nyou may want to move the heavy compute that's required by a complex join query\nwith filters and pagination to your application servers which may be easier to\nscale.\n\nTLDR:\n\n  * The new join strategy will be more efficient in most scenarios.\n  * There may be edge cases where query could be more performant depending on the characteristics of the dataset and query. We recommend that you profile your database queries to identify these scenarios.\n  * Use query if you want to save resources on the database server and do heavy-lifting of merging and transforming data in the application server which might be easier to scale.\n\n## Understanding relations in SQL databases\n\nNow that we learned about Prisma ORM's JOIN strategies, let's review how\nrelation queries generally work in SQL databases.\n\n### Flat vs nested data structures for relations\n\nSQL databases store data in flat (i.e. normalized) ways. Relations between\nentities are represented via foreign keys that specify references across\ntables.\n\nOn the other hand, application developers are typically used to working with\nnested data, i.e. objects that can nest other objects arbitrarily deep.\n\nThis is a huge difference, not only in the way how data is physically laid out\non disk and in memory, but also when it comes to the mental model and\nreasoning about the data.\n\n### Relational data needs to be \"merged\" for application developers\n\nSince related data is stored physically separately in the database, it needs\nto be merged somewhere to become the nested structure an application developer\nis familiar with. This merge is also called \"join\".\n\nThere are two places where this join can happen:\n\n  * On the database-level: A single SQL query is sent to the database. The query uses the JOIN keyword or a correlated subquery to let the database perform the join across multiple tables and returns the nested structures.\n  * On the application-level: Multiple queries are sent to the database. Each query only accesses a single table and the query results are then merged in-memory in the application layer. This used to be the only query strategy that Prisma Client supported before v5.9.0.\n\nWhich approach is more desirable depends on the database that's used, the size\nand characteristics of the dataset, and the complexity of the query. Read on\nto learn when it's recommended to use which strategy.\n\n## What's happening under the hood?\n\nPrisma ORM implements the new join relation load strategy using LATERAL joins\nand DB-level JSON aggregation (e.g. via json_agg) in PostgreSQL and correlated\nsubqueries on MySQL.\n\nIn the following sections, we'll investigate why the LATERAL joins and DB-\nlevel JSON aggregation approach on PostgreSQL is more efficient than plain,\ntraditional JOINs.\n\n### Preventing redundancy in query results with JSON aggregation\n\nWhen using database-level JOINs, there are several options for constructing a\nSQL query. Let's consider the SQL table definition for the Prisma schema from\nabove:\n\n    \n    \n    -- CreateTable\n    \n    CREATE TABLE \"User\" (\n    \n    \"id\" SERIAL NOT NULL,\n    \n    \"name\" TEXT,\n    \n    CONSTRAINT \"User_pkey\" PRIMARY KEY (\"id\")\n    \n    );\n    \n    -- CreateTable\n    \n    CREATE TABLE \"Post\" (\n    \n    \"id\" SERIAL NOT NULL,\n    \n    \"title\" TEXT NOT NULL,\n    \n    \"authorId\" INTEGER,\n    \n    CONSTRAINT \"Post_pkey\" PRIMARY KEY (\"id\")\n    \n    );\n    \n    -- AddForeignKey\n    \n    ALTER TABLE \"Post\" ADD CONSTRAINT \"Post_authorId_fkey\" FOREIGN KEY (\"authorId\") REFERENCES \"User\"(\"id\") ON DELETE SET NULL ON UPDATE CASCADE;\n\nTo retrieve all users with their posts, you can use a simple LEFT JOIN query:\n\n    \n    \n    SELECT\n    \n    u.id AS user_id,\n    \n    u.name AS user_name,\n    \n    p.id AS post_id,\n    \n    p.title AS post_title\n    \n    FROM\n    \n    \"user\" u\n    \n    LEFT JOIN\n    \n    post p ON u.id = p.author_id\n    \n    ORDER BY\n    \n    u.id, p.id;\n\nThis is what the result could look like with some sample data:\n\nNotice the redundancy in the user_name column in this case. This redundancy is\nonly going to get worse the more tables are being joined. For example, assume\nthere's another Comment table, where each comment has a postId foreign key\nthat points to a record in the Post table.\n\nHere's a SQL query to represent that:\n\n    \n    \n    SELECT\n    \n    u.id AS user_id,\n    \n    u.name AS user_name,\n    \n    p.id AS post_id,\n    \n    p.title AS post_title,\n    \n    c.id AS comment_id,\n    \n    c.body AS comment_body\n    \n    FROM\n    \n    \"user\" u\n    \n    LEFT JOIN\n    \n    post p ON u.id = p.author_id\n    \n    LEFT JOIN\n    \n    comment c ON p.id = c.post_id\n    \n    ORDER BY\n    \n    u.id, p.id, c.id;\n\nNow, assume the first post had multiple comments:\n\nThe size of the result set in this case grows exponentially with the number of\ntables that are being joined. Since this data goes over the wire from the\ndatabase to the application server, this can become very expensive.\n\nThe join strategy implemented by Prisma with JSON aggregation on the database-\nlevel solves this problem.\n\nHere is an example for PostgreSQL that uses json_agg and json_build_object to\nsolve the redundancy problem and return the posts per user in JSON format:\n\n    \n    \n    SELECT\n    \n    u.id AS user_id,\n    \n    u.name AS user_name,\n    \n    jsonb_agg(\n    \n    jsonb_build_object(\n    \n    'post_id', p.id,\n    \n    'post_title', p.title\n    \n    )\n    \n    ) AS posts\n    \n    FROM\n    \n    \"user\" u\n    \n    LEFT JOIN\n    \n    post p ON u.id = p.author_id\n    \n    GROUP BY\n    \n    u.id, u.name\n    \n    ORDER BY\n    \n    u.id;\n\nThe result set this time doesn't contain redundant data. Additionally, the\ndata structure conveniently already has the shape that's returned by Prisma\nClient which saves the extra work of transforming results in the query engine:\n\n### Lateral JOINs for more efficient queries with pagination and filters\n\nRelation queries (like most other ones) almost never fetch the entire data\nfrom a table, but come with additional result set constraints like filters and\npagination. Specifically pagination can become very complex with traditional\nJOINs, let's look at another example.\n\nConsider this Prisma Client query that fetches 10 users and 5 posts per user:\n\n    \n    \n    await prisma.user.findMany({\n    \n    take: 10,\n    \n    include: {\n    \n    posts: {\n    \n    take: 5,\n    \n    },\n    \n    },\n    \n    });\n\nWhen writing this in raw SQL, you might be tempted to use a LIMIT clause\ninside the sub-query, e.g.:\n\n    \n    \n    SELECT \"user\".id,\n    \n    name,\n    \n    title\n    \n    FROM (\"user\"\n    \n    LEFT JOIN\n    \n    (SELECT *\n    \n    FROM post\n    \n    LIMIT 5) AS p ON (p.author_id = \"user\".id))\n    \n    LIMIT 10;\n\nHowever, this won't work because the inner SELECT doesn't actually return five\nposts per user \u2014 instead it returns two posts in total which is of course not\nat all the desired outcome.\n\nUsing a traditional JOIN, this could be resolved by using the row_number()\nfunction to assign incrementing integers to the records in the result set with\nwhich the computation of the pagination could be performed manually.\n\nThis approach becomes very complex very fast though and thus isn't ideal for\nbuilding paginated relation queries.\n\n    \n    \n    SELECT \"user\".id,\n    \n    name,\n    \n    title,\n    \n    rn\n    \n    FROM (\"user\"\n    \n    LEFT JOIN\n    \n    (SELECT *,\n    \n    row_number() OVER (PARTITION BY author_id) AS rn\n    \n    FROM post) AS p ON (p.author_id = \"user\".id))\n    \n    WHERE p.rn >= 1\n    \n    AND p.rn <= 5\n    \n    OR p.rn IS NULL\n    \n    LIMIT 10;\n\nMaintaining, scaling and debugging these kinds of SQL queries is daunting and\ncan consume hours of development time.\n\nThankfully, newer database versions solve this with a new kind of query: the\nlateral JOIN.\n\nThe above query can be simplified by using the LATERAL keyword:\n\n    \n    \n    SELECT \"user\".id,\n    \n    name,\n    \n    title\n    \n    FROM (\"user\"\n    \n    LEFT JOIN LATERAL\n    \n    (SELECT *\n    \n    FROM post\n    \n    WHERE post.author_id = \"user\".id\n    \n    LIMIT 5) AS p ON TRUE)\n    \n    LIMIT 10;\n\nThis not only makes the query more readable, but the database engine also\nlikely is more capable of optimizing the query because it can understand more\nabout the intent of the query.\n\n### Conclusion\n\nLet's review the different options for joining data from relation queries with\nPrisma.\n\nIn the past, Prisma only supported the application-level join strategy which\nsends multiple queries to the database and does all the work of merging and\ntransforming it into the expected JavaScript object structures inside of the\nquery engine:\n\nUsing plain, traditional JOINs, the merging of the data would be delegated to\nthe database. However, as explained above, there are problems with data\nredundancy (the result sets grow exponentially with the number of tables in\nthe relation query) and the complexity of queries that contain filters and\npagination:\n\nTo work around these issues, Prisma ORM implements modern, lateral JOINs\naccompanied with JSON aggregation on the database-level. That way, all the\nheavy lifting that's needed to resolve the query and bring the data into the\nexpected JavaScript object structures is done on the database-level:\n\n## Try it out and share your feedback\n\nWe'd love for you to try out to the new loading strategy for relation queries.\nLet us know what you think and share your feedback with us!\n\nAnnouncementPrisma ORM\n\n### Don\u2019t miss the next post!\n\nSign up for the Prisma Newsletter\n\n### Increase Database Security With Static IP Support in Prisma Accelerate\n\nApril 09, 2024\n\nPrisma Accelerate introduces Static IP support, enabling secure connections to\nyour database with predictable IPs for controlled access and minimized\nexposure. This allows connections from Accelerate to databases requiring\ntrusted IP access.\n\nAnnouncementData Platform\n\n### Build Applications at the Edge with Prisma ORM & Cloudflare D1 (Preview)\n\nApril 02, 2024\n\nCloudflare has been pioneering the edge computing landscape since the\nintroduction of Workers in 2017. With D1, Cloudflare recently released a\nnative serverless database. We\u2019re excited to announce that you can now talk to\nD1 using Prisma ORM!\n\nAnnouncementPrisma ORMRelease\n\n### Prisma ORM Support for Edge Functions is Now in Preview\n\nMarch 12, 2024\n\nWe\u2019re thrilled to share that support for edge functions is in Preview! You can\nnow access your database with Prisma ORM from Vercel Edge Functions, Vercel\nEdge Middleware, Cloudflare Workers, and Cloudflare Pages. Try it out!\n\nAnnouncementPrisma ORM\n\n#### Product\n\nORMAcceleratePulsePricingChangelogData Platform status\n\n#### Resources\n\nDocsEcosystemPlaygroundCustomer storiesData guide\n\n#### Contact us\n\nCommunitySupportEnterprisePartnersOSS Friends\n\n#### Company\n\nAboutBlogData DXCareersTerms & PrivacyService Level Agreement\n\n#### Newsletter\n\n\u00a9 2024 Prisma Data, Inc.\n\n", "frontpage": false}
