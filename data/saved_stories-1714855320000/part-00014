{"aid": "40257980", "title": "\"Dirty stream\" attack: A common vulnerability pattern in Android apps", "url": "https://www.microsoft.com/en-us/security/blog/2024/05/01/dirty-stream-attack-discovering-and-mitigating-a-common-vulnerability-pattern-in-android-apps/", "domain": "microsoft.com", "votes": 2, "user": "croes", "posted_at": "2024-05-04 14:33:57", "comments": 0, "source_title": "\u201cDirty stream\u201d attack: Discovering and mitigating a common vulnerability pattern in Android apps | Microsoft Security Blog", "source_text": "\u201cDirty stream\u201d attack: Discovering and mitigating a common vulnerability pattern in Android apps | Microsoft Security Blog\n\nSkip to main content\n\nMicrosoft\n\nMicrosoft Security\n\nMicrosoft Security\n\n  * Research\n  * Threat intelligence\n  * Microsoft Defender\n  * Vulnerabilities and exploits\n\n15 min read\n\n# \u201cDirty stream\u201d attack: Discovering and mitigating a common vulnerability\npattern in Android apps\n\n  * By Microsoft Threat Intelligence\n\nMay 1, 2024\n\n  * Microsoft Defender for Endpoint\n  * Microsoft Defender Vulnerability Management\n  * Mobile threats\n  * Android\n  * Credential theft\n  * Remote code execution\n\nMicrosoft discovered a path traversal-affiliated vulnerability pattern in\nmultiple popular Android applications that could enable a malicious\napplication to overwrite files in the vulnerable application\u2019s home directory.\nThe implications of this vulnerability pattern include arbitrary code\nexecution and token theft, depending on an application\u2019s implementation.\nArbitrary code execution can provide a threat actor with full control over an\napplication\u2019s behavior. Meanwhile, token theft can provide a threat actor with\naccess to the user\u2019s accounts and sensitive data.\n\nWe identified several vulnerable applications in the Google Play Store that\nrepresented over four billion installations. We anticipate that the\nvulnerability pattern could be found in other applications. We\u2019re sharing this\nresearch so developers and publishers can check their apps for similar issues,\nfix as appropriate, and prevent introducing such vulnerabilities into new apps\nor releases. As threats across all platforms continue to evolve, industry\ncollaboration among security researchers, security vendors, and the broader\nsecurity community is essential in improving security for all. Microsoft\nremains committed to working with the security community to share\nvulnerability discoveries and threat intelligence to protect users across\nplatforms.\n\nAfter discovering this issue, we identified several vulnerable applications.\nAs part of our responsible disclosure policy, we notified application\ndevelopers through Coordinated Vulnerability Disclosure (CVD) via Microsoft\nSecurity Vulnerability Research (MSVR) and worked with them to address the\nissue. We would like to thank the Xiaomi, Inc. and WPS Office security teams\nfor investigating and fixing the issue. As of February 2024, fixes have been\ndeployed for the aforementioned apps, and users are advised to keep their\ndevice and installed applications up to date.\n\nRecognizing that more applications could be affected, we acted to increase\ndeveloper awareness of the issue by collaborating with Google to publish an\narticle on the Android Developers website, providing guidance in a high-\nvisibility location to help developers avoid introducing this vulnerability\npattern into their applications. We also wish to thank Google\u2019s Android\nApplication Security Research team for their partnership in resolving this\nissue.\n\nIn this blog post, we continue to raise developer and user awareness by giving\na general overview of the vulnerability pattern, and then focusing on Android\nshare targets, as they are the most prone to these types of attacks. We go\nthrough an actual code execution case study where we demonstrate impact that\nextends beyond the mobile device\u2019s scope and could even affect a local\nnetwork. Finally, we provide guidance to users and application developers and\nillustrate the importance of collaboration to improve security for all.\n\n## Overview: Data and file sharing on Android\n\nThe Android operating system enforces isolation by assigning each application\nits own dedicated data and memory space. To facilitate data and file sharing,\nAndroid provides a component called a content provider, which acts as an\ninterface for managing and exposing data to the rest of the installed\napplications in a secure manner. When used correctly, a content provider\nprovides a reliable solution. However, improper implementation can introduce\nvulnerabilities that could enable bypassing of read/write restrictions within\nan application\u2019s home directory.\n\nThe Android software development kit (SDK) includes the FileProvider class, a\nsubclass of ContentProvider that enables file sharing between installed\napplications. An application that needs to share its files with other\napplications can declare a FileProvider in its app manifest and declare the\nspecific paths to share.\n\nEvery file provider has a property called authority, which identifies it\nsystem-wide, and can be used by the consumer (the app that wants to access the\nshared files) as a form of address. This content-based model bears a strong\nresemblance to the web model, but instead of the http scheme, consumers\nutilize the content scheme along with the authority, followed by a pseudo-path\nto the file that they want to access.\n\nFor example, assuming that the application com.example.server shares some\nfiles under the file:///data/data/com.example.server/files/images directory\nthat it has previously declared as shared using the name shared_images, a\nconsumer can use the content://[authority]/shared_images/[sub-path]/[filename]\nURI to index these files.\n\nAccess is given by the data sharing application most commonly using the\ngrantUriPermissions attribute of the Android manifest, in combination with\nspecial flags that are used to define a read or write mode of operation. The\ndata sharing application creates and sends an intent to the consumer that\nprovides temporary fine-grained access to a file. Finally, when a provider\nreceives a file access request, it resolves the actual file path that\ncorresponds to the incoming URI and returns a file descriptor to it.\n\n### Implementation pitfalls\n\nThis content provider-based model provides a well-defined file-sharing\nmechanism, enabling a serving application to share its files with other\napplications in a secure manner with fine-grained control. However, we have\nfrequently encountered cases where the consuming application doesn\u2019t validate\nthe content of the file that it receives and, most concerning, it uses the\nfilename provided by the serving application to cache the received file within\nthe consuming application\u2019s internal data directory. If the serving\napplication implements its own malicious version of FileProvider, it may be\nable to cause the consuming application to overwrite critical files.\n\n### Share targets\n\nIn simple terms, a share target is an Android app that declares itself to\nhandle data and files sent by other apps. Common application categories that\ncan be share targets include mail clients, social networking apps, messaging\napps, file editors, browsers, and so on. In a common scenario, when a user\nclicks on a file, the Android operating system triggers the share-sheet dialog\nasking the user to select the component that the file should be sent to:\n\nFigure 1. The Android share sheet dialog\n\nWhile this type of guided file-sharing interaction itself may not trigger a\nsuccessful attack against a share target, a malicious Android application can\ncreate a custom, explicit intent and send a file directly to a share target\nwith a malicious filename and without the user\u2019s knowledge or approval.\nEssentially, the malicious application is substituting its own malicious\nFileProvider implementation and provides a filename that is improperly trusted\nby the consuming application.\n\nFigure 2. Dirty stream attack\n\nIn Figure 2, the malicious app, on the left, creates an explicit intent that\ntargets the file processing component of the share target, on the right, and\nattaches a content URI as an intent\u2019s extra. It then sends this intent to the\nshare target using the startActivity API call.\n\nAfter this point, most of the share targets that we have reviewed seem to\nfollow a specific code pattern that includes the following steps:\n\n  1. Request the actual filename from the remote file provider\n  2. Use this filename to initialize a file that is subsequently used to initialize a file output stream\n  3. Create an input stream using the incoming content URI\n  4. Copy the input stream to the output stream\n\nSince the rogue app controls the name as well as the content of the file, by\nblindly trusting this input, a share target may overwrite critical files in\nits private data space, which may lead to serious consequences.\n\n### Impact\n\nWe identified this vulnerability pattern in the then-current versions of\nseveral Android applications published on the Google Play Store, including at\nleast four with more than 500 million installations each. In each case, we\nresponsibly disclosed to the vendor. Two example vulnerable applications that\nwe identified are Xiaomi Inc.\u2019s File Manager (1B+ installs) and WPS Office\n(500M+ installs).\n\nIn Xiaomi Inc.\u2019s File Manager, we were able to obtain arbitrary code execution\nin version V1-210567. After our disclosure, Xiaomi published version\nV1-210593, and we verified that the vulnerability has been addressed. In WPS\nOffice, we were able to obtain arbitrary code execution in version 16.8.1.\nAfter our disclosure, WPS published and informed us that the vulnerability has\nbeen addressed as of version 17.0.0.\n\nThe potential impact varies depending on implementation specifics. For\nexample, it\u2019s very common for Android applications to read their server\nsettings from the shared_prefs directory. In such cases, the malicious app can\noverwrite these settings, causing the vulnerable app to communicate with an\nattacker-controlled server and send the user\u2019s authentication tokens or other\nsensitive information.\n\nIn a worst-case (and not so uncommon) scenario, the vulnerable application\nmight load native libraries from its data directory (as opposed to the more\nsecure /data/app-lib directory, where the libraries are protected from\nmodification). In this case, the malicious application can overwrite a native\nlibrary with malicious code that gets executed when the library is loaded. In\nthe following section, we use Xiaomi Inc.\u2019s File Manager to illustrate this\ncase. We demonstrated the ability for a malicious application to overwrite the\napplication\u2019s shared preferences, write a native library to the application\u2019s\ninternal storage, and cause the application to load the library. These actions\nprovided arbitrary code execution with the file manager\u2019s user ID and\npermissions.\n\nIn the following sections, we focus on this case and delve into the technical\ndetails of this vulnerability pattern.\n\n## Case study: Xiaomi Inc.\u2019s File Manager\n\nXiaomi Inc.\u2019s File Manager is the default file manager application for Xiaomi\ndevices and is published under the package name\ncom.mi.android.globalFileexplorer on the Google Play Store, where it has been\ninstalled over one billion times.\n\nFigure 3. Xiaomi\u2019s File Manager profile according to Android rank (source:\nFile Manager)\n\nBesides having full access to the device\u2019s external storage, the application\nrequests many permissions, including the ability to install other\napplications:\n\nFigure 4. A snapshot of the application\u2019s permissions\n\nFurther, it offers a junk files cleaner plugin as well as the ability to\nconnect to remote FTP and SMB shares:\n\nFigure 5. Connecting to remote shares using the file manager\n\n## Vulnerability assessment findings\n\nDuring our investigation, we identified that the application exports the\nCopyFileActivity, an activity alias of the\ncom.android.fileexplorer.activity.FileActivity, which is used to handle copy-\nfrom-to file operations:\n\nFigure 6. Triggering the copy to CopyFileActivity\n\nSince this activity is exported, it can be triggered by any application\ninstalled on the same device by using an explicit intent of action SEND or\nSEND_MULTIPLE and attaching a content URI corresponding to a file stream.\n\nUpon receiving such an intent, the browser performs a validity check, which we\nfound to be insufficient:\n\nFigure 7. Validating an incoming copy file request\n\nAs depicted above, the initCopyOrMoveIntent method calls the checkValid method\npassing as an argument a content URI (steps 1 and 2). However, the checkValid\nmethod is designed to handle a file path, not a content URI. It always returns\ntrue for a content URI. Instead, a safer practice is to parse the string as a\nURI, including ensuring the scheme is the expected value (in this case, file,\nnot content).The checkValid method verifies that the copy or move operation\ndoesn\u2019t affect the private directory of the app, by initializing a file object\nusing the incoming string as an argument to the File class constructor and\ncomparing its canonical path with the path that corresponds to the home\ndirectory of the application (steps 3 and 4). Given a content URI as a path,\nthe File constructor normalizes it (following a Unix file system\nnormalization), thus the getCanonicalPath method returns a string starting\nwith \u201c/content:/\u201c, which will always pass the validity check. More\nspecifically, the app performs a query to the remote content provider for the\n_size, _display_name and _data columns (see line 48 below). Then it uses the\nvalues returned by these rows to initialize the fields of an object of the\ncom.android.fileexplorer.mode.c class:\n\nFigure 8. Getting file metadata from the remote content provider\n\nGiven the case that the _display_name and _data values, returned from the\nexternal file provider, are relative paths to the destination directory, after\nexiting from the method above, these class fields will contain values like the\nones depicted below:\n\nFigure 9. The file model initialized after calling the method a\n\nAs shown above, the paths (variables d and e) of this file-model point to\nfiles within the home directory of the application, thus the file streams\nattached to the incoming intent are going to be written under the specific\nlocations.\n\n## Getting code execution\n\nAs previously mentioned, the application uses a plugin to clean the device\u2019s\njunk files:\n\nFigure 10. The junk files cleaner plugin user interface\n\nWhen the application loads this plugin, it makes use of two native libraries:\nlibixiaomifileu.so, which fetches from the /data/app directory, and\nlibixiaomifileuext.so from the home directory:\n\nFigure 11. Tracing the loaded native libraries using medusa\n\nAs apps don\u2019t have write access to the /data/app folder, the\nlibixiaomifileu.so file stored there cannot be replaced. The easiest way to\nget code execution is to replace the libixiaomifileuext.so with a malicious\none. However, an attempt to do so would fail since in this particular case,\nthe vulnerability that we described can only be used to write new files within\nthe home directory, not overwrite existing files. Our next inquiry was to\ndetermine how the application loads the libixiaomifileu.so.\n\nOur assessment showed that before the application loads this library, it\nfollows the following steps:\n\n  1. Calculate the hash of the file libixiaomifileu.so, located in the /data/app directory\n\n  2. Compare this hash with the value assigned to the \u201clibixiaomifileu.so_hm5\u201d string, fetched from the com.mi.android.globalFileexprorer_preferences.xml file\n\nFigure 12. the com.mi.android.globalFileexprorer_preferences.xml\n\n  3. If the values don\u2019t match, search for the libixiaomifileu.so file in the /files/lib path in the home directory\n\n  4. If the file is found there, calculate its hash and compare it again with the value from the shared_preferences folder\n\n  5. If the hashes match, load the file under the /files/lib using the System.load method\n\nGiven this behavior, in order to get code execution with the file manager\u2019s\nuser ID, an attacker must take the following steps:\n\n  1. Use the path traversal vulnerability to save a malicious library as /files/lib/libixiaomifileu.so (the file does not already exist in that directory, so overwriting is not an issue)\n\n  2. Calculate the hash of this library to replace the value of the libixiaomifileu.so_hm5 string\n\n  3. Trigger the junk cleaner plugin with an explicit intent, since the activity that loads the native libraries is exported\n\nAn acute reader might have noticed that the second step requires the attacker\nto force the browser to overwrite the\ncom.mi.android.globalFileexprorer_preferences.xml, which, as we already\nmentioned, was not possible.\n\nTo overcome this restriction, we referred to the actual implementation of the\nSharedPreferences class, where we found that when an Android application uses\nthe getSharedPreferences API method to retrieve an instance of the\nSharedPreferences class, giving the name of the shared preferences file as an\nargument, then the constructor of the SharedPreferencesImpl class performs the\nfollowing steps:\n\n  1. Create a new file object using the name provided to the getSharedPreferences method, followed by the .xml extension, followed by the .bak extension\n\n  2. Check if this file exists, and in case it does, delete the original xml file and replace it with the one created in the first step\n\nThrough this behavior, we were able to save the\ncom.mi.android.globalFileexprorer_preferences.xml.bak under the shared\npreferences folder (as during the application\u2019s runtime it is unlikely to\nexist), so when the app tried to verify the hash, the original xml file was\nalready replaced by our own copy. After this point, by using a single intent\nto start the junk cleaner plugin, we were able to trick the application to\nload the malicious library instead of the one under the /data/app folder and\nget code execution with the browser\u2019s user ID.\n\n## Impact\n\nOne reason we chose to use this app as a showcase is because the impact\nextends beyond the user\u2019s mobile device. The application gives the option to\nconnect to remote file shares using the FTP and SMB protocols and the user\ncredentials are saved in clear text in the\n/data/data/com.mi.android.globalFileexplorer/files/rmt_i.properties file:\n\nFigure 13. SMB/FTP credentials saved in clear text\n\nIf a third party app was able to exploit this vulnerability and obtain code\nexecution, an attacker could retrieve these credentials. The impact would then\nextend even further, since by the time that a user requests to open a remote\nshare, the browser creates the directory\n/sdcard/Android/data/com.mi.android.globalFileexplorer/files/usbTemp/ where it\nsaves the files that the user retrieves:\n\nFigure 14. SMB shared files, saved in the external storage\n\nThis means that a remote attacker would be able to read or write files to SMB\nshares of a local network, assuming that the device was connected to it. The\nsame stands for FTP shares as they are handled exactly in the same way:\n\nFigure 15. FTP shared files, saved in the external storage\n\nIn summary, the exploitation flow is depicted in the figure below:\n\nFigure 16. Getting remote access to local shares\n\nIn step 1, the user opens a malicious app that may pose as a file editor,\nmessaging app, mail client, or any app in general and request the user to save\na file. By the time that the user attempts to save such a file, no matter what\ndestination path they choose to save it, the malicious app forces the file\nbrowser app to write it under its internal /files/lib folder. Then, the\nmalicious app can start the junk cleaner using an explicit intent (no user\ninteraction is required) and this will lead to code execution with the\nbrowser\u2019s ID (step 2).\n\nIn step 3, the attacker uses the arbitrary code execution capability to\nretrieve the SMB and FTP credentials from the rmt_i.properties file.\nSubsequently, the attacker can now jump to step 5 and access the shares\ndirectly using the stolen credentials. Alternatively, after retrieving the\nshare credentials, the mobile device can connect to a local network (step 4)\nand access an SMB or FTP share, allowing the attacker to access the shared\nfiles through the\n/sdcard/Android/data/com.mi.android.globalFileexplorer/files/usbTemp/ folder\n(step 5).\n\n## Recommendations\n\nRecognizing that this vulnerability pattern may be widespread, we shared our\nfindings with Google\u2019s Android Application Security Research team. We\ncollaborated with Google to author guidance for Android application developers\nto help them recognize and avoid this pattern. We recommend developers and\nsecurity analysts familiarize themselves with the excellent Android\napplication security guidance provided by Google as well as make use of the\nAndroid Lint tool included with the Android SDK and integrated with Android\nStudio (supplemented with Google\u2019s additional security-focused checks) to\nidentify and avoid potential vulnerabilities. GitHub\u2019s CodeQL also provides\ncapabilities to identify vulnerabilities.\n\nTo prevent these issues, when handling file streams sent by other\napplications, the safest solution is to completely ignore the name returned by\nthe remote file provider when caching the received content. Some of the most\nrobust approaches we encountered use randomly generated names, so even in the\ncase that the content of an incoming stream is malformed, it won\u2019t tamper with\nthe application.\n\nIn cases where such an approach is not feasible, developers need to take extra\nsteps to ascertain that the cached file is written to a dedicated directory.\nAs an incoming file stream is usually identified by a content URI, the first\nstep is to reliably identify and sanitize the corresponding filename. Besides\nfiltering characters that may lead to a path traversal and before performing\nany write operation, developers must verify that the cached file is within the\ndedicated directory by performing a call to the File.getCanonicalPath and\nvalidating the prefix of the returned value.\n\nAnother area to safeguard is in the way developers try to extract a filename\nfrom a content URI. Developers often use Uri.getLastPathSegment(), which\nreturns the (URL) decoded value of the last path URI segment. An attacker can\ncraft a URI with URL encoded characters within this segment, including\ncharacters used for path traversal. Using the returned value to cache a file\ncan again render the application vulnerable to this type of attack.\n\nFor end users, we recommend keeping mobile applications up to date through the\nGoogle Play Store (or other appropriate trusted source) to ensure that updates\naddressing known vulnerabilities are installed. Users should only install\napplications from trusted sources to avoid potentially malicious applications.\nWe recommend users who accessed SMB or FTP shares through the Xiaomi app\nbefore updates to reset credentials and to investigate for any anomalous\nbehavior. Microsoft Defender for Endpoint on Android can alert users and\nenterprises to malicious applications, and Microsoft Defender Vulnerability\nManagement can identify installed applications with known vulnerabilities.\n\nDimitrios Valsamaras\n\nMicrosoft Threat Intelligence\n\n### References\n\n  * https://www.blackhat.com/asia-23/briefings/schedule/index.html#dirty-stream-attack-turning-android-share-targets-into-attack-vectors-30234\n  * https://developer.android.com/privacy-and-security/risks/untrustworthy-contentprovider-provided-filename\n  * https://developer.android.com/reference/androidx/core/content/FileProvider\n  * https://developer.android.com/guide/topics/manifest/provider-element#gprmsn\n  * https://play.google.com/store/apps/details?id=com.mi.android.globalFileexplorer\n  * https://play.google.com/store/apps/details?id=cn.wps.moffice_eng\n  * https://googlesamples.github.io/android-custom-lint-rules/checks/UnsafeDynamicallyLoadedCode.md.html\n  * https://androidrank.org/application/file_manager/com.mi.android.globalFileexplorer\n  * https://cs.android.com/android/platform/superproject/+/master:frameworks/base/core/java/android/app/SharedPreferencesImpl.java;l=150\n  * https://developer.android.com/privacy-and-security/risks\n  * https://developer.android.com/studio/write/lint#gradle\n  * https://github.com/google/android-security-lints/\n  * https://codeql.github.com/codeql-query-help/java/\n\n### Learn more\n\nFor the latest security research from the Microsoft Threat Intelligence\ncommunity, check out the Microsoft Threat Intelligence Blog:\nhttps://aka.ms/threatintelblog.\n\nTo get notified about new publications and to join discussions on social\nmedia, follow us on LinkedIn at https://www.linkedin.com/showcase/microsoft-\nthreat-intelligence, and on X (formerly Twitter) at\nhttps://twitter.com/MsftSecIntel.\n\nTo hear stories and insights from the Microsoft Threat Intelligence community\nabout the ever-evolving threat landscape, listen to the Microsoft Threat\nIntelligence podcast: https://thecyberwire.com/podcasts/microsoft-threat-\nintelligence.\n\n## Related Posts\n\n  *     * Research\n    * Threat intelligence\n    * Microsoft Defender\n    * Mobile threats\n\nPublished Nov 20, 2023\n\n9 min read\n\n## Social engineering attacks lure Indian users to install Android banking\ntrojans\n\nMicrosoft has observed ongoing activity from mobile banking trojan campaigns\ntargeting users in India with social media messages and malicious applications\ndesigned to impersonate legitimate organizations and steal users\u2019 information\nfor financial fraud scams.\n\n  *     * Research\n    * Threat intelligence\n    * Vulnerabilities and exploits\n\nPublished Mar 6, 2023\n\n6 min read\n\n## Protecting Android clipboard content from unintended exposure\n\nMicrosoft discovered that the SHEIN Android application periodically read the\ncontents of the Android device clipboard and, if a particular pattern was\npresent, sent the contents of the clipboard to a remote server.\n\n  *     * Research\n    * Threat intelligence\n    * Microsoft Defender\n    * Threat actors\n\nPublished Apr 11, 2023\n\n14 min read\n\n## DEV-0196: QuaDream\u2019s \u201cKingsPawn\u201d malware used to target civil society in\nEurope, North America, the Middle East, and Southeast Asia\n\nMicrosoft analyzes a threat group tracked as DEV-0196, the actor\u2019s iOS malware\n\u201cKingsPawn\u201d, and their link to an Israel-based private sector offensive actor\n(PSOA) known as QuaDream, which reportedly sells a suite of exploits, malware,\nand infrastructure called REIGN, that\u2019s designed to exfiltrate data from\nmobile devices.\n\n  *     * Research\n    * Threat intelligence\n    * Vulnerabilities and exploits\n\nPublished Aug 31, 2022\n\n11 min read\n\n## Vulnerability in TikTok Android app could lead to one-click account\nhijacking\n\nMicrosoft discovered a high-severity vulnerability in the TikTok Android\napplication, now identified as CVE-2022-28799 and fixed by TikTok, which could\nhave allowed attackers to compromise users' accounts with a single click.\n\n## Get started with Microsoft Security\n\nMicrosoft is a leader in cybersecurity, and we embrace our responsibility to\nmake the world a safer place.\n\nLearn more\n\n## Connect with us on social\n\nEnglish (United States) Your Privacy Choices Consumer Health Privacy\n\n", "frontpage": false}
