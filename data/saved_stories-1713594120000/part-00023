{"aid": "40091928", "title": "Using Zig to Provide Stack Traces on Kernel Panic for an Operating System", "url": "https://andrewkelley.me/post/zig-stack-traces-kernel-panic-bare-bones-os.html", "domain": "andrewkelley.me", "votes": 1, "user": "liamswayne", "posted_at": "2024-04-19 21:10:03", "comments": 0, "source_title": "Using Zig to Provide Stack Traces on Kernel Panic for a Bare Bones Operating System - Andrew Kelley", "source_text": "Using Zig to Provide Stack Traces on Kernel Panic for a Bare Bones Operating\nSystem - Andrew Kelley\n\nAndrew Kelley - Using Zig to Provide Stack Traces on Kernel Panic for a Bare\nBones Operating System (2018 Dec 04)\n\n# Using Zig to Provide Stack Traces on Kernel Panic for a Bare Bones Operating\nSystem\n\nLast week, I reached an exciting milestone in my career as a programmer. For\nthe first time in my life, I ran code directly on hardware, with no Operating\nSystem sitting between the bare metal and my code.\n\nFor some context, the goal of this side project is to create a 2-4 player\narcade game running directly on a Raspberry Pi 3+.\n\nHaving just gotten Hello World working, this software can do little more than\nsend a message over the serial uART on bootup:\n\n    \n    \n    Hello World! ClashOS 0.0\n\nSo what's the next step? Bootloader? File system? Graphics?!\n\nWell, when coding all of these things, I'm inevitably going to run into bugs\nand crashes. And when this happens, I want to quickly understand what's gone\nwrong. Normally, in Zig, when something goes wrong, you get a nice stack\ntrace, like this:\n\nThis example, however, is targeting Linux, whereas this arcade game project is\nfreestanding. The equivalent code in freestanding actually just hangs the CPU:\n\n    \n    \n    --- a/src/main.zig +++ b/src/main.zig serial.log(\"Hello World! ClashOS 0.0\\n\"); + var x: u8 = 255; + x += 1; + serial.log(\"got here\\n\");\n\nWhen run, you'll see we never get to the \"got here\" message, but also we don't\nget any kind of error message printed or anything.\n\n    \n    \n    Hello World! ClashOS 0.0\n\nTo understand this, we can look at the default panic handler. In Zig, you can\nprovide a pub fn panic in your root source file alongside pub fn main. But if\nyou do not provide this function, the default is used:\n\n    \n    \n    pub fn panic(msg: []const u8, error_return_trace: ?*builtin.StackTrace) noreturn { @setCold(true); switch (builtin.os) { builtin.Os.freestanding => { while (true) {} }, else => { const first_trace_addr = @ptrToInt(@returnAddress()); std.debug.panicExtra(error_return_trace, first_trace_addr, \"{}\", msg); }, } }\n\nHere we can see why the code earlier is hanging - the default panic handler\nfor the freestanding target is simply while(true) {}.\n\nSo we can make an immediate improvement by creating our own panic handler:\n\n    \n    \n    pub fn panic(message: []const u8, stack_trace: ?*builtin.StackTrace) noreturn { serial.write(\"\\n!KERNEL PANIC!\\n\"); serial.write(message); serial.write(\"\\n\"); while(true) {} }\n\nAnd now, the output of booting the Raspberry Pi:\n\n    \n    \n    Hello World! ClashOS 0.0 !KERNEL PANIC! integer overflow\n\nAlready this is much better. We can see that an integer overflow caused a\nkernel panic. But an integer overflow could occur anywhere. Wouldn't it be\nnice to have a full stack trace printed?\n\nYes, yes it would. The first thing I needed to make this work is access to the\nDWARF debugging info from inside the kernel. But I don't even have a file\nsystem. How can that work?\n\nEasy! Just put the DWARF info directly into the kernel's memory. I modified my\nlinker script to do just that:\n\n    \n    \n    .rodata : ALIGN(4K) { *(.rodata) __debug_info_start = .; KEEP(*(.debug_info)) __debug_info_end = .; __debug_abbrev_start = .; KEEP(*(.debug_abbrev)) __debug_abbrev_end = .; __debug_str_start = .; KEEP(*(.debug_str)) __debug_str_end = .; __debug_line_start = .; KEEP(*(.debug_line)) __debug_line_end = .; __debug_ranges_start = .; KEEP(*(.debug_ranges)) __debug_ranges_end = .; }\n\nAnd to my dismay, these error messages stared back at me:\n\n    \n    \n    lld: error: incompatible section flags for .rodata >>> /home/andy/dev/clashos/zig-cache/clashos.o:(.debug_info): 0x0 >>> output section .rodata: 0x12 lld: error: incompatible section flags for .rodata >>> <internal>:(.debug_str): 0x30 >>> output section .rodata: 0x12 lld: error: incompatible section flags for .rodata >>> /home/andy/dev/clashos/zig-cache/clashos.o:(.debug_line): 0x0 >>> output section .rodata: 0x32\n\nAfter a back and forth on a bug report, George Rimar suggested simply deleting\nthat particular check, as it might have been an overly strict enforcement. I\ntried this in my LLD fork, and it worked! Debug information was now linked\ninto my kernel images. After completing the rest of the steps in this blog\npost, I submitted a patch upstream, which Rui has already merged into LLD.\nThis will be released with LLVM 8, and in the meantime Zig's LLD fork has the\npatch.\n\nAt this point it was a simple matter of writing the glue code between my\nkernel and the Zig Standard Library's stack trace facilities. In Zig, you\ndon't have to intentionally support freestanding mode. Code which has no\ndependencies on a particular operating system will work in freestanding mode\nthanks to Zig's lazy top level declaration analysis. Because the standard\nlibrary stack trace code does not call any OS API, it therefore supports\nfreestanding mode.\n\nThe Zig std lib API for opening debug information from an ELF file looks like\nthis:\n\n    \n    \n    pub fn openElfDebugInfo( allocator: *mem.Allocator, elf_seekable_stream: *DwarfSeekableStream, elf_in_stream: *DwarfInStream, ) !DwarfInfo\n\nBut this kernel is so bare bones, it's not even in an ELF file. It's booting\ndirectly from a binary blob. We just have the debug info sections mapped\ndirectly into memory. For that we can use a lower level API:\n\n    \n    \n    /// Initialize DWARF info. The caller has the responsibility to initialize most /// the DwarfInfo fields before calling. These fields can be left undefined: /// * abbrev_table_list /// * compile_unit_list pub fn openDwarfDebugInfo(di: *DwarfInfo, allocator: *mem.Allocator) !void\n\nAnd DwarfInfo is defined like this:\n\n    \n    \n    pub const DwarfInfo = struct { dwarf_seekable_stream: *DwarfSeekableStream, dwarf_in_stream: *DwarfInStream, endian: builtin.Endian, debug_info: Section, debug_abbrev: Section, debug_str: Section, debug_line: Section, debug_ranges: ?Section, abbrev_table_list: ArrayList(AbbrevTableHeader), compile_unit_list: ArrayList(CompileUnit), };\n\nTo hook these up, the glue code needs to initialize the fields of DwarfInfo\nwith the offsets into a std.io.SeekableStream, which can be implemented as a\nsimple pointer to memory. By declaring external variables and then looking at\ntheir addresses, we can find out where in memory the symbols defined in the\nlinker script are.\n\nFor .debug_abbrev, .debug_str, and .debug_ranges, I had to set the offset to 0\nto workaround LLD thinking that the sections start at 0 for some reason.\n\n    \n    \n    var kernel_panic_allocator_bytes: [100 * 1024]u8 = undefined; var kernel_panic_allocator_state = std.heap.FixedBufferAllocator.init(kernel_panic_allocator_bytes[0..]); const kernel_panic_allocator = &kernel_panic_allocator_state.allocator; extern var __debug_info_start: u8; extern var __debug_info_end: u8; extern var __debug_abbrev_start: u8; extern var __debug_abbrev_end: u8; extern var __debug_str_start: u8; extern var __debug_str_end: u8; extern var __debug_line_start: u8; extern var __debug_line_end: u8; extern var __debug_ranges_start: u8; extern var __debug_ranges_end: u8; fn dwarfSectionFromSymbolAbs(start: *u8, end: *u8) std.debug.DwarfInfo.Section { return std.debug.DwarfInfo.Section{ .offset = 0, .size = @ptrToInt(end) - @ptrToInt(start), }; } fn dwarfSectionFromSymbol(start: *u8, end: *u8) std.debug.DwarfInfo.Section { return std.debug.DwarfInfo.Section{ .offset = @ptrToInt(start), .size = @ptrToInt(end) - @ptrToInt(start), }; } fn getSelfDebugInfo() !*std.debug.DwarfInfo { const S = struct { var have_self_debug_info = false; var self_debug_info: std.debug.DwarfInfo = undefined; var in_stream_state = std.io.InStream(anyerror){ .readFn = readFn }; var in_stream_pos: usize = 0; const in_stream = &in_stream_state; fn readFn(self: *std.io.InStream(anyerror), buffer: []u8) anyerror!usize { const ptr = @intToPtr([*]const u8, in_stream_pos); @memcpy(buffer.ptr, ptr, buffer.len); in_stream_pos += buffer.len; return buffer.len; } const SeekableStream = std.io.SeekableStream(anyerror, anyerror); var seekable_stream_state = SeekableStream{ .seekToFn = seekToFn, .seekForwardFn = seekForwardFn, .getPosFn = getPosFn, .getEndPosFn = getEndPosFn, }; const seekable_stream = &seekable_stream_state; fn seekToFn(self: *SeekableStream, pos: usize) anyerror!void { in_stream_pos = pos; } fn seekForwardFn(self: *SeekableStream, pos: isize) anyerror!void { in_stream_pos = @bitCast(usize, @bitCast(isize, in_stream_pos) +% pos); } fn getPosFn(self: *SeekableStream) anyerror!usize { return in_stream_pos; } fn getEndPosFn(self: *SeekableStream) anyerror!usize { return @ptrToInt(&__debug_ranges_end); } }; if (S.have_self_debug_info) return &S.self_debug_info; S.self_debug_info = std.debug.DwarfInfo{ .dwarf_seekable_stream = S.seekable_stream, .dwarf_in_stream = S.in_stream, .endian = builtin.Endian.Little, .debug_info = dwarfSectionFromSymbol(&__debug_info_start, &__debug_info_end), .debug_abbrev = dwarfSectionFromSymbolAbs(&__debug_abbrev_start, &__debug_abbrev_end), .debug_str = dwarfSectionFromSymbolAbs(&__debug_str_start, &__debug_str_end), .debug_line = dwarfSectionFromSymbol(&__debug_line_start, &__debug_line_end), .debug_ranges = dwarfSectionFromSymbolAbs(&__debug_ranges_start, &__debug_ranges_end), .abbrev_table_list = undefined, .compile_unit_list = undefined, }; try std.debug.openDwarfDebugInfo(&S.self_debug_info, kernel_panic_allocator); return &S.self_debug_info; }\n\nYou can see that the Zig common practice of accepting an allocator as an\nargument when allocation is needed comes in extremely handy for kernel\ndevelopment. We simply statically allocate a 100 KiB buffer and pass that\nalong as the debug info allocator. If this ever becomes too small, it can be\nadjusted.\n\nAnd now it's just a matter of wiring up the panic function:\n\n    \n    \n    pub fn panic(message: []const u8, stack_trace: ?*builtin.StackTrace) noreturn { serial.log(\"\\n!KERNEL PANIC! {}\\n\", message); const dwarf_info = getSelfDebugInfo() catch |err| { serial.log(\"unable to get debug info: {}\\n\", @errorName(err)); hang(); }; const first_trace_addr = @ptrToInt(@returnAddress()); var it = std.debug.StackIterator.init(first_trace_addr); while (it.next()) |return_address| { std.debug.printSourceAtAddressDwarf( dwarf_info, serial_out_stream, return_address, true, // tty color on printLineFromFile, ) catch |err| { serial.log(\"missed a stack frame: {}\\n\", @errorName(err)); continue; }; } hang(); } fn hang() noreturn { while (true) {} } fn printLineFromFile(out_stream: var, line_info: std.debug.LineInfo) anyerror!void { serial.log(\"TODO print line from the file\\n\"); }\n\nHere it is in action:\n\n    \n    \n    Hello World! ClashOS 0.0 !KERNEL PANIC! integer overflow /home/andy/dev/clashos/src/main.zig:166:7: 0x15e0 in ??? (clashos) TODO print line from the file ^ ???:?:?: 0x1c in ??? (???)\n\nGreat progress.\n\nThat last line is coming from the startup assembly code, which has no source\nmapping. But we can see that it's correct, by looking at the disassembly of\nthe kernel:\n\n    \n    \n    0000000000000000 <_start>: 0: d53800a0 mrs x0, mpidr_el1 4: d2b82001 mov x1, #0xc1000000 8: 8a210000 bic x0, x0, x1 c: b4000040 cbz x0, 14 <master> 10: 14000003 b 1c <__hang> 0000000000000014 <master>: 14: b26503ff mov sp, #0x8000000 18: 9400054b bl 1544 <kernel_main> 000000000000001c <__hang>: 1c: d503205f wfe 20: 17ffffff b 1c <__hang>\n\nYou can see that 0x1c is indeed the return address (the next instruction that\nwill be executed when the function returns) of the function call to\nkernel_main.\n\nLet's shuffle the code around into more files and make that trace longer.\n\n    \n    \n    Hello World! ClashOS 0.0 !KERNEL PANIC! integer overflow /home/andy/dev/clashos/src/serial.zig:42:7: 0x1b10 in ??? (clashos) TODO print line from the file ^ /home/andy/dev/clashos/src/main.zig:58:16: 0x1110 in ??? (clashos) TODO print line from the file ^ /home/andy/dev/clashos/src/main.zig:67:18: 0xecc in ??? (clashos) TODO print line from the file ^ ???:?:?: 0x1c in ??? (???)\n\nIt's looking good. But can we add a cherry on top, and make it print the\nsource lines?\n\nAgain we don't have a file system. How can the printLineFromFile function have\naccess to source files?\n\nSometimes the simplest solution is the best one. How about the kernel just has\nits own source code in memory?\n\nThat's really easy to hook up in Zig:\n\n    \n    \n    const source_files = [][]const u8{ \"src/debug.zig\", \"src/main.zig\", \"src/mmio.zig\", \"src/serial.zig\", }; fn printLineFromFile(out_stream: var, line_info: std.debug.LineInfo) anyerror!void { inline for (source_files) |src_path| { if (std.mem.endsWith(u8, line_info.file_name, src_path)) { const contents = @embedFile(\"../\" ++ src_path); try printLineFromBuffer(out_stream, contents[0..], line_info); return; } } try out_stream.print(\"(source file {} not added in std/debug.zig)\\n\", line_info.file_name); }\n\nHere we take advantage of inline for as well as @embedFile, and all the sudden\nwe can print lines of code from our own source files. printLineFromBuffer left\nas an exercise for the reader.\n\nSo let's see that output again:\n\n    \n    \n    Hello World! ClashOS 0.0 !KERNEL PANIC! integer overflow /home/andy/dev/clashos/src/serial.zig:42:7: 0x1b10 in ??? (clashos) x += 1; ^ /home/andy/dev/clashos/src/main.zig:58:16: 0x1110 in ??? (clashos) serial.boom(); ^ /home/andy/dev/clashos/src/main.zig:67:18: 0xecc in ??? (clashos) some_function(); ^ ???:?:?: 0x1c in ??? (???)\n\nBeautiful. Here's a picture so you can see it with color:\n\nAnd now all of the protections that Zig offers against undefined behavior will\nresult in output like this.\n\n### Conclusion\n\nOne of my big goals with Zig is to improve the embedded and OS development\nprocess. I hope you're as excited as I am about the potential here.\n\nIf this blog post captured your interest, maybe you would like to check out\nthis Hello World x86 Kernel, which comes with a video of me live coding it.\nThanks to an insightful Twitch comment, it works with only Zig code, no\nassembly required.\n\nThanks for reading my blog post.\n\nHome Page | RSS feed | Sponsor the Zig Software Foundation\n\n", "frontpage": false}
