{"aid": "40083008", "title": "What's the difference between JavaScript engines and JavaScript runtimes?", "url": "https://humanwhocodes.com/blog/2024/03/javascript-engines-runtimes/", "domain": "humanwhocodes.com", "votes": 1, "user": "simonpure", "posted_at": "2024-04-19 02:49:04", "comments": 0, "source_title": "What's the difference between JavaScript engines and JavaScript runtimes?", "source_text": "What's the difference between JavaScript engines and JavaScript runtimes? -\nHuman Who Codes\n\n# What's the difference between JavaScript engines and JavaScript runtimes?\n\nRuntimes and engines are often incorrectly referred to as the same thing.\n\nPosted at March 26, 2024 by Nicholas C. Zakas\n\nTags: JavaScript, ECMAScript, APIs\n\nYou have probably heard the terms \u201cJavaScript engine\u201d and \u201cJavaScript runtime\u201d\nused interchangeably to mean \u201ca program that runs JavaScript.\u201d These are often\nintermixed by referencing V8, Node.js, or some other combination of related\nprograms. However, there is a significant difference between a JavaScript\nengine and a JavaScript runtime in terms of scope and functionality.\nUnderstanding this difference is key to a good understanding of the JavaScript\nlanguage as a whole.\n\nBefore discussing what an engine is vs. a runtime, though, it helps to define\na couple of terms that are often used in conjunction with both engine and\nruntime: ECMAScript and JavaScript.\n\n## What is ECMAScript?\n\nIn 1996, Netscape and Sun Microsystems approached Ecma International, a\nnonprofit standards organization, about standardizing JavaScript. The result\nof that effort, released in 1997, was ECMA-262, the specification that defines\nhow a JavaScript implementation should work. With Sun unwilling to donate the\nJavaScript trademark,^1 the specification had to have a different name, and so\nECMA-262 was titled, \u201cECMAScript Language Specification.\u201d ECMAScript,\ntherefore, is the name of the language specified in ECMA-262.\n\nECMAScript defines the core functionality of JavaScript that must be\nimplemented by conforming implementations regardless of where they are\nembedded (a program that embeds an implementation is called a host). Even at\nthis early stage, Netscape intended to use JavaScript not just in the browser,\nbut also on the server, and ECMAScript was to serve as the core for both\nimplementations. As such, ECMAScript does not contain any web-related\nfunctionality nor any way to input or output data (such functionality must be\nprovided by the host). That means ECMAScript contains, for example, standard\nglobal classes such as Object, Array, and Promise, but does not contain\nHTMLElement, setTimeout, or fetch().\n\n## What is JavaScript?\n\nThe term \u201cJavaScript\u201d has no formal definition but it\u2019s widely understood to\nbe a superset of the ECMAScript language. That means JavaScript implements\nECMAScript in addition to other specifications and other functionality. In its\nearly form, JavaScript was considered to be ECMAScript plus the web-based APIs\nlike the Document Object Model (DOM) and browser-based APIs like the History\nAPI. Today, JavaScript is considered to be any combination of ECMAScript plus\nany other host-provided APIs. This includes web-specific API for browsers and\nserver-specific APIs for hosts like Node.js.\n\n## What is a JavaScript engine?\n\nWhat are commonly referred to as JavaScript engines could more accurately be\ncalled ECMAScript engines, because they implement ECMA-262 without any (or\nmuch) additional functionality. A JavaScript engine is meant to be embedded in\na host, which in turn defines additional functionality for input and output.\nThe best known JavaScript engines are:\n\n  * V8^2 - Created as the JavaScript engine for the Chromium project and is now also used in Node.js and Deno. Because Edge and Opera are based on Chromium, V8 is the most frequently used JavaScript engine.\n  * SpiderMonkey^3 - The JavaScript engine for Firefox.\n  * JavaScriptCore^4 - Created as the JavaScript engine for Safari, both on MacOS and in iOS, and is also used in Bun.\n\nBecause JavaScript engines only implement ECMAScript and are meant to be\nextended by a host, they can be used in a variety of different runtime\nenvironments.\n\n## What is a JavaScript runtime?\n\nA JavaScript runtime is an ECMAScript host, meaning that it is a program that\nembeds a JavaScript engine. Chrome, Firefox, Edge, Safari, Node.js, Deno, and\nBun are all JavaScript runtimes because they embed a JavaScript engine and\ndefine additional functionality that is accessible through JavaScript. The web\nbrowsers implement the DOM and other web APIs while the server-side runtimes\nimplement file system access.\n\nThere are no rules as to what additional functionality a JavaScript runtime\nmay add; the runtime developers can decide for themselves. That\u2019s why Node.js,\nDeno, and Bun all implement file systems in different ways and why Deno\ndecided to favor web APIs such as fetch() while Node.js initially decided to\nimplement their own HTTP client (Node.js has since also adopted fetch()). But\nit\u2019s not just JavaScript APIs that make JavaScript runtimes unique. It\u2019s also\nthe way in which they use the JavaScript engine.\n\nThe event loop, the process that allows a runtime to switch between running\nJavaScript and performing other tasks, for example, is not defined in ECMA-262\nand therefore is not implemented in any JavaScript engine. It\u2019s up to each\nJavaScript runtime to implement its own event loop. Web browsers have their\nversion of the event loop defined in the HTML specification^5 but server-side\nruntimes such as Node.js define their own.^6 An event loop is not required for\na JavaScript runtime but is found in general-purpose JavaScript runtimes.\n\n## Summary\n\nJavaScript engines and JavaScript runtimes are related but not the same. A\nJavaScript engine implements ECMAScript as defined by the ECMA-262 standard.\nECMA-262 defines the core functionality of JavaScript without any affordances\nfor input or output. A JavaScript runtime is an ECMAScript host that embeds a\nJavaScript engine and augments it with additional functionality for input and\noutput, along with anything else the runtime needs. Additional functionality\nmight include the DOM in web browsers or file system access in server-side\nruntimes. Runtimes are under no obligation to follow other standards and are\nable to define their own APIs as necessary, which is why Node.js, Deno, and\nBun all have different file system APIs.\n\n## Footnotes\n\n  1. JavaScript creator ponders past, future \u21a9\n\n  2. V8 - Google\u2019s open source JavaScript engine \u21a9\n\n  3. SpiderMonkey - The JavaScript engine for Firefox \u21a9\n\n  4. JavaScriptCore - The JavaScript engine for Safari \u21a9\n\n  5. HTML Living Standard - Event Loops \u21a9\n\n  6. Node.js - Event Loop, Timers, and process.nextTick() \u21a9\n\nDemystify JavaScript promises with the e-book that explains not just concepts,\nbut also real-world uses of promises.\n\n## Download the Free E-book!\n\nThe community edition of Understanding JavaScript Promises is a free download\nthat arrives in minutes.\n\n# Additional Information\n\nSend transactional or bulk emails from your app with our developer friendly\nRESTful API. Free trial. ads via Carbon\n\n## My Books\n\n## Recent Snippets\n\n  * Publishing to JSR using release-please\n  * How to setup a known_hosts file for a Jenkins pipeline job\n  * Mimicking __dirname and __filename in ESM modules in Node.js\n  * How to add npm packages for client-side use in Eleventy\n  * Creating a new user with an SSH key on Linux\n  * How to setup and deploy a web application on Dokku\n  * How to regain Jenkins web access after being locked out\n  * Create TypeScript declarations from JavaScript and JSDoc\n  * How to read environment variables in Deno using JavaScript\n  * How to validate the signature of a GitHub webhook using Node.js\n\n## Archives (20 Years)\n\n  * 2024\n  * 2023\n  * 2022\n  * 2021\n  * 2020\n  * 2019\n  * 2018\n  * 2016\n  * 2015\n  * 2014\n  * 2013\n  * 2012\n  * 2011\n  * 2010\n  * 2009\n  * 2008\n  * 2007\n  * 2006\n  * 2005\n  * 2004\n\n## About the Human\n\nHi, I'm Nicholas C. Zakas, an independent software developer living in\nMountain View, California. I've been a software architect at companies like\nYahoo and Box, as well as an author and speaker. I created the ESLint open\nsource project and wrote several books. At the moment, I'm recovering from\nLyme disease and haven't been able to leave my home much in the past five\nyears. (Health update, More about me)\n\n## On the Web\n\n  * Mastodon\n  * Twitter\n  * GitHub\n  * Instagram\n  * YouTube\n  * LinkedIn\n  * Slideshare\n  * Amazon\n\nPrivacy Policy | Terms of Service\n\nCopyright \u00a9 2020-2024 Human Who Codes LLC. Content licensed under a Creative\nCommons Attribution-NonCommercial-NoDerivs 3.0 Unported License. Some links\nmay be affiliate links. We may get paid if you buy something or take an action\nafter clicking one of these. As an Amazon Associate we earn from qualifying\npurchases. Blog Feed\n\n", "frontpage": false}
