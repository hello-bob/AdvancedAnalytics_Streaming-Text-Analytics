{"aid": "40055885", "title": "Cross compiling C/Rust to Win32, again", "url": "https://neugierig.org/software/blog/2024/04/cross-compile-2.html", "domain": "neugierig.org", "votes": 1, "user": "ingve", "posted_at": "2024-04-16 19:00:09", "comments": 0, "source_title": "Tech Notes: Cross compiling C/Rust to win32, again", "source_text": "Tech Notes: Cross compiling C/Rust to win32, again\n\n# neugierig.org: Tech Notes\n\nYou're reading a single entry. Go back to the front page for more.\n\n## Cross compiling C/Rust to win32, again\n\nApril 16, 2024\n\nThis post is part of a series on retrowin32.\n\nEarlier I wrote about cross compiling Rust to win32. I ended up not following\nthrough on that approach due to missing compiler intrinsics. Instead here are\ntwo closely related dives.\n\n## Cross compiling C to win32\n\nClang supports cross compilation, including targeting Windows, but I kept\ngetting it wrong. After a few false starts, I reached out to Nico, who\nactually knows things, and he set me straight, so thank him for anything you\nlearn from this post!\n\nClang has a clang-cl binary that is intended to be a drop-in substitute for\nVisual Studio's cl.exe, which means not only matching the command-line\ninterface in terms of how flags are spelled (which I don't care much about)\nbut importantly also in terms of preconfiguring the compiler settings to\nproperly produce a Windows output (which ends up critical). For example, if\nyour program #includes a Windows header file, you need the compiler to be\nconfigured to understand all the minor language variations found in Windows-\nstyle source code.\n\nThis means cross compiling C++ code to Windows ends up being as simple as\nsomething like this. (I'm still not exactly clear on when flags are hyphenated\nor slashed, but I do know to pass linker args to cl.exe they must follow the\n/link switch...)\n\n    \n    \n    $ clang-cl -fuse-ld=lld -target i686-pc-windows-msvc \\ -vctoolsdir $xwin_path/crt -winsdkdir $xwin_path/sdk \\ foo.cc \\ /link /subsystem:console\n\nFully worked example here.\n\n## xwin\n\nThe above invocation needs Windows headers and libraries in a particular file\nsystem layout. They are available from Microsoft but only in the form of\ninstaller .exe files.\n\nwinetricks is a script that downloads and unpacks those (and many other\nredistributable packages) by invoking the executables through Wine. (I briefly\nthought about running this through retrowin32 but the exes target modern\nWindows, not the old Windows that retrowin32 targets.)\n\nBut as I mentioned in the previous post, there is a tool called xwin that\ndownloads and unpacks the .exes directly. This is a subtle process \u2014 the files\ncan be VSIX or CAB files which contain XML blob indexing other files and\nthere's some manual shuffling of files around when unpacking happens \u2014 which\ndoesn't give me a lot of confidence it will keep working into the future, but\nfor now, an invocation like this:\n\n    \n    \n    $ xwin --accept-license --arch x86 splat --output redist --disable-symlinks\n\n(where --disable-symlinks is only needed on a case insensitive file system)\nproduces a directory layout that the above clang-cl invocation accepts.\n\n## Back to Rust, and calling conventions\n\nLooking back, many of the problems I encountered in my previous post were due\nto using Rust's no_std. I was avoiding the Rust standard library for a few\nreasons but primarily because it used SSE instructions, which retrowin32\ndoesn't (yet?) support. But it turns out that switching the Rust target from\ni686-pc-windows-msvc to i585-pc-windows-msvc was sufficient to avoid these.\n\nI could then run a Rust \"hello world\" with-std app in retrowin32 with a few\nmore function stubs. The only tricky one was that it needs memcpy from\nvcruntime140.dll. Implementing memcpy is pretty easy; the tricky part was\nrealizing it uses the cdecl calling convention. To understand why this matters\nyou need a bit of background.\n\nFirst, on Windows there are two main calling conventions, called stdcall and\ncdecl. In both, the caller pushes its arguments onto the stack right to left.\nIn stdcall, the callee is then responsible for popping those arguments, while\nin cdecl it's the caller. (There's a lot more to it than just this; I found\nthis reference especially helpful.)\n\nI'm not clear on why both exist. A benefit of stdcall is you only need the\nstack-popping code in one location (the callee) and not once per caller, and\nin fact the ret instruction takes an integer argument of how much to pop so it\nonly costs two extra bytes in the binary. A benefit of cdecl is that it's\narguably necessary for varargs functions \u2014 or at least that is what sources\nonline say, but it seems to me you could make it work either way so I'm not\nreally sure. (I guess it would be more fragile in the case where the callee\ndoesn't consume all its varargs inputs? Maybe it'd more complex with all the\nmodern stack corruption mitigations?)\n\nIn any case, up to this point retrowin32 implements hundreds of Windows\nfunctions but they were all stdcall. It implements these functions in two\nlayers.\n\nFirst, I implement a given Windows API function via an annotated Rust function\nusing Rust types, like the following:\n\n    \n    \n    #[win32_derive::dllexport] pub fn SetThreadDescription( machine: &mut Machine, hThread: HTHREAD, lpThreadDescription: Option<&Str16>, ) -> bool { ... }\n\nSecond, a code generator collects up all the functions that were annotated as\ndllexport and generates code for each that translates emulator state into a\ncall to these functions. For example, for the above it knows to pull hThread\nand lpThreadDescription off the emulated stack, and the latter is an optional\npointer to a NUL-terminated WTF-16 string that needs to be read from emulated\nmemory. The bool return value becomes an integer that goes in the emulator's\neax register. And finally that the stack is popped by 8 bytes because that's\nwhat the arguments used.\n\nTo support cdecl, I only needed to adjust the dllexport code generation to\ncontrol how much stack was popped. With that in place retrowin32 can now at\nleast run a simple Rust program with println!(\"hello, world\");.\n\n## Inline assembly\n\nThe reason I have been poking at all of this is because I want to write a test\nsuite over my implementations of x86 opcodes, and I want to run that suite on\na native x86 to verify my emulator behavior matches the real thing.\n\nBecause I want to test specifically the invocations of opcodes I write inline\nassembly to do it. This has allowed me to contrast the way inline assembly\nworks in C and in Rust.\n\nClang follows gcc syntax for inline assembly, as documented in the gcc docs\n(and I believe nowhere in the Clang docs?). It is syntactically surprisingly\nclunky. For example:\n\n  * to write multiple instructions of assembly you must embed literal '\\n's into the string;\n  * it treats % as an escape metacharacter, but meanwhile (in AT&T syntax) registers are prefixed with %, which means to refer to a register you must write it doubled as %%;\n  * to specify inputs/outputs/clobbers, you write them after : in the blocks, which means you end up with awkward empty blocks (see e.g. the /* No outputs */ comment in the example here);\n  * the syntax within these blocks is itself a kind printf-like format string with docs describing things like \"g\" means \"Any register, memory or immediate integer operand is allowed, except for registers that are not general registers.\"\n\nI have no context here so I imagine a lot of the above probably organically\ngrew from how assemblers worked over gcc's history. It doesn't feel like the\nthing you would design if you were inventing it today.\n\nMeanwhile, clang-cl configures clang to work like a Windows compiler, which\nmeans it also supports Microsoft's inline assembly syntax. I don't have much\nexperience with this except that it looks a lot simpler than the gcc syntax.\nIt seems the compiler must infer a lot more of the context that is explicitly\nstated in the gcc format to get things like clobbers right; that is at least\nwhat LLVM does, where you can see the ~{flags} bits on the right.\n\nFinally, Rust has its own syntax for inline assembly that feels very sensible.\n(Rust supports many fewer architectures than gcc, which possibly makes the\nproblem space a lot easier?) Since it backs onto LLVM anyway it feels\nsemantically close to Clang, but the syntactical problems like how options are\nspecified is in a simple syntax with keywords.\n\nOne bit of cute syntax I enjoyed: in assembly in various places you end up\nusing a letter suffix to specify the size of a given operation; for example in\nAT&T assembly you write addb to specify a byte-sized add but addw for a 16-bit\n(\"word\") add. Unfortunately I keep getting these letter suffixes confused,\nwhere AT&T uses e.g. l for \"long\" when Intel uses d for \"dword\", both to\nspecify a 32-bit operation. (The worst is q is for \"quad word\", aka (2-byte\nword) * 4 = 8 bytes.) LLVM has a zoo of single-letter codes which is surely\nnecessary for modeling all the necessary complexity.\n\nMeanwhile, it's not the same context so it's a little unfair, but in Rust asm\ntemplates the formatting codes just correspond to the register names \u2014 e.g.\nyou use e (as in eax, ebx) to refer to 32 bits, or l (as in al, bl) for the\nlow 8 bits.\n\nBetween these options and given how the rest of retrowin32 is in Rust already\nI am leaning towards using Rust (if anything, my main complaint is that the\nRust autoformatter skips my asm blocks, possibly because it's a macro?). The\nbinaries are pretty large, so maybe that is what I will look into next...\n\n", "frontpage": false}
