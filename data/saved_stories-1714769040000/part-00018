{"aid": "40247633", "title": "Prima has got a Python interface", "url": "https://github.com/libprima/prima", "domain": "github.com/libprima", "votes": 3, "user": "zaikunzhang", "posted_at": "2024-05-03 13:48:30", "comments": 7, "source_title": "GitHub - libprima/prima: PRIMA is a package for solving general nonlinear optimization problems without using derivatives. It provides the reference implementation for Powell's derivative-free optimization methods, i.e., COBYLA, UOBYQA, NEWUOA, BOBYQA, and LINCOA. PRIMA means Reference Implementation for Powell's methods with Modernization and Amelioration, P for Powell.", "source_text": "GitHub - libprima/prima: PRIMA is a package for solving general nonlinear\noptimization problems without using derivatives. It provides the reference\nimplementation for Powell's derivative-free optimization methods, i.e.,\nCOBYLA, UOBYQA, NEWUOA, BOBYQA, and LINCOA. PRIMA means Reference\nImplementation for Powell's methods with Modernization and Amelioration, P for\nPowell.\n\nSkip to content\n\n## Navigation Menu\n\nSign in\n\n# Search code, repositories, users, issues, pull requests...\n\nSearch syntax tips\n\nSign in\n\nSign up\n\nYou signed in with another tab or window. Reload to refresh your session. You\nsigned out in another tab or window. Reload to refresh your session. You\nswitched accounts on another tab or window. Reload to refresh your session.\nDismiss alert\n\nlibprima / prima Public\n\n  * Notifications\n  * Fork 33\n  * Star 275\n\nPRIMA is a package for solving general nonlinear optimization problems without\nusing derivatives. It provides the reference implementation for Powell's\nderivative-free optimization methods, i.e., COBYLA, UOBYQA, NEWUOA, BOBYQA,\nand LINCOA. PRIMA means Reference Implementation for Powell's methods with\nModernization and Amelioration, P for Powell.\n\nlibprima.net\n\n### License\n\nBSD-3-Clause license\n\n275 stars 33 forks Branches Tags Activity\n\nStar\n\nNotifications\n\n# libprima/prima\n\nThis commit does not belong to any branch on this repository, and may belong\nto a fork outside of the repository.\n\n2 Branches\n\n12 Tags\n\n## Folders and files\n\nName| Name| Last commit message| Last commit date  \n---|---|---|---  \n  \n## Latest commit\n\nzaikunzhangMerge pull request #203 from\nlibprima/dependabot/github_actions/pypa/...May 3, 2024fdbe1a1 \u00b7 May 3, 2024May\n3, 2024\n\n## History\n\n5,323 Commits  \n  \n### .development @ faa999d\n\n|\n\n### .development @ faa999d\n\n| 240406.235444.HKT fortran/newuoa: revise the threshold for shiftbase ...|\nApr 6, 2024  \n  \n### .github\n\n|\n\n### .github\n\n| Bump pypa/cibuildwheel from 2.16.5 to 2.17.0| May 3, 2024  \n  \n### .mygit\n\n|\n\n### .mygit\n\n| 240312.120630.HKT use /usr/bin/env bash instead of /bin/bash/| Mar 12, 2024  \n  \n### benchmark\n\n|\n\n### benchmark\n\n| 231003.105256.HKT fix spelling| Oct 3, 2023  \n  \n### c\n\n|\n\n### c\n\n| Removed limits.h| Apr 21, 2024  \n  \n### fortran\n\n|\n\n### fortran\n\n| 240421.192835.HKT [skip ci] fix a failure of dtest| Apr 21, 2024  \n  \n### matlab\n\n|\n\n### matlab\n\n| 240421.150115.HKT fix a failure of ftest: \"Assertion fails: KNEW >= 1...|\nApr 21, 2024  \n  \n### python\n\n|\n\n### python\n\n| 240501.135558.HKT revoke the changes to test_combining_constraints.py| May\n1, 2024  \n  \n### todo\n\n|\n\n### todo\n\n| 240319.193520.HKT update allow.txt, fix a failure of cirrus tests| Mar 19,\n2024  \n  \n### .cirrus.yml\n\n|\n\n### .cirrus.yml\n\n| 240421.220154.HKT revise .cirrus.yml| Apr 21, 2024  \n  \n### .git-archival.txt\n\n|\n\n### .git-archival.txt\n\n| Get the version number using git describe| Dec 28, 2023  \n  \n### .gitattributes\n\n|\n\n### .gitattributes\n\n| Get the version number using git describe| Dec 28, 2023  \n  \n### .gitignore\n\n|\n\n### .gitignore\n\n| Added Python bindings| Apr 21, 2024  \n  \n### .gitmodules\n\n|\n\n### .gitmodules\n\n| Added Python bindings| Apr 21, 2024  \n  \n### CMakeLists.txt\n\n|\n\n### CMakeLists.txt\n\n| 240501.222431.HKT add comments to CMakeLists.txt| May 1, 2024  \n  \n### LICENCE.txt\n\n|\n\n### LICENCE.txt\n\n| 240303.014531.HKT norma: correct preprima_norma| Mar 2, 2024  \n  \n### NEWS.md\n\n|\n\n### NEWS.md\n\n| PR feedback| Jan 25, 2024  \n  \n### README.md\n\n|\n\n### README.md\n\n| 240501.030659.HKT add \"Build Python wheels\" to README| Apr 30, 2024  \n  \n### README_mat.md\n\n|\n\n### README_mat.md\n\n| 230604.073411.CST update README_mat| Jun 3, 2023  \n  \n### prima-config.cmake.in\n\n|\n\n### prima-config.cmake.in\n\n| No need to enable Fortran language in cmake project| Sep 21, 2023  \n  \n### pyproject.toml\n\n|\n\n### pyproject.toml\n\n| Minor changes| Apr 21, 2024  \n  \n### setup.m\n\n|\n\n### setup.m\n\n| 240401.114802.HKT update setup.m regarding the message printed when M...|\nApr 1, 2024  \n  \n## Repository files navigation\n\n## PRIMA: Reference Implementation for Powell's Methods with Modernization and\nAmelioration\n\nDedicated to the late Professor M. J. D. Powell FRS (1936--2015)\n\n  * What\n  * Why\n  * How\n  * Current status\n\n    * Modern Fortran\n    * C\n    * Python\n    * MATLAB\n    * Julia\n    * Other languages\n  * Bug fixes\n  * Improvements\n  * Who was Powell?\n  * A \"fun\" fact\n  * Acknowledgment\n  * Citing PRIMA\n  * Charityware\n  * Contact\n  * Mirrors\n\n    * Gitee\n    * GitHub\n    * GitLab\n  * Star history\n\n### What\n\nPRIMA is a package for solving general nonlinear optimization problems without\nusing derivatives. It provides the reference implementation for Powell's\nrenowned derivative-free optimization methods, i.e., COBYLA, UOBYQA, NEWUOA,\nBOBYQA, and LINCOA. The \"P\" in the name stands for Powell, and \"RIMA\" is an\nacronym for \"Reference Implementation with Modernization and Amelioration\".\n\nPRIMA is part of a research project funded by the Hong Kong Research Grants\nCouncil and the Department of Applied Mathematics (AMA) at the Hong Kong\nPolytechnic University (PolyU). The current version is ready to be used in\nFortran, in C, in Python, in MATLAB, and in Julia.\n\nPRIMA was initiated by Zaikun Zhang in July 2020, based on the PDFO package by\nTom M. Ragonneau and Zaikun Zhang.\n\nSee Zaikun Zhang's talk on PRIMA at The 10th International Congress on\nIndustrial and Applied Mathematics for more information.\n\n### Why\n\nProfessor Powell carefully implemented his derivative-free optimization\nmethods into publicly available solvers, which are genuine masterpieces. They\nare widely used by engineers and scientists. For instance, see Section 1 of a\nrecent paper on Powell's solvers as well as the Google searches of COBYLA and\nBOBYQA.\n\nHowever, Professor Powell's implementation was done in Fortran 77. The code is\nnontrivial to understand or maintain, let alone extend. For many\npractitioners, this has become an obstacle to exploiting these solvers in\ntheir applications. Even worse, it has hindered researchers from exploring the\nwealth left by Professor Powell. By all means, it is necessary to make the\nsolvers available in languages other than Fortran promptly, first wrapping\nPowell's code, which is the objective of PDFO, and then providing native and\nmodernized implementations, which is the mission of PRIMA.\n\nBefore he passed, Professor Powell had asked me and Professor Nick Gould to\nmaintain his solvers. This is an honorable mission. To make the solvers more\naccessible, I started PRIMA. It is a project similar to the translation,\ninterpretation, and annotation of Euclid\u2019s Elements. It will make Powell's\nsolvers easily understandable to everyone, not only the experts. Few people\nremember who translated Elements, but it is a job that must be done.\n\nPRIMA aims to provide the reference implementation of Powell's methods in\nmodern languages, including modern Fortran (F2008 or newer), C/C++, Python,\nMATLAB, Julia, and R. It will be a faithful implementation, in the sense that\nthe code will be mathematically equivalent to Powell\u2019s, except for the bug\nfixes and improvements made intentionally.\n\nThe focus is to implement these methods in a structured and modularized way so\nthat they are understandable, maintainable, extendable, fault-tolerant, and\nfuture-proof. The code will have no GOTO (of course) and will use matrix-\nvector procedures instead of loops whenever possible. In doing so, PRIMA codes\nthe algorithms in a way that we would present them on a blackboard. Such an\nimplementation will enable us to get a deeper understanding of Powell's\nmethods and pave the way for new developments based on them.\n\nThere do exist \"translations\" of Powell's Fortran 77 code in other languages.\nFor example, NLopt contains a C version of COBYLA, NEWUOA, and BOBYQA, but the\nC code in NLopt is translated from the Fortran 77 code straightforwardly, if\nnot automatically by f2c, and hence inherits the style, structure, and\nprobably bugs of the original Fortran 77 implementation. Note, however, that\nPy-BOBYQA is a true translation of BOBYQA to Python, with significant\nimprovements.\n\n### How\n\nThe mission of PRIMA is nontrivial due to the delicacy of Powell's algorithms\nand the unique style of his code. To ensure the faithfulness of PRIMA, the\nmodern Fortran version was started by refactoring Powell's code into the free\nform via a small MATLAB tool. However, such refactored code is far from what\nis desired, because it inherits completely the structure and style of Powell's\ncode except for the layout. Significant modifications are needed to reorganize\n(indeed, to rewrite) the code. To maintain the faithfulness and quality of the\nreference implementation, extensive tests are conducted after each and every\ntiny modification, using the CUTEst problems via MatCUTEst. The tests do not\nonly verify the faithfulness of the implementation but also check that the\nsolvers behave properly even if they are invoked with improper inputs or\nencounter failures of function evaluations. Stress tests are also conducted\nperiodically to verify that the solvers work correctly without running into\nerrors when applied to excessively large problems.\n\nThe tests are automated by GitHub Actions. As of August 2023, more than 45,000\n\"workflows\" have been successfully run by GitHub Actions. Normally, each\nworkflow consists of ~ 5 (sometimes more than 200) randomized tests, each test\ntaking from tens of minutes to several hours (the maximum is 6 hours, after\nwhich the test will be canceled automatically). In other words, PRIMA has been\nverified by more than 200,000 hours (or more than 20 years) of randomized\ntests. Code must be battle-tested before becoming software.\n\nSince each GitHub Team account can only run at most 60 GitHub Actions\nworkflows concurrently, I have to distribute this large amount of tests to\nmultiple Team accounts as follows.\n\n  * Tests at libprima/prima\n\n  * Tests at libsprima/prima\n\n  * Tests at primapack/prima\n\n  * Tests at fortlab/prima\n\n  * Tests at primalib/prima\n\n  * Tests at opt4ai/prima\n\n  * Tests at opt2ai/prima\n\n  * Tests at sprimalib/prima\n\n  * Tests at zequipe/prima\n\n  * Tests at equipez/prima\n\n  * Tests at s-prima/prima\n\n### Current status\n\n#### Modern Fortran\n\nAfter almost three years of intensive coding, the modern Fortran version of\nPRIMA was finished by December 2022. It can be compiled using CMake as\nfollows.\n\n    \n    \n    git clone --depth 1 https://github.com/libprima/prima.git cd prima cmake -S . -B build -DCMAKE_INSTALL_PREFIX=install cmake --build build --target install\n\nThis should create the primaf library for Fortran usage, located in the\ninstall/lib/ directory to be used with the module files in\ninstall/include/prima/mod/. In case CMake fails to find your Fortran compiler,\nyou can indicate it by specifying\n-DCMAKE_Fortran_COMPILER=/path/to/your/Fortran/compiler. Similarly, set\n-DCMAKE_C_COMPILER=/path/to/your/C/compiler for your C compiler if needed.\n\nExamples on how to use the library from an external code are available in\nfortran/examples/. Below is an illustration with COBYLA.\n\n    \n    \n    cd fortran/examples/cobyla cmake -S . -B build -DCMAKE_INSTALL_PREFIX=install -DPRIMA_DIR=$PWD/../../../install/lib/cmake/prima/ cmake --build build --target install LD_LIBRARY_PATH=$LD_LIBRARY_PATH:$PWD/../../../install/lib ./install/bin/cobyla_example_1\n\n#### C\n\nA C binding to the Fortran library is available in the c/ folder. In the same\nway as the Fortran library, it can be compiled using CMake, which should also\ncreate the primac library for C compilation, located in install/lib/ to be\nused with the prima.h header in install/include/prima/.\n\nExamples on how to use the library from an external code are available in\nc/examples/. Below is an illustration with COBYLA.\n\n    \n    \n    cd c/examples/cobyla cmake -S . -B build -DCMAKE_INSTALL_PREFIX=install -DPRIMA_DIR=$PWD/../../../install/lib/cmake/prima/ cmake --build build --target install LD_LIBRARY_PATH=$LD_LIBRARY_PATH:$PWD/../../../install/lib ./install/bin/cobyla_example\n\n#### Python\n\n  * An interface is provided for using the modern Fortran implementation in Python.\n  * The inclusion of PRIMA into SciPy is under discussion. It will replace the buggy and unmaintained Fortran 77 version of COBYLA underlying scipy.optimize.minimize, and make the other four solvers available to all SciPy users.\n  * A native Python implementation of PRIMA is under development.\n\n#### MATLAB\n\n  * An interface is provided for using the modern Fortran implementation in MATLAB.\n  * A pure MATLAB version of NEWUOA is implemented. It was generated straightforwardly (indeed, automatically) from an earlier version of the modern Fortran code (with the help of Mr. Galann Pennec). The other four solvers will be implemented in MATLAB similarly.\n\n#### Julia\n\n  * A Julia interface is provided by PRIMA.jl. It is registered in the General Registry of Julia as PRIMA.\n\n#### Other languages\n\n  * Interfaces for using the modern Fortran implementation in other languages will be available later.\n  * Given the modern Fortran version, native implementations in other languages become much easier, because we now have a structured and modularized implementation as a reference. My team will implement the methods in other languages in this way. This is the main motivation for developing the modern Fortran version first \u2014 to provide a modernized reference implementation for the development in other languages.\n\n### Bug fixes\n\nPRIMA has fixed some serious issues in the original Fortran 77 implementation\nof Powell's methods. Note that all of them are problems in the Fortran 77 code\nrather than flaws in the algorithms.\n\nThe examples given below are bugs or requests sent to SciPy, NLopt, nloptr,\nOpenTURNS, etc., which are reputable packages that wrap/interface the original\nFortran 77 implementation of Powell's solver. Inevitably, they suffer from the\nbugs in the Fortran 77 code.\n\n  * The Fortran 77 solvers may get stuck in infinite loops.\n\n    * optimize: COBYLA hangs / infinite loop #8998\n\n    * BUG: Scipy.optimize / COBYLA hangs on some CPUs #15527\n\n    * COBYLA freezes (though maxeval and maxtime are given) #370\n\n    * COBYLA hangs #118\n\n    * NEWUOA_BOUND stuck in infinite loop inside MMA #117\n\n    * Cobyla freezes in 0T1.16rc1 #1651\n\n    * Optimization freezes #25\n\n    * BOBYQA gets stuck in infinite loop. #7\n\n    * Cobyla turns into infinite loop and never finishes #8\n\n    * Algorithm turns into infinite loop and never finishes #3\n\n    * The Fortran 77 version of UOBYQA encounters infinite cyclings very often if PRIMA_REAL_PRECISION is 32\n\n  * The Fortran 77 solvers may crash with segmentation faults due to uninitialized variables that are used as indices.\n\n    * Fix all uninitialized variable warnings #134\n\n    * BOBYQA uninitialised variables in rare cases #133\n\n    * Use of uninitialized variable in BOBYQA altmov #36\n\n  * Fortran 77 COBYLA may not return the best point that is evaluated; sometimes, the returned point can have a large constraint violation even though the starting point is feasible.\n\n    * nlopt COBYLA optimizer gives unexpected output #182\n\n    * Last Result Returned Not Optimized Result #110\n\n    * COBYLA returns last evaluated function which might not be minimum #57\n\n    * Successful termination when constraints violated #1\n\n### Improvements\n\nThanks to the improvements introduced into the new implementation, PRIMA\noutperforms Powell's original code in terms of the number of function\nevaluations, which is the standard performance indicator in derivative-free\noptimization. Below are the performance profiles of the PRIMA solvers compared\nwith Powell's implementation, the convergence tolerance being . Roughly\nspeaking, performance profiles plot the percentage of test problems solved\nagainst the budget, which is measured relative to the cost of the most\nefficient solver in the comparison. A higher curve indicates a better solver.\nSee Benchmarking Derivative-Free Optimization Algorithms (J. J. Mor\u00e9 and S. M.\nWild) for more information.\n\n  * NEWUOA on unconstrained CUTEst problems of at most 200 variables\n\n  * BOBYQA on bound-constrained CUTEst problems of at most 200 variables\n\n  * LINCOA on linearly constrained CUTEst problems of at most 200 variables and 20000 constraints\n\n  * COBYLA on nonlinearly constrained CUTEst problems of at most 100 variables and 10000 constraints\n\n  * UOBYQA on unconstrained CUTEst problems of at most 100 variables\n\n### Who was Powell?\n\nMichael James David Powell FRS was \"a British numerical analyst who was among\nthe pioneers of computational mathematics\". He was the inventor/early\ncontributor of quasi-Newton method, trust region method, augmented Lagrangian\nmethod, and SQP method. Each of them is a pillar of modern numerical\noptimization. He also made significant contributions to approximation theory\nand methods.\n\nAmong numerous honors, Powell was one of the two recipients of the first\nDantzig Prize from the Mathematical Programming Society (MOS) and Society for\nIndustrial and Applied Mathematics (SIAM). This is considered the highest\naward in optimization.\n\n### A \"fun\" fact\n\nIn the past years, while working on PRIMA, I have spotted a dozen of bugs in\nreputable Fortran compilers and three bugs in MATLAB. Each of them represents\ndays of bitter debugging, which finally led to the conclusion that it was not\na problem in my code but a flaw in the Fortran compilers or in MATLAB. From a\nvery unusual angle, this reflects how intensive the coding has been.\n\nThe bitterness behind this \"fun\" fact is exactly why I work on PRIMA: I hope\nthat all the frustrations that I have experienced will not happen to any user\nof Powell's methods anymore. I hope I am the last one in the world to decode a\nmaze of 244 GOTOs in 7939 lines of Fortran 77 code \u2014 I did this for three\nyears and I do not want anyone else to do it again.\n\n### Acknowledgment\n\nPRIMA is dedicated to the memory of the late Professor Powell with gratitude\nfor his inspiration and for the wealth he left to us.\n\nI am grateful to Professor Ya-xiang Yuan for his everlasting encouragement and\nsupport.\n\nThe development of PRIMA would have been a mission impossible without the\ngroundwork laid by the PDFO package of Tom M. Ragonneau and Zaikun Zhang. PDFO\nis Chapter 3 of Ragonneau's thesis co-supervised by Zaikun Zhang and Professor\nXiaojun Chen, with financial support from the Hong Kong Ph.D. Fellowship\nScheme (ref. PF18-24698).\n\nPRIMA is a long-term project, which would not have been sustainable without\nthe continued funds from the Hong Kong Research Grants Council (ref. PolyU\n253012/17P, PolyU 153054/20P, PolyU 153066/21P, and PolyU 153086/23P) and The\nHong Kong Polytechnic University (PolyU), in particular the Department of\nApplied Mathematics (AMA).\n\n### Citing PRIMA\n\nPRIMA has taken me significant energy and time. I will be delighted if it is\nuseful to you. All I need is a citation / acknowledgment. Note that PRIMA\ncontains bug fixes and improvements that do not exist in Powell's original\nimplementation of the solvers. Results produced by PRIMA may not be\nreproducible using the original solvers.\n\nIf you use PRIMA, please cite it as follows. The citation will be pointed to\nmy paper on PRIMA when I finish it.\n\n[1] Z. Zhang, PRIMA: Reference Implementation for Powell's Methods with\nModernization and Amelioration, available at http://www.libprima.net, DOI:\n10.5281/zenodo.8052654, 2023\n\n    \n    \n    @misc{Zhang_2023, title = {{PRIMA: Reference Implementation for Powell's Methods with Modernization and Amelioration}}, author = {Zhang, Z.}, howpublished = {available at http://www.libprima.net, DOI: 10.5281/zenodo.8052654}, year = {2023} }\n\nIn addition, Powell\u2019s methods can be cited as follows.\n\n[2] M. J. D. Powell, A direct search optimization method that models the\nobjective and constraint functions by linear interpolation, In Advances in\nOptimization and Numerical Analysis, eds. S. Gomez and J. P. Hennart, pages 51\n--67, Springer Verlag, Dordrecht, Netherlands, 1994\n\n[3] M. J. D. Powell, UOBYQA: unconstrained optimization by quadratic\napproximation, Math. Program., 92(B):555--582, 2002\n\n[4] M. J. D. Powell, The NEWUOA software for unconstrained optimization\nwithout derivatives, In Large-Scale Nonlinear Optimization, eds. G. Di Pillo\nand M. Roma, pages 255--297, Springer, New York, US, 2006\n\n[5] M. J. D. Powell, The BOBYQA algorithm for bound constrained optimization\nwithout derivatives, Technical Report DAMTP 2009/NA06, Department of Applied\nMathematics and Theoretical Physics, Cambridge University, Cambridge, UK, 2009\n\n[6] T. M. Ragonneau and Z. Zhang, PDFO: a cross-platform package for Powell's\nderivative-free optimization solvers, arXiv:2302.13246, 2023\n\nRemarks\n\n  * LINCOA seeks the least value of a nonlinear function subject to linear inequality constraints without using derivatives of the objective function. Powell did not publish a paper to introduce the algorithm.\n\n  * The paper [6] introduces the PDFO package rather than PRIMA. Nevertheless, it provides a good introduction to Powell's methods.\n\n### Charityware\n\nPRIMA is charityware, distributed for free under its license. If you\nappreciate it, you may consider making a donation to a charity that you trust\n(in addition to citing & acknowledging PRIMA). This is only a suggestion, not\nan obligation.\n\nThe inspiration comes from Vim, with which Zaikun Zhang typed all his PRIMA\ncode.\n\n### Contact\n\nIn case of problems, open a GitHub issue or contact Zaikun Zhang.\n\n### Mirrors\n\n  * Gitee: https://gitee.com/libprima/prima\n\n  * GitHub: https://github.com/libprima/prima\n\n  * GitLab: https://gitlab.com/libprima/prima\n\n### Star history\n\nstardev ranking: 28 among 30,975 Fortran repos as of Jan. 2024.\n\nThank you for your support.\n\n## About\n\nPRIMA is a package for solving general nonlinear optimization problems without\nusing derivatives. It provides the reference implementation for Powell's\nderivative-free optimization methods, i.e., COBYLA, UOBYQA, NEWUOA, BOBYQA,\nand LINCOA. PRIMA means Reference Implementation for Powell's methods with\nModernization and Amelioration, P for Powell.\n\nlibprima.net\n\n### Topics\n\npython optimization matlab constrained-optimization numerical-optimization\nnonlinear-optimization unconstrained-optimization prima powell blackbox-\noptimization modern-fortran cobyla derivative-free-optimization simulation-\nbased-optimization bobyqa newuoa uobyqa lincoa zeroth-order-method\n\n### Resources\n\nReadme\n\n### License\n\nBSD-3-Clause license\n\nActivity\n\nCustom properties\n\n### Stars\n\n275 stars\n\n### Watchers\n\n2 watching\n\n### Forks\n\n33 forks\n\nReport repository\n\n## Releases 12\n\nVersion 0.7.2 Latest\n\nOct 8, 2023\n\n\\+ 11 releases\n\n## Packages 0\n\nNo packages published\n\n## Contributors 5\n\n## Languages\n\n  * Fortran 73.9%\n  * MATLAB 21.6%\n  * Shell 1.3%\n  * Makefile 1.0%\n  * Python 0.9%\n  * C 0.8%\n  * Other 0.5%\n\n## Footer\n\n\u00a9 2024 GitHub, Inc.\n\nYou can\u2019t perform that action at this time.\n\n", "frontpage": false}
