{"aid": "40144076", "title": "JSONoid Discovery: Simplify Schema Discovery", "url": "https://spin.atomicobject.com/jsonoid-discovery-schema/", "domain": "atomicobject.com", "votes": 1, "user": "philk10", "posted_at": "2024-04-24 13:22:47", "comments": 0, "source_title": "JSONoid Discovery: Simplify Schema Discovery", "source_text": "JSONoid Discovery: Simplify Schema Discovery\n\n\u2190 Back to Blog Home\n\n# JSONoid Discovery: Simplify Schema Discovery\n\nDeveloper Tools\n\nby: Brian May\n\nApril 24, 2024\n\n  * Twitter\n  * Facebook\n  * Linkedin\n  * Hackernews\n\n### Article summary\n\n  * The Problem\n  * The Tool\n  * Usage\n  * Understanding the Output\n  * JSONoid Discovery\n\nOn a recent client project, my software development team faced a mismanaged\nlegacy NoSQL database. This database contained hundreds of thousands of\nrecords across a couple of dozen containers multiplied by four environments.\nWe got ourselves out of trouble with JSONoid Discovery.\n\n## The Problem\n\nThe biggest issue was the lack of schema enforcement or documentation\nthroughout the life of the database. This meant every query result needed to\nbe painstakingly validated at runtime.\n\nStep one of migrating to a more reasonable data storage solution was\nunderstanding the current state of the data. For the first container that we\ntackled, we tried a manual process. We researched data access patterns,\ninterviewed developers, and sampled the existing data. This was a difficult\nprocess that didn\u2019t yield satisfactory results, and we still regularly found\nourselves chasing edge cases.\n\n## The Tool\n\nIf we were going to solve this problem in a timely way, we needed an automated\nsolution that removes the guesswork. Enter: JSONoid Discovery. JSONoid is a\ntool created by Rochester Institute of Technology\u2019s Data Unity Lab directed by\nDr. Michael Mior. It uses some clever monoids to perform schema discovery on a\ncollection of JSON documents. The code is open-sourced under an MIT license\nand helpfully distributed as a Docker container.\n\n## Usage\n\nWe exported the data of an entire container from Azure using the Azure\nCosmosDB developer community\u2019s Data Migration Tool. Any NoSQL database will\nhave ways of extracting a group of JSON documents. That means it\u2019s important\nto include all of the data of a single container, not a sampling, to get the\nmost accurate output possible.\n\nJSONoid expects newline-delimited JSON as an input. Converting a standard JSON\narray to newline-delimited JSON is easy with JQ.\n\njq -c '.[]' exported-data.json > newline-delimited-data.json\n\nBefore you can execute the tool you\u2019ll need to pull the Docker image.\n\ndocker pull michaelmior/jsonoid-discovery\n\nThen executing the tool is as simple as feeding the input file to the Docker\ncontainer and capturing the output.\n\ndocker run --rm -i michaelmior/jsonoid-discovery < newline-delmited-data.json\n> output-schema.json\n\n## Understanding the Output\n\nThe output of JSONoid Discovery is a JSON schema that describes the structure\nand properties of the input data. The repository offers some example outputs,\nbut these appear to come from fairly normalized data. We found that our messy\ninput data produced some output that required further manual analysis. An\nanonymized and abbreviated example of our output is below.\n\nJson\n\n    \n    \n    { \"type\" : \"object\", \"additionalProperties\" : false, \"fieldPresence\" : { \"id\" : 1.0, \"property1\" : 0.0082625099441552, \"property2\" : 0.9872163454343528 }, \"dependentRequired\" : { \"property1\" : [ \"property2\" ] }, \"required\" : [ \"id\" ], \"properties\" : { \"id\" : { \"type\" : \"string\", \"minLength\" : 36, \"bloomFilter\" : \"BLOOM_FILTER\", \"distinctValues\" : 131551, \"hll\" : \"HLL\", \"lengthHistogram\" : { \"bins\" : [ [ 35.69989444930044, 122185 ] ], \"hasExtremeValues\" : false }, \"format\" : \"uuid\", \"examples\" : [ \"04a4426b-7387-4fc4-81e5-c6d45adf54ad\", \"08160b45-4d7a-4fd6-8492-26c8f6054872\", ... ], \"maxLength\" : 36 }, \"property1\" : { \"enum\" : [ \"value1\", \"value2\" ] }, \"property2\" : { \"type\" : \"string\", \"minLength\" : 0, \"bloomFilter\" : \"BLOOM_FILTER\", \"distinctValues\" : 193, \"hll\" : \"HLL\", \"lengthHistogram\" : { \"bins\" : [ [ 0.0, 82 ], [ 1.9813812853544068, 1 ], ..., [ 23.06811574166162, 1 ], [ 24.002636914918774, 1 ] ], \"hasExtremeValues\" : false }, \"examples\" : [ \"\", \"FOO BAR\", \"EXAMPLE\" ], \"maxLength\" : 24 } }, \"$schema\" : \"https://json-schema.org/draft/2020-12/schema\", \"description\" : \"Generated by JSONoid 0.0.0-1-afeb9aee-SNAPSHOT. Not to be used for validation purposes.\" }\n\n### Properties\n\nThe properties field is a map of all the properties found in the input data.\nFor each property, JSONoid infers a type (e.g. string, number, boolean). It\nalso provides some other interesting data like minimum and maximum length,\nnumber of distinct values, and some examples. I was impressed that it was even\nable to infer enums and timestamp formats for strings.\n\n### Advanced Metadata\n\nIn addition to these basic statistics, JSONoid also provides some more\nadvanced metadata. The bloomFilter and hll (HyperLogLog) fields are\nprobabilistic data structures that can be used for efficient membership\ntesting and cardinality estimation, respectively. The lengthHistogram field\nprovides a histogram of the lengths of string values, which can be useful for\nunderstanding the distribution of the data.\n\n### Field Frequency\n\nAnother important field in the output schema is fieldPresence. This is a map\nthat indicates the frequency with which each property appeared in the input\ndata. A value of 1.0 means the property was present in every record, while a\nvalue of 0.5 would mean it was present in half of the records. We found this\ndata extremely valuable when deciding whether a field was an outlier from a\nbad write operation or a necessary part of the schema. I should note that a\nsmall number in fieldPresence does not necessarily indicate an outlier, it\ncould just be that there is a less common subclass of the schema that uses\nthat property.\n\n### Dependency Mapping\n\nFinally, the dependentRequired field is used to specify dependencies between\nproperties. In the example output, it indicates that property2 is required\nwhenever property1 is present. This type of relationship can be important to\nmodel in the schema to ensure data integrity. We used these mappings to help\ndetermine where we had discriminated unions in our schema. By graphing the\nrelationships we were able to see two independent subgraphs emerge from the\nrelationships.\n\n## JSONoid Discovery\n\nJSONoid greatly increased our confidence moving forward with this risky data\nmigration. It is an incredibly powerful tool. I also found it very interesting\nto work with; it\u2019s not often that I find myself reading academic research in\nmy day-to-day software development tasks.\n\nA big thank you to Dr. Mior and everybody at Rochester Institute of\nTechnology\u2019s Data Unity Lab for their research in this field. I look forward\nto looking in to more of their work. In particular, NoSE looks like it could\nbe useful as we continue through this legacy data migration.\n\njsonschema\n\nBrian May Software Consultant & Developer at Atomic Object Grand Rapids.\nMember of Cell Two. Curious how that thing works.\n\nAll Posts \u2192\n\n### Related Posts\n\n  * Developer Tools\n\n## Keep It Simple with Camera Intents in Your Jetpack Compose App\n\n  * Developer Tools\n\n## Reconsider Using Storybook: Is It Worth the Hassle?\n\n  * Developer Tools\n\n## When to Use PUT and When to Use PATCH\n\n## Keep up with our latest posts.\n\nWe\u2019ll send our latest tips, learnings, and case studies from the Atomic\nbraintrust on a monthly basis.\n\n[mailpoet_form id=\"1\"]\n\nConversation\n\n### Join the conversation Cancel reply\n\n### Development Category\n\n  * Software Science\n  * Development Practices\n  * Developer Tools\n\nRelated Posts\n\nDeveloper Tools\n\n# Keep It Simple with Camera Intents in Your Jetpack Compose App\n\nDeveloper Tools\n\n# Reconsider Using Storybook: Is It Worth the Hassle?\n\nDeveloper Tools\n\n# When to Use PUT and When to Use PATCH\n\n### Tell Us About Your Project\n\nWe\u2019d love to talk with you about your next great software project. Fill out\nthis form and we\u2019ll get back to you within two business days.\n\nShare Your Project\n\nAtomic is a software design + development consultancy.\n\n\u00a9 2024 Atomic Object LLC\n\n##### Explore\n\n  * Careers\n  * Diversity\n  * Resources\n  * Atomic Blog\n\n##### Offices\n\n  * Grand Rapids\n  * Ann Arbor\n  * Chicago\n  * Raleigh-Durham\n\n##### Details\n\n  * Contact\n  * Media\n  * Privacy Policy\n\n", "frontpage": false}
