{"aid": "40118243", "title": "Temporal: Getting started with JavaScript's new date time API. (2021)", "url": "https://2ality.com/2021/06/temporal-api.html", "domain": "2ality.com", "votes": 1, "user": "fanf2", "posted_at": "2024-04-22 19:42:04", "comments": 0, "source_title": "Temporal: getting started with JavaScript\u2019s new date time API", "source_text": "Temporal: getting started with JavaScript\u2019s new date time API\n\n2ality \u2013 JavaScript and more\n\nHome|About|Follow|Archive|Search |Books\n\n# Temporal: getting started with JavaScript\u2019s new date time API\n\n[2021-06-28] dev, javascript, es proposal\n\n(Ad, please don\u2019t block)\n\nDesign and Development tips in your inbox. Every weekday. ads via Carbon\n\nUpdates:\n\n  * 2022-01-10: Temporal.now was renamed to Temporal.Now.\n  * 2021-06-30: Rearranged the content and created a section on the concepts and patterns used by the Temporal API.\n  * 2021-06-29: Clarified how Instant uses the ISO-8601 calendar. Listed the properties of some classes.\n\nDate, JavaScript\u2019s current date time API is infamously difficult to use. The\nECMAScript proposal \u201cTemporal\u201d is a new and better date time API and currently\nat stage 3. It was created by Philipp Dunkel, Maggie Johnson-Pint, Matt\nJohnson-Pint, Brian Terlson, Shane Carr, Ujjwal Sharma, Philip Chimento, Jason\nWilliams, and Justin Grant.\n\nThis blog post has two goals:\n\n  * Giving you a feeling for how Temporal works\n  * Helping you get started with it\n\nHowever, it is not an exhaustive documentation: For many details, you will\nhave to consult the (excellent) documentation for Temporal.\n\nWarning: These are my first explorations of this API \u2013 feedback welcome!\n\n## The Temporal API #\n\nThe Temporal date time API is accessible via the global variable Temporal. It\nis a pleasure to use:\n\n  * All objects are immutable. Changing them produces new values, similarly to how strings work in JavaScript.\n  * There is support for time zones and non-Gregorian calendars.\n  * There are several specialized classes for Temporal values (date time values with time zones, date time values without time zones, date values without time zones, etc.). That has several benefits:\n\n    * The context of a value (time zone or not, etc.) is easier to understand.\n    * It is often more obvious how to achieve a given task.\n    * .toString() can be used with much less consideration.\n  * January is month 1.\n\nParts of this blog post:\n\n  * The post starts with background knowledge. That will help you with the remainder of the post, but you should be fine without it.\n  * Next, there is an overview of all the classes of the Temporal API and how they fit together.\n  * At the end, there is a comprehensive section with examples.\n\n## Background: representing time #\n\n### From solar time to standard time #\n\nHistorically, how we measure time has progressed over the years:\n\n  * Apparent solar time (local apparent time): One of the earliest ways of measuring time was to base the current time on the position of the sun. For example, noon is when the sun is directly overhead.\n  * Mean solar time (local mean time): This time representation corrects the variations of apparent solar time so that each day of the year has the same length.\n  * Standard time and time zones: Standard time specifies how the clocks within a geographical region are to be synchronized. It was established in the 19th century to support weather forecasting and train travel. In the 20th century, standard time was defined globally and geographical regions became time zones.\n\nWall-clock time is the current time within a time zone (as shown by a clock on\nthe wall). Wall-clock time is also called local time.\n\n### Time standards: UTC vs. Z vs. GMT #\n\nUTC, Z, and GMT are ways of specifying time that are similar, but subtly\ndifferent:\n\n  * UTC (Coordinated Universal Time) is the time standard that all times zones are based on. They are specified relative to it. That is, no country or territory has UTC as its local time zone.\n\n  * Z (Zulu Time Zone) is a military time zone that is often used in aviation and the military as another name for UTC+0.\n\n  * GMT (Greenwich Mean Time) is a time zone used in some European and African countries. It is UTC plus zero hours and therefore has the same time as UTC.\n\nSources:\n\n  * \u201cThe Difference Between GMT and UTC\u201d at TimeAndDate.com\n  * \u201cZ \u2013 Zulu Time Zone (Military Time)\u201d at TimeAndDate.com\n\n### Time zones vs. time offsets #\n\nTemporal\u2019s time zones are based on the IANA Time Zone Database (short: tz\ndatabase). IANA stands for Internet Assigned Numbers Authority. In that\ndatabase, each time zone has an identifier and rules defining offsets for UTC\ntimes. If a time zone has standard time and daylight saving time, the offsets\nchange during a year:\n\n    \n    \n    const standardTime = Temporal.ZonedDateTime.from({ timeZone: 'Europe/Zurich', year: 1995, month: 11, day: 30, hour: 3, minute: 24, }); assert.equal( standardTime.toString(), '1995-11-30T03:24:00+01:00[Europe/Zurich]'); // (A) const daylightSavingTime = Temporal.ZonedDateTime.from({ timeZone: 'Europe/Zurich', year: 1995, month: 5, day: 30, hour: 3, minute: 24, }); assert.equal( daylightSavingTime.toString(), '1995-05-30T03:24:00+02:00[Europe/Zurich]'); // (B)\n\nIn standard time, the time offset for the Europe/Zurich time zone is +1:00\n(line A). In daylight saving time, the time offset is +2:00 (line B).\n\n#### Resources for working with time zones #\n\n  * \u201cTime Zone Database\u201d on the IANA website is a list of time zone names.\n  * \u201cList of tz database time zones\u201d on Wikipedia is another list of time zone names.\n  * \u201cTime Difference\u201d (\u201cZeitverschiebung\u201d) lists time zones for cities etc. \u2013 for example, the time zone for San Francisco is America/Los_Angeles.\n\n### Calendars #\n\nThe calendars supported by Temporal are based on the standard Unicode Unicode\nCommon Locale Data Repository (CLDR) \u2013 among others:\n\n  * buddhist: Thai Buddhist calendar\n  * chinese: Traditional Chinese calendar\n  * coptic: Coptic calendar\n  * dangi: Traditional Korean calendar\n  * ethiopic: Ethiopic calendar, Amete Mihret (epoch approx, 8 C.E.)\n  * gregory: Gregorian calendar\n  * hebrew: Traditional Hebrew calendar\n  * indian: Indian calendar\n  * islamic: Islamic calendar\n  * iso8601: ISO calendar (Gregorian calendar using the ISO-8601 calendar week rules)\n  * japanese: Japanese Imperial calendar\n  * persian: Persian calendar\n  * roc: Republic of China calendar\n\niso8601 is used by most western countries and gets extra support in Temporal,\nvia methods such as Temporal.Now.zonedDateTimeISO() (which returns the current\ndate and wall-clock time in the system time zone and ISO-8601 calendar).\n\n### ECMAScript Extended ISO-8601/RFC 3339 Strings #\n\nThe standards ISO-8601 and RFC 3339 specify how to represent dates in strings.\nCurrently, they are missing functionality that is needed and added by\nTemporal:\n\n  * Representing month-day data as strings\n  * Representing IANA Time Zone Names in date time strings\n  * Representing calendar systems in date time strings\n\nThe goal is to eventually get these additions standardized (beyond\nECMAScript).\n\n#### Month-day syntax #\n\nMonth-day syntax looks like this:\n\n    \n    \n    > Temporal.PlainMonthDay.from('12-24').toString() '12-24'\n\n#### Date time strings with IANA Time Zone Names and calendar systems #\n\nThe following code shows what a full date time string looks like. In practice,\nmany of these parts will often be missing:\n\n    \n    \n    const zdt = Temporal.ZonedDateTime.from({ timeZone: 'Africa/Nairobi', year: 2019, month: 11, day: 30, hour: 8, minute: 55, second: 0, millisecond: 123, microsecond: 456, nanosecond: 789, }); assert.equal( zdt.toString({calendarName: 'always', smallestUnit: 'nanosecond'}), '2019-11-30T08:55:00.123456789+03:00[Africa/Nairobi][u-ca=iso8601]');\n\nParts of the date time string in the previous example:\n\n  * Date: '2019-11-30'\n\n    * year '-' month '-' day\n  * Separator between date and time: 'T'\n  * Time: '08:55:00.123456789'\n\n    * hour ':' minute ':' seconds\n    * '.' (separator between seconds and fractions of a second)\n    * milliseconds (3 digits)\n    * microseconds (3 digits)\n    * nanoseconds (3 digits)\n  * Time offset relative to UTC: '+03:00'\n\n    * Alternative: 'Z' which means '+0:00'\n  * Time zone: '[Africa/Nairobi]'\n  * Calendar: '[u-ca=iso8601]'\n\nThe last two items are not currently standardized.\n\n## Concepts and patterns of the Temporal API #\n\n### Wall-clock time vs. exact time #\n\nTemporal distinguishes two kinds of time. Given a global instant of time:\n\n  * Wall-clock time (also called local time or clock time) varies globally, depending on the time zone of a clock.\n  * Exact time (also called UTC time) is the same everywhere.\n\nEpoch time is one way of representing exact time: It\u2019s a number counting time\nunits (such as nanoseconds) before or since Unix epoch (midnight UTC on\nJanuary 1, 1970).\n\n### The core classes of the Temporal API #\n\nLet\u2019s first take a quick look at Temporal\u2019s core classes and what data goes\ninto them. They are covered in more detail later.\n\n  * Exact time:\n\n    * Wall-clock time plus time zone:\n\n      * ZonedDateTime: new Temporal.ZonedDateTime(epochNanoseconds: bigint, timeZone: TimeZoneLike, calendar?: CalendarLike)\n    * UTC:\n\n      * Instant: new Temporal.Instant(epochNanoseconds : bigint)\n  * Abstract time (no associated time standard):\n\n    * PlainDateTime: new Temporal.PlainDateTime(isoYear: number, isoMonth: number, isoDay: number, isoHour: number = 0, isoMinute: number = 0, isoSecond: number = 0, isoMillisecond: number = 0, isoMicrosecond: number = 0, isoNanosecond: number = 0, calendar?: CalendarLike)\n    * PlainDate: new Temporal.PlainDate(isoYear: number, isoMonth: number, isoDay: number, calendar?: CalendarLike)\n    * PlainTime: new Temporal.PlainTime(isoHour: number = 0, isoMinute: number = 0, isoSecond: number = 0, isoMillisecond: number = 0, isoMicrosecond: number = 0, isoNanosecond: number = 0)\n    * PlainYearMonth: new Temporal.PlainYearMonth(isoYear: number, isoMonth: number, calendar?: CalendarLike, referenceISODay: number = 1)\n    * PlainMonthDay: new Temporal.PlainMonthDay(isoMonth: number, isoDay: number, calendar?: CalendarLike, referenceISOYear?: number)\n  * Durations:\n\n    * Duration: new Temporal.Duration(years?: number, months?: number, weeks?: number, days?: number, hours?: number, minutes?: number, seconds?: number, milliseconds?: number, microseconds?: number, nanoseconds?: number)\n\n### Creating instances of Temporal classes #\n\nThere are two main ways of creating instances of Temporal classes.\n\n#### Constructor #\n\nOn one hand, we can create instances via constructors. Each constructor\naccepts the minimal amount of data needed to fully specify an instance. For\nexample, in the case of the two classes for exact time, Instant and\nZonedDateTime, the point in time itself is specified via epoch nanoseconds.\n\n    \n    \n    const epochNanoseconds = 6046761644163000000n; const timeZone = 'America/Los_Angeles'; // San Francisco const zdt1 = new Temporal.ZonedDateTime(epochNanoseconds, timeZone); assert.equal( zdt1.toString(), '2161-08-12T09:00:44.163-07:00[America/Los_Angeles]');\n\n#### Static factory method .from() #\n\nOn the other hand, we can create instances via the static factory method\n.from(). It is overloaded: Most classes support three kinds of values for its\nparameter.\n\nFirst, if the parameter is an instance of the same class, then that instance\nis cloned:\n\n    \n    \n    const zdt2 = Temporal.ZonedDateTime.from(zdt1); assert.equal( zdt2.toString(), '2161-08-12T09:00:44.163-07:00[America/Los_Angeles]'); // Really a clone? assert.notEqual(zdt1, zdt2);\n\nSecond, all other objects are interpreted as specifying various fields with\ntime-related information:\n\n    \n    \n    const zdt3 = Temporal.ZonedDateTime.from({ timeZone: 'America/Los_Angeles', year: 2161, month: 8, day: 12, hour: 9, minute: 0, second: 44, millisecond: 163, microsecond: 0, nanosecond: 0, }); assert.equal( zdt3.toString(), '2161-08-12T09:00:44.163-07:00[America/Los_Angeles]');\n\nThird, all primitive values are coerced to string and parsed:\n\n    \n    \n    const zdt4 = Temporal.ZonedDateTime.from( '2161-08-12T09:00:44.163[America/Los_Angeles]'); // (A) assert.equal( zdt4.toString(), '2161-08-12T09:00:44.163-07:00[America/Los_Angeles]'); // (B)\n\nNote that we didn\u2019t need to specify the offset in line A, but it is shown in\nline B.\n\n### Updating time values #\n\nThe fields we use when creating an instance via .from() become properties of\nthat instance:\n\n    \n    \n    const zonedDateTime = Temporal.ZonedDateTime.from({ timeZone: 'Africa/Lagos', year: 1995, month: 12, day: 7, hour: 3, minute: 24, second: 30, millisecond: 0, microsecond: 3, nanosecond: 500, }); assert.equal( zonedDateTime.toString(), '1995-12-07T03:24:30.0000035+01:00[Africa/Lagos]'); assert.equal( zonedDateTime.year, 1995); assert.equal( zonedDateTime.month, 12); assert.equal( zonedDateTime.dayOfWeek, 4); assert.equal( zonedDateTime.epochNanoseconds, 818303070000003500n);\n\nThese properties are immutable: If we want to change them, we have to create a\nnew instance where they have different values. Method .with() lets us do that:\n\n    \n    \n    const newZonedDateTime = zonedDateTime.with({ year: 2222, month: 3, }); assert.equal( newZonedDateTime.toString(), '2222-03-07T03:24:30.0000035+01:00[Africa/Lagos]');\n\n### Values that are \u201clike\u201d instances of classes (TimeZone, Calendar, Duration,\netc.) #\n\nWhenever Temporal needs an instance of a class C, it accepts any value that is\n\u201clike\u201d an instance of class C:\n\n  1. An instance of class C\n  2. An object that can be parsed via C.from()\n\n     * Note that the properties of such an object are a subset of the properties of an instance of C.\n  3. A string that can be parsed via C.from()\n\nValues like TimeZone \u2013 these are three ways of specifying time zones (last\narguments of the following constructor invocations):\n\n    \n    \n    const zdt1 = new Temporal.ZonedDateTime(0n, new Temporal.TimeZone('America/Lima')); const zdt2 = new Temporal.ZonedDateTime(0n, {timeZone: 'America/Lima'}); const zdt3 = new Temporal.ZonedDateTime(0n, 'America/Lima');\n\nValues like Calendar \u2013 these are three ways of specifying calendars (last\narguments of the following constructor invocations):\n\n    \n    \n    const pd1 = new Temporal.PlainDate(1992, 2, 24, new Temporal.Calendar('iso8601')); const pd2 = new Temporal.PlainDate(1992, 2, 24, {calendar: 'iso8601'}); const pd3 = new Temporal.PlainDate(1992, 2, 24, 'iso8601');\n\nValues like Duration \u2013 these are three ways of specifying durations (argument\nof .add()):\n\n    \n    \n    const pdStart = Temporal.PlainDate.from('2022-03-08'); const pd1 = pdStart.add( Temporal.Duration.from({years: 5, months: 2, days: 1})); assert.equal(pd1.toString(), '2027-05-09'); const pd2 = pdStart.add( {years: 5, months: 2, days: 1}); assert.equal(pd2.toString(), '2027-05-09'); const pd3 = pdStart.add( 'P5Y2M1D'); assert.equal(pd3.toString(), '2027-05-09');\n\n## A closer look at Temporal\u2019s classes #\n\n### Temporal.Now: the current time #\n\nThe object Temporal.Now has several factory methods for creating Temporal\nvalues representing the current time:\n\n    \n    \n    > Temporal.Now.instant().toString() '2021-06-27T12:51:10.961Z' > Temporal.Now.zonedDateTimeISO('Asia/Shanghai').toString() '2021-06-27T20:51:10.961+08:00[Asia/Shanghai]' > Temporal.Now.plainDateTimeISO().toString() '2021-06-27T20:51:10.961' > Temporal.Now.plainTimeISO().toString() '20:51:10.961'\n\nProperties of Temporal.Now:\n\n  * .timeZone()\n  * .instant()\n  * .plainDateTime(calendar, temporalTimeZoneLike?)\n  * .plainDateTimeISO(temporalTimeZoneLike?)\n  * .zonedDateTime(calendar, temporalTimeZoneLike?)\n  * .zonedDateTimeISO(temporalTimeZoneLike?)\n  * .plainDate(calendar, temporalTimeZoneLike?)\n  * .plainDateISO(temporalTimeZoneLike?)\n  * .plainTimeISO(temporalTimeZoneLike?)\n\nThese properties are documented here.\n\n#### Context provided by the system: time zone and calendar #\n\nWe can use Temporal.Now to access the current time zone of the system. This\ntime zone can change \u2013 for example, when the system travels:\n\n    \n    \n    > Temporal.Now.timeZone().toString() 'Asia/Shanghai'\n\nThe concept of a \u201ccurrent calendar\u201d is more complicated. Ideas for how to best\nhandle it are still evolving. This is the current way of getting the ID (a\nstring) of the \u201cpreferred calendar\u201d:\n\n    \n    \n    const preferredCalendarId = (new Intl.DateTimeFormat()) .resolvedOptions().calendar; assert.equal(preferredCalendarId, 'gregory');\n\n### Exact time: class Instant, class ZonedDateTime, nanoseconds since epoch #\n\nTemporal represents exact time in three ways:\n\n  * Via class Instant (UTC time).\n  * Via class ZonedDateTime (wall-clock time plus a time zone and a calendar).\n  * Via a bigint number expressing nanoseconds since epoch.\n\n#### Class Instant #\n\nClass Instant represents global exact time. Its time standard is UTC. It is\nmostly a container for nanoseconds since epoch. That is also reflected by it\nnot having properties such as .year and .hour (which ZonedDateTime and\nPlainDateTime have).\n\nFor some operations (such as .toString()), Instant internally uses an ISO-8601\ncalendar, but that calendar is not stored in instances.\n\nUse case:\n\n  * Internal dates that are not shown to end users (time stamps in logs, etc.).\n\n    \n    \n    const instant = Temporal.Now.instant(); assert.equal( instant.toString(), '2021-06-27T08:32:33.18174345Z');\n\nProperties of Instant:\n\n  * .from(item)\n  * .fromEpochSeconds(epochSeconds)\n  * .fromEpochMilliseconds(epochMilliseconds)\n  * .fromEpochMicroseconds(epochMicroseconds)\n  * .fromEpochNanoseconds(epochNanoseconds)\n  * .compare(one, two)\n\nProperties of Instant.prototype:\n\n  * get .epochSeconds\n  * get .epochMilliseconds\n  * get .epochMicroseconds\n  * get .epochNanoseconds\n  * .add(temporalDurationLike)\n  * .subtract(temporalDurationLike)\n  * .until(other, options?)\n  * .since(other, options?)\n  * .round(options)\n  * .equals(other)\n  * .toString(options?)\n  * .toLocaleString(locales?, options?)\n  * .toJSON()\n  * .valueOf()\n  * .toZonedDateTime(item)\n  * .toZonedDateTimeISO(item)\n\nThese properties are documented here.\n\n#### Class ZonedDateTime #\n\nClass ZonedDateTime represents time via wall-clock time plus a time zone and a\ncalendar.\n\nUse cases for this class:\n\n  * Representing actual events\n  * Converting time between zones\n  * Time computations where daylight saving time may play a role (\u201cone hour later\u201d)\n\n    \n    \n    // Current time in Melbourne, Australia (in ISO-8601 calendar) const zonedDateTime = Temporal.Now.zonedDateTimeISO( 'Australia/Melbourne'); assert.equal( zonedDateTime.toString(), '2021-06-27T10:46:31.179753181+10:00[Australia/Melbourne]');\n\nProperties of ZonedDateTime:\n\n  * .from(item, options?)\n  * .compare(one, two)\n\nProperties of ZonedDateTime.prototype:\n\n  * get .calendar\n  * get .timeZone\n  * get .year\n  * get .month\n  * get .monthCode\n  * get .day\n  * get .hour\n  * get .minute\n  * get .second\n  * get .millisecond\n  * get .microsecond\n  * get .nanosecond\n  * get .epochSeconds\n  * get .epochMilliseconds\n  * get .epochMicroseconds\n  * get .epochNanoseconds\n  * get .dayOfWeek\n  * get .dayOfYear\n  * get .weekOfYear\n  * get .hoursInDay\n  * get .daysInWeek\n  * get .daysInMonth\n  * get .daysInYear\n  * get .monthsInYear\n  * get .inLeapYear\n  * get .offsetNanoseconds\n  * get .offset\n  * .with(temporalZonedDateTimeLike, options?)\n  * .withPlainTime(plainTimeLike?)\n  * .withPlainDate(plainDateLike)\n  * .withTimeZone(timeZoneLike)\n  * .withCalendar(calendarLike)\n  * .add(temporalDurationLike, options?)\n  * .subtract(temporalDurationLike, options?)\n  * .until(other, options?)\n  * .since(other, options?)\n  * .round(options)\n  * .equals(other)\n  * .toString(options?)\n  * .toLocaleString(locales?, options?)\n  * .toJSON()\n  * .valueOf()\n  * .startOfDay()\n  * .toInstant()\n  * .toPlainDate()\n  * .toPlainTime()\n  * .toPlainDateTime()\n  * .toPlainYearMonth()\n  * .toPlainMonthDay()\n  * .getISOFields()\n\nThese properties are documented here.\n\n### Plain (wall-clock time) classes #\n\n#### Class PlainDateTime, PlainDate, PlainTime #\n\nIf a class doesn\u2019t have a time zone, Temporal calls it \u201cplain\u201d. There are\nthree timezone-less classes: PlainDateTime, PlainDate, and PlainTime. They are\nabstract representations of time.\n\nUse cases for these classes:\n\n  * Displaying the wall-clock time in a given time zone (see below).\n  * Time computations when the time zone doesn\u2019t matter (\u201cThe first Wednesday of May 1998\u201d).\n\n    \n    \n    const zonedDateTime = Temporal.Now.zonedDateTimeISO( 'Asia/Novosibirsk'); assert.equal( zonedDateTime.toString(), '2021-06-27T10:46:31.179+07:00[Asia/Novosibirsk]'); // Get the wall-clock time as a string const plainDateTime = zonedDateTime.toPlainDateTime() assert.equal( plainDateTime.toString(), '2021-06-27T10:46:31.179');\n\nProperties of PlainDateTime:\n\n  * .from(item, options?)\n  * .compare(one, two)\n\nProperties of PlainDateTime.prototype:\n\n  * get .calendar\n  * get .year\n  * get .month\n  * get .monthCode\n  * get .day\n  * get .hour\n  * get .minute\n  * get .second\n  * get .millisecond\n  * get .microsecond\n  * get .nanosecond\n  * get .dayOfWeek\n  * get .dayOfYear\n  * get .weekOfYear\n  * get .daysInWeek\n  * get .daysInMonth\n  * get .daysInYear\n  * get .monthsInYear\n  * get .inLeapYear\n  * .with(temporalDateTimeLike, options?)\n  * .withPlainTime(plainTimeLike?)\n  * .withPlainDate(plainDateLike)\n  * .withCalendar(calendar)\n  * .add(temporalDurationLike, options?)\n  * .subtract(temporalDurationLike, options?)\n  * .until(other, options?)\n  * .since(other, options?)\n  * .round(options)\n  * .equals(other)\n  * .toString(options?)\n  * .toLocaleString(locales?, options?)\n  * .toJSON()\n  * .valueOf()\n  * .toZonedDateTime(temporalTimeZoneLike, options?)\n  * .toPlainDate()\n  * .toPlainYearMonth()\n  * .toPlainMonthDay()\n  * .toPlainTime()\n  * .getISOFields()\n\nThese properties are documented here.\n\nPlainDate and PlainTime have subsets of PlainDateTime\u2019s properties.\n\n#### Class PlainYearMonth #\n\nAn instance of PlainYearMonth abstractly refers to a particular month in a\nparticular year.\n\nUse case:\n\n  * Identifying a monthly recurring event (\u201cthe October 2022 meeting\u201d)\n\n    \n    \n    const plainYearMonth = Temporal.PlainYearMonth.from( {year: 2022, month: 10}); assert.equal( plainYearMonth.toString(), '2022-10');\n\n#### Class PlainMonthDay #\n\nAn instance of PlainMonthDay abstractly refers to a particular day in a\nparticular month.\n\nUse case:\n\n  * Identifying a yearly recurring event (\u201cBastille Day is July 14\u201d)\n\n    \n    \n    // Bastille Day const bastilleDay = Temporal.PlainMonthDay.from({month: 7, day: 14}); assert.equal( bastilleDay.toString(), '07-14'); // Bastille Day in 1989 in Paris const zonedDateTime = bastilleDay .toPlainDate({year: 1989}) .toZonedDateTime('Europe/Paris'); assert.equal( zonedDateTime.toString(), '1989-07-14T00:00:00+02:00[Europe/Paris]');\n\n### Helper classes #\n\n#### Calendar #\n\nAll Temporal classes that contain full dates use calendars to help them with\nvarious computations. Most code will use the ISO-8601 calendar, but other\ncalendar systems are supported, too.\n\n    \n    \n    const calendar1 = new Temporal.Calendar('iso8601'); const calendar2 = Temporal.Calendar.from('iso8601'); const calendar3 = Temporal.Calendar.from({calendar: 'iso8601'});\n\n#### TimeZone #\n\nInstances of TimeZone represent time zones. They support IANA time zones, UTC,\nand UTC offsets. For most use cases, IANA time zones are the best choice\nbecause they enable proper handling of daylight saving time.\n\n    \n    \n    const timeZone1 = new Temporal.TimeZone('America/Nuuk'); const timeZone2 = Temporal.TimeZone.from('America/Nuuk'); const timeZone3 = Temporal.TimeZone.from({timeZone: 'America/Nuuk'});\n\n#### Duration #\n\nA duration represents a length of time \u2013 for example, 3 hours and 45 minutes.\n\nDurations are used for temporal arithmetic:\n\n  * Measuring differences between two Temporal values\n  * Adding time to a temporal value\n  * Etc.\n\n    \n    \n    const duration = Temporal.Duration.from({hours: 3, minutes: 45}); assert.equal( duration.total({unit: 'second'}), 13500);\n\nNote that there is no simple normalization for durations:\n\n  * Sometimes, we mean \u201c90 minutes\u201d.\n  * Sometimes, we mean \u201c1 hour 30 minutes\u201d.\n\nThe former should not be automatically converted to the latter.\n\n##### ISO-8601 notation for durations #\n\nMethod .toString() of duration objects returns strings that conform to the\nISO-8601 notation for durations:\n\n    \n    \n    // Date information assert.equal( Temporal.Duration.from( {years: 1, months: 2, weeks: 3, days: 4}).toString(), 'P1Y2M3W4D'); // Time information assert.equal( Temporal.Duration.from( {hours: 1, minutes: 2, seconds: 3, milliseconds: 4}).toString(), 'PT1H2M3.004S'); // Mixed information assert.equal( Temporal.Duration.from( {days: 30, hours: 50}).toString(), 'P30DT50H'); // No duration assert.equal( Temporal.Duration.from( {hours: 0}).toString(), 'PT0S');\n\nObservations:\n\n  * All duration strings start with 'P'.\n  * Time information starts with 'T'.\n\n## Examples #\n\n### Input and output #\n\n#### Converting from and to strings #\n\nThe static factory method .from() always accepts strings:\n\n    \n    \n    const zdt = Temporal.ZonedDateTime.from( '2019-12-01T12:00:00[Pacific/Auckland]');\n\nThe .toString() method works predictably and can be configured:\n\n    \n    \n    assert.equal( zdt.toString(), '2019-12-01T12:00:00+13:00[Pacific/Auckland]'); assert.equal( zdt.toString({offset: 'never', timeZoneName: 'never'}), '2019-12-01T12:00:00'); assert.equal( zdt.toString({smallestUnit: 'minute'}), '2019-12-01T12:00+13:00[Pacific/Auckland]');\n\nHowever, .toString() doesn\u2019t let you hide minutes in this case \u2013 you have to\nconvert the ZonedDateTime to a PlainDate if that is what you want:\n\n    \n    \n    assert.equal( zdt.toPlainDate().toString(), '2019-12-01');\n\n#### Converting to and from JSON #\n\nAll Temporal date time values have a .toJSON() method and can therefore be\nstringified to JSON:\n\n    \n    \n    const zdt = Temporal.ZonedDateTime.from( '2019-12-01T12:00[Asia/Singapore]'); // Stringifying a zoned date time directly: assert.equal( JSON.stringify(zdt), '\"2019-12-01T12:00:00+08:00[Asia/Singapore]\"'); // Stringifying a zoned date time inside an object: const obj = {startTime: zdt}; assert.equal( JSON.stringify(obj), '{\"startTime\":\"2019-12-01T12:00:00+08:00[Asia/Singapore]\"}');\n\nIf you want to parse JSON with date time values, you need to set up a JSON\nreviver.\n\n#### Converting to human-readable strings #\n\nTemporal\u2019s support for converting date time values to human readable strings\nis similar to Intl.DateTimeFormat\u2019s:\n\n    \n    \n    const zdt = Temporal.ZonedDateTime.from( '2019-12-01T12:00[Europe/Berlin]'); assert.equal( zdt.toLocaleString(), '12/1/2019, 12:00:00 PM GMT+1'); assert.equal( zdt.toLocaleString('de-DE'), '1.12.2019, 12:00:00 MEZ'); assert.equal( zdt.toLocaleString('en-GB', { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric', }), 'Sunday, 1 December 2019');\n\nTemporal does not support parsing human-readable strings.\n\n#### Converting between legacy Date and Temporal #\n\nOn one hand, we can convert legacy dates to Temporal instants:\n\n    \n    \n    const legacyDate = new Date('1970-01-01T00:00:01Z'); const instant1 = legacyDate.toTemporalInstant(); assert.equal( instant1.toString(), '1970-01-01T00:00:01Z');\n\nThis is an alternative to the previous approach:\n\n    \n    \n    const ms = legacyDate.getTime(); const instant2 = Temporal.Instant.fromEpochMilliseconds(ms); assert.equal( instant2.toString(), '1970-01-01T00:00:01Z');\n\nOn the other hand, one of the fields exposed by Instant provides us with the\nepoch time in milliseconds \u2013 which we can use to create a date:\n\n    \n    \n    const instant = Temporal.Instant.from('1970-01-01T00:00:01Z'); const legacyDate = new Date(instant.epochMilliseconds); assert.equal( legacyDate.toISOString(), '1970-01-01T00:00:01.000Z');\n\n### Sorting dates #\n\nEvery date time class D provides a function D.compare for sorting instances of\nD:\n\n    \n    \n    const dates = [ Temporal.ZonedDateTime.from('2022-12-01T12:00[Asia/Tehran]'), Temporal.ZonedDateTime.from('2001-12-01T12:00[Asia/Tehran]'), Temporal.ZonedDateTime.from('2009-12-01T12:00[Asia/Tehran]'), ]; dates.sort(Temporal.ZonedDateTime.compare); assert.deepEqual( dates.map(d => d.toString()), [ '2001-12-01T12:00:00+03:30[Asia/Tehran]', '2009-12-01T12:00:00+03:30[Asia/Tehran]', '2022-12-01T12:00:00+03:30[Asia/Tehran]', ]);\n\nD.compare() also accepts strings \u2013 if they can be parsed via D.from():\n\n    \n    \n    const dates = [ '2022-12-01T12:00[Asia/Tehran]', '2001-12-01T12:00[Asia/Tehran]', '2009-12-01T12:00[Asia/Tehran]', ]; dates.sort(Temporal.ZonedDateTime.compare); assert.deepEqual( dates, [ '2001-12-01T12:00[Asia/Tehran]', '2009-12-01T12:00[Asia/Tehran]', '2022-12-01T12:00[Asia/Tehran]', ]);\n\n### Converting between Temporal values #\n\n#### Converting Instant to ZonedDateTime and PlainDateTime #\n\n    \n    \n    const instant = Temporal.Instant.from('1970-01-01T00:00:01Z'); const zonedDateTime = instant.toZonedDateTimeISO('Europe/Madrid'); assert.equal( zonedDateTime.toString(), '1970-01-01T01:00:01+01:00[Europe/Madrid]'); const plainDateTime1 = zonedDateTime.toPlainDateTime(); assert.equal( plainDateTime1.toString(), '1970-01-01T01:00:01'); const timeZone = Temporal.TimeZone.from('Europe/Madrid'); const plainDateTime2 = timeZone.getPlainDateTimeFor(instant); assert.equal( plainDateTime2.toString(), '1970-01-01T01:00:01');\n\n#### Converting ZonedDateTime to Instant and PlainDateTime #\n\n    \n    \n    const zonedDateTime = Temporal.ZonedDateTime.from( '2019-12-01T12:00[Europe/Minsk]'); const instant = zonedDateTime.toInstant(); assert.equal( instant.toString(), '2019-12-01T09:00:00Z'); const plainDateTime = zonedDateTime.toPlainDateTime(); assert.equal( plainDateTime.toString(), '2019-12-01T12:00:00');\n\n#### Converting PlainDateTime to ZonedDateTime and Instant #\n\n    \n    \n    const plainDateTime = Temporal.PlainDateTime.from( '1995-12-07T03:24:30'); const zonedDateTime = plainDateTime.toZonedDateTime('Europe/Berlin'); assert.equal( zonedDateTime.toString(), '1995-12-07T03:24:30+01:00[Europe/Berlin]'); const instant = zonedDateTime.toInstant(); assert.equal( instant.toString(), '1995-12-07T02:24:30Z');\n\n### Converting between time zones #\n\n    \n    \n    const source = Temporal.ZonedDateTime.from( '2022-01-09T02:00[America/Chicago]'); const target = source.withTimeZone('America/Anchorage'); assert.equal( target.toString(), '2022-01-08T23:00:00-09:00[America/Anchorage]');\n\n### Date time arithmetic #\n\n#### Time difference #\n\n    \n    \n    const departure = Temporal.ZonedDateTime.from( '2017-05-08T12:55[Europe/Berlin]'); // Munich const arrival = Temporal.ZonedDateTime.from( '2017-05-08T17:10[America/Los_Angeles]'); // Seattle const flightTime = departure.until(arrival); assert.equal( flightTime.toString(), 'PT13H15M');\n\n#### A day after a given date #\n\n    \n    \n    const plainDate = Temporal.PlainDate.from('2022-03-08'); assert.equal( plainDate.add({days: 1}).toString(), '2022-03-09');\n\n#### First Monday in September #\n\nTo compute Labor Day (first Monday in September) for a given year, we need to\nfigure out how many days to add to September 1 in order to get to weekday 1\n(Monday).\n\n    \n    \n    const mod = (a, b) => ((a % b) + b) % b; function getLaborDay(year) { const firstOfSeptember = Temporal.PlainDate.from({ year, month: 9, day: 1, }); // How many days until Monday? const MONDAY = 1; const daysToAdd = mod(MONDAY - firstOfSeptember.dayOfWeek, 7); return firstOfSeptember.add({days: daysToAdd}); } assert.equal( getLaborDay(2021).toString(), '2021-09-06'); assert.equal( getLaborDay(2022).toString(), '2022-09-05');\n\n## Implementations of the Temporal API #\n\nThe \u201cCan I use\u201d page for Temporal shows on which platforms the API is\nsupported.\n\nFor now, the proposal warns:\n\n> Although this proposal's API is not expected to change, implementers of this\n> proposal MUST NOT ship unflagged Temporal implementations until IETF\n> standardizes timezone/calendar string serialization formats. See #1450 for\n> updates.\n\nThe proposal has a list of polyfills for the Temporal API.\n\n## More information on the APIs Temporal and Date #\n\n  * The official Temporal documentation is currently hosted on GitHub, but will eventually be moved to MDN Web Docs.\n  * The legacy Date API is documented in a chapter in the book \u201cJavaScript for impatient programmers\u201d.\n\nDr. Axel Rauschmayer Homepage | Mastodon\n\nJavaScript for impatient programmers Book (free online), exercises, quizzes\n\nDeep JavaScript Book (free online)\n\nTackling TypeScript Book (free online)\n\nNode.js shell scripting Book (free online)\n\nECMAScript News Newsletter (free)\n\n", "frontpage": false}
