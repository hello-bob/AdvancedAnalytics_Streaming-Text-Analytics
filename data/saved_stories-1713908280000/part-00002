{"aid": "40133160", "title": "Let's Deprecate Update from (2008)", "url": "https://sqlserverfast.com/blog/hugo/2008/03/lets-deprecate-update-from/", "domain": "sqlserverfast.com", "votes": 1, "user": "harborsong", "posted_at": "2024-04-23 15:37:30", "comments": 0, "source_title": "Let's deprecate UPDATE FROM! - SQLServerFast", "source_text": "Let's deprecate UPDATE FROM! - SQLServerFast\n\nSQLServerFast\n\n# Let\u2019s deprecate UPDATE FROM!\n\n# Let\u2019s deprecate UPDATE FROM!\n\n16 years ago\n\nHugo Kornelis\n\n58 Comments\n\nI guess that many people using UPDATE ... FROM on a daily basis do so without\nbeing aware that they are violating all SQL standards.\n\nAll versions of the ANSI SQL standard that I checked agree that an UPDATE\nstatement has three clauses \u2013 the UPDATE clause, naming the table to be\nupdated; the SET clause, specifying the columns to change and their new\nvalues; and the optional WHERE clause to filter the rows to be updated. No\nFROM or JOIN \u2013 if you need data from a different table, use a subquery in the\nSET clause. The optional FROM and JOIN clauses were added by Microsoft, as an\nextension to the standard syntax (and just to make out lives more interesting,\nthey invented different variations of the syntax for SQL Server and for\nAccess). So when you are in the habit of using them, be prepared to review all\nyour UPDATE statements when moving to Oracle, DB2, Sybase, MySQL, or even a\ndifferent Microsoft database!\n\nStandards? Bah, who cares?\n\nWell, some do. Me for instance \u2013 I will never use proprietary syntax if I know\na standard alternative, expect if using the latter has severe negative\nconsequences. And maybe you will, one day, when your boss comes back from the\ngolf course with the great news that he managed to convince a colleague (who\njust happens to work in an Oracle shop) to buy a copy of your company\u2019s\napplication instead of some off-the-shelf product. Or when there\u2019s a great job\nopportunity for someone with cross platform skills. Or when you are asked to\nhelp out this new colleague with 10+ years of DB2 experience. One of the\nlesser known side effects of Murphy\u2019s Law is that those who least expect\nhaving to move their database to another platform, will.\n\nBut even if you really don\u2019t care about portability, there are other reasons\nto be wary of using UPDATE FROM. In fact, the most important reason why I\ndislike UPDATE FROM is not that it\u2019s non-standard, but that it is just too\neasy to make mistakes with.\n\nCorrectness? Bah, who cares?\n\nWell, most do. That\u2019s why we test.\n\nIf I mess up the join criteria in a SELECT query so that too many rows from\nthe second table match, I\u2019ll see it as soon as I test, because I get more rows\nback then expected. If I mess up the subquery criteria in an ANSI standard\nUPDATE query in a similar way, I see it even sooner, because SQL Server will\nreturn an error if the subquery returns more than a single value. But with the\nproprietary UPDATE FROM syntax, I can mess up the join and never notice \u2013 SQL\nServer will happily update the same row over and over again if it matches more\nthan one row in the joined table, with only the result of the last of those\nupdates sticking. And there is no way of knowing which row that will be, since\nthat depends in the query execution plan that happens to be chosen. A worst\ncase scenario would be one where the execution plan just happens to result in\nthe expected outcome during all tests on the single-processor development\nserver \u2013 and then, after deployment to the four-way dual-core production\nserver, our precious data suddenly hits the fan...\n\nThat\u2019s all?\n\nWell, almost. There\u2019s one more thing. Probably not something you\u2019ll run into\non a daily base, but good to know nonetheless. If the target of the update\nhappens to be a view instead of a base table, and there is an INSTEAD OF\nUPDATE trigger defined for the view, the UPDATE will fail with this error\nmessage:\n\nMsg 414, Level 16, State 1, Line 1\n\nUPDATE is not allowed because the statement updates view \u201cv1\u201d which\nparticipates in a join and has an INSTEAD OF UPDATE trigger.\n\nOf course, most people will never run into this. But I did have the misfortune\nof doing so once \u2013 unfortunately, I discovered this limitation after rewriting\nseveral hundred ANSI standard UPDATE statements to the equivalent UPDATE FROM,\nand having to convert them all back after as much as a single test...\n\nAnd that\u2019s why you want to deprecate UPDATE FROM?\n\nWell, no. The view with INSTEAD OF UPDATE trigger won\u2019t affect many people.\nAnd the possibility of error can be somewhat thwarted by making sure (and\ndouble-checking) to always include all columns of the primary key (or a unique\nconstraint) of the source table. So we\u2019re back to the more principle point of\navoiding proprietary syntax if there is an ANSI standard alternative with no\nor limited negative consequences. And in the case of UPDATE FROM, there are\nsome cases where the standard syntax just doesn\u2019t cut it.\n\nOne such scenario is when a file is read in periodically with updated\ninformation that has to be pushed into the main table. The code below sets up\na simplified example of this \u2013 a table Customers, with SSN as its primary key,\nthat stores address and lots of other information, and a table Moved, which is\nthe staging table containing the contents of a file received from a third\nparty listing new address for people who recently moved. I have also included\nthe code to preload the tables with some mocked up data \u2013 the Customers table\nhas 10,000 rows, and the Moved table has 3,000 rows, 1,000 of which match an\nexisting row in the Customers table. The others don\u2019t \u2013 those people are\napparently not our customers.\n\nCREATE TABLE Customers\n\n(SSN char(9) NOT NULL,\n\nStreet varchar(40) NOT NULL,\n\nHouseNo int NOT NULL,\n\nCity varchar(40) NOT NULL,\n\nLotsOfOtherInfo char(250) NOT NULL DEFAULT (\u201d),\n\nPRIMARY KEY (SSN),\n\nCHECK (SSN NOT LIKE \u2018%[^0-9]%\u2019)\n\n);\n\nCREATE TABLE Moved\n\n(SSN char(9) NOT NULL,\n\nStreet varchar(40) NOT NULL,\n\nHouseNo int NOT NULL,\n\nCity varchar(40) NOT NULL,\n\nPRIMARY KEY (SSN),\n\nCHECK (SSN NOT LIKE \u2018%[^0-9]%\u2019)\n\n);\n\ngo\n\nINSERT INTO Customers(SSN, Street, HouseNo, City)\n\nSELECT RIGHT(Number+1000000000,9), \u2018Street \u2018 + CAST(Number AS varchar(10)),\n\nNumber, \u2018City \u2018 + CAST(Number AS varchar(10))\n\nFROM dbo.Numbers\n\nWHERE Number BETWEEN 1 AND 30000\n\nAND Number % 3 = 0;\n\nINSERT INTO Moved(SSN, Street, HouseNo, City)\n\nSELECT RIGHT(Number+1000000000,9), \u2018New street \u2018 + CAST(Number AS\nvarchar(10)),\n\nNumber * 2, \u2018New city \u2018 + CAST(Number AS varchar(10))\n\nFROM dbo.Numbers\n\nWHERE Number BETWEEN 1 AND 30000\n\nAND Number % 10 = 0;\n\ngo\n\nSince ANSI-standard SQL does not allow a join to be used in the UPDATE\nstatement, we\u2019ll have to use subqueries to find the new information, and to\nfind the rows that need to be updated, resulting in this query:\n\nUPDATE Customers\n\nSET Street = (SELECT Street\n\nFROM Moved AS m\n\nWHERE m.SSN = Customers.SSN),\n\nHouseNo = (SELECT HouseNo\n\nFROM Moved AS m\n\nWHERE m.SSN = Customers.SSN),\n\nCity = (SELECT City\n\nFROM Moved AS m\n\nWHERE m.SSN = Customers.SSN)\n\nWHERE EXISTS (SELECT *\n\nFROM Moved AS m\n\nWHERE m.SSN = Customers.SSN);\n\nThere\u2019s a lot of duplicated code in here. And if we were getting data from a\ncomplicated subquery instead of the table Moved, it would be even worse\n(though we can at least put all the duplicated code in a CTE since SQL Server\n2005). Of course, writing the code is done quickly enough once you master the\nuse of copy and paste, but the code has to be maintained as well.\n\nMaybe even worse is that the performance of this query just sucks \u2013 if you run\nthis (enclosed in a BEGIN TRAN / ROLLBACK TRAN, so you can run the variations\nbelow without having to rebuild the original data) and check out the execution\nplan, you\u2019ll see that the optimizer needs no less than five table scans (one\nfor Customers, and four for Moved) and four merge join operators. And that,\ntoo, would be much worse if the source of the data had been a complex subquery\n(and no, using a CTE will not help the optimizer find a better plan \u2013 it just\ndoesn\u2019t understand that the four subqueries are similar enough that they can\nbe collapsed.\n\nNow, if Microsoft had chosen to implement row-value constructors (as defined\nin the ANSI standard), we could have simplified this to\n\nUPDATE Customers\n\nSET (Street, HouseNo, City)\n\n= (SELECT Street, HouseNo, City\n\nFROM Moved AS m\n\nWHERE m.SSN = Customers.SSN)\n\nWHERE EXISTS (SELECT *\n\nFROM Moved AS m\n\nWHERE m.SSN = Customers.SSN);\n\nBut this is invalid syntax in any version of SQL Server (including the latest\nCTP for SQL Server 2008), and I know of no plans to change that before SQL\nServer 2008 RTMs.\n\nBut with using the proprietary UPDATE FROM syntax, we can simplify this, and\nget a much better performance to boot. Here\u2019s how the same update is written\nin non-portable code:\n\nUPDATE c\n\nSET Street = m.Street,\n\nHouseNo = m.HouseNo,\n\nCity = m.City\n\nFROM Customers AS c\n\nINNER JOIN Moved AS m\n\nON m.SSN = c.SSN;\n\nAnd now, the optimizer will produce a plan that scans each table only once and\nhas only a single merge join operator. Some quick tests (with much more rows\nin the tables) show that it executes two to three times quicker than the ANSI\nstandard version. For that performance gain, I will gladly choose the\nproprietary syntax over the standard!\n\nWhat\u2019s with the title of this post then? Why deprecate a fine feature?\n\nPatience, we\u2019re getting there. Bear with me.\n\nAll the above is true for versions of SQL Server up to SQL Server 2005. But\nSQL Server 2008 will change the playing field. It introduces a new statement,\nMERGE, that is specifically designed for situations where rows from a table\nsource either have to be inserted into a destination table, or have to be used\nto update existing rows in the destination table. However, there is no law\nthat prescribes that any MERGE should always actually include both an insert\nand an update clause \u2013 so with this new statement, we can now rewrite the\nabove code as follows:\n\nMERGE INTO Customers AS c\n\nUSING Moved AS m\n\nON m.SSN = c.SSN\n\nWHEN MATCHED\n\nTHEN UPDATE\n\nSET Street = m.Street,\n\nHouseNo = m.HouseNo,\n\nCity = m.City;\n\nAs you can see, the source table and the join criteria are included only once,\njust as in the proprietary UPDATE FROM. The execution plan (tested on the\nFebruary CTP, also known as CTP6) is also quite similar, including just a few\nextra operators that are specific to the new MERGE statement. What really\nsurprised me, was that the plan for the MERGE statement was estimated to be\nabout 65% cheaper (faster) than the corresponding UPDATE FROM statement.\nHowever, I think SQL Server is lying here \u2013 a quick test with more data shows\nonly an extremely marginal advantage of MERGE over UPDATE FROM. This test was\ntoo limited to draw serious conclusions, but I am quite sure that there will\nnot be a 65% saving by using MERGE over UPDATE FROM. (I do expect such a\nsaving form either MERGE or UPDATE FROM over the ANSI-compliant UPDATE\nstatement for this case).\n\nThe good news is that:\n\n1) The MERGE statement is described in SQL:2003 and can thus be considered\nANSI standard. (In fact, SQL Server implements a superset of the ANSI standard\nMERGE syntax: everything described in the syntax is implemented, but there are\nsome non-standard extensions that make the command even more useful as well.\nHowever, the example above uses only the standard features and should hence\nrun on each DBMS that conforms to the SQL:2003 version of MERGE).\n\n2) The MERGE statement will return an error message if I mess up my join\ncriteria so that more than a single row from the source is matched:\n\nMsg 8672, Level 16, State 1, Line 1\n\nThe MERGE statement attempted to UPDATE or DELETE the same row more than once.\nThis happens when a target row matches more than one source row. A MERGE\nstatement cannot UPDATE/DELETE the same row of the target table multiple\ntimes. Refine the ON clause to ensure a target row matches at most one source\nrow, or use the GROUP BY clause to group the source rows.\n\n3) The MERGE statement will gladly accept a view with an INSTEAD OF UPDATE\ntrigger as the target of the update.\n\nSo as you see, MERGE allows me to achieve what I previously could achieve only\nwith an ANSI standard UPDATE statement with lots of duplicated code and lousy\nperformance, or with a UPDATE FROM statement that hinders portability,\nintroduces a higher than normal risk of errors going unnoticed through QA\nright into the production database, and has some odd limitation on views with\nINSTEAD OF UPDATE triggers. None of these downsides and limitations apply to\nMERGE. And if there are any other problems with MERGE, I have yet to find\nthem.\n\nWith this alternative available, I fail to see any reason why the proprietary\nUPDATE FROM syntax should be maintained. In my opinion, it can safely be\nmarked as deprecated in SQL Server 2008. It should of course still work, as\n\u201cnormal\u201d supported syntax in both SQL Server 2008 and the next version, and in\nat least one version more if the database is set to a lower compatibility \u2013\nbut it should be marked as deprecated, and it should eventually be removed\nfrom the product. Why waste resources on maintaining that functionality, when\nthere is an alternative that is better in every conceivable way? I\u2019d much\nrather see the SQL Server team spend their time and energy on more important\nstuff, such as full support for row-value constructors and full support for\nthe OVER() clause. Or maybe even on releasing Service Pack 3 for SQL Server\n2005!\n\n### Share this:\n\n  * Click to share on Twitter (Opens in new window)\n  * Click to share on Facebook (Opens in new window)\n\n### Like this:\n\nLike Loading...\n\nHugo Kornelis\n\nHugo Kornelis is an established SQL Server Community expert. He writes, blogs,\nspeaks, tech edits, and researches, focusing mostly on SQL Server performance\nand execution plans. He was the technical editor for the third edition of\nGrant Fritchey's \"SQL Server Execution Plans\". In 2018 he started a project to\ndocument all behaviour of SQL Server execution plans at his website, \"the SQL\nServer Execution Plan Reference\" (https://sqlserverfast.com/epr) When not\nworking for the community, Hugo is busy at his day job: freelance database\ndeveloper/consultant. Hugo has over 20 years of experience on SQL Server in\nvarious roles. He has a strong database design background but has since\nspecialized into query tuning and execution plans.\n\nWant a Service Pack? Ask for it!\n\n[OT] Alive and kicking\n\n#### Related Posts\n\nNo results found.\n\n#### 58 Comments. Leave new\n\n  * Steve Dassin\n\nMarch 10, 2008 13:05\n\nYou might as well ask them to deprecate their multi-row triggers:) Have you\never considered the update-from and multi-row trigger as different sides of\nthe same coin?\n\nhttp://beyondsql.blogspot.com/2007/10/sql-undefined-trigger.html\n\nLoading...\n\nReply\n\n  * Alejandro Mesa\n\nMarch 10, 2008 20:36\n\nHi Hugo,\n\nVery interesting. I would prefer them to implement row-value constructors,\nthan deprecating the UPDATE statement. Both statements, UPDATE and MERGE, are\npart of the standard, aren\u2019t they?\n\nLet us know if you create an entry in connect.\n\nI really like your writing style,\n\nAMB\n\nLoading...\n\nReply\n\n  * Hugo Kornelis\n\nMarch 11, 2008 02:14\n\nHi Steve,\n\nNice try, but it won\u2019t fly\n\nMy main reasons for suggesting to deprecate UPDATE FROM can be summarized in\nshort as:\n\n1) It\u2019s not part of the ANSI standard, nor (as far as I know) part of any\nother RDBMS;\n\n2) Its results are undefined in some situations; and\n\n3) There is (in SQL Server 2008) an alternative that does everything UPDATE\nFROM can and then some, without incurring the two previously mentioned\nproblems.\n\nSince you consider multi-row triggers a different side of the same coin, let\u2019s\nsee how these three main points relate to them:\n\n1) The ANSI standard describes both statement-level and row-level triggers. If no \"FOR EACH [ROW | STATEMENT]\" is specified, the trigger has to default to statement level \u2013 what you can a multi-row trigger. Granted, SQL Server does not exactly follow the ANSI standard syntax for triggers, but statement-level (multi-row) triggers are definitely ANNSI standard.\n\n2) The results of multii-row triggers are defined very exactly, and in all\nsituations. Whenever an insert, update, or delete is executed, the trigger\nwill fire, with all rows affected in the \"inserted\" and \"deleted\" pseudo-\ntables. This is documented and described ad nauseam, and I\u2019ve never seen\nanything unexpected happen WRT trigger execution.\n\n3) One might argue that the ANSI standard still offers row-level triggers as a\nvalid alternative for statement-level triggers. But since SQL Server does not\nimplement them, there is (as of SQL Server 2008) no replacement for statement-\nlevel triggers. Deprecating them would leave us without any triggers at all!\nDefinitely not a good idea.\n\nAfter reading your blog post on this subject, I can only conclude that you are\ngood at stringing together words that at first sight seem to make sense, but\non second sight reveal your absolute lack of comprehension of the subject.\nWhich is a shame, for I really believe that Dataphor deserves a better\nproponent.\n\nBest, Hugo\n\nLoading...\n\nReply\n\n  * Hugo Kornelis\n\nMarch 11, 2008 02:27\n\nHi Alejandro,\n\nJust to make sure you don\u2019t misunderstand me: I don\u2019t suggest deprecating\nUPDATE, it\u2019s only the FROM clause (and thus the possibility to join) in the\nUPDATE (and DELETE) statement that I\u2019m targetting.\n\n> >UPDATE and MERGE, are part of the standard, aren\u2019t they?<<\n\nYes, they are \u2013 but the standard does not allow a FROM clause (or any other\nmethod of specifying a join) in the UPDATE statement.\n\n> >Let us know if you create an entry in connect.<<\n\nI had not plannned to actually suggest this on Connect, but your comment made\nme change my mind. I filed\nhttps://connect.microsoft.com/SQLServer/feedback/ViewFeedback.aspx?FeedbackID=332437.\nI expect lots of negative feedback on this one!\n\n> >I really like your writing style,<<\n\nThanks. That\u2019s good to hear.\n\nLoading...\n\nReply\n\n  * Saggi Neumann\n\nMarch 11, 2008 13:58\n\nHey Hugo,\n\nNice post!\n\nWhat about DELETE FROM (with JOINs)? Not as common as UPDATE FROM, but can\nalso be replaced by MERGE.\n\nAs a side note, I agree that standards and sticking to them is important, but\nat least in 50% of the time it is more beneficial to a project that the code\nworks in several versions of the same product than having the code work cross-\nplatform. In these cases even if row-value constructors were introduced in\n2008, I\u2019d use UPDATE FROM in my code, for backwards compatibility.\n\nCheers,\n\nS. Neumann\n\nLoading...\n\nReply\n\n  * Alejandro Mesa\n\nMarch 11, 2008 15:22\n\nHi Hugo,\n\n> Just to make sure you don\u2019t misunderstand me: I don\u2019t suggest deprecating\n>\n> UPDATE, it\u2019s only the FROM clause (and thus the possibility to join) in the\n> UPDATE > (and DELETE) statement that I\u2019m targetting.\n\nThanks for the clarification. I did understand you, but made a mistake in my\npost and it was to late to fix it.\n\nI remember from the request sent by Itzik Ben-Gan and Sujata Mehta, about the\nfull support for the OVER clause, a section talking about \"Vector\nexpressions\". In the document they suggest the implementation of \"Vector\nexpressions\" to avoid declaring the same OVER clause in miltiple expressions.\nIn the connect entry, the request changed to use the SQL:2003 WINDOW\ndefinition, which is more elegant regards OVER clause.\n\nThanks for creating the connect entry. You got my vote.\n\nI hope Microsoft put more attention to the requests coming from the SQL Server\ncommunity.\n\nAMB\n\nLoading...\n\nReply\n\n  * jerryhung\n\nMarch 11, 2008 16:31\n\nI use UPDATE FROM and DELETE FROM often ........\n\nI could live with a change, but it\u2019s quite more work lazy me\n\nLoading...\n\nReply\n\n  * Hugo Kornelis\n\nMarch 11, 2008 22:56\n\nHi Saggi,\n\nGood catch!\n\nI actually intended to include some comments on DELETE FROM, but when I\nnoticed that I already was well over what I regard to be the maximum lengthh\nfor a bllog post, I changed my mind. Forunately, you are now giving me a\nchance to make up for that.\n\nDELETE FROM should never have been supported at all. I have never ever seen a\nquery with DELETE FROM that could not have been written just as well with\nDELETE WHERE EXISTS. The only thing it has going for it is that its inclusion\nis congruent with the inclusion of UPDATE FROM \u2014 so when I suggest deprecating\nUPDATE FROM, it\u2019ll come as no surprise that I believe DELETE FROM should be\nremoved as well.\n\nBy the way, the connect entry I opened after Alejandro suggested me to does in\nfact mention DELETE FROM as well.\n\nThanks, all, for your comments!\n\nLoading...\n\nReply\n\n  * Steve Dassin\n\nMarch 12, 2008 07:15\n\nHello Hugo,\n\n> \"you are good at stringing together words...but reveal your absolute lack of\n>\n> comprehension\"\n\nWell, you have a curious form of courtesy to those coming to your home:)\n\n> >\"You might as well ask them to deprecate their multi-row triggers\":)\n>\n> \"...there is (as of SQL Server 2008) no replacement for statement-level\n> triggers. >Deprecating them would leave us without any triggers at all!\n> Definitely not a good idea.\"\n\nI confess to the mistake of again underestimating the amount of sarcasm needed\nto make a point (drip,drip:). Shouldn\u2019t you save such a precious commodity\nlike scorn for a serious matter? I resent being called an empty suit for\npoking fun at sql:) Although I don\u2019t really see anything wrong with a connect\ncandidate that argues for a redesigned trigger based on common sense\nconsiderations. Really, all I tried to do was bring attention to two\nconstructs that share \"multirow\" considerations that don\u2019t make the lives of\ndevelopers any easier. Both require an unwarranted intervention. To paraphrase\nyou, an undefined update is \"congruent\" with a multirow considered trigger. As\nHugo Igo, no?:) Speaking of standards, do you have two?:)\n\nI\u2019m quite sure we\u2019re talking about a moot point here as far as change. What\nwould be interesting would be their \"real\" rationale. I wouldn\u2019t be surprised\nif it didn\u2019t include the usual suspects.\n\n> \"...I really believe that Dataphor deserves a better proponent.\"\n\nNow you\u2019re talking about a serious matter. I would gladly concede defeat in\nthis battle to win a much wider war:) Can I finally compliment you for seeing\nthe bright light? A relational form of update and a relational trigger are\nquite different beasts compared to their sql counterparts. We are talking\nabout different considerations. I look forward to your taking up the challenge\nto lead sql folks to a relational system. And succeed where I have failed!\n\nLoading...\n\nReply\n\n  * Dave Markle\n\nMarch 12, 2008 16:16\n\nI tend to disagree about your ability to string together words. Steve, I found\nyour blogs pretty hard to follow.\n\nThere\u2019s a lot to be said about working with the standards we have now. Steve,\ndo you use a Dvorak or a QWERTY keyboard? Just because we may know that\nthere\u2019s something better out there doesn\u2019t mean that we can or should dump\nwhat we have now, stop extending and polishing it, and start with what\u2019s\n\"better\". SQL is a lot like that. It may have cruft, but it\u2019s the lingua\nfranca for data manipulation right now.\n\nHugo, I think UPDATE FROM should be deprecated when we have a standard syntax\nwhich performs as well and is as understandable as what we have now... But if\nthey can\u2019t deprecate DELETE FROM, do you think there\u2019s ever going to be a\nchance that UPDATE FROM will be?\n\nLoading...\n\nReply\n\n  * andyleonard\n\nMarch 12, 2008 21:03\n\nHi Hugo,\n\nI was unaware of the potential for undefined results. Data integrity is vital\n\u2013 enough for me to change my coding habits from Update From to Merge in SQL\nServer 2008. I\u2019m sold on Merge based on your post.\n\nDeprecating features has to be a tricky, touchy subject. There\u2019s stuff in SQL\nServer I\u2019d like to see go, but it turns out I am accurately representative of\nprecisely one user(s). I don\u2019t know how Microsoft decides on what stays and\nwhat goes. Based on history, I would guess ANSI compliance isn\u2019t at the top of\nthe list.\n\n:{> Andy\n\nLoading...\n\nReply\n\n  * matt\n\nMarch 12, 2008 23:39\n\nwhat do you think of the oracle syntax\n\nupdate ( select .... from multiple tables )\n\nset c1 = ..., c2 = ...\n\nis this standard? safe? if so why doesn\u2019t sqlserver support it?\n\nAnd using Merge isn\u2019t really an option for a lot of people since they have to\nsupport mssql2005 for probably at least another 2-3 years (and what about\nother vendor\u2019s dbms ... not that you could use update from anyways...)\n\nLoading...\n\nReply\n\n  * Hugo Kornelis\n\nMarch 13, 2008 03:13\n\nWow, lots of new comments added. Thanks, all! I really appreciate it!\n\n@Steve:\n\n> >you have a curious form of courtesy to those coming to your home:)<<\n\nHehe! The comments sections of my blog, especially after a deliberately\nprovocative post, should be compared to a debating club, not to my home\n(though my home sometimes is hard to distinguish from a debating club).\n\nAs far as I\u2019m concerned, everyone is free to speak their minds here \u2013 I have\nso far only removed comments that were pure spam (though I will also remove\ncomments with high volumes of profanity). Yes, I can be harsh \u2013 if I think\nsomeone is wrong, I will say so in very clear words. And I expect no less from\nmy readers when they see me making a mistake!\n\n> >Although I don\u2019t really see anything wrong with a connect candidate that\n> argues for a redesigned trigger based on common sense considerations<<\n\nSo far, I\u2019ve only seen you claim THAT SQL Server\u2019s triggers are badly\ndesigned, with insufficient backing. I\u2019ve seen no proposed \"common sense\"\nreplacements. But do let me know once you have the suggestion filed on Connect\n\u2013 I\u2019ll gladly read your suggestions, and if I agree that you have found a\nbetter way, I\u2019ll vote for it.\n\n> >Really, all I tried to do was bring attention to two constructs that share\n> \"multirow\" considerations that don\u2019t make the lives of developers any\n> easier. Both require an unwarranted intervention. To paraphrase you, an\n> undefined update is \"congruent\" with a multirow considered trigger<<\n\nParaphrase? It looks more like an attempt to put words in my mouth. I don\u2019t\nsee any congruence between the two.\n\nUPDATE ... FROM can cause a situation where two or more values are selected to\nbe put into a single value \u2013 and there\u2019s no way of predicting which one will\nmake it. That\u2019s why Books Online calls the behaviour UNDEFINED.\n\nTriggers will fire once per statement, so that the trigger code has to be\nwritten just as set-based as all other SQL. Nothing unpredictable, nothing\nundefined \u2013 but for some programmers (a.o. those with Oracle background, where\nrow-based triggers were for a long time the only option), this comes as a\nsurprise. That\u2019s what the \"consideration\" in Books Online is all about \u2013 I\u2019d\npersonally rather call it a heads up or a warning.\n\nThe behaviour of triggers is correct and is defined in all situations, but\nsome developers need a heads up. The behaviour of UPDATE FROM is undefined in\nsome situations. You really can\u2019t compare those in any way.\n\nre Dataphor \u2013 I won\u2019t be its proponent, sorry. It is a product I would like to\nget to know a bit better if I could spare some time \u2013 but I am currently\ntrying very hard to squeeze 28 hours into each day, and it doesn\u2019t appear to\nbe working. But I do hope that others, with more time available, will explore\nit \u2013 and I\u2019m afraid that your anti-SQL crusade accomplishes rather the reverse\n\u2013 expecially when you use far-fetched arguments such as these. Come on, there\nare enough REAL problems in SQL Server, you don\u2019t have to clutch straws!\n\n@Dave:\n\n> >But if they can\u2019t deprecate DELETE FROM, do you think there\u2019s ever going to\n> be a chance that UPDATE FROM will be?<<\n\nI was going to reply that I never really expected much from my suggestion on\nConnect, but I just got notice that a comment has been added on Connect \u2013\napparently, the SQL development team had already planned to look into the FROM\nclause for UPDATE and DELETE and will now take this suggestion as another\nconsideration for the equation.\n\nUgh, that sentence didn\u2019t come out as intended. And it sounded so great when I\nheard it in my head (but that was in Dutch, unfortunately ;-))\n\n@Andy:\n\nGlad to hear that you have decided to shy away from UPDATE FROM in the future.\n\n> >I don\u2019t know how Microsoft decides on what stays and what goes. Based on\n> history, I would guess ANSI compliance isn\u2019t at the top of the list.<<\n\nI\u2019d love to know, but I don\u2019t expect them to share. It seems as if there are\nmultiple camps inside Microsoft, as you sometimes see new features that\nclosely follow the standards (MERGE is a great example \u2013 the \"extra\" feratures\nare implemented in such a way that ANSI standard MERGE can be parsed and\nexecuted without any change), and then you see things going right against the\nstandard (for instance, even though Books Online urges us to use ROWVERSION\ninstead of TIMESTAMP for the ROWVERSION data type, the SQL generated from a\ntable will actually use TIMESTAMP).\n\n@Matt:\n\n> >what do you think of the oracle syntax (...) is this standard?<<\n\nNo. The late draft of the SQL:2003 standard that I have (check wikipedia for\nthe download location, if you\u2019re interested) has this specification for\nUPDATE:\n\n<update statement: searched> ::=\n\nUPDATE <target table> [ [ AS ] <correlation name> ]\n\nSET <set clause list>\n\n[ WHERE <search condition> ]\n\n> >safe?<<\n\nDunno. I\u2019ve never had a chance to play with Oracle, and I was unaware of this\nsyntax. But test for yourself \u2013 create two sample tables using the standard\nOrderHeader / OrderDetail scheme and then try to use this syntax to set a\ncolumn in the OrderHeader table equal to one in the OrderDetail. This should\nfail (since you have to specifiy which of the different OrderDetail rows to\nuse). If it works, it\u2019s just as unsafe as SQL Server\u2019s UPDATE FROM.\n\n> >if so why doesn\u2019t sqlserver support it?<<\n\nI don\u2019t think they\u2019ll beat Oracle by copying its features. They have to try to\nstay ahead.\n\nAnyway, since we\u2019ve got MERGE now, there is no longer any reason to want them\nto copy this. Right?\n\n> >And using Merge isn\u2019t really an option for a lot of people since they have\n> to support mssql2005 for probably at least another 2-3 years<<\n\nThat\u2019s why I suggested deprecating it first, and removing it after a couple of\nversions. So that people have ample time to fix their code.\n\nOnce more: thanks all for your great comments \u2013 do keep them coming!\n\nLoading...\n\nReply\n\n  * matt\n\nMarch 13, 2008 23:25\n\nI did a quick test (not using orderheader/orderdetail, just some schema I made\nup)\n\nUpdating the inline view fails with an error when the update isn\u2019t\ndeterministic:\n\nORA-01779: cannot modify a column which maps to a non key-preserved table\n\nI joined two tables t1 and t2 .. If I updated a column on t1 with a column on\nt2, I got the error unless the column I joined on was unique in t2 (I had to\ncreate a unique index .. the mere absence of duplicate values without a unique\nindex still resulted in error) .. So the update of an inline view seems safe\nbut nonstandard.\n\nI checked the manuals and oracle does support update from. Using the join that\ngenerated the ORA-01779 error using the UPDATE ( view ) syntax, merge\ngenerates\n\nORA-30926: unable to get a stable set of rows in the source tables\n\nWhen I added the unique index, merge performed as expected. I was able to test\noracle 11.1 and 10.2, but I didn\u2019t have a 9.2 instance handy.\n\nI did notice in comparing the oracle and sqlserver docs that sqlserver there\nis some variation in the supported syntax. They both support WHEN MATCHED, but\nsqlserver supports WHEN MATCHED AND, they both support WHEN NOT MATCHED but\noracle doesn\u2019t support AND and TARGET can\u2019t be specified. SqlServer supports\nWHEN SOURCE NOT MATCHED that Oracle doesn\u2019t seem to support at all.\n\nIn any event, good blog entry \u2014 its got me thinking and made me reconsider\nmerge over update from and double check what oracle supports (my company\nsupports both sql and oracle) .. Once SQL2008 is the min platform, we should\nbe able to use standard sql across both platforms instead of sqlserver\u2019s\nupdate from or the oracle\u2019s update of an inline view.\n\nin the meantime, at the very least shouldn\u2019t sqlserver be generating an error\nif the update from isn\u2019t deterministic?\n\nLoading...\n\nReply\n\n  * Hugo Kornelis\n\nMarch 14, 2008 02:25\n\nHi Matt,\n\nThanks for testing on Oracle and sharing the results.\n\n> >I did notice in comparing the oracle and sqlserver docs that sqlserver\n> there is some variation in the supported syntax<<\n\nCorrect. From what you write, it seems as if Oracle is supporting ANSI\nstandard MERGE. SQL Server does so as well \u2013 but it has also added extra\nfeatures and possibilities.\n\nFortunately, they have chosen the syntax so that the plain bog-standard ANSI\nsyntax for MERGE is a subset of the full syntax, so any ANSI-compliant MERGE\nstatement should work without change in SQL Server.\n\n> >in the meantime, at the very least shouldn\u2019t sqlserver be generating an\n> error if the update from isn\u2019t deterministic?<<\n\nI would prefer that to the current behaviour, but I don\u2019t think they\u2019ll change\nit \u2013 it would potentially break too much existing code. If they are prepared\nto do that, they might just as well pull the feature completely (and based on\nthe comment on Connect, it appears as if they are indeed giving this serious\nconsideration).\n\nBest regards,\n\nHugo\n\nLoading...\n\nReply\n\n  * Steve Dassin\n\nMarch 16, 2008 12:07\n\nDave Markle (and K\u2019s of others no doubt) said:\n\n<quote> Just because we may know that there\u2019s something better out there\ndoesn\u2019t mean that we can or should dump what we have now, stop extending and\npolishing it, and start with what\u2019s \"better\".<unquote>\n\nTo quote Dalton (Patrick Swayze) from \u2018Road House\u2019, \"I get that alot\". In case\nyou haven\u2019t heard the Cloverfield of software is also offering an alternative,\nie. the object model with LINQ/EFM. I assume you have the same sediment to\nMS:) Perhaps you don\u2019t like my way of courting you. I\u2019m not bashing sql, I\u2019m\nsimply pointing out the holes in it and showing how the relational model fills\nthem in. Is it irritating, probably so. There\u2019s always a price to be paid for\nexamining a comfort zone. Of course MS has taken quite a different tack. You\ndon\u2019t see MS evangelists getting into the face of sql folks do you. You don\u2019t\nsee them directly addressing sql folks with the reasons why they should leave\nsql and work with an object model. Nope, they are more than content to leave\nsql folks alone. LINQ is really not targeted here because MS does not really\ncare whether sql folks jump ship. You are expendable:) And they don\u2019t take the\nrisk of getting your ire up and alienating you. It\u2019s quite an interesting\nstrategy they have. Sql folks foster a product that is going in the opposite\ndirection of their intentions without any opposition:)\n\n> Steve, I found your blogs pretty hard to follow.\n\nWell the relational model is a \u2018real\u2019 theory. Dataphor is not trivial, you\ngotta use your head to think where you haven\u2019t had too in sql. No pain, no\ngain:) As the saying goes there is no such thing as a small logical\ndifference. They are all monster differences.\n\n> Sql is \"the lingua franca for data manipulation right now.\"\n\nYep, for a large variety of reasons amongst which an intellectual one is not\namong them. Users fear vendors but that\u2019s backwards. I\u2019m hoping at some point\nthe simple consent for sql as \u2018the\u2019 thing for data manipulation melts and\ncoalesces around something else (just as MS does).\n\n> I found your blogs pretty hard to follow.\n\nThat\u2019s because you\u2019re used to the heavy lifting in BOL:) The \"how\" of syntax\nis easy, the \"what\" and \"why\" of it is not. The subject matter is not always\nobvious and to be entertaining at the same time is no easy feat. Go double or\nnothing, give me a second read:)\n\nHugo said:\n\nAs far as triggers go \"...do let me know once you have the suggestion filed on\nConnect\"\n\nI think there\u2019s already too many users who are patronized. I\u2019ll stick with\ncriticism:) The simplest common sense consideration for a trigger would be for\nthe system to understand a \u2018row\u2019 as a type. As far as sql case closed:)\n\n> I\u2019m afraid that your anti-SQL crusade accomplishes rather the reverse \u2013\n> expecially >when you use far-fetched arguments such as these.\n\nOf the many arguments I\u2019ve made against sql you\u2019re sentencing me on just this\none? That hardly seems fair:)\n\n> Dataphor \u2013 I won\u2019t be its proponent, sorry. It is a product I would like to\n> get to >know a bit better if I could spare some time...\n\nIsn\u2019t that excuse on the same level as \"I was just following orders\"?:) Do you\nreally want to leave pioneering work to others...like me?:)\n\nLoading...\n\nReply\n\n  * Hugo Kornelis\n\nMarch 17, 2008 01:54\n\nHi Steve,\n\n> >I\u2019ll stick with criticism:) <<\n\nI expected as much. Criticising is easier than specifying an alternative.\n\n> >The simplest common sense consideration for a trigger would be for the\n> system to understand a \u2018row\u2019 as a type.<<\n\nWhy? Coming from someone who claims SQL Server is not relational enough, this\nis a surprising statement. The relational model is about sets. SQL Server is\n(mostly) about sets as well.\n\nEvery serious SQL Server developer should learn to think set-based. And once\nyou have mastered that, coding row-based triggers seems like a step backwards\nto me.\n\n> >Of the many arguments I\u2019ve made against sql you\u2019re sentencing me on just\n> this one? That hardly seems fair:) <<\n\nI\u2019m singling out this one, because this one happens to be made on my blog, as\npart of an attack of a view I presented.\n\nOn other places, I have learned to mostly ignore your posts.\n\n> >Isn\u2019t that excuse on the same level as \"I was just following orders\"?:)<<\n\nNo. \"I was following orders\" puts the blame on someone else. I take full\nresponsibility for choosing to spend time on stuff I consider more important.\nThat\u2019s my choice, and you\u2019re free to blame me for it.\n\n> >Do you really want to leave pioneering work to others...like me?:)<<\n\nYes. At least, this pioneering. I choose to spend my energy pioneering in\ndifferent areas, where I think more progress can be made.\n\nBest, Hugo\n\nLoading...\n\nReply\n\n  * Robert\n\nMarch 17, 2008 11:43\n\nI use UPDATE FROM regularly. Result are AFAIK never undefined. Predictability\nof the statements are responsibility of developer. MERGE can replace it and do\nmore, however, a lot of customers still use sql server2000/2005, so if they\nupgrade in a future to a version not supporting UPDATE FROM, I\u2019d have to\nrewrite a lot of triggers and stored procedures working perfectly well.\n\nIf you know the data model well and how to properly join tables, you know how\nto write a predictable UPDATE FROM.\n\nDo you blame a gun, when you shoot yourself in the foot? Usually not.\n\nIt should return an error in case of unpredictable result, but I\u2019d never agree\non removing this feature. The error would not break much existing code as I\ndon\u2019t thing there are many misusing this. Also, bad UPDATE FROM sends trash to\ntriggers.\n\nAbout triggers. It would be nice, if we had BEFORE triggers:\n\nif it rejects the update, no update takes place, if after trigger does it, the\nclient must rollback the transaction. What if it\u2019s not a well behaving client?\nThere are INSTEAD OF triggers, which can do the job, but they\u2019re not the same\nthing and have a lot of limitations. it can modify data without performing an\nupdate (update the \"inserted\" table instead of actual table)\n\nInto the same basket would go a request for row level triggers. Most of things\ncan be done with statement level triggers, but sometimes a set based solution\nis not possible, so you have to use a cursor.\n\nLoading...\n\nReply\n\n  * Ken Lee\n\nMarch 18, 2008 08:29\n\nUpdates that are deterministic!?! What an idea. I\u2019m having a hard time\nconvincing people that creating tables without a unique constraint is a bad\nidea. (OK, that\u2019s false. They agree that it is a good idea and maybe sometime\nin the future they may consider...)\n\nI agree that deprecating \"update from\" in version 2010 (or whatever after SQL\n2008) is a good idea but there are companies that run SQL 6.5 now. When would\nbe a good time for commercial software suppliers to consider replacing with\nthe \"MERGE INTO\" commands? Major companies are just now converting from SQL\n2000 to SQL 2005 and they definitely aren\u2019t implementing sweeping changes in\ntheir code to take advantage of 2005 changes.\n\nThe only people who should consider using \"MERGE INTO\" now have control of\ntheir SQL driver and know it is not going to change into a non ANSI 2003\nstandard driver in the future. Hmm isn\u2019t that one of the reasons why we\nshouldn\u2019t use \"UPDATE FROM\"... we don\u2019t control our SQL driver?:)\n\nLoading...\n\nReply\n\n  * Steve Dassin\n\nMarch 18, 2008 08:38\n\nHello Hugo,\n\n> I expected as much. Criticising is easier than specifying an alternative.\n\nWhen I said \"I think there\u2019s already too many users who are patronized. I\u2019ll\nstick with criticism\" I meant I would rather have someone criticize me for a\npoint of view I expressed (like here) than be patronized based on a submission\non Connect. And I thank you for reinforcing my decision:)\n\nLets look at the sql server big picture of the associations between Update,\ntriggers and Match. In \u2018Multirow Considerations for DML Triggers\u2019\n\nms-\nhelp://MS.SQLCC.v9/MS.SQLSVR.v9.en/udb9/html/d476c124-596b-4b27-a883-812b6b50a735.htm\n\n\"C. Storing a running total based on the type of insert\"\n\nNow if someone asks the question \u2018what is the optimal trigger to store a\nrunning total\u2019 the answer is the bedrock that sql rests on, \u2018it depends\u2019.\nThat\u2019s what a multirow consideration is, a dependency. There\u2019s no definition\nof a trigger independent of the data. And if nothing else this consideration\nresults in more code than if the trigger was based on a row (ie for each row).\nMore code runs contrary to the idea of parsimony of effort, where less is\nbetter. Now ask the simplest question of Update, \"what can you update\" and the\nsql answer is \"it depends\". It depends if it\u2019s an expression(no), a\ntable(yes), a view with a single table (possibly), a view with multiple\ntables(no) etc. It\u2019s a relational idea that Update can be used with anything\nthat the system recognizes as a table. Therefore there\u2019s no consistency to the\nsql Update. The motivation of Match is simply a way to overcome this\ninconsistency in sql. The idea of using Match to drive an insert or an update\nis something a relational system does implicitly. Sql cannot do the same\nbecause it requires an explicit concept of \"keys\" which is a different animal\nfrom sql indexes. But what is the price of Match? It too runs contrary to\nparsimony of effort.\n\nThis idea of parsimony is important. It\u2019s a central theme in MSs push for the\nobject model (LINQ/EFM) and declarative programming. They are convinced that\ndevelopment can be done in a simpler way than sql. Perhaps this explains their\npatronizing on Connect:) I\u2019m afraid MS no longer has their heart in sql. If I\ncan only convince them that the relational model also is an example of \"less\nis more\":)\n\nLoading...\n\nReply\n\n  * jeet\n\nApril 1, 2008 12:56\n\nBrilliant stuff!\n\nLoading...\n\nReply\n\n  * Eirik Mangseth\n\nApril 1, 2008 17:41\n\nHugo,\n\nI think you should read up on your transact-sql history. I used Sybase back in\nthe early nineties and it had support for UPDATE..FROM, so I don\u2019t think this\nwas something M$ added. They rather kept what was already there.\n\nE\n\nLoading...\n\nReply\n\n  * Hugo Kornelis\n\nApril 2, 2008 15:02\n\nHi Eirik,\n\nThanks for the history lesson. Even though I have actually worked with SQL\nServer 4.2 (which, IIRC, was still based on the common codebase), I never\nrealised that UPDATE FROM existed back then. I always assumed that MS added it\nwhen they rewrote the entire codebase \u2013 but I never went the extra mile to\nactually check it.\n\nLoading...\n\nReply\n\n  * CosmicTrickster\n\nApril 11, 2008 07:06\n\nAnother general consideration is performance vs. portability. Various RDMS\nhave their own flavours of SQL. So do you choose the lesser performing syntax\nin order to support ease of portability? Or do you code for each RDMS you\nchoose to support with your application, but have optimised versions for each\nRDMS so that it performs the best it can for a given platform?\n\nRhetorical question, I\u2019m not looking for an answer to it. It\u2019s six of one,\nhalf a dozen of the other. Or, as is more commonly heard in DBA circles, \"it\ndepends\".\n\nLoading...\n\nReply\n\n  * ALZDBA\n\nMay 9, 2008 11:24\n\nNice article, good comments.\n\nI guess, if the would deprecate update from, they would end up providing a\n\"hotfix\" with the need of a startup parameter to revert to the \"old\"\nbehaviour. Cfr \"views with order by\" with the results actualy being ordered as\ndefined in the view.\n\nThe new merge will have my favour.\n\nLoading...\n\nReply\n\n  * John\n\nJune 2, 2008 23:36\n\n> >Yes, I can be harsh \u2013 if I think someone is wrong, I will say so in very\n> clear words. And I expect no less from my readers when they see me making a\n> mistake!<<\n\nHugo, one word: Spell Check. It\u2019s your friend.\n\nLoading...\n\nReply\n\n  * Diana\n\nJune 7, 2008 14:26\n\nThank you for making me aware of the \"messed up joins\" case. I\u2019ve never run\ninto this until now \u2013 I use the \"source table\" primary key for joining and I\ntest the result. But from now on I\u2019ll pay more attention...:)\n\nLoading...\n\nReply\n\n  * Daniel Andrews\n\nJune 16, 2008 23:31\n\nUnfortunately, the subqueries you suggest require a tablescan for each. Lets\nsay you are migrating data stored in a vision file format that you have to\nconvert to line sequential format then import that data into a sql server db\ntable. It\u2019s much easier and more efficient to use update from when dealing\nwith 2 tables of 15 million records and 1 table of 7 million records to update\nfrom when they have character based key fields to combine that information in\na relational format over 5 different tables. Perhaps you are correct with what\nyou are saying but if no one pushes the envelope on standards then the\nimplementations stagnate.\n\nLoading...\n\nReply\n\n  * Steve Danowitz\n\nJuly 7, 2008 20:55\n\nYour statement, \"SQL Server will happily update the same row over and over\nagain if it matches more than one row in the joined table, with only the\nresult of the last of those updates sticking\" is not true\n\nSQL Server 2005 Books Online says, \"a single UPDATE statement never updates\nthe same row two times.\"\n\nLoading...\n\nReply\n\n  * Hugo Kornelis\n\nJuly 7, 2008 21:40\n\nSteve:\n\nThanks for your comment. You are right, insofar that indeed SQL Server will\nnot physically update a row, write out the new value, then update it again. It\nwill, however, read and process all matching rows in the source, changing the\nin-memory version of the \"new\" row on every iteration, before finallly writing\nout the final version.\n\nThe point I was making was not about performance (which it would have been if\nindeed each row was physically updated multiple times), but about\nunpredictable behaviour \u2013 since if the execution plan changes, so does the\norder in which rows are processed and hence the value that just happens to be\n\"last\".\n\nIf you copy the code below and paste it in SSMS, you\u2019ll see what I mean \u2013 just\nadding an index changes the effect of the UPDATE. (And if you run with\n\"Include Actual Execution Plan\" enabled, you\u2019ll also see that indeed all rows\nfrom the source table are read.\n\nAll others: Thanks for your comments as well!\n\nBest, Hugo\n\nLoading...\n\nReply\n\n  * Hugo Kornelis\n\nJuly 7, 2008 21:41\n\nCREATE TABLE Dest (KeyCol int PRIMARY KEY, DataCol varchar(20));CREATE TABLE\nSource (KeyCol int, \u2014 no PRIMARY KEY! DataCol varchar(20))INSERT INTO Dest\n(KeyCol, DataCol)VALUES (1, \u2018Original\u2019);INSERT INTO Source (KeyCol,\nDataCol)VALUES (1, \u2018First new value\u2019);INSERT INTO Source (KeyCol,\nDataCol)VALUES (1, \u2018Second new value\u2019);goUPDATE DestSET DataCol =\ns.DataColFROM Dest AS dINNER JOIN Source AS s ON s.KeyCol = d.KeyCol;SELECT\n*FROM Dest;goCREATE INDEX ix1 ON Source(KeyCol, DataCol DESC);goUPDATE DestSET\nDataCol = s.DataColFROM Dest AS dINNER JOIN Source AS s ON s.KeyCol =\nd.KeyCol;SELECT *FROM Dest;goDROP TABLE Dest, Source;\n\nLoading...\n\nReply\n\n  * Regina\n\nJuly 18, 2008 16:05\n\nHugo,\n\nWe use SQL Server, PostgreSQL and MySQL most of all the databases. All support\nsome variant of UPDATE FROM. Granted its annoying they do it slightly\ndifferently. So UPDATE FROM even though not ANSI standard is not some weird\nthing concocted by Microsoft or Sybase.\n\nIt would be nice if all databases that support it do it the same way but I\ntend to find it more efficient and intuitive than any other way. I tend to\nlike PostgreSQL implementation the most.\n\nUPDATE sometable\n\nFROM someothertable\n\nWHERE sometable.someid = someothertable.someid;\n\nThere are also things such as Information_schemas \u2013 which are ANSI standard\nand supported by SQL Server, PostgreSQL, and MySQL (neither Oracle or IBM\nsupport those \u2013 so so much for standards)\n\nLoading...\n\nReply\n\n  * Joshua\n\nMarch 10, 2009 18:22\n\nOne quick question. When updating multiple rows with multiple possible values\nusing update-from statements, is it possible to have different values for each\nupdated row?\n\nTaking following scripts for example, is it possible to produce results like\n\n1, 10\n\n1, 20 ?\n\nOr the results could just be one of\n\n1, 10\n\n1, 10\n\nor\n\n1, 20\n\n1, 20 ?\n\nI\u2019d appreciate it if you can share your experience. Thank you.\n\nUSE tempdb;\n\nGO\n\nIF OBJECT_ID (\u2018dbo.Table1\u2019, \u2018U\u2019) IS NOT NULL\n\nDROP TABLE dbo.Table1;\n\nGO\n\nIF OBJECT_ID (\u2018dbo.Table2\u2019, \u2018U\u2019) IS NOT NULL\n\nDROP TABLE dbo.Table2;\n\nGO\n\nCREATE TABLE dbo.Table1\n\n(ColA int , ColB int);\n\nGO\n\nCREATE TABLE dbo.Table2\n\n(ColA int , ColB int);\n\nGO\n\nINSERT INTO dbo.Table1 VALUES(1, 10);\n\nINSERT INTO dbo.Table1 VALUES(1, 20);\n\nINSERT INTO dbo.Table2 VALUES(1, 0);\n\nINSERT INTO dbo.Table2 VALUES(1, 1);\n\nGO\n\nUPDATE dbo.Table2\n\nSET dbo.Table2.ColB = dbo.Table1.ColB\n\nFROM dbo.Table2\n\nINNER JOIN dbo.Table1\n\nON (dbo.Table2.ColA = dbo.Table1.ColA);\n\nGO\n\nSELECT ColA, ColB\n\nFROM dbo.Table2;\n\nLoading...\n\nReply\n\n  * Duke Ganote\n\nMarch 11, 2009 17:00\n\nI learned a lot about UPDATE FROM by reading this! Thank you.\n\nI reference it in a wiki discussion of UPDATE options in Oracle:\n\nhttp://tinyurl.com/2vphxg\n\nAnd I concur that MERGE is much more intuitive.\n\nJust FYI\n\nHere\u2019s a short URL for your entry: http://tinyurl.com/deprecateUPDATEfrom\n\nLoading...\n\nReply\n\n  * Alexander Kuznetsov\n\nMay 5, 2009 17:21\n\nHi Hugo,\n\nWhere is the Connect item to vote for?\n\nLoading...\n\nReply\n\n  * Hugo Kornelis\n\nMay 5, 2009 17:28\n\nHi Alexander,\n\nThe link was hidden in one of the comments. Here it is again:\n\nhttps://connect.microsoft.com/SQLServer/feedback/ViewFeedback.aspx?FeedbackID=332437\n\nBest, Hugo\n\nLoading...\n\nReply\n\n  * star\n\nJuly 24, 2009 01:33\n\nI am using a join in sql to update pfsalprf using data from pfposifx, getting\nan error(Column qualifier or table PFPOSIFX undefined) , can\u2019t figure out what\nI am missing.\n\nupdate pfsalprf set plunbr = pfposifx.itmplu from pfposifx where pfp\n\nosifx.itmnbr = pfsalprf.plunbr\n\nLoading...\n\nReply\n\n  * Hugo Kornelis\n\nAugust 5, 2009 13:27\n\nHi Star,\n\nAssuming you\u2019re using SQL Server and not any other database, I see no errors\nin the code you posted.\n\nI suggest that you find a SQL Server forum or newsgroup and repeat the\nquestion there. And in order for others to help you find the problem, you best\ninclude table definitions (as CREATE TABLE statements) and some rows of sample\ndata (as INSERT statements).\n\nGood luck!\n\nLoading...\n\nReply\n\n  * Michael\n\nSeptember 15, 2009 05:32\n\nI Agree with Hugo Kornelis\n\nLoading...\n\nReply\n\n  * techvslife\n\nFebruary 2, 2010 05:18\n\nSome concerns with or disadvantages of MERGE:\n\nBooks online says that MERGE \"may produce incorrect results\" if a cte is used\nto filter out rows from the source or target, so in that case you do not end\nup with an assurance that there hasn\u2019t been a mistake. To me, a lot harder on\nthe eyes than UPDATE/DELETE FROM if all you are doing is updating/deleting.\nAlso takes longer to write. There are other caveats with filter criteria\n(besides cte warning, shouldn\u2019t be done in the ON clause), which leaves the\nWHEN MATCHED clauses, sometimes inelegant, or, adding derived tables with\nselect & where clauses (or adding filters on the join clauses when no select).\nin contrast, update/delete from has a natural place for filter criteria, the\ntraditional WHERE after FROM clause. Of course merge is uniquely useful and\npowerful, & can do \"upserts\" etc., but that means it also has more subtle\nstructure and considerations overall (e.g. merge is one of the few times that\nBOL mentions anti semijoins)\u2013not a golden bullet that protects you from\nerrors. the syntax and structure is new, more of a break from older syntax\nthan one would guess at a quick glance. One could simply add the same runtime\nerror as MERGE has to UPDATE/DELETE FROM statements, with option to turn off\nor on (erland somm.\u2019s suggestion).\n\nLoading...\n\nReply\n\n  * Yasser\n\nNovember 13, 2010 09:41\n\nThank you, thank you and thank you very much.\n\nYou saved me from \"Msg 414, Level 16, State 1, Line 1\n\nUPDATE is not allowed because the statement updates view \"v1\" which\nparticipates in a join and has an INSTEAD OF UPDATE trigger.\"\n\nGood luck\n\nLoading...\n\nReply\n\n  * many codes\n\nJanuary 17, 2011 21:57\n\ntechvslife makes some very good points about MERGE, I think it is important to\nconsider them.\n\nLoading...\n\nReply\n\n  * RJ Samp\n\nApril 15, 2011 08:02\n\nWho said that any of the SQL Server 2008 new SQL stuff was any ANSI SQL\nStandard? MERGE INTO, please, since when is that \u2018standard\u2019?\n\n..... We\u2019ve been coding on SQL Server 6.5 through 2008 R2 AND......Oracle 7.3\nthrough XI using the SAME SQL CODE..... (we used to run the same code on\nBorland Interbase but that went the way of the DoDo bird...).\n\nfrom 1996 \u2013 yesterday.....or is that today.\n\nDon\u2019t even get me started on MINUS versus EXCEPTION.....\n\nLoading...\n\nReply\n\n  * JB\n\nJune 7, 2011 19:40\n\nI guess I am late to the party once again.\n\nInteresting article, thank you for the contribution, not sure that I agree\nwith the logic of depracating UPDATE FROM using standards as a rationale, but\nintersting ang good article.\n\nBTW the Merge clause in MySql does NOT provide the same functionality as the\nMerge clause in your argument. MySql merge is used to merge tables (go figure,\naye?)\n\nKind Thanks.\n\nJB\n\nLoading...\n\nReply\n\n  * Francesco\n\nNovember 17, 2011 17:25\n\nWhat about \"cloning\" records from the same table?\n\nLet\u2019s say we have a table \"dbo.THING\" like this:\n\n[ID], [VALUE]\n\n1, 100\n\n2, 200\n\n3, Null \u2013> This line could or could not exist.\n\n([ID] is the Primary Key)\n\nI have to copy values from ID 1 to ID 3. If id 3 exists, i have to UPDATE. If\nnot, i have to INSERT.\n\nIt seems a perfect candidate for MERGE:\n\nDeclare @OldId int, @NewId int\n\nSelect @OldId = 1, @NewId = 3\n\nMerge dbo.THING As Target\n\nUsing dbo.THING As Source\n\nOn (Source.[ID] = @OldId) And (Target.[ID] = @NewId)\n\nWhen Matched Then\n\nUpdate Set Target.[VALUE] = Source.[VALUE]\n\nWhen Not Matched Then\n\nInsert ([ID], [VALUE])\n\nValues (@NewId, Source.[VALUE]);\n\nBut it doesn\u2019t work. It never matches even if a row with ID 3 exists, and\ngives me a Primary Key violation.\n\nOr am I doing something wrong?\n\nAn \"Update From\" in this case would be straightforward.\n\nThank you\n\nLoading...\n\nReply\n\n  * Lukas Eder\n\nJanuary 11, 2012 15:11\n\nNice replacement of UPDATE .. FROM by MERGE. But beware, SQL Server heavily\nextends the SQL:2003 / SQL:2008 standard MERGE clause. You might run into\nproblems yet again, when you want to run your SQL on these databases taht\nsupport MERGE\n\nDB2 HSQLDB Oracle Sybase\n\nOr on any other ones (including MySQL, Postgres), that don\u2019t support MERGE\n\nLoading...\n\nReply\n\n  * Sergejack\n\nFebruary 28, 2012 17:29\n\nUpdate from is a clever feature.\n\nIt violates standards, does that means it sucks or that the standards do? We\nwould express ourself with \"Urgh!\", \"Mamoth?\" and \"Ouch!\" at best if standards\nweren\u2019t broken past some point.\n\nLoading...\n\nReply\n\n  * Abu- Safiyya\n\nMarch 4, 2012 13:10\n\nHello Hugo,\n\nthis very nice stuff thanks\n\nLoading...\n\nReply\n\n  * Kalman Toth\n\nApril 23, 2012 22:47\n\nHugo,\n\nI think UPDATE ... FROM originates from SYBASE.\n\nLoading...\n\nReply\n\n  * david\n\nDecember 26, 2012 13:48\n\nnice article\n\nLoading...\n\nReply\n\n  * Mladen\n\nApril 26, 2013 17:12\n\nHugo, you saved me lots of time, very nice, thank you\n\nLoading...\n\nReply\n\n  * Binh Thanh Nguyen\n\nJuly 30, 2014 03:18\n\nThanks, nice post\n\nLoading...\n\nReply\n\n  * Tony\n\nAugust 20, 2014 01:35\n\nHugo, Thanks, let more\n\nLoading...\n\nReply\n\n  * Bart\n\nNovember 13, 2014 09:41\n\nWhy is it not included in the \"standard\"?\n\nI have grown up with SQL Server technology (since 2001) and I was not aware\n(and shocked to hear) that an update on joined tables was not defined in the\nSQL standards.\n\nIt probably means that if I need to update data in a table with values based\non fields in other tables, that I need to use a subquery in the WHERE clause?\nThat moves this discussion to the use of subqueries vs. joins. Probably with\nthe same conclusion: the choice for subqueries or joins may depend on the\nspecific data structure and data population of the database. Sometimes a\nsubquery gives better performance, and sometimes a join does.\n\nI definitely want to keep the choice for using either subqueries or joins.\nYes, also in UPDATE statements. So I will definitely NOT follow SQL\n\"standards\".\n\nApart from that, I see no issues with NOT complying with SQL \"standards\".\n\nDuring my entire career, I have NEVER encountered a single project with end-\nuser requirements for supporting multiple DBMSes from the same business logic\n(except distributed heterogenous database layers, when two or more different\nDBMSes are used TOGETHER and have their own task for storing and serving\nSPECIFIC data). So I personally NEVER needed to strictly adhere to the SQL\n\"standards\".\n\nSo I am convinced that with real-life database application development, you\nwill just need to write multiple DBMS-vendorspecific data layer functionality\nwhen you need to support different DBMSes. In each distinct data layer\nimplementation, you will be able to use any standard or non-standard SQL\ncommands to manipulate your data.\n\nIMHO, this will simply stay this way until the SQL \"standard\" has matured\nenough (or until it has died a painful death). Just compare it with the\ndevelopment of HTML and CSS up to their current standard (HTML 5 and CSS 3)...\n\nCheers, and happy developing!\n\nLoading...\n\nReply\n\n  * Carlos Benito\n\nJuly 2, 2015 17:32\n\nand how about this error message:\n\nMsg 5315, Level 16, State 1, Line 19\n\nThe target of a MERGE statement cannot be a remote table, a remote view, or a\nview over remote tables.\n\nLoading...\n\nReply\n\n  * Why does UPDATE FROM fail and MERGE works on a View with an INSTEAD OF Trigger?\n\nSeptember 2, 2022 12:02\n\n[...] Let\u2019s deprecate UPDATE FROM! [...]\n\nLoading...\n\nReply\n\n  * \"Upsert\" trigger writing mass duplicates from SSIS\n\nSeptember 16, 2022 06:05\n\n[...] of this \u201cfeature\u201d and other issues it can cause, in Hugo Kornelis\u2019s blog\npost: Let\u2019s deprecate UPDATE FROM! and especially this [...]\n\nLoading...\n\nReply\n\n  * Is `Delete From Join` Standard SQL?\n\nJanuary 31, 2023 22:52\n\n[...] (though UPDATE FROM, and I imagine DELETE FROM in some scenarios, has\nproven unpredictable: https://sqlserverfast.com/blog/hugo/2008/03/lets-\ndeprecate-update-from/). Personally, I typically use CTEs for a lot of DELETE\noperations... but my development is [...]\n\nLoading...\n\nReply\n\n### Leave a ReplyCancel reply\n\nThis site uses Akismet to reduce spam. Learn how your comment data is\nprocessed.\n\n### Hugo Kornelis\n\nMarried, father of 2 children.\n\nAwarded 13x MVP (2006-2016; 2019-now), in the areas SQL Server and Data\nPlatform.\n\n### Subscribe via Email\n\n### Meta\n\n  * Log in\n  * Entries feed\n  * Comments feed\n  * WordPress.org\n\n### Archives\n\n  * February 2024 (2)\n  * January 2024 (3)\n  * December 2023 (4)\n  * November 2023 (2)\n  * October 2023 (1)\n  * September 2023 (1)\n  * August 2023 (1)\n  * July 2023 (3)\n  * June 2023 (4)\n  * May 2023 (4)\n  * April 2023 (2)\n  * March 2023 (1)\n  * February 2023 (1)\n  * January 2023 (1)\n  * December 2022 (2)\n  * November 2022 (1)\n  * October 2022 (2)\n  * September 2022 (5)\n  * June 2022 (1)\n  * May 2022 (3)\n  * March 2022 (1)\n  * February 2022 (2)\n  * October 2021 (1)\n  * August 2021 (1)\n  * July 2021 (1)\n  * June 2021 (1)\n  * May 2021 (4)\n  * April 2021 (5)\n  * March 2021 (1)\n  * February 2021 (2)\n  * January 2021 (2)\n  * December 2020 (2)\n  * November 2020 (1)\n  * October 2020 (2)\n  * September 2020 (3)\n  * August 2020 (3)\n  * July 2020 (2)\n  * June 2020 (3)\n  * May 2020 (7)\n  * April 2020 (3)\n  * February 2020 (1)\n  * May 2019 (1)\n  * April 2019 (1)\n  * February 2019 (3)\n  * January 2019 (3)\n  * December 2018 (2)\n  * November 2018 (1)\n  * September 2018 (2)\n  * August 2018 (2)\n  * July 2018 (4)\n  * June 2018 (1)\n  * May 2018 (3)\n  * April 2018 (3)\n  * March 2018 (3)\n  * February 2018 (3)\n  * January 2018 (1)\n  * December 2017 (2)\n  * September 2017 (1)\n  * November 2016 (1)\n  * October 2016 (1)\n  * September 2016 (1)\n  * August 2016 (1)\n  * June 2016 (1)\n  * November 2014 (1)\n  * October 2014 (2)\n  * July 2014 (2)\n  * June 2014 (2)\n  * April 2014 (1)\n  * March 2014 (1)\n  * January 2014 (3)\n  * December 2013 (1)\n  * November 2013 (1)\n  * October 2013 (1)\n  * June 2013 (2)\n  * January 2013 (1)\n  * October 2012 (2)\n  * August 2012 (2)\n  * June 2012 (1)\n  * May 2012 (4)\n  * April 2012 (2)\n  * February 2012 (1)\n  * December 2011 (1)\n  * November 2011 (1)\n  * October 2011 (3)\n  * October 2008 (2)\n  * August 2008 (2)\n  * March 2008 (1)\n  * February 2008 (1)\n  * January 2008 (1)\n  * December 2007 (1)\n  * November 2007 (3)\n  * October 2007 (2)\n  * September 2007 (3)\n  * July 2007 (3)\n  * June 2007 (2)\n  * May 2007 (1)\n  * March 2007 (2)\n  * January 2007 (1)\n  * December 2006 (1)\n  * November 2006 (1)\n  * October 2006 (1)\n  * September 2006 (3)\n  * August 2006 (1)\n  * July 2006 (3)\n\n\u00a9 Hugo Kornelis\n\n%d\n\nBy continuing to use the site, you agree to the use of cookies. more\ninformation\n\nThe cookie settings on this website are set to \"allow cookies\" to give you the\nbest browsing experience possible. If you continue to use this website without\nchanging your cookie settings or you click \"Accept\" below then you are\nconsenting to this.\n\nClose\n\n", "frontpage": false}
