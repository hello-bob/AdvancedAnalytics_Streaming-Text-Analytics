{"aid": "40132106", "title": "Why Nostr Login?", "url": "https://nostrlogin.org/", "domain": "nostrlogin.org", "votes": 4, "user": "fiatjaf", "posted_at": "2024-04-23 14:02:58", "comments": 0, "source_title": "Why Nostr Login?", "source_text": "Why Nostr Login? | Nostr Login\n\nSkip to the content.\n\n# Why Nostr Login?\n\n## Nostr is the new identity layer for the Web\n\nView on GitHub\n\n# Why Nostr Login?\n\nWere you looking for a cryptographic identity system for your app or website?\n\nNostr might be the answer!\n\nIt is quite simple.\n\nUsers generate a key pair.\n\nThe public key of the key pair is the globally unique user identifier.\n\nThe private key of the key pair is used to cryptographically sign properly\nformatted json messages called Nostr events.\n\nThat\u2019s enough for a global decentralized identity system.\n\nNostr keys can be used to log into your app, to get tamper-proof data signed\nby the user, to do encryption. You could also publish Nostr events on relays,\nbut that\u2019s a story for another day.\n\n## How does it work?\n\nNostr keys are usually stored in browser extensions or in specialized key\nstorage apps.\n\nThe simplest way for web apps to access Nostr keys in a browser is using the\nwindow.nostr JavaScript object. It is a standard interface for Nostr key\naccess, and has methods to get the user\u2019s public key, to sign Nostr events, to\nencrypt and decrypt data.\n\nThere are different providers of the window.nostr interface.\n\nUsers could install a browser extension, which would inject the window.nostr\nobject into all browser tabs. That\u2019s a convenient solution for existing Nostr\nusers, but it\u2019s quite hard to onboard new users into your app if you\u2019re\ninstructing them to install a browser extension...\n\nAnother way to access Nostr keys is Nostr Connect. It\u2019s a remote key access\nprotocol using Nostr relays to communicate with a key storage app, and it can\nbe used by both web and native apps. It also has OAuth-like flows specified\nfor login and sign up, which makes it a familiar way for users to provide\naccess to their identity.\n\nNostr Connect is not trivial to implement, but luckily - you don\u2019t have to.\nThere are several libraries you can use for remote key access. Some of those\nlibraries would even provide a window.nostr interface for you, and will\nforward your window.nostr calls to the remote key storage app.\n\n## How do I start?\n\nLet\u2019s start integrating Nostr into your web app.\n\nFirst, install one of the browser extensions for Nostr key storage (start with\nnos2x or Nostore). You\u2019ll be using it for testing.\n\nSecond, ask for the user\u2019s public key in your web app:\n\n    \n    \n    const publicKey = await window.nostr.getPublicKey();\n\nThat\u2019s it!\n\nNow you have an ID of the current user!\n\nYou could show personalized data for this ID, you could use it to show the\nuser profile, you could request various Nostr events related to this user from\nthe Nostr network.\n\nWell, actually that\u2019s a weak form of authentication, it doesn\u2019t verify that\nthe user owns the private key. User\u2019s window.nostr provider could be made to\nreturn anyone else\u2019s public key (those are public, right?).\n\nHowever, getPublicKey is still a useful and frictionless way to provide\npersonalization within your app. Many Nostr apps have read-only modes where\nyou can log in as anyone - how cool is that?!\n\nBut suppose read-only mode is not enough for us.\n\n## How to use Nostr keys?\n\nSuppose we need to be sure this user actually owns or has access to the\nprivate key corresponding to their public key.\n\nThe way to go is to get the user to actually sign some Nostr event. If they\nproduce a valid signature for the public key, then they are who they claim\nthey are.\n\n    \n    \n    const signedEvent = await window.nostr.signEvent({ kind: 12345, // event kind created_at: Math.floor(Date.now() / 1000), // event timestamp tags: [], // event tags content: '' // event content });\n\nBut what Nostr event should your app sign? What are those kind, tags and\ncontent fields for?\n\nWell, ideally you would design your app\u2019s data model around Nostr events.\nNostr events have kind, which is a number you would use to indicate the data\ntype. You would store the data that users produce in a form of signed Nostr\nevents, which would make it all tamper-proof. You could even store all that\ndata on the Nostr relays...\n\nThat would be an actual Nostr app. You\u2019d need to learn how the Nostr protocol\nworks, and learn to structure your data as Nostr events by studying existing\nevent kinds.\n\nHowever, you don\u2019t have to go that far.\n\n## How to do authentication for API calls?\n\nYou can simply use Nostr to authenticate the HTTP API calls your app is\nmaking.\n\nThere is a standard way to sign a special Nostr event for your HTTP request\nand include it as Authorization: Nostr ... header. Your server would verify\nthe signed event from the header, and would be sure the user is who they say\nthey are.\n\nCheck out the examples for the client and the server. TBD\n\n## How to authenticate using Nostr DMs?\n\nFor some apps it might be too hard to arrange a continuous access to Nostr\nkeys for users. For instance, if you\u2019re building a native app, you\u2019d either\nhave to implement Nostr Connect, which might be quite complex, or you would\njust ask users for their private key and learn how to handle it safely (hint:\ndon\u2019t do that!).\n\nIn this case you could use Nostr encrypted direct messages for authentication.\n\nAsk users for their public key (usually in the npub form), then send them a\nNostr DM with a one-time code. Users could use any Nostr app that supports DMs\nto read the one-time code. If they enter the correct code back into your app,\nyou can be sure they have access to the keys for the provided public key.\n\nYour implementation would probably involve a database table of public keys and\nthe matching one-time codes, with codes expiring after several minutes. You\nwill also need to generate Nostr keys for your app, store them on your server\nand use them to sign and encrypt the DMs with one-time codes. You\u2019ll also need\nto learn to talk to relays, and to discover relays that the target user is\nreading from...\n\nThis is not a trivial option, but sometimes there\u2019s just no better way.\n\n## What about the libraries?\n\nFirst, we recommend you to try nostr-login as the window.nostr provider. Just\nadd https://www.unpkg.com/nostr-login@latest/dist/unpkg.js script into your\nhtml page and get a powerful UI for various Nostr key access methods\n(extensions, Nostr Connect, read-only, account switching, etc). Another option\nis window.nostr.js.\n\nSecond, take a look at nostr-tools and NDK. The first one is a lower-level\ntool - verify signatures, generate keys, format events, talk to a relay, etc.\nThe second one is higher-level, with sophisticated relay communication logic,\nNostr Connect implementation, and other powerful tools.\n\nFor native apps, check out awesome-nostr or just run a github search for nostr\n+ your language. Thousands of tools are already out there, you\u2019ll certainly\nfind something useful for your particular needs.\n\n## Still have questions?\n\nSubmit an issue for this page, we will do our best to figure things out for\nyou. Or submit a PR if you have something to contribute.\n\nnostrlogin.org is maintained by nostrband. This page was generated by GitHub\nPages.\n\n", "frontpage": false}
