{"aid": "40113472", "title": "Show HN: Tactix: A Game of Tactics and Emojis", "url": "https://brianberns.github.io/Tactix/", "domain": "brianberns.github.io", "votes": 1, "user": "brianberns", "posted_at": "2024-04-22 11:55:29", "comments": 0, "source_title": "GitHub - dahlia/logtape: Simple logging library with zero dependencies for Deno/Node.js/Bun/browsers", "source_text": "GitHub - dahlia/logtape: Simple logging library with zero dependencies for\nDeno/Node.js/Bun/browsers\n\nSkip to content\n\nSign in\n\n# Search code, repositories, users, issues, pull requests...\n\nSearch syntax tips\n\nSign in\n\nSign up\n\nYou signed in with another tab or window. Reload to refresh your session. You\nsigned out in another tab or window. Reload to refresh your session. You\nswitched accounts on another tab or window. Reload to refresh your session.\nDismiss alert\n\ndahlia / logtape Public\n\n  * Notifications\n  * Fork 1\n  * Star 36\n\nSimple logging library with zero dependencies for Deno/Node.js/Bun/browsers\n\njsr.io/@logtape/logtape\n\n### License\n\nMIT license\n\n36 stars 1 fork Branches Tags Activity\n\nStar\n\nNotifications\n\n# dahlia/logtape\n\nThis commit does not belong to any branch on this repository, and may belong\nto a fork outside of the repository.\n\n3 Branches\n\n6 Tags\n\n## Folders and files\n\nName| Name| Last commit message| Last commit date  \n---|---|---|---  \n  \n## Latest commit\n\ndahliaVersion bumpApr 22, 2024d7a4de4 \u00b7 Apr 22, 2024Apr 22, 2024\n\n## History\n\n46 Commits  \n  \n### .github/workflows\n\n|\n\n### .github/workflows\n\n| npm packaging| Apr 16, 2024  \n  \n### .vscode\n\n|\n\n### .vscode\n\n| Run tests on CI| Apr 16, 2024  \n  \n### logtape\n\n|\n\n### logtape\n\n| Sink filter| Apr 21, 2024  \n  \n### screenshots\n\n|\n\n### screenshots\n\n| Screenshots| Apr 17, 2024  \n  \n### .gitignore\n\n|\n\n### .gitignore\n\n| npm packaging| Apr 16, 2024  \n  \n### CHANGES.md\n\n|\n\n### CHANGES.md\n\n| Version bump| Apr 22, 2024  \n  \n### LICENSE\n\n|\n\n### LICENSE\n\n| Initial commit| Apr 16, 2024  \n  \n### README.md\n\n|\n\n### README.md\n\n| Sink filter| Apr 21, 2024  \n  \n### deno.json\n\n|\n\n### deno.json\n\n| Version bump| Apr 22, 2024  \n  \n### dnt.ts\n\n|\n\n### dnt.ts\n\n| Adjust readme| Apr 19, 2024  \n  \n## Repository files navigation\n\n# LogTape\n\nNote\n\nLogTape is still in the early stage of development. The API is not stable yet.\nPlease be careful when using it in production.\n\nLogTape is a logging library for JavaScript and TypeScript. It provides a\nsimple and flexible logging system that is easy to use and easy to extend. The\nhighlights of LogTape are:\n\n  * Zero dependencies: LogTape has zero dependencies. You can use LogTape without worrying about the dependencies of LogTape.\n\n  * Library support: LogTape is designed to be used in libraries as well as applications. You can use LogTape in libraries to provide logging capabilities to users of the libraries.\n\n  * Runtime diversity: LogTape supports Deno, Node.js, Bun, edge functions, and browsers. You can use LogTape in various environments without changing the code.\n\n  * Structured logging: You can log messages with structured data.\n\n  * Hierarchical categories: LogTape uses a hierarchical category system to manage loggers. You can control the verbosity of log messages by setting the log level of loggers at different levels of the category hierarchy.\n\n  * Template literals: LogTape supports template literals for log messages. You can use template literals to log messages with placeholders and values.\n\n  * Dead simple sinks: You can easily add your own sinks to LogTape.\n\nCurrently, LogTape provides only few sinks, but you can easily add your own\nsinks.\n\n## Installation\n\n### Deno\n\n    \n    \n    deno add @logtape/logtape\n\n### Node.js\n\n    \n    \n    npm add @logtape/logtape\n\n### Bun\n\n    \n    \n    bun add @logtape/logtape\n\n## Quick start\n\nSet up LogTape in the entry point of your application (if you are composing a\nlibrary, you should not set up LogTape in the library itself; it is up to the\napplication to set up LogTape):\n\n    \n    \n    import { configure, getConsoleSink } from \"@logtape/logtape\"; await configure({ sinks: { console: getConsoleSink() }, filters: {}, loggers: [ { category: \"my-app\", level: \"debug\", sinks: [\"console\"] } ] });\n\nAnd then you can use LogTape in your application or library:\n\n    \n    \n    import { getLogger } from \"@logtape/logtape\"; const logger = getLogger([\"my-app\", \"my-module\"]); export function myFunc(value: number): void { logger.debug `Hello, ${value}!`; }\n\n## How to log\n\nThere are total 5 log levels: debug, info, warning, error, fatal (in the order\nof verbosity). You can log messages with the following syntax:\n\n    \n    \n    logger.debug `This is a debug message with ${value}.`; logger.info `This is an info message with ${value}.`; logger.warn `This is a warning message with ${value}.`; logger.error `This is an error message with ${value}.`; logger.fatal `This is a fatal message with ${value}.`;\n\nYou can also log messages with a function call. In this case, log messages are\nstructured data:\n\n    \n    \n    logger.debug(\"This is a debug message with {value}.\", { value }); logger.info(\"This is an info message with {value}.\", { value }); logger.warn(\"This is a warning message with {value}.\", { value }); logger.error(\"This is an error message with {value}.\", { value }); logger.fatal(\"This is a fatal message with {value}.\", { value });\n\nSometimes, values to be logged are expensive to compute. In such cases, you\ncan use a function to defer the computation so that it is only computed when\nthe log message is actually logged:\n\n    \n    \n    logger.debug(l => l`This is a debug message with ${computeValue()}.`); logger.debug(\"Or you can use a function call: {value}.\", () => { return { value: computeValue() }; });\n\n## Categories\n\nLogTape uses a hierarchical category system to manage loggers. A category is a\nlist of strings. For example, [\"my-app\", \"my-module\"] is a category.\n\nWhen you log a message, it is dispatched to all loggers whose categories are\nprefixes of the category of the logger. For example, if you log a message with\nthe category [\"my-app\", \"my-module\", \"my-submodule\"], it is dispatched to\nloggers whose categories are [\"my-app\", \"my-module\"] and [\"my-app\"].\n\nThis behavior allows you to control the verbosity of log messages by setting\nthe log level of loggers at different levels of the category hierarchy.\n\nHere's an example of setting log levels for different categories:\n\n    \n    \n    import { configure, getConsoleSink } from \"@logtape/logtape\"; await configure({ sinks: { console: getConsoleSink(), }, filters: {}, loggers: [ { category: [\"my-app\"], level: \"info\", sinks: [\"console\"] }, { category: [\"my-app\", \"my-module\"], level: \"debug\", sinks: [\"console\"] }, ], })\n\n## Sinks\n\nA sink is a destination of log messages. LogTape currently provides a few\nsinks: console and stream. However, you can easily add your own sinks. The\nsignature of a sink is:\n\n    \n    \n    export type Sink = (record: LogRecord) => void;\n\nHere's a simple example of a sink that writes log messages to console:\n\n    \n    \n    import { configure } from \"@logtape/logtape\"; await configure({ sinks: { console(record) { console.log(record.message); } }, // Omitted for brevity });\n\n### Console sink\n\nOf course, you don't have to implement your own console sink because LogTape\nprovides a console sink:\n\n    \n    \n    import { configure, getConsoleSink } from \"@logtape/logtape\"; await configure({ sinks: { console: getConsoleSink(), }, // Omitted for brevity });\n\nSee also getConsoleSink() function and ConsoleSinkOptions interface in the API\nreference for more details.\n\n### Stream sink\n\nAnother built-in sink is a stream sink. It writes log messages to a\nWritableStream. Here's an example of a stream sink that writes log messages to\nthe standard error:\n\n    \n    \n    // Deno: await configure({ sinks: { stream: getStreamSink(Deno.stderr.writable), }, // Omitted for brevity });\n    \n    \n    // Node.js: import stream from \"node:stream\"; await configure({ sinks: { stream: getStreamSink(stream.Writable.toWeb(process.stderr)), }, // Omitted for brevity });\n\nNote\n\nHere we use WritableStream from the Web Streams API. If you are using Node.js,\nyou cannot directly pass process.stderr to getStreamSink because\nprocess.stderr is not a WritableStream but a Writable, which is a Node.js\nstream. You can use Writable.toWeb() method to convert a Node.js stream to a\nWritableStream.\n\nSee also getStreamSink() function and StreamSinkOptions interface in the API\nreference for more details.\n\n### File sink\n\nNote\n\nFile sink is unavailable in the browser environment.\n\nLogTape provides a file sink as well. Here's an example of a file sink that\nwrites log messages to a file:\n\n    \n    \n    import { getFileSink } from \"@logtape/logtape\"; await configure({ sinks: { file: getFileSink(\"my-app.log\"), }, // Omitted for brevity });\n\nSee also getFileSink() function and FileSinkOptions interface in the API\nreference for more details.\n\nNote\n\nOn Deno, you need to have the --allow-write flag and the --unstable-fs flag to\nuse the file sink.\n\n### Rotating file sink\n\nNote\n\nRotating file sink is unavailable in the browser environment.\n\nA rotating file sink is a file sink that rotates log files. It creates a new\nlog file when the current log file reaches a certain size. Here's an example\nof a rotating file sink that writes log messages to a file:\n\n    \n    \n    import { getRotatingFileSink } from \"@logtape/logtape\"; await configure({ sinks: { file: getRotatingFileSink(\"my-app.log\", { maxFileSize: 1024 * 1024, // 1 MiB maxFiles: 5, }), }, // Omitted for brevity });\n\nRotated log files are named with a suffix like .1, .2, .3, and so on.\n\nFor more details, see getRotatingFileSink() function and\nRotatingFileSinkOptions interface in the API reference.\n\nNote\n\nOn Deno, you need to have the --allow-write flag and the --unstable-fs flag to\nuse the rotating file sink.\n\n### Text formatter\n\nA stream sink and a file sink write log messages in a plain text format. You\ncan customize the format by providing a text formatter. The type of a text\nformatter is:\n\n    \n    \n    export type TextFormatter = (record: LogRecord) => string;\n\nHere's an example of a text formatter that writes log messages in a JSON\nformat:\n\n    \n    \n    await configure({ sinks: { stream: getStreamSink(Deno.stderr.writable, { formatter(log) { return JSON.stringify(log) + \"\\n\", } }), }, // Omitted for brevity })\n\n### Disposable sink\n\nTip\n\nIf you are unfamiliar with the concept of disposables, see also the proposal\nof ECMAScript Explicit Resource Management.\n\nA disposable sink is a sink that can be disposed of. They are automatically\ndisposed of when the configuration is reset or the program exits. The type of\na disposable sink is: Sink & Disposable. You can create a disposable sink by\ndefining a [Symbol.dispose] method:\n\n    \n    \n    const disposableSink: Sink & Disposable = (record: LogRecord) => { console.log(record.message); }; disposableSink[Symbol.dispose] = () => { console.log(\"Disposed!\"); };\n\nA sync can be asynchronously disposed of as well. The type of an asynchronous\ndisposable sink is: Sink & AsyncDisposable. You can create an asynchronous\ndisposable sink by defining a [Symbol.asyncDispose] method:\n\n    \n    \n    const asyncDisposableSink: Sink & AsyncDisposable = (record: LogRecord) => { console.log(record.message); }; asyncDisposableSink[Symbol.asyncDispose] = async () => { console.log(\"Disposed!\"); };\n\n### Explicit disposal\n\nYou can explicitly dispose of a sink by calling the dispose() method. It is\nuseful when you want to flush the buffer of a sink without blocking returning\na response in edge functions. Here's an example of using the dispose() with\nctx.waitUntil() in Cloudflare Workers:\n\n    \n    \n    import { configure, dispose } from \"@logtape/logtape\"; export default { async fetch(request, env, ctx) { await configure({ /* ... */ }); // ... ctx.waitUntil(dispose()); } }\n\n## Filters\n\nA filter is a function that filters log messages. A filter takes a log record\nand returns a boolean value. If the filter returns true, the log record is\npassed to the sinks; otherwise, the log record is discarded. Its signature is:\n\n    \n    \n    export type Filter = (record: LogRecord) => boolean;\n\nFor example, the following filter discards log messages whose property elapsed\nis less than 100 milliseconds:\n\n    \n    \n    import { configure, type LogRecord } from \"@logtape/logtape\"; await configure({ // Omitted for brevity filters: { tooSlow(record: LogRecord) { return \"elapsed\" in record.properties && record.properties.elapsed >= 100; }, }, loggers: [ { category: [\"my-app\", \"database\"], level: \"debug\", sinks: [\"console\"], filters: [\"tooSlow\"], } ] });\n\n### Level filter\n\nLogTape provides a built-in level filter. You can use the level filter to\nfilter log messages by their log levels. The level filter factory takes a\nLogLevel string and returns a level filter. For example, the following level\nfilter discards log messages whose log level is less than info:\n\n    \n    \n    import { getLevelFilter } from \"@logtape/logtape\"; await configure({ filters: { infoOrHigher: getLevelFilter(\"info\"); }, // Omitted for brevity });\n\n### Sink filter\n\nA sink filter is a filter that is applied to a specific sink. You can add a\nsink filter to a sink by decorating the sink with withFilter():\n\n    \n    \n    import { getConsoleSink, withFilter } from \"@logtape/logtape\"; await configure({ sinks: { filteredConsole: withFilter( getConsoleSink(), log => \"elapsed\" in log.properties && log.properties.elapsed >= 100, ), }, // Omitted for brevity });\n\nThe filteredConsoleSink only logs messages whose property elapsed is greater\nthan or equal to 100 milliseconds to the console.\n\nTip\n\nThe withFilter() function can take a LogLevel string as the second argument.\nIn this case, the log messages whose log level is less than the specified log\nlevel are discarded.\n\n## Testing\n\nHere are some tips for testing your application or library with LogTape.\n\n### Reset configuration\n\nYou can reset the configuration of LogTape to its initial state. This is\nuseful when you want to reset the configuration between tests. For example,\nthe following code shows how to reset the configuration after a test\n(regardless of whether the test passes or fails) in Deno:\n\n    \n    \n    import { configure, reset } from \"@logtape/logtape\"; Deno.test(\"my test\", async (t) => { await t.step(\"set up\", async () => { await configure({ /* ... */ }); }); await t.step(\"run test\", () => { // Run the test }); await t.step(\"tear down\", async () => { await reset(); }); });\n\n### Buffer sink\n\nFor testing purposes, you may want to collect log messages in memory. Although\nLogTape does not provide a built-in buffer sink, you can easily implement it:\n\n    \n    \n    import { type LogRecord, configure } from \"@logtape/logtape\"; const buffer: LogRecord[] = []; await configure({ sinks: { buffer: buffer.push.bind(buffer), }, // Omitted for brevity });\n\n## About\n\nSimple logging library with zero dependencies for Deno/Node.js/Bun/browsers\n\njsr.io/@logtape/logtape\n\n### Topics\n\nnodejs javascript typescript logging bun deno\n\n### Resources\n\nReadme\n\n### License\n\nMIT license\n\nActivity\n\n### Stars\n\n36 stars\n\n### Watchers\n\n1 watching\n\n### Forks\n\n1 fork\n\nReport repository\n\n## Releases\n\n6 tags\n\n## Packages 0\n\nNo packages published\n\n## Languages\n\n  * TypeScript 100.0%\n\n## Footer\n\n\u00a9 2024 GitHub, Inc.\n\nYou can\u2019t perform that action at this time.\n\n", "frontpage": false}
