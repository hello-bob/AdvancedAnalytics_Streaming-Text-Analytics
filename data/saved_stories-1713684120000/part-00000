{"aid": "40102487", "title": "Target_clones Is a Trap", "url": "https://zeux.io/2024/04/20/target-clones-trap/", "domain": "zeux.io", "votes": 1, "user": "ibobev", "posted_at": "2024-04-21 01:19:37", "comments": 0, "source_title": "target_clones is a trap", "source_text": "zeux.io - target_clones is a trap\n\nBits, pixels, cycles and more\n\nArseny Kapoulkine (email, , )\n\n#### Author\n\nArseny Kapoulkine (email, , )\n\nWork, projects and publications\n\n#### Posts\n\nIf you like this blog, you should follow it via RSS and read older posts. Here\nare the recent posts:\n\n  * target_clones is a trap\n  * Meshlet triangle locality matters\n  * Condvars and atomics do not mix\n  * LLM inference speed of light\n  * It is time\n  * Efficient jagged arrays\n  * Fine-grained backface culling\n  * Meshlet size tradeoffs\n  * Approximate projected bounds\n  * VPEXPANDB on NEON with Z3\n\n\u00ab Meshlet triangle locality matters  \n---  \n  \n# target_clones is a trap\n\n20 Apr 2024\n\nIn Luau, modulo operator a % b is defined as a - floor(a / b) * b, the\ndefinition inherited from Lua 5.1. While it has some numeric issues, like\nbehavior for b = inf, it\u2019s decently fast to compute so we have not explored\nalternatives yet.\n\nThat is, it would be decently fast to compute if floor was fast.\n\n> This post is much shorter than usual, and it was originally written in 2022\n> and published on Cohost. I\u2019m going to experiment with posting shorter\n> technical content like this more regularly in the coming months, including\n> reposting my earlier Cohost posts (of which this is one of).\n\nFor example, on A64 the codegen for the relevant C function is short and\nsweet, and the function is trivially inlineable:\n\n    \n    \n    luai_nummod(double, double): fdiv d2, d0, d1 frintm d2, d2 fmsub d0, d2, d1, d0 ret\n\nUnfortunately, on Intel architectures this isn\u2019t as simple. When compiling the\nnative C source code with -msse4.1 command line switch, the codegen is also\nsimple but it uses roundsd instruction that requires SSE4.1 to function: an\ninstruction set that debuted 15 years ago and yet you can\u2019t rely on it being\npresent still.\n\n    \n    \n    luai_nummod(double, double): movapd xmm2, xmm0 divsd xmm2, xmm1 roundsd xmm2, xmm2, 9 mulsd xmm1, xmm2 subsd xmm0, xmm1 ret\n\nWithout SSE4.1, MSVC can be coerced to generate a lengthy inline SSE2 sequence\nwith fast math pragmas, but clang insists on calling the libc function which\nhas a substantial penalty^1.\n\nIdeally what we want is to synthesize two versions of the function, one with\nSSE4.1 and one with SSE2, and have the compiler call the right one\nautomatically based on the hardware we\u2019re targeting at build time or are\nrunning at compile time. Fortunately, gcc 6.0 (2016) introduced a target_clone\nattribute precisely for this purpose. You can simply add the following\nattribute to our function:\n\n    \n    \n    __attribute__((target_clones(\"default\", \"sse4.1\")))\n\nand the compiler will generate two versions of the function itself, and a\nhelper \u201cresolver\u201d function (see GNU indirect function (ifunc) mechanism) that\nis ran at process startup, computes the function pointer we\u2019re going to use,\nand stores the result in procedure linkage table (PLT) which is used to call\nthe function via indirect calls.\n\nPerfect - so we just add the attribute for gcc/clang and we\u2019re done!\n\n... well.\n\nWhile the attribute was implemented in gcc6 in 2016, and clang does have an\nimplementation for that attribute, clang only supports it starting from clang\n14 (released in 2022, and as such might not be your production compiler yet).\n\nAdditionally, in clang 14 there seems to be a problem that prevents use of\nthis attribute on inline functions, as multiple resolvers are generated and\nthey aren\u2019t correctly marked with flags for linker to merge them. This is\noften not a problem but it is a problem in this case - for targets like\nAArch64 that don\u2019t need the dispatch to begin with, or for x64 with SSE4.1\nused as a compilation target, we\u2019d like the resulting function to be\ninlinable. The issue seems to be fixed in clang 15.\n\nWhat\u2019s more, this feature is really less of a gcc feature and more of a glibc\nfeature. When glibc is not available, this feature doesn\u2019t seem to exist -\nthis notably includes macOS. While by default clang on macOS enables SSE4.1\nthese days, when targeting earlier versions of macOS using -mmacosx-version-\nmin=10.11, SSE4.1 code generation gets disabled by default^2.\n\nOf course, even on Linux this can be a problem. Some distributions, like\nAlpine Linux, use musl libc and the toolchain there doesn\u2019t support ifunc and\nas a consequence target_clones doesn\u2019t work either^3.\n\n> Now would be a great time to mention that ifunc was one of the mechanisms\n> used in the recent - as of 2024 when this was reposted, not as of 2022 when\n> this was written! - xz backdoor... Something tells me ifunc is not coming to\n> musl based distributions any time soon.\n\nSo yes, the target_clones attribute exists, and it solves the problem pretty\nelegantly... when it is supported, which, even 6 years after it was introduced\nin gcc, still is \u201cpretty rarely\u201d. It\u2019s unfortunate that SIMD in C is full of\nportability problems like this - for a language that prides itself in\nunlocking the maximum performance, actually reaching that performance can be\nrather painful.\n\nIn 2023, we ended up solving the efficiency problem without using\ntarget_clones via manual CPUID dispatch to set up a function pointer in cases\nwhere SSE4.1-friendly computations were part of builtin functions, a mechanism\nthat deserves a separate post eventually.\n\n  1. gcc can generate the inline SSE2 version with -ffast-math but that switch is unsafe to enable globally, so absent a way to enable it just for one function we\u2019re still out of luck. \u21a9\n\n  2. This is intentional as OSX 10.11 still supports iMacs released in 2007, that have Core 2 Duo (T7700) CPU - these support up to SSSE3, but roundsd is from SSE4.1. \u21a9\n\n  3. It\u2019s not fully clear to me which components of the system on Alpine really present the problem - this ostensibly should be a linker feature, not a libc feature, but I digress. \u21a9\n\n\u00ab Meshlet triangle locality matters  \n---  \n  \nShow Comments\n\n", "frontpage": false}
