{"aid": "40055726", "title": "Tillitis Security Bulletin 240115-1", "url": "https://bugbounty.tillitis.se/security-bulletins/tillitis-security-bulletin-240115-1/", "domain": "tillitis.se", "votes": 2, "user": "JoachimS", "posted_at": "2024-04-16 18:47:08", "comments": 0, "source_title": "Tillitis Security Bulletin 240115-1 \u2013 Tillitis Bug Bounty Program", "source_text": "Tillitis Security Bulletin 240115-1 \u2013 Tillitis Bug Bounty Program\n\n  * About\n  * Contact\n\n  * Bounty\n  * Security Bulletins\n  * Threat Model\n  * Hall of Fame\n  * tillitis.se\n\n  * Bounty\n  * Security Bulletins\n  * Threat Model\n  * Hall of Fame\n  * tillitis.se\n\nBuy\n\n  * About\n  * Contact\n\n# Tillitis Security Bulletin 240115-1\n\n## Summary\n\nSeverity: Low.\n\nA vulnerability has been found in tkey-device-signer and verisigner that makes\nit possible to disclose portions of the TKey\u2019s data in RAM over the USB\ninterface. To exploit the vulnerability an attacker needs to use a custom\nclient application and to touch the TKey.\n\nThe threat model defines a set of assets, attack types and threat actors. This\nvulnerability analysis shows that the attack is of software type and,\n\n  * a threat actor can read portions of RAM content, but no sensitive assets, from a device that runs tkey-device-signer or verisigner that have been compiled by Tillitis.\n  * a skilled threat actor* could potentially read out asset information from a device that runs tkey-device-signer or verisigner that have been compiled by other parties and generates a different SHA512 digest, see reproducible builds below.\n\n*type 1, 2 or 3 as defined in the threat model.\n\n## User action\n\nTillitis recommends:\n\n  * Update any client application* that uses verisigner to tkey-device-signer version 1.0.0. verisigner is being deprecated.\n  * Update any client application* that uses tkey-device-signer to version 1.0.0.\n  * If you are building tkey-device-signer from source code, Tillitis recommends using the provided OCI image.\n\n*Custom client applications using tkey-device-signer are also recommended to be updated.\n\nNote: Updating the device application changes the identity, meaning that the\nEd25519 key pair also changes. All services using your current identity need\nto be updated with the new identity. See this guide.\n\n## Affected applications\n\nAll client applications running tkey-device-signer version 0.0.7 and 0.0.8.\nFrom Tillitis this includes:\n\n  * tkey-ssh-agent v0.0.6 and earlier embedding tkey-device-signer v0.0.7\n  * tkey-sign-cli v0.0.8 embedding tkey-device-signer v0.0.8\n\nAll client applications running verisigner v0.0.3 and earlier. From Tillitis\nthis includes:\n\n  * tkey-verification v0.0.2. embedding verisigner v0.0.3.\n\n## Patching\n\nThe following release contain security updates that address the vulnerability\ndescribed in this bulletin:\n\n  * tkey-device-signer, v1.0.0\n\nThe following client applications are updated to embed tkey-device-signer\nv1.0.0:\n\n  * tkey-ssh-agent, v1.0.0\n  * tkey-sign-cli, v1.0.0\n  * tkey-verification, v1.0.0 (see GitHub repository for release status)\n\nFor user compiled applications, see section Reproducible builds below.\n\nNote: verisigner is going to be deprecated in favor of using tkey-device-\nsigner v1.0.0 in the forthcoming tkey-verification v1.0.0.\n\n## Technical details\n\nThe vulnerability is of type CWE-367: Time-of-check Time-of-use (TOCTOU). If\nthis is exploited it allows for a CWE-125: Out-of-bounds Read.\n\nAn exploit is made by setting an increasingly larger size of the message to\nsign (using CMD_SET_SIZE) and relying on the TOCTOU bug to get additional data\nin the message.\n\nFirst the message size is set to 4096 bytes (maximum size), then immediately a\nnew message size of 4097 bytes is set. The device app will return an error but\nstill use the new size (4097). Another variable that keeps track of what is\nleft to be sent by the client keeps the old value (4096).\n\nWhen 4096 bytes of data is sent from client to TKey, this creates a signature\nof the sent data plus the extra byte in memory according to the new message\nsize (4097). Repeating this method again, but using a size of 4098 bytes, will\ninclude yet another byte of RAM in the signature. This is continued with 4099,\n4100, ...\n\nThe signature returned is computed over an unknown byte every time. One can\niterate over every possible value of the last byte (brute forcing) and do a\nsignature verification. When the signature verifies correctly the unknown byte\nis revealed.\n\nEventually the signing operation\u2019s own memory is part of the message to sign.\nThe message itself will change during the signing operation, making it much\nharder and probably impossible to produce verifiable signatures over a known\nmessage. This stops the exploit.\n\n### The signing context stops the exploit\n\nThere are a few interesting assets in RAM:\n\n  1. The message, since this is the start of the data included in the signature.\n  2. The private key.\n  3. The context of the signing operation.\n\nThe locations in memory are:\n\nVersion| location of message| location of private key| location of signing\ncontext  \n---|---|---|---  \n0.0.7, verisigner-v0.0.3| message = 0x4001ec20| local_cdi = 0x4001ebc0| ctx =\n0x4001fd40  \n0.0.8| message = 0x4001ee98| secret_key = 0x4001edf8| r = 0x4001ebe0*  \n*location of the variable r , which is part of the signing context.\n\nThe memory visualized for v0.0.7 and verisigner-0.0.3:\n\n    \n    \n    --------------------------- <--- 0x40020000 | STACK | | .. | | Signing context | <--- An exploit stops here | .. | | message \u2191 | <--- start of exploit, grows | .. | towards higher addresses | | | Private key | | .. | | - - - - - - - - - - - - | | .. | | | | Unused area, | | randomized at power up | | | | .. | | - - - - - - - - - - - - | | APP | --------------------------- <--- 0x40000000\n\nThe memory visualized for v0.0.8:\n\n    \n    \n    --------------------------- <--- 0x40020000 | STACK | | .. | | message \u2191 | <--- start of exploit, grows | .. | towards higher addresses | | | Private key | | .. | | Signing context | <--- An exploit stops here | .. | | - - - - - - - - - - - - | | .. | | | | Unused area, | | randomized at power up | | | | .. | | - - - - - - - - - - - - | | APP | <--- Wraps and continue to read upwards --------------------------- <--- 0x40000000\n\nThe message buffer contains the data to be signed and grows towards higher\naddresses, so the out-of-bounds read occur on addresses above the message\nbuffer\u2019s end. In order to include the private key in the signing operation,\nall the previous content in RAM needs to be leaked first.\n\nThe signing context is located in between the message and the private key for\nall versions, v0.0.7, v0.0.8, and verisigner-v0.0.3. The difference in v0.0.8\nis the need to wrap around and continue to read from the start of RAM. The\npossibility to wrap around and continue to read from the beginning of RAM is\nan unwanted behavior in the FPGA design. This is addressed in release\nTK1-2024.03.\n\nThe location of the signing context on the stack is crucial for stopping an\nexploit. The signing context is used by the Ed25519 signing operation to store\nintermediate calculations. In order to leak it you have to include the signing\ncontext as part of the message being signed. However, during the signing the\nmessage is used in two separate hash operations. Since the execution is in\nseries this means that the context, which is included in the message to be\nsigned, will change between these two function calls. This makes it impossible\nto create a valid signature over a known message.\n\nThe implementations differ, but the same operations are performed. The details\nbelow are from v0.0.8, but the same general idea applies for v0.0.7 and\nverisigner-v0.0.3.\n\nWhen generating a signature the function call looks like this:\n\n    \n    \n    static void ed25519_dom_sign(u8 signature [64], const u8 secret_key[32], const u8 *dom, size_t dom_size, const u8 *message, size_t message_size) { u8 a[64]; // secret scalar and prefix u8 r[32]; // secret deterministic \"random\" nonce u8 h[32]; // publically verifiable hash of the message (not wiped) u8 R[32]; // first half of the signature (allows overlapping inputs) const u8 *pk = secret_key + 32; crypto_sha512(a, secret_key, 32); crypto_eddsa_trim_scalar(a, a); hash_reduce(r, dom, dom_size, a + 32, 32, message, message_size, 0, 0); crypto_eddsa_scalarbase(R, r); hash_reduce(h, dom, dom_size, R, 32, pk, 32, message, message_size); COPY(signature, R, 32); crypto_eddsa_mul_add(signature + 32, h, a, r); WIPE_BUFFER(a); WIPE_BUFFER(r); }\n\nThe interesting section in this function is:\n\n    \n    \n    hash_reduce(r, dom, dom_size, a + 32, 32, message, message_size, 0, 0); crypto_eddsa_scalarbase(R, r); hash_reduce(h, dom, dom_size, R, 32, pk, 32, message, message_size);\n\nThe message, which is a pointer to a location on the stack, is used twice in\norder to calculate the signature. The variable r, which is of type u8 r[32],\nstores the return value of hash_reduce() on the stack. This gives that, when\nthe context is included in the message to be signed, the content of message\nwill change before the next function call of hash_reduce(). Also note that a,\nwhich is used in the first hash_reduce(), is derived from the secret key so r\ncannot be considered guessable or known.\n\n### Reproducible builds\n\nThe exploit is effectively stopped by the order of the data on the stack. C\ncompilers don\u2019t provide any guarantee for how the data is ordered, and can be\nvastly different depending on compiler, compiler version, and compiler\noptimization level.\n\nTillitis have reproducible builds and verification of both tkey-device-signer\nand verisigner in place, so the analysis above covers binaries built with\nother compiler versions as long as they have the same SHA512 digests. The\ndigests are included in the repositories. The recommended way of building is\nto use the OCI image, tkey-builder, with the right version for the device\napplication\u2019s tag. See the device applications\u2019 documentation in the\nrepositories for more information.\n\n## Timeline\n\n  * January 15, 2024 \u2013 Tillitis receives the report through security@tillitis.se\n  * January 17, 2024 \u2013 Confirmed that an out-of-bounds read is possible.\n  * January 29, 2024 \u2013 Confirmed that this also affects verisigner in tkey-verification.\n  * March 25, 2024 \u2013 Released new version of hardware design with hardware RAM wraparound protection, TK1-24.03.\n  * April 16, 2024 \u2013 Released new versions of tkey-device-signer, including the TOCTOU fix and hardening with explicit protocol state machine, as well as official client apps using tkey-device-signer.\n\n## Credits\n\nWe would like to thank the security researcher Sergei Volokitin of Hexplot,\nwho discovered the vulnerability and reported it through our bug bounty\nprogram.\n\n## Change log\n\n2024-04-16 17:00 CEST: Initial publication\n\nTillitis AB Ekelundsgatan 4 411 18 G\u00f6teborg Sweden\n\nhello@tillitis.se\n\nJoin one of our mailinglists\n\n  * #tillitis:matrix.org\n  * #tillitis @ OFTC\n  * tillitisab\n  * tillitis-ab/\n  * tillitis\n  * tillitis\n\n", "frontpage": false}
