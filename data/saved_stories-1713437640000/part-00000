{"aid": "40073077", "title": "Use Cases for Merging, Splitting Partitions with Minimal Locking in PostgreSQL17", "url": "http://andyatkinson.com/blog/2024/04/16/postgresql-17-merge-split-partitions", "domain": "andyatkinson.com", "votes": 1, "user": "thunderbong", "posted_at": "2024-04-18 04:52:51", "comments": 0, "source_title": "\u2702\ufe0f Use Cases for Merging and Splitting Partitions With Minimal Locking in PostgreSQL 17", "source_text": "\u2702\ufe0f Use Cases for Merging and Splitting Partitions With Minimal Locking in PostgreSQL 17 | Andrew Atkinson\n\n# Andrew Atkinson\n\nSoftware Engineer\n\nApril 16, 2024\n\n# \u2702\ufe0f Use Cases for Merging and Splitting Partitions With Minimal Locking in\nPostgreSQL 17\n\nPostgreSQL Open Source\n\nThis post looks at some interesting new capabilities managing Partitioned\nTables coming in PostgreSQL 17, expected for release Fall 2024. The current\nmajor version is 16.\n\n## Current Table Partition Commands\n\nPrior to Version 17, workflow options for partition management are limited to\ncreating, attaching, and detaching partitions.\n\nOnce we\u2019ve designed our partition structure, we couldn\u2019t redesign it in place.\n\nThis applies to all partition types, whether we\u2019re using RANGE, LIST, or HASH.\n\nTo combine multiple partitions into a single one, or to \u201csubdivide\u201d a single\npartition into multiples, we\u2019d need to design a new structure then migrate all\ndata rows to it. That\u2019s a lot of steps!\n\n## What\u2019s New?\n\nFrom version 17, we have more options. We can now perform a SPLIT PARTITION\noperation on an existing singular partition, into two or more new ones.\n\nIf we wish to do the reverse, we\u2019ve got that option as well. Starting from two\nor more partitions, we can perform a MERGE PARTITIONS (plural) operation to\ncombine them into one.\n\nAn aside: don\u2019t confuse this with the upsert-like SQL MERGE command which uses\nthe same \u201cmerge\u201d verb (oof)!\n\nThe new DDL commands are:\n\n  * MERGE PARTITIONS\n  * SPLIT PARTITION\n\nHere are tweets from Nori Shinoda that link to PostgreSQL git commits:\n\n  * Ability to merge two existing partitions: https://twitter.com/nori_shinoda/status/1776841440167121057\n  * Ability to split a partition into two or more: https://twitter.com/nori_shinoda/status/1776865005704499331\n\nLet\u2019s test the new commands out and think about use cases for them.\n\nWe\u2019ll need a way to run pre-release PostgreSQL 17. Fortunately, I\u2019ve recently\ncompiled PostgreSQL from source code on my macOS laptop, and will use that\ninstance and some test tables within the default postgres DB.\n\nI use Postgres.app to run PostgreSQL 16 for most of my local development, and\ninstances on different ports. I stop the instance on port 5432 so I can start\nup the one based on the compiled source code like this:\n\n    \n    \n    /usr/local/pgsql/bin/pg_ctl \\ -D /usr/local/pgsql/data \\ -l logfile \\ start waiting for server to start.... done server started\n\n## Terminology Notes\n\nPreviously I wrote about table partitioning in a two-part post. Here\u2019s the\nfirst post: PostgreSQL Table Partitioning \u2014 Growing the Practice \u2014 Part 1 of 2\nif you\u2019d like a refresher on general information.\n\nI\u2019ll use \u201cchildren\u201d below referring to \u201cpartitions\u201d of a partitioned table.\nThe top-most table has the partition constraints, and tables that correspond\nto those constraints are added as \u201cchildren\u201d.\n\nThe term \u201cchildren\u201d can also show up when discussing foreign keys, when\nforeign key columns refer to the primary key of another table. The table with\na foreign key can be said to be a child table.\n\nFor this post, \u201cchildren\u201d refers solely to partitions \u201cof\u201d (the PARTITION OF\nsyntax below) a parent table.\n\n## What do these look like?\n\nImagine we had a multi-tenant application where tenants are identified as\n\u201caccounts.\u201d Tables with mixed account data have an account_id column with a\nvalue that identifies their account, meaning we can partition on it using LIST\npartitioning.\n\nWe\u2019d normally have one account per customer. However, in my real-world working\nexperience at startup companies, this isn\u2019t always the case.\n\nAt a past employer with a B2B SaaS, an account was created to demo to a\ncustomer prospect.\n\nWhen the customer joined the platform many months later, a new account was\ncreated for them, creating a situation where they had primary data under two\naccounts. There were also primary key conflicts, so we couldn\u2019t easily combine\nthe data without some manual efforts, but that\u2019s a different story.\n\nIf this table had been created as a partitioned table with LIST partitioning,\nwe could identify all rows by their account_id, and each would have its own\npartition.\n\nOn PostgreSQL 17 in that scenario, we could leverage MERGE PARTITIONS to\ncombine those partitions that we would to group under one account, choosing\none or the other.\n\nWhat would that look like?\n\n## Merging Partitions\n\nThe table below has an account_id and no real data columns, since we\u2019re just\nlooking to demo the partition management aspect.\n\nThe id uses a generated sequence value, which means each row will have a\nunique value across partitions.\n\n    \n    \n    CREATE TABLE t ( id INT GENERATED ALWAYS AS IDENTITY, account_id INT NOT NULL ) PARTITION BY LIST (account_id);\n\nImagine we have the following two partitions for account_id 1 and account_id\n2.\n\n    \n    \n    CREATE TABLE t_account_1 PARTITION OF t FOR VALUES IN (1); CREATE TABLE t_account_2 PARTITION OF t FOR VALUES IN (2);\n\nLet\u2019s insert 10 records for account_id 1, and 100 records for account_id 2. We\nhave 110 records total, but they\u2019re split across two partitions. We want to\nmerge these together.\n\n    \n    \n    INSERT INTO t (account_id) SELECT 1 FROM GENERATE_SERIES(1,10); INSERT INTO t (account_id) SELECT 2 FROM GENERATE_SERIES(1,100);\n\nNow we want to merge them together using MERGE PARTITIONS:\n\n    \n    \n    ALTER TABLE t MERGE PARTITIONS (t_account_1, t_account_2) INTO t_account_1_2;\n\nCool. That combined t_account_1 and t_account_1 into a single partition called\nt_account_1_2 with 110 records.\n\nWhat about splitting partitions? How does that work?\n\n## Splitting Partitions\n\nWe\u2019ve seen how to merge partitions. We can also split partitions using the new\nSPLIT PARTITIONS command.\n\nFor this example let\u2019s use the RANGE partitioning type.\n\nImagine that we had decided to create partitions for one week\u2019s worth of data\nfor an \u201cevents\u201d style table that receives a lot of records. We\u2019ll call the\ntable t_events below.\n\nWe\u2019ve decided with a one week boundary, the tables are large and unwieldy.\nWe\u2019d like to move to daily partitions so that the table for a day\u2019s worth of\ndata is smaller and more manageable.\n\nLet\u2019s look at the SQL commands for how we might achieve that.\n\n## Split Partitions Events Table\n\nCreate the t_events table using the RANGE partitioning type, initially with\nweekly partitions to demonstrate the current configuration.\n\n    \n    \n    CREATE TABLE t_events ( id INT GENERATED ALWAYS AS IDENTITY, event_at TIMESTAMP WITHOUT TIME ZONE NOT NULL ) PARTITION BY RANGE (event_at);\n\nHere are partitions for \u201clast week,\u201d \u201cthis week,\u201d and \u201cnext week.\u201d\n\n    \n    \n    CREATE TABLE t_events_last_week PARTITION OF t_events FOR VALUES FROM ('2024-04-08 00:00:00') TO ('2024-04-15 00:00:00'); CREATE TABLE t_events_this_week PARTITION OF t_events FOR VALUES FROM ('2024-04-15 00:00:00') TO ('2024-04-22 00:00:00'); CREATE TABLE t_events_next_week PARTITION OF t_events FOR VALUES FROM ('2024-04-22 00:00:00') TO ('2024-04-29 00:00:00');\n\nNow we\u2019d like to take \u201cnext week\u2019s partition\u201d called t_events_next_week, and\ndivide it into 7 daily partitions, one for each day.\n\nSince it\u2019s an upcoming week, we\u2019ll assume it has no data in it, but is a pre-\ncreated partition.\n\nWhen designing your own change like this, keep in mind the resulting\nboundaries you come up with must have equivalent start and end boundaries to\nthe current configuration.\n\nIf the boundaries are off, you\u2019ll get an error like this:\n\n    \n    \n    ERROR: partition bound for relation \"t_events_next_week\" is null\n\nHere\u2019s the SPLIT PARTITION DDL command to split the single week command, into\n7 daily partitions:\n\n    \n    \n    ALTER TABLE t_events SPLIT PARTITION t_events_next_week INTO ( PARTITION t_events_day_1 FOR VALUES FROM ('2024-04-22 00:00:00') TO ('2024-04-23 00:00:00'), PARTITION t_events_day_2 FOR VALUES FROM ('2024-04-23 00:00:00') TO ('2024-04-24 00:00:00'), PARTITION t_events_day_3 FOR VALUES FROM ('2024-04-24 00:00:00') TO ('2024-04-25 00:00:00'), PARTITION t_events_day_4 FOR VALUES FROM ('2024-04-25 00:00:00') TO ('2024-04-26 00:00:00'), PARTITION t_events_day_5 FOR VALUES FROM ('2024-04-26 00:00:00') TO ('2024-04-27 00:00:00'), PARTITION t_events_day_6 FOR VALUES FROM ('2024-04-27 00:00:00') TO ('2024-04-28 00:00:00'), PARTITION t_events_day_7 FOR VALUES FROM ('2024-04-28 00:00:00') TO ('2024-04-29 00:00:00') );\n\nNice. If we run \\d+ t_events to describe t_events, we\u2019ll see the two remaining\nweekly partitions, and the new 7 daily partitions.\n\nThere\u2019s a catch. Performing this operation requires a lock on the parent\ntable, which could be a long lock.\n\nIs there a workaround?\n\n## Detach, Split, Reattach\n\nAs long as the structure of the table stays the same, partitions can be\ndetached and reattached.\n\nThose operations can both be performed in a non-blocking way by using\nCONCURRENTLY.\n\nUnfortunately we can\u2019t perform a SPLIT PARTITION CONCURRENTLY, which would\nmake this even more convenient because we wouldn\u2019t be worried about blocking\nwrites while the exclusive lock was in effect. Perhaps we\u2019ll get that in a\nfuture version of PostgreSQL.\n\nLet\u2019s consider a workaround. We know that we can detach partitions, split them\nwhile detached, then re-attach them. Would that work?\n\nThis is a lot of operations, and requires a \u201cnew fake parent\u201d (my own name\nbelow) to work, so these steps should be considered more a proof of concept,\nnot a recommendation. The goal is to avoid a potentially long lock blocking\nwrites, by allowing the lock to occur on a detached table hierarchy.\nEssentially \u201coffline.\u201d\n\nThis was my idea when I first saw these new capabilities and the required\naccess exclusive lock they acquire:\n\n> MERGE PARTITIONS is cool! But exclusive lock on parent is limiting.\n> Workaround idea: concurrent detachment of two, then merge, then \u201creattach\n> concurrently\u201d on consolidated partition? cc @andrewkane @keithf4 @brandur\n> @nori_shinoda https://t.co/fF9nJEL9ip\n>\n> \u2014 Andrew Atkinson (@andatki) April 7, 2024\n\nTrying to run SPLIT PARTITION on a detached partition with no parent doesn\u2019t\nwork. However, we can add a \u201cnew fake parent\u201d table to stand-in temporarily.\n\nHere\u2019s the detach operation:\n\n    \n    \n    ALTER TABLE t_events DETACH PARTITION t_events_next_week CONCURRENTLY;\n\nHere\u2019s the \u201cfake\u201d stand-in parent table definition. Once we\u2019ve created this,\nwe need to attach our detached partitions to it in order to perform the split.\n\nWe\u2019ll only use the \u201cfake parent\u201d table for the split operation. When that\u2019s\ndone, we\u2019ll detach the partitions again, and then re-attach them to the\noriginal parent CONCURRENTLY. At that point we can drop the \u201cfake\u201d parent.\n\n    \n    \n    CREATE TABLE t_events_fake_new ( id INT GENERATED ALWAYS AS IDENTITY, event_at TIMESTAMP WITHOUT TIME ZONE NOT NULL ) PARTITION BY RANGE (event_at);\n\nRunning the SPLIT PARTITION on a separate parent avoids a long lock on the\noriginal parent, since it\u2019s a completely separate table.\n\n    \n    \n    ALTER TABLE t_events_fake_new SPLIT PARTITION t_events_next_week INTO ( PARTITION t_events_day_1 FOR VALUES FROM ('2024-04-22 00:00:00') TO ('2024-04-23 00:00:00'), PARTITION t_events_day_2 FOR VALUES FROM ('2024-04-23 00:00:00') TO ('2024-04-24 00:00:00'), PARTITION t_events_day_3 FOR VALUES FROM ('2024-04-24 00:00:00') TO ('2024-04-25 00:00:00'), PARTITION t_events_day_4 FOR VALUES FROM ('2024-04-25 00:00:00') TO ('2024-04-26 00:00:00'), PARTITION t_events_day_5 FOR VALUES FROM ('2024-04-26 00:00:00') TO ('2024-04-27 00:00:00'), PARTITION t_events_day_6 FOR VALUES FROM ('2024-04-27 00:00:00') TO ('2024-04-28 00:00:00'), PARTITION t_events_day_7 FOR VALUES FROM ('2024-04-28 00:00:00') TO ('2024-04-29 00:00:00') );\n\nSince the table structures have not changed, and since we\u2019re not introducing\nany overlapping partition constraints, we can reattach to the original parent.\n\n## Alternatives\n\nWhat about simply creating new partitions to move data rows into?\n\nWhile it might be less work to create new partitions and move data rows, we\ncouldn\u2019t introduce new partitions that overlap with the boundaries/constraints\nof any existing one. PostgreSQL enforces this and would prevent the partition\ncreation.\n\nTo avoid the overlap limitation, SPLIT PARTITION seems necessary when our goal\nis to modify a structure in-place like this.\n\nHowever, in a similar way to the workaround above, we could follow the same\ntactic and detach the overlapping partition to work around the conflict.\n\nWith that approach, we might achieve the same end result and not need the\nSPLIT PARTITION command.\n\nWhat are your thoughts?\n\n## Resources and Thank You\n\nHere are some people to thank, and more resources on these new commands to\ncheck out.\n\n  * Nori Shinoda for posting the latest and greatest from PostgreSQL source code\n  * PostgreSQL 17: Split and Merge partitions by Daniel Westermann\n  * Creston Jamison for covering the split and merge partition commands in Scaling Postgres #311\n\nI\u2019m curious to see how merging and splitting partitions commands get used in\nthe wild.\n\nIn the future, if we can perform these operations CONCURRENTLY, they will be\neven more useful. The introduction of these features may be a step towards\nmodifying an unpartitioned table in place.\n\nHaving something like SPLIT TABLE CONCURRENTLY would be very nice for tables\nthat weren\u2019t originally partitioned, became huge, and to lessen the work\nneeded to migrate their data into more manageable partitions.\n\nShare: Twitter Facebook\n\n## Comments\n\n### High Performance PostgreSQL for Rails\n\n#### Reliable, Scalable, Maintainable Database Applications\n\n> As a senior Rails dev, it's rare to find a book that challenges and excites\n> me like this one did.\n\n\\- Andrew M.\n\n\ud83d\udc49 Now available\n\n## Read Next\n\nApril 15, 2024\n\n### \ud83c\udf99\ufe0f Hacking Postgres \ud83d\udc18 Podcast - Season 2, Ep. 1 - Andrew Atkinson\n\nPodcast Postgresql Open source Ruby on rails\n\n## Tags\n\nAPI Books CLI Conferences Databases DevOps Events Git Go Hardware Java\nJavaScript Lean Startup MySQL OS X Objective-C Open Source Performance Podcast\nPostgreSQL Productivity Programming Rails Redis RegExp Remote Work Ruby Ruby\non Rails SQL Scripts Tips Tools Vim conferences iOS podcast\n\nAndrew Atkinson \u00a9 2006-2024. Royce theme by JustGoodThemes. Powered by Jekyll.\nHosted on GitHub Pages.\n\nBack to top\n\n", "frontpage": false}
