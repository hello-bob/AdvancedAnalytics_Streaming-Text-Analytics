{"aid": "40156508", "title": "Direct-Style Effects Explained", "url": "https://www.inner-product.com/posts/direct-style-effects/", "domain": "inner-product.com", "votes": 1, "user": "thunderbong", "posted_at": "2024-04-25 12:11:28", "comments": 0, "source_title": "Direct-style Effects Explained", "source_text": "Direct-style Effects Explained\n\n# Direct-style Effects Explained\n\nBy Noel Welsh on 24 Apr 2024\n\n#### Direct-style effects, also known as algebraic effects and effect\nhandlers, are the next big thing in programming languages. At the same time I\nsee some confusion about direct-style effects. In this post I want to address\nthis confusion by explaining the what, the why, and the how of direct-style\neffects using a Scala 3 implementation as an example.\n\nDirect-style effects, also known as algebraic effects and effect handlers, are\nthe next big thing in programming languages. They are already available in\nUnison and OCaml, are coming to Scala, and I\u2019m seeing discussion about them in\nother closely-related-to-industry contexts.\n\nThe goal is very simple: to allow us to write code in a natural style without\nmonads, but still get the benefits of reasoning and composition that monads\nbring. At the same time I see some confusion about direct-style effects. In\nthis post I want to address this confusion by explaining the what, the why,\nand the how of direct-style effects using a Scala 3 implementation as an\nexample.\n\nThere is quite a bit going on here. First we\u2019ll talk about the problem we\u2019re\ntrying to solve and the constraints we\u2019re operating under. Then we\u2019ll look at\na simple implementation in Scala 3 and describe the language feature,\ncontextual functions, that enables it. Next up we\u2019ll see some shortcomings of\nthis implementation and see how they can solved by two language features, one\nwell known (delimited continuations) and one in development (type system\ninnovations). Finally I\u2019ll give some pointers to more about information on\nthis topic.\n\n## What We Care About\n\nWhen we argue for one programming style over alternatives we are making a\nvalue judgement about programming. It is helpful to be explicit about what\nthose values are. As I\u2019ve written elsewhere, I believe the core values of\nfunctional programming are reasoning and composition. Side effects stop us\nachieving both of these, but every useful program must interact with the world\nin some way. (If you\u2019re uncertain what is meant by a side effect, this chapter\nof Creative Scala goes into detail.) Therefore, replacing side effects with\nsomething in keeping with these core principles is considered an important\nproblem in functional programming. Solutions to this problem are called effect\nsystems.\n\nNota bene: in this post I use the term side effect for uncontrolled effects,\nand just effect for effects that are controlled in a more desirable way.\n\nMonads are the most common effect system in modern functional programming, but\nthis doesn\u2019t mean they are the only approach. Older versions of Haskell used\nstreams. The Clean language uses uniqueness types, which are very closely\nrelated to the affine types seen in Rust\u2019s borrow checker. Most current\nresearch work focuses on what are called algebraic effects and effect\nhandlers. It\u2019s this kind of approach we will be exploring, though we have some\nbackground to get through first.\n\nNow we known why effect systems are interesting, let\u2019s look at some of the\ndesign choices in effect systems.\n\n## The Design Space of Effect Systems\n\nReasoning and composition are non-negotiable criteria for any effect system.\nThere are other criteria that are desirable, however. Here we will look at the\nstyle in which code is written, the separation between description and action,\nand some of the nuances in how effect systems can help us reason about and\ncompose effectful code.\n\n### Direct and Monadic Style\n\nThe style of code that we have to write to use the effect system is a major\ndeterminant of how usable the system is. If an effect system requires too much\nwork from the programmer it is unusable in practice, no matter what other\nproperties it has. Here we will look at direct style, which is code as we want\nto write it, and monadic style, which is code as monadic effect systems force\nus to write it.\n\nDirect style code is code as it is usually written. You call functions, they\nreturn results, and you use those results in further computations. Here\u2019s the\nkind of code we write in direct style.\n\n    \n    \n    val a: A = ??? val b = doSomething(a) val c = doSomething2(b) val d = doSomething3(c)\n\nWe don\u2019t need to say much about direct style, other than that it is desirable\nto write in this style.\n\nAs most Scala programmers will have experienced, we must write code in a\ndifferent style if we are to use monads. In monadic style the code above ends\nup looking something like\n\n    \n    \n    doSomething(a) .flatMap(b => doSomething(b)) .flatMap(c => doSomething(c))\n\nThis is considered annoying enough that languages that support monads usually\nprovide special syntax for them. In Scala we can write\n\n    \n    \n    for { b <- doSomething(a) c <- doSomething(b) d <- doSomething(c) } yield d\n\nThis isn\u2019t too bad. Lots of developers have written code like this. However,\nit\u2019s still a different style of coding that has been learned, and hence a\nbarrier to entry. It\u2019s also a whole program transform. Once one part of our\ncode start using monads, it is usually the case that all of our code has to be\ntransformed to monadic style. So ideally an alternative effect system would\nallow us to continue to write in direct style.\n\n### Description and Action\n\nAny effect system must have a separation between describing the effects that\nshould occur, and actually carrying out those effects. This is a requirement\nof composition. Consider perhaps the simplest effect in any programming\nlanguage: printing to the console. In Scala we can accomplish this as a side\neffect with println:\n\n    \n    \n    println(\"OMG, it's an effect\")\n\nImagine we want to compose the effect of printing to the console with the\neffect that changes the color of the text on the console. With the println\nside effect we cannot do this. Once we call println the output is already\nprinted; there is no opportunity to change the color.\n\nLet me be clear that the goal is composition. We can certainly use two side\neffects that happen to occur in the correct order to get the output with the\ncolor we want.\n\n    \n    \n    println(\"\\u001b[91m\") // Color code for bright red text println(\"OMG, it's an effect\")\n\nHowever this is not the same thing as composing an effect that combines these\ntwo effects. For example, the example above doesn\u2019t reset the foreground color\nso all subsequent output will be bright red. This is the classic problem of\nside effects: they have \u201caction at a distance\u201d meaning one part of the program\ncan change the meaning of another part of the program. This in turns means we\ncannot reason locally, nor can we build programs in a compositional way.\n\nWhat we really want is to write code like\n\n    \n    \n    Effect.println(\"OMG, it's an effect\").foregroundBrightRed\n\nwhich limits the foreground colour to just the given text. We can only do if\nwe have a separation between describing the effect, as we have done above, and\nactually running it.\n\n### Reasoning and Composing with Effects\n\nEffect systems should help us reason about what code does. Take for example,\nthe following method signature:\n\n    \n    \n    def cthulhuFhtagn(): Unit\n\nWhat happens when we call this method? Returning Unit suggests it has some\nside-effect, but what is that side-effect? It could print to the console,\nraise an exception, or wake a Great Old One to destroy the Earth. We cannot\ntell.\n\nUsing the IO monad is similar. If we instead see the method signature\n\n    \n    \n    def cthulhuFhtagn(): IO[Unit]\n\nwe again don\u2019t know what effects will occur but we do have some way to\nmanipulate those effects. We can attempt to cancel the effects, for example,\nby writing\n\n    \n    \n    IO.canceled *> cthulhuFhtagn()\n\nor instead recover from errors using handleError.\n\nIt\u2019s important to note that we can do this manipulation of effects in a\ncomposable way. For instance, we can pass the IO to some other method that\nchooses how to manipulate it.\n\n    \n    \n    def cancelOrRecover(effect: IO[Unit]): IO[Unit] = // Continue only if the stars are right IO.realTimeInstant .map(time => starsAreRight(time)) .ifM( true = effect.handleError(...), false = IO.cancel *> effect )\n    \n    cancelOrRecover(cthulhuFhtagn())\n\nWe cannot do this in the first case that uses side-effects.\n\nBefore we get into effect systems, there another issue I want to quickly deal\nwith, which is composition of effects. One criticism of IO is that it lumps\nall effects into one type. We might want to be more precise, and say, for\nexample, this method requires logging and database access, while that method\nreads from the keyboard and prints to the screen. Monad transformers are one\nway to achieve this, but they are difficult to use. A more common alternative\nis tagless final. The method signature\n\n    \n    \n    def cthulhuFhtagn[F[_]: WakeGreatOldOne](): F[Unit]\n\nindicates this method requires a WakeGreatOldOne effect, which we might use to\ndecide to not call the method. Tagless final is also inconvenient, but not so\ninconvenient to stop it becoming relatively common in the Scala world.\n\n## Direct-style Effect Systems in Scala 3\n\nLet\u2019s now implement a direct-style effect system in Scala 3. This requires\nsome machinery that is new in Scala 3. Since that\u2019s probably unfamiliar to\nmany readers we\u2019re going to start with an example, explain the programming\ntechniques behind it, and then explain the concepts it embodies.\n\nOur example is a simple effect system for printing to the console. The\nimplementation is below. You can save this in a file (called, say,\nPrint.scala) and run it with scala-cli with the command scala-cli Print.scala.\n\n    \n    \n    //> using scala 3\n    \n    // For convenience, so we don't have to write Console.type everywhere. type Console = Console.type\n    \n    type Print[A] = Console ?=> A extension [A](print: Print[A]) {\n    \n    /** Insert a prefix before `print` */ def prefix(first: Print[Unit]): Print[A] = Print { first print }\n    \n    /** Use red foreground color when printing */ def red: Print[A] = Print { Print.print(Console.RED) val result = print Print.print(Console.RESET) result } } object Print { def print(msg: Any)(using c: Console): Unit = c.print(msg)\n    \n    def println(msg: Any)(using c: Console): Unit = c.println(msg)\n    \n    def run[A](print: Print[A]): A = { given c: Console = Console print }\n    \n    /** Constructor for `Print` values */ inline def apply[A](inline body: Console ?=> A): Print[A] = body }\n    \n    @main def go(): Unit = { // Declare some `Prints` val message: Print[Unit] = Print.println(\"Hello from direct-style land!\")\n    \n    // Composition val red: Print[Unit] = Print.println(\"Amazing!\").prefix(Print.print(\"> \").red)\n    \n    // Make some output Print.run(message) Print.run(red) }\n\nA Print[A] is a description: a program that when run may print to the console\nand also compute a value of type A. It is implemented as a context function.\nYou can think of a context function as a normal function with given (implicit)\nparameters. In our case a Print[A] is a context function with a Console given\nparameter. (Console is a type in the Scala standard library.)\n\nContext function types have a special rule that makes constructing them\neasier: a normal expression will be converted to an expression that produces a\ncontext function if the type of the expression is a context function. Let\u2019s\nunpack that by seeing how it works in practice. In the example above we have\nthe line\n\n    \n    \n    val message: Print[Unit] = Print.println(\"Hello from direct-style land!\")\n\nPrint.println is an expression with type Unit, not a context function type.\nHowever Print[Unit] is a context function type. This type annotation causes\nPrint.println to be converted to a context function type. You can check this\nyourself by removing the type annotation:\n\n    \n    \n    val message = Print.println(\"Hello from direct-style land!\")\n\nThis will not compile.\n\nWe use the same trick with Print.apply, which is a general purpose\nconstructor. You can call apply with any expression and it will be converted\nto a context function. (As far as I know it is not essential to use inline,\nbut all the examples I learned from do this so I do it as well. I assume it is\nan optimization.)\n\nRunning a Print[A] uses another bit of special sauce: if there is given value\nof the correct type in scope of a context function, that given value will be\nautomatically applied to the function. This is also what makes direct-style\ncomposition, an example of which is shown below, work. The calls to\nPrint.print are in a context where a Console is available, and so will be\nevaluated once the surrounding context function is run.\n\n    \n    \n    def red: Print[A] = Print { Print.print(Console.RED) val result = print Print.print(Console.RESET) result }\n\nThat\u2019s the mechanics of how direct-style effect systems work in Scala: it all\ncomes down to context functions.\n\nNotice what we have in these examples: we write code in the natural direct\nstyle, but we still have an informative type, Print[A], that helps us reason\nabout effects and we can compose together values of type Print[A].\n\nI\u2019m going to deal with composition of different effects and more in just a\nbit. First though, I want describe the concepts behind what we\u2019ve done.\n\nNotice in direct-style effects we split effects into two parts: context\nfunctions that define the effects we need, and the actual implementation of\nthose effects. In the literature these are called algebraic effects and effect\nhandlers respectively. This is an important difference from IO, where the same\ntype indicates the need for effects and provides the implementation of those\neffects.\n\nAlso notice that we use the argument type of context functions to indicate the\neffects we need, rather the result type as in monadic effects. This difference\navoids the \u201ccolored function\u201d problem with monads. We can think of the\narguments as specifying requirements on the environment or context in which\nthe context functions, hence the name.\n\nNow let\u2019s look at composition of effects, and effects that modify control\nflow.\n\n### Composition of Direct-Style Effects\n\nDirect-style effects compose in a straightforward way: we just add additional\nparameters to our context function. Here\u2019s a simple example that defines\nanother effect, Sample, for producing random values, and then builds a program\nthat requires both Print and Sample.\n\nFirst we define the effect, using the same pattern as before.\n\n    \n    \n    import scala.util.Random\n    \n    // A `Sample[A]` is a description of an effect that, when run, will generate a // values of type `A` possibly using a random number generator type Sample[A] = Random ?=> A object Sample { // This runs a `Sample[A]` producing a value of type `A`. By default it uses // the global random number generator, but the user can pass in a different // generator as the first argument. def run[A](sample: Sample[A])(using random: Random = scala.util.Random): A = { given r: Random = random sample }\n    \n    // Utility to use inside a `Sample[A]` to produce a random `Int` def int(using r: Random): Int = r.nextInt()\n    \n    // Utility to use inside a `Sample[A]` to produce a random `Double` def double(using r: Random): Double = r.nextDouble()\n    \n    // Constructs a `Sample[A]`. inline def apply[A](inline body: Random ?=> A): Sample[A] = body }\n\nNow we can use both Print and Sample.\n\n    \n    \n    val printSample: (Console, Random) ?=> Unit = Print { val i = Sample { Sample.int } Print.println(i) }\n    \n    Print.run(Sample.run(printSample))\n\n### Effects That Change Control Flow\n\nSo far, the effects we\u2019ve looked at have very simple control flow. In fact\nthey don\u2019t alter the control flow at all. Many interesting effects, such as\nerror handling and concurrency, require manipulation of the program\u2019s control\nflow. How do we handle this in our model?\n\nWe need a slight extension to accomodate this: when the user program calls an\neffect handler method, the effect handler is passed not just that method\u2019s\narguments but also also a continuation that it can resume when the effect is\ncomplete. What\u2019s a continuation? It represents the \u201crest of the program\u201d: a\nvalue that can be invoked to continue execution from the point that called the\neffect handler. Cooperative threads, fibers, generators, and coroutines are\nall examples of abstractions that use a form of continuations.\n\nContinuations can be implemented as a program transform, but for performance\nwe ideally want runtime support. This is why Scala Native is getting\ncontinuations. On the JVM, Project Loom adds them.\n\nScala 3 does not yet expose a continuation API, but it does have non-local\nexits in scala.util.boundary that can express a few interesting things. Here\u2019s\nan example implementing error-handling in the style of exceptions.\n\n    \n    \n    //> using scala 3\n    \n    import scala.util.boundary import scala.util.boundary.{break, Label}\n    \n    final class Error[-A](using label: Label[A]) { def raise(error: A): Nothing = break(error) }\n    \n    type Raise[A] = Error[A] ?=> A object Raise { inline def apply[A](inline body: Error[A] ?=> A): Raise[A] = body\n    \n    def raise[A](error: A)(using e: Error[A]): Nothing = e.raise(error)\n    \n    def run[A](raise: Raise[A]): A = { boundary[A] { given error: Error[A] = new Error[A] raise } } }\n    \n    @main def go(): Unit = { val program: Raise[String] = Raise { // This early return is difficult to write in a purely functional style List(1, 2, 3, 4) .foreach(x => if x == 3 then Raise.raise(\"Found 3\")) \"No 3 found\" }\n    \n    val result = Raise.run(program) println(result) }\n\nNotice that we still have the separation between description and action. The\nprogram isn\u2019t run until we call Raise.run, and the control-flow exits at the\npoint where it is run, not at the point where it is defined.\n\nUsing direct-style effects we can write programs that would have to use\ntraverse or other combinators in monadic style. Here\u2019s an example that\nproduces an Option[List[Int]] from a List[Int].\n\n    \n    \n    val traverse: Raise[Option[List[Int]]] = Raise { Some( List(1, 2, 3, 4).map(x => if x == 3 then Raise.raise(None) else x) ) } println(Raise.run(traverse))\n\nThis is the equivalent of the following program using Cats:\n\n    \n    \n    val traverseCats: Option[List[Int]] = List(1, 2, 3, 4).traverse(x => if x == 3 then None else Some(x))\n\nYou might wonder how monads implement effects that play with control flow\nwithout requiring runtime support. The answer is that monads require the user\nto explicitly specify the control-flow. This is exactly what flatMap does: it\nexpresses what should happen in what order, and by giving the monad this\ninformation as a chain of flatMaps it can evaluate them in the order that\nmakes sense for the particular monad implementation. In fact monads are\nequivalent to delimited continuations. So direct-style effects and monad\neffects can be seen as just two different syntaxes for writing the same thing.\n\n## Capturing, Types, and Effects\n\nWhat we\u2019ve seen so far suggests that effects are straightforward to implement\nand use, and they are for the most part. However there is at least one wrinkle\nthat we need to be aware of: capturing effects.\n\nIn the following code we capture a Error[String] in a closure, and then\nattempt to call the raise method on that Error outside of the block where it\nis valid. This leads to a runtime exception.\n\n    \n    \n    val capture: Raise[() => String] = Raise { error ?=> () => if 3 < 2 then \"Nothing to see here\" else Raise.raise(() => \"Hahahahaha!\")(using error) }\n    \n    val closure = Raise.run(capture) println(closure())\n\nIs this a serious flaw in the entire foundation of direct-style effects? No!\nWhat we\u2019ve seen so far is only the portion of the effect system that is\ncurrently in Scala 3. Capture checking, which is still experimental, rules out\nthis kind of bug. The Capturing Types paper has all the technical details.\n\nCapture checking in fact goes further than the examples we\u2019ve seen so far. It\ntracks capability usage in the dynamic scope of the program. It can be used to\nimplement composition of different effects. We saw an example earlier where we\nconstructed a context function with type (Console, Random) ?=> Unit. You might\nhave given this type a bit of side-eye as it doesn\u2019t use the type aliases we\nused for the two effects on their own (Print and Sample.) With capture\nchecking the type system works out these types for us. It can also be use for\nresource checking, such as ensuring all open files are closed or that region-\nbased memory management is implemented without leaks.\n\n## Conclusions and Further Reading\n\nWe\u2019ve seen that direct-style effect allow us to write code in a natural direct\nstyle, while still retaining useful types that help with reasoning and\nallowing composition of effects. The implementation is a combination of:\n\n  1. context functions;\n  2. continuations; and\n  3. type system improvements\n\nwhich together allow us to express effects in direct-style as operations on\neffect handlers.\n\nOverall, I\u2019m pretty excited by direct-style effects in general, and direct-\nstyle effects in Scala in particular. I think they are much more ergonomic\nthan monadic effects, which in turn makes them accessible to a wider range of\nprogrammers. I\u2019m also excited to have access to continuations, and presumably\ntail calls, in more languages. Tail calls are really useful for certain\nproblems, such as virtual machine dispatch.\n\nI\u2019m also excited to see Scala continuing to evolve. Scala has always been a\nlanguage of innovation, and these changes are nothing more than a continuation\n(pun-intended) of that heritage. I\u2019m also excited to see more investment in\nScala Native. I think it\u2019s only in Scala Native that the developers will have\nthe flexibility to implement the runtime support needed for a full effect\nsystem, and also to really maximise its advantages by providing things like\nregion based memory management. I also think Scala Native is important for\nScala\u2019s industrial adoption in use cases like serverless, so I see more\ninvestment in Scala Native as a big win for the community.\n\nIf you\u2019d like to read more about direct-style effects here are some\nsuggestions, which are a mix of accessible introductions and academic papers:\n\n  * Abilities for the monadically inclined, a very nice post from the Unison team that covers a lot of the same material from a different perspective.\n  * Dean Wampler\u2019s post What is \u201cDirect Style\u201d.\n  * The Gears concurrency library being developed for Scala 3.\n  * Raise4s, a simple example of error handling as a direct-style effect.\n  * An Introduction to Algebraic Effects and Handlers is a tutorial from a more theoretic perspective.\n  * Handlers in Action is one of the more readable academic papers on implementing effect handlers.\n  * Capturing Types describes the extensions to the Scala type system that are necessary for correctly implementing effects.\n\nFinally, if you\u2019ve found this interesting I think you\u2019ll love my book,\nFunctional Programming Strategies. It covers lots of the concepts in this\npost, such as continuation-passing style and interpreters, and a whole lot\nmore.\n\n### Like what you are reading?\n\nSign up to our newsletter to get regular updates.\n\n### Ready to Start?\n\nDo you have a project that could use some help? Get in touch and we can get\nstarted right away.\n\nSend us an email Give us a call\n\nServices Writing Events Contact\n\nhello@inner-product.com +1 (206) 905-9033 @InnerProductLLC\n\n\u00a9 2021 Inner Product LLC\n\n", "frontpage": false}
