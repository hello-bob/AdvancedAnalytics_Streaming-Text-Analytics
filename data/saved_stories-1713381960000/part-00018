{"aid": "40063137", "title": "Show HN: Desbordante 2.0", "url": "https://github.com/Desbordante/desbordante-core", "domain": "github.com/desbordante", "votes": 6, "user": "chernishev", "posted_at": "2024-04-17 11:36:54", "comments": 2, "source_title": "GitHub - Desbordante/desbordante-core: Desbordante is a high-performance data profiler that is capable of discovering many different patterns in data using various algorithms. It also allows to run data cleaning scenarios using these algorithms. Desbordante has a console version and an easy-to-use web application.", "source_text": "GitHub - Desbordante/desbordante-core: Desbordante is a high-performance data\nprofiler that is capable of discovering many different patterns in data using\nvarious algorithms. It also allows to run data cleaning scenarios using these\nalgorithms. Desbordante has a console version and an easy-to-use web\napplication.\n\nSkip to content\n\nSign in\n\n# Search code, repositories, users, issues, pull requests...\n\nSearch syntax tips\n\nSign in\n\nSign up\n\nYou signed in with another tab or window. Reload to refresh your session. You\nsigned out in another tab or window. Reload to refresh your session. You\nswitched accounts on another tab or window. Reload to refresh your session.\nDismiss alert\n\nDesbordante / desbordante-core Public\n\n  * Notifications\n  * Fork 50\n  * Star 62\n\nDesbordante is a high-performance data profiler that is capable of discovering\nmany different patterns in data using various algorithms. It also allows to\nrun data cleaning scenarios using these algorithms. Desbordante has a console\nversion and an easy-to-use web application.\n\n### License\n\nAGPL-3.0 license\n\n62 stars 50 forks Branches Tags Activity\n\nStar\n\nNotifications\n\n# Desbordante/desbordante-core\n\nThis commit does not belong to any branch on this repository, and may belong\nto a fork outside of the repository.\n\n14 Branches\n\n5 Tags\n\n## Folders and files\n\nName| Name| Last commit message| Last commit date  \n---|---|---|---  \n  \n## Latest commit\n\npolyntsovUpdate desbordante version to 2.0.0Apr 16, 202424d5d46 \u00b7 Apr 16,\n2024Apr 16, 2024\n\n## History\n\n1,164 Commits  \n  \n### .github\n\n|\n\n### .github\n\n| Remove paths-ignore from core tests workflow| Mar 11, 2024  \n  \n### cfg\n\n|\n\n### cfg\n\n| Issue #23 - set up logging via easylogging| Feb 12, 2022  \n  \n### cli\n\n|\n\n### cli\n\n| Update desbordante version to 2.0.0| Apr 16, 2024  \n  \n### datasets\n\n|\n\n### datasets\n\n| Make input_data directory before unzipping datasets| Jul 30, 2023  \n  \n### docs/papers\n\n|\n\n### docs/papers\n\n| chore: add g3 paper| Apr 2, 2024  \n  \n### examples\n\n|\n\n### examples\n\n| Add CLI, bindings and example for CFD discovery| Apr 15, 2024  \n  \n### images\n\n|\n\n### images\n\n| Upgrade README with image preview| May 24, 2022  \n  \n### src\n\n|\n\n### src\n\n| Manage ColumnLayoutRelationData with a separate class| Apr 15, 2024  \n  \n### test_input_data\n\n|\n\n### test_input_data\n\n| Add tests for Order| Mar 31, 2024  \n  \n### .clang-format\n\n|\n\n### .clang-format\n\n| Update clang-format version and add new rules| Dec 18, 2023  \n  \n### .clang-tidy\n\n|\n\n### .clang-tidy\n\n| Add rule readability-identifier-naming to .clang-tidy| Mar 23, 2024  \n  \n### .gitattributes\n\n|\n\n### .gitattributes\n\n| Track datasets.zip by git lfs| Feb 22, 2022  \n  \n### .gitignore\n\n|\n\n### .gitignore\n\n| Add venv in .gitignore| Mar 22, 2024  \n  \n### CMakeLists.txt\n\n|\n\n### CMakeLists.txt\n\n| Make -march=native optional| Feb 15, 2024  \n  \n### COPYING\n\n|\n\n### COPYING\n\n| Switch license to Affero GPL| Jul 11, 2022  \n  \n### README.md\n\n|\n\n### README.md\n\n| Update README.md| Apr 16, 2024  \n  \n### README_PYPI.md\n\n|\n\n### README_PYPI.md\n\n| Update README.md| Apr 16, 2024  \n  \n### build.bat\n\n|\n\n### build.bat\n\n| one last script fix| Jun 5, 2020  \n  \n### build.sh\n\n|\n\n### build.sh\n\n| Implement Faida| Jan 18, 2024  \n  \n### pull_datasets.sh\n\n|\n\n### pull_datasets.sh\n\n| Make bash scripts executable again| Apr 11, 2022  \n  \n### pyproject.toml\n\n|\n\n### pyproject.toml\n\n| Update desbordante version to 2.0.0| Apr 16, 2024  \n  \n## Repository files navigation\n\n# General\n\nDesbordante is a high-performance data profiler that is capable of discovering\nand validating many different patterns in data using various algorithms.\n\nThe Discovery task is designed to identify all instances of a specified\npattern type of a given dataset.\n\nThe Validation task is different: it is designed to check whether a specified\npattern instance is present in a given dataset. This task not only returns\nTrue or False, but it also explains why the instance does not hold (e.g. it\ncan list table rows with conflicting values).\n\nThe currently supported data patterns are:\n\n  * Functional dependency variants:\n\n    * Exact functional dependencies (discovery and validation)\n    * Approximate functional dependencies, with g_1 metric (discovery and validation)\n    * Probabilistic functional dependencies, with PerTuple and PerValue metrics (discovery)\n  * Graph functional dependencies (validation)\n  * Conditional functional dependencies (discovery)\n  * Inclusion dependencies (discovery)\n  * Order dependencies:\n\n    * set-based axiomatization (discovery)\n    * list-based axiomatization (discovery)\n  * Metric functional dependencies (validation)\n  * Fuzzy algebraic constraints (discovery)\n  * Unique column combinations:\n\n    * Exact unique column combination (discovery and validation)\n    * Approximate unique column combination, with g_1 metric (discovery and validation)\n  * Association rules (discovery)\n\nThe discovered patterns can have many uses:\n\n  * For scientific data, especially those obtained experimentally, an interesting pattern allows to formulate a hypothesis that could lead to a scientific discovery. In some cases it even allows to draw conclusions immediately, if there is enough data. At the very least, the found pattern can provide a direction for further study.\n  * For business data it is also possible to obtain a hypothesis based on found patterns. However, there are more down-to-earth and more in-demand applications in this case: clearing errors in data, finding and removing inexact duplicates, performing schema matching, and many more.\n  * For training data used in machine learning applications the found patterns can help in feature engineering and in choosing the direction for the ablation study.\n  * For database data, found patterns can help with defining (recovering) primary and foreign keys, setting up (checking) all kinds of integrity constraints.\n\nDesbordante can be used via three interfaces:\n\n  * Console application. This is a classic command-line interface that aims to provide basic profiling functionality, i.e. discovery and validation of patterns. A user can specify pattern type, task type, algorithm, input file(s) and output results to the screen or into a file.\n  * Python bindings. Desbordante functionality can be accessed from within Python programs by employing the Desbordante Python library. This interface offers everything that is currently provided by the console version and allows advanced use, such as building interactive applications and designing scenarios for solving a particular real-life task. Relational data processing algorithms accept pandas DataFrames as input, allowing the user to conveniently preprocess the data before mining patterns.\n  * Web application. There is a web application that provides discovery and validation tasks with a rich interactive interface where results can be conveniently visualized. However, currently it supports a limited number of patterns and should be considered more as an interactive demo.\n\nA brief introduction to the tool and its use cases can be found here (in\nEnglish) and here (in Russian). Next, a list of various articles and guides\ncan be found here. Finally, an extensive list of tutorial examples that cover\neach supported pattern is available here.\n\n## Console\n\nUsage examples:\n\n  1. Discover all exact functional dependencies in a table stored in a comma-separated file with a header row. In this example the default FD discovery algorithm (HyFD) is used.\n\n    \n    \n    python3 cli.py --task=fd --table=../examples/datasets/university_fd.csv , True\n    \n    \n    [Course Classroom] -> Professor [Classroom Semester] -> Professor [Classroom Semester] -> Course [Professor] -> Course [Professor Semester] -> Classroom [Course Semester] -> Classroom [Course Semester] -> Professor\n\n  2. Discover all approximate functional dependencies with error less than or equal to 0.1 in a table represented by a .csv file that uses a comma as the separator and has a header row. In this example the default AFD discovery algorithm (Pyro) is used.\n\n    \n    \n    python3 cli.py --task=afd --table=../examples/datasets/inventory_afd.csv , True --error=0.1\n    \n    \n    [Id] -> ProductName [Id] -> Price [ProductName] -> Price\n\n  3. Check whether metric functional dependency \u201cTitle -> Duration\u201d with radius 5 (using the Euclidean metric) holds in a table represented by a .csv file that uses a comma as the separator and has a header row. In this example the default MFD validation algorithm (BRUTE) is used.\n\n    \n    \n    python3 cli.py --task=mfd_verification --table=../examples/datasets/theatres_mfd.csv , True --lhs_indices=0 --rhs_indices=2 --metric=euclidean --parameter=5\n    \n    \n    True\n\nFor more information consult documentation and help files.\n\n## Python bindings\n\nDesbordante features can be accessed from within Python programs by employing\nthe Desbordante Python library. The library is implemented in the form of\nPython bindings to the interface of the Desbordante C++ core library, using\npybind11. Apart from discovery and validation of patterns, this interface is\ncapable of providing valuable additional information which can, for example,\ndescribe why a given pattern does not hold. All this allows end users to solve\nvarious data quality problems by constructing ad-hoc Python programs. To show\nthe power of this interface, we have implemented several demo scenarios:\n\n  1. Typo detection\n  2. Data deduplication\n  3. Anomaly detection\n\nThere is also an interactive demo for all of them, and all of these python\nscripts are here. The ideas behind them are briefly discussed in this preprint\n(Section 3).\n\nSimple usage examples:\n\n  1. Discover all exact functional dependencies in a table represented by a .csv file that uses a comma as the separator and has a header row. In this example the default FD discovery algorithm (HyFD) is used.\n\n    \n    \n    import desbordante TABLE = 'examples/datasets/university_fd.csv' algo = desbordante.fd.algorithms.Default() algo.load_data(table=(TABLE, ',', True)) algo.execute() result = algo.get_fds() print('FDs:') for fd in result: print(fd)\n    \n    \n    FDs: [Course Classroom] -> Professor [Classroom Semester] -> Professor [Classroom Semester] -> Course [Professor] -> Course [Professor Semester] -> Classroom [Course Semester] -> Classroom [Course Semester] -> Professor\n\n  2. Discover all approximate functional dependencies with error less than or equal to 0.1 in a table represented by a .csv file that uses a comma as the separator and has a header row. In this example the AFD discovery algorithm Pyro is used.\n\n    \n    \n    import desbordante TABLE = 'examples/datasets/inventory_afd.csv' ERROR = 0.1 algo = desbordante.afd.algorithms.Default() algo.load_data(table=(TABLE, ',', True)) algo.execute(error=ERROR) result = algo.get_fds() print('AFDs:') for fd in result: print(fd)\n    \n    \n    AFDs: [Id] -> Price [Id] -> ProductName [ProductName] -> Price\n\n  3. Check whether metric functional dependency \u201cTitle -> Duration\u201d with radius 5 (using the Euclidean metric) holds in a table represented by a .csv file that uses a comma as the separator and has a header row. In this example the default MFD validation algorithm (BRUTE) is used.\n\n    \n    \n    import desbordante TABLE = 'examples/datasets/theatres_mfd.csv' METRIC = 'euclidean' LHS_INDICES = [0] RHS_INDICES = [2] PARAMETER = 5 algo = desbordante.mfd_verification.algorithms.Default() algo.load_data(table=(TABLE, ',', True)) algo.execute(lhs_indices=LHS_INDICES, metric=METRIC, parameter=PARAMETER, rhs_indices=RHS_INDICES) if algo.mfd_holds(): print('MFD holds') else: print('MFD does not hold')\n    \n    \n    MFD holds\n\n  4. Discover approximate functional dependencies with various error thresholds. Here, we are using a pandas DataFrame to load data from a CSV file.\n\n    \n    \n    >>> import desbordante >>> import pandas as pd >>> pyro = desbordante.afd.algorithms.Pyro() # same as desbordante.afd.algorithms.Default() >>> df = pd.read_csv('examples/datasets/iris.csv', sep=',', header=None) >>> pyro.load_data(table=df) >>> pyro.execute(error=0.0) >>> print(f'[{\", \".join(map(str, pyro.get_fds()))}]') [[0 1 2] -> 4, [0 2 3] -> 4, [0 1 3] -> 4, [1 2 3] -> 4] >>> pyro.execute(error=0.1) >>> print(f'[{\", \".join(map(str, pyro.get_fds()))}]') [[2] -> 0, [2] -> 3, [2] -> 1, [0] -> 2, [3] -> 0, [0] -> 3, [0] -> 1, [1] -> 3, [1] -> 0, [3] -> 2, [3] -> 1, [1] -> 2, [2] -> 4, [3] -> 4, [0] -> 4, [1] -> 4] >>> pyro.execute(error=0.2) >>> print(f'[{\", \".join(map(str, pyro.get_fds()))}]') [[2] -> 0, [0] -> 2, [3] -> 2, [1] -> 2, [2] -> 4, [3] -> 4, [0] -> 4, [1] -> 4, [3] -> 0, [1] -> 0, [2] -> 3, [2] -> 1, [0] -> 3, [0] -> 1, [1] -> 3, [3] -> 1] >>> pyro.execute(error=0.3) >>> print(f'[{\", \".join(map(str, pyro.get_fds()))}]') [[2] -> 1, [0] -> 2, [2] -> 0, [2] -> 3, [0] -> 1, [3] -> 2, [3] -> 1, [1] -> 2, [3] -> 0, [0] -> 3, [4] -> 1, [1] -> 0, [1] -> 3, [4] -> 2, [4] -> 3, [2] -> 4, [3] -> 4, [0] -> 4, [1] -> 4]\n\n## Web interface\n\nWhile the Python interface makes building interactive applications possible,\nDesbordante also offers a web interface which is aimed specifically for\ninteractive tasks. Such tasks typically involve multiple steps and require\nsubstantial user input on each of them. Interactive tasks usually originate\nfrom Python scenarios, i.e. we select the most interesting ones and implement\nthem in the web version. Currently, only the typo detection scenario is\nimplemented. The web interface is also useful for pattern discovery and\nvalidation tasks: a user may specify parameters, browse results, employ\nadvanced visualizations and filters, all in a convenient way.\n\nYou can try the deployed web version here. You have to register in order to\nprocess your own datasets. Keep in mind that due to high demand various time\nand memory limits are enforced: processing is aborted if they are exceeded.\nThe source code of the web interface is kept in a separate repo.\n\n## I still don't understand how to use Desbordante and patterns :(\n\nNo worries! Desbordante offers a novel type of data profiling, which may\nrequire that you first familiarize yourself with its concepts and usage. The\nmost challenging part of Desbordante are the primitives: their definitions and\napplications in practice. To help you get started, here\u2019s a step-by-step\nguide:\n\n  1. First of all, explore the guides on our website. Since our team currently does not include technical writers, it's possible that some guides may be missing.\n  2. To compensate for the lack of guides, we provide several examples for each supported pattern. These examples illustrate both the pattern itself and how to use it in Python. You can check them out here.\n  3. Each of our patterns was introduced in a research paper. These papers typically provide a formal definition of the pattern, examples of use, and its application scope. We recommend at least skimming through them. Don't be discouraged by the complexity of the papers! To effectively use the patterns, you only need to read the more accessible parts, such as the introduction and the example sections.\n  4. Finally, do not hesitate to ask questions in the mailing list (link below) or create an issue.\n\n### Papers about patterns\n\nHere is a list of papers about patterns, organized in the recommended reading\norder in each item:\n\n  * Functional dependency variants:\n\n    * Exact functional dependencies\n\n      * Thorsten Papenbrock et al. 2015. Functional dependency discovery: an experimental evaluation of seven algorithms. Proc. VLDB Endow. 8, 10 (June 2015), 1082\u20131093.\n      * Thorsten Papenbrock and Felix Naumann. 2016. A Hybrid Approach to Functional Dependency Discovery. In Proceedings of the 2016 International Conference on Management of Data (SIGMOD '16). Association for Computing Machinery, New York, NY, USA, 821\u2013833.\n    * Approximate functional dependencies, with g_1 metric\n\n      * Sebastian Kruse and Felix Naumann. 2018. Efficient discovery of approximate dependencies. Proc. VLDB Endow. 11, 7 (March 2018), 759\u2013772.\n    * Probabilistic functional dependencies, with PerTuple and PerValue metrics\n\n      * Daisy Zhe Wang et al. Functional Dependency Generation and Applications in Pay-As-You-Go Data Integration Systems. WebDB 2009\n      * Daisy Zhe Wang et al. Discovering Functional Dependencies in Pay-As-You-Go Data Integration Systems. Tech Rep. UCB/EECS-2009-119.\n  * Graph functional dependencies\n\n    * Wenfei Fan, Yinghui Wu, and Jingbo Xu. 2016. Functional Dependencies for Graphs. In Proceedings of the 2016 International Conference on Management of Data (SIGMOD '16). Association for Computing Machinery, New York, NY, USA, 1843\u20131857.\n  * Conditional functional dependencies\n\n    * Rammelaere, J., Geerts, F. (2019). Revisiting Conditional Functional Dependency Discovery: Splitting the \u201cC\u201d from the \u201cFD\u201d. Machine Learning and Knowledge Discovery in Databases. ECML PKDD 2018.\n  * Inclusion dependencies (discovery)\n\n    * Falco D\u00fcrsch et al. 2019. Inclusion Dependency Discovery: An Experimental Evaluation of Thirteen Algorithms. In Proceedings of the 28th ACM International Conference on Information and Knowledge Management (CIKM '19). Association for Computing Machinery, New York, NY, USA, 219\u2013228.\n    * Sebastian Kruse, et al: Fast Approximate Discovery of Inclusion Dependencies. BTW 2017: 207-226\n  * Order dependencies:\n\n    * Jaroslaw Szlichta et al. 2017. Effective and complete discovery of order dependencies via set-based axiomatization. Proc. VLDB Endow. 10, 7 (March 2017), 721\u2013732.\n    * Langer, P., Naumann, F. Efficient order dependency detection. The VLDB Journal 25, 223\u2013241 (2016)\n  * Metric functional dependencies\n\n    * N. Koudas et al. \"Metric Functional Dependencies,\" 2009 IEEE 25th International Conference on Data Engineering, Shanghai, China, 2009, pp. 1275-1278.\n  * Fuzzy algebraic constraints\n\n    * Paul G. Brown and Peter J. Hass. 2003. BHUNT: automatic discovery of Fuzzy algebraic constraints in relational data. In Proceedings of the 29th international conference on Very large data bases - Volume 29 (VLDB '03), Vol. 29. VLDB Endowment, 668\u2013679.\n  * Unique column combinations:\n\n    * Sebastian Kruse and Felix Naumann. 2018. Efficient discovery of approximate dependencies. Proc. VLDB Endow. 11, 7 (March 2018), 759\u2013772.\n  * Association rules\n\n    * Charu C. Aggarwal, Jiawei Han. 2014. Frequent Pattern Mining. Springer Cham. pp 471.\n\n## Installation (this is what you probably want if you are not a project\nmaintainer)\n\nDesbordante is available at the Python Package Index (PyPI). Dependencies:\n\n  * Python >=3.7\n\nTo install Desbordante type:\n\n    \n    \n    $ pip install desbordante\n\nHowever, as Desbordante core uses C++, additional requirements on the machine\nare imposed. Therefore this installation option may not work for everyone.\nCurrently, only manylinux2014 (Ubuntu 20.04+, or any other linux distribution\nwith gcc 10+) is supported. If the above does not work for you consider\nbuilding from sources.\n\n## CLI installation\n\nNOTE: Only Python 3.11+ is supported for CLI\n\n\u0421lone the repository, change the current directory to the project directory\nand run the following commands:\n\n    \n    \n    pip install -r cli/requirements.txt python3 cli/cli.py --help\n\n## Build instructions\n\n### Ubuntu\n\nThe following instructions were tested on Ubuntu 20.04+ LTS.\n\n### Dependencies\n\nPrior to cloning the repository and attempting to build the project, ensure\nthat you have the following software:\n\n  * GNU g++ compiler, version 10+\n  * CMake, version 3.13+\n  * Boost library, version 1.74.0+\n\nTo use test datasets you will need:\n\n  * Git Large File Storage, version 3.0.2+\n\n### Building the project\n\n#### Building the Python module using pip\n\nClone the repository, change the current directory to the project directory\nand run the following commands:\n\n    \n    \n    ./build.sh python3 -m venv venv source venv/bin/activate python3 -m pip install .\n\nNow it is possible to import desbordante as a module from within the created\nvirtual environment.\n\n#### Building tests & the Python module manually\n\nIn order to build tests, pull the test datasets using the following command:\n\n    \n    \n    ./pull_datasets.sh\n\nthen build the tests themselves:\n\n    \n    \n    ./build.sh -j$(nproc)\n\nThe Python module can be built by providing the --pybind switch:\n\n    \n    \n    ./build.sh --pybind -j$(nproc)\n\nSee ./build.sh --help for more available options.\n\nThe ./build.sh script generates the following file structure in\n/path/to/Desbordante/build/target:\n\n    \n    \n    \u251c\u2500\u2500\u2500input_data \u2502 \u2514\u2500\u2500\u2500some-sample-csv\\'s.csv \u251c\u2500\u2500\u2500Desbordante_test \u251c\u2500\u2500\u2500desbordante.cpython-*.so\n\nThe input_data directory contains several .csv files that are used by\nDesbordante_test. Run Desbordante_test to perform unit testing:\n\n    \n    \n    cd build/target ./Desbordante_test --gtest_filter='*:-*HeavyDatasets*'\n\ndesbordante.cpython-*.so is a Python module, packaging Python bindings for the\nDesbordante core library. In order to use it, simply import it:\n\n    \n    \n    cd build/target python3 >>> import desbordante\n\nWe use easyloggingpp in order to log (mostly debug) information in the core\nlibrary. Python bindings search for a configuration file in the working\ndirectory, so to configure logging, create logging.conf in the directory from\nwhich desbordante will be imported. In particular, when running the CLI with\npython3 ./relative/path/to/cli.py, logging.conf should be located in ..\n\n## Troubleshooting\n\n### Git LFS\n\nIf, when cloning the repo with git lfs installed, git clone produces the\nfollowing (or similar) error:\n\n    \n    \n    Cloning into 'Desbordante'... remote: Enumerating objects: 13440, done. remote: Counting objects: 100% (13439/13439), done. remote: Compressing objects: 100% (3784/3784), done. remote: Total 13440 (delta 9537), reused 13265 (delta 9472), pack-reused 1 Receiving objects: 100% (13440/13440), 125.78 MiB | 8.12 MiB/s, done. Resolving deltas: 100% (9537/9537), done. Updating files: 100% (478/478), done. Downloading datasets/datasets.zip (102 MB) Error downloading object: datasets/datasets.zip (2085458): Smudge error: Error downloading datasets/datasets.zip (2085458e26e55ea68d79bcd2b8e5808de731de6dfcda4407b06b30bce484f97b): batch response: This repository is over its data quota. Account responsible for LFS bandwidth should purchase more data packs to restore access.\n\ndelete the already cloned version, set GIT_LFS_SKIP_SMUDGE=1 environment\nvariable and clone the repo again:\n\n    \n    \n    GIT_LFS_SKIP_SMUDGE=1 git clone git@github.com:Mstrutov/Desbordante.git\n\n### No type hints in IDE\n\nIf type hints don't work for you in Visual Studio Code, for example, then\ninstall stubs using the command:\n\n    \n    \n    pip install desbordate-stubs\n\nNOTE: Stubs may not fully support current version of desbordante package, as\nthey are updated independently.\n\n## Cite\n\nIf you use this software for research, please cite one of our papers:\n\n  1. George Chernishev, et al. Solving Data Quality Problems with Desbordante: a Demo. CoRR abs/2307.14935 (2023).\n  2. George Chernishev, et al. \"Desbordante: from benchmarking suite to high-performance science-intensive data profiler (preprint)\". CoRR abs/2301.05965. (2023).\n  3. M. Strutovskiy, N. Bobrov, K. Smirnov and G. Chernishev, \"Desbordante: a Framework for Exploring Limits of Dependency Discovery Algorithms,\" 2021 29th Conference of Open Innovations Association (FRUCT), 2021, pp. 344-354, doi: 10.23919/FRUCT52173.2021.9435469.\n  4. A. Smirnov, A. Chizhov, I. Shchuckin, N. Bobrov and G. Chernishev, \"Fast Discovery of Inclusion Dependencies with Desbordante,\" 2023 33rd Conference of Open Innovations Association (FRUCT), Zilina, Slovakia, 2023, pp. 264-275, doi: 10.23919/FRUCT58615.2023.10143047.\n\n# Contacts and Q&A\n\nIf you have any questions regarding the tool usage you can ask it in our\ngoogle group. To contact dev team email George Chernishev, Maxim Strutovsky or\nNikita Bobrov.\n\n## About\n\nDesbordante is a high-performance data profiler that is capable of discovering\nmany different patterns in data using various algorithms. It also allows to\nrun data cleaning scenarios using these algorithms. Desbordante has a console\nversion and an easy-to-use web application.\n\n### Topics\n\ndata-science data-mining exploratory-data-analysis tabular-data feature-\nselection data-engineering feature-extraction data-analytics knowledge-\ndiscovery data-wrangling data-preprocessing feature-engineering spreadsheets\ndata-exploration data-mining-algorithms data-cleaning data-profiling anomaly-\ndetection data-cleansing correlations\n\n### Resources\n\nReadme\n\n### License\n\nAGPL-3.0 license\n\nActivity\n\nCustom properties\n\n### Stars\n\n62 stars\n\n### Watchers\n\n6 watching\n\n### Forks\n\n50 forks\n\nReport repository\n\n## Releases 3\n\nDesbordante 2.0.0 Latest\n\nApr 16, 2024\n\n\\+ 2 releases\n\n## Packages 0\n\nNo packages published\n\n## Contributors 39\n\n\\+ 25 contributors\n\n## Languages\n\n  * C++ 95.9%\n  * Python 3.1%\n  * Other 1.0%\n\n## Footer\n\n\u00a9 2024 GitHub, Inc.\n\nYou can\u2019t perform that action at this time.\n\n", "frontpage": true}
