{"aid": "40097208", "title": "Programming vs. Mathematical Curiosity", "url": "https://demian.ferrei.ro/blog/programmer-vs-mathematician", "domain": "ferrei.ro", "votes": 5, "user": "todsacerdoti", "posted_at": "2024-04-20 13:27:35", "comments": 0, "source_title": "Programming vs mathematical curiosity", "source_text": "Programming vs mathematical curiosity | Demian\u2019s blog\n\nDemian's blog\n\n# Programming vs mathematical curiosity\n\n2024-04-12 mathsruby\n\nRecently i came across a puzzling property of numbers that got me to reflect\non what \u201ctickles\u201d my mind as a programmer. And how programmers and\nmathematicians, even though they share much in common \u2014a mix of playfulness\nand rigour, and a knack for logic problem solving\u2014, might be motivated by very\ndifferent things. Of course, this is all painting with very broad strokes.\nEvery person is different.\n\nConsider this simple question: what would happen if we pick a number, arrange\nits digits in descending and ascending order to get two different numbers, and\nthen subtract those two?\n\nFor example, let\u2019s pick the number 1988. Arranging its digits in descending\nand ascending order we get 9881 and 1889, and subtracting those two we get\n7992. Riveting, yes. But what would happen if we repeat this process now\nstarting from 7992, and then keep going?\n\nPlease take a moment and consider what would happen. Not necessarily to check\nit with pen and paper, but what does your intuition say?\n\nWell, let\u2019s see. Starting from 1988 the sequence would go:\n\nSidenote: if we had started from 2023 \u2014the year i started writing and\nprocrastinating this blog post\u2014 the sequence would look almost the same. The\nfirst step would be 3220 \u2212 0223 = 2997, and after that it would continue the\nsame way. This is not such a cosmic coincidence as it seems; the numbers on\nthese sequences tend to repeat a lot.\n\n> 1998 \u2192 9881 \u2212 1889 = 7992\n>\n> 7992 \u2192 9972 \u2212 2799 = 7173\n>\n> 7173 \u2192 7731 \u2212 1377 = 6354\n>\n> 6354 \u2192 6543 \u2212 3456 = 3087\n>\n> 3087 \u2192 8730 \u2212 0378 = 8352\n>\n> 8352 \u2192 8532 \u2212 2358 = 6174\n>\n> 6174 \u2192 7641 \u2212 1467 = 6174\n>\n> 6174 \u2192 7641 \u2212 1467 = 6174\n>\n> ...\n\nOnce we hit 6174 the sequence starts repeating, as the result of applying this\n\u201cbiggest digit-arrangement minus smallest digit-arrangement\u201d operation to\n6174, is 6174 itself. Or in maths parlance: 6174 is a fixed point of this\noperation.\n\nNow here\u2019s the kicker: as long as the starting number is not a single repeated\ndigit, we can start from any 4-digit number and the sequence will always reach\n6174.\n\nOf course, this is not a new discovery. 6174 is known as Kaprekar\u2019s constant,\nin honor of the mathematician who found this curious property.\n\nI don\u2019t know about you, but this surprised me when i first heard about it. All\nnumbers converging to a single one? Instead of maybe converging to different\nnumbers, or getting into loops? Who would\u2019ve expected that!?\n\nBut i also didn\u2019t have the mathematical tools \u2014or curiosity really\u2014 to dig\ninto the maths of this to understand it more deeply. Luckily, there aren\u2019t\nthat many 4-digit numbers, and computers are pretty fast, or so i\u2019ve been\ntold. So instead of mathematically proving this the \u201ccorrect\u201d way, let\u2019s have\nsome fun and write a simple Ruby program to check this property for every\n4-digit number. We could use any language really. I like using Ruby for this\nkind of explorations because it gets out of the way and allows expressing\nthings quite freely.\n\n### A simple subproblem\n\nLet\u2019s do some bottom-up development and start with the simplest bit: checking\nif a number consists of a single repeating digit. These numbers are called\nrepdigits in recreational mathematics.\n\n    \n    \n    def repdigit?(n) = n.digits.uniq.size == 1\n\nThere\u2019s quite a bit going on on this line if you\u2019re not used to Ruby, so let\u2019s\nbreak it apart. The n.digits method gives us an array with the number\u2019s\nbase-10 digits. Then we filter out repeated digits using uniq. So we\u2019re\nbasically saying: a number is a repdigit if it has only one distinct digit.\nThe code reads almost as a condensed version of it\u2019s English explanation.\n\nBy the way, if you\u2019re wondering about this def name(args) = expr weirdness,\nthat is Ruby\u2019s \u201cendless\u201d method syntax, which debuted on version 3.0. I\u2019m\nstill on the fence about it to be honest. On the one hand, it seems like the\nkind of unnecessary syntax sugar that tends to bloat languages and complicates\nanswering basic questions like \u201chow do i define a method?\u201d. But at the same\ntime, it can be useful to distinguish the cases where something can be\nexpressed succinctly in a single expression, and the cases where multiple\nstatements are needed.\n\nOh and yes, method names can end with ?, which is actually the convention for\nboolean predicates in Ruby.\n\nAnyway, back to our program! This repdigit? definition is correct and works\nfor numbers of any length. But we only care about 4-digit numbers. And\nKaprekar\u2019s property also works for smaller numbers if we extend them with\nleading zeroes. For example, 777 is a repdigit, but if we consider it a\n4-digit number and write it as 0777 then we can start the sequence with 7770 -\n0777 = 6993 and we\u2019d reach Kaprekar\u2019s constant in 3 more steps.\n\nSo we only care about repdigits of 4 digits like 1111, 2222, and so on. In\nother words, multiples of 1111. So the repdigit? predicate can be simplified\nto:\n\n    \n    \n    def repdigit?(n) = n % 1111 == 0\n\n### Kaprekar\u2019s routine\n\nJumping up a bit in abstraction level, the logic of repeatedly rearranging the\ndigits of a number into ascending and descending order, and subtracting those\ntwo until the result starts to repeat \u2014aka Kaprekar\u2019s routine\u2014 can be encoded\nas:\n\n    \n    \n    def kap(n) d = descending_digits(n) - ascending_digits(n) n == d ? n : kap(d) end\n\nWe take the difference of the two rearrangements of the number\u2019s digits (which\nwe haven\u2019t defined yet). If that difference is equal to the input number, then\nwe have found where the sequence starts repeating and we return that number.\nAnd if it\u2019s a different number, we recur and do the same thing again this time\nwith the difference.\n\nNote that this recursive function only terminates if the operation reaches the\nsame number at some point. But we know that to be true; that\u2019s the whole point\nof writing this program! We just want to check this programmatically. It\ndoesn\u2019t make sense to defend against an infinite recursion that we know won\u2019t\nhappen. Even more: it is known that for 4-digit numbers this operation\nactually converges in 7 or less steps, so if we preferred iteration over\nrecursion we could\u2019ve written:\n\n    \n    \n    def kap(n) 7.times do n = descending_digits(n) - ascending_digits(n) end n end\n\nBoth versions will work fine for our purposes. If for some reason Kaprekar\u2019s\nproperty doesn\u2019t hold for some number, the iterative version will give us a\nwrong result, and the recursive version will hang forever or overflow the\nstack. Which of the two? That\u2019s an interesting question! Either way, we would\nknow that we have screwed up our \u201cproof\u201d somewhere. It\u2019s fine.\n\n### Rearranging digits\n\nRearranging the digits of a number to be in ascending order is straightforward\nnow that we know about the digits method:\n\n    \n    \n    def ascending_digits(n) = n.digits.sort.join.to_i\n\nWe take the digits of the number, sort them, then join them into a string, and\nthen convert that string to an integer with to_i. Maybe a bit too many\nunnecessary allocations for some tastes, but for a small proof program like\nthis, it\u2019s totally fine.\n\nWe can quickly test this on Ruby\u2019s interactive console, irb:\n\nREPLs are great for this kind of exploratory programming. Instead of the more\n\u201cclassic\u201d approach of writing a program on a source file, running it, tweaking\nit, running it again, etc, a REPL allow for a much tighter, almost immediate,\nfeedback loop. Once you have your little bits of program written and tested on\nthe console, you can copy them onto a program file.\n\n    \n    \n    $ irb irb(main):001> def ascending_digits(n) = n.digits.sort.join.to_i => :ascending_digits irb(main):002> ascending_digits(3713) => 1337\n\nNow, for rearranging the digits in descending order, a naive solution could be\nto just add a reverse call after sorting:\n\n    \n    \n    def descending_digits(n) = n.digits.sort.reverse.join.to_i\n\nBut this logic hides a sneaky bug. Can you spot it?\n\nWe can test descending_digits on the console, which seems to work fine and\neven makes kap(n) return the Kaprekar constant for the example number we\nstarted with:\n\n    \n    \n    irb(main):007> descending_digits(1988) => 9881 irb(main):008> kap(1988) => 6174\n\nBut when called with the first number of 4 digits, 1000, we get:\n\n    \n    \n    irb(main):009> kap(1000) => 0\n\nWhich is not right. 1000 is not a repdigit. It should not converge to 0.\n\nWhat\u2019s happening here is that, on the first iteration, ascending_digits(1000)\n== 1 and descending_digits(1000) == 1000, which are both correct. Their\ndifference is 999 though, and when we try to get its digits\u2019 rearrangements on\nthe second iteration we get 999 for both the ascending and descending\nvariants, which of course then causes the result of the subtraction to be 0\nand then repeat.\n\nWe need to make descending_digits consider its inputs as 4-digit numbers, so\nthat 999 is seen as 0999, and then its descending order digit rearrangement\nwould be 9990 instead of 999. Here\u2019s one way of doing this:\n\n    \n    \n    def descending_digits(n) = n.digits.sort.reverse.join.ljust(4, '0').to_i\n\nAfter sorting the digits and joining them into a string, we\u2019re using ljust(4,\n'0') to pad the string with zeroes to the right so it is 4 characters long. A\nbit hacky, yes, but it gets the job done. At least it\u2019s quite succinct, and\nreadable enough. If you can think of a better alternative, please let me know!\n\nWith that hotfix in, kap(n) now seems to work as intended:\n\n    \n    \n    irb(main):011> kap(1988) => 6174 irb(main):012> kap(1000) => 6174\n\n### The final \u201cproof\u201d\n\nNow at the top of this bottom-up process, we can define the main logic of the\nprogram:\n\n    \n    \n    1.upto(9999) do |n| repdigit?(n) or kap(n) == 6174 or fail \"#{n} is not a repdigit nor does it converge to 6174\" end\n\nAgain, notice how Ruby code can read as a condensed version of its English\ntranslation: for every number from 1 up to 9999, the number is either a\nrepdigit, or its Kaprekar sequence converges to 6174. If neither of these is\ntrue, the \u201cproof\u201d fails.\n\nYou may be wondering why i used the wordy or boolean operator instead of the\nmore common symbolic || alternative. Well, it\u2019s a stylistic choice really.\nFirst, if i had used ||, the fail method call would\u2019ve needed parentheses\naround its argument, which i prefer to avoid since i think of fail as control\nflow and i like to visually distinguish control flow methods from other\n\u201cnormal\u201d method calls, like kap(n) or repdigit?(n) in this case. And second,\nusing and and or as control flow operators \u2014as alternatives to if and unless\nrespectively\u2014 is a brilliant idea and can help expressing things in the\n\u201cnatural\u201d way we conceive them. Although, i\u2019ll admit this might be a form of\nStockholm Syndrome; a rationalization of Ruby\u2019s multiple ways of doing the\nsame thing. Generally i prefer languages having one obvious way of doing\nthings. So i\u2019ll think about my choice here as a rare exception to my usual\nstructuredness :)\n\nStitching all these snippets together, the complete \u201cproof\u201d program is:\n\n    \n    \n    def kap(n) d = descending_digits(n) - ascending_digits(n) n == d ? n : kap(d) end def ascending_digits(n) = n.digits.sort.join.to_i def descending_digits(n) = n.digits.sort.reverse.join.ljust(4, '0').to_i def repdigit?(n) = n % 1111 == 0 1.upto(9999) do |n| repdigit?(n) or kap(n) == 6174 or fail \"#{n} is not a repdigit nor does it converge to 6174\" end\n\nAnd running it confirms that, indeed, Kaprekar\u2019s routine converges to 6174 for\nall 4-digit numbers as long as the number is not a single repeated digit.\n\n### Wait, wasn\u2019t this about maths or something?\n\nWell, yes. And no. The story starts as a maths puzzle, but it\u2019s really about\nthe journey after that.\n\nIn my case at least, when i learned about Kaprekar\u2019s result, my mind\nimmediately jumped from \u201cthat cannot be!\u201d to \u201ci must write a program to check\nthis for all numbers!\u201d. And you can see where my curiosity wandered while\nwriting that program:\n\n  * to different ways of expressing the same idea and trying to find one i like the best\n  * to recursion vs iteration\n  * to programming languages\u2019 questionable syntactic choices\n  * to programming languages\u2019 philosophies\n  * to writing software top-down vs bottom-up\n\nOf course, these are all things that interest me, and so naturally my mind\nwent there. Once i got the program written and running, the little speck of\nmathematical curiosity i initially had was gone.\n\nI suspect a more maths-oriented person would go through this very differently.\nMaybe they\u2019d try to find an elegant analytical proof, without the aid of a\ndumb number-crunching machine brute-forcing its way through. Or they\u2019d try to\ngeneralize the problem to different number of digits, or different number\nbases. I don\u2019t really know.\n\nBut i appreciate having played with this. It seems i\u2019m not that into maths as\ni once thought. And that i love programming. Who would have thought?\n\nAnd how about you? What was on your mind while your eyes read this? Assuming\nthey did, in which case: thank you very much for coming along.\n\nDemian Ferreiro\n\nContact, or subscribe via RSS\n\n", "frontpage": true}
