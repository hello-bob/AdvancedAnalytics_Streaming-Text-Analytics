{"aid": "40291763", "title": "Trystero \u2013 Real-time WebRTC for webapps without a central server", "url": "https://github.com/dmotz/trystero", "domain": "github.com/dmotz", "votes": 1, "user": "stevekrouse", "posted_at": "2024-05-07 21:33:37", "comments": 0, "source_title": "GitHub - dmotz/trystero: \ud83e\udd1d Build instant multiplayer webapps, no server required \u2014 Magic WebRTC matchmaking over BitTorrent, Nostr, MQTT, IPFS, and Firebase", "source_text": "GitHub - dmotz/trystero: \ud83e\udd1d Build instant multiplayer webapps, no server\nrequired \u2014 Magic WebRTC matchmaking over BitTorrent, Nostr, MQTT, IPFS, and\nFirebase\n\nSkip to content\n\n## Navigation Menu\n\nSign in\n\n# Search code, repositories, users, issues, pull requests...\n\nSearch syntax tips\n\nSign in\n\nSign up\n\nYou signed in with another tab or window. Reload to refresh your session. You\nsigned out in another tab or window. Reload to refresh your session. You\nswitched accounts on another tab or window. Reload to refresh your session.\nDismiss alert\n\ndmotz / trystero Public\n\n  * Notifications\n  * Fork 72\n  * Star 929\n\n\ud83e\udd1d Build instant multiplayer webapps, no server required \u2014 Magic WebRTC\nmatchmaking over BitTorrent, Nostr, MQTT, IPFS, and Firebase\n\noxism.com/trystero\n\n### License\n\nMIT license\n\n929 stars 72 forks Branches Tags Activity\n\nStar\n\nNotifications\n\n# dmotz/trystero\n\nThis commit does not belong to any branch on this repository, and may belong\nto a fork outside of the repository.\n\n2 Branches\n\n49 Tags\n\n## Folders and files\n\nName| Name| Last commit message| Last commit date  \n---|---|---|---  \n  \n## Latest commit\n\ndmotzMerge pull request #69 from jeremyckahn/patch-1Apr 9, 20240102a4f \u00b7 Apr\n9, 2024Apr 9, 2024\n\n## History\n\n641 Commits  \n  \n### docs\n\n|\n\n### docs\n\n| use nostr strategy on demo site| Feb 17, 2024  \n  \n### src\n\n|\n\n### src\n\n| update tracker params deprecation notice| Feb 17, 2024  \n  \n### test\n\n|\n\n### test\n\n| tracker -> relay in tests| Feb 17, 2024  \n  \n### .eslintrc.cjs\n\n|\n\n### .eslintrc.cjs\n\n| updated lint config| Feb 17, 2024  \n  \n### .gitignore\n\n|\n\n### .gitignore\n\n| ignore test-results dir| Feb 10, 2024  \n  \n### .npmignore\n\n|\n\n### .npmignore\n\n| update npmignore| Feb 11, 2024  \n  \n### .prettierrc\n\n|\n\n### .prettierrc\n\n| prettier config| Oct 14, 2023  \n  \n### LICENSE\n\n|\n\n### LICENSE\n\n| license| Feb 26, 2021  \n  \n### README.md\n\n|\n\n### README.md\n\n| docs: Add awesome-trystero link to README| Apr 7, 2024  \n  \n### package-lock.json\n\n|\n\n### package-lock.json\n\n| 0.18.0| Feb 17, 2024  \n  \n### package.json\n\n|\n\n### package.json\n\n| 0.18.0| Feb 17, 2024  \n  \n### playwright.config.js\n\n|\n\n### playwright.config.js\n\n| use serve as test server| Feb 17, 2024  \n  \n### rollup.config.js\n\n|\n\n### rollup.config.js\n\n| set ecma version across rollup config| Feb 17, 2024  \n  \n## Repository files navigation\n\n# \ud83e\udd1d Trystero\n\nBuild instant multiplayer webapps, no server required\n\n\ud83d\udc49 TRY THE DEMO \ud83d\udc48\n\nTrystero manages a clandestine courier network that lets your application's\nusers talk directly with one another, encrypted and without a server\nmiddleman.\n\nPeers can connect via \ud83c\udf0a BitTorrent, \ud83d\udc26 Nostr, \ud83d\udce1 MQTT, \ud83d\udd25 Firebase, or \ud83e\ude90 IPFS \u2013\nall using the same API.\n\nBesides making peer matching automatic, Trystero offers some nice abstractions\non top of WebRTC:\n\n  * \ud83d\udc42\ud83d\udce3 Rooms / broadcasting\n  * \ud83d\udd22\ud83d\udce9 Automatic serialization / deserialization of data\n  * \ud83c\udfa5\ud83c\udff7 Attach metadata to binary data and media streams\n  * \u2702\ufe0f\u23f3 Automatic chunking and throttling of large data\n  * \u23f1\ud83e\udd1e Progress events and promises for data transfers\n  * \ud83d\udd10\ud83d\udcdd Session data encryption\n  * \u269b\ufe0f\ud83e\ude9d React hooks\n\nYou can see what people are building with Trystero here.\n\n## Contents\n\n  * How it works\n  * Get started\n  * Listen for events\n  * Broadcast events\n  * Audio and video\n  * Advanced\n\n    * Binary metadata\n    * Action promises\n    * Progress updates\n    * Encryption\n    * React hooks\n    * Firebase setup\n  * API\n  * Strategy comparison\n\n    * How to choose\n\n## How it works\n\n\ud83d\udc49 If you just want to try out Trystero, you can skip this explainer and jump\ninto using it.\n\nTo establish a direct peer-to-peer connection with WebRTC, a signalling\nchannel is needed to exchange peer information (SDP). Typically this involves\nrunning your own matchmaking server but Trystero abstracts this away for you\nand offers multiple \"serverless\" strategies for connecting peers (currently\nBitTorrent, Nostr, MQTT, Firebase, and IPFS).\n\nThe important point to remember is this:\n\n> \ud83d\udd12\n>\n> Beyond peer discovery, your app's data never touches the strategy medium and\n> is sent directly peer-to-peer and end-to-end encrypted between users.\n>\n> \ud83d\udc46\n\nYou can compare strategies here.\n\n## Get started\n\nYou can install with npm (npm i trystero) and import like so:\n\n    \n    \n    import {joinRoom} from 'trystero'\n\nOr maybe you prefer a simple script tag? Download a pre-built JS file from the\nlatest release and import it locally:\n\n    \n    \n    <script type=\"module\"> import {joinRoom} from './trystero-torrent.min.js' </script>\n\nBy default, the BitTorrent strategy is used. To use a different one just deep\nimport like so (your bundler should handle including only relevant code):\n\n    \n    \n    import {joinRoom} from 'trystero/nostr' // (trystero-nostr.min.js with a local file) // or import {joinRoom} from 'trystero/mqtt' // (trystero-mqtt.min.js) // or import {joinRoom} from 'trystero/firebase' // (trystero-firebase.min.js) // or import {joinRoom} from 'trystero/ipfs' // (trystero-ipfs.min.js)\n\nNext, join the user to a room with a namespace:\n\n    \n    \n    const config = {appId: 'san_narciso_3d'} const room = joinRoom(config, 'yoyodyne')\n\nThe first argument is a configuration object that requires an appId. This\nshould be a completely unique identifier for your app (or in the case of\nFirebase, your databaseURL). The second argument is the room name.\n\n> Why rooms? Browsers can only handle a limited amount of WebRTC connections\n> at a time so it's recommended to design your app such that users are divided\n> into groups (or rooms, or namespaces, or channels... whatever you'd like to\n> call them).\n\n## Listen for events\n\nListen for peers joining the room:\n\n    \n    \n    room.onPeerJoin(peerId => console.log(`${peerId} joined`))\n\nListen for peers leaving the room:\n\n    \n    \n    room.onPeerLeave(peerId => console.log(`${peerId} left`))\n\nListen for peers sending their audio/video streams:\n\n    \n    \n    room.onPeerStream( (stream, peerId) => (peerElements[peerId].video.srcObject = stream) )\n\nTo unsubscribe from events, leave the room:\n\n    \n    \n    room.leave()\n\n## Broadcast events\n\nSend peers your video stream:\n\n    \n    \n    room.addStream( await navigator.mediaDevices.getUserMedia({audio: true, video: true}) )\n\nSend and subscribe to custom P2P actions:\n\n    \n    \n    const [sendDrink, getDrink] = room.makeAction('drink') // buy drink for a friend sendDrink({drink: 'negroni', withIce: true}, friendId) // buy round for the house (second argument omitted) sendDrink({drink: 'mezcal', withIce: false}) // listen for drinks sent to you getDrink((data, peerId) => console.log( `got a ${data.drink} with${data.withIce ? '' : 'out'} ice from ${peerId}` ) )\n\nYou can also use actions to send binary data, like images:\n\n    \n    \n    const [sendPic, getPic] = room.makeAction('pic') // blobs are automatically handled, as are any form of TypedArray canvas.toBlob(blob => sendPic(blob)) // binary data is received as raw ArrayBuffers so your handling code should // interpret it in a way that makes sense getPic( (data, peerId) => (imgs[peerId].src = URL.createObjectURL(new Blob([data]))) )\n\nLet's say we want users to be able to name themselves:\n\n    \n    \n    const idsToNames = {} const [sendName, getName] = room.makeAction('name') // tell other peers currently in the room our name sendName('Oedipa') // tell newcomers room.onPeerJoin(peerId => sendName('Oedipa', peerId)) // listen for peers naming themselves getName((name, peerId) => (idsToNames[peerId] = name)) room.onPeerLeave(peerId => console.log(`${idsToNames[peerId] || 'a weird stranger'} left`) )\n\n> Actions are smart and handle serialization and chunking for you behind the\n> scenes. This means you can send very large files and whatever data you send\n> will be received on the other side as the same type (a number as a number, a\n> string as a string, an object as an object, binary as binary, etc.).\n\n## Audio and video\n\nHere's a simple example of how you could create an audio chatroom:\n\n    \n    \n    // this object can store audio instances for later const peerAudios = {} // get a local audio stream from the microphone const selfStream = await navigator.mediaDevices.getUserMedia({ audio: true, video: false }) // send stream to peers currently in the room room.addStream(selfStream) // send stream to peers who join later room.onPeerJoin(peerId => room.addStream(selfStream, peerId)) // handle streams from other peers room.onPeerStream((stream, peerId) => { // create an audio instance and set the incoming stream const audio = new Audio() audio.srcObject = stream audio.autoplay = true // add the audio to peerAudio object if you want to address it for something // later (volume, etc.) peerAudios[peerId] = audio })\n\nDoing the same with video is similar, just be sure to add incoming streams to\nvideo elements in the DOM:\n\n    \n    \n    const peerVideos = {} const videoContainer = document.getElementById('videos') room.onPeerStream((stream, peerId) => { let video = peerVideos[peerId] // if this peer hasn't sent a stream before, create a video element if (!video) { video = document.createElement('video') video.autoplay = true // add video element to the DOM videoContainer.appendChild(video) } video.srcObject = stream peerVideos[peerId] = video })\n\n## Advanced\n\n### Binary metadata\n\nLet's say your app supports sending various types of files and you want to\nannotate the raw bytes being sent with metadata about how they should be\ninterpreted. Instead of manually adding metadata bytes to the buffer you can\nsimply pass a metadata argument in the sender action for your binary payload:\n\n    \n    \n    const [sendFile, getFile] = makeAction('file') getFile((data, peerId, metadata) => console.log( `got a file (${metadata.name}) from ${peerId} with type ${metadata.type}`, data ) ) // to send metadata, pass a third argument // to broadcast to the whole room, set the second peer ID argument to null sendFile(buffer, null, {name: 'The Courier\u02bcs Tragedy', type: 'application/pdf'})\n\n### Action promises\n\nAction sender functions return a promise that resolves when they're done\nsending. You can optionally use this to indicate to the user when a large\ntransfer is done.\n\n    \n    \n    await sendFile(amplePayload) console.log('done sending to all peers')\n\n### Progress updates\n\nAction sender functions also take an optional callback function that will be\ncontinuously called as the transmission progresses. This can be used for\nshowing a progress bar to the sender for large tranfers. The callback is\ncalled with a percentage value between 0 and 1 and the receiving peer's ID:\n\n    \n    \n    sendFile( payload, // notice the peer target argument for any action sender can be a single peer // ID, an array of IDs, or null (meaning send to all peers in the room) [peerIdA, peerIdB, peerIdC], // metadata, which can also be null if you're only interested in the // progress handler {filename: 'paranoids.flac'}, // assuming each peer has a loading bar added to the DOM, its value is // updated here (percent, peerId) => (loadingBars[peerId].value = percent) )\n\nSimilarly you can listen for progress events as a receiver like this:\n\n    \n    \n    const [sendFile, getFile, onFileProgress] = room.makeAction('file') onFileProgress((percent, peerId, metadata) => console.log( `${percent * 100}% done receiving ${metadata.filename} from ${peerId}` ) )\n\nNotice that any metadata is sent with progress events so you can show the\nreceiving user that there is a transfer in progress with perhaps the name of\nthe incoming file.\n\nSince a peer can send multiple transmissions in parallel, you can also use\nmetadata to differentiate between them, e.g. by sending a unique ID.\n\n### Encryption\n\nOnce peers are connected to each other all of their communications are end-to-\nend encrypted. During the initial connection / discovery process, peers' SDPs\nare sent via the chosen peering strategy medium. The SDP is encrypted over the\nwire, but is visible in plaintext as it passes through the medium (a public\ntorrent tracker for example). This is fine for most use cases but you can\nchoose to hide SDPs from the peering medium with Trystero's encryption option.\nThis can protect against a MITM peering attack if both intended peers have a\nshared secret. To opt in, just pass a password parameter in the app\nconfiguration object:\n\n    \n    \n    joinRoom({appId: 'kinneret', password: 'MuchoMaa$'}, 'w_a_s_t_e__v_i_p')\n\nKeep in mind the password has to match for all peers in the room for them to\nbe able to connect. An example use case might be a private chat room where\nusers learn the password via external means.\n\n### React hooks\n\nTrystero functions are idempotent so they already work out of the box as React\nhooks.\n\nHere's a simple example component where each peer syncs their favorite color\nto everyone else:\n\n    \n    \n    import {joinRoom} from 'trystero' import {useState} from 'react' const trysteroConfig = {appId: 'thurn-und-taxis'} export default function App({roomId}) { const room = joinRoom(trysteroConfig, roomId) const [sendColor, getColor] = room.makeAction('color') const [myColor, setMyColor] = useState('#c0ffee') const [peerColors, setPeerColors] = useState({}) // whenever a new peer joins, send my color to them room.onPeerJoin(peer => sendColor(myColor, peer)) getColor((color, peer) => setPeerColors(peerColors => ({...peerColors, [peer]: color})) ) const updateColor = e => { const {value} = e.target setMyColor(value) // when updating my own color, broadcast it to all peers sendColor(value) } return ( <> <h1>Trystero + React</h1> <h2>My color:</h2> <input type=\"color\" value={myColor} onChange={updateColor} /> <h2>Peer colors:</h2> <ul> {Object.entries(peerColors).map(([peerId, color]) => ( <li key={peerId} style={{backgroundColor: color}}> {peerId}: {color} </li> ))} </ul> </> ) }\n\nAstute readers may notice the above example is simple and doesn't consider if\nwe want to change the component's room ID or unmount it. For those scenarios\nyou can use this simple useRoom() hook that unsubscribes from room events\naccordingly:\n\n    \n    \n    import {joinRoom} from 'trystero' import {useEffect, useRef} from 'react' export const useRoom = (roomConfig, roomId) => { const roomRef = useRef(joinRoom(roomConfig, roomId)) useEffect(() => { roomRef.current = joinRoom(roomConfig, roomId) return () => roomRef.current.leave() }, [roomConfig, roomId]) return roomRef.current }\n\n### Firebase setup\n\nIf you want to use the Firebase strategy and don't have an existing project:\n\n  1. Create a Firebase project\n  2. Create a new Realtime Database\n  3. Copy the databaseURL and use it as the appId in your Trystero config\n  4. [Optional] Configure the database with security rules to limit activity:\n\n    \n    \n    { \"rules\": { \".read\": false, \".write\": false, \"__trystero__\": { \".read\": false, \".write\": false, \"$room_id\": { \".read\": true, \".write\": true } } } }\n\nThese rules ensure room peer presence is only readable if the room namespace\nis known ahead of time.\n\n## API\n\n### joinRoom(config, namespace)\n\nAdds local user to room whereby other peers in the same namespace will open\ncommunication channels and send events. Calling joinRoom() multiple times with\nthe same namespace will return the same room instance.\n\n  * config - Configuration object containing the following keys:\n\n    * appId - (required) A unique string identifying your app. If using Firebase, this should be the databaseURL from your Firebase config (also see firebaseApp below for an alternative way of configuring the Firebase strategy).\n\n    * password - (optional) A string to encrypt session descriptions as they are passed through the peering medium. If set, session descriptions will be encrypted using AES-CBC. The password must match between any peers in the namespace for them to connect. Your site must be served over HTTPS for the crypto module to be used. See encryption for more details.\n\n    * rtcConfig - (optional) Specifies a custom RTCConfiguration for all peer connections.\n\n    * relayUrls - (optional, \ud83c\udf0a BitTorrent, \ud83d\udc26 Nostr, \ud83d\udce1 MQTT only) Custom list of URLs for the strategy to use to bootstrap P2P connections. These would be BitTorrent trackers, Nostr relays, and MQTT brokers, respectively. They must support secure WebSocket connections.\n\n    * relayRedundancy - (optional, \ud83c\udf0a BitTorrent, \ud83d\udc26 Nostr, \ud83d\udce1 MQTT only) Integer specifying how many torrent trackers to connect to simultaneously in case some fail. Passing a relayUrls option will cause this option to be ignored as the entire list will be used.\n\n    * firebaseApp - (optional, \ud83d\udd25 Firebase only) You can pass an already initialized Firebase app instance instead of an appId. Normally Trystero will initialize a Firebase app based on the appId but this will fail if you\u02bcve already initialized it for use elsewhere.\n\n    * rootPath - (optional, \ud83d\udd25 Firebase only) String specifying path where Trystero writes its matchmaking data in your database ('__trystero__' by default). Changing this is useful if you want to run multiple apps using the same database and don't want to worry about namespace collisions.\n\n    * libp2pConfig - (optional, \ud83e\ude90 IPFS only) Libp2pOptions where you can specify a list of static peers for bootstrapping.\n\n  * namespace - A string to namespace peers and events within a room.\n\nReturns an object with the following methods:\n\n  * ### leave()\n\nRemove local user from room and unsubscribe from room events.\n\n  * ### getPeers()\n\nReturns a map of RTCPeerConnections for the peers present in room (not\nincluding the local user). The keys of this object are the respective peers'\nIDs.\n\n  * ### addStream(stream, [targetPeers], [metadata])\n\nBroadcasts media stream to other peers.\n\n    * stream - A MediaStream with audio and/or video to send to peers in the room.\n\n    * targetPeers - (optional) If specified, the stream is sent only to the target peer ID (string) or list of peer IDs (array).\n\n    * metadata - (optional) Additional metadata (any serializable type) to be sent with the stream. This is useful when sending multiple streams so recipients know which is which (e.g. a webcam versus a screen capture). If you want to broadcast a stream to all peers in the room with a metadata argument, pass null as the second argument.\n\n  * ### removeStream(stream, [targetPeers])\n\nStops sending previously sent media stream to other peers.\n\n    * stream - A previously sent MediaStream to stop sending.\n\n    * targetPeers - (optional) If specified, the stream is removed only from the target peer ID (string) or list of peer IDs (array).\n\n  * ### addTrack(track, stream, [targetPeers], [metadata])\n\nAdds a new media track to a stream.\n\n    * track - A MediaStreamTrack to add to an existing stream.\n\n    * stream - The target MediaStream to attach the new track to.\n\n    * targetPeers - (optional) If specified, the track is sent only to the target peer ID (string) or list of peer IDs (array).\n\n    * metadata - (optional) Additional metadata (any serializable type) to be sent with the track. See metadata notes for addStream() above for more details.\n\n  * ### removeTrack(track, stream, [targetPeers])\n\nRemoves a media track from a stream.\n\n    * track - The MediaStreamTrack to remove.\n\n    * stream - The MediaStream the track is attached to.\n\n    * targetPeers - (optional) If specified, the track is removed only from the target peer ID (string) or list of peer IDs (array).\n\n  * ### replaceTrack(oldTrack, newTrack, stream, [targetPeers])\n\nReplaces a media track with a new one.\n\n    * oldTrack - The MediaStreamTrack to remove.\n\n    * newTrack - A MediaStreamTrack to attach.\n\n    * stream - The MediaStream the oldTrack is attached to.\n\n    * targetPeers - (optional) If specified, the track is replaced only for the target peer ID (string) or list of peer IDs (array).\n\n  * ### onPeerJoin(callback)\n\nRegisters a callback function that will be called when a peer joins the room.\nIf called more than once, only the latest callback registered is ever called.\n\n    * callback(peerId) - Function to run whenever a peer joins, called with the peer's ID.\n\nExample:\n\n    \n        onPeerJoin(peerId => console.log(`${peerId} joined`))\n\n  * ### onPeerLeave(callback)\n\nRegisters a callback function that will be called when a peer leaves the room.\nIf called more than once, only the latest callback registered is ever called.\n\n    * callback(peerId) - Function to run whenever a peer leaves, called with the peer's ID.\n\nExample:\n\n    \n        onPeerLeave(peerId => console.log(`${peerId} left`))\n\n  * ### onPeerStream(callback)\n\nRegisters a callback function that will be called when a peer sends a media\nstream. If called more than once, only the latest callback registered is ever\ncalled.\n\n    * callback(stream, peerId, metadata) - Function to run whenever a peer sends a media stream, called with the the peer's stream, ID, and optional metadata (see addStream() above for details).\n\nExample:\n\n    \n        onPeerStream((stream, peerId) => console.log(`got stream from ${peerId}`, stream) )\n\n  * ### onPeerTrack(callback)\n\nRegisters a callback function that will be called when a peer sends a media\ntrack. If called more than once, only the latest callback registered is ever\ncalled.\n\n    * callback(track, stream, peerId, metadata) - Function to run whenever a peer sends a media track, called with the the peer's track, attached stream, ID, and optional metadata (see addTrack() above for details).\n\nExample:\n\n    \n        onPeerTrack((track, stream, peerId) => console.log(`got track from ${peerId}`, track) )\n\n  * ### makeAction(namespace)\n\nListen for and send custom data actions.\n\n    * namespace - A string to register this action consistently among all peers.\n\nReturns an array of three functions:\n\n    1. #### Sender\n\n       * Sends data to peers and returns a promise that resolves when all target peers are finished receiving data.\n\n       * (data, [targetPeers], [metadata], [onProgress])\n\n         * data - Any value to send (primitive, object, binary). Serialization and chunking is handled automatically. Binary data (e.g. Blob, TypedArray) is received by other peer as an agnostic ArrayBuffer.\n\n         * targetPeers - (optional) Either a peer ID (string), an array of peer IDs, or null (indicating to send to all peers in the room).\n\n         * metadata - (optional) If the data is binary, you can send an optional metadata object describing it (see Binary metadata).\n\n         * onProgress - (optional) A callback function that will be called as every chunk for every peer is transmitted. The function will be called with a value between 0 and 1 and a peer ID. See Progress updates for an example.\n\n    2. #### Receiver\n\n       * Registers a callback function that runs when data for this action is received from other peers.\n\n       * (data, peerId, metadata)\n\n         * data - The value transmitted by the sending peer. Deserialization is handled automatically, i.e. a number will be received as a number, an object as an object, etc.\n\n         * peerId - The ID string of the sending peer.\n\n         * metadata - (optional) Optional metadata object supplied by the sender if data is binary, e.g. a filename.\n\n    3. #### Progress handler\n\n       * Registers a callback function that runs when partial data is received from peers. You can use this for tracking large binary transfers. See Progress updates for an example.\n\n       * (percent, peerId, metadata)\n\n         * percent - A number between 0 and 1 indicating the percentage complete of the transfer.\n\n         * peerId - The ID string of the sending peer.\n\n         * metadata - (optional) Optional metadata object supplied by the sender.\n\nExample:\n\n    \n        const [sendCursor, getCursor] = room.makeAction('cursormove') window.addEventListener('mousemove', e => sendCursor([e.clientX, e.clientY])) getCursor(([x, y], peerId) => { const peerCursor = cursorMap[peerId] peerCursor.style.left = x + 'px' peerCursor.style.top = y + 'px' })\n\n  * ### ping(peerId)\n\nTakes a peer ID and returns a promise that resolves to the milliseconds the\nround-trip to that peer took. Use this for measuring latency.\n\n    * peerId - Peer ID string of the target peer.\n\nExample:\n\n    \n        // log round-trip time every 2 seconds room.onPeerJoin(peerId => setInterval( async () => console.log(`took ${await room.ping(peerId)}ms`), 2000 ) )\n\n### selfId\n\nA unique ID string other peers will know the local user as globally across\nrooms.\n\n### getRelaySockets()\n\n(\ud83c\udf0a BitTorrent, \ud83d\udc26 Nostr, \ud83d\udce1 MQTT only) Returns an object of relay URL keys\nmapped to their WebSocket connections. This can be useful for determining the\nstate of the user's connection to the relays and handling any connection\nfailures.\n\nExample:\n\n    \n    \n    console.log(trystero.getRelaySockets()) // => Object { // \"wss://tracker.webtorrent.dev\": WebSocket, // \"wss://tracker.openwebtorrent.com\": WebSocket // }\n\n### getOccupants(config, namespace)\n\n(\ud83d\udd25 Firebase only) Returns a promise that resolves to a list of user IDs\npresent in the given namespace. This is useful for checking how many users are\nin a room without joining it.\n\n  * config - A configuration object\n  * namespace - A namespace string that you'd pass to joinRoom().\n\nExample:\n\n    \n    \n    console.log((await trystero.getOccupants(config, 'the_scope')).length) // => 3\n\n## Strategy comparison\n\none-time setup1| bundle size2| time to connect3  \n---|---|---  \n\ud83c\udf0a BitTorrent| none \ud83c\udfc6| 25K \ud83c\udfc6| \u23f1\ufe0f\u23f1\ufe0f  \n\ud83d\udc26 Nostr| none \ud83c\udfc6| 54K| \u23f1\ufe0f\u23f1\ufe0f  \n\ud83d\udce1 MQTT| none \ud83c\udfc6| 332K| \u23f1\ufe0f\u23f1\ufe0f  \n\ud83d\udd25 Firebase| ~5 mins| 177K| \u23f1\ufe0f \ud83c\udfc6  \n\ud83e\ude90 IPFS| none \ud83c\udfc6| 1MB| \u23f1\ufe0f\u23f1\ufe0f\u23f1\ufe0f  \n  \n1 All strategies except Firebase require zero setup. Firebase is a managed\nstrategy which requires setting up an account.\n\n2 Calculated via Rollup bundling + Terser compression.\n\n3 Relative speed of peers connecting to each other when joining a room.\nFirebase is near-instantaneous while the other strategies are a bit slower to\nexchange peering info.\n\n### How to choose\n\nTrystero\u02bcs unique advantage is that it requires zero backend setup and uses\ndecentralized infrastructure in most cases. This allows for frictionless\nexperimentation and no single point of failure. One potential drawback is that\nit\u02bcs difficult to guarantee that the public infrastructure it uses will always\nbe highly available, even with the redundancy techniques Trystero uses. While\nthe other strategies are decentralized, the Firebase strategy is a more\nmanaged approach with greater control and an SLA, which might be more\nappropriate for \u201cproduction\u201d apps.\n\nLuckily, Trystero makes it trivial to switch between strategies \u2014 just change\na single import line and quickly experiment:\n\n    \n    \n    import {joinRoom} from 'trystero/[torrent|nostr|mqtt|firebase|ipfs]'\n\nTrystero by Dan Motzenbecker\n\n## About\n\n\ud83e\udd1d Build instant multiplayer webapps, no server required \u2014 Magic WebRTC\nmatchmaking over BitTorrent, Nostr, MQTT, IPFS, and Firebase\n\noxism.com/trystero\n\n### Topics\n\njavascript chat mqtt firebase bittorrent serverless webrtc peer-to-peer dapp\nipfs decentralized realtime p2p webtorrent web3 signaling matchmaking pairing\nsignalling nostr\n\n### Resources\n\nReadme\n\n### License\n\nMIT license\n\nActivity\n\n### Stars\n\n929 stars\n\n### Watchers\n\n13 watching\n\n### Forks\n\n72 forks\n\nReport repository\n\n## Releases 9\n\n0.18.0 Latest\n\nFeb 17, 2024\n\n\\+ 8 releases\n\n## Packages 0\n\nNo packages published\n\n## Used by 110\n\n\\+ 102\n\n## Contributors 4\n\n  * dmotz Dan Motzenbecker\n  * jeremyckahn Jeremy Kahn\n  * freehuntx\n  * wkwhwh Marc David\n\n## Languages\n\n  * JavaScript 99.8%\n  * HTML 0.2%\n\n## Footer\n\n\u00a9 2024 GitHub, Inc.\n\nYou can\u2019t perform that action at this time.\n\n", "frontpage": false}
