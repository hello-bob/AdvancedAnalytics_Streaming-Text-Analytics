{"aid": "40169636", "title": "Choosing a Computer Language for a Project", "url": "https://www.johndcook.com/blog/2024/04/23/choosing-a-computer-language-for-a-project/", "domain": "johndcook.com", "votes": 1, "user": "Bostonian", "posted_at": "2024-04-26 14:09:32", "comments": 0, "source_title": "Choosing a Computer Language for a Project", "source_text": "Choosing a Computer Language for a Project\n\n(832) 422-8646\n\nContact\n\n# Choosing a Computer Language for a Project\n\nPosted on 23 April 2024 by Wayne Joubert\n\nJulia. Scala. Lua. TypeScript. Haskell. Go. Dart. Various computer languages\nnew and old are sometimes proposed as better alternatives to mainstream\nlanguages. But compared to mainstream choices like Python, C, C++ and Java\n(cf. Tiobe Index)\u2014are they worth using?\n\nCertainly it depends a lot on the planned use: is it a one-off small project,\nor a large industrial-scale software application?\n\nYet even a one-off project can quickly grow to production-scale, with\naccompanying growing pains. Startups sometimes face a growth crisis when the\nnascent code base becomes unwieldy and must be refactored or fully rewritten\n(or you could do what Facebook/Meta did and just write a new compiler to make\nyour existing code base run better).\n\nThe scope of different types of software projects and their requirements is so\nincredibly diverse that any single viewpoint from experience runs a risk of\nbeing myopic and thus inaccurate for other kinds of projects. With this\ncaveat, I\u2019ll share some of my own experience from observing projects for many\ndozens of production-scale software applications written for leadership-scale\nhigh performance computing systems. These are generally on a scale of 20,000\nto 500,000 lines of code and often require support of mathematical and\nscientific libraries and middleware for build support, parallelism,\nvisualization, I/O, data management and machine learning.\n\nHere are some of the main issues regarding choice of programming languages and\ncompilers for these codes:\n\n1\\. Language and compiler sustainability. While the lifetime of computing\nsystems is measured in years, the lifetime of an application code base can\nsometimes be measured in decades. Is the language it is written in likely to\nsurvive and be well-supported long into the future? For example, Fortran,\nthough still used and frequently supported, is is a less common language thus\nrequiring special effort from vendors, with fewer developer resources than\nmore popular languages. Is there a diversity of multiple compilers from\ndifferent providers to mitigate risk? A single provider means a single point\nof failure, a high risk; what happens if the supplier loses funding? Are the\nlanguage and compilers likely to be adaptable for future computer hardware\ntrends (though sometimes this is hard to predict)? Is there a large customer\nbase to help ensure future support? Similarly, is there an adequate pool of\navailable programmers deeply skilled in the language? Does the language have a\nwell-featured standard library ecosystem and good support for third-party\nlibraries and frameworks? Is there good tool support (debuggers, profilers,\nbuild tools)?\n\n2\\. Related to this is the question of language governance. How are decisions\nabout future updates to the language made? Is there broad participation from\nthe user community and responsiveness to their needs? I\u2019ve known members of\nthe C++ language committee; from my limited experience they seem very\nreasonable and thoughtful about future directions of the language. On the\nother hand, some standards have introduced features that scarcely anyone ever\nuses\u2014a waste of time and more clutter for the standard.\n\n3\\. Productivity. It is said that programmer productivity is limited by the\nability of a few lines of code to express high level abstractions that can do\na lot with minimal syntax. Does the language permit this? Does the language\nstandard make sense (coherent, cohesive) and follow the principle of least\nsurprise? At the same time, the language should not engulf what might better\nbe handled modularly by a library. For example, a matrix-matrix product that\nis bound up with the language might be highly productive for simple cases but\nhave difficulty supporting the many variants of matrix-matrix product provided\nfor example by the NVIDIA CUTLASS library. Also, in-language support for CUDA\nGPU operations, for example, would make it hard for the language not to lag\nbehind in support of the frequent new releases of CUDA.\n\n4\\. Strategic advantage. The 10X improvement rule states that an innovation is\nonly worth adopting if it offers 10X improvement compared to existing practice\naccording to some metric . If switching to a given new language doesn\u2019t bring\nsignificant improvement, it may not be worth doing. This is particularly true\nif there is an existing code base of some size. A related question is whether\nthe new language offers an incremental transition path for an existing code to\nthe new language (in many cases this is difficult or impossible).\n\n5\\. Performance (execution speed). Does the language allow one to get down to\nbare-metal performance rather than going through costly abstractions or an\ninterpreter layer? Are the features of the underlying hardware exposed for the\nuser to access? Is performance predictable? Can one get a sense of the\nperformance of each line of code just by inspection, or is this occluded by\nabstractions or a complex compilation process? Is the use of just-in-time\ncompilation or garbage collection unpredictable, which could be a problem for\nparallel computing wherein unexpected \u201changs\u201d can be caused by one process\nunexpectedly performing one of these operations? Do the compiler developers\nprovide good support for effective and accurate code optimization options?\nHave results from standardized non-cherry-picked benchmarks been published\n(kernel benchmarks, proxy apps, full applications)?\n\nEarly adopters provide a vibrant \u201cearly alert\u201d system for new language and\ntool developments that are useful for small projects and may be broadly\nimpactful. Python was recognized early in the scientific computing community\nfor its potential complementary use with standard languages for large\nscientific computations. When it comes to planning large-scale software\nprojects, however, a range of factors based on project requirements must be\nconsidered to ensure highest likelihood of success.\n\nCategories : Computing Parallel computing Productivity Software development\n\nTags : computer languages software planning software projects\n\nBookmark the permalink\n\n## One thought on \u201cChoosing a Computer Language for a Project\u201d\n\n  1. Mike Anderson\n\n24 April 2024 at 03:54\n\n\u201cCertainly it depends a lot on the planned use: is it a one-off small project,\nor a large industrial-scale software application?\u201d\n\nAn anonymous wise man once told me \u201cThere is no such thing as a one-time\nprogram.\u201d That said, I have often done prototyping with Mathematica, knowing\nfull well that the production version of the application would be implemented\nin something far more portable.\n\n### Leave a Reply\n\nJohn D. Cook, PhD\n\nMy colleagues and I have decades of consulting experience helping companies\nsolve complex problems involving data privacy, applied math, and statistics.\n\nLet\u2019s talk. We look forward to exploring the opportunity to help your company\ntoo.\n\n### John D. Cook\n\n\u00a9 All rights reserved.\n\n(832) 422-8646\n\nEMAIL\n\n", "frontpage": false}
