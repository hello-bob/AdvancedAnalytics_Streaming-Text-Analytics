{"aid": "40081840", "title": "Extensible Language Support in Zed", "url": "https://zed.dev/blog/language-extensions-part-1", "domain": "zed.dev", "votes": 1, "user": "herrington_d", "posted_at": "2024-04-18 23:32:25", "comments": 0, "source_title": "Extensible Language Support in Zed - Part 1", "source_text": "Extensible Language Support in Zed - Part 1\n\n\u2190 Back to Blog\n\n# Extensible Language Support in Zed - Part 1\n\nMax Brunsfeld\n\nApril 18th, 2024\n\nAbout two months ago, @maxdeviant and I began the project of making Zed\nextensible. In a code editor, extensibility can include many features that\nrequire many different capabilities, but for the first phase of the project,\nwe have focused on extensible language support. We want people to be able to\ncode in Zed in any programming language, not just a select few. We've just\nfinished up that first milestone, so it seems like a good time to share what\nwe've done.\n\n## Language Support in Zed\n\nZed has two categories of language-specific features that we made extensible:\n\n  1. In-process syntax-based analysis of individual source files based on Tree-sitter. This requires a Tree-sitter grammar for each supported language, along with a set of Tree-sitter queries that describe how to use that grammar's syntax tree for tasks like syntax highlighting, auto-indent, etc. See my previous blog post for more information on how Zed uses Tree-sitter queries.\n\n  2. External servers that provide semantic understanding via the Language Server Protocol. This requires specifying how to run a given language server, how to install and upgrade that server, and how to adapt its output (completions and symbols) to match Zed's style.\n\nIn this first post, I'm going to focus on the Tree-sitter part. We'll describe\nhow we handled extensible language servers in a follow-up blog post.\n\n## Challenges with Packaging Parsers\n\nThe hard part about letting extensions add Tree-sitter parsers to Zed is that\nTree-sitter parsers are expressed as C code. Grammars are written in\nJavaScript, and converted into C code by the Tree-sitter CLI. Tree-sitter is\ndesigned this way for a variety of reasons. In short, some kind of turing-\ncomplete language is needed, and C code has the useful property that it can be\nconsumed from almost any high-level language via C bindings. But sadly, C code\nis not the most convenient artifact to distribute to end users.\n\nOne possible method of distributing extensions would have been to ship the C\ncode itself, compile it on the user's machine with their C compiler, and\ndynamically load the resulting shared library. This is essentially what we did\nfor Atom (using the Node.js packaging facilities). Other editors that use\nTree-sitter, like Neovim and Helix, also use this same approach.\n\nBut for Zed, we wanted a smooth, safe plugin-installation experience that\ndidn't depend on the user's C compiler. We wanted to make it impossible for an\nextension to crash Zed. Tree-sitter parsers consist mostly of auto-generated C\ncode that is fairly safe, but grammar authors can also write external scanners\nthat contain arbitrary logic, and we had seen crashes due to bugs in third-\nparty external scanners. We would never be able to prevent these kinds of\ncrashes if we loaded extensions directly as shared libraries.\n\n## Obviously, We Used WebAssembly. But How?\n\nYou probably won't be surprised to find out that the solution involved\nWebAssembly. I had already built a WebAssembly binding for Tree-sitter, which\nlets you run Tree-sitter parsers on the web, via a JavaScript API. WebAssembly\n(or wasm for short) is a great format for distributing parsers, because it's\ncross-platform, and it's designed for running untrusted code safely.\n\nIt was not obvious though, how to use wasm builds of parsers in our native\ncode editor.\n\nWhen you run a WebAssembly program, your application provides the program with\nan array of bytes that will serve as its linear memory. The wasm code can then\nonly read or write to those bytes. But in Zed, when running a parser, a lot of\ndata needs to be exchanged. On each keystroke, Zed needs to pass in source\ncode, and the parser needs to return a concrete syntax tree - a data structure\nthat's much larger than the corresponding text. When parsing incrementally,\neach syntax tree shares common structure with the previous syntax tree, and\nZed frequently sends these syntax trees to background threads, where they are\nused for various async tasks.\n\nSo if we ran parsers entirely via WebAssembly, we would need to copy a huge\namount of data out of the wasm memory on every parse. So simply compiling\nTree-sitter and the grammars to wasm would not suffice.\n\nIf we simply compiled all of Tree-sitter to wasm, it would be very expensive\nto copy the syntax tree out of the wasm memory.\n\n## A Hybrid Native + WebAssembly System\n\nWe decided to take advantage of the fact that Tree-sitter parsers are table-\ndriven. Most of the generated C code consists of static arrays that represent\na state machine.\n\nLike other table-driven parsing frameworks, Tree-sitter's parsing is divided\ninto two parts. The lexing phase processes text character-by-character,\nproducing tokens. Each grammar's lexer is implemented as some auto-generated C\nfunctions, and some optional hand-written ones. The parsing phase is more\ncomplex, and is where syntax trees are actually constructed. Crucially,\nparsing is driven entirely by static data.\n\nThe lexing logic for a grammar is encoded as executable code, while the\nparsing logic is encoded as static data.\n\nThis division between the two phases enables a unique architecture in which we\nload a parser from a wasm file, but most of the static data in that wasm file\nis copied out of the wasm linear memory into a native data structure. During\nparsing, we use a WebAssembly engine whenever we need to run a lexing\nfunctions, but all of the rest of the computation is done natively, in exactly\nthe same way as when using a natively-compiled Tree-sitter parser.\n\nTree-sitter uses wasm internally, just for the lexing step. The syntax tree is\nconstructed natively.\n\nLexing is the least expensive part of the parsing process, and is also the\nonly part where custom hand-written code is involved. So in many ways, this\nhybrid native + wasm design gives us the ideal combination of safety and\nperformance.\n\n## Extending the Tree-sitter API\n\nTo enable this new approach to parsing, we added some new primitives to the\nTree-sitter library.\n\nFor background, the Tree-sitter core library provides a Parser type, which is\nused to parse source code, creating Tree objects. To use a parser, you must\nassign it a Language, which is an opaque object generated from a particular\ngrammar, and provided in a separate library for that grammar.\n\n    \n    \n    let mut parser = tree_sitter::Parser::new(); let python_language = tree_sitter_python::language().unwrap(); parser.set_language(&python_language).unwrap(); let tree = parser.parse(\"def secret():\\n return 42\\n\", None).unwrap();\n\nWe added a new type called WasmStore, which integrates with the Wasmtime\nWebAssembly engine and lets you create Language instances from WASM binaries.\nThese language objects work exactly like the normal, native language objects,\nexcept that when using them, your parser needs to have a WasmStore assigned to\nit. This is needed because the wasm store allows parsers to call wasm\nfunctions during lexing.\n\n    \n    \n    let engine = wasmtime::Engine::default(); let mut wasm_store = tree_sitter::WasmStore::new(&engine); const WASM_BYTES: &[u8] = include_bytes!(\"tree-sitter-python.wasm\"); let python_language = wasm_store.load_language(\"python\", WASM_BYTES).unwrap(); parser.set_wasm_store(wasm_store); parser.set_language(&python_language).unwrap();\n\nExcept for that one difference, the languages loaded from WASM behave exactly\nlike the natively-compiled ones. The resulting syntax trees are the same, and\naren't coupled to a wasm store.\n\n## Implementation Highlights\n\nLike the rest of the Tree-sitter library, these new APIs are implemented in C.\nThey use Wasmtime's excellent C API. You can find their full implementation\nhere.\n\nWhen using wasm, you have very low-level control over the details of how\nmodules are linked and loaded. Modules declare imports for several constants\nthat control how the wasm linear memory is laid out - the address where their\nstatic data should be placed, the base address of the call stack, and the\nstart address of the heap. Here is a diagram of how a tree-sitter WasmStore's\nwasm memory is laid out:\n\nThe layout of a Tree-sitter wasm store's linear memory\n\nModules also declare imports for all of the functions that they depend on. As\nmentioned above, Tree-sitter grammars can include hand-written source files\ncalled external scanners. These files often use functions from the C standard\nlibrary - character-categorization functions like iswalpha/iswspace, string-\nhandling functions like strlen/strncmp, and memory-management functions like\nmalloc/free for carrying small amounts of state. To handle imports like these,\nthe Tree-sitter library embeds a small wasm blob containing a subset of\nfunctions from libc that are available for external scanners.\n\nOne cool thing about providing our own mini-libc is that we don't need to use\nthe standard versions of the memory-allocation functions malloc, free, etc. We\nknow that the memory allocated by external scanners is only needed for the\nduration of a single parse, so we implemented our own tiny malloc library that\nuses a bump-allocation. This allocator has much less overhead than a general-\npurpose malloc implementation, and requires much less wasm code. Best of all,\nit makes it impossible for external scanners to cause memory leaks! We can\nsimply reset the entire wasm heap at the beginning of each parse.\n\n## Using Language Extensions\n\nAs soon as we shipped this feature, the Zed community began shipping language\nextensions. The current number of language extensions available in Zed's\nextension store is at 6\ufe0f\u20e37\ufe0f\u20e3 and counting. These languages support all of\nZed's syntax-aware features: syntax-aware selection, the outline view, syntax-\nbased auto-indent, and of course syntax highlighting.\n\nTo browse the extensions, click Zed > Extensions in the application menu. If\nthere's a language that you use that isn't yet supported, we invite you to\nopen a PR on our extensions repository. Or just open an issue and ask for\nhelp. The docs for authoring an extension are in the repo.\n\n## Closing\n\nUsing wasm to package Tree-sitter grammars has worked wonderfully for Zed, and\nthe Wasmtime engine has been fantastic to use. Tree-sitter grammars are just\none piece of Zed's extension system. In a later post, we'll talk about all of\nthe other ways we're using wasm to make Zed extensible. Thanks for reading!\n\n## Interested in trying Zed out?\n\nYou can try Zed today on macOS. Download now!\n\nMax Brunsfeld\n\n04/18/24\n\n\u00a9 2024 Zed Industries.\n\nEULA \u00b7 Attributions \u00b7 Sign in\n\n#### Product\n\n  * Download\n  * FAQ\n  * Roadmap\n  * EULA\n  * CLA\n\n#### Developers\n\n  * Docs\n  * Releases\n  * GitHub\u2197\n  * Status\u2197\n\n#### Community\n\n  * Blog\n  * Feedback\n  * Discussions\u2197\n  * Merch\u2197\n\n#### Company\n\n  * About\n  * Team\n  * Jobs\n  * Twitter\u2197\n\n", "frontpage": false}
