{"aid": "40223617", "title": "AnyCable for Ruby on Rails: How Does It Improve over Action Cable?", "url": "https://blog.appsignal.com/2024/05/01/anycable-for-ruby-on-rails-how-does-it-improve-over-action-cable.html", "domain": "appsignal.com", "votes": 1, "user": "amalinovic", "posted_at": "2024-05-01 14:20:10", "comments": 0, "source_title": "AnyCable for Ruby on Rails: How Does it Improve over Action Cable? | AppSignal Blog", "source_text": "AnyCable for Ruby on Rails: How Does it Improve over Action Cable? | AppSignal Blog\n\n  * Features\n\n### Monitoring features\n\n    * Error tracking\n\n    * Performance monitoring\n\n    * Host monitoring\n\n    * Anomaly detection\n\n    * Uptime monitoring\n\n    * Metric dashboards\n\n    * Workflow\n\n    * Log management\n\n    * Automated Dashboards\n\n  * Languages\n\n### Supported Languages\n\n    * Ruby (on Rails) APM\n\n    * Elixir APM\n\n    * Node.js APM\n\n    * JavaScript Error Tracking\n\n    * Python APM\n\n  * Learn\n  * Docs\n  * Blog\n  * Pricing\n\n  * Login\n  * Start free trial\n\nMenu\n\nruby\n\n# AnyCable for Ruby on Rails: How Does it Improve over Action Cable?\n\nAbiodun Olowode on May 1, 2024\n\nIn modern web applications, real-time communication has become more than a\nfeature: it's gradually evolved into a necessity. Users expect instant\nupdates, live interactions, and dynamic content.\n\nIn Rails applications, Action Cable has long been the go-to solution,\nharnessing WebSockets to fulfill these demands. In this article, we introduce:\n\n  * The basics of WebSockets\n  * How Action Cable enables real-time communication via WebSockets\n  * Why AnyCable was created\n  * How to get AnyCable up and running\n  * The improvements AnyCable brings to the table\n\nLet's get started!\n\n## The WebSocket Technology\n\nThe WebSocket technology was introduced in 2011 with the publication of RFC\n6455, titled \"The WebSocket Protocol\". This standardized protocol facilitated\nthe establishment of persistent, real-time communication channels between web\nbrowsers and servers, allowing for more efficient and continuous data exchange\ncompared to traditional HTTP.\n\nThe WebSocket technology enables continuous bi-directional communication\nbetween clients and servers, a stark departure from the request-response model\nof HTTP (where connections terminate after each exchange). This persistence in\ncommunication proves pivotal for real-time applications like chat platforms\nand gaming systems.\n\nBefore the introduction of WebSocket technology, many applications often\nrelied on a technique called polling. Polling involves the client repeatedly\nsending requests to the server at specified intervals to check for updates or\nnew information. While this method allowed for some level of real-time\nupdates, it was less efficient than WebSocket communication. Polling could\nlead to unnecessary server load and increased latency, as the client had to\ninitiate a new request each time it wanted to retrieve updated data.\n\nWebSocket technology addressed these limitations by establishing a persistent\nconnection between the client and the server, enabling more immediate and\nefficient data transmission without the need for constant polling. This shift\nsignificantly improved the responsiveness and real-time capabilities of\napplications, providing a seamless and dynamic experience for users,\nparticularly in scenarios demanding instant, up-to-the-moment information.\n\nBoth Action Cable and AnyCable harness the power of web sockets to furnish\nRails applications with real-time updates, liberating users from the\ncumbersome need to refresh pages or poll for the latest information.\n\n## Action Cable and Real-time Communication\n\nAction Cable enables the incorporation of real-time features into a Rails\napplication via web sockets. This real-time communication happens between the\nclient side (browser) and the Rails server. A few things are important to\nnote:\n\n  * A connection forms the foundation of this client-server relationship. For every WebSocket connection, Action Cable creates one connection instance.\n  * A channel refers to a communication pathway that allows clients to subscribe to and receive updates about specific topics or categories of information, e.g., BookChannel, MovieChannel, SportsChannel.\n  * A subscriber is a client subscribed to a channel to receive information.\n  * Broadcasting is when the server publishes information that is transmitted by the relevant channel to the subscribed client/s.\n  * A stream is the route or pathway through which broadcasts get to the subscribers. By using stream_from, subscriptions can be made for broadcasting.\n\nWhen a connection is established between the client and the server, Action\nCable creates a connection object for that connection. With this connection,\nthe client can subscribe to one or more channels. Action Cable broadcasts\nupdates to all subscribed clients via their respective channels.\n\nA simple example is a browser view showing a library book list that updates\nwhen a book is added.\n\nshell\n\n    \n    \n    # create the rails application rails new book_list cd book_list # create the needed controller and model rails g controller books index rails g model Book name rails db:migrate # change the development Action Cable adapter from Async (the default one) to Redis rails turbo:install:redis # start the redis server redis-server # start the rails server rails s\n\nTo get a real-time update on the book model, we employ Action Cable for\nbroadcasting the updates. We set up Action Cable to broadcast these updates to\na channel called \"books\". Via Turbo Streams, we create the subscriber to this\nchannel and deliver the updates.\n\nruby\n\n    \n    \n    # app/models/books.rb class Book < ApplicationRecord broadcasts_to -> (book) { :books } # Broadcasts all the activities on this model -> create, update, destroy. end\n\nWe can now render the list of books:\n\nruby\n\n    \n    \n    # app/views/rooms/_book.html.erb <div id=<%= dom_id(book) %>> <%= book.name %> </div>\n\nruby\n\n    \n    \n    # app/views/books/index.html.erb <h1>Books</h1> <%= turbo_stream_from \"books\" %> <div id=\"books\"> <%= render @books %> </div>\n\nAs seen below, different actions trigger a broadcast, and Action Cable\nbroadcasts to the channel specified \u2014 \"books\". The view is also subsequently\nupdated to reflect these updates.\n\nruby\n\n    \n    \n    irb> Book.create(name: \"The Avatar\") Rendered books/_book.html.erb (Duration: 0.0ms | Allocations: 11) [ActionCable] Broadcasting to books: \"<turbo-stream action=\\\"append\\\" target=\\\"books\\\"><template><div> The Avatar </div></template></turbo-stream>\" => #<Book:0x0000000107c13358> irb> book_1 = Book.find(1) irb> book_1.update(name: \"The Demo\") Rendered books/_book.html.erb (Duration: 0.0ms | Allocations: 11) [ActionCable] Broadcasting to books: \"<turbo-stream action=\\\"replace\\\" target=\\\"book_1\\\"><template><div> The Demo </div></template></turbo-stream>\" => true irb> book_1.destroy [ActionCable] Broadcasting to books: \"<turbo-stream action=\\\"remove\\\" target=\\\"book_7\\\"></turbo-stream>\" => #<Book:0x0000000107bd2948\n\n\u2193 Article continues below\n\n#### Is your app broken or slow? AppSignal lets you know.\n\nMonitoring by AppSignal \u2192\n\nIn Rails, integrating Action Cable (and, as a result, real-time updates into\nan application) is quite easy: even a beginner can get up and running in\nminutes. With Action Cable, we can manage connections, channels, and\nbroadcasting to clients without worrying about the underlying WebSocket\ndetails. It also uses the same connection for multiple subscriptions, reducing\nthe overhead of creating new connections for each new real-time update.\n\n## Why AnyCable for Ruby on Rails?\n\nAction Cable is built on Ruby and has significant differences from other\nservers written in Golang and Erlang. Check out a detailed summary of AnyCable\nvs. Action Cable benchmark findings. Here are the key results:\n\n  * Action Cable consumes approximately 4 times more memory when handling 20 thousand idle clients without subscriptions or transmissions.\n  * Action Cable requires much higher CPU usage.\n  * Action Cable takes around 10 times longer to broadcast to 10,000 clients. Starting at 1 second for a thousand clients, the time required increases by 1 second for every additional thousand clients.\n\nThe AnyCable WebSocket Server was created to combine the beauty of Action\nCable with the performance benefits gained from Golang. AnyCable handles\nWebSockets on a different server called AnyCable-Go, effectively reducing the\nburden on your primary web application.\n\nIn addition to performance advantages, AnyCable offers resumability. If a\nclient becomes disconnected from the server (e.g., due to network issues\nleading to an offline status), upon reconnection, the client will receive all\nthe messages missed during the disconnection. They are also not required to\nre-subscribe as sessions are recovered. See a brief demo of the resumability\nfeature.\n\nView detailed information on the recent enhancements to AnyCable.\n\n## Integrating AnyCable\n\nLet's replace Action Cable with AnyCable in our BookList example.\n\nInstall the gem:\n\nshell\n\n    \n    \n    # add the gem to your gemfile gem \"anycable-rails\" # install it bundle install\n\nNext, run the setup generator.\n\nThis generator is interactive and asks questions about:\n\n  * The type of development environment in use.\n  * How you would like to install the AnyCable-Go websocket server.\n  * If Heroku is being used for deployment.\n  * If JWT is the intended means of authentication.\n  * If you want a Procfile.dev file.\n\nAll of this information helps to reduce the amount of manual work you need to\ndo.\n\nshell\n\n    \n    \n    rails g anycable:setup\n\nIf you did say \"yes\" to the generation of a Procfile.dev, it would look\nsomething like this:\n\ntext\n\n    \n    \n    # Procfile.dev web: bin/rails s anycable: bundle exec anycable ws: bin/anycable-go --port=8080\n\nHence, you do not need to manually run the rest of the commands below.\n\nRun the AnyCable RPC server:\n\nshell\n\n    \n    \n    bundle exec anycable\n\nRun the WebSocket server:\n\nshell\n\n    \n    \n    anycable-go --port=8080\n\nRestart the Rails server.\n\nIn the cable.yml file, you'll find that the adapter changes to any_cable if\nthe ACTION_CABLE_ADAPTER environment variable is not set.\n\nshell\n\n    \n    \n    adapter: <%= ENV.fetch(\"ACTION_CABLE_ADAPTER\", \"any_cable\") %>\n\nIn all the $env.rb files, you'll find the Action Cable URL set as:\n\nshell\n\n    \n    \n    config.action_cable.url = ActionCable.server.config.url = ENV.fetch(\"CABLE_URL\", \"/cable\") if AnyCable::Rails.enabled?\n\nIn the any_cable.yml file, the Redis channel is set to __anycable__. You can\nconfirm this in the terminal via:\n\nshell\n\n    \n    \n    redis-cli PUBSUB CHANNELS # 1) \"__anycable__\"\n\nRead more about the AnyCable configuration.\n\nIn the Rails server, you'll find a routing error related to the /cable\nendpoint. You'll also find that, when you filter by websockets in the Network\ntab of the browser, the Request URL for cable is ws://localhost:3000/cable,\nwhich is wrong. We should be attempting to connect to\nws://localhost:8080/cable, the value of config.action_cable.url.\n\nTo fix this, the action_cable_meta_tag has to be added to the\napplication.html.erb file.\n\nruby\n\n    \n    \n    # application.html.erb <head> # ... <%= action_cable_meta_tag %> # ... </head>\n\nThis resets the url to the set value. At this point, any broadcasted stream\nwill show up!\n\n## Swapping Action Cable for AnyCable in Ruby\n\nTo enable resumability, AnyCable utilizes the Action Cable Extended Protocol,\nwhich is implemented by the AnyCable server version 1.4 and later. This\nprotocol is inherently supported by the AnyCable JS client.\n\nTo integrate this with Turbo Streams, it's necessary to swap out the default\nAction Cable client for the AnyCable client. However, when using the\n@hotwired/turbo-rails package, the Action Cable getConsumer function is\ninvoked before the setConsumer function during the initial page load, leading\nto the consumer not being overridden, and two web socket connections being\nopened. The @anycable/turbo-stream package was created to handle this (read\nadditional details about this issue).\n\nHere's the procedure for this swap.\n\nAdd the @anycable/web and @anycable/turbo-stream packages:\n\nshell\n\n    \n    \n    bin/importmap pin @anycable/web @anycable/turbo-stream\n\nThis pins the stated packages, along with @anycable/core, @hotwired/turbo, and\nnanoevents to your importmap.rb file.\n\nCreate the anycable client:\n\njavascript\n\n    \n    \n    // app/javascript/cable.js import { createCable } from \"@anycable/web\"; export default createCable();\n\nRefer to this as the new \"cable\" client:\n\nruby\n\n    \n    \n    # config/importmap.rb pin \"cable\", to: \"cable.js\", preload: true\n\nStart the new cable client:\n\njavascript\n\n    \n    \n    // app/javascript/application.js // We no longer need @hotwired/turbo-rails import \"@hotwired/turbo\"; import { start } from \"@anycable/turbo-stream\"; import cable from \"cable\"; start(cable);\n\nWith this, we can restart our server, and the consumer/client is replaced with\nAnyCable.\n\nRead more about advanced configurations for the Turbo Streams package.\n\nWith the client replaced, resumability can be implemented.\n\nWith resumable sessions, the supported adapters are http and redisx (if you\nuse Redis). It is, however, important to note that the broker preset command\nautomatically sets the adapter as http. Hence, when using redisx, it must\nspecified explicitly like so:\n\nshell\n\n    \n    \n    $ anycable-go --broker=memory --broadcast_adapter=redisx\n\nThere you go! You should have resumable sessions working!\n\n## Community Adoption and Feedback\n\nAnyCable has existed for several years and has gained widespread adoption\namong numerous organizations. Adopters have cited several compelling reasons\nfor its attractiveness, including:\n\n  * Seamless migration without the need for architectural changes.\n  * No requirement to modify Action Cable channels or connections.\n  * Utilization of a dedicated server for WebSockets.\n  * Ability to handle a substantial number of concurrent connections without encountering any problems.\n\nSee a few testimonials from satisfied users.\n\n## Wrapping Up\n\nIn this post, we've seen that AnyCable offers performance enhancements to\nAction Cable and can be used as an alternative when dealing with a large\nnumber of connections or high traffic.\n\nWith recent improvements to AnyCable (such as the introduction of reliable\nstreams), AnyCable has become a solid choice regardless of performance\nconcerns. It supports broadcasting and subscription confirmation, thereby\nmaking it consistent and reliable. It can also be used in non-Rails\napplications, and to power serverless JavaScript applications.\n\nOverall, AnyCable is a reliable choice for modern web applications and\nsupports a variety of servers, allowing for greater flexibility in\ndevelopment.\n\nHappy coding!\n\nP.S. If you'd like to read Ruby Magic posts as soon as they get off the press,\nsubscribe to our Ruby Magic newsletter and never miss a single post!\n\n# Share this article\n\nRSS\n\n# Abiodun Olowode\n\nOur guest author Abiodun is a software engineer who works with Ruby/Rails and\nReact. She is passionate about sharing knowledge via writing/speaking and\nspends her free time singing, binge-watching movies, and watching football\ngames.\n\nAll articles by Abiodun Olowode\n\nBecome our next author!\n\nFind out more\n\n# Magicians never share their secrets. But we do. Subscribe to our Ruby Magic\nemail series and get in-depth Ruby articles.\n\n# AppSignal monitors your apps\n\nAppSignal provides insights for Ruby, Rails, Elixir, Phoenix, Node.js, Express\nand many other frameworks and libraries. We are located in beautiful\nAmsterdam. We love stroopwafels. If you do too, let us know. We might send you\nsome!\n\nDiscover AppSignal\n\n## Features\n\n  * Error tracking\n\n  * Performance monitoring\n\n  * Host monitoring\n\n  * Anomaly detection\n\n  * Uptime monitoring\n\n  * Metric dashboards\n\n  * Workflow\n\n  * Log management\n\n  * Automated Dashboards\n\n## Resources\n\n  * Plans & pricing\n\n  * Documentation\n\n  * Blog\n\n  * Customer Stories\n\n  * Compare AppSignal to Datadog\n\n  * Compare AppSignal to New Relic\n\n  * Changelog\n\n  * Learning Center\n\n  * Why AppSignal\n\n## Support\n\nDo you need help, have a feature request or just need someone to rubber duck\nwith? Get in touch with one of our engineers.\n\n  * Contact us\n\n  * Live chat\n\n  * Status\n\n  * Security\n\n## About us\n\nAppSignal is located in the beautiful Netherlands. We love stroopwafels. If\nyou do too, let us know. We might send you some!\n\n  * About\n\n  * Jobs\n\n  * Write for Our Blog\n\n  * Diversity\n\n  * Open Source\n\n  * Twitter\n\n## Languages\n\n  * Ruby\n\nActive Record, Capistrano, Delayed::Job, Garbage Collection, Global VM Lock,\nGrape, GraphQL, Hanami, MongoDB, Padrino, Puma, Que, Rake, Resque, Ruby on\nRails, Shoryuken, Sidekiq, Sinatra, Webmachine\n\n  * Elixir\n\nEcto, Erlang, Finch, Oban, Phoenix, Plug\n\n  * Node.js\n\nExpress, Fastify, fs Module, GraphQL, Knex.js, Koa, MongoDB, Mongoose, MySQL,\nNestJS, Next.js, PostgreSQL, Prisma, Redis, Remix, Restify\n\n  * JavaScript\n\nReact, Vue, Angular, Ember, Preact, Stimulus\n\n  * Python\n\nCelery, Django, FastAPI, Flask, Jinja2, Psycopg2, Redis, Request, Starlette,\nWSGI and ASGI\n\n  * Terms & Conditions\n  * Privacy Policy\n  * Cookie Policy\n  * GDPR compliance\n  * Contact us / Imprint\n\n", "frontpage": false}
