{"aid": "40081529", "title": "Abilities for the Monadically Inclined", "url": "https://www.unison-lang.org/docs/fundamentals/abilities/for-monadically-inclined/", "domain": "unison-lang.org", "votes": 2, "user": "twoodfin", "posted_at": "2024-04-18 22:43:08", "comments": 0, "source_title": "Abilities for the monadically inclined \u00b7 Unison programming language", "source_text": "Abilities for the monadically inclined \u00b7 Unison programming language\n\n#\n\nWelcome\n\n  * Welcome\n  * Quickstart\n  * What problems does Unison solve\n  * The big idea\n  * Unison at a glance\n  * A tour of Unison\n  * Introducing Unison projects\n\n  * Exercises\n\n#\n\nLanguage fundamentals\n\n  *     * Values and functions\n    *       * Terms\n      * Common collections\n      * Functions\n      * Reading type signatures\n      * Defining operators\n      * Operators for function application\n      * Delayed computations\n  *     * Control flow\n    *       * If, then, and else\n      * Pattern matching part 1\n      * Pattern matching part 2\n      * Looping\n      * Error handling with data types\n  *     * Data types\n    *       * Unique and structural types\n      * Record types\n  *     * Abilities\n    *       * Mental model\n      * Using abilities part 1\n      * Using abilities part 2\n      * Error handling with abilities\n      * Writing ability handlers\n      * Abilities for monadically inclined users\n      * Ability FAQ's\n\n#\n\nUsage Topics\n\n  * Updating code and dependencies\n  * Running a program\n  * Documentation\n  * Testing\n  * Transcripts\n  * Structural find and replace\n  * FAQ's\n  * Bibliography\n\n#\n\nUnison Codebase Manager\n\n  *     * Codebase organization\n    *       * Projects quickstart\n      * Projects library migration\n      * Unison project workflows\n      * Project FAQ's\n      * Codebase organization\n  *     * Workspace setup\n    *       * Editor setup\n      * Code hosting with Unison Share\n      * Using the local codebase UI\n      * Add your author and license\n      * UCM command reference\n\n#\n\nLanguage Reference\n\n  * Top-level declarations\n  *     * Term declarations\n    *       * Type signatures\n      * Term definition\n      * Operator definitions\n  * Ability declaration\n  *     * User-defined data types\n    *       * Structural types\n      * Unique types\n      * Record types\n  *     * Expressions\n    *       * Basic lexical forms\n      * Identifiers\n  * Name resolution and the environment\n  * Blocks and statements\n  *     * Literals\n    *       * Documentation literals\n      * Escape sequences\n  * Comments\n  * Type annotations\n  * Parenthesized expressions\n  *     * Function application\n    *       * Syntactic precedence of operators and prefix function application\n  * Boolean expressions\n  *     * Delayed computations\n    *       * Syntactic precedence\n  * Destructuring binds\n  *     * Match expressions and pattern matching\n    *       * Blank patterns\n      * Literal patterns\n      * Variable patterns\n      * As-patterns\n      * Constructor patterns\n      * List patterns\n      * Tuple patterns\n      * Ability patterns (orRequestpatterns)\n      * Guard patterns\n  * Hashes\n  *     * Types\n    *       * Type variables\n      * Polymorphic types\n      * Scoped type variables\n      * Type constructors\n      * Kinds of Types\n      * Type application\n      * Function types\n      * Tuple types\n      * Built-in types\n      * Built-in type constructors\n      * User-defined types\n  *     * Abilities and ability handlers\n    *       * Abilities in function types\n      * The typechecking rule for abilities\n      * User-defined abilities\n      * Ability handlers\n      * Pattern matching on ability constructors\n  * Use clauses\n\n#\n\nLearning Labs\n\n  *     * Wordle clone\n    *       * Codebase setup\n      * Lab breakdown\n      * Core logic\n      * Colorize results\n      * Validation\n      * Game loop\n      * Challenge task\n      * Other challenges\n\n# Abilities for the monadically inclined\n\nThis section covers the purpose of monads, their alternatives, and why you\nmight want to use abilities.\n\n## How we ended up in the world with monads\n\nLittle-known fact: Monads were introduced into functional programming\nbecauseHaskell is lazy (non-strict).Before we look into Haskell, let's look at\nstrict languages.\n\nMainstream languages (Java, JavaScript, Python, etc.) are based on strict\nevaluation:\n\n  * the expressions are evaluated when they are bound to a name;\n  * the function arguments are evaluated before they're applied to a function.\n\nLet's start with a simple snippet in a strict pseudo-language:\n\n    \n    \n    fun second(a: Int, b: Int, c: Int): Int = { println(\"Ignore everything and return second\"); b }\n    \n    \n    let c = { println(\"Evaluating C\"); 3 } // [1] let result = second( { println(\"Evaluating A\"); 1 }, // [2] { println(\"Evaluating B\"); 2 }, // [3] c ) println(result)\n\nIn this example,cis evaluated and printed first, thena,thenb,and so on:\n\n    \n    \n    Evaluating C Evaluating A Evaluating B Ignore everything and return second 2\n\nSuch an evaluation strategy, roughly speaking, allows us to read code in\nsequential order: up to down, left to right. This might be taken for granted,\nbut we can show/observe this because theside-effects(like printing to the\nconsole)are executedduring theevaluationof the expression where they are\ndefined.\n\nOn the other hand, having this \u201cnatural\u201d evaluation order and tying execution\nto evaluation the same way is not an option in Haskell. Haskell is non-strict.\nIn a similar snippet, \u201ca\u201d and \u201cc\u201d are never used nor evaluated.\n\n    \n    \n    second a b c = b\n    \n    \n    result = ???\n\nWe won't try to translate the rest of the snippet to Haskell \u2014 it wouldn't\nmake much sense. The non-strictness raises too many questions. Would it even\nprintEvaluating AorEvaluating C?If so, when? Bothaandcare never used! If we\ncall thissecondfunction multiple times, should we printEvaluating\nAorEvaluating Cmultiple times? It's non-strict! And so on.\n\nLuckily for us, we can avoid philosophizing by using monads! The idea is that\nwe can embed thesenative side-effectsin a data type and describe the\nsequencing using functions.\n\nFor example, we can use theputStrLnfunction that returnsIO:\n\n    \n    \n    second a b c = putStrLn \"Ignore everything and return second\" >>= \\_ -> return b main :: IO () main = putStrLn \"Evaluating C\" >>= \\_ -> return 3 >>= \\c -> putStrLn \"Evaluating A\" >>= \\_ -> return 1 >>= \\a -> putStrLn \"Evaluating B\" >>= \\_ -> return 2 >>= \\b -> second a b c >>= \\result -> putStrLn (show result)\n\nWhen we run this Haskell program, we once again see:\n\n    \n    \n    Evaluating C Evaluating A Evaluating B Ignore everything and return second 2\n\nOkay, but why are we using monads and monad-like things outside of Haskell \u2014\nwhere we don't have \u201cthis laziness issue\u201d? Turned out that monads are great\nnot just for modeling native effects but also forany customoruser-defined\neffect.\n\n### Control flow\n\nThe actual superpower of monads is the embedding of control flow.In other\nwords, we can abstract control flow (and various patterns) as datatypes and\nuse functions over values.\n\nControl flow is the order of execution \u2014 the path a program takes, based on\ninstructions like conditions, loops, and function calls. For instance, do X,\nthen do Y, and depending on some condition do S or Z (usingif/then/else):\n\nIn traditional programming languages, the set of control flow patterns is\nfixed. Expanding it requires additional features, such\nastry/catch,whileandforloops,asyncandawait,and so on.\n\nSometimes, we can represent complex patterns using simpler building blocks;\nfor example, we can represent loops using conditionals (akaif/then/else):\n\n    \n    \n    fun loop(counter: Int, iterations: Int) = if counter >= max_iterations // Do something else // Do something else loop(counter + 1, iterations)\n\nWriting loops from scratch quickly becomes cumbersome. So, usually, we'll get\nbuilt-in loops.\n\nAnother example is checking if the value exists (checking\nfornull,nil,whatever). It can be implemented using a simple check:\n\n    \n    \n    String result = \"\"; if (album != null) { result = album.getLast().toString(); } else { result = \"missing\"; }\n\nIt also doesn't scale well:\n\n    \n    \n    String result = \"\"; if (artist != null && artist.getDiscography() != null && artist.getDiscography().getAlbums() != null && artist.getDiscography().getAlbums().getLast() != null) { result = artist.getDiscography().getAlbums().getLast().toString(); } else { result = \"missing\"; }\n\nThat's why languages like Kotlin and Rust provide operators or special syntax\nto safely chain and deal with nullable values:\n\n    \n    \n    artist?.discography?.albums?.last?.toString() ?: \"missing\"\n    \n    \n    artist?.discography?.albums?.last.map(|album| album.to_string())\n\nWhich are pretty much monads in disguise. We represent optionality as\ndatatypes and use functions overvalues.And it's not just optionality. We can\nmodel various concepts (such as exceptions, iterating, sync / async, parsing,\nfinalizing or closing resources, dependency injection, and cancellation) with\nmonads and monad-like things:\n\n  * doSomething.handleErrorWith(doSomethingElse)\n  * listOfItems.traverse(item => persistToDB(item))\n  * (fetchFromOneService, fetchFromAnotherDataBase).parMapN(doSomethingWithResult)\n\nThe largest recent\u201cmonadization\u201dwe can observe in strict and mainstream\nlanguages is aroundasynchronous programming:Reactive Streams in Java, Futures\nin Scala, Promises in JavaScript and many other places.\n\nEventually, languages catch up and acquire some sort of async/await syntax or\nlightweight threads, which replace monads (and monad-like things). But it\ntakes time. For example, Java finally obtained virtual threads (seeProject\nLoom),but we have been doing asynchronous programming in Java thanks to\n\u201cmonads\u201d for more than 10 years already!\n\nThis is the real superpower of monads.This is why we use monads! They allow\nus, developers, to have more control over the flow of the program.\n\n## The costs of monads\n\nHowever, let's not lie to ourselves, this is not the nicest snippet of code:\n\n    \n    \n    second a b c = putStrLn \"Ignore everything and return second\" >>= \\_ -> return b main :: IO () main = putStrLn \"Evaluating C\" >>= \\_ -> return 3 >>= \\c -> putStrLn \"Evaluating A\" >>= \\_ -> return 1 >>= \\a -> putStrLn \"Evaluating B\" >>= \\_ -> return 2 >>= \\b -> second a b c >>= \\result -> putStrLn (show result)\n\nLook at all the plumbing we have to do with monads. We describe the sequencing\nof effects using explicit combinators. It's nice that we have unified syntax\nfor various effects (`pure`/`return`,flatMap/`bind`,etc.), but it's less nice\nthat we have to deal with all the noise and syntax overhead. It\u2019s also a\ncognitive overhead! We wouldn't have the phenomenon of monad tutorials and\nhate towards monads if it wasn't the case.\n\nAnd let's not even talk about monad transformers and problems with mixing\neffects \ud83d\ude16\n\nDirect style (code without monads) is straightforward. Effects are executed\nduring the evaluation of an expression. Most of the code is just do-this-do-\nthat:\n\n    \n    \n    // execute foo and pass the result to bar let x = foo() let y = bar(x)\n\nSometimes, if we need to prevent execution, we can explicitly suspend\nevaluation:\n\n    \n    \n    // pass the foo itself let doFoo = () => foo let y = retry3Times(doFoo)\n\nIn this example, we don't want to evaluatefooand don't want to execute its\neffects, because we want the retry function to do that.\n\nIn the monadic world,foois alreadydoFoo\u2014 it's already suspended. We can\npassthingsto functions, return them as results, and so on:\n\n    \n    \n    // pass the foo itself retry3Times(foo)\n\nIt's amazing for building control flows and writing composable code, but we\nend up juggling two layers all the time: the layer of constructing it and the\nlayer of when it will execute.\n\n    \n    \n    // pass the result of foo to bar foo >>= bar\n\n\ud83e\udde0Note that in a strict language, using monads can also trip up advanced\npeople. For example, this causes aStackOverflowErrorin Scala with cats:def bar\n= foo *> bar\n\nThis is taxing on an untrained brain. This is where we lose people.\n\nIt might hurt to admit, but because most of the code is plain do-this-do-that,\non average, it's is simpler to write and readdirect-stylecode because thinking\nabout one level at a time is less demanding than thinking about two.\n\n### Monads vs. Direct Style\n\nDirect style is simple, yes, but only when it's possible. Each feature (or\ncontrol-flow mechanism) needs to be supported by the language and usually\ncomes with its own syntax.\n\nAnother trade-off is effects tracking: the effects are not typed and it's not\nas painful to mix different effects.\n\nOn the one hand, it's still easier to teach; on the other hand, it comes with\nannoying properties such as a lack ofreferential transparencyand some presence\noffunction coloring(depends on the particular implementation).\n\nThe latter can be frustrating with monads as well. Have you ever had to\nreplace a bunch ofmapswithtraversewhen you introduce one additional monad\n(e.g., adding a log) in a deeply nested function?\n\n    \n    \n    def one(str: String): String def two(y: String): Option[String] = y.some.map(one(_)) def three(x: Option[String]): Option[String] = x.flatMap(two(_))\n    \n    \n    // if String becomes IO[String] def one(str: String): IO[String] // map becomes traverse def two(y: String): IO[Option[String]] = y.some.traverse(one(_)) // map becomes traverse def three(x: Option[String]): IO[Option[String]] = x.flatTraverse(two(_))\n\n\"Monads\"| \"Direct Style\"  \n---|---  \nArbitrary/User-defined Effects| \ud83d\udc4d| \ud83d\udc4e\ud83d\udc4e\ud83d\udc4e  \nSyntax| Unified, but has plumbing overhead| O(N) \u2014 each feature requires\ncustom syntax  \nTeachability| \ud83d\udc4e\ud83d\udc4e\ud83d\udc4e| \ud83d\udc4d  \nFamiliarity| \ud83d\udc4e| \ud83d\udc4d  \nTyped Effects| typed| not typed  \nEffects mixing| \ud83d\udc4e| \ud83d\udc4d  \nFunction coloring| some (e.g., map vs traverse)| some (depends on the\nimplementation)  \nReferential transparency| \ud83d\udc4d\ud83d\udc4d\ud83d\udc4d| \ud83d\udc4e\ud83d\udc4e  \n  \nSo, can we do better?\n\n### The worst of both worlds? Mixed styles\n\nNaturally, we want to have our cake and eat it too, so we wind up with a mix\nboth \u2014 the cons of both! We are stuck in this world because we want thepower\nof monadsto embed user-defined effects and control flows, but at the same\ntime, we never handled thehate of monads.\n\n\ud83c\udfa8Note that a mix of styles isn't necessarily a bad thing. A bad thing is\nhaving no choice or being stuck in a local optimum. For instance, Unison\nallowserror handling with abilitiesanddata types.\n\nSome effects are controlled by evaluation (direct style), and some \u2014 by\nexplicit combinators (monadic style). As a result, we lose both the immediacy\nof the former and the systematic clarity of the latter.\n\nHowever, we don't have to stay here.\n\n## The best of both worlds? Abilities\n\nMeetabilities\u2014 Unison's implementation of direct-style algebraic effects, also\nknown aseffect handlersand ambiguosly asalgebraic effects.\n\n\ud83d\udcccActually, they are not very well known. That's why they are known by\ndifferent names and come in many forms.\n\nLet's start with division:\n\n    \n    \n    1 / 0\n    \n    \n    Encountered exception: divide by zero\n\nWe can build a safer version by utilizingExceptionability:\n\n    \n    \n    safeDiv1 : Nat -> Nat ->{Exception} Nat\n    \n    \n    safeDiv1 : Nat -> Nat ->{Exception} Nat safeDiv1 a b = use Nat / == if b == 0 then Exception.raise (Generic.failure \"Oops. Zero\" b) else a / b\n\nWe use theException.raiseconstructor to capture failure details (which aren't\nvery interesting in this case). If we try to naively run/evaluate it, we get a\ncompilation error:\n\n    \n    \n    .> safeDiv 6 3\n    \n    \n    The expression in red needs the {Exception} ability, but this location does not have access to any abilities.\n\nWe can use thecatchhandler,which translates theExceptioninto a value of\ntypeEither:\n\n    \n    \n    catch '(safeDiv1 6 3)\n    \n    \u29e8\n    \n    Right 2\n    \n    \n    catch '(safeDiv1 6 0)\n    \n    \u29e8\n    \n    Left (Failure (typeLink Generic) \"Oops. Zero\" (Any 0))\n\n\ud83d\udcdaThe handlers for effects is an impressive part of the concept, but we won't\nlook too deep into it here.\n\nLet's try something more exciting and randomly generate both numbers via\ntheIOability (imagine fetching numbers from external services or something):\n\n    \n    \n    safeDiv2 : '{IO, Exception} Nat\n    \n    \n    safeDiv2 : '{IO, Exception} Nat safeDiv2 _ = use Nat / == a = !randomNat b = !randomNat if b == 0 then Exception.raise (Generic.failure \"Oops. Zero\" b) else a / b\n\n\ud83d\udcdaNote that there is a dedicatedRandomability \u2014 we're usingrandomNatfor\nillustration purposes.\n\nThere are a couple of new things in this snippet. Weforce(execute) the\ncomputation ofrandomNatto get 2 random natural numbers anddelay(suspend) the\nwholesafeDiv,which is also reflected in the type signature.\n\n\ud83d\udcccNote that Unison also provides an alternative syntax\nforforcedanddelayedcomputations\n\nThe idea behind forcing should be straightforward, but why should we delay a\ncomputation? The type{IO, Exception} Natby itself is not allowed there,\nbecauseIOandExceptionabilities must be provided by a handler. The runtime can\ndo it for us when we run the whole program (notice that we don't usecatch):\n\n    \n    \n    >. run safeDiv2\n\nAs a result, we get something boring like0or2.Let's make it fun by involving\nanother ability:\n\n    \n    \n    safeDiv3 : '{IO, Exception, Store Text} Nat\n    \n    \n    safeDiv3 : '{IO, Exception, Store Text} Nat safeDiv3 = do use Nat / == toText use Text ++ a = !randomNat b = !randomNat Store.put (toText a ++ \"/\" ++ toText b) if b == 0 then Exception.raise (Generic.failure \"Oops. Zero\" b) else a / b\n\nWe can use theStoreability to record the randomly generated division\ncomponents. This time we must provide a handler forStore\u2014 because Unison can't\njust guess or handle it for us \u2014withInitialValue \"empty\"will do the job:\n\n    \n    \n    final : '{IO, Exception} ()\n    \n    \n    final : '{IO, Exception} () final = do use Text ++ withInitialValue \"empty\" do result = !safeDiv3 printLine (Store.get ++ \"=\" ++ Nat.toText result)\n\nWow, look at this:\n\n    \n    \n    >. run final\n    \n    \n    6864436983616853973/1491537154359797591=4\n\nAnd we can keep going and going with adding new abilities. Notice how little\nsyntax we used (nobind/flatMapor any specialized combinators) and how similar\neach iteration ofsafeDivwas.\n\n### Control flow and the call stack\n\nIn a nutshell, direct-style algebraic effects is \u201cjust\u201d a nice interface\noverdelimited continuations.\n\nControl flow happens by affecting the call stack.As a reminder: exceptions,\nloops, async, finalizing or closing resources, dependency injection,\ncancellation \u2014 all of these require some technique to jump through the\nfunction call stack. So, instead of manipulating the call stack \u201cdirectly\u201d via\ncustom features, we can use monads or some other instrument.\n\n  * Direct style / Custom features:The compiler does that.\n  * Monads:We can manipulate the data structures that reify the call stack.\n  * Delimited continuations:We can use user-level primitives to affect the call stack, but it's quite mind-breaking. Nobody wants that.\n  * Direct-style algebraic effects:We can use delimited continuations via a better interface (types + syntax).\n\n### The pros of direct-style algebraic effects\n\nWhat do we have now?\n\nRight up front, we get the ability to embed user-defined effects \u2014 a massive\nimprovement over traditional direct style; plus the ability to write code in\ndirect style \u2014 a considerable improvement in expressing control flow.\n\nWe haven't demonstrated this,but writing custom effects is more accessible\nthan monads.You have to trust us on that.Writing custom monads is an upper-\nintermediate or expert-only endeavor (especially when you have to deal with\nstack-safety in a strict language).\n\nAt the same time, there's a limited amount of syntax. The language designers\nmust make a few choices: around effect handlers, suspending and forcing\nexecution. We saw two variations in the case of Unison. Still, there is no\nneed to make a new syntax for every feature.\n\nWhich leads us to teaching. Teaching people how touseeffects is trivial\n(essentially, they need to grasp suspending and forcing computations).\n\nRemember how easy it was to add theStoreability to existing abilities? We keep\ntyped effects and peacefully mix them! And on top of all that, no more\nfunction coloring at all. There is nomap/`traverse`distinction and so on.\n\n### The elephant in the pure room\n\nNothing comes for free. This might sound dramatic for people coming from\nmonadic worlds, but the first thing we lose with direct-style algebraic\neffects isreferential transparency.\n\nImagine we have a program that initializes two mutable refs\nwith\"empty\",writes\"full\"into the first one, and then reads values from the\nboth refs:\n\n    \n    \n    refExample1 : '{IO} Text\n    \n    \n    refExample1 : '{IO} Text refExample1 = do use IO ref use Text ++ use mutable.Ref read x = ref \"empty\" y = ref \"empty\" mutable.Ref.write x \"full\" read x ++ \"|\" ++ read y\n\nWhen werun refExample,we get:\n\n    \n    \n    \"full|empty\"\n\nIf we decide todrythe code and naively extract the initialization\nintoemptyRef:\n\n    \n    \n    refExample2 : '{IO} Text\n    \n    \n    refExample2 : '{IO} Text refExample2 = do use Text ++ use mutable.Ref read emptyRef = IO.ref \"empty\" x = emptyRef y = emptyRef mutable.Ref.write x \"full\" read x ++ \"|\" ++ read y\n\nWe get a different program because, when werun refExample2,we get:\n\n    \n    \n    \"full|full\"\n\nBothxandywere updated because they are the same ref. What we wanted to do is\ntosuspendthe initialization and thenforceit twice (first time forxand second\nfory):\n\n    \n    \n    refExample3 : '{IO} Text\n    \n    \n    refExample3 : '{IO} Text refExample3 = do use Text ++ use mutable.Ref read emptyRef = do IO.ref \"empty\" x = !emptyRef y = !emptyRef mutable.Ref.write x \"full\" read x ++ \"|\" ++ read y\n\nWhich would give us:\n\n    \n    \n    \"full|empty\"\n\nAs you can see, refactoring the code with abilities might require more brain\nactivity than with monads. Even though it's a hurdle for people with a\n\u201cmonadic\u201d background, it's not the end of the world. We gave up something\nimportant, but we also gained a ton.\n\n### Other limitations and unknowns\n\nThe drawbacks don't stop there. Direct-style algebraic effects is a novel\nconcept (even comparatively to monads) \u2014 there are still some open questions\nand some unknowns. We need some time to explore their limitations.\n\nFor example, static control flow (applicative-style code) is a niche use case\n(e.g., applicative parsers, applicative-style build tools) can't be expressed\nwith abilities. Because there is no way not to evaluate effects or undo an\neffect.\n\nAre there more cases like this? We don't know yet. However...\n\n## Takeaways\n\nIf you are curious and want to explore the knowns and unknowns of abilities\n(and direct-style algebraic effects), now is the perfect time.\n\nAt the end of the day, direct-style algebraic effects (delimited\ncontinuations) and monads havethe same expressive power\u2014 they can express the\nsame things.\n\nMonads| Direct Style| Abilities  \n---|---|---  \nArbitrary/User-defined Effects| \ud83d\udc4d| \ud83d\udc4e\ud83d\udc4e\ud83d\udc4e| \ud83d\udc4d\ud83d\udc4d\ud83d\udc4d  \nSyntax| Unified, but has plumbing overhead| O(N) \u2014 each feature requires\ncustom syntax| Unified, O(1)  \nTeachability| \ud83d\udc4e\ud83d\udc4e\ud83d\udc4e| \ud83d\udc4d| \ud83d\udc4d  \nFamiliarity| \ud83d\udc4e| \ud83d\udc4d| \ud83d\udc4d  \nTyped Effects| typed| not typed| typed  \nEffects mixing| \ud83d\udc4e| \ud83d\udc4d| \ud83d\udc4d  \nFunction coloring| some (e.g., map vs traverse)| some (depends on the\nimplementation)| \ud83d\udc4d  \nReferential transparency| \ud83d\udc4d\ud83d\udc4d\ud83d\udc4d| \ud83d\udc4e\ud83d\udc4e| \ud83d\udc4c / \ud83d\udc4e  \nCall-stack manipulation| via data structures| compiler's job| via delimited\ncontinuations  \nMaturity| Limitations are known| Limitations are known| Novel, some unknowns  \nStatic control flow| \ud83d\udc4d| \ud83d\udc4e| \ud83d\udc4e  \n  \nBy native side-effects, we mean effects provided by the runtime; for example,\nprinting to the console, exceptions, and interacting with the file system.\n\n\u00a9 2024\n\nUnison Computing, a public benefit corp\n\nand contributors.\n\n", "frontpage": false}
