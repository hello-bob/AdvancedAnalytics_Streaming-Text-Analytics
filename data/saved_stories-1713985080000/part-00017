{"aid": "40143544", "title": "HTML Attributes vs. DOM Properties", "url": "https://jakearchibald.com/2024/attributes-vs-properties/", "domain": "jakearchibald.com", "votes": 3, "user": "dassurma", "posted_at": "2024-04-24 12:26:25", "comments": 0, "source_title": "HTML attributes vs DOM properties", "source_text": "HTML attributes vs DOM properties - JakeArchibald.com\n\nJake Archibald wrote...who?\n\n# HTML attributes vs DOM properties\n\nPosted 24 April 2024\n\nAttributes and properties are fundamentally different things. You can have an\nattribute and property of the same name set to different values. For example:\n\n    \n    \n    <div foo=\"bar\">...</div> <script> const div = document.querySelector('div[foo=bar]'); console.log(div.getAttribute('foo')); // 'bar' console.log(div.foo); // undefined div.foo = 'hello world'; console.log(div.getAttribute('foo')); // 'bar' console.log(div.foo); // 'hello world' </script>\n\nIt seems like fewer and fewer developers know this, partially thanks to\nframeworks:\n\n    \n    \n    <input className=\"...\" type=\"...\" aria-label=\"...\" value=\"...\" />\n\nIf you do the above in a framework's templating language, you're using\nattribute-like syntax, but under the hood it'll sometimes be setting the\nproperty instead, and when it does that differs from framework to framework.\nIn some cases, it'll set a property and an attribute as a side-effect, but\nthat isn't the framework's fault.\n\nMost of the time, these distinctions don't matter. I think it's good that\ndevelopers can have a long and happy career without caring about the\ndifferences between properties and attributes. But, if you need to dig down\ninto the DOM at a lower level, it helps to know. Even if you feel you know the\ndifference, maybe I'll touch on a couple of details you hadn't considered. So\nlet's dig in...\n\n## The key differences\n\nBefore we get to the interesting stuff, let's get some of the technical\ndifferences out of the way:\n\n### HTML serialisation\n\nAttributes serialise to HTML, whereas properties don't:\n\n    \n    \n    const div = document.createElement('div'); div.setAttribute('foo', 'bar'); div.hello = 'world'; console.log(div.outerHTML); // '<div foo=\"bar\"></div>'\n\nSo when you're looking at the elements panel in browser developer tools,\nyou're only seeing attributes on elements, not properties.\n\n### Value types\n\nIn order to work in the serialised format, attribute values are always\nstrings, whereas properties can be any type:\n\n    \n    \n    const div = document.createElement('div'); const obj = { foo: 'bar' }; div.setAttribute('foo', obj); console.log(typeof div.getAttribute('foo')); // 'string' console.log(div.getAttribute('foo')); // '[object Object]' div.hello = obj; console.log(typeof div.hello); // 'object' console.log(div.hello); // { foo: 'bar' }\n\n### Case sensitivity\n\nAttribute names are case-insensitive, whereas property names are case-\nsensitive.\n\n    \n    \n    <div id=\"test\" HeLlO=\"world\"></div> <script> const div = document.querySelector('#test'); console.log(div.getAttributeNames()); // ['id', 'hello'] div.setAttribute('FOO', 'bar'); console.log(div.getAttributeNames()); // ['id', 'hello', 'foo'] div.TeSt = 'value'; console.log(div.TeSt); // 'value' console.log(div.test); // undefined </script>\n\nHowever, attribute values are case-sensitive.\n\nOk, here's where things start to get blurry:\n\n## Reflection\n\nTake a look at this:\n\n    \n    \n    <div id=\"foo\"></div> <script> const div = document.querySelector('#foo'); console.log(div.getAttribute('id')); // 'foo' console.log(div.id); // 'foo' div.id = 'bar'; console.log(div.getAttribute('id')); // 'bar' console.log(div.id); // 'bar' </script>\n\nThis seems to contradict the first example in the post, but the above only\nworks because Element has an id getter & setter that 'reflects' the id\nattribute.\n\nWhen a property reflects an attribute, the attribute is the source of the\ndata. When you set the property, it's updating the attribute. When you read\nfrom the property, it's reading the attribute.\n\nFor convenience, most specs will create a property equivalent for every\ndefined attribute. It didn't work in the example at the start of the article,\nbecause foo isn't a spec-defined attribute, so there isn't a spec-defined foo\nproperty that reflects it.\n\nHere's the spec for <ol>. The \"Content attributes\" section defines the\nattributes, and the \"DOM interface\" defines the properties. If you click on\nreversed in the DOM interface, it takes you to this:\n\n> The reversed and type IDL attributes must reflect the respective content\n> attributes of the same name.\n\nBut not all of these reflectors are as simple as these.\n\n### Naming differences\n\nOk, this is relatively minor, but sometimes the property has a different name\nto the attribute it reflects.\n\nIn some cases it's just to add the kind of casing you'd expect from a\nproperty:\n\n  * On <img>, el.crossOrigin reflects the crossorigin attribute.\n  * On all elements, el.ariaLabel reflects the aria-label attribute (the aria reflectors became cross browser in late 2023. Before that you could only use the attributes).\n\nIn some cases, names had to be changed due to old JavaScript reserved words:\n\n  * On all elements, el.className reflects the class attribute.\n  * On <label>, el.htmlFor reflects the for attribute.\n\n### Validation, type coercion, and defaults\n\nProperties come with validation and defaults, whereas attribute don't:\n\n    \n    \n    const input = document.createElement('input'); console.log(input.getAttribute('type')); // null console.log(input.type); // 'text' input.type = 'number'; console.log(input.getAttribute('type')); // 'number' console.log(input.type); // 'number' input.type = 'foo'; console.log(input.getAttribute('type')); // 'foo' console.log(input.type); // 'text'\n\nIn this case, the validation is handled by the type getter. The setter allowed\nthe invalid value 'foo', but when the getter saw the invalid value, or no\nvalue, it returned 'text'.\n\nSome properties perform type coercion:\n\n    \n    \n    <details open>...</details> <script> const details = document.querySelector('details'); console.log(details.getAttribute('open')); // '' console.log(details.open); // true details.open = false; console.log(details.getAttribute('open')); // null console.log(details.open); // false details.open = 'hello'; console.log(details.getAttribute('open')); // '' console.log(details.open); // true </script>\n\nIn this case, the open property is a boolean, returning whether the attribute\nexists. The setter also coerces the type - even though the setter is given\n'hello', it's turned to a boolean rather than going directly to the attribute.\n\nProperties like img.height coerce the attribute value to a number. The setter\nconverts the incoming value to a number, and treats negative values as 0.\n\n### value on input fields\n\nvalue is a fun one. There's a value property and a value attribute. However,\nthe value property does not reflect the value attribute. Instead, the\ndefaultValue property reflects the value attribute.\n\nI know, I know.\n\nIn fact, the value property doesn't reflect any attribute. That isn't unusual,\nthere's loads of these (offsetWidth, parentNode, indeterminate on checkboxes\nfor some reason, and many more).\n\nInitially, the value property defers to the defaultValue property. Then, once\nthe value property is set, either via JavaScript or through user interaction,\nit switches to an internal value. It's as if it's implemented roughly like\nthis:\n\n    \n    \n    class HTMLInputElement extends HTMLElement { get defaultValue() { return this.getAttribute('value') ?? ''; } set defaultValue(newValue) { this.setAttribute('value', String(newValue)); } #value = undefined; get value() { return this.#value ?? this.defaultValue; } set value(newValue) { this.#value = String(newValue); } // This happens when the associated form resets #reset() { this.#value = undefined; } }\n\nSo:\n\n    \n    \n    <input type=\"text\" value=\"default\" /> <script> const input = document.querySelector('input'); console.log(input.getAttribute('value')); // 'default' console.log(input.value); // 'default' console.log(input.defaultValue); // 'default' input.defaultValue = 'new default'; console.log(input.getAttribute('value')); // 'new default' console.log(input.value); // 'new default' console.log(input.defaultValue); // 'new default' // Here comes the mode switch: input.value = 'hello!'; console.log(input.getAttribute('value')); // 'new default' console.log(input.value); // 'hello!' console.log(input.defaultValue); // 'new default' input.setAttribute('value', 'another new default'); console.log(input.getAttribute('value')); // 'another new default' console.log(input.value); // 'hello!' console.log(input.defaultValue); // 'another new default' </script>\n\nThis would have made way more sense if the value attribute was named\ndefaultvalue. Too late now.\n\n## Attributes should be for configuration\n\nIn my opinion, attributes should be for configuration, whereas properties can\ncontain state. I also believe that the light-DOM tree should have a single\nowner.\n\nIn that sense, I think <input value> gets it right (aside from the naming).\nThe value attribute configures the default value, whereas the value property\ngives you the current state.\n\nIt also makes sense that validation applies when getting/setting properties,\nbut never when getting/setting attributes.\n\nI say 'in my opinion', because a couple of recent HTML elements have done it\ndifferently.\n\nThe <details> and <dialog> elements represent their open state via the open\nattribute, and the browser will self add/remove this attribute in response to\nuser interaction.\n\nI think this was a design mistake. It breaks the idea that attributes are for\nconfiguration, but more importantly it means that the system in charge of\nmaintaining the DOM (a framework, or vanilla JS) needs to be prepared for the\nDOM to change itself.\n\nI think it should have been:\n\n    \n    \n    <details defaultopen>...</details>\n\nAnd a details.open property to get/set the current state, along with a CSS\npseudo-class for targeting that state.\n\nI guess contenteditable also breaks that contract, but... well... it's a opt-\nin to a lot of breakage.\n\n## How frameworks handle the difference\n\nBack to the example from earlier:\n\n    \n    \n    <input className=\"...\" type=\"...\" aria-label=\"...\" value=\"...\" />\n\nHow do frameworks handle this?\n\n### Preact and VueJS\n\nAside from a predefined set of cases where they favour attributes, they'll set\nthe prop as a property if propName in element, otherwise they'll set an\nattribute. Basically, they prefer properties over attributes. Their render-to-\nstring methods do the opposite, and ignore things that are property-only.\n\n  * setProperty in Preact.\n  * shouldSetAsProp in VueJS.\n\n### React\n\nReact does things the other way around. Aside from a predefined set of cases\nwhere they favour properties, they'll set an attribute. This makes their\nrender-to-string method similar in logic.\n\nThis explains why custom elements don't seem to work in React. Since they're\ncustom, their properties aren't in React's 'predefined list', so they're set\nas attributes instead. Anything that's property-only on the custom element\nsimply won't work. This will be fixed in React 19, where they'll switch to the\nPreact/VueJS model for custom elements.\n\nThe funny thing is, React popularised using className instead of class in what\nlooks like an attribute. But, even though you're using the property name\nrather than the attribute name, React will set the class attribute under the\nhood.\n\n  * setProp in React.\n\n### lit-html\n\nLit does things a little differently:\n\n    \n    \n    <input type=\"...\" .value=\"...\" />\n\nIt keeps the distinction between attributes and properties, requiring you to\nprefix the name with . if you want to set the property rather than the\nattribute.\n\n  * Lit's expression docs.\n\n## And that's yer lot\n\nThat's pretty much everything I know about the difference between properties\nand attributes. If there's something I've missed, or you have a question, let\nme know in the comments below!\n\nThanks to my podcast husband Surma for his usual reviewing skills.\n\nView this page on GitHub\n\nComments powered by Disqus\n\nHello, I'm Jake and that's me there. The one that isn't a cat. I'm a developer\nof sorts.\n\n# Elsewhere\n\n  * Twitter\n  * Github\n  * YouTube\n  * Podcast\n\n# Contact\n\nFeel free to throw me an email, unless you're a recruiter, or someone trying\nto offer me 'sponsored content' for this site, in which case write your\nrequest on a piece of paper, and fling it out the window.\n\n", "frontpage": false}
