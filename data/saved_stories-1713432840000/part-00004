{"aid": "40071809", "title": "WebSocketStream API", "url": "https://developer.chrome.com/docs/capabilities/web-apis/websocketstream", "domain": "chrome.com", "votes": 6, "user": "begoon", "posted_at": "2024-04-18 00:49:19", "comments": 0, "source_title": "WebSocketStream: integrating streams with the WebSocket API | Capabilities | Chrome for Developers", "source_text": "WebSocketStream: integrating streams with the WebSocket API | Capabilities | Chrome for Developers\n\ndeveloper.chrome.com uses cookies from Google to deliver and enhance the\nquality of its services and to analyze traffic. Learn more.\n\n  * English\n  * Deutsch\n  * Espa\u00f1ol \u2013 Am\u00e9rica Latina\n  * Fran\u00e7ais\n  * Indonesia\n  * Italiano\n  * Nederlands\n  * Polski\n  * Portugu\u00eas \u2013 Brasil\n  * Ti\u1ebfng Vi\u1ec7t\n  * T\u00fcrk\u00e7e\n  * \u0420\u0443\u0441\u0441\u043a\u0438\u0439\n  * \u05e2\u05d1\u05e8\u05d9\u05ea\n  * \u0627\u0644\u0639\u0631\u0628\u064a\u0651\u0629\n  * \u0641\u0627\u0631\u0633\u06cc\n  * \u0939\u093f\u0902\u0926\u0940\n  * \u09ac\u09be\u0982\u09b2\u09be\n  * \u0e20\u0e32\u0e29\u0e32\u0e44\u0e17\u0e22\n  * \u4e2d\u6587 \u2013 \u7b80\u4f53\n  * \u4e2d\u6587 \u2013 \u7e41\u9ad4\n  * \u65e5\u672c\u8a9e\n  * \ud55c\uad6d\uc5b4\n\nSign in\n\n  * Capabilities\n\n  * On this page\n  * Background\n\n    * The WebSocket API\n    * The Streams API\n    * The Problem with the current WebSocket API\n  * What is the WebSocketStream API?\n\n    * Suggested use cases for the WebSocketStream API\n  * Current status\n  * How to use the WebSocketStream API\n\n    * Introductory example\n    * Advanced examples\n    * Information about closed WebSocketStream connection\n    * Closing a WebSocketStream connection\n    * Progressive enhancement and interoperability\n  * Demo\n  * Feedback\n\n    * Tell us about the API design\n    * Report a problem with the implementation\n    * Show support for the API\n  * Helpful links\n  * Acknowledgements\n\n  * Home\n  * Docs\n\n  * Capabilities\n\nWas this helpful?\n\n# WebSocketStream: integrating streams with the WebSocket API\n\nbookmark_borderbookmark Stay organized with collections Save and categorize\ncontent based on your preferences.\n\n  * On this page\n  * Background\n\n    * The WebSocket API\n    * The Streams API\n    * The Problem with the current WebSocket API\n  * What is the WebSocketStream API?\n\n    * Suggested use cases for the WebSocketStream API\n  * Current status\n  * How to use the WebSocketStream API\n\n    * Introductory example\n    * Advanced examples\n    * Information about closed WebSocketStream connection\n    * Closing a WebSocketStream connection\n    * Progressive enhancement and interoperability\n  * Demo\n  * Feedback\n\n    * Tell us about the API design\n    * Report a problem with the implementation\n    * Show support for the API\n  * Helpful links\n  * Acknowledgements\n\nPrevent your app from getting drowned in WebSocket messages or flooding a\nWebSocket server with messages by applying backpressure.\n\nThomas Steiner\n\n## Background\n\n### The WebSocket API\n\nThe WebSocket API provides a JavaScript interface to the WebSocket protocol,\nwhich makes it possible to open a two-way interactive communication session\nbetween the user's browser and a server. With this API, you can send messages\nto a server and receive event-driven responses without polling the server for\na reply.\n\n### The Streams API\n\nThe Streams API allows JavaScript to programmatically access streams of data\nchunks received over the network and process them as desired. An important\nconcept in the context of streams is backpressure. This is the process by\nwhich a single stream or a pipe chain regulates the speed of reading or\nwriting. When the stream itself or a stream later in the pipe chain is still\nbusy and isn't yet ready to accept more chunks, it sends a signal backwards\nthrough the chain to slow delivery as appropriate.\n\n### The Problem with the current WebSocket API\n\n#### Applying backpressure to received messages is impossible\n\nWith the current WebSocket API, reacting to a message happens in\nWebSocket.onmessage, an EventHandler called when a message is received from\nthe server.\n\nLet's assume you had an application that needs to perform heavy data crunching\noperations whenever a new message is received. You would probably set up the\nflow similar to the code below, and since you await the result of the\nprocess() call, you should be good, right?\n\n    \n    \n    // A heavy data crunching operation. const process = async (data) => { return new Promise((resolve) => { window.setTimeout(() => { console.log('WebSocket message processed:', data); return resolve('done'); }, 1000); }); };\n    \n    webSocket.onmessage = async (event) => { const data = event.data; // Await the result of the processing step in the message handler. await process(data); };\n\nWrong! The problem with the current WebSocket API is that there is no way to\napply backpressure. When messages arrive faster than the process() method can\nhandle them, the render process will either fill up memory by buffering those\nmessages, become unresponsive due to 100% CPU usage, or both.\n\n#### Applying backpressure to sent messages is non-ergonomic\n\nApplying backpressure to sent messages is possible, but involves polling the\nWebSocket.bufferedAmount property, which is inefficient and non-ergonomic.\nThis read-only property returns the number of bytes of data that have been\nqueued using calls to WebSocket.send(), but not yet transmitted to the\nnetwork. This value resets to zero once all queued data has been sent, but if\nyou keep calling WebSocket.send(), it will continue to climb.\n\n## What is the WebSocketStream API?\n\nThe WebSocketStream API deals with the problem of non-existent or non-\nergonomic backpressure by integrating streams with the WebSocket API. This\nmeans backpressure can be applied \"for free\", without any extra cost.\n\n### Suggested use cases for the WebSocketStream API\n\nExamples of sites that can use this API include:\n\n  * High-bandwidth WebSocket applications that need to retain interactivity, in particular video and screen-sharing.\n  * Similarly, video capture and other applications that generate a lot of data in the browser that needs to be uploaded to the server. With backpressure, the client can stop producing data rather than accumulating data in memory.\n\n## Current status\n\nStep| Status  \n---|---  \n1\\. Create explainer| Complete  \n2\\. Create initial draft of specification| In progress  \n3\\. Gather feedback & iterate on design| In progress  \n4\\. Origin trial| Complete  \n5\\. Launch| Not started  \n  \n## How to use the WebSocketStream API\n\n### Introductory example\n\nThe WebSocketStream API is promise-based, which makes dealing with it feel\nnatural in a modern JavaScript world. You start by constructing a new\nWebSocketStream and passing it the URL of the WebSocket server. Next, you wait\nfor the connection to be opened, which results in a ReadableStream and/or a\nWritableStream.\n\nBy calling the ReadableStream.getReader() method, you finally obtain a\nReadableStreamDefaultReader, which you can then read() data from until the\nstream is done, that is, until it returns an object of the form {value:\nundefined, done: true}.\n\nAccordingly, by calling the WritableStream.getWriter() method, you finally\nobtain a WritableStreamDefaultWriter, which you can then write() data to.\n\n    \n    \n    const wss = new WebSocketStream(WSS_URL); const {readable, writable} = await wss.opened; const reader = readable.getReader(); const writer = writable.getWriter();\n    \n    while (true) { const {value, done} = await reader.read(); if (done) { break; } const result = await process(value); await writer.write(result); }\n\n#### Backpressure\n\nWhat about the promised backpressure feature? As I wrote above, you get it\n\"for free\", no extra steps needed. If process() takes extra time, the next\nmessage will only be consumed once the pipeline is ready. Likewise the\nWritableStreamDefaultWriter.write() step will only proceed if it is safe to do\nso.\n\n### Advanced examples\n\nThe second argument to WebSocketStream is an option bag to allow for future\nextension. Currently the only option is protocols, which behaves the same as\nthe second argument to the WebSocket constructor:\n\n    \n    \n    const chatWSS = new WebSocketStream(CHAT_URL, {protocols: ['chat', 'chatv2']}); const {protocol} = await chatWSS.opened;\n\nThe selected protocol as well as potential extensions are part of the\ndictionary available via the WebSocketStream.opened promise. All the\ninformation about the live connection is provided by this promise, since it is\nnot relevant if the connection fails.\n\n    \n    \n    const {readable, writable, protocol, extensions} = await chatWSS.opened;\n\nNote: In an earlier version of the API, WebSocketStream.opened was called\nWebSocketStream.connection.\n\n### Information about closed WebSocketStream connection\n\nThe information that was available from the WebSocket.onclose and\nWebSocket.onerror events in the WebSocket API is now available via the\nWebSocketStream.closed promise. The promise rejects in the event of an unclean\nclose, otherwise it resolves to the code and reason sent by the server.\n\nAll possible status codes and their meaning is explained in the list of\nCloseEvent status codes.\n\n    \n    \n    const {code, reason} = await chatWSS.closed;\n\n### Closing a WebSocketStream connection\n\nA WebSocketStream can be closed with an AbortController. Therefore, pass an\nAbortSignal to the WebSocketStream constructor.\n\n    \n    \n    const controller = new AbortController(); const wss = new WebSocketStream(URL, {signal: controller.signal}); setTimeout(() => controller.abort(), 1000);\n\nAs an alternative, you can also use the WebSocketStream.close() method, but\nits main purpose is to permit specifying the code and reason which is sent to\nthe server.\n\n    \n    \n    wss.close({code: 4000, reason: 'Game over'});\n\n### Progressive enhancement and interoperability\n\nChrome is currently the only browser to implement the WebSocketStream API. For\ninteroperability with the classic WebSocket API, applying backpressure to\nreceived messages is not possible. Applying backpressure to sent messages is\npossible, but involves polling the WebSocket.bufferedAmount property, which is\ninefficient and non-ergonomic.\n\n#### Feature detection\n\nTo check if the WebSocketStream API is supported, use:\n\n    \n    \n    if ('WebSocketStream' in window) { // `WebSocketStream` is supported! }\n\n## Demo\n\nOn supporting browsers, you can see the WebSocketStream API in action in the\nembedded iframe, or directly on Glitch.\n\n## Feedback\n\nThe Chrome team wants to hear about your experiences with the WebSocketStream\nAPI.\n\n### Tell us about the API design\n\nIs there something about the API that doesn't work like you expected? Or are\nthere missing methods or properties that you need to implement your idea? Have\na question or comment on the security model? File a spec issue on the\ncorresponding GitHub repo, or add your thoughts to an existing issue.\n\n### Report a problem with the implementation\n\nDid you find a bug with Chrome's implementation? Or is the implementation\ndifferent from the spec? File a bug at new.crbug.com. Be sure to include as\nmuch detail as you can, simple instructions for reproducing, and enter\nBlink>Network>WebSockets in the Components box. Glitch works great for sharing\nquick and easy reproduction cases.\n\n### Show support for the API\n\nAre you planning to use the WebSocketStream API? Your public support helps the\nChrome team to prioritize features and shows other browser vendors how\ncritical it is to support them.\n\nSend a tweet to @ChromiumDev using the hashtag #WebSocketStream and let us\nknow where and how you're using it.\n\n## Helpful links\n\n  * Public explainer\n  * WebSocketStream API Demo | WebSocketStream API Demo source\n  * Tracking bug\n  * ChromeStatus.com entry\n  * Blink Component: Blink>Network>WebSockets\n\n## Acknowledgements\n\nThe WebSocketStream API was implemented by Adam Rice and Yutaka Hirano. Hero\nimage by Daan Mooij on Unsplash.\n\nWas this helpful?\n\nExcept as otherwise noted, the content of this page is licensed under the\nCreative Commons Attribution 4.0 License, and code samples are licensed under\nthe Apache 2.0 License. For details, see the Google Developers Site Policies.\nJava is a registered trademark of Oracle and/or its affiliates.\n\nLast updated 2020-03-27 UTC.\n\n", "frontpage": true}
