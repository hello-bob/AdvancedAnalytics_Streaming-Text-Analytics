{"aid": "40195811", "title": "Quantum-Proof ClientHello Messages: How Size Causes Server Failures", "url": "https://tldr.fail/", "domain": "tldr.fail", "votes": 1, "user": "skilled", "posted_at": "2024-04-29 08:12:11", "comments": 0, "source_title": "tldr.fail", "source_text": "# tldr.fail\n\nThe migration to post-quantum cryptography is being held back by buggy servers\nthat do not correctly implement TLS. Due to a bug, these servers reject\nconnections that use post-quantum-secure cryptography, instead of negotiating\nclassical cryptography if they do not support post-quantum cryptography.\n\n## What is the bug?\n\nThe Internet is currently beginning a migration to post-quantum secure\ncryptography. This migration is important because large-scale quantum\ncomputers will be powerful enough to break most public-key cryptosystems\ncurrently in use and compromise digital communications on the Internet and\nelsewhere. It is important to migrate to cryptography that cannot be broken by\na quantum computer before quantum computers exist.\n\nUnfortunately, some buggy servers are not prepared for clients to start\nsupporting post-quantum-secure cryptography. The TLS protocol contains a\nmechanism for the server and client to negotiate the cryptographic algorithms\nused for the connection based on which algorithms are mutally supported by\nboth. This means that correctly-implemented servers that have not yet added\nsupport for the draft post-quantum algorithms should silently ignore the post-\nquantum option, and select a different classical algorithm.\n\nTLS ClientHello messages that offer post-quantum cryptography are larger than\nclassical ClientHello messages, and exceed the threshold for transmission in a\nsingle packet. This means that a single call to TCP read() might not return\nthe entire ClientHello packet. This has always been possible in TCP, but it is\nexacerbated by the larger ClientHello messages. Most buggy servers are not\nprepared to have to call read() more than once to read the entire ClientHello.\nThis is still a bug even prior to the post-quantum migration, however, the bug\nis much more commonly exposed when the larger post-quantum cryptography is in\nuse.\n\n## What is post-quantum-secure cryptography?\n\nModern public-key cryptography is secure in the face of a classical computer,\nbut can be broken by a quantum computer. Luckily, quantum computers don't\nexist yet!\n\nPost-quantum-secure cryptography (also shortened to post-quantum cryptography)\nis cryptography that is resistant to quantum computers. Due to the power of\nmath, we can design, build, and verify this cryptography using only classical\n(non-quantum) computers.\n\nNIST recently ran a competition to find the best post-quantum cryptographic\nalgorithms, and is in the process of standardizing the winners. Some of the\nwinning post-quantum cryptographic algorithms include Kyber for key exchange\nand key encapsulation, and Dilithium for digital signatures. The IETF is\nstandardizing how to integrate this cryptography into TLS.\n\n## Why is this happening now?\n\nFuture quantum computers pose a risk to current Internet traffic through\nstore-then-decrypt attacks, in which attackers harvest encrypted sensitive\ninformation now, and then decrypt it later, once quantum computers exist.\nMitigating this threat requires deploying a post-quantum key exchange\nmechanism now.\n\nTo start mitigating the store-then-decrypt attack, Chrome is in the process of\nrolling out a post-quantum key exchange.\n\n## What about authentication?\n\nQuantum computers are capable of breaking the digital signature algorithms\nused for authenticating digital communications today. Post-quantum signature\nalgorithms exist, but still have performance issues that make them difficult\nto integrate into existing authentication systems, such as HTTPS certificates\n(X.509). Luckily, unlike key exchange, the risk to authentication from a\nquantum computer requires a sufficiently powerful quantum computer to actually\nexist, since connections are authenticated in realtime. The store-then-decrypt\nattack does not apply to authentication algorithms.\n\nThis means the migration to post-quantum secure authentication algorithms is\nless urgent than key exchange. Due to the slow moving nature of the\nauthentication ecosystems on the Internet, such as the Web PKI, it is\nimportant to start this migration soon. However, there is no urgent threat to\nauthentication, like there is with key exchange.\n\n## Does this bug apply to classical cryptography?\n\nServers that are not prepared for a ClientHello may incorrectly reject any\nconnection, especially if it split over two packets. This is less likely with\nclassical cryptography, but can happen. You can test for this by sending\n\"half\" a ClientHello, and then waiting before sending the rest, and seeing if\nthe server correctly handles the connection, or if it resets the connection.\nThis bug is not specific to post-quantum cryptography, but is exacerbated by\nit.\n\n## How does this affect the migration to post-quantum cryptography?\n\nTLS contains a mechanism for negotiating the cryptographic algorithms used for\nthe connection. If things were working correctly, servers that don't support\npostquantum cryptography would select a classical algorithm. Unfortunately,\nthese buggy servers fail on connections that offer postquantum cryptography.\nThis means clients cannot start the rollout of postquantum cryptography\nwithout risking breaking access to sites hosted on buggy servers.\n\n## I'm not migrating to post-quantum cryptography until later. Why do I need\nto do anything now?\n\nYou should still make sure your server doesn't have this bug, especially if\nyou're a server implementor. Clients are starting to deploy post-quantum\ncryptography, and while you don't need to update your server to support draft\nstandards, you don't want to prevent clients from being able to start this\ntransition, even if you aren't planning on participating right now.\n\n## How can I tell if my server has this bug?\n\nYou can use this Python script to test your server. You can also enable\nchrome://flags/#enable-tls13-kyber and then attempt to make an HTTPS\nconnection to your server from Chrome. If the connection fails with\nERR_CONNECTION_RESET or similar, the server is buggy.\n\n## How do I patch the bug if I'm an implementor?\n\nTLS messages contain a two-byte record length field at byte index 3. When\nprocessing a ClientHello, servers should ensure they've called read() until\nthe connection has returned the full content of the message, as set in the\nlength field. If read() returns less bytes than the length of the message,\nservers should loop until they've read the entire message.\n\n## I'm a network administrator? How does this affect me?\n\nYou may be using a vendor that has buggy servers or a buggy middlebox. You\nshould contact your vendor and request that they patch their software. You can\nprovide this website for more information.\n\n## Why are you calling this tldr.fail?\n\nThe bug is that servers \"didn't read\" the whole ClientHello, likely because it\nwas \"too long\" for a single packet, and then erroneously \"fail\" the\nconnection.\n\n## This isn't a vulnerability, why do you have a website?\n\nThis bug appears in a lot of servers and is holding back the Internet's\nmigration to post-quantum secure cryptography. If things were operating\ncorrectly, clients could deploy support for post-quantum cryptography and then\nservers would slowly opt-in. Instead, we're stuck, because buggy servers are\nrejecting connections from properly implemented clients that deploy post-\nquantum cryptography. These clients are then unable to load sites served by\nthe buggy server. This site serves as a reference for why the bug is\nimportant, and how to identify and fix it.\n\nTo contact the authors, create an issue on Github\n\n", "frontpage": false}
