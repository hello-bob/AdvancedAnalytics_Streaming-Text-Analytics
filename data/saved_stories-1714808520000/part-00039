{"aid": "40252784", "title": "Speeding up ELF relocations for store-based systems", "url": "https://fzakaria.com/2024/05/03/speeding-up-elf-relocations-for-store-based-systems.html", "domain": "fzakaria.com", "votes": 2, "user": "setheron", "posted_at": "2024-05-03 21:48:43", "comments": 0, "source_title": "Speeding up ELF relocations for store-based systems", "source_text": "Speeding up ELF relocations for store-based systems | Farid Zakaria\u2019s Blog\n\n# Speeding up ELF relocations for store-based systems\n\nPublished 2024-05-03 on Farid Zakaria's Blog \u2014 Permalink\n\nSince the introduction of Nix and similar store-based systems such as Guix or\nSpack, I have been fascinated about finding improvements that take advantage\nof the new paradigms they introduce. Linux distributions are traditionally\ndynamic in nature, with shared libraries and executables being linked at\nruntime. Store-based systems, however, are static in nature, with all\ndependencies being resolved at build time. This determinism allows for not\nonly reproducibility but also the ability to optimize various aspects of our\ntoolchain.\n\nWork that I\u2019ve have written previously about shows that there are worthwhile\nspeedups that can be gained. While previously, I focused on improving the stat\nstorm that occurs when resolving dependencies, I have recently been looking at\nspeeding up the ELF relocations that occur when executing a program.\n\n> You can check out my publication Mapping Out the HPC Dependency Chaos about\n> the development of shrinkwrap if you are interested in the topic.\n\nExtending the idea further, I have been looking at how we can optimize the ELF\nrelocations that occur when executing a program. In this post, I will discuss\nthe basics of ELF relocations and symbol resolution and how we can optimize\nthese processes for store-based systems.\n\n## ELF Relocations and Symbol Resolution\n\nELF (Executable and Linkable Format) files are the defacto format for\nexecutables and shared libraries on Linux systems. A crucial part of this\nstructure involves relocations.\n\n### What Are ELF Relocations?\n\nRelocations are actions that the dynamic linker performs to connect symbolic\nreferences or addresses in the compiled program to actual physical addresses\nin memory during program execution. These are necessary because the actual\naddresses where functions and data will reside in memory are not known at the\ntime of compilation such as when code is making calls to external functions in\nshared libraries.\n\nSuppose I have the two following files: main.c and foo.c.\n\n    \n    \n    #include <stdio.h> void foo() { printf(\"Calling the foo function.\\n\"); }\n    \n    \n    #include <stdio.h> #include <dlfcn.h> extern void foo(); int main() { foo(); return 0; }\n\nI setup a simple Makefile to create the shared-library and the executable. I\nadditionally set RPATH to the current directory to ensure the dynamic linker\ncan find the shared library.\n\n    \n    \n    CC = ../build/bin/musl-gcc CFLAGS = -g -O0 libfoo.so: foo.c $(CC) $(CFLAGS) -o $@ -shared $^ '-Wl,--no-as-needed,--enable-new-dtags' main: main.c libfoo.so $(CC) $(CFLAGS) -o $@ $^ -L. -lfoo '-Wl,--no-as-needed,--enable-new-dtags,-rpath,$$ORIGIN'\n\nIf we inspect the resulting executable file with readelf we can see the\nrelocations that are present, specifically the one for the foo function.\n\n    \n    \n    \u276f readelf -r main ... Relocation section '.rela.plt' at offset 0x530 contains 5 entries: Offset Info Type Sym. Value Sym. Name + Addend 000000004000 000600000007 R_X86_64_JUMP_SLO 0000000000000000 foo + 0\n\nThere are various types of relocation structures (REL vs. RELA) and types\n(R_X86_64_JUMP_SLOT, R_X86_64_GLOB_DAT, etc.) that can be present in an ELF\nfile. I am concerned about JUMP_SLOT relocations, which are used to resolve\nfunction calls to shared libraries.\n\n### Why Is Symbol Resolution Necessary?\n\nWhen a program is loaded into memory, it might be placed at a different base\naddress than the one for which it was originally compiled, more-so now that\nASLR (Address space layout randomization) is the default. Additionally, it\noften depends on multiple shared libraries, which are also not fixed in memory\nahead of time. The relocation entries in an ELF file tell the dynamic linker\nhow to modify the program\u2019s code and data sections to correctly reference\nmemory locations, whether they\u2019re functions or variables.\n\nSymbol resolution is the process of finding the correct addresses for these\nsymbolic references. For each undefined symbol in the program, the linker must\nsearch through all loaded libraries to find the correct definition. This\nprocess can be time-consuming, particularly when there are many symbols to\nresolve and multiple libraries to search through.\n\nHow time consuming?\n\nLet\u2019s look at an extreme example where we dynamically link in a shared-object\nwith 1000 to 1 million symbols. Working with the musl dynamic loader, I\u2019ve\naugmented it to include timing information.\n\n\ud83e\udd2f Relocation can take nearly 4.5 seconds for 1 million symbols!\n\nProfiling the linker with perf and visualizing the results with FlameGraph\n(click the image below to explore), we can see that the majority (+60% of\ncycles) of the time is spent in symbol resolution in the find_sym function.\n\nThe reason is that the cost of relocations is : O(R + nr log s), where R is\nthe number of relative relocations, n is the number of shared libraries, r is\nthe number of named relocations, and s is the number of symbols.\n\nIn fact, the cost of relocations is even worse. Each check for a symbol\ninvolves a strcmp which is O(m); ELF and C/C++ (GNU GCC) have no upper-limit\nfor the length of a symbol name. This means that the cost of relocations can\nbe O(R + n log s*m).\n\n> \ud83d\udd75\ufe0f name-mangling for C++ means that the prefix for many symbols are common\n> which necessitates checking most of the string during the strcmp if the\n> symbols reside in the same class.\n\n### Traditional Methods for Optimizing Symbol Resolution\n\nA popular historic method for optimizing relocations involved the prelink tool\nthat effectively performed all relocations ahead-of-time and saved the\nresulting binary to disk. This method, however, has become obsolete with the\nadvent of ASLR since the prelinked binary and it\u2019s dependent shared libraries\nare no longer loaded at the same base address.\n\nThe GNU toolchain includes an alternative symbol table DT_GNU_HASH that can be\nused to speedup symbol resolution. The main efficiency improvement is to\ninclude a bloom-filter in the ELF file that can be used to quickly determine\nif a symbol is present in the symbol table. This can reduce the number of\nstrcmp calls that are made and walking the symbol table.\n\nThe DT_GNU_HASH method is helpful but fundamentally fails to take advantage of\nthe static nature of store-based systems. The symbol table is still loaded\ninto memory and symbols must be re-resolved at runtime. Given the\ndeterministic set of shared-libraries, we can do something similar to that of\nprelink but with a twist. \ud83c\udf00\n\n## Optimizing ELF Relocations for Store-Based Systems\n\nThe major insight for store-based systems is that we can perform all symbol\nresolutions for relocations ahead-of-time and save the resulting binary to\ndisk. This is similar to prelink but with the twist that we are not performing\nthe actual relocations but rather saving the resolved shared-object for each\nrelocation.\n\nThis works on store-based systems, such as Nix, since the set of shared\nlibraries is fixed and immutable.\n\nLet\u2019s start of with the results of this optimization by looking at the extreme\ncase of 1 million symbols.\n\n    \n    \n    \u276f hyperfine --warmup 1 --runs 3 'DEBUG=1 RELOC_READ=1 ./1_million_functions.bin > /dev/null' Benchmark 1: DEBUG=1 RELOC_READ=1 ./1_million_functions.bin > /dev/null Time (mean \u00b1 \u03c3): 623.4 ms \u00b1 15.1 ms [User: 524.7 ms, System: 98.6 ms] Range (min ... max): 608.1 ms ... 638.3 ms 3 runs\n\n\ud83c\udf86 We cutdown the time to run the program down from 4.5 seconds -> ~600\nmilliseconds.\n\n\ud83c\udfce\ufe0f That is a 7.5x speedup! \ud83c\udfce\ufe0f\n\nTo achieve this improvement, I have a basic implementation built atop musl\u2019s\ndynamic loader.\n\n> You can try, play with and track my changes on my fork of musl\n\n  1. I\u2019ve added support for a new environment variable RELOC_WRITE that when set will write the resolved symbols for each relocation to disk in a file set by the variable.\n    \n        \u276f RELOC_WRITE=relo.bin ./1_million_functions.bin &>/dev/null\n\nThe resolves symbols are serialized as the simple structure below.\n\n    \n        typedef struct { // Type of the relocation int type; // Symbol value which is typically the offset size_t st_value; // Offset of the relocation size_t offset; // Aboslute path of the DSO where symbol was found char symbol_dso_name[255]; // Name of the DSO that needs the relocation char dso_name[255]; } CachedRelocInfo;\n\nThis file contains all symbol relocations for the binary and it\u2019s dependent\nshared libraries.\n\n  2. We add this serialized file to the ELF binary as a new section using objcopy\n    \n        \u276f objcopy --add-section .reloc.cache=relo.bin \\ --set-section-flags .reloc.cache=noload,readonly 1_million_functions.bin \\ 1_million_functions.bin\n\n  3. Run the program again, and the dynamic linker will use the cached symbol resolutions if the section .reloc.cache is present.\n    \n        \u276f ./1_million_functions.bin\n\nThe dynamic linker will load the symbol resolutions and apply them to the\nrelocations in the binary. The DSO names for each entry are needed so that the\nbase address for the offset of the relocation and the symbol value can be\ncalculated. This allows this optimization to work despite ASLR.\n\n> \ud83d\udd75\ufe0f Further optimizations can be done by removing the name of the shared\n> objects in the structure and replacing it with an index into the array of\n> shared objects that are loaded. This is possible since the load order of\n> shared objects must be deterministic to ensure reproducibility for symbol\n> resolution.\n\n\u2757 This optimization is only possible for store-based systems since the set of\nshared libraries is fixed and immutable. In a traditional Linux distribution,\neach shared library could be updated at any time, which would invalidate the\ncached symbol resolutions and their offsets.\n\nStore-based systems allow us to revisit many of the assumptions that have been\nmade in the past and I believe can lead to either a simpler or more efficient\ntoolchain. So far, these systems have adopted the same assumptions, but\nhopefully with improvements such as this or shrinkwrap we can begin to see the\nbenefits of the new paradigms they introduce.\n\nI'm a software engineer, father and wishful amateur surfer. If you've come\nseeking my political views; you've found the wrong Fareed.\n\nlinkedin fmzakari\n\ngithub fzakaria\n\nemail farid.m.zakaria@gmail.com\n\npgp D1B232E7\n\nArchive\n\nHistoric WordPress Blog\n\n### Recent Posts\n\n2024-05-03 Speeding up ELF relocations for store-based systems\n\n2024-03-03 Visualizing GitHub workflow run length time\n\n2024-02-27 Hermetic, but at what cost?\n\n### License\n\nThe content for this site is CC-BY-SA. The inspiration for the theme for this\nsite is \u00a9 Drew Devault.\n\nImprove this page @ c7c2c06\n\n", "frontpage": false}
