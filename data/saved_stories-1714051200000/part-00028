{"aid": "40152744", "title": "Why Is Local Development of NPM Packages So Hard? (2022)", "url": "https://blog.coding.kiwi/why-is-local-development-of-npm-packages-so-hard/", "domain": "coding.kiwi", "votes": 1, "user": "turtleyacht", "posted_at": "2024-04-25 02:41:58", "comments": 0, "source_title": "Why is local development of npm packages so hard?", "source_text": "Why is local development of npm packages so hard?\n\njavascript\n\n# Why is local development of npm packages so hard?\n\n#### CodingKiwi\n\nApr 16, 2022 \u2022 6 min read\n\nPhoto by Jalal Kelink / Unsplash\n\nTable of Contents\n\n  1. The Problem\n  2. Solution 1: npm link or yalc\n  3. Solution 2: npm workspaces\n  4. Solution 3: git dependencies\n  5. Solution 4: fake npm repository\n  6. Why the last timestamp?\n  7. The tarpit\n  8. Branches\n  9. Conclusion\n\n\ud83d\udca1\n\nDisclaimer: the information in this article is outdated! I will write an\nupdate soon\n\nSometimes you want to split up code into several npm packages, in my case I\nhad a css/vue library called \u201chop\u201d and a project, called \u201cflow\u201d in which I\nused hop.\n\nLater on I build a prosemirror-based text editor but because its quite huge I\ndid not want it to be part of hop. So I moved it to a seperate project/package\nand named it \u201chop-editor\u201d. Since I wanted to use some functionality of hop\ninside hop-editor I required it in the package.json of hop-editor.\n\n### The Problem\n\nWhile developing with multiple packages you might run into the problem that\nwith \u201creal\u201d npm packages for a change to be available in depending packages,\nyou would need to publish a new version of the package for each little change.\nFor example if I change a css rule in \u201chop\u201d a little, I would need to create\nand publish a new version to npm and run npm update in flow to have the change\nthere.\n\nWhile that does work, and thanks to npm version its quite simple to increment\nthe version number, it is not very elegant.\n\n### Solution 1: npm link or yalc\n\nRunning npm link in a folder of a package (in my case \u201chop\u201d) creates a symlink\nto a special global folder. After that, running npm link hop in flow symlinks\nthe package from the global folder into the node_modules folder of flow.\n\nThats great! File changes in hop would take immediate effect in flow, right?\n\nSadly npm link did not reliably work for me because symlinks tend to behave\ndifferently depending on the environment and setup (windows, linux, WSL,\ndocker on windows, docker in wsl.. just to name a few).\n\nUsing webpack makes it even harder since it sometimes freakes out when\nconfronted with the symlinked packages.\n\nSo because of that, someone build yalc:\n\n> Though this (npm link) may work in many cases, it often brings nasty\n> constraints and problems with dependency resolution, symlink\n> interoperability between file systems, etc.\n\nyalc acts like a local repository and injects file:/link: dependencies into\nthe package.json\n\nThis could work but if I now want to commit and push this package.json to the\ngit repo of flow to run tests in its ci/cd pipeline, it will fail because the\nlocal packages are not available there (except I git clone and link all kinds\nof packages into the pipeline on startup)\n\n### Solution 2: npm workspaces\n\nnpm workspaces are a bit like npm link except that they automate the process a\nbit. Basically the folder structure looks a bit like this:\n\n    \n    \n    . +-- package.json `-- packages +-- a | `-- package.json\n\nYou can read more about npm workspaces here:\nhttps://docs.npmjs.com/cli/v8/using-npm/workspaces\n\nrunning npm install in the root . directory of the example project above\nsymlinks the packages inside the \u201cpackages\u201d folder to the node_modules folder:\n\n    \n    \n    . +-- node_modules | `-- packages/a -> ../packages/a +-- package-lock.json +-- package.json `-- packages +-- a | `-- package.json\n\nSo npm workspaces could also be a valid solution, I could even push the whole\nproject into a repository and it would work in a pipeline. But the main issue\nis: the packages now only exist in this one project constellation.\n\nMeaning I can\u2019t really use the packages inside the packages folder in any\nother project\n\n### Solution 3: git dependencies\n\nI ended up having flow, hop and hop-editor each in a seperate git project,\nthen I installed hop in flow and hop-editor like this:\n\n    \n    \n    \"devDependencies\": { \"hop\": \"git+https://<link of my git repo>/hop.git\",\n\nGreat! now I can use hop from everywhere, get the latest version by simply\nrunning npm update and all without constantly using symlinks or pumping out\nnew package versions\n\nIt was too good to be true. Sadly but justifiably, npm does not recursively\nresolve git dependencies. What does that mean?\n\nLook at the following dependency tree:\n\n    \n    \n    flow: | -> \"hop\": \"git+https://<link of my git repo>/hop.git\", -> \"hop-editor\": \"git+https://<link of my git repo>/hop-editor.git\" | -> \"hop\": \"git+https://<link of my git repo>/hop.git\",\n\nAs you can see, both flow and hop-editor depend on hop. The dependencies \u201chop\u201d\nand \u201chop-editor\u201d of \u201cflow\u201d get resolved by npm because they are first-level\ndependencies. The actual effect of this is that webpack does not know what\n\u201chop\u201d is from inside \u201chop-editor\u201d eventhough it is installed in flow.\n\nThe nested dependency flow > hop-editor > hop is not resolved because it is a\nnon-first-level git dependency. Imagine npm would need to recursively fetch\ndependency git repositories of dependency git repositories to read the\npackage.json inside them \u2014 a huge performance issue!\n\n### Solution 4: fake npm repository\n\n> To resolve packages by name and version, npm talks to a registry website\n> that implements the CommonJS Package Registry specification for reading\n> package info.\n\nnpm allows you to specify a custom repository which is then used to resolve\npackages instead of the default public `https://registry.npmjs.org/`\n\nFor example using a .npmrc file like this, you can specify a custom registry\nfor a package scope:\n\n    \n    \n    @codingkiwi:registry=https://mycustomregistry.example.org\n\nNow it seems like a npm registry is just a simple api server that follows this\nspecification: http://wiki.commonjs.org/wiki/Packages/Registry\n\nBasically there are 3 endpoints: / , /<package> and /<package>/<version>\n\nFirst we point npm to the custom registry server for a certain scope like\nmentioned above. Then we set up a little express server which answers on the\n/<package> endpoint like this:\n\n    \n    \n    { \"_id\": \"@codingkiwi/hop\", \"name\": \"@codingkiwi/hop\", \"versions\": { \"1.1.5-1649875607\": { \"name\": \"@codingkiwi/hop\", \"version\": \"1.1.5-1649875607\", \"dist\": { \"tarball\": \"https://<repo>/archive/master.tar.gz\" } }, \"1.1.5\": { \"name\": \"@codingkiwi/hop\", \"version\": \"1.1.5\", \"dist\": { \"tarball\": \"https://<repo>/archive/v1.1.5.tar.gz\" } }, ...\n\nAs you can see it simply reads the latest version from the package.json of my\ngit repository which is 1.1.5 in that case and appends the timestamp of the\nlast commit of the repo to inject a fake latest version called\n\u201c1.1.5\u20131649875607\u201d\n\nThis fake version always points to the up-to-date tar.gz archive of the master\nbranch.\n\n### Why the last timestamp?\n\nnpm versions need to follow semver!\n\nAt first I appended the commit ref , for example 1.1.5-d73a38f2f which is a\nvalid semver, but npm resolves the pre-release bit (the part after the \u201c-\u201d) of\na version lexically in ASCII sort order and since the commit refs are random,\nit can happen that you have installed a version where the commit ref belongs\nto an older commit but the lexical sort order is higher than the latest\nversion provided by the endpoint.\n\nIf that happens, npm is confused because the newest version of the package is\nolder than the one it has installed, so it tries to check if the version that\nis installed can be found somewhere lower in the \u201cversions\u201d array/object\nprovided by the endpoint.\n\nBut since the endpoint does not create a fake version for each commit ref that\never existed (which would be possible but insane for git projects with\nthousands of commits), the version currently installed is not part of the\nversions list and npm fails with an error saying that the package does not\nexist.\n\nSince time does not run backwards the timestamp works more reliable since it\nis numerical and the latest version is always higher.\n\n### The tarpit\n\nIf the package.json of flow says: I want \u201c@codingkiwi/hop@1.1.5\u20131649875607\u201d\nnpm fetches the version from our registry but the package.json inside the hop\nproject itself still says \u201c1.1.5\u201d and that is also the version that npm puts\ninto the package-lock.json\n\nThat isn\u2019t an issue until you run npm ci which ignores the package.json and\njust loads packages from the package-lock.json. Since its \u201c1.1.5\u201d there and we\ndon\u2019t have \u201c1.1.5\u201d in our versions array (and we can\u2019t put it in there because\n1.1.5 is greater than 1.1.5\u2013xxxx in semver) npm ci fails.\n\nSo it got even crazier: I added a tar.gz endpoint to my fake registry which\nstreams the real tar.gz from the git repo and while streaming modifies the\nversion inside the package.json.\n\nAlso the tar.gz from my git repo has one folder in the root of the archive\nnamed \u201chop\u201d after the repository name, but npm needs it to be \u201cpackage\u201d or\notherwise the ssri integrity will fail, so I modify that folder name too.\n\n### Branches\n\nA desirable feature would be the possibility to install different branches.\nFor this to be possible we need a way to differentiate the versions by branch,\nsemver allows adding a build suffix after the version and prerelease part but\nit is not possible to install a specific build.\n\nSo the only solution would be using a different major or minor version number\nfor each branch, for example:\n\n0.0.<stamp> for master 0.1.<stamp> for branch1 0.2.<stamp> for branch2\n\nFor this to work we would need a deterministic system that chooses a number\nfor a branch that will work even if new branches are added or branches are\nremoved which may be possible by storing the branch list and incrementing the\nnumber when a new branch is detected.\n\nThe next problem to solve would be how a user will know which number is which\nbranch\n\nInstalling is as easy as npm install @prefix/repo@0.0 and because its a sub-\none version this will include >=0.0.0 && < 0.1.0 according to npm caret ranges\n\n### Conclusion\n\nIt solution 4 a good solution? Probably not. Being the first person to have a\ncertain solution for a problem sometimes means that the solution might not be\nthe best one.\n\nBut does it work? Yes :)\n\n## Quick and dirty network synced vue state\n\nFor some apps it can be useful to have the state server-side and sync it to\nthe clients live using websockets. One option is to just send the full state\neverytime it has changed, this has some disadvantages though * overhead: we\nsend the full state even if just one property\n\nApr 20, 2024 2 min read\n\n## My PHP VSCode / Docker / Remote SSH Setup\n\nEven though I mainly work on js projects I did a lot of laravel apps in the\npast and currently I still work on my project management app \"flow\" from time\nto time. Everything I explain in this post is based on my experience over the\npast years\n\nApr 2, 2024 6 min read\n\n## SQL Batch inserts are faster\n\nAt my current employer a PHP script was used that extracts entries from a\nlarge database table, optimizes them and saves them in a second table. This\nscript was written years ago and it ran every day for 12 hours. Although the\ngeneral rule \"never change a running system&\n\nOct 3, 2023 2 min read\n\nCodingKiwi \u00a9 2024\n\nPowered by Ghost\n\n", "frontpage": false}
