{"aid": "40112282", "title": "The problem with invariants is that they change over time", "url": "https://surfingcomplexity.blog/2024/03/26/the-problem-with-invariants-is-that-they-change-over-time/", "domain": "surfingcomplexity.blog", "votes": 1, "user": "kiyanwang", "posted_at": "2024-04-22 08:07:27", "comments": 0, "source_title": "The problem with invariants is that they change over time", "source_text": "The problem with invariants is that they change over time \u2013 Surfing Complexity\n\nSkip to content\n\nSurfing Complexity\n\nLorin Hochstein's ramblings about software, complex systems, and incidents.\n\n# The problem with invariants is that they change over time\n\nLorin Hochstein incidents, software, systems March 26, 2024March 26, 2024 1\nMinute\n\nCliff L. Biffle blogged a great write-up of a debugging odyssey at Oxide with\nthe title Who killed the network switch? Here\u2019s the bit that jumped out at me:\n\n> At the time that code was written, it was correct, but it embodied the\n> assumption that any loaned memory would fit into one region.\n>\n> That assumption became obsolete the moment that Matt implemented task\n> packing, but we didn\u2019t notice. This code, which was still simple and easy to\n> read, was now also wrong.\n\nThis type of assumption is an example of an invariant, a property of the\nsystem that is supposed to be guaranteed to not change over time. Invariants\nplay an important role in formal methods (for example, see the section Writing\nan invariant in Hillel Wayne\u2019s Learn TLA+ site).\n\nNow, consider the following:\n\n  * Our systems change over time. In particular, we will always make modifications to support new functionality that we could not have foreseen earlier in the lifecycle of the system.\n  * Our code often rests on a number of invariants, properties that are currently true of our system and that we assume will always be true.\n  * These invariants are implicit: the assumptions themselves are not explicitly represented in the source code. That means there\u2019s no easy way to, say, mechanically extract them via static analysis.\n  * A change can happen that violates an assumed invariant can be arbitrary far away from code that depends on the invariant to function properly.\n\nWhat this means is that these kinds of failure modes are inevitable. If you\u2019ve\nbeen in this business long enough, you\u2019ve almost certainly run into an\nincident where one of the contributors was an implicit invariant that was\nviolated by a new change. If you\u2019re system lives long enough, it\u2019s going to\nchange. And one of those changes is eventually going to invalidate an\nassumption that somebody made long ago, which was a reasonable assumption to\nmake at the time.\n\nImplicit invariants are, by definition, impossible to enforce explicitly. They\nare time bombs. And they are everywhere.\n\n### Share this:\n\n  * Twitter\n  * Facebook\n\nLike Loading...\n\nInductive invariantsDecember 27, 2018In \"software\"\n\nWhat if everybody did everything right?February 17, 2024In \"incidents\"\n\nWhen something you believe is falseJuly 2, 2012In \"software\"\n\n## Published by Lorin Hochstein\n\nView all posts by Lorin Hochstein\n\nPublished March 26, 2024March 26, 2024\n\n## 2 thoughts on \u201cThe problem with invariants is that they change over time\u201d\n\n  1. Bart Smaalders says:\n\nMarch 26, 2024 at 10:41 pm\n\nAny code that is maintained long enough will have this issue in spades. When I\nworked at Sun, we often found assumptions in kernel code about things that had\nbeen true ten (or twenty!) years earlier, but now seemed laughable. Software\ngardening is critical; we just have to revist our (or our predecessors)\nassumptions every so often. Every part of the software \u201cgarden\u201d needs spading\nat some point.\n\nReply\n\n  2. Verisimilitude says:\n\nMarch 28, 2024 at 1:16 pm\n\nI disagree.\n\n> Our systems change over time. In particular, we will always make\n> modifications to support new functionality that we could not have foreseen\n> earlier in the lifecycle of the system.\n>\n> Lorin Hochstein\n\nThe article hinges on this incorrect assumption. To provide a counterexample,\nI\u2019ll mention that mere modularity defeats this assumption. Functionality can\nbe fully specified, in some limited context, and never thereafter changed. An\nimplementation of a data structure would qualify as an example; its internal\nrepresentations, affecting such things as optimizations, can change, but the\ninterface to this functionality doesn\u2019t change. It follows that systems should\ncomprise smaller modules, so that ideally only the top-level, representing the\nparticular program itself, needs to change.\n\n> These invariants are implicit: the assumptions themselves are not explicitly\n> represented in the source code. That means there\u2019s no easy way to, say,\n> mechanically extract them via static analysis.\n>\n> Lorin Hochstein\n\nI use the Ada programming language, which makes these invariants explicit.\nSPARK goes even further with Ada. However, this quote is an argument in\nsupport of higher level programming systems, which have fewer and fewer\nassumptions. It\u2019s entirely possible to specify something at so high a level\nthat it need never change, and a system which processes mathematical equations\nwould be an example. Writing every program at a level where worthless details\npop up repeatedly and constantly is a recipe for disaster, yes.\n\n> A change can happen that violates an assumed invariant can be arbitrary far\n> away from code that depends on the invariant to function properly.\n>\n> Lorin Hochstein\n\nThis quote is an argument in support of small modules.\n\n> What this means is that these kinds of failure modes are inevitable.\n>\n> Lorin Hochstein\n\nVery cute, but this is wrong for the reasons I\u2019ve explained. Software can be\nperfect. If software be kept small, rewriting it becomes an alternation from\nchanging it.\n\n> Implicit invariants are, by definition, impossible to enforce explicitly.\n> They are time bombs. And they are everywhere.\n>\n> Lorin Hochstein\n\nWhen I write code in Common Lisp, and especially APL, I don\u2019t really suffer\nfrom implicit invariants, although some do remain. In addition to every method\nI\u2019ve mentioned so far, these implicit invariants should be documented where\nthey can\u2019t be made explicit otherwise.\n\nReply\n\n### Leave a comment Cancel reply\n\n# Elsewhere on the Internet\n\n  * Website: lorinhochstein.org\n  * Mastodon: @norootcause@hachyderm.io\n  * Twitter: @norootcause\n\n# Recent Posts\n\n  * The problem with invariants is that they change over time\n  * When there\u2019s no gemba to go to\n  * What if everybody did everything right?\n  * Book Review: Trust in Numbers\n  * Negotiability is non-negotiable\n\n# Archives\n\n  * March 2024\n  * February 2024\n  * January 2024\n  * December 2023\n  * September 2023\n  * August 2023\n  * June 2023\n  * April 2023\n  * March 2023\n  * February 2023\n  * January 2023\n  * December 2022\n  * November 2022\n  * October 2022\n  * September 2022\n  * August 2022\n  * July 2022\n  * June 2022\n  * May 2022\n  * April 2022\n  * January 2022\n  * December 2021\n  * November 2021\n  * October 2021\n  * September 2021\n  * August 2021\n  * July 2021\n  * June 2021\n  * May 2021\n  * April 2021\n  * February 2021\n  * January 2021\n  * December 2020\n  * September 2020\n  * August 2020\n  * July 2020\n  * June 2020\n  * May 2020\n  * April 2020\n  * March 2020\n  * February 2020\n  * January 2020\n  * November 2019\n  * October 2019\n  * September 2019\n  * August 2019\n  * July 2019\n  * June 2019\n  * May 2019\n  * March 2019\n  * January 2019\n  * December 2018\n  * October 2017\n  * June 2017\n  * May 2017\n  * February 2017\n  * January 2017\n  * July 2016\n  * June 2016\n  * October 2015\n  * August 2015\n  * June 2015\n  * April 2015\n  * February 2015\n  * November 2014\n  * October 2014\n  * September 2014\n  * August 2014\n  * July 2014\n  * June 2014\n  * May 2014\n  * April 2014\n  * March 2014\n  * November 2013\n  * September 2013\n  * August 2013\n  * June 2013\n  * May 2013\n  * March 2013\n  * February 2013\n  * December 2012\n  * November 2012\n  * October 2012\n  * August 2012\n  * July 2012\n  * April 2012\n  * March 2012\n  * February 2012\n  * January 2012\n  * December 2011\n\n# Categories\n\n  * books\n  * cognitive-systems-engineering\n  * education\n  * engineering\n  * incidents\n  * journalism\n  * netflix\n  * openstack\n  * research\n  * resilience\n  * software\n  * systems\n  * Uncategorized\n  * work\n\n# Meta\n\n  * Register\n  * Log in\n  * Entries feed\n  * Comments feed\n  * WordPress.com\n\nBlog at WordPress.com.\n\n  * Comment\n  * Reblog\n  * Subscribe Subscribed\n\n    * Surfing Complexity\n    * Already have a WordPress.com account? Log in now.\n\n  * Privacy\n  *     * Surfing Complexity\n    * Customize\n    * Subscribe Subscribed\n    * Sign up\n    * Log in\n    * Copy shortlink\n    * Report this content\n    * View post in Reader\n    * Manage subscriptions\n    * Collapse this bar\n\n%d\n\n", "frontpage": false}
