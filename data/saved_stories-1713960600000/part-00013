{"aid": "40139909", "title": "OAuth Modes", "url": "https://fusionauth.io/docs/lifecycle/authenticate-users/oauth/modes", "domain": "fusionauth.io", "votes": 1, "user": "mooreds", "posted_at": "2024-04-24 02:46:43", "comments": 0, "source_title": "Modes", "source_text": "Modes\n\n/ Docs\n\nLog In\n\n## Results\n\n  * If you search it, they will come.\n\n## Recent\n\n  * Item 1\n  * Item 1\n  * Item 1\n  * Item 1\n  * Item 1\n  * Item 1\n  * Item 1\n  * Item 1\n  * Item 1\n  * Item 1\n\nlifecycle / authenticate users / OAuth\n\n# Modes\n\n## Overview\n\nOAuth modes are ways that the OAuth and OIDC specifications are used. There\nare eight OAuth modes in common use today.\n\nnote\n\nThese are not standard concepts, but instead reflections of real world OAuth\nimplementations the FusionAuth team has observed over time.\n\n## The Modes\n\nThe OAuth modes are:\n\n  1. Local login and registration\n  2. Third-party login and registration (federated identity)\n  3. First-party login and registration (reverse federated identity)\n  4. Enterprise login and registration (federated identity with a twist)\n  5. Third-party service authorization\n  6. First-party service authorization\n  7. Machine-to-machine authentication and authorization\n  8. Device login and registration\n\nThere are multiple modes considered federated identity workflows. The reason\nto avoid the singular concept of \u201cfederated identity\u201d is that each case is\nslightly different. Plus, the term federated identity is often overloaded and\nmisunderstood.\n\nTo help clarify terms, the term \u201clogin\u201d is used instead. However, this is\ngenerally the same as \u201cfederated identity\u201d in that the user\u2019s identity is\nstored in an OAuth server and the authentication/authorization is delegated to\nthat server.\n\nModes are orthogonal to the grant types specified in RFC 6749. Instead, they\ndepend on who owns which piece of the system (the client, the resource server,\nthe authorization server).\n\nYou can use the authorization code grant, client credentials grant, or other\ngrant with any of the modes.\n\n## Which OAuth Mode Is Right For You?\n\nThe list above has eight different ways you can use OAuth. Didn\u2019t you just\nwant to add login to your application? How did things get so complex?\n\nThat\u2019s the power and the danger of OAuth. It is so flexible that people new to\nit can be overwhelmed. Here is a set of questions for you to ask yourself. The\nanswers will help you choose.\n\n  * Are you looking to outsource your authentication and authorization to a safe, secure and standards-friendly auth system? Check out Local Login and Registration .\n  * Trying to avoid storing any credentials because you don\u2019t want to handle passwords or other sensitive data? Third-party Login and Registration is what you want.\n  * Are you selling to Enterprise customers? Enterprise Login and Registration will be of interest.\n  * Are you building service to service communication with no user interaction? Check out Machine-to-machine Authorization .\n  * Are you trying to let a user log in from a separate device without a friendly typing interface? If this is the case, check out Device Login and Registration .\n  * Are you building a platform and want to allow other developers to ask for permissions to make calls to APIs or services on your platform? Review First-party Login and Registration and First-party Service Authorization .\n  * Do you have a user store already integrated and instead need to access a third party service on your users\u2019 behalf? Read up on Third-party Service Authorization .\n\n## Local Login and Registration\n\nThe Local login and registration mode is when you are using an OAuth workflow\nto register or log users into your application. In this mode, you own both the\nOAuth server and the application. You might not have written the OAuth server\n(if you are using a product such as FusionAuth), but you control it.\n\nIn fact, this mode usually feels like the user is signing up or logging\ndirectly into your application via native forms and there is no delegation at\nall.\n\nWhat do we mean by native forms? Most developers have at one time written\ntheir own login and registration forms directly into an application. They\ncreate a table called users and it stores everyone\u2019s username and password.\nThen they write the registration and the login forms (HTML or some other UI).\nThe registration form collects the username and password and checks if the\nuser exists in the database. If they don\u2019t, the application inserts the new\nuser into the database. The login form collects the username and password and\nchecks if the account exists in the database and logs the user in if it does.\nThis type of implementation is what we call native forms.\n\nThe only difference between native forms and the Local login and registration\nOAuth mode is that with the latter you delegate the login and registration\nprocess to an OAuth server rather than writing everything by hand.\n\nAdditionally, since you control the OAuth server and your application, it\nwould be odd to ask the user to \u201cauthorize\u201d your application. Therefore, this\nmode does not include the permission grant screens that often are mentioned in\nOAuth tutorials. Never fear; we\u2019ll cover these in the next few sections.\n\nSo, how does this work in practice? Let\u2019s take a look at the steps for a\nfictitious web application called \u201cThe World\u2019s Greatest ToDo List\u201d or \u201cTWGTL\u201d\n(pronounced \u201cTwig-Til\u201d):\n\n  1. A user visits TWGTL and wants to sign up and manage their ToDos.\n  2. They click the \u201cSign Up\u201d button on the homepage.\n  3. This button takes them over to the OAuth server. In fact, it takes them directly to the registration form that is included as part of the OAuth workflow (this typically happens with the Authorization Code grant, if you are familiar with OAuth terminology).\n  4. They fill out the registration form and click \u201cSubmit\u201d.\n  5. The OAuth server ensures this is a new user and creates their account.\n  6. The OAuth server redirects the browser back to TWGTL, which logs the user in.\n  7. The user uses TWGTL and adds their current ToDos.\n  8. The user stops using TWGTL; they head off and do some ToDos.\n  9. Later, the user comes back to TWGTL and needs to sign in to check off some ToDos. They click the My Account link at the top of the page.\n  10. This takes the user to the OAuth server\u2019s login page.\n  11. The user types in their username and password.\n  12. The OAuth server confirms their identity.\n  13. The OAuth server redirects the browser back to TWGTL, which logs the user in.\n  14. The user interacts with the TWGTL application, checking off those ToDos.\n\nThe user feels like they are registering and logging into TWGTL directly, but\nin fact, TWGTL is delegating this functionality to the OAuth server. The user\nis none-the-wiser so this is why we call this mode Local login and\nregistration.\n\nThis mode allows you to control the entire login experience, yet still have it\nabstracted from all of your applications.\n\nnote\n\nThe details of this mode have implications for the security best practices\nrecommended by some of the standards bodies for native apps. In particular,\nthe OAuth 2.0 for Native Apps Best Current Practices (BCP) recommends against\nusing a webview:\n\n> This best current practice requires that native apps MUST NOT use embedded\n> user-agents to perform authorization requests...\n\nThis is because the \u201cembedded user-agents\u201d, also known as webviews, are under\ncontrol of the mobile application developer in a way that the system browser\nis not.\n\nIf you are operating in a mode where the OAuth server is under a different\nparty\u2019s control, such as the third-party login that we\u2019ll cover next, this\nprohibition makes sense. But in this mode, you control everything. In that\ncase, the chances of a malicious webview being able to do extra damage is\nminimal, and must be weighed against the user interface issues associated with\npopping out to a system browser for authentication.\n\n## Third-party Login and Registration\n\nThe Third-party login and registration mode is typically implemented with the\nclassic \u201cLogin with ...\u201d buttons you see in many applications. These buttons\nlet users sign up or log in to your application by logging into one of their\nother accounts (i.e. Facebook or Google). Here, your application sends the\nuser over to Facebook or Google to log in.\n\nLet\u2019s use Facebook as an example OAuth provider. In most cases, your\napplication will need to use one or more APIs from the OAuth provider in order\nto retrieve information about the user or do things on behalf of the user (for\nexample sending a message on behalf of the user). In order to use those APIs,\nthe user has to grant your application permissions. To accomplish this, the\nthird-party service usually shows the user a screen that asks for certain\npermissions. These are called \u201cscopes\u201d in the OAuth specifications. We\u2019ll\nrefer to these screens as the \u201cpermission grant screen\u201d throughout the rest of\nthe document.\n\nFor example, Facebook will present a screen asking the user to share their\nemail address with your application. Once the user grants these permissions,\nyour application can call the Facebook APIs using an access token.\n\nHere\u2019s an example of the Facebook permission grant screen, where Zapier would\nlike to access a user\u2019s email address:\n\nAfter the user has logged into the third-party OAuth server and granted your\napplication permissions, they are redirected back to your application and\nlogged into it.\n\nThis mode is different from the previous mode because the user logged in but\nalso granted your application permissions to the service (Facebook). This is\none reason so many applications leverage \u201cLogin with Facebook\u201d or other social\nintegrations. It not only logs the user in, but also gives them access to call\nthe Facebook APIs on the user\u2019s behalf.\n\nSocial logins are the most common examples of this mode, but there are plenty\nof other third-party OAuth servers beyond social networks (GitHub or Discord\nfor example).\n\nThis mode is a good example of federated identity. Here, the user\u2019s identity\n(username and password) is stored in the third-party system. They are using\nthat system to register or log in to your application.\n\nHow does this work in practice? Let\u2019s take a look at the steps for our TWGTL\napplication if we want to use Facebook to register and log users in:\n\n  1. A user visits TWGTL and wants to sign up and manage their ToDos.\n  2. They click the \u201cSign Up\u201d button on the homepage.\n  3. On the login and registration screen, the user clicks the \u201cLogin with Facebook\u201d button.\n  4. This button takes them over to Facebook\u2019s OAuth server.\n  5. They log in to Facebook (if they aren\u2019t already logged in).\n  6. Facebook presents the user with the permission grant screen based on the permissions TWGTL needs. This is done using OAuth scopes.\n  7. Facebook redirects the browser back to TWGTL, which logs the user in. TWGTL also calls Facebook APIs to retrieve the user\u2019s information.\n  8. The user begins using TWGTL and adds their current ToDos.\n  9. The user stops using TWGTL; they head off and do some ToDos.\n  10. Later, the user comes back to TWGTL and needs to log in to check off some of their ToDos. They click the My Account link at the top of the page.\n  11. This takes the user to the TWGTL login screen that contains the \u201cLogin with Facebook\u201d button.\n  12. Clicking this takes the user back to Facebook and they repeat the same process as above.\n\nYou might be wondering if the Third-party login and registration mode can work\nwith the Local login and registration mode. Absolutely! This is what I like to\ncall Nested federated identity. Basically, your application delegates its\nregistration and login forms to an OAuth server like FusionAuth.\n\nYour application also allows users to sign in with Facebook by enabling that\nfeature of the OAuth server (FusionAuth calls this the Facebook Identity\nProvider. It\u2019s a little more complex, but the flow looks something like this:\n\n  1. A user visits TWGTL and wants to sign up and manage their ToDos.\n  2. They click the \u201cSign Up\u201d button on the homepage.\n  3. This button takes them over to the OAuth server\u2019s login page.\n  4. On this page, there is a button to \u201cLogin with Facebook\u201d and the user clicks that.\n  5. This button takes them over to Facebook\u2019s OAuth server.\n  6. They log in to Facebook.\n  7. Facebook presents the user with the permission grant screen.\n  8. The user authorizes the requested permissions.\n  9. Facebook redirects the browser back to TWGTL\u2019s OAuth server, which reconciles out the user\u2019s account.\n  10. TWGTL\u2019s OAuth server redirects the user back to the TWGTL application.\n  11. The user is logged into TWGTL.\n\nnote\n\nWhat does \u201creconcile out\u201d mean? To reconcile a user with a remote system means\noptionally creating a local account and then attaching data and identity from\na remote data source like Facebook to that account. The remote account is the\nauthority and the local account is modified as needed to reflect remote data.\n\nThe nice part about this workflow is that TWGTL doesn\u2019t have to worry about\nintegrating with Facebook (or any other provider) or reconciling the user\u2019s\naccount. That\u2019s handled by the OAuth server. It\u2019s also possible to delegate to\nadditional OAuth servers, easily adding \u201cLogin with Google\u201d or \u201cLogin with\nApple\u201d.\n\n## First-party Login and Registration\n\nThe First-party login and registration mode is the inverse of the Third-party\nlogin and registration mode. Basically, if you happen to be an organization\nlike Facebook in the examples above and your customer is playing the role of\nTWGTL, you are providing the OAuth server to your customer.\n\nOne benefit of using OAuth for this is that you are also providing a way for\nthem to call your APIs on behalf of your users.\n\nThis type of setup is not just reserved for the massive social networks like\nFacebook and Google. More and more companies are offering this functionality\nto their customers and partners, therefore becoming platforms.\n\n## Enterprise Login and Registration\n\nThe Enterprise login and registration mode is when your application allows\nusers to sign up or log in with an enterprise identity provider such as a\ncorporate Active Directory. This mode is very similar to the Third-party login\nand registration mode, but with a few critical differences.\n\nFirst, it rarely requires the user to grant permissions to your application\nusing a granting screen. Typically, a user does not have the option to grant\nor restrict permissions for your application, since such permissions are\nmanaged by IT in an enterprise directory or, less commonly, within your\napplication.\n\nSecond, this mode does not apply to all users of an application. In most\ncases, this mode is only available to the subset of users who exist in the\nenterprise directory. The rest of your users will either log in directly to\nyour application using Local login and registration or through the Third-party\nlogin and registration mode. In some cases, the user\u2019s email address\ndetermines the authentication source.\n\nYou might have noticed some login forms only ask for your email on the first\nstep like this:\n\nKnowing a user\u2019s email domain allows the OAuth server to determine where to\nsend the user to log in or if they should log in locally. If you work at\nExample Company, proud purveyors of TWGTL, providing richard@example.com to\nthe login screen allows the OAuth server to know you are an employee and\nshould be authenticated against a corporate authentication source. If instead\nyou enter dinesh@gmail.com, you won\u2019t be authenticated against that directory.\n\nOutside of these differences, this mode behaves much the same as the Third-\nparty login and registration mode.\n\nThis is the final mode where users can register and log in to your\napplication. The remaining modes are used entirely for authorization, usually\nto application programming interfaces (APIs). We\u2019ll cover these modes next.\n\n## Third-party Service Authorization\n\nThe third-party service authorization mode is quite different from the Third-\nparty login and registration mode; don\u2019t be deceived by the similar names.\nHere, the user is already logged into your application. The login could have\nbeen through a native form (as discussed above) or using the Local login and\nregistration mode, the Third-party login and registration mode, or the\nEnterprise login and registration mode. Since the user is already logged in,\nall they are doing is granting access for your application to call third-\nparty\u2019s APIs on their behalf.\n\nFor example, let\u2019s say a user has an account with TWGTL, but each time they\ncomplete a ToDo, they want to let their followers on WUPHF know. WUPHF is a\nfictional up and coming social network. To accomplish this, TWGTL provides an\nintegration that will automatically send a WUPHF when the user completes a\nToDo. The integration uses the WUPHF APIs and calling those requires an access\ntoken. In order to get an access token, the TWGTL application needs to log the\nuser into WUPHF via OAuth.\n\nTo hook all of this up, TWGTL needs to add a button to the user\u2019s profile page\nthat says \u201cConnect your WUPHF account\u201d. Notice it doesn\u2019t say \u201cLogin with\nWUPHF\u201d since the user is already logged in; the user\u2019s identity for TWGTL is\nnot delegated to WUPHF. Once the user clicks this button, they will be taken\nto WUPHF\u2019s OAuth server to log in and grant the necessary permissions for\nTWGTL to WUPHF for them.\n\nSince WUPHF doesn\u2019t actually exist, here\u2019s an example screenshot from Buffer,\na service which posts to your social media accounts such as Twitter.\n\nWhen you connect a Twitter account to Buffer, you\u2019ll see a screen like this:\n\nThe workflow for this mode looks like:\n\n  1. A user visits TWGTL and logs into their account.\n  2. They click the \u201cMy Profile\u201d link.\n  3. On their account page, they click the \u201cConnect your WUPHF account\u201d button.\n  4. This button takes them over to WUPHF\u2019s OAuth server.\n  5. They log in to WUPHF.\n  6. WUPHF presents the user with the \u201cpermission grant screen\u201d and asks if TWGTL can WUPHF on their behalf.\n  7. The user grants TWGTL this permission.\n  8. WUPHF redirects the browser back to TWGTL where it calls WUPHF\u2019s OAuth server to get an access token.\n  9. TWGTL stores the access token in its database and can now call WUPHF APIs on behalf of the user. Success!\n\n## First-party Service Authorization\n\nThe First-party service authorization mode is the inverse of the Third-party\nservice authorization mode. When another application wishes to call your APIs\non behalf of one of your users, you are in this mode. Here, your application\nis the \u201cthird-party service\u201d discussed above. Your application asks the user\nif they want to grant the other application specific permissions. Basically,\nif you are building a platform and want developers to be able to call your\nAPIs on behalf of their users, you\u2019ll need to support this OAuth mode.\n\nWith this mode, your OAuth server might display a \u201cpermission grant screen\u201d to\nthe user asking if they want to grant the third-party application permissions\nto your APIs. This isn\u2019t strictly necessary and depends on your requirements,\nbut if it is, you want custom scopes.\n\nCustom scopes are not currently supported in FusionAuth; here\u2019s the GitHub\ntracking issue.\n\n## Machine-to-machine Authorization\n\nThe Machine-to-machine authorization OAuth mode is different from the previous\nmodes we\u2019ve covered. This mode does not involve users at all. Rather, it\nallows an application to interact with another application. Normally, this is\nbackend services communicating with each other via APIs.\n\nHere, one backend needs to be granted access to the other. We\u2019ll call the\nfirst backend the source and the second backend the target.\n\nTo accomplish this, the source authenticates with the OAuth server. The OAuth\nserver confirms the identity of the source and then returns a token that the\nsource will use to call the target. This token can also include permissions\nthat are used by the target to authorize the call the source is making.\n\nUsing our TWGTL example, let\u2019s say that TWGTL has two microservices: one to\nmanage ToDos and another to send WUPHFs. The ToDo microservice needs to call\nthe WUPHF microservice. The WUPHF microservice needs to ensure that any caller\nis allowed to use its APIs before it WUPHFs.\n\nThe workflow for this mode looks like:\n\n  1. The ToDo microservice authenticates with the OAuth server.\n  2. The OAuth server returns a token to the ToDo microservice.\n  3. The ToDo microservice calls an API in the WUPHF microservice and includes the token in the request.\n  4. The WUPHF microservice verifies the token by calling the OAuth server (or verifying the token itself if the token is a JWT).\n  5. If the token is valid, the WUPHF microservice performs the operation.\n\n## Device Login and Registration\n\nThe Device login and registration mode is used to log in to (or register) a\nuser\u2019s account on a device that doesn\u2019t have a rich input device like a\nkeyboard. In this case, a user connects the device to their account, usually\nto ensure their account is active and the device is allowed to use it.\n\nA good example of this mode is setting up a streaming app on an Apple TV,\nsmart TV, or other device such as a Roku. In order to ensure you have a\nsubscription to the streaming service, the app needs to verify the user\u2019s\nidentity and connect to their account. The app on the Apple TV device displays\na code and a URL and asks the user to visit the URL. The workflow for this\nmode is as follows:\n\n  1. The user opens the app on the Apple TV.\n  2. The app displays a code and a URL.\n  3. The user types in the URL displayed by the Apple TV on their phone or computer.\n  4. The user is taken to the OAuth server and asked for the code.\n  5. The user submits this form and is taken to the login page.\n  6. The user logs into the OAuth server.\n  7. The user is taken to a \u201cFinished\u201d screen.\n  8. A few seconds later, the device is connected to the user\u2019s account.\n\nThis mode often takes a bit of time to complete because the app on the Apple\nTV is polling the OAuth server.\n\n## Conclusion\n\nModes are reflective of the flexibility of OAuth. Picking the right mode, or\nset of modes, can help you pick the correct identity architecture for the\nproblem you are solving.\n\n### On this page\n\n## Results\n\n## Recent\n\n  * Item 1\n  * Item 1\n  * Item 1\n  * Item 1\n  * Item 1\n  * Item 1\n  * Item 1\n  * Item 1\n  * Item 1\n  * Item 1\n\n", "frontpage": false}
