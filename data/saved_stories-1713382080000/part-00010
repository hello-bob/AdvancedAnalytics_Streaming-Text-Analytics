{"aid": "40063499", "title": "Erasure Coding (Forward Error Correction)", "url": "https://en.wikipedia.org/wiki/Erasure_code", "domain": "wikipedia.org", "votes": 1, "user": "noctarius", "posted_at": "2024-04-17 12:12:50", "comments": 0, "source_title": "Erasure code", "source_text": "Erasure code - Wikipedia\n\nJump to content\n\nSearch\n\n# Erasure code\n\n  * Fran\u00e7ais\n  * \u65e5\u672c\u8a9e\n  * \u0420\u0443\u0441\u0441\u043a\u0438\u0439\n  * \u0423\u043a\u0440\u0430\u0457\u043d\u0441\u044c\u043a\u0430\n  * \u4e2d\u6587\n\nEdit links\n\nFrom Wikipedia, the free encyclopedia\n\nThis article needs additional citations for verification. Please help improve\nthis article by adding citations to reliable sources. Unsourced material may\nbe challenged and removed. Find sources: \"Erasure code\" \u2013 news \u00b7 newspapers \u00b7\nbooks \u00b7 scholar \u00b7 JSTOR (August 2023) (Learn how and when to remove this\ntemplate message)  \n---  \n  \nCode added to allow recovery of lost data\n\nIn coding theory, an erasure code is a forward error correction (FEC) code\nunder the assumption of bit erasures (rather than bit errors), which\ntransforms a message of k symbols into a longer message (code word) with n\nsymbols such that the original message can be recovered from a subset of the n\nsymbols. The fraction r = k/n is called the code rate. The fraction k\u2019/k,\nwhere k\u2019 denotes the number of symbols required for recovery, is called\nreception efficiency. The recovery algorithm expects that it is known which of\nthe n symbols are lost \u2014 unlike forward error correction codes.\n\n## Optimal erasure codes[edit]\n\nThis section may be too technical for most readers to understand. Please help\nimprove it to make it understandable to non-experts, without removing the\ntechnical details. (August 2023) (Learn how and when to remove this template\nmessage)  \n---  \n  \nOptimal erasure codes have the property that any k out of the n code word\nsymbols are sufficient to recover the original message (i.e., they have\noptimal reception efficiency). Optimal erasure codes are maximum distance\nseparable codes (MDS codes).\n\n### Parity check[edit]\n\nSee also: Parity bit\n\nParity check is the special case where n = k + 1. From a set of k values , a\nchecksum is computed and appended to the k source values:\n\nThe set of k + 1 values is now consistent with regard to the checksum. If one\nof these values, , is erased, it can be easily recovered by summing the\nremaining variables:\n\n### Polynomial oversampling[edit]\n\n#### Example: Err-mail (k = 2)[edit]\n\nIn the simple case where k = 2, redundancy symbols may be created by sampling\ndifferent points along the line between the two original symbols. This is\npictured with a simple example, called err-mail:\n\nAlice wants to send her telephone number (555629) to Bob using err-mail. Err-\nmail works just like e-mail, except\n\n  1. About half of all the mail gets lost.^[1]\n  2. Messages longer than 5 characters are illegal.\n  3. It is very expensive (similar to air-mail).\n\nInstead of asking Bob to acknowledge the messages she sends, Alice devises the\nfollowing scheme.\n\n  1. She breaks her telephone number up into two parts a = 555, b = 629, and sends 2 messages \u2013 \"A=555\" and \"B=629\" \u2013 to Bob.\n  2. She constructs a linear function, , in this case , such that and .\n\n  1. She computes the values f(3), f(4), and f(5), and then transmits three redundant messages: \"C=703\", \"D=777\" and \"E=851\".\n\nBob knows that the form of f(k) is , where a and b are the two parts of the\ntelephone number. Now suppose Bob receives \"D=777\" and \"E=851\".\n\nBob can reconstruct Alice's phone number by computing the values of a and b\nfrom the values (f(4) and f(5)) he has received. Bob can perform this\nprocedure using any two err-mails, so the erasure code in this example has a\nrate of 40%.\n\nNote that Alice cannot encode her telephone number in just one err-mail,\nbecause it contains six characters, and that the maximum length of one err-\nmail message is five characters. If she sent her phone number in pieces,\nasking Bob to acknowledge receipt of each piece, at least four messages would\nhave to be sent anyway (two from Alice, and two acknowledgments from Bob). So\nthe erasure code in this example, which requires five messages, is quite\neconomical.\n\nThis example is a little bit contrived. For truly generic erasure codes that\nwork over any data set, we would need something other than the f(i) given.\n\n#### General case[edit]\n\nThe linear construction above can be generalized to polynomial interpolation.\nAdditionally, points are now computed over a finite field.\n\nFirst we choose a finite field F with order of at least n, but usually a power\nof 2. The sender numbers the data symbols from 0 to k \u2212 1 and sends them. He\nthen constructs a (Lagrange) polynomial p(x) of order k such that p(i) is\nequal to data symbol i. He then sends p(k), ..., p(n \u2212 1). The receiver can\nnow also use polynomial interpolation to recover the lost packets, provided he\nreceives k symbols successfully. If the order of F is less than 2^b, where b\nis the number of bits in a symbol, then multiple polynomials can be used.\n\nThe sender can construct symbols k to n \u2212 1 'on the fly', i.e., distribute the\nworkload evenly between transmission of the symbols. If the receiver wants to\ndo his calculations 'on the fly', he can construct a new polynomial q, such\nthat q(i) = p(i) if symbol i < k was received successfully and q(i) = 0 when\nsymbol i < k was not received. Now let r(i) = p(i) \u2212 q(i). Firstly we know\nthat r(i) = 0 if symbol i < k has been received successfully. Secondly, if\nsymbol i \u2265 k has been received successfully, then r(i) = p(i) \u2212 q(i) can be\ncalculated. So we have enough data points to construct r and evaluate it to\nfind the lost packets. So both the sender and the receiver require O(n (n \u2212\nk)) operations and only O(n \u2212 k) space for operating 'on the fly'.\n\n#### Real world implementation[edit]\n\nThis process is implemented by Reed\u2013Solomon codes, with code words constructed\nover a finite field using a Vandermonde matrix.\n\nMost practical erasure codes are systematic codes -- each one of the original\nk symbols can be found copied, unencoded, as one of the n message symbols.^[2]\n(Erasure codes that support secret sharing never use a systematic code).\n\n## Near-optimal erasure codes[edit]\n\nNear-optimal erasure codes require (1 + \u03b5)k symbols to recover the message\n(where \u03b5>0). Reducing \u03b5 can be done at the cost of CPU time. Near-optimal\nerasure codes trade correction capabilities for computational complexity:\npractical algorithms can encode and decode with linear time complexity.\n\nFountain codes (also known as rateless erasure codes) are notable examples of\nnear-optimal erasure codes. They can transform a k symbol message into a\npractically infinite encoded form, i.e., they can generate an arbitrary amount\nof redundancy symbols that can all be used for error correction. Receivers can\nstart decoding after they have received slightly more than k encoded symbols.\n\nRegenerating codes address the issue of rebuilding (also called repairing)\nlost encoded fragments from existing encoded fragments. This issue occurs in\ndistributed storage systems where communication to maintain encoded redundancy\nis a problem.^[2]\n\n## Applications of erasure coding in storage systems[edit]\n\nErasure coding is now standard practice for reliable data storage.^[3]^[4]^[5]\nIn particular, various implementations of Reed-Solomon erasure coding are used\nby Apache Hadoop, the RAID-6 built into Linux, Microsoft Azure, Facebook cold\nstorage, and Backblaze Vaults.^[5]^[2]\n\nThe classical way to recover from failures in storage systems was to use\nreplication. However, replication incurs significant overhead in terms of\nwasted bytes. Therefore, increasingly large storage systems, such as those\nused in data centers use erasure-coded storage. The most common form of\nerasure coding used in storage systems is Reed-Solomon (RS) code, an advanced\nmathematics formula used to enable regeneration of missing data from pieces of\nknown data, called parity blocks. In a (k, m) RS code, a given set of k data\nblocks, called \"chunks\", are encoded into (k + m) chunks. The total set of\nchunks comprises a stripe. The coding is done such that as long as at least k\nout of (k + m) chunks are available, one can recover the entire data. This\nmeans a (k, m) RS-encoded storage can tolerate up to m failures.\n\nExample: In RS (10, 4) code, which is used in Facebook for their HDFS,^[6] 10\nMB of user data is divided into ten 1MB blocks. Then, four additional 1 MB\nparity blocks are created to provide redundancy. This can tolerate up to 4\nconcurrent failures. The storage overhead here is 14/10 = 1.4X.\n\nIn the case of a fully replicated system, the 10 MB of user data will have to\nbe replicated 4 times to tolerate up to 4 concurrent failures. The storage\noverhead in that case will be 50/10 = 5 times.\n\nThis gives an idea of the lower storage overhead of erasure-coded storage\ncompared to full replication and thus the attraction in today's storage\nsystems.\n\nInitially, erasure codes were used to reduce the cost of storing \"cold\"\n(rarely-accessed) data efficiently; but erasure codes can also be used to\nimprove performance serving \"hot\" (more-frequently-accessed) data.^[2]\n\n## Examples[edit]\n\nHere are some examples of implementations of the various codes:\n\n### Near optimal erasure codes[edit]\n\n  * Tornado codes\n  * Low-density parity-check codes\n\n### Near optimal fountain (rateless erasure) codes[edit]\n\n  * Fountain code\n  * Online codes\n  * LT codes\n  * Raptor codes\n  * Network Codes\n  * Triangular codes\n\n### Optimal erasure codes[edit]\n\n  * Parity: used in RAID storage systems.\n  * Parchive\n  * Tahoe-LAFS includes zfec\n  * Reed\u2013Solomon codes\n  * Erasure Resilient Systematic Code, an MDS code outperforming Reed\u2013Solomon in the maximal number of redundant packets,^[according to whom?] see RS(4,2) with 2 bits or RS(9,2) with 3 bits\n  * Regenerating Codes^[7]^[8]\n  * any other maximum distance separable code\n\n## See also[edit]\n\n  * Forward error correction codes.\n  * Secret sharing (differs in that the original secret is encrypted and obscured until the decode quorum is reached)\n  * Spelling alphabet\n\n## References[edit]\n\n  1. ^ Some versions of this story refer to the err-mail daemon.\n  2. ^ Jump up to: ^a ^b ^c ^d Rashmi Vinayak. \"Erasure Coding for Big-data Systems: Theory and Practice\". 2016. p. 2: section \"Abstract\". p. 9: section \"Systematic codes\". p. 12: section \"Regenerating codes\".\n  3. ^ \"Erasure Encoding\u2014Practice and Principles\". 2016.\n  4. ^ Matt Sarrel. \"Erasure Coding 101\". 2022.\n  5. ^ Jump up to: ^a ^b Brian Beach. \"Backblaze Open-sources Reed-Solomon Erasure Coding Source Code\". 2015.\n  6. ^ Xia, Mingyuan; Saxena, Mohit; Blaum, Mario; Pease, David A. (2015). A Tale of Two Erasure Codes in {HDFS}. pp. 213\u2013226. ISBN 978-1-931971-20-1.\n  7. ^ Dimakis, Alexandros G.; Godfrey, P. Brighten; Wu, Yunnan; Wainwright, Martin J.; Ramchandran, Kannan (September 2010). \"Network Coding for Distributed Storage Systems\". IEEE Transactions on Information Theory. 56 (9): 4539\u20134551. arXiv:cs/0702015. CiteSeerX 10.1.1.117.6892. doi:10.1109/TIT.2010.2054295. S2CID 260559901.\n  8. ^ \"home [Erasure Coding for Distributed Storage Wiki]\". 2017-07-31. Archived from the original on 2017-07-31. Retrieved 2023-08-20.\n\n## External links[edit]\n\n  * Jerasure is a Free Software library implementing Reed-Solomon and Cauchy erasure code techniques with SIMD optimisations.\n  * Software FEC in computer communications by Luigi Rizzo describes optimal erasure correction codes\n  * Feclib is a near optimal extension to Luigi Rizzo's work that uses band matrices. Many parameters can be set, like the size of the width of the band and size of the finite field. It also successfully exploits the large register size of modern CPUs. How it compares to the near optimal codes mentioned above is unknown.\n  * Coding for Distributed Storage wiki for regenerating codes and rebuilding erasure codes.\n  * ECIP \"Erasure Code Internet Protocol\" Developed in 1996, was the first use of FEC \"Forward Error correction\" on the Internet. It was first used commercially to *stream live video of Sir Arthur C. Clarke in Sri Lanka to UIUC in Indiana.\n\nRetrieved from\n\"https://en.wikipedia.org/w/index.php?title=Erasure_code&oldid=1214399590\"\n\nCategory:\n\n  * Coding theory\n\nHidden categories:\n\n  * Articles needing additional references from August 2023\n  * All articles needing additional references\n  * Articles with short description\n  * Short description is different from Wikidata\n  * Wikipedia articles that are too technical from August 2023\n  * All articles that are too technical\n  * All articles with specifically marked weasel-worded phrases\n  * Articles with specifically marked weasel-worded phrases from August 2023\n\n  * This page was last edited on 18 March 2024, at 18:44 (UTC).\n  * Text is available under the Creative Commons Attribution-ShareAlike License 4.0; additional terms may apply. By using this site, you agree to the Terms of Use and Privacy Policy. Wikipedia\u00ae is a registered trademark of the Wikimedia Foundation, Inc., a non-profit organization.\n\n  * Privacy policy\n  * About Wikipedia\n  * Disclaimers\n  * Contact Wikipedia\n  * Code of Conduct\n  * Developers\n  * Statistics\n  * Cookie statement\n  * Mobile view\n  * Edit preview settings\n\n", "frontpage": false}
