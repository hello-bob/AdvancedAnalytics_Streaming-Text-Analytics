{"aid": "40284437", "title": "Esbuild implements the JavaScript decorators proposal", "url": "https://github.com/evanw/esbuild/releases/tag/v0.21.0", "domain": "github.com/evanw", "votes": 1, "user": "yurivish", "posted_at": "2024-05-07 11:51:27", "comments": 0, "source_title": "Release v0.21.0 \u00b7 evanw/esbuild", "source_text": "Release v0.21.0 \u00b7 evanw/esbuild \u00b7 GitHub\n\nSkip to content\n\n## Navigation Menu\n\nSign in\n\n# Search code, repositories, users, issues, pull requests...\n\nSearch syntax tips\n\nSign in\n\nSign up\n\nYou signed in with another tab or window. Reload to refresh your session. You\nsigned out in another tab or window. Reload to refresh your session. You\nswitched accounts on another tab or window. Reload to refresh your session.\nDismiss alert\n\nevanw / esbuild Public\n\n  * Notifications\n  * Fork 1.1k\n  * Star 37.3k\n\n# v0.21.0\n\nLatest\n\nLatest\n\ngithub-actions released this 07 May 02:53\n\nv0.21.0\n\nc6da2c3\n\nThis release doesn't contain any deliberately-breaking changes. However, it\ncontains a very complex new feature and while all of esbuild's tests pass, I\nwould not be surprised if an important edge case turns out to be broken. So\nI'm releasing this as a breaking change release to avoid causing any trouble.\nAs usual, make sure to test your code when you upgrade.\n\n  * Implement the JavaScript decorators proposal (#104)\n\nWith this release, esbuild now contains an implementation of the upcoming\nJavaScript decorators proposal. This is the same feature that shipped in\nTypeScript 5.0 and has been highly-requested on esbuild's issue tracker. You\ncan read more about them in that blog post and in this other (now slightly\noutdated) extensive blog post here: https://2ality.com/2022/10/javascript-\ndecorators.html. Here's a quick example:\n\n    \n        const log = (fn, context) => function() { console.log(`before ${context.name}`) const it = fn.apply(this, arguments) console.log(`after ${context.name}`) return it } class Foo { @log static foo() { console.log('in foo') } } // Logs \"before foo\", \"in foo\", \"after foo\" Foo.foo()\n\nNote that this feature is different than the existing \"TypeScript experimental\ndecorators\" feature that esbuild already implements. It uses similar syntax\nbut behaves very differently, and the two are not compatible (although it's\nsometimes possible to write decorators that work with both). TypeScript\nexperimental decorators will still be supported by esbuild going forward as\nthey have been around for a long time, are very widely used, and let you do\ncertain things that are not possible with JavaScript decorators (such as\ndecorating function parameters). By default esbuild will parse and transform\nJavaScript decorators, but you can tell esbuild to parse and transform\nTypeScript experimental decorators instead by setting\n\"experimentalDecorators\": true in your tsconfig.json file.\n\nProbably at least half of the work for this feature went into creating a test\nsuite that exercises many of the proposal's edge cases:\nhttps://github.com/evanw/decorator-tests. It has given me a reasonable level\nof confidence that esbuild's initial implementation is acceptable. However, I\ndon't have access to a significant sample of real code that uses JavaScript\ndecorators. If you're currently using JavaScript decorators in a real code\nbase, please try out esbuild's implementation and let me know if anything\nseems off.\n\n\u26a0\ufe0f WARNING \u26a0\ufe0f\n\nThis proposal has been in the works for a very long time (work began around 10\nyears ago in 2014) and it is finally getting close to becoming part of the\nJavaScript language. However, it's still a work in progress and isn't a part\nof JavaScript yet, so keep in mind that any code that uses JavaScript\ndecorators may need to be updated as the feature continues to evolve. The\ndecorators proposal is pretty close to its final form but it can and likely\nwill undergo some small behavioral adjustments before it ends up becoming a\npart of the standard. If/when that happens, I will update esbuild's\nimplementation to match the specification. I will not be supporting old\nversions of the specification.\n\n  * Optimize the generated code for private methods\n\nPreviously when lowering private methods for old browsers, esbuild would\ngenerate one WeakSet for each private method. This mirrors similar logic for\ngenerating one WeakSet for each private field. Using a separate WeakMap for\nprivate fields is necessary as their assignment can be observable:\n\n    \n        let it class Bar { constructor() { it = this } } class Foo extends Bar { #x = 1 #y = null.foo static check() { console.log(#x in it, #y in it) } } try { new Foo } catch {} Foo.check()\n\nThis prints true false because this partially-initialized instance has #x but\nnot #y. In other words, it's not true that all class instances will always\nhave all of their private fields. However, the assignment of private methods\nto a class instance is not observable. In other words, it's true that all\nclass instances will always have all of their private methods. This means\nesbuild can lower private methods into code where all methods share a single\nWeakSet, which is smaller, faster, and uses less memory. Other JavaScript\nprocessing tools such as the TypeScript compiler already make this\noptimization. Here's what this change looks like:\n\n    \n        // Original code class Foo { #x() { return this.#x() } #y() { return this.#y() } #z() { return this.#z() } } // Old output (--supported:class-private-method=false) var _x, x_fn, _y, y_fn, _z, z_fn; class Foo { constructor() { __privateAdd(this, _x); __privateAdd(this, _y); __privateAdd(this, _z); } } _x = new WeakSet(); x_fn = function() { return __privateMethod(this, _x, x_fn).call(this); }; _y = new WeakSet(); y_fn = function() { return __privateMethod(this, _y, y_fn).call(this); }; _z = new WeakSet(); z_fn = function() { return __privateMethod(this, _z, z_fn).call(this); }; // New output (--supported:class-private-method=false) var _Foo_instances, x_fn, y_fn, z_fn; class Foo { constructor() { __privateAdd(this, _Foo_instances); } } _Foo_instances = new WeakSet(); x_fn = function() { return __privateMethod(this, _Foo_instances, x_fn).call(this); }; y_fn = function() { return __privateMethod(this, _Foo_instances, y_fn).call(this); }; z_fn = function() { return __privateMethod(this, _Foo_instances, z_fn).call(this); };\n\n  * Fix an obscure bug with lowering class members with computed property keys\n\nWhen class members that use newer syntax features are transformed for older\ntarget environments, they sometimes need to be relocated. However, care must\nbe taken to not reorder any side effects caused by computed property keys. For\nexample, the following code must evaluate a() then b() then c():\n\n    \n        class Foo { [a()]() {} [b()]; static { c() } }\n\nPreviously esbuild did this by shifting the computed property key forward to\nthe next spot in the evaluation order. Classes evaluate all computed keys\nfirst and then all static class elements, so if the last computed key needs to\nbe shifted, esbuild previously inserted a static block at start of the class\nbody, ensuring it came before all other static class elements:\n\n    \n        var _a; class Foo { constructor() { __publicField(this, _a); } static { _a = b(); } [a()]() { } static { c(); } }\n\nHowever, this could cause esbuild to accidentally generate a syntax error if\nthe computed property key contains code that isn't allowed in a static block,\nsuch as an await expression. With this release, esbuild fixes this problem by\nshifting the computed property key backward to the previous spot in the\nevaluation order instead, which may push it into the extends clause or even\nbefore the class itself:\n\n    \n        // Original code class Foo { [a()]() {} [await b()]; static { c() } } // Old output (with --supported:class-field=false) var _a; class Foo { constructor() { __publicField(this, _a); } static { _a = await b(); } [a()]() { } static { c(); } } // New output (with --supported:class-field=false) var _a, _b; class Foo { constructor() { __publicField(this, _a); } [(_b = a(), _a = await b(), _b)]() { } static { c(); } }\n\n  * Fix some --keep-names edge cases\n\nThe NamedEvaluation syntax-directed operation in the JavaScript specification\ngives certain anonymous expressions a name property depending on where they\nare in the syntax tree. For example, the following initializers convey a name\nvalue:\n\n    \n        var foo = function() {} var bar = class {} console.log(foo.name, bar.name)\n\nWhen you enable esbuild's --keep-names setting, esbuild generates additional\ncode to represent this NamedEvaluation operation so that the value of the name\nproperty persists even when the identifiers are renamed (e.g. due to\nminification).\n\nHowever, I recently learned that esbuild's implementation of NamedEvaluation\nis missing a few cases. Specifically esbuild was missing property definitions,\nclass initializers, logical-assignment operators. These cases should now all\nbe handled:\n\n    \n        var obj = { foo: function() {} } class Foo0 { foo = function() {} } class Foo1 { static foo = function() {} } class Foo2 { accessor foo = function() {} } class Foo3 { static accessor foo = function() {} } foo ||= function() {} foo &&= function() {} foo ??= function() {}\n\n44 people reacted\n\n## Footer\n\n\u00a9 2024 GitHub, Inc.\n\nYou can\u2019t perform that action at this time.\n\n", "frontpage": false}
