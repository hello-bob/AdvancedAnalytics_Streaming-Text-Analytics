{"aid": "40211583", "title": "The $1 MICROCONTROLLER (comparison of cheap microcontrollers)", "url": "https://jaycarlson.net/microcontrollers/", "domain": "jaycarlson.net", "votes": 1, "user": "em3rgent0rdr", "posted_at": "2024-04-30 14:51:14", "comments": 0, "source_title": "The Amazing $1 Microcontroller - Jay Carlson", "source_text": "The Amazing $1 Microcontroller - Jay Carlson\n\nThe Amazing $1 Microcontroller\n\nA new series that explores 21 different microcontrollers \u2014 all less than $1 \u2014\nto help familiarize you with all the major ecosystems out there.\n\nAs an embedded design consultant, the diverse collection of projects on my\ndesk need an equally-diverse collection of microcontroller architectures that\nhave the performance, peripheral selection, and power numbers to be the\nbackbone of successful projects. At the same time, we all have our go-to chips\n\u2014 those parts that linger in our toolkit after being picked up in school,\nthrough forum posts, or from previous projects.\n\nIn 2017, we saw several new MCUs hit the market, as well as general trends\ncontinuing in the industry: the migration to open-source, cross-platform\ndevelopment environments and toolchains; new code-generator tools that\nintegrate seamlessly (or not so seamlessly...) into IDEs; and, most notably,\nthe continued invasion of ARM Cortex-M0+ parts into the 8-bit space.\n\nI wanted to take a quick pulse of the industry to see where everything is \u2014\nand what I\u2019ve been missing while backed into my corner of DigiKey\u2019s web site.\n\nIt\u2019s time for a good ol\u2019 microcontroller shoot-out.\n\n# The Rules\n\nWhile some projects that come across my desk are complex enough to require a\nhundreds-of-MHz microcontroller with all the bells and whistles, it\u2019s amazing\nhow many projects work great using nothing more than a $1 chip \u2014 so this is\nthe only rule I established for this microcontroller review. ((To get\ntechnical: I purchased several different MCUs \u2014 all less than a $1 \u2014 from a\nwide variety of brands and distributors. I\u2019m sure people will chime in and\neither claim that a part is more than a dollar, or that I should have used\nanother part which can be had for less than a dollar. I used a price-break of\n100 units when determining pricing, and I looked at typical, general suppliers\nI personally use when shopping for parts \u2014 I avoided eBay/AliExpress/Taobao\nunless they were the only source for the parts, which is common for devices\nmost popular in China and Taiwan.))\n\nI wanted to explore the $1 pricing zone specifically because it\u2019s the least\namount of money you can spend on an MCU that\u2019s still general-purpose enough to\nbe widely useful in a diverse array of projects.\n\nAny cheaper, and you end up with 6- or 8-pin parts with only a few dozen bytes\nof RAM, no ADC, nor any peripherals other than a single timer and some GPIO.\n\nAny more expensive, and the field completely opens up to an overwhelming\nnumber of parts \u2014 all with heavily-specialized peripherals and connectivity\noptions.\n\nThese MCUs were selected to represent their entire families \u2014 or sub-families,\ndepending on the architecture \u2014 and in my analysis, I\u2019ll offer some\ninformation about the family as a whole.\n\nIf you want to scroll down and find out who the winner is, don\u2019t bother \u2014\nthere\u2019s really no sense in trying to declare the \u201cking of $1 MCUs\u201d as everyone\nknows the best microcontroller is the one that best matches your application\nneeds. I mean, everyone knows the best microcontroller is the one you already\nknow how to use. No, wait \u2014 the best microcontroller is definitely the one\nthat is easiest to prototype with. Or maybe that has the lowest impact on BOM\npricing?\n\nI can\u2019t even decide on the criteria for the best microcontroller \u2014 let alone\ncrown a winner.\n\nWhat I will do, however, is offer a ton of different recommendations for\ndifferent users at the end. Read on!\n\n# The Criteria\n\nThis microcontroller selection guide will have both qualitative and\nquantitative assessments. Overall, I\u2019ll be looking at a few different\ncategories:\n\n## Parametrics, Packaging, and Peripherals\n\nWithin a particular family, what is the range of core speed? Memory?\nPeripherals? Price? Package options?\n\nSome microcontroller families are huge \u2014 with hundreds of different models\nthat you can select from to find the perfect MCU for your application. Some\nfamilies are much smaller, which means you\u2019re essentially going to pay for\nperipherals, memory, or features you don\u2019t need. But these have an economies-\nof-scale effect; if we only have to produce five different MCU models, we\u2019ll\nbe able to make a lot more of each of them, driving down the price. How do\ndifferent MCU families end up on that spectrum?\n\nPackage availability is another huge factor to consider. A professional\nelectronics engineer working on a wearable consumer product might be looking\nfor a wafer-level CSP package that\u2019s less than 2\u00d72 mm in size. A hobbyist who\nis uncomfortable with surface-mount soldering may be looking for a legacy DIP\npackage that can be used with breadboards and solder protoboards. Different\nmanufacturers choose packaging options carefully, so before you dive into an\narchitecture for a project, one of the first things to consider is making sure\nthat it\u2019s in a package you actually want to deal with.\n\nPeripherals can vary widely from architecture to architecture. Some MCUs have\nextremely powerful peripherals with multiple interrupt channels, DMA, internal\nclock generators, tons of power configuration control, and various clocking\noptions. Others are incredibly simple \u2014 almost basic. Just as before,\ndifferent people will be looking for different things (even for different\napplications). It would be a massive undertaking to go over every single\nperipheral on these MCUs, but I\u2019ll focus on the ones that all MCUs have in\ncommon, and point out fine-print \u201cgotchas\u201d that datasheets always seem to\nglance over.\n\n## Development Experience\n\nAny microcontroller review or selection guide should include a discussion of\nthe overall development environment and experience.\n\nWhile this is where things get subjective and opinion-oriented, I\u2019ll attempt\nto present \u201cjust the facts\u201d and let you decide what you care about. The main\nsource of subjectivity comes from weighing these facts appropriately, which I\nwill not attempt to do.\n\nIDEs / SDKs / Compilers: What is the manufacturer-suggested IDE for developing\ncode on the MCU? Are there other options? What compilers does the\nmicrocontroller support? Is the software cross-platform? How much does it\ncost? These are the sorts of things I\u2019ll be exploring while evaluating the\nsoftware for the MCU architecture.\n\nPlatform functionality and features will vary a lot by architecture, but I\u2019ll\nlook at basic project management, source-code editor quality, initialization\ncode-generation tools, run-time peripheral libraries, debugging experience,\nand documentation accessibility.\n\nI\u2019ll focus on manufacturer-provided or manufacturer-suggested IDEs and\ncompilers (and these will be what I use to benchmark the MCU). There are more\nthan a dozen compilers / IDEs available for many of these architectures, so I\ncan\u2019t reasonably review all of them. Feel free to express your contempt of my\nmethodology in the comments section.\n\nProgrammers / debuggers / emulators / dev boards: What dev boards and\ndebuggers are available for the ecosystem? How clunky is the debugging\nexperience? Every company has a slightly different philosophy for development\nboards and debuggers, so this will be interesting to compare.\n\n## Performance\n\nI\u2019ve established three different code samples I\u2019ll be using to benchmark the\nparts in this microcontroller review; I\u2019ll be measuring quantitative\nparameters like benchmark speed, clock-cycle efficiency, power efficiency, and\ncode-size efficiency.\n\n### While(1) Blink\n\nFor this test, I\u2019ll toggle a pin in a while() loop. I\u2019ll use the fastest C\ncode possible \u2014 while also reporting if the code generator tool or peripheral\nlibraries were able to produce efficient code. I\u2019ll use bitwise complement or\nGPIO-specific \u201ctoggle\u201d registers if the platform supports it, otherwise, I\u2019ll\nresort to a read-modify-write operation. I\u2019ll report on which instructions\nwere executed, and the number of cycles they took.\n\nWhat this tests: This gives some good intuition for how the platform works \u2014\nbecause it is so low-level, we\u2019ll be able to easily look at the assembly code\nand individual instruction timing. Since many of these parts operate above\nflash read speed, this will allow us to see what\u2019s going on with the flash\nread accelerator (if one exists), and as a general diagnostic / debugging tool\nfor getting the platform up and running at the proper speed. This routine will\nobviously also test bit manipulation performance (though this is rarely\nimportant in general-purpose projects).\n\n### 64-Sample Biquad Filter\n\nThis is an example of a real-world application where you often need good,\nreal-time performance, so I thought it would be a perfect test to evaluate the\nraw processing power of each microcontroller. For this test, I\u2019ll process\n16-bit signed integer data through a 400 Hz second-order high-pass filter\n(Transposed Direct Form II implementation, for those playing along at home),\nassuming a sample rate of 8 kHz. We won\u2019t actually sample the data from an ADC\n\u2014 instead, we\u2019ll process 64-element arrays of dummy input data, and record the\ntime it takes to complete this process (by wiggling a GPIO pin run into my 500\nMHz Saleae Logic Pro 16 logic analyzer).\n\nIn addition to the samples-per-second measure of raw processing power, I\u2019ll\nalso measure power consumption, which will give us a \u201cnanojoule-per-sample\u201d\nmeasure; this will help you figure out how efficient a processor is. While\nI\u2019ve traditionally used \u03bcCurrent units for this, I ended up using a Silicon\nLabs EFM8 Sleepy Bee STK \u2014 I ripped the target processor off the board,\nturning it into a $30 time-domain logarithmic power meter. If you\u2019re\ninterested in more information, check out my EFM8 review, which has the\ndetails of these excellent tools.\n\nWhat this tests: Memory and 16-bit math performance per microamp, essentially.\nThe 8-bit MCUs in our round up are going to struggle with this pretty hardcore\n\u2014 it\u2019ll be interesting to see just how much better the 16 and 32-bit MCUs do.\nLike it or hate it, this will also evaluate a compiler\u2019s optimization\nabilities since different compilers implement math routines quite differently.\n\n### DMX-512 RGB light\n\nDMX-512 is a commonly-used lighting protocol for stage, club, and commercial\nlighting systems. Electrically, it uses RS-485; the protocol uses a long BREAK\nmessage at the beginning, followed by a \u201c0\u201d and then 511 bytes of data,\ntransmitted at 250 kbaud. In this test, I\u2019ll implement a DMX-512 receiver that\ndirectly drives a common-anode RGB LED. I will do this with whatever\nperipheral library or code-generator tool the manufacturer provides (if any at\nall).\n\nWhile you should really look for a precisely-timed break message, since this\nis only for prototyping, I\u2019ll detect the start-of-frame by looking for an RX\nframing error (or a \u201cbreak\u201d signal, as some UARTs support LIN).\n\nI\u2019ll minimize power consumption by lowering the frequency of the CPU as much\nas possible, using interrupt-based UART receiver routines, and halting or\nsleeping the CPU. I\u2019ll report the average power consumption (with the LED\nremoved from the circuit, of course). To get a rough idea of the completeness\nand quality of the code-generator tools or peripheral libraries, I\u2019ll report\nthe total number of statements I had to write, as well as the flash usage.\n\nWhat this tests: This is a sort of holistic test that lets me get into the\necosystem and play around with the platform. This stuff is the bread and\nbutter of embedded programming: interrupt-based UART reception with a little\nbit of flair (framing error detection), multi-channel PWM configuration, and\nnearly-always-halted state-machine-style CPU programming. Once you have your\nhardware set up and you know what you\u2019re doing (say, after you\u2019ve implemented\nthis on a dozen MCUs before...), with a good code-gen tool or peripheral\nlibrary, you should be able to program this with just a few lines of code in\nan hour or less \u2014 hopefully without having to hit the datasheet much at all.\n\nTest notes: I\u2019m using FreeStyler to generate DMX messages through an FTDI USB-\nto-serial converter (the program uses the Enttec Open DMX plugin to do this).\nAs my FTDI cable is 5V, I put a 1k resistor with a 3.3V zener diode to to\nground, which clamps the signal to 3.3V. The zener clamp isn\u2019t there to\nprotect the MCU \u2014 all of these chips tested have diode catches to protect from\nover-voltage \u2014 but rather, so that the MCU doesn\u2019t inadvertently draw power\nfrom the Rx pin, which would ruin my current measurement results.\n\n# Evaluation Code\n\nAll code I used to evaluate these parts in this microcontroller selection\nguide is available on my microcontroller-test-code GitHub repo. Check it out,\nfork it, submit patches, and keep me honest \u2014 if your results differ from\nmine, let\u2019s get this post updated.\n\nThe Contenders\n\nThis page will compare the devices, development tools, and IDEs all together.\nHowever, to prevent this article from getting overwhelmingly long, I\u2019ve\ncreated review pages for each device that cover way more details about the\narchitecture \u2014 along with more complete testing notes, different benchmarking\nvariations, and in-depth assessment. If an architecture strikes your interest,\nyou should definitely check out the full review below.\n\nAtmel TinyAVR\n\nPart: ATtiny1616 The new-for-2017 tinyAVR line includes seven parts with\nXMEGA-style peripherals, a two-cycle 8\u00d78 multiplier, the new UPDI one-wire\ndebug interface, and a 20 MHz oscillator that should shoot some energy into\nthis line of entry-level AVR controllers that was looking quite long in the\ntooth next to other 8-bit parts.\n\nAtmel MegaAVR\n\nPart: ATmega168PB The AVR earned its hobbyist-friendly badge as the first MCU\nprogrammed in C with open-source tools. The \u201cB\u201d version of the classic\nATmega168 takes a price cut due to a die-shrink, but little else has changed,\nincluding the anemic 8 MHz internal oscillator \u2014 and, like the tinyAVR, must\nsip on 5V to hit its full 20 MHz speed.\n\nAtmel SAM D10\n\nPart: ATSAMD10D14A Atmel is positioning their least-expensive ARM Cortex-M0\noffering \u2014 the new SAM D10 \u2014 to kill off all but the smallest TinyAVR MCUs\nwith its performance numbers, peripherals, and price. Stand-out analog\nperipherals capstone a peripheral set and memory configuration that endows\nthis part with good value.\n\nCypress PSoC 4000S\n\nPart: CY8C4024LQI Reconfigurable digital logic \u2014 the PSoC\u2019s claim to fame \u2014 is\nabsent from this entry-level 24 MHz Arm part that also sports average analog\nfeatures, and no support for Cypress\u2019s handy \u201cit just works\u201d capacitive-touch\nhardware. Other than its unique development environment, this part treads\nwater in a sea of low-cost ARM devices.\n\nFreescale KE04\n\nPart: MKE04Z8VTG4 Freescale introduced the Arm Cortex-M0 KE04 to kill off\n8-bit MCUs \u2014 and with 2.7-5.5V support, tons of timers and analog options,\nit\u2019s a step in that direction. Processor Expert provides a unique development\nexperience for rapid-prototyping, which may be enough to lure some developers\naway from newer parts.\n\nFreescale KL03\n\nPart: MKL03Z8VFG4 While the KE series attacks the 8-bit sector with bells and\nwhistles, the KL series focuses on being some of the lowest-power Arm parts on\nthe market, with good low leakage performance in sleep mode. I\u2019m testing this\n48 MHz Arm part inside of NXP\u2019s MCUXpresso, which recently added support for\nthe newer Kinetis devices.\n\nHoltek HT-66\n\nPart: HT66F0185 A basic 8-bit microcontroller with a slow, 4-cycle PIC16-style\nsingle-accumulator core. An anemic peripheral selection and limited memory\ncapacity makes this a better one-trick pony than a main system controller.\nHoltek has a wide range of application-specific MCUs that integrate this core\nwith HV power and other goodies.\n\nInfineon XMC1100\n\nPart: XMC1100T016X0016 Infineon Arm chips are common picks for control\nprojects, and the new XMC1100 is no different. With 16K of RAM, a 1 MSPS six-\nchannel ADC, flexible communications, up to 16 timer capture channels, and the\nability to form a 64-bit timer for large-range timing gives this part a bit of\npersonality among entry-level Cortex-M0 microcontrollers.\n\nMicrochip PIC16\n\nPart: PIC16LF18325 Vying with the 8051 as the most famous microcontroller of\nall time, the latest PIC16 Five-Digit Enhanced parts feature improved\nperipheral interconnectivity, more timers, and better analog. Still driven by\na sluggish core that clambers along at one-fourth its clock speed, the PIC16\nhas always been best-suited for peripheral-heavy workloads.\n\nMicrochip PIC24\n\nPart: PIC24F04KL100 An expensive 16-bit part that\u2019s designed (and priced) to\nmirror the MSP430. While it has decent performance and power consumption, it\u2019s\nhard not to look toward other parts \u2014 especially the PIC32MM \u2014 which offer\nbetter pricing, and can beat the PIC24 at everything other than deep-sleep\ncurrent consumption.\n\nMicrochip PIC32MM\n\nPart: PIC32MM0064 The 32-bit MIPS-powered PIC32MM compares similarly with ARM\ncontrollers on a per-cycle basis, but doesn\u2019t provide the same flexibility\nwith tooling that ARM does. It\u2019s a great part for 32-bit beginners, though, as\nit brings along PIC18/PIC24-style peripherals and fuse-based configuration,\neasing development.\n\nNuvoton N76\n\nPart: N76E003AT20 The N76 is a 1T-style 8051 that brings a few twists and\nuseful additions to the basic set of \u201951 peripherals. This MCU has a slower\ninstruction timing versus the EFM8 or STC8, but it\u2019s hard to complain about a\nwell-documented, fully-featured MCU with North American support that you can\nbuy with East Asia pricing.\n\nNuvoton M051\n\nPart: M052LDN The M051 series is a high-value, 50 MHz Cortex-M0 with excellent\ntimers and comms peripherals, a coherent, easy-to-use functional-oriented\nperipheral library, a relatively high pin-count, and utilitarian dev tools.\nThe Achilles\u2019 heel is the somewhat-limited IDE options, buggy software, and\ngross power consumption figures.\n\nNXP LPC811\n\nPart: LPC811M001JDH16 The LPC81x is famous among hobbyists for the LPC810 \u2014 an\n8-pin DIP-package MCU. For everyone else, the LPC81x is an older, forgettable\n30 MHz ARM that\u2019s short on peripherals (it doesn\u2019t even have an ADC). An easy-\nto-use function-oriented peripheral library, serial loader, and plenty of code\nexamples on blog posts keep this part alive.\n\nRenesas RL-78\n\nPart: R5F102A8ASP With the RL-78, Renesas built a clever hybrid MCU with an\n8-bit-wide data path and a 16-bit-wide ALU, balancing cost and performance.\nExcellent low-power consumption, arrayed comms and timer peripherals, plus a\ngood code-gen tool built into the free Eclipse IDE makes this part a strong\ncompetitor against the PIC24 and MSP430.\n\nSanyo LC87\n\nPart: LC87F1M16 There\u2019s not much to like in the LC-87. Abysmal power\nconsumption, lackluster peripherals, unfriendly pricing, and an obnoxiously\nantiquated development ecosystem should steer away almost any rational person\nfrom this architecture that, from the copyright dates on the development\ntools, looks to be headed to the grave.\n\nSilicon Labs EFM8\n\nPart: EFM8LB11 The EFM8 Laser Bee is a snappy 72 MHz 8051 MCU that\u2019s both the\nfastest 8-bit MCU in our round-up, as well as one of the lowest-power. Low-\ncost tools, a free cross-platform Eclipse-based IDE, and a slew of easy-to-\nprogram peripherals should get both professionals and hobbyists interested in\nexploring this platform.\n\nST STM8\n\nPart: STM8S103F3P6 The STM8 feels like an ARM in disguise: a 32-bit-wide\nprogram memory bus with efficient compute performance, peripheral power\ngating, and a nested vector interrupt controller makes this thing look more\nlike its STM32 big brothers. If only its STVD development environment felt as\nmodern as its peripheral set does.\n\nST STM32F0\n\nPart: STM32F030F4P6 While the F0 has an average peripheral set and worse-than-\naverage power consumption, its low-cost ST-Link debugger, free IDE, good code-\ngen tools, and huge parametric latitude (up to the 180 MHz, 2 MB STM32F4) make\nthis a useful family to learn \u2014 plus everyone seems to have an STM32 Discovery\nboard laying around.\n\nSTCmicro STC8\n\nPart: STC8A8K64S4A12 A brand-new, single-cycle 8051 jam-packed full of flash,\nRAM, and oodles of peripherals \u2014 and a large, 64-pin package to make use of\nall these guts. Unfortunately, this part isn\u2019t quite ready for prime-time: the\ndatasheet hasn\u2019t been translated into English yet, the errata is massive, and\nthere\u2019s limited availability of the part.\n\nTI MSP430\n\nPart: MSP430FR2111 Texas Instruments dials down the power consumption in the\nlatest iteration of the MSP430. FRAM memory, flexible power states, and tons\nof internal clocking options make this part a battery\u2019s dream come true.\nYou\u2019ll pay for this power, though: the MSP430 can be twice as expensive as\nmany 8-bit parts.\n\nSpecs Comparison\n\n# Core\n\nMicrocontrollers continue to divide into two camps \u2014 those with vendor-\nspecific core architectures, and those who use a third-party core design. Out\nof the 21 microcontrollers reviewed here, eight of them use a 32-bit ARM core,\nwhich is becoming ubiquitous in the industry \u2014 even at this price point. Three\nof the microcontrollers use an 8-bit 8051-compatible ISA. The remaining ten\nuse the vendor\u2019s proprietary core design: six are 8-bit parts, three are\n16-bit parts, and the PIC32MM is the sole 32-bit part that doesn\u2019t use an ARM\ncore.\n\n## AVR\n\nThe AVR core is a famous RISC design known for its clock-cycle efficiency \u2014\nespecially at the time it was introduced in 1997. I reviewed two\nmicrocontrollers with an AVR core \u2014 the tinyAVR 1-Series and the megaAVR.\n\nThe specific AVR instruction set and timing for both parts I reviewed is known\nas \u201cAVRe\u201d \u2014 this instruction set includes a two-cycle multiply and many\nsingle-cycle operations. Note that tinyAVR parts prior to the tinyAVR 1-Series\nare essentially completely different MCUs with a less-capable AVR core that\nhas no multiplier.\n\nThe AVR core has a 16-bit instruction fetch width; most instructions are 16\nbits wide; some are 32. Still, this is a RISC architecture, so the instruction\nset is anything but orthogonal; while there are 32 registers you can operate\nwith, there are very few instructions for working directly with RAM; and of\nthose 32 registers, I\u2019d say that only 16 of them are true \u201cgeneral purpose\u201d\nregisters, as R0-R15 can\u2019t be used with all register operations (load-\nimmediate probably being the most important).\n\nAll things said, though, AVR offered a huge performance improvement over the\n12-cycle or 6-cycle 8051 processors when AVR was first introduced \u2014 and the\nAVR is always faster than even modern 8051 derivatives when it comes to\nworking with large arrays of data that must be stored in extended (16-bit) RAM\non the 8051.\n\nIt was also designed for C compilers, too \u2014 with 32 registers available at all\ntimes, compilers can efficiently juggle around many operands concurrently; the\n8051, by comparison, has four banks of eight registers that are only easily\nswitched between within interrupt contexts (which is actually quite useful).\n\nAnd interrupts are one of the weak points of the AVR core: there\u2019s only one\ninterrupt priority, and depending on the ISR, many registers will have to be\npushed to the stack and restored upon exit. In my testing, this often added 10\nPUSH instructions or more \u2014 each taking 2 cycles.\n\nAnother issue with AVR is the generally slow clock speed \u2014 even the high-end\nXMEGA AVR parts can only run at up to 32 MHz, with both the parts reviewed\nhere topping out at 20 MHz. Compare that to the EFM8, of which is many\nvarieties run at 48 MHz or higher (like the 72 MHz Laser Bee I reviewed). Even\na 50%-better clock cycle efficiency doesn\u2019t help much when the competition\nruns almost four times faster than the AVR.\n\n## Microchip PIC16\n\nThere\u2019s something fundamentally goofy about almost all aspects of the PIC16\nthat make it seem, at first glance, completely bizarre that it is as popular\nas it is.\n\nPIC16 uses an odd-ball 14-bit-wide program memory, yet it\u2019s an 8-bit machine.\nThis dramatically simplifies the core architecture: a 14-bit word can hold\njust enough data to specify every CPU instruction \u2014 with enough free space\nleft in the word to address up to 128 registers or 2K of program memory (for\nthe two jump/call routines).\n\nMicrochip calls the PIC16 a RISC machine since every PIC instruction (there\u2019s\njust 49 of them) is precisely one word long((There\u2019s considerable debate as to\nthe precise definition of a \u201cRISC architecture\u201d is, but while the PIC16 has a\nsingle-word instruction length for all instructions, the PIC16 varies greatly\nfrom most RISC parts in that it is an accumulator-based machine, and has no\nworking registers. I\u2019ll leave it up to you to decide.)). The PIC16 is often\ndescribed as a 4T architecture \u2014 taking 4 clock cycles to execute a single\nmachine instruction. This isn\u2019t entirely true, as the PIC16 takes an\nadditional 4 cycles to fetch that instruction. Consequently, it\u2019s actually an\n8T machine, though it implements a pipeline scheme that allows each\ninstruction to execute in 4 cycles \u2014 except jumps, which take 8.\n\nSince real MCUs have more than 128 bytes of registers and 2K of program\nmemory, this PIC has a bank selection register (BSR), which is written to\nwhenever you need to swap banks (which happens a lot).\n\nThe PIC16 is a single-register machine, and that register is named W.\nEverything you do will essentially be moving something into W, doing something\nwith it, and then moving it back to somewhere. Consequently, programming it in\nassembly is easy, and downright fun.\n\nBecause this part can store 8192 14-bit program words, Microchip will tell you\nthis part has 14 KB of flash (close to 16 KB, right?), but users will tell you\nthat it has 8K of program memory \u2014 8192 words of memory \u2014 since storing an\n8192-element byte array will occupy all 14 KB of its flash memory. Keep this\nin mind when comparing memory.\n\nI have a longer write-up of PIC16 in the main PIC16 article.\n\n## Microchip PIC24\n\nWhile the PIC10, 12, 16, and 18 are all 8-bit cores with 12-16 bit program\nmemory, the PIC24 moves up to 16-bit data operated through 24-bit instructions\n(are you starting to catch onto the numbering system?)\n\nWhile all the PICs before it were 4T machines, the PIC24 is 2T \u2014 that is, two\nclock cycles per instruction cycle.\n\nThe PIC24 has new indirect addressing modes that allow\nincrementing/decrementing and register-offset addressing, has a few more other\ninstructions, and has three \u2014 instead of two \u2014 hardware breakpoints; but\notherwise, the core is very much in the spirit of the PIC16.\n\nThe PIC24 carries the excellent power consumption figures that the PIC16 has,\nbut many of the parts lack the clocking and oscillator options the MSP430 has\n(and apples-to-apples, the MSP430 is lower-power).\n\nThe dsPIC versions of these parts \u2014 which add DSP-friendly instructions \u2014 are\npopular for motor drivers, but it\u2019s not clear that the PIC24 has more widely\nbeen the runaway success Microchip had hoped.\n\n## Microchip PIC32\n\nWhile everyone was migrating their 8-bit proprietary cores to Arm, Microchip\nwas gleefully popping out PIC parts. But in 2007, they finally decided to add\na new microcontroller \u2014 the PIC32 \u2014 which uses a third-party, industry-\nstandard 32-bit core. Instead of following everyone to the Arm ecosystem, they\ntook a different turn: PIC32 parts use the MIPS architecture \u2014 specifically\nthe M4K core.\n\nMIPS built this core for single-chip MCU applications. M4K has 32 registers, a\n5-stage pipeline, vectored interrupts and exceptions, bit-manipulation, and\n16-bit instruction encoding support.\n\nIt is not the same as an Arm processor, but at the C application level, they\nare similar enough that any Arm developer should have no problems (other than\nthe usual manufacturer-to-manufacturer peripheral differences).\n\nYou can program and debug the PIC32 using the same PGC/PGD/MCLR set-up you use\non all other PIC parts \u2014 but there\u2019s also support for JTAG, though the most\npopular JTAG debugger \u2014 the Segger J-Link \u2014 has limited support for the\nPIC32MX parts, and no support for the PIC32MM.\n\n## Arm Cortex-M0\n\nThe Arm Cortex-M0 ((Formerly ARM, but as of August 1, 2017, \u201cArm\u201d is the\ncapitalization style they now use.)) is a 32-bit RISC architecture that serves\nas the entry-level Arm architecture available to silicon vendors for\nmicrocontroller applications. Arm cores are designed by Arm Holdings and\nlicensed to semiconductor manufacturers for integration into their products.\n\nArm started out as a personal computer microprocessor when Advanced RISC\nMachines formed a joint venture between Acorn, Apple, and VLSI Technology to\nmanufacture 32-bit processors for the Acorn computer. While Arm cores have\ngrown in popularity as microprocessors for battery-powered systems (they are\nalmost certainly powering your smartphone), Arm moved into the microcontroller\nsphere as well \u2014 the ARM7TDMI-S was probably the first Arm core that was used\nin microcontrollers \u2014 i.e., processors with completely self-contained RAM,\nflash, and peripherals. The Atmel AT91 and ST STR7 were probably the first\nmicrocontroller parts designed with an Arm core.\n\nIt\u2019s important to understand the history of Arm because it explains a serious\nfeature of Arm microcontrollers that differs substantially from the 8051 (the\nother multi-vendor architecture that dominates the field): Unlike the 8051,\nArm is just a core, not a complete microcontroller.\n\nThe ARM7TDMI-S didn\u2019t come with any GPIO designs, or provisions for UARTs or\nADCs or timers \u2014 it was designed as a microprocessor. Thus, as vendors started\nstuffing this core into their extremely high-end MCUs, they had to add in\ntheir vendor-specific peripherals to the AHB (AMBA((Advanced Microcontroller\nBus Architecture \u2014 these multi-level acronyms are getting tedious)) High-\nperformance Bus).\n\nConsequently, Freescale used a lot of HC08 and ColdFire peripherals; while\nAtmel designed new peripherals from scratch. ST borrowed a bit from the ST7\n(the precursor to the STM8) but used new designs for timers and communications\nperipherals.\n\nSince many microcontroller projects spend 90% or more of the code base\nmanipulating peripherals, this is a serious consideration when switching from\none Arm MCU vendor to another: there\u2019s absolutely zero peripheral\ncompatibility between vendors, and even within a single vendor, their Arm\nparts can have wildly different peripherals.\n\nUnlike other Arm parts, the M0 series only supports a subset of the 16-bit\nThumb instruction set, which allows it to be about 1/3 the size of a Cortex-M3\ncore. Still, there\u2019s a full 32-bit ALU, with a 32-bit hardware multiplier\nsupporting a 32-bit result. Arm provides the option of either a single-cycle\nmultiply, or a 32-cycle multiply instruction, but in my browsing, it seems as\nthough most vendors use the single-cycle multiply option.\n\nIn addition to the normal CPU registers, Arm cores have 13 general-purpose\nworking registers, which is roughly the sweet spot. The core has a nested\nvector interrupt controller, with up to 32 interrupt vectors and 4 interrupt\npriorities \u2014 plenty when compared to the 8-bit competition, but a far cry from\nthe 240 interrupts at 256 interrupt priorities that the larger Arm parts\nsupport. The core also has full support for runtime exceptions, which isn\u2019t a\nfeature found on 8-bit architectures.\n\nThe M0+ is an improved version of the M0 that supports faster two-cycle\nbranches (due to the pipeline going from three-stage to two-stage), and lower\npower consumption. There are a slew of silicon options that vendors can choose\nfrom: single-cycle GPIO, support for a simple instruction trace buffer called\nMicro Trace Buffer (MTB), vector table relocation, and a rudimentary memory\nprotection unit (MPU).\n\nOne of the biggest problems with ARM microcontrollers is their low code\ndensity for anything other than 16- and 32-bit math \u2014 even those that use the\n16-bit Thumb instruction set. This means normal microcontroller type routines\n\u2014 shoving bytes out a communication port, wiggling bits around, performing\nsoftware ADC conversions, and updating timers \u2014 can take a lot of code space\non these parts. Exacerbating this problem is the peripherals, which tend to be\nmore complex \u2014 I mean \u201cflexible\u201d \u2014 than 8-bit parts, often necessitating run-\ntime peripheral libraries and tons of register manipulation.\n\nAnother problem with ARM processors is the severe 12-cycle interrupt latency.\nWhen coupled with the large number of registers that are saved and restored in\nthe prologue and epilogue of the ISR handlers, these cycles start to add up.\nISR latency is one area where a 16 MHz 8-bit part can easily beat a 72 MHz\n32-bit Arm microcontroller.\n\n## 8051\n\nThe 8051 was originally an Intel microcontroller introduced in 1980 as one of\nthe first widely-deployed 8-bit parts. The 8-bit modified Harvard core has a\nfully-orthogonal variable-length CISC instruction set, hardware multiplier and\nhardware divider, bit-addressable RAM and specific bit-manipulation\ninstructions, four switchable banks of eight registers each, two-priority\ninterrupt controller with automatic register bank-switching, 64 KB of both\nprogram and extended RAM addressability, with 128 bytes of \u201cscratch pad\u201d RAM\naccessible with fast instructions.\n\nThe 8051 was actually a specific part \u2014 not a family \u2014 but its name is now\nsynonymous with the core architecture, peripherals, and even package pin-out\n((the 8051 is a member of a family officially called the \u201cMCS-51\u201d \u2014 along with\nthe 8031, 8032, 8051, and 8052 \u2014 plus all the subsequent versions that were\nintroduced later)).\n\nThe original had 4K of ROM ((Expensive windows ceramic packages allowed EPROM\nprogramming for developers, but production units were mask-ROM or OTP \u2014 or, in\nthe case of the 8031, only external ROM was supported.)), 128 bytes of RAM,\nfour full 8-bit GPIO ports (32 I/O total), a UART, two or three timers, and a\ntwo-priority interrupt system.\n\nThe 8051 has a fully orthogonal CISC instruction set, which means you can do\nnearly any operation with immediate, direct, or indirect operands, and you can\ndo these operations in RAM, registers, or the A accumulator.\n\nMany vendors built direct, drop-in compatible clones of the 8051, and by the\ntime Intel discontinued its MCS-51 products in 2007, barely anyone noticed \u2014\nthese third-party parts evolved from mimicking Intel functionality to outright\nbeating them with tons of additional timers, peripherals, and special-purpose\nfunctionality.\n\nBecause of its small core and fast interrupt architecture, the 8051\narchitecture is extremely popular for managing peripherals used in real-time\nhigh-bandwidth systems, such as USB web cameras and audio DSPs, and is\ncommonly deployed as a house-keeping processor in FPGAs used in audio/video\nprocessing and DSP work.\n\nOld-timers associate the 8051 with \u201cold and slow\u201d because the original was a\n12T microcontroller \u2014 each machine cycle took 12 clock cycles to complete.\nSince there was no pipelining, every instruction byte took a machine cycle to\nfetch, plus one or more additional machine cycles to execute \u2014 altogether, it\ncould take more than 50 clock cycles to execute a given instruction. Ouch.\n\nNo need to worry about that anymore, though: all the modern 8051-style MCUs\navailable are 1T processors, and many of them have a pipelined core, meaning\nmany instructions take the same number of clock cycles to execute as the\ninstruction\u2019s length. Consequently, in many 8051 implementations, operations\nin A (the accumulator) are the fastest, followed by the register bank, and\nthen RAM.\n\nI ended up with three different 8051-compatible microcontrollers end the\nlineup: the Nuvoton N76, the Silicon Labs EFM8 Laser Bee, and the STCmicro\nSTC8.\n\nFrom a pure core design standpoint, the STC8 is probably the most interesting\n\u2014 while I can\u2019t find documentation to confirm this, it appears that STCmicro\nuses a 24-bit (or more) parallel instruction-fetch size. This means that a\nhuge number \u2014 more than 80% \u2014 of instructions can be executed in a single\ncycle, which is a substantial step up from all other 8051s on the market these\ndays.\n\nHowever, the EFM8, from Silicon Labs\u2019 C8051 lineage, can hit much higher clock\nspeeds \u2014 topping out at 72 MHz \u2014 making it the fastest part I reviewed, by\ncore speed.\n\nI\u2019ll be looking more at this in the performance section of the review.\n\n## STM8\n\nThe STM8 core has six CPU registers: a single accumulator, two index\nregisters, a 24-bit program counter, a 16-bit stack pointer, and a condition\nregister. The STM8 has a Harvard architecture, but uses a unified address\nspace. There\u2019s a 32-bit-wide program memory bus which can fetch most\ninstructions in a single cycle \u2014 and pipelined fetch/decode/execute operations\npermit many instructions to execute in a single cycle.\n\nThe claim to fame of the core is its comprehensive list of 20 addressing\nmodes, including indexed indirect addressing and stack-pointer-relative modes.\nThere\u2019s three \u201creaches\u201d for addressing \u2014 short (one-byte), long (two-byte),\nand extended (three-byte) \u2014 trading off memory area with performance.\n\nThis is the only architecture in this round-up that has this level of\ngranularity \u2014 all the other chips are either RISC-style processors that have\nlots of general-purpose registers they do their work in, or 8051-style CISC\nparts that manipulate RAM directly \u2014 but pay a severe penalty when hitting\n16-bit address space. The STM8 manages these trade-offs in an efficient\nmanner.\n\n# Peripherals\n\nUse the tabs below to compare precise specs across families.\n\n  * Speed\n  * Flash\n  * RAM\n  * Timers\n  * PWM\n  * Comms\n  * ADC\n\n#### Speed\n\nAtmel tinyAVR 20 MHz\n\nAtmel megaAVR 20 MHz\n\nAtmel SAM D10 48 MHz\n\nCypress PSoC 4000S 24 MHz\n\nFreescale KE04 48 MHz\n\nFreescale KL03 48 MHz\n\nHoltek HT66 20 MHz\n\nInfineon XMC1100 32 MHz\n\nMicrochip PIC16 32 MHz\n\nMicrochip PIC24 32 MHz\n\nMicrochip PIC32MM 25 MHz\n\nNuvoton N76 16 MHz\n\nNuvoton M051 50 MHz\n\nNXP LPC811 30 MHz\n\nRenesas RL78 24 MHz\n\nSanyo LC87 12 MHz\n\nSilicon Labs EFM8 72 MHz\n\nST STM8 16 MHz\n\nST STM32F0 48 MHz\n\nSTC STC8 30 MHz\n\nTI MSP430FR 16 MHz\n\nThe chart above illustrates the differences in core clock speed among each\nMCU. As will be seen in the evaluation section, core clock speed is not a good\npredictor of performance when comparing between different MCU families\n(especially between 8-, 16-, and 32-bit parts). However, most MCUs limit the\nmaximum peripheral clock rate to that of the CPU, which may be a driving\nfactor if your application requires fast peripheral clocks (say, for fast GPIO\nbit-banging or for high-speed capture/compare timer operations). The Infineon\nXMC1100 is a neat exception to this rule \u2014 its peripheral clock can run at up\nto 64 MHz.\n\nThere are other important asterisks to this data: the Atmel tinyAVR and\nmegaAVR parts have severely limited operating ranges when running below 5V,\nwhich will affect most modern designs. The tinyAVR can only run at 10 MHz\nbelow 3.6V, and at 5 MHz below 2.2V. The megaAVR has the same speed grades,\nbut even worse, has nothing faster than an 8 MHz internal oscillator. When\ntalking about sub-$1 MCUs, adding a crystal or even low-cost ceramic resonator\nadds a sizable portion of the cost of the MCU to the BOM.\n\nThe Silicon Labs EFM8 Laser Bee, with its 72 MHz core clock speed, beats out\neven the ARM microcontrollers in this round-up. The Sanyo LC87 brings in a 12\nMHz reading \u2014 but bear in mind this is a 3T architecture, which limits the\nactual instruction clock speed to 4 MHz. The Holtek HT66 and Microchip PIC16\nare both 4T architectures, but the PIC16 has a relatively snappy 32 MHz core\nspeed (thanks to its on-board PLL), which allows it to compete better with 8\nMHz parts.\n\n#### Flash\n\nAtmel tinyAVR 16 KB\n\nAtmel megaAVR 16 KB\n\nAtmel SAM D10 16 KB\n\nCypress PSoC 4000S 16 KB\n\nFreescale KE04 8 KB\n\nFreescale KL03 8 KB\n\nHoltek HT66 8 KB\n\nInfineon XMC1100 14 KB\n\nMicrochip PIC16 14 KB\n\nMicrochip PIC24 4 KB\n\nMicrochip PIC32MM 32 KB\n\nNuvoton N76 18 KB\n\nNuvoton M051 12 KB\n\nNXP LPC811 8 KB\n\nRenesas RL78 10 KB\n\nSanyo LC87 16 KB\n\nSilicon Labs EFM8 16 KB\n\nST STM8 32 KB\n\nST STM32F0 16 KB\n\nSTC STC8 64 KB\n\nTI MSP430FR 16 KB\n\nHere, we consider flash capacity in terms of bytes \u2014 but be aware that flash\nusage varies considerably by core. The PIC16 may have 14 KB of flash, but\nbeing a 14-bit-wide core, it will feel more like it has 8 KB of flash when it\ncomes time to actually storing and manipulating data, and counting\ninstructions. The Holtek HT66 is similar to the PIC16, but with a 16-bit-wide\nfetch. The same goes for the PIC24, which has a 24-bit-wide flash data path.\nWhile other cores may have a wider-than-a-byte fetch size, they still allow\ninstructions and data to be packed into flash efficiently.\n\nThe STC8\u2019s insane equipment list starts to shine \u2014 with 64 KB of flash, this\npart should be able to do essentially anything you throw at its space-\nefficient 8051 core. On the other side of the spectrum, the ARM processors\nwere especially stingy with flash capacity, which is important to consider for\napplications that rely on a lot of peripheral runtime libraries: as we\u2019ll see\nin the performance evaluation, many of these parts had little room left over\nafter the test code was programmed onto them. The Microchip PIC24\u2019s 4 KB flash\ncapacity makes the part essentially unusable for general-purpose applications\nthat would usually target a 16-bit controller, as it can only hold 1408\ninstructions in flash (due to its 24-bit-wide word fetches).\n\n#### RAM\n\nAtmel tinyAVR 2 KB\n\nAtmel megaAVR 1 KB\n\nAtmel SAM D10 4 KB\n\nCypress PSoC 4000S 2 KB\n\nFreescale KE04 1 KB\n\nFreescale KL03 2 KB\n\nHoltek HT66 0.25 KB\n\nInfineon XMC1100 16 KB\n\nMicrochip PIC16 1 KB\n\nMicrochip PIC24 0.5 KB\n\nMicrochip PIC32MM 8 KB\n\nNuvoton N76 1 KB\n\nNuvoton M051 4 KB\n\nNXP LPC811 2 KB\n\nRenesas RL78 0.768 KB\n\nSanyo LC87 1 KB\n\nSilicon Labs EFM8 1.28 KB\n\nST STM8 2 KB\n\nST STM32F0 4 KB\n\nSTC STC8 4 KB\n\nTI MSP430FR 1 KB\n\nInfineon\u2019s memory configuration is actually \u201cbackwards\u201d \u2014 it has 8 KB of\nflash, and 16 KB of RAM. It doesn\u2019t have a good flash pre-fetch engine, so\nperformance-critical code should be moved to RAM for fast execution. While\nyou\u2019re at it, unless you\u2019ve got some large data capturing/analyzing\nprocedures, you could just move your entire program into RAM, too.\n\nThe KE04 (and probably the PIC24) both have too little RAM for most projects\nthat would target these architectures. I\u2019m actually less worried about the\nHoltek HT66; it\u2019s efficient peripheral library essentially uses no RAM, and\n256 bytes of user data is plenty of space for an ultra-low-power MCU that\u2019s\ndesigned for only the most basic duties.\n\n#### Timers\n\nAtmel tinyAVR 28 Points\n\nAtmel megaAVR 17 Points\n\nAtmel SAM D10 51 Points\n\nCypress PSoC 4000S 37 Points\n\nFreescale KE04 50 Points\n\nFreescale KL03 26 Points\n\nHoltek HT66 12 Points\n\nInfineon XMC1100 48 Points\n\nMicrochip PIC16 47 Points\n\nMicrochip PIC24 17 Points\n\nMicrochip PIC32MM 44 Points\n\nNuvoton N76 31 Points\n\nNuvoton M051 62 Points\n\nNXP LPC811 45 Points\n\nRenesas RL78 54 Points\n\nSanyo LC87 22 Points\n\nSilicon Labs EFM8 42 Points\n\nST STM8 43 Points\n\nST STM32F0 40 Points\n\nSTC STC8 51 Points\n\nTI MSP430FR 13 Points\n\nEach MCU\u2019s review page discusses its complement of timers, but I wanted to\ncome up with a score to help quickly compare timer peripherals across MCUs \u2014 I\ncall it TimerMark.\n\nHere\u2019s how it works:\n\n### Basic Timer Blocks\n\n  * 1 point for 8-bit counters\n  * 2 points for 8-bit auto-reload (period) timers\n  * 2 points for 16-bit counters\n  * 4 points for 16-bit auto-reload timers\n  * 6 points for 24-bit auto-reload timers\n  * 8 points for 32-bit auto-reload timers\n  * 2 points for RTC\n  * 2 points for each 16-bit timer set that can be extended to 32-bit\n\n### Capture Channels & PWM\n\n  * 1 point for each capture channel (regardless of depth)\n  * 1 point for each 8-bit PWM channel\n  * 2 points for each 16-bit PWM channel\n  * 3 points for each 24-bit PWM channel\n  * 3 points for each arbitrary-phase PWM channel (i.e., if the channel has separate ON and OFF comparator registers\n  * 2 points if the PWM module is \u201cpower friendly\u201d (multi-channel outputs with programmable dead-time, blanking, etc)\n\n#### PWM\n\nAtmel tinyAVR 9 Channels\n\nAtmel megaAVR 6 Channels\n\nAtmel SAM D10 8 Channels\n\nCypress PSoC 4000S 5 Channels\n\nFreescale KE04 8 Channels\n\nFreescale KL03 4 Channels\n\nHoltek HT66 3 Channels\n\nInfineon XMC1100 4 Channels\n\nMicrochip PIC16 7 Channels\n\nMicrochip PIC24 2 Channels\n\nMicrochip PIC32MM 3 Channels\n\nNuvoton N76 6 Channels\n\nNuvoton M051 8 Channels\n\nNXP LPC811 4 Channels\n\nRenesas RL78 7 Channels\n\nSanyo LC87 4 Channels\n\nSilicon Labs EFM8 6 Channels\n\nST STM8 9 Channels\n\nST STM32F0 6 Channels\n\nSTC STC8 12 Channels\n\nTI MSP430FR 2 Channels\n\n#### Comms\n\nAtmel tinyAVR 3 Resources\n\nAtmel megaAVR 4 Resources\n\nAtmel SAM D10 3 Resources\n\nCypress PSoC 4000S 2 Resources\n\nFreescale KE04 3 Resources\n\nFreescale KL03 3 Resources\n\nHoltek HT66 2 Resources\n\nInfineon XMC1100 2 Resources\n\nMicrochip PIC16 3 Resources\n\nMicrochip PIC24 2 Resources\n\nMicrochip PIC32MM 4 Resources\n\nNuvoton N76 4 Resources\n\nNuvoton M051 6 Resources\n\nNXP LPC811 4 Resources\n\nRenesas RL78 4 Resources\n\nSanyo LC87 3 Resources\n\nSilicon Labs EFM8 4 Resources\n\nST STM8 3 Resources\n\nST STM32F0 3 Resources\n\nSTC STC8 6 Resources\n\nTI MSP430FR 1 Resources\n\nThe chart above illustrates the total number of communications resources each\nmicrocontroller has.\n\nMost vendors use a separate, dedicated module for UART, SPI, and I^2C\ncommunication. Nuvoton\u2019s M0 went a step further and doubled up everything \u2014\ntwo UARTs, two SPI, and two I^2C. Except under heavily-loaded buses, or under\nextremely strange designs, there\u2019s rarely a need for multiple SPI or I^2C\nbuses, so this decision struck me as a bit odd.\n\nSTC\u2018s decision to incorporate four separate UARTs in addition to an SPI and an\nI^2C module seems to be more useful, since UARTs are almost always dedicated\nto a particular peripheral. Doubling-up on UARTs was a popular decision\noverall: the other 8051s \u2014 the EFM8 and the N76 \u2014 bring a second UART, as do\nthe PIC16 and PIC32MM, along with the LPC811.\n\nI also like the flexibility that Atmel, Cypress, Infineon, and Renesas have \u2014\nthey use arrayed \u201cserial units,\u201d each can morph into a UART, SPI, or I^2C\nperipheral. Cypress and Infineon have two; Atmel and Renesas have three (plus\na fourth I^2C-slave-only interface for Renesas).\n\nThe odd ones out were the PIC32MM, the LC87, and the MSP430: none of these\nMCUs have an I^2C peripheral \u2014 a curious omission in an era of SMBus-complaint\ndigital sensors everywhere. And unlike the 8051\u2019s quasi-bidirectional GPIO\nconfiguration, none of these MCUs are well-suited to bit-banging I^2C (though\nit\u2019s obviously possible by switching data-direction).\n\n#### ADC\n\nAtmel tinyAVR 20 Channels\n\nAtmel megaAVR 8 Channels\n\nAtmel SAM D10 8 Channels\n\nCypress PSoC 4000S 0 Channels\n\nFreescale KE04 12 Channels\n\nFreescale KL03 4 Channels\n\nHoltek HT66 8 Channels\n\nInfineon XMC1100 6 Channels\n\nMicrochip PIC16 24 Channels\n\nMicrochip PIC24 0 Channels\n\nMicrochip PIC32MM 11 Channels\n\nNuvoton N76 8 Channels\n\nNuvoton M051 8 Channels\n\nNXP LPC811 0 Channels\n\nRenesas RL78 6 Channels\n\nSanyo LC87 20 Channels\n\nSilicon Labs EFM8 20 Channels\n\nST STM8 7 Channels\n\nST STM32F0 16 Channels\n\nSTC STC8 15 Channels\n\nTI MSP430FR 8 Channels\n\nAll the reviewed parts had an ADC except the PSoC 4000S, LPC811, and the\nMicrochip PIC24 (though these peripherals are available on more expensive\nmembers of this family).\n\nMost of the 8 and 16-bit parts had 10-bit ADCs, while the 32-bit parts had\n12-bit resolution. Some 8-bit vendors offered 12-bit (Holtek HT66, STCmicro\nSTC8), but the stand-out is the Silicon Labs EFM8, which has a 14-bit ADC \u2014\nthe highest resolution in our round up \u2014 and also has 20 channels, tying the\ntinyAVR and Sanyo LC87.\n\nThe PIC16 brought in the highest channel count \u2014 it has 24 total inputs and\ncan sample at 470 ksps.\n\nFor speed, the EFM8 brings 900 ksps to the table \u2014 beat out only by ST and\nInfineon whose ADCs can clock at up to 1 Msps.\n\nOther vendors turned in results hovering in the 500-800 ksps range.\n\nThe Atmel ADCs were the slowest, with the megaAVR\u2019s sluggish 15 ksps (no \u201c0\u201d\nmissing) far below everyone else. Even their 32-bit ARM only turned in a 350\nksps reading \u2014 the slowest ARM part tested.\n\n## DAC\n\nIn this price range, it is unusual to find parts with DACs, but in this\nmicrocontroller review, five parts had this functionality. The EFM8 has a two-\nchannel 12-bit DAC \u2014 the highest resolution in my round-up. The SAM D10 has a\nsingle-channel 10-bit DAC, while the tinyAVR 1-Series part has three channels\nwith 8-bit resolution. The PIC16 has a basic, 5-bit DAC (oddly, with two\nseparate outputs \u2014 even though they\u2019re generated from the same DAC). The\nFreescale KE04 also had a basic 6-bit DAC that is pumped directly into a\ncomparator (where these low-speed, low-resolution DACs are usually used).\n\nAtmel tinyAVR 1.0 x\n\nAtmel megaAVR 2.1 x\n\nAtmel SAM D10 4.5 x\n\nCypress PSoC 4000S 9.2 x\n\nFreescale KE04 16.4 x\n\nFreescale KL03 14.7 x\n\nHoltek HT66 1.0 x\n\nInfineon XMC1100 23.6 x\n\nMicrochip PIC16 8.0 x\n\nMicrochip PIC24 19.4 x\n\nMicrochip PIC32MM 66.0 x\n\nNuvoton N76 3.2 x\n\nNuvoton M051 10.2 x\n\nNXP LPC811 27.0 x\n\nRenesas RL78 10.5 x\n\nSanyo LC87 4.2 x\n\nSilicon Labs EFM8 3.9 x\n\nST STM8 2.6 x\n\nST STM32F0 27.0 x\n\nSTC STC8 1.0 x\n\nTI MSP430FR 15.3 x\n\n## Parametric Reach\n\nOne of the major themes of this microcontroller selection guide is to show how\neasy it can be to get going with different parts, and comfortably jump around\namong ecosystems \u2014 picking the best part for the job.\n\nBut for casual hobbyists who may live far away from major distributors, and\nprofessionals who have to meet tight timelines, sometimes there\u2019s no time to\nplay around with new architectures.\n\nIf you want to commit to a single architecture, it\u2019s important to know which\none gives you the most headroom to move up. I created a fictious \u201ctimes\nbetter\u201d score by comparing the the part tested with the best part available in\nthe same ecosystem \u2014 this usually means fairly comparable peripheral\nprogramming, along with identical development tools. I multiplied the core\nspeed, package size, flash, and RAM capacities together, ratioed the two\nparts, and then took the quartic root. Essentially, if every parameter is\ndouble, it is considered \u201c2.0 x\u201d as powerful.\n\nSurprisingly, the PIC32 came out on top: there are four PIC32 families \u2014 the\nPIC32MX was the first; it\u2019s the mainstream core that runs up to 120 MHz, with\nup to 512 KB of flash and 128 KB of RAM.\n\nBut it\u2019s the newer PIC32MZ that reaches even higher: up to 252 MHz, with 2 MB\nof flash, and \u2014 with the DA version of the part \u2014 includes 32 MB of onboard\nDDR2 memory. With the MZ-DA, you can build complex graphical apps without\nneeding an application processor running Linux (and the PCB / BSP complexity\nthat arrives with that). It\u2019s essentially the PIC32 version of the Arm\nCortex-M7.\n\nNext up, the STM32 line. The STM32F0 has a famous big brother \u2014 the STM32F4 \u2014\nthat\u2019s one of the most capable Arm Cortex parts ever built. Several versions\nrun up to 180 MHz, with 2 MB of flash and up to 364 KB of RAM (in the case of\nthe STM32F469).\n\nBut the brand-new STM32F7 \u2014 part of the new Cortex-M7 line of parts \u2014 goes\neven further, with 216 MHz maximum operating frequency, 2 MB of flash, and 512\nKB of RAM.\n\nThe LPC811 \u2014 one of the lower-performing parts in my round-up \u2014 has several\nbig sisters, including the LPC546xx series, a giant Cortex-M4 with 220 MHz max\nfrequency, 512 KB of flash, 200 KB of RAM, in up to 208-pin packages.\n\nThe tinyAVR in this review has very little headroom \u2014 these devices top out at\n16 KB of flash, 2 KB of RAM, 20 MHz, and 24-pin QFN packages; however, 32 KB\ntinyAVR parts are soon to be released.\n\nThe megaAVR has a bit of reach in pinning and memory. The ATmega3290 keeps the\n20 MHz clock speed but bumps up the pin-count to 100 pins. There are many\nmegaAVR parts with 64 KB of flash and 4 K of RAM, as this part has. Some\nmegaAVR parts have as much as 16 KB of RAM or 256 KB of flash. Oddly, Atmel\ncan\u2019t seem to combine these specs \u2014 there is no 100-pin, 256 KB flash, 16 KB\nRAM megaAVR that is in current production.\n\nThe SAM D10 extends up to the SAM D21, which maintains its 48 MHz clock speed,\nbut increases flash up to 256 KB, with up to 32 K of RAM, and sizable 64-pin\npackage options.\n\nThere\u2019s a lot of headroom left in the SAM Arm microcontroller ecosystem, but\nif you leave the D1x/D2x line of parts, you\u2019ll lose familiarity with some of\nthe peripherals (especially the communications interfaces). Having said that,\nthe Arm Cortex-M7-based ATSAMS70 will get you up to 300 MHz of performance, 2\nMB of flash, and 384 KB of RAM, in up to 144-pin packages. The older A\nrevision parts are deeply discounted, including this 64-pin 1 MB flash part\nfor $5.14 on DigiKey.\n\nWith the PSoC 4000S, you\u2019re at rock-bottom in the PSoC ecosystem, so the only\ndirection is up \u2014 the PSoC 5 devices run at 80 MHz, with up to 256 KB of flash\nand 64 KB of RAM in 100-pin packages. These parts come with all the PSOC\ngoodness that Cypress users love \u2014 reconfigurable digital logic, lots of\nanalog features, and excellent capacitive-touch sensing.\n\nThe just-around-the-corner PSoC 6 promises to bring even more performance to\nthe ecosystem, with the PSoC 63 running a 150 MHz Arm Cortex-M4F, 1 MB of\nflash, 288 KB of RAM, integrated BTLE connectivity, and 100+ pin packages.\n\nThe Freescale KE04 and KL03 are both entry-level devices in the E and L\nfamilies within the Kinetis system. The E family has good reach up to the 168\nMHz KE1x, with up to 512 KB of flash, 64 KB of RAM, and up to 100-pin\npackaging. Unfortunately, this is a fairly different process than the KE04\nreviewed here \u2014 there\u2019s no Processor Expert support, and the communications\nperipherals are quite different than those in the lower-end part. It retains\nits 5V operating range, which segments it into the E family.\n\nThe KL03 extends up to the KL28 \u2014 a 72 MHz Cortex-M0+ with 512 KB of flash,\n128 KB of RAM, and up to 121-pin BGA packages available. Unlike the E series,\nthe KL series has much more uniform peripherals across its range of devices.\n\nThe Holtek HT-66 has no real latitude above the HT66F0185 \u2014 but as mentioned\non the review page, there are tons of application-specific products Holtek\nmakes that use this core.\n\nThe Infineon XMC1000 family extends up to the XMC1400, with 200 KB of flash,\n16 K of RAM, a slightly-faster 48 MHz core clock, and a 64-pin package. Moving\nout of the XMC1000 ecosystem, the XMC4000 keeps the XMC1000 peripherals and\nswaps out the core for a Cortex-M4F, running up to 144 MHz, with 2 MB of\nflash, 352 KB of RAM, and up to 196-pin packaging options.\n\nThe PIC16 tops out in the 64-pin PIC16F19197 device, with 56 KB of flash\n(well, 32 K words, because PIC), 4 K of RAM. I\u2019ll include PIC18 devices,\nthough, as they\u2019re targetted with the same compiler, programmed with the same\ndebugger, and share peripherals and architectural decisions.\n\nPIC18 devices can reach up to the PIC18F97J60 \u2014 a 100-pin beast with 128 KB of\nflash (64 K words), and almost 4K of RAM. While most of these 8-bit parts have\nsimilar peripherals across the board, I must note the Ethernet MAC and PHY\npresent in the PIC18F97J60. While many higher-end microcontrollers have an\nEthernet MAC, this low-end PIC18 part is one of the only microcontrollers \u2014 at\nany price \u2014 to also integrate a PHY ((The only other mainstream MCU that has\nan integrated Ethernet PHY is the $14 Tiva-C TM4C129x, a giant 128-pin 120 MHz\nArm Cortex-M4 from Texas Instruments. There are a few other (albeit odd)\nchoices out there: Freescale\u2019s legacy ColdFire microcontrollers include the\nMCF5223X, which has an integrated Ethernet PHY. Fabless designer ASIX\nmanufacturers the AX11015, a 100 MHz 8051 with an integrated Ethernet PHY)).\n\nThe PIC24FJ1024GA610 supports up to a 1024 KB of flash, 32 KB of RAM, and a 32\nMHz run speed \u2014 though there are dsPIC devices, like the dsPIC33EP512GM604,\nwith up to 140 MHz operating frequency, 512 KB of flash, and 48 KB of RAM.\n\nThe Nuvoton N76 can look up to the 40 MHz W79E658A, with 128 KB of flash,\n100-pin packaging, and 1.25K of RAM.\n\nThe Nuvoton M051 has a few Cortex-M4 big sisters: the M505 has 2 MB of\nembedded SPI flash (sounds slow to me), and 128 KB of RAM, runs at 100 MHz,\nand comes in a 48-pin package. Nuvoton hasn\u2019t released the M487 yet, but it\npromises a 192 MHz CPU with 512 KB of flash, 160 KB of RAM, and at least\n80-pin package options (though Nuvoton hasn\u2019t unveiled all details yet).\n\nRenesas RL-78 extends up to the R5F101SLAFB, with 128-pin package, 512 KB of\nflash, 32 KB of RAM, and a slightly-faster 32 MHz clock speed.\n\nSanyo\u2019s LC87 extend up to 100-pin 256 KB parts with 12 KB of RAM, and an 18\nMHz clock with the LC87F7NP6AUE.\n\nThe Silicon Labs EFM8LB1 is the top-of-the-line part in the EFM8 family \u2014\nthese top out at 64 KB of flash, 4.25 KB of RAM, and a relatively-small 32-pin\npackage.\n\nHaving said that, you can stay in the Silicon Labs 8051 family with the\nC8051F120 \u2014 a 100 MHz 8051 with 128 KB of flash, 8.25 KB of RAM, and a 100-pin\nmicrocontroller. It\u2019s an older part, but it\u2019s still supported in Simplicity\nStudio (though not in Simplicity Configurator).\n\nThe STC8 I tested is the top-of-the-line part in their catalog.\n\nThe MSP430 extends up to the MSP430F6779, with 512 KB of flash, 32 KB of RAM,\nand 128-pin packaging.\n\nDevelopment Ecosystem\n\nThe development ecosystem of a microcontroller has a profound impact on\nproductivity and ease of use of the part, and these IDEs, peripheral\nlibraries, dev boards, and debuggers varied wildly among the microcontrollers\nreviewed here.\n\n# Development Environments\n\nEclipse-based development environments, such as Code Composer Studio from\nTexas Instruments, provide a complete text editor, toolchain, and debugging\nsystem in one application \u2014 plus many vendors choose to extend Eclipse with\nvendor-specific features, such as the ULP Advisor that Texas Instruments\nbundles to help developers get active- and sleep-mode current down to the\nminimum.\n\n## Eclipse\n\nEclipse is a Java-based IDE originally developed at IBM to develop in Java.\nBut since 2001, it has been an open-source project built by the Eclipse\nFoundation.\n\nEclipse CDT provides C/C++ tooling, and has taken off like wildfire in the\nembedded world \u2014 starting in the 32-bit ARM ecosystems, but migrating down to\n16- and 8-bit parts as well. In fact, almost all the major microcontrollers\nhere are programmed in an IDE based on Eclipse:\n\n  * NXP Kinetis KE04 uses Kinetis Design Studio\n  * NXP Kinetis KL03 uses MCUXpresso (or Kinetis Design Studio)\n  * Infineon XMC1100 uses DAVE\n  * Nuvoton M051 uses CooCox CoIDE\n  * NXP LPC811 uses MCUXpresso\n  * Renesas RL-78 uses e^2 studio\n  * Silicon Labs EFM8 uses Simplicity Studio\n  * ST STM32F0 uses System Workbench for STM32\n  * Texas Instruments MSP430 uses Code Composer Studio\n\nOther than DAVE, CooCox, and e^2 studio (which all only run on Windows), all\nof these toolchains have cross-platform support for Windows, macOS, and Linux.\n\nRecent versions of Eclipse, like the 4.6.3 Neon release that System Workbench\nfor STM32 uses, provide good dark theme support, as well as the incredibly\nsnappy pop-up function browser that shows you the full source code of any\nfunction you hover over.\n\nMain features of Eclipse CDT include multi-project workspaces, debugging with\ntons of introspection windows, support for different toolchains, plus a\nsyntax-highlighting text editor with content assist text completion, macro\ndefinition browsing and highlighting, code snippets, and tons of refactoring\ncapabilities.\n\nThe code editor in Eclipse is definitely a stand-out among IDEs tested \u2014\nespecially if you\u2019re coming from other IDEs. Everything is completely\ncustomizable, very snappy, and full of features. The pop-up \u201cSource Hover\u201d is\none of my favorite features: hover over a function, and the source of the\nfunction (including any docs) will pop-up immediately. If you\u2019re still not\nsure about something, move your mouse down into the pop-up window and it turns\ninto a scrollable editor window, allowing you to see the entire contents of\nthe function (and copy-and-paste from it). One feature request: I would love\nto see Ctrl-Click working from within this pop-up, and it would also be\namazing to see editing capability, too.\n\n### Vendor Customizations\n\nThe GNU MCU Eclipse plug-ins have made it trivial to set up an Eclipse-based\nworkflow when working on many ARM processors; under the hood, some of these\nIDEs are basically just pre-packaged open-source components with a nice splash\nscreen. This is definitely the case for Kinetis Design Studio, MCUXpresso, and\nSystem Workbench for STM32 (which didn\u2019t even bother changing the Eclipse\nlogo). There\u2019s nothing wrong with that \u2014 it\u2019s far less jarring to move between\nstock Eclipse IDEs, and if you\u2019re short on hard drive space, you could\nprobably install and configure plug-ins to essentially combine many of these\nIDEs together.\n\nOn the other hand, some vendors had to go through great lengths to get an\nEclipse-based environment working with their parts. Silicon Labs had to write\na debug interface from scratch that could communicate with their tools (and\nwork with Keil C51 binaries), custom property panes for managing the build\nsystem \u2014 along with packaging a patched WINE system that can run Keil C51\nseamlessly on macOS and Linux (and from my testing, they pulled it off).\n\nCoIDE has a super-simple target configuration property pane, and Keil \u03bcVision-\nstyle buttons for building and rebuilding projects.\n\nIn fact, one IDE \u2014 CoIDE \u2014 is so far removed from Eclipse, I hesitated to even\nmention it in this list. CooCox essentially stripped Eclipse down to its base,\nand built up CoIDE saving little more than the Eclipse shell.\n\nWhat results is an IDE that is extremely easy to use \u2014 great for students and\nhobbyists who many find the Eclipse project properties pane to be... well, a\npain. This comes at the expense of flexibility, however \u2014 tons of the\ndebugging options and windows are missing, and you can only open one project\nat a time. Sometimes the IDE does thing you may not want. For example, every\nfolder you create in a project is automatically added to the list of project\nsource files as well as include files. I imagine this will quickly cause\nfilename conflicts in large projects (which CoIDE doesn\u2019t seem built for).\n\nWhen building out the DMX-512 demo for the RL-78, e^2 studio\u2019s Stack Analysis\ntool helped me see where my stack-heavy calls were.\n\nVendors like Freescale decided to stop heavily customizing Eclipse with their\nown proprietary debugging system (which they did in CodeWarrior), and switch\nto these open-source plug-ins. I have mixed feelings about this change, as\nCodeWarrior seemed much faster at starting and stopping debug sessions than\nthe GDB-based system everyone uses these days.\n\nOn performance overall, recent versions of Eclipse (Mars or better) seem to be\nmuch snappier than the disastrous Juno release, so if it felt slow and bloated\nlast time you tried it, you may want to give it another shot.\n\nOxygen (4.7.0) was just released in June, so the newest IDEs \u2014 System\nWorkbench, MCUXpresso, and Code Composer Studio \u2014 and are still on Neon (4.5).\nOther Eclipse-based IDEs are on older versions \u2014 with Kinetis Design Studio\nand DAVE being on the oldest release (Luna SR2 \u2014 4.4.2).\n\nSimplicity Studio has a beautiful and functional register view that allows you\nto interact with registers using names and drop-down lists \u2014 this saves a lot\nof time when tracking down problems \u2014 no datasheet required.\n\n### Debugging in Eclipse\n\nEclipse \u2014 across nearly all vendors \u2014 provided the best out-of-the-box\nexperience out of all the IDEs I tested. Projects support multiple debug\nconfigurations that allow you to use different debuggers and target\nconfigurations. Out of the box, you get a source code view with interactive\nbreakpoints, a memory browser, a disassembly view, and a list of core CPU\nregisters.\n\nDebugging in Eclipse is relatively unified across the platforms \u2014 the biggest\ndifferences are the supported debuggers, and the custom debugging windows \u2014\nespecially the peripheral register view.\n\nIn my opinion, the peripheral register viewer is one of the most important\ndebug windows \u2014 even more important than the disassembly view. My favorite\nregister viewers are the ones used in TI\u2019s Code Composer Studio and SiLabs\u2019\nSimplicity Studio. These have a contiguous list of all registers, organized in\na tree view, with detailed descriptions of each register\u2019s value, with combo-\nbox selectors of all the values. Simplicity Studio edges out Code Composer\nStudio by naming all the constants. This is sometimes unnecessary (like:\nSYSCLK_DIV_12 (System clock divided by 12) ), but definitely keeps your eyes\nout of the datasheet for the part.\n\nKinetis Design Studio uses EmbSysRegView \u2014 an open-source Eclipse plugin \u2014\nwhich provides similar functionality. This uses SVD, a standardized set of\ntools for generating header files and descriptions of such.\n\nSystem Workbench for STM32 has a similar view, but doesn\u2019t automatically fetch\nthe register values. This may not be a bad thing, as ARM microcontrollers tend\nto have a lot more register addresses than 8-bit parts, but it still feels a\nbit clunkier.\n\nMCUXpresso and Infineon DAVE have a somewhat-strange two-step process \u2014 you\nselect the peripheral in one view, and it creates a memory rendering.\nRegisters are broken out logically into one or more bits, but the drop-down\nlists don\u2019t have named enumerations that describe what each bit-pattern does.\n\nDAVE has exactly the same plugin as MCUXpresso, but it seems buggy \u2014 it\ndoesn\u2019t always work. Hopefully this gets fixed in a future version, because is\nseverely limits the usability of the debug system.\n\nCoIDE and e^2 studio both have the worst register views \u2014 they simply display\na list of the peripheral register whole values, without breaking them up\nlogically or annotating them with text.\n\ne2 studio has real-time watches of variables; in addition to displaying\nvariable values as a list, they can be plotted over time, or displayed in\ngimmicky GUI widgets that look ugly.\n\n### Other features\n\nSome vendors have gone above and beyond with useful (and not-so-useful)\nadditional views and features. e^2 studio, despite the pesky peripheral\nregister viewer, has a useful real-time view of variables that update while\ndebugging. I suspect the IDE is periodically breaking the MCU, reading the\ncontents of RAM, and updating the display \u2014 but they may have a mechanism for\nreal-time tracing in the RL-78 core.\n\nThis IDE can also show flash and RAM usage \u2014 though it\u2019s not plotted as nicely\nas it is in DAVE, which shows a pie chart of all symbols.\n\nSpecific to ARM parts, all Eclipse IDEs I tested support semihosting, which\nallows you to print characters to a console window during debugging. The\ncharacters are printed through the debugging interface, so there\u2019s no need to\nconfigure a UART. MCUXpresso and CoIDE were the easiest Eclipse-based IDEs to\nconfigure with semihosting.\n\nMCUXpresso has nice project properties panes for selecting a C runtime library\n(it includes Redlib in addition to Newlib Nano) as well as linker settings.\n\nWhich of these #ifdefs are enabled? Your guess is as good as mine; Atmel\nStudio is Visual Studio without Microsoft\u2019s excellent IntelliSense engine,\nmaking it worse than even Keil \u03bcVision in terms of text-editing productivity \u2014\nand far inferior to the Eclipse- and NetBeans-based IDEs from competitors. I\nadded 6 publicly-visible global variables in this file among others in the\nproject, and none of them appear in the auto-complete list.\n\n## Atmel Studio\n\nThis error started popping up recently in Atmel Studio \u2014 the only solution\nseems to restart my computer. It\u2019s obviously from an old chunk of code, since\nit\u2019s referring to the program as \u201cAVR Studio.\u201d\n\nWhile many vendors have transitioned to Eclipse-based IDEs, Atmel went with a\nVisual Studio Isolated Shell-based platform starting with AVR Studio 5. I do a\nton of .NET and desktop-based C++ development, so I expected to feel right at\nhome in Atmel Studio when I first launched it. Unfortunately, Microsoft calls\nthis product \u201cVisual Studio Isolated Shell\u201d for a reason \u2014 it\u2019s simply the\nshell of Visual Studio, without any of the meat. The excellent IntelliSense\nengine that Microsoft spent years perfecting has been replaced by a third-\nparty \u201cVisual Assist\u201d plugin that struggles to identify global variables,\nevaluate pre-processor definitions, or perform refactoring of items defined\noutside of the current file. The Toolchain editor is a near-clone of the\nEclipse CDT one (no reason to reinvent the wheel), but it\u2019s missing checkboxes\nand inputs for commonly-used compiler and linker options; one stunning\nomission is link-time optimization, which even when manually-specified as\ncommand parameters, doesn\u2019t seem to work \u2014 odd, since Atmel is using a recent\nversion of GCC.\n\nMy biggest issue with Atmel Studio is how incredibly buggy and unstable it has\nbeen every time I\u2019ve used it in the last two years. I\u2019m not referring to a\nspecific installation on a specific computer: rather, every single time I\u2019ve\ninstalled the software, I\u2019ve fought with AVR Dragon drivers, a bad DLL file in\nthe installer, programmer firmware issues, or, most recently, the software\npopping up the \u201cWaiting for an operation to complete\u201d message that prevents me\nfrom debugging any Atmel product without restarting my computer. Look, I get\nit: embedded firmware development is a highly-specialized task, so maintaining\nsoftware that works reliably for such a small user-base can be challenging.\nYet, every other vendor tools tested worked nearly flawlessly.\n\nMPLAB X is a NetBeans-based IDE that is comparable to Eclipse in terms of OS\nsupport, editor capabilities, and debugging \u2014 but it lacks some of the\nadvanced debug configurations and introspection features that make Eclipse so\npowerful.\n\n## MPLAB X\n\nWhile many vendors were moving from their proprietary Windows-only IDEs to an\nopen-source Eclipse-based workflow, Microchip went a different route when they\nmoved MPLAB 8 to the NetBeans-based MPLAB X in 2012.\n\nOn paper, NetBeans is a lot like Eclipse \u2014 it\u2019s a Java-based IDE that was\noriginally built to target Java development \u2014 but has since expanded to\nsupport C/C++ (along with web-centric languages: HTML, PHP, JavaScript, etc).\nLike Eclipse, NetBeans is open-source, and cross-platform. Unlike Workspaces\nin Eclipse, NetBeans doesn\u2019t strongly enforce this paradigm \u2014 but it does\noffer \u201cProject Groups\u201d which has similar functionality. Both have good text-\ncompletion capabilities and source introspection; both have macro expansion.\n\nI\u2019ve used both for years, so I feel comfortable making this subjective claim:\nNetBeans feels simpler; Eclipse feels more powerful. A lot of this is a result\nof the UX design choices \u2014 Eclipse loads the window with tons of buttons,\ndrop-down menus, and docked panes full of features. The entire IDE\u2019s scale is\nmuch more dense than NetBeans.\n\nEven though NetBeans has a lot of the same features, the UI is sparsely\npopulated with the bare minimum of buttons you need to get your job done. Even\nthe menu bar is light on options. Instead, advanced, rarely-used features are\nburied away inside sub-sub menus, or \u2014 somewhat more commonly \u2014 with keyboard\ncombinations. As an example, I have no idea how to show the excellent Macro\nExpansion view in NetBeans, other than pressing Ctrl-Alt and clicking on a\nmacro. Just to double-check, I went hunting for it in the menu bar, as well as\ndigging through the context menus.\n\nI think students and hobbyists might be drawn toward the simplicity of\nNetBeans, but I prefer Eclipse\u2019s density, as it encourages users to go\nexploring and discover new features.\n\nOne big omission with the NetBeans text editor is the pop-up Source Hover code\nexplorer that Eclipse has. Hover over any function in Eclipse, and the entire\nsource code for that function pops up in a window you can scroll through.\nNetBeans will display code docs for functions, but if you want to look at the\ncontent of them, you\u2019ll have to Ctrl-Click your way into the definition.\n\n### Microchip Customizations\n\nI have to applaud Microchip for heavily customizing NetBeans into MPLAB X \u2014 an\nIDE that really feels like it was built for embedded development. The Project\nProperties window is all Microchip \u2014 you can select which tool you want to use\nto program the device (or the integrated simulator), as well as compiler\noptions, include paths, and tool configuration.\n\nIntegrating the tool setup into individual project properties is useful for\ndevelopers who switch between devices (and voltages!) a lot; but it may feel\nclunky to users who are always on the same device, using the same settings \u2014\nevery time they create a new project, they\u2019ll have to go through the same tool\nconfiguration settings (debugger powers target, select correct voltage, blah\nblah blah).\n\nOne goof immediately visible is the redundant \u201cRun Project\u201d and \u201cMake and\nProgram Device\u201d buttons. From what I can tell, these are identical (the manual\nsays you can use either). However, from the bizarre Eclipse integrations I\u2019ve\nseen, I\u2019m used to dealing with UI oddities like this when dealing with\nembedded IDEs.\n\nMicrochip integrates a lovely dashboard view (visible in the bottom of the\nmain photo), which indicates the device target, the compiler, and the memory\nusage.\n\nThe MPLAB X Options window allows you to add multiple instances of the\nMicrochip XC compilers. As these compilers are quite expensive and don\u2019t\nsupport new devices introduced after their release, it is common for shops to\nhave several versions of XC compilers floating around \u2014 old, paid-for\nversions, and new code-size-limited versions they may grab to evaluate a new\npart before forking over dough.\n\nI\u2019m not a big fan of the hover-over-to-view-bit-values feature in the\nperipheral registers view.\n\n### Debugging\n\nDebugging across all Microchip devices is much slower than in other IDEs. I\u2019m\nnot sure if this a limitation of the MCU, the PicKit 3, or the IDE (or all of\nthe above). The default behavior of MPLAB X is to reconnect from the tool\nwhenever starting a debug session, but you can shave a few seconds off the\ndebug load time by instructing the IDE to maintain a constant connection to\nthe tool by ticking the appropriate box in the Options dialogue. This really\nought to be the default option, as few developers know of its existence,\ndebugging is slow enough as it is, and there are very few usage cases where\nyou\u2019d want the IDE to disconnect from the debugger upon completing a debug\nsession.\n\nWhile there\u2019s an option to display a Dissassembly view while debugging, this\ndoesn\u2019t come up by default, and even when you select it, it doesn\u2019t seem to be\n\u201csticky\u201d \u2014 you have to re-open the view every time you start a debug session.\nThis is fine for Java or desktop C/C++ development, but for embedded\nmicrocontrollers, disassembly view is critical.\n\nMPLAB X\u2019s NetBeans backend seems confused by bit-field register definitions,\nwhich makes hover-over symbol inspection basically worthless when you\u2019re in a\ndebug session.\n\nAnother afterthought seems to be the peripheral register view, and peripheral\nregister handling in general. Pull up the SFRs view, and you\u2019ll be greeted by\nan extremely slow-loading window that\u2019s painful to scroll through \u2014 especially\non larger devices like the PIC32.\n\nThis view displays the address of the register (who cares?), the hard-to-\nunderstand short-form name, the hex value of the register, the decimal value\nof the register (who cares?), the binary value (hilariously long when working\non 16- and 32-bit processors), and an ASCII interpretation of the register\u2019s\nvalue (...why on Earth...?) \u2014 but what\u2019s not in this view is: a human-readable\nname of the register, description of the register\u2019s function, or a human-\nreadable decoding of the register\u2019s current value.\n\nThere\u2019s a hover-over break-down of the register into its individual bits, but\nthese use the same short-form datasheet names, don\u2019t provide descriptions, and\ndon\u2019t contain enumeration values for multi-bit fields (or any explanation at\nall).\n\nBasically, you\u2019re going to have to have your datasheet open so that you can\nhand-decode the values of these registers, as Microchip doesn\u2019t seem\ninterested in integrating that style of documentation into their IDE.\n\nThese are the things that drive me nuts \u2014 it\u2019s 2017; all of this data is\nalready computerized. All they need to do is add a bit more functionality to\ntheir view (which many Eclipse-based vendor tools have), and all the sudden,\nthe SFR view becomes ten times more productive to use.\n\nFor higher-end PIC32 and PIC24 devices, there\u2019s a semihosting-like feature\nMicrochip calls appIO (though it only works with their pricy ICD debuggers).\nThere\u2019s also runtime variable watch and instruction tracing, but that\u2019s only\nsupported by the really pricy RealICE debugger.\n\nHT-IDE3000 looks like Office 2003\u2019s ugly cousin, but its ancient GUI toolkit\nsnaps along on modern systems at lightning speed. Text completion is basic but\nrocket-fast, and the IDE integrates well with the debugger and target MCU.\n\n## Holtek HT-IDE3000\n\nAnyone who complains about IDE bloat and download registration walls should\nimmediately check out Holtek HT-IDE3000 (yes, that\u2019s what it\u2019s called). Visit\ntheir website, click the download link, and a small 90 MB ZIP file starts\ndownloading.\n\nThey do make you type in the serial number on your $40 eLink debugger before\nusing it (likely to deter debugger cloning), but that\u2019s the only registration\nyou\u2019ll see.\n\nOnce you get the IDE up and running, the first thing you\u2019ll notice is its\nOffice 2003 look. It ain\u2019t pretty, but it\u2019s functional. All the menu buttons\nyou see are completely customizable through a drag-and-drop editor, which I\ndidn\u2019t see in any other IDE tested.\n\nThe best part about having such an old-school IDE is that this thing screams:\nzero-lag text-editing, immediate hover-over pop-up tooltips with function\nsource code (like the Hover Source feature in Eclipse, but much more\nlightweight), and zippy project building. I did a double-take when looking at\nRAM usage: HT-IDE3000 uses 9.9 MB of RAM. Yes, that decimal point is placed\nproperly. Insane.\n\nThis comes at the expense of code intelligence features. IDE3000 can go to\nvariables, macros, and function definitions; auto-complete variables and\nfunctions; and display pop-up source listings of functions when you hover over\nthem. But there are no real macro expansion capabilities or code outline\nviews, and the text completion is pretty basic: it recognizes C types and\nfunctions but doesn\u2019t seem to like remembering SFRs or other types of things\nthat get #define\u2019d. There\u2019s no macro expansion, and the text completion isn\u2019t\nintelligent \u2014 it\u2019s only a selectable list of all symbols visible in the given\ncontext.\n\nThis turns out to be good enough for the sorts of projects these small devices\ntackle. It\u2019s not like you\u2019re going to be juggling around more than a few dozen\nvariables, and I\u2019d bet 90% of the code-bases that target these parts comprise\na single C file.\n\nWhat you do get with Holtek is deep integration with the device you\u2019re\ntargetting. There\u2019s built-in functionality for interacting with EEPROM on the\ndevice, programming using USB bootloaders present in some of their chips, as\nwell as a built-in OTP workflow for generating the appropriate files Holtek\nneeds to manufacture your parts (since most Holtek devices sold are OTP\nparts).\n\nDebugging in HT-IDE3000 is lightweight and snappy, with most features you\u2019d\nexpect. I wish the register view had more information about the individual\nbits (at least their full name and description as a hover-over tooltip), but\nit gets the job done \u2014 especially considering how simple the architecture is\nthis IDE targets.\n\nAs soon as you build a project, IDE3000 will jump into a debugging session in\nthe background \u2014 even as you continue editing and building. This\nunconventional experience lures you tap that \u201cBuild\u201d button often, and gush at\nyour progress. As most firmware projects targetting this microcontroller will\nhover in a while() loop until interacted with, while you\u2019re editing, you can\ndouble-click on a line of code to set a breakpoint, immediately check out\nwhat\u2019s going on, make changes, and continue editing \u2014 without the manual\nprocess of uploading code, switching to a debug perspective, waiting for the\nimage to flash, start running, and a breakpoint hit.\n\nCode building and uploading are so fast, it almost feels like you\u2019re in a\nsimulator or a PC-based environment. The debugging views are basic but fully-\nfunctional. The peripheral register view will break down each register into\nthe bits that are set and cleared \u2014 but I would have preferred hover-over\ndescriptions of the registers and the bits they command.\n\nWhile Holtek could modernize the UI, you\u2019ll get no complaints about stability\nfrom me: I didn\u2019t have a single crash, bug, hiccup, or driver installation\nkerfuffle the entire time I used IDE3000 \u2014 I tried it on both Windows 7 and\nWindows 10 Fall Creator\u2019s Update, and the experience was identical. Holtek\naccelerates an update schedule by squashing bugs and adding new features\nseveral times a year \u2014 in fact, they had two updates over the course of my\nwriting this review, which is more than any other IDE.\n\nSTVD supports decent text completion, and customizable editor colors and\nfonts.\n\n## ST Visual Develop (STVD)\n\nSTVD is the official IDE for the STM8. Its UI feels even older than IDE3000,\nbut it\u2019s a bit better when it comes to text-editing capabilities. Its code\ncompletion is invoked with the familiar ctrl-spacebar shortcut, and instead of\njust displaying all symbols discovered, it seems to default to symbols that\nmake sense in the present context. It knows enough about C to walk into\npointer-referenced structs, but unfortunately, has no pop-up documentation or\nsource-code browsing when you hover over a method.\n\nUnfortunately, it feels slow. Code completion can take a second or longer to\npop-up in larger projects, rearranging toolbars was sluggish, going to the\ndefinition of a symbol took time to load the editor window, and menus were\nslow to appear.\n\nThe peripheral registers view had descriptions of all the registers, but\ndidn\u2019t break down registers into individual bits (or explain what they were).\n\nDebugging was also worse than average. Breakpoints can\u2019t be set while the\ntarget is running \u2014 you must manually pause it, add your breakpoint, and then\ncontinue execution. The peripheral registers view was also underwhelming:\nwhile it has descriptions of registers, it only displays the whole value of\nthe register \u2014 in hex format \u2014 without giving you a per-bit breakdown useful\nfor catching bit math bugs in your code. Yet again, you\u2019ll be resigned to\nmanually cross-checking register values with values from the datasheet \u2014 one\nof my biggest pet peeves.\n\nPSoC Creator is built around Cypress\u2019s code-gen tools, which provides a\nschematic capture interface for instantiating and connecting components; these\ntools generate the configuration bitstream along with an API for the\nperipherals.\n\n## PSoC Creator\n\nCypress PSoC Creator is the official \u2014 and only \u2014 development environment\navailable for Cypress\u2019s line of PSoC devices, and encompasses a project\nmanagement system, text editor, schematic capture tool, code generator, and\ndebugger.\n\nPSoC Creator\u2019s interface lurks out of the last decade with its Office 2003\ncostume, and its .NET codebase ensures porting it to Linux or macOS will be an\narduous task that Cypress, itself, resigns as unlikely.\n\nPSoC Creator feels snappier and lighter-weight than Eclipse or NetBeans-based\nenvironments while maintaining 90% of the IDE features and code introspection\nabilities. Loadable workspaces weave together one or more projects \u2014 any\nnumber of which can be open at the same time \u2014 exactly as Eclipse does.\n\nA Code Explorer pane leads you to variable and function definitions with a\nsingle click; while the text competition digs deep into functions, macros, and\nvariables to bubble up suggestions with the familiar Ctrl-Spacebar shortcut.\n\nCypress needs to refashion hover-over tooltips into what Eclipse or IDE3000\ndoes; as it stands, the tooltips print the name of the function and its\nparameters \u2014 there are no code docs, and no quick source view you can use to\npeek at a function\u2019s implementation.\n\nThere\u2019s one-click documentation access, plus a resource meter for monitoring\nboth flash and SRAM usage \u2014 but also peripheral usage, which shows you exactly\nhow integrated PSoC Creator is with the underlying PSoC hardware.\n\nThe 500 lb gorilla in the PSoC Creator ecosystem \u2014 the schematic capture\nconfigurator tool \u2014 is a major omnipresence in PSoC Creator \u2014 but I\u2019ll save\nthat discussion for Code Generator section of this review page.\n\nPSoC Creator has no global register inspector like other environments; you can\nonly view peripheral registers associated with instantiated components.\n\nFlash load times were unimpressive (though not the worst seen in my round-up).\nA basic, 1.4 KB program took 7.82 seconds to load and run to main(). Filling\nflash up to 16 KB took 10.84 seconds.\n\nPSoC Creator jostled my brain when I strained to reduce power consumption in\nmy DMX project. I couldn\u2019t find a standard list of all peripheral registers\nwhich would allow me to cross-reference bits from the datasheet \u2014 instead, you\ncan select from the peripherals you\u2019ve configured in the schematic capture\nview, which initiates a limited view of that specific peripheral (and only\ndisplaying the registers associated with its current function).\n\nAs this is an ARM microcontroller, you may intuit that a cross-platform GCC-\nbased toolchain would be easy to set up \u2014 but because of the proprietary\nconfiguration bitstream required when flashing these devices, you\u2019ll need to\nuse Cypress\u2019s tools to fit your design to the processor and merge this\nbitstream with your application binary code.\n\nWhile Cypress stops short of supporting Linux or macOS outright, PSoC Creator\ncan export projects to common cross-platform Eclipse or Makefile-based\nenvironments \u2014 as well to industry stalwarts \u03bcVision and IAR.\n\nBut if you\u2019re on Windows, I wouldn\u2019t bother \u2014 this is as close to an\nEclipse/NetBeans workflow you\u2019ll get with a proprietary IDE, and it\u2019s\ndefinitely good enough to compete with either.\n\n## Keil uVision\n\nKeil\u2019s fame ensues from their acclaimed 8051 compiler, C51, introduced in 1988\n\u2014 but since 1997, their compilers have also shipped with their in-house IDE,\nKeil \u03bcVision. Now at version 5, \u03bcVision continues to be popular among\nprofessional dev shops for both Arm and 8051 development, even as more and\nmore manufacturers roll their own cross-platform toolchains.\n\nSpeaking of that, while every Arm part I reviewed has its own manufacturer-\nprovided IDE (save for the M051), developers can use \u03bcVision as an officially-\nsupported development environment for all them.\n\nOn the other end of the spectrum, among the 8051, only Silicon Labs maintains\ntheir own IDE for the EFM8 \u2014 both the N76 and STC8 only support \u03bcVision.\nKeil\u2019s IDE has support for multi-project workspaces, though it doesn\u2019t enforce\ntheir use.\n\nKeil\u2019s text editor is painful to use. The first two things you\u2019ll notice are\nthat there are no auto-indenting inside block statements, and out of the box,\nthere\u2019s no keyboard shortcut for commenting or uncommenting code. Sure, you\ncan bind \u201ccomment text selection\u201d and \u201cuncomment text selection\u201d to shortcut\nkeys, but you have to select the text before invoking. This is ridiculous.\n\nEven more painful: \u03bcVision has a Jekyll-and-Hyde act when switching between\nC51 (8051) and MDK (Arm) projects. When building Arm projects, \u03bcVision has ok-\nbut-not-great text-completion (in the form of a pop-up list of discovered\nsymbols) \u2014 but when building 8051 projects, that text completion inexplicably\nvanishes.\n\nKeil \u03bcVision\u2019s Arm debugging has a functional peripheral inspector that breaks\neach register into each logical field, with named descriptions of any\nenumeration values.\n\nDebugging is the same sad song. Keil has good support for semihosting in Arm\nprojects without needing much user intervention. A decent peripheral register\nexplorer helps you diagnose peripheral issues with named-value fields that\nhave nice descriptions.\n\nDebugging on the 8051 is a different story \u2014 the pop-up peripheral inspectors\nare clunky, and not every vendor adds the proper support to Keil.\n\nBut in 8051land, weird pop-up peripheral inspectors stand in for the\nperipheral pane. While these curtail my productivity, I must admit they are\nmore amusing than their Arm brethren (let\u2019s be honest: who doesn\u2019t love\nclicking checkboxes and watching LEDs light up?).\n\nI scoured the menus, feature lists, help files, and online examples trying to\nredeem \u03bcVision by finding something it excelled at compared to the other IDEs\nI evaluated. I suppose it\u2019s much lighter-weight than Eclipse is \u2014 coming in at\n105 MB of RAM usage during a debug session. It makes too many concessions for\nme to even consider it alongside Eclipse, though.\n\nIn the end, consider \u03bcVision as nothing more than the free editor you get when\nyou download C51 or MDK-ARM. And it\u2019s not worth a penny more.\n\n# Code generation tools\n\nPeripheral configuration and bring-up is generally a drop in the bucket when\ncompared to the time required to implement an entire commercial embedded\nproject \u2014 but if you\u2019re working on tiny projects (either hobbyist stuff, or\nsimple proof-of-concept engineering demos), having a code-gen tool can\nnoticeably speed up the development cycle.\n\nMany of the development environments tested have code-gen tools either\nintegrated directly into the IDE (Microchip Code Configurator, Simplicity\nConfigurator, Infineon DAVE, PSoC Creator, Processor Expert, or have stand-\nalone tools (STM32CubeMX, Atmel START, STC-ISP, MCUXpresso Config Tools).\n\nSome generate initialization code that calls into the vendor\u2019s general-purpose\nperipheral libraries (like STM32CubeMX), while some generate raw register\ninitialization values from scratch (Silicon Labs\u2019 Simplicity Configurator).\n\nWhile Atmel START provides a nice-looking graphical interface especially\nuseful for the flexible clocking schemes available on modern ARM\nmicrocontrollers, its design validation is hit or miss: in this picture,\nthere\u2019s absolutely no warning that the main 32 kHz oscillator isn\u2019t enabled.\nMost seriously, the DFLL module indicates it\u2019s outputting a frequency of 48\nMHz, even though its multiplier is set to \u201c0\u201d in the configuration properties\ndialogue. Changing this to arbitrary values does not update the \u201c48 MHz\u201d\ndisplay. This is a tool you cannot trust.\n\n## Atmel START\n\nMicrochip\u2019s code-gen tool for its Atmel acquisition is a hold-over called\nAtmel START; it\u2019s a web-based code configurator that supports nearly their\nwhole catalog of current devices. Under the hood, it generates peripheral\nlibraries that are considered part of ASF4 (Atmel... err, \u201cAdvanced\u201d...\nSoftware Framework). This is a marked improvement over ASF3 on paper, but\nthere are still significant problems with it.\n\nFirst, the good: using the part with 8-bit megaAVR and tinyAVR devices is a\nno-brainer. You can use the \u201cinitialization\u201d drivers instead of the \u201cbasic\u201d\ndrivers to generate init-only code, along with any stubbed out ISR functions\nyou need. The generated code is beautifully documented, extremely readable,\nand compact. It\u2019s written the way you would probably write it by hand, and I\ncan imagine this would serve as a nice learning tool for someone coming from\nArduino, looking to take baby steps toward programming MCUs at the register\nlevel.\n\nNow the bad: Atmel START is extremely clunky to use. Projects must originate\nin the web browser, then get exported to a ZIP archive format, where Atmel\nStudio extracts them to a solution, where you can then open them. If you want\nto change something, thankfully Atmel Studio allows you to right-click on the\nproject and reconfigure it \u2014 opening a browser window inside the app and\nautomatically loading the project.\n\nBut this begs the question: why can\u2019t Atmel Studio create these projects from\nthe get-go, if it can edit and re-generate them? Another problem with Atmel\nSTART is the lack of placeholder markers the tool can use to determine what to\npreserve and what to overwrite \u2014 this is only done at a whole file level. I\nassume this is why they don\u2019t pre-define user callback function stubs, as\nthese would get overwritten on subsequent regenerations of the code. This is a\nlazy design decision that makes integrating code with Atmel START challenging.\n\nMore bad news for START: Atmel\u2019s SAM D-series parts I evaluated require lots\nof clock configuration (like most Arm parts), but START provides absolutely no\nerror-checking or clocking suggestions for you. It will gladly generate code\nthat uses the main DFLL, without actually enabling the main DFLL, causing your\nprogram to hang in a while() loop waiting for the DFLL to start up, when it\nnever will.\n\nThis is the crap that makes getting going on a new platform so challenging,\nand this is precisely why I like using code configuration tools. So if a tool\ncan\u2019t do that, I scarcely see much value to it that I can\u2019t get from normal\nperipheral libraries.\n\nProcessor Expert provides a stunning array of configuration options and\nflexibility \u2014 but make sure you have a fast desktop PC, as this tool is a huge\nresource hog. It also generated some of the slowest peripheral code in the\nround-up.\n\n## Processor Expert\n\nProcessor Expert is at the other end of the spectrum. PE generates\ninitialization code, interrupts, user callbacks, linker files, and an entire\nperipheral library. It uses a component-oriented model with dependency\nresolution; for example, two high-level \u201cPWM\u201d component instances will share a\ncommon \u201cTimer Unit\u201d low-level component (as they will end up on different\noutput-compare channels of that timer unit).\n\nHigh-level components implement conceptual functionality, not peripheral\nfunctions. For example, if you wanted a function to execute every 25 ms, you\nwould add a \u201cTimerInt\u201d component, and set the interval to 25 ms. Processor\nExpert will figure out which timer to use (FlexTimer, LPTimer, PIT, etc),\nroute the clock appropriately, and calculate the necessary period register\nvalues, enable interrupts, generate an interrupt handler that takes care of\nany bits you need to set or clear. Of course, you can override any of its\ndecisions at any point through its plethora of property panes \u2014 and unlike\nSTART, it will check your work to make sure everything is kosher.\n\nWhile it\u2019s extremely flexible, the biggest problem with Processor Expert is\nits interface is unbelievably slow \u2014 whenever you change a parameter, it can\ntake several seconds (even on a fast computer) for that change to propagate.\nWhen you hit \u201cGenerate Code\u201d prepare to wait 10-30 seconds at least \u2014 and\nproject rebuilding takes forever, too.\n\nDAVE provides a property-based GUI code generator that integrates well into\nthe IDE. The tool calls into a lightweight peripheral library, XMClib.\n\n## Infineon DAVE\n\nInfineon DAVE is similar from the user\u2019s perspective, but instead of\ngenerating nearly-unreadable, multi-level library code, DAVE generates\ninitialization code calls into XMClib to manage peripherals. And unlike\nProcessor Expert, DAVE designers appear to have designed the generated code\n(as well as XMClib in general) for better optimization than Processor Expert,\nwhere even a single bit-toggle function ends up nearly completely unoptimized\n\u2014 taking 40 cycles to complete.\n\nDAVE also integrates higher-level \u201capps\u201d \u2014 like built-in lighting control\nsystems (including a DMX-512 receiver), communication protocols, graphics\nlibraries, and motor controller libraries (we\u2019re talking about pretty advanced\nstuff: FOC of ACIMs and PMSMs).\n\nSilicon Labs\u2019 Simplicity Studio includes the built-in Simplicity Configurator\nfor generating lightweight initialization code and ISR stubs.\n\n## Silicon Labs Simplicity Configurator\n\nSilicon Labs takes a much lighter-weight approach to code generation with\nSimplicity Configurator. All Simplicity Configurator does is create peripheral\ninitialization code, by generating functions that directly initialize register\nvalues.\n\nSilicon Labs has a full EFM8 peripheral library, but Simplicity Configurator\ndoes not call into it nor include it automatically \u2014 it just initializes\nperipherals, using raw register manipulation.\n\nYou can combine Simplicity Configurator projects with the EFM8 peripheral\nlibrary, or use your own code for interacting with the peripherals during\nruntime (Or just use the peripheral library without any code configurator).\n\nI really like this approach, as it provides a ton of flexibility, and keeps\nthe size of generated code under control.\n\nIt\u2019s also one of the snappiest code-gen tools reviewed \u2014 Silicon Labs has so\nmuch confidence in its tool\u2019s speed that it programmed the tool to auto-\nregenerate all the initialization code whenever you save the Configurator\ndocument, and in my testing, this didn\u2019t introduce any noticeable lag.\n\nA neat perk unique to Simplicity Configurator is it can also generate stubs\nfor ISRs \u2014 and the generated stubs include comments instructing you which bits\nto clear before leaving the ISR. Beautiful.\n\nI really enjoyed the timer documentation in the datasheet, and I was glad to\nsee much of it made it into the code generator tool. Too many embedded\nprogrammers don\u2019t understand all the powerful functions of advanced timers, so\nthis tool should help out a lot.\n\n## Renesas Code Configurator\n\nRenesas e2studio includes Code Configurator, their code-gen tool built into\ntheir IDE. This tool integrates a nicely-organized visual layout that\u2019s\nextremely readable and self-documenting.\n\nThis tool handles communication callbacks particularly effectively \u2014 the code\ngenerator creates an interrupt that handles the underlying ISR details, but\nthen directly invokes a statically-declared callback function that\u2019s stubbed\nout conveniently for the user. This callback has direct access to the buffer\nassociated with the data, so there\u2019s no expensive copying/buffering operation\nrequired in Processor Expert, Microchip Code Configurator, or Atmel START.\n\nUnfortunately, some of the other peripherals \u2014 especially the timers \u2014 focus\nheavily on initialization code, and don\u2019t provide high-level APIs. For\nexample, with the PWM peripheral, you\u2019ll still need to directly modify timer\nregisters, which involves looking up the register names in the datasheet, and\nlearning about the values those registers can take.\n\nI would have preferred Code Configurator to generate PWM setDutyCycle()-type\nfunctions \u2014 more advanced users could directly modify the registers instead of\nrelying on those functions, which would then be optimized out of the final\ncode anyway.\n\n## Nuvoton NuTool PinConfig\n\nNuvoton provided a code configurator tool for their M0, but I mention it here\nonly to dissuade you from thinking it has absolutely any value at all, in case\nyou see an advertisement for it. Rather, it is full of bugs, only uses an\noutdated, buggy peripheral library, and cannot restore configurations\nproperly. Whoever wrote it on their lunch break needs to spend another day or\ntwo getting it working before they release version 2.0.\n\n## NXP MCUXpresso Config Tools\n\nSimilarly, NXP really dropped the ball on the MCUXpresso Config Tools program,\nwhich it uses in lieu of Processor Expert. This stand-alone program purports\nto do clock configuration and pin-muxing, but in practice, the only code it\ngenerates is clock gating code. It claims to generate MCUXpresso projects, but\nthen it informs you it cannot generate projects for MCUXpresso.\n\nYou can export a weird archive format that you can import back into\nMCUXpresso, but if you want to make any changes, you have to go through the\nwhole process again \u2014 recreating your project. It\u2019s terrible.\n\nI ended up forcing it to generate code in a \u201cgenerated\u201d folder inside an\nexisting MCUXpresso project. I set up the include paths to look in the new,\ngenerated tree structure, and was able to get it going \u2014 but this is not a\nprocedure for novices who may be unfamiliar with Eclipse C/C++ development.\n\nSTC-ISP is STC\u2019s do-everything programmer, parametric search engine, and code-\ngen tool. It may look a little silly, but it\u2019s both easy to use and very\nfunctional.\n\n## STCmicro STC-ISP\n\nSTC-ISP \u2014 STC\u2019s do-everything programmer utility \u2014 has some built-in code-\ngeneration capabilities. On the 8051, the three things people struggle with\nthe most is UART, timer, and delay functions, as these all require clock\ncalculations dependent on your particular set-up. STC-ISP generates precisely\nthree types of source code: UART initialization, timer initialization, and\ndelay functions. Oh, and it will output both C and ASM code, and it nicely\ncomments the values so you remember why they\u2019re in your source code in 6\nmonths when you go to look at it again.\n\nMicrochip Code Configurator provides a stellar pin-muxing perspective that\nother manufactures haven\u2019t quite duplicated.\n\n## Microchip Code Configurator\n\nMicrochip Code Configurator (MCC) works with some (but not nearly all) 8-bit,\n16-bit, and 32-bit PIC parts. This tool provides a nice pin manager view that\nshows you assignment possibilities for all peripherals. Each peripheral has an\nEasy Setup or a Registers view that lets you interact with the system at a\nlower level.\n\nThe tool generates a purpose-built, basic, compact runtime library that\u2019s a\ngreat place to get started with, but I\u2019d like to see the ability to generate\nISR stubs \u2014 especially for communication peripherals \u2014 instead of relying on\nout-of-ISR-context functions for handling data (which requires buffering data\nand other overheads).\n\nYou can disable automatic reception to prevent MCC from generating these ISRs\n(allowing you to write your own), but I couldn\u2019t find a way of being able to\ndefine my own ISR, but also have MCC generate code that automatically sets all\nthe interrupt-enable bits that need to be present for ISRs to execute. Again,\nthis results in an unnecessary trip to the datasheet.\n\nThe tool managed to generate extremely compact code \u2014 the best in the round-up\nof code configurator tool (though this is also just a product of the PIC16\narchitecture), and, like Atmel START\u2019s 8-bit code, read like something a human\nwould write.\n\nPSoC Creator is built around Cypress\u2019s code-gen tools, which provides a\nschematic capture interface for instantiating and connecting components; these\ntools generate the configuration bitstream along with an API for the\nperipherals.\n\n## PSoC Creator\n\nPSoC Creator is infamous for its deeply-integrated code configurator tool.\nBecause PSoC devices have peripherals whose registers are configured directly\nfrom a bitstream in flash memory, the PSoC Creator\u2019s tools are not optional.\n\nThis is an elaborate system that uses a schematic-capture interface to place\nindividual blocks \u2014 PWM modules, SPI devices, ADC pins, and \u2014 in higher-end\nPSoC devices \u2014 reconfigurable analog and digital blocks.\n\nEach block has a nicely laid-out properties window that allows you to\nconfigure nearly everything about the peripheral.\n\nThis system seems like it would be popular among people with an electronics \u2014\nnot programming \u2014 background. As much of a die-hard PCB layout guy as I am, I\nactually found the interface to be clunky and unproductive. You have to place\neverything on the schematic \u2014 even pins and clock sources. If you want to\ndefine an ISR, the \u201cPSoC way\u201d is to wire up an ISR component to an interrupt\nsignal on the schematic.\n\nI suppose you end up with nicely-documented PDF outputs explaining how the\ncomponents fit together, but again, the system seems clunky and heavy-handed.\nDo I really have to create and configure a clock component, simply to route it\ninto a timer? Can\u2019t the timer just have a clock divider interface built-in?\n\nIt\u2019s all a matter of personal preference.\n\nSTM32CubeMX is a lightweight, stand-alone code-gen tool that focuses on\nperipheral initialization, while pulling in the standard STM32 peripheral\nlibrary for runtime duties.\n\n## ST STM32CubeMX\n\nSTM32CubeMX (the worst name in my round-up) is a lightweight, stand-alone Java\napp that\u2019s oddly compelling to use. The tool supports initializing almost all\nperipherals of almost all STM32 devices \u2014 an impressive feat on its own. I\ncouldn\u2019t find a peripheral mode or feature that the tool didn\u2019t support \u2014 but\nit\u2019s important to understand the runtime code it generates uses the standard\nSTM32 peripheral libraries, which have bothered some people due to their size.\n\nAnd, truth be told, these were some of the fattest hex files I made \u2014 only\ntopped by Atmel START\u2019s D10 code, and Nuvoton\u2019s non-LTO\u2019d peripheral library.\n\nThe other problem is how basic some of the peripheral drivers are. But because\nthe tool is intelligent enough to ignore strategically-placed user code, it\u2019s\neasy to customize the generated code to suit your purposes.\n\nAs a plus, the tool can generate project formats that target all popular\ndevelopment ecosystems \u2014 and not just their official System Workbench for\nSTM32.\n\n# Compilers\n\nThere was a large contingent of hobbyists in the 1990s and 2000s who were\nlured by low-quality proprietary compilers that didn\u2019t work well, crashed\noften, and quickly disappeared from the market without a trace. Those have all\nbut vanished \u2014 these days, GCC builds code for several different MCU families,\nwhile the industry stand-bys \u2014 Keil, IAR, Cosmic, etc \u2014 continue to be popular\nchoices for 8-bit MCUs that lack C-friendliness (and thus, GCC support).\n\nThe biggest change in the last 10 years is the democratization of tools \u2014 even\nproprietary, expensive compilers tend to have generous code-size limitations\n(64 KB or more in some cases \u2014 plenty for a quick evaluation or hobbyist\nprojects).\n\nAnd some vendors \u2014 like Silicon Labs and ST \u2014 work with compiler vendors to\noffer full versions of these expensive tools free of charge to the customer.\n\nI conducted all my testing using nothing but freely-available versions of the\nvendor-recommended toolchains for their products. Throughout the months of\ntesting on 21 different parts, I didn\u2019t run into a single compiler bug \u2014 but I\ndid run into several peculiarities and optimization snafus.\n\n## GCC\n\nGCC is an open-source, cross-platform part of the GNU Project, and first\nreleased in 1987. Since then, developers have ported GCC to dozens of\narchitectures. In the microcontroller world, it can target the Arm, AVR,\nRL-78, and MSP-430 parts reviewed \u2014 as well as parts I wasn\u2019t able to get to,\nincluding Xtensa, RX, M16C, SH, NIOS2, and Microblaze.\n\nGCC can support MIPS processors, and there are several projects (e.g.) from\npeople trying to build code for the PIC32, but you\u2019ll get no help from\nMicrochip ((and a growing chorus is questioning whether they\u2019re in violation\nof GPL)).\n\nGCC excels at producing fast math code, supporting recent C standards, and \u2014\nwith link-time-optimization \u2014 producing compact code.\n\nArm, especially, has seen a mass migration to GCC \u2014 even Arm Holdings (who own\nMDK-ARM) take part in GCC\u2019s upkeep, and distribute binary releases of it on\ntheir site. I know several smaller shops that have stopped renewing their Keil\nMDK licenses, because GCC is as good \u2014 or better \u2014 than MDK.\n\nI haven\u2019t conducted thorough benchmarking myself, but in my biquad filtering\ntest with the Nuvoton Cortex-M0 part, the GCC implementation required 30 clock\ncycles, while the MDK version needed 42. Code size was also better for GCC\nthan MDK \u2014 2880 bytes versus 3004 bytes.\n\nThe Achilles\u2019 heel for GCC on MCUs is actually not GCC itself \u2014 but rather the\nC library \u2014 Newlib or Newlib-Nano \u2014 that is often linked to the program\nwhenever you need printf() or similar C routines.\n\nHere, Keil MDK, IAR, and other vendors can produce much smaller code size, as\nthey\u2019re using their own C libraries that are highly-optimized for the\narchitecture (and may not be 100% compatible with C99).\n\nThis compares with Newlib, the full GCC C library that\u2019s aimed at much larger\ndevices running full operating systems \u2014 or Newlib-Nano, which trims down, but\nis still much larger than proprietary MCU C libraries.\n\nI want to highlight NXP\u2019s MCUXpresso IDE, as they\u2019re the only vendor to\ndistribute a built-for-ARM C library, Redlib, with their IDE. Redlib is part\nof their Code Red acquisition. All other vendors copy-and-paste the same\nnewlib and newlib-nano options.\n\nRaisonance conducted a benchmark a few years ago that confirms everything I\u2019ve\nwritten on the strengths and weaknesses of GCC.((Full disclosure: Raisonance\nhas a stake in GCC, as they use it in their Ride7 proprietary IDE.))\n\nOne minor annoyance with GCC is that its backend considers SFR accesses as an\n\u201coptimization\u201d \u2014 so with the optimizer off, it uses fairly slow code for\naccessing peripherals. I\u2019ve verified this with both AVR and RL-78 targets.\n\nOn avr-gcc, compiling with -Og or higher will fix this issue, but this can\nintroduce debugging headaches (though -Og minimizes them).\n\nGCC\u2019s RL-78 port, however, seems crippled by this issue \u2014 no optimization\nflags I tried were ever able to generate correct SFR accesses; everything\nalways went through normal 16-bit space, issuing a strong performance penalty.\n\n## CC-RL\n\nWhile the RL-78 has rudimentary support for GCC, as I mentioned above, I was\nnever able to coax it into generating good register I/O. CC-RL, the\nproprietary RL78 compiler from Renesas, has no issues with this.\n\nBut CC-RL doesn\u2019t inline non-native math functions \u2014 instead, it calls into\nruntime libraries, which introduces extra overhead.\n\nThe free mode supports 64 K linking.\n\n## Keil C51\n\nThe 8051 harkens from a time where developers programmed microcomputers (and\nmicrocontrollers) in assembly, not C. Its fancy control-friendly features like\nsmall sets of banked registers (which can interchange in an interrupt context)\ndon\u2019t play well with compilers.\n\nWorst still, the 8051 suffers from a small, 8-bit stack that struggles to keep\nup with traditional stack-based C implementations.\n\nEarly C compilers for the 8051 often started as 68K or x86 compilers hacked\nwith an emulated software stack stored in XRAM. This produced code that\ndawdled through tasks at a snail\u2019s pace.\n\nPL/M-51((PL/M-51 wasn\u2019t a C compiler \u2014 it actually compiled code written PL/M,\na proprietary Intel high-level language. Man, the 80s were weird.)) was an\nIntel compiler introduced in 1980 that got around this problem by passing\nvariables in defined RAM locations.\n\nKeil took this idea and ran with it. They introduced C51 in 1988 \u2014 and it\nflourished in popularity.\n\nOne of the problems with Keil is its trigger-happy use of nonstandard reserved\nwords. But this what you would expect: when you\u2019re building a C compiler for\nthe 8051, you have to have the ability to declare variables in XRAM versus RAM\n\u2014 or be able to instruct the compiler to make a function reentrant if\nnecessary. You don\u2019t have the luxury of a stack-friendly microcontroller which\ntreats all RAM equal.\n\nWhile that\u2019s unavoidable, the way Keil implemented these special attributes is\nnot. Keil obnoxiously sets aside: alien, bdata, bit, code, compact, data, far,\nidata, interrupt, large, pdata, reentrant, sbit, sfr, sfr16, small, using, and\nxdata.\n\nBecause, as we all know, no developer ever declares variables named things\nlike \u201cdata,\u201d so that should work out fine.\n\nThis is a serious problem when porting large stacks built for other compilers,\nlike GCC. ((Yes, I know you can disable these extensions with the NOEXTEND\ncompiler directive... but obviously then you can\u2019t use these directives.))\n\nI would have preferred GCC-style __attribute__((xdata)) or at least __xdata.\n\nA bigger problem with C51 is that, like CC-RL, it calls into pre-built math\nlibraries whenever it needs to perform a non-native operation (such as a\n16-bit multiply), instead of inlining the appropriate set of operations, as\nGCC does. No optimization setting will fix this behavior, and because function\ncalls are expensive on the 8051, this has dramatic performance implications.\n\n## Microchip XC\n\nMicrochip produces microcontrollers of three basic designs: an 8-bit, a\n16-bit, and a 32-bit. The XC8, XC16, and XC32 are the current compilers in\ntheir collection that target each of these, respective. These are quite\ndifferent processors and, under the hood, these are quite different compilers.\n\nThe 8-bit processors, in particular, have gone through slow, incremental\nchanges over the years: from 12-bit, to 14-bit, to 16-bit program word sizes,\nwith each bump adding more address space, new instructions, and a bit more\nstack space.\n\nWith each improvement, these PIC devices became easier to write compilers for.\nThe PIC18 was the first core for which Microchip supported C programming \u2014\nthough Hi-Tech had already developed a Keil C51-like compiler for the lower-\nend devices that lacked a proper stack.\n\nEventually, Microchip acquired Hi-Tech, and combined these two disparate\nproducts into XC8, which covers all 8-bit PIC devices.\n\nNone of the 8-bit PIC parts have a usable stack to store variables. To handle\nthis shortcoming, XC8 can create a software stack on PIC18 devices, which have\nenough indirect addressing operators to support this.\n\nNot so on PIC10/12/16 devices. Like Keil C51, XC8 will reuse certain RAM\naddresses to hold local auto variables and function parameters. This works\nwell, and is often more efficient than a stack-based approach simpler\ncompilers can use on more advanced hardware. As mentioned with Keil C51 above,\nthe big problem is reentrancy \u2014 when a function attempts to call itself (i.e.,\nrecursion), or when an ISR calls the same function it happened to interrupt.\nHere, these auto variables \u2014 which should be unique to the function\u2019s\nexecution \u2014 will be at the same address, thus causing possible corruption.\n\nXC8 beats out Keil C51 by tacitly duplicating any function that ISRs call\ninto, eliminating the ISR reentrancy problem. Unfortunately, unlike Keil, XC8\nhas no way of forcing the compiler to generate reentrant-capable code on these\nmidrange devices.\n\nThey support optimization through the \u201cOmniscient Code Generation\u201d optimizer.\nAccording to the documentation, for well-written code, the main advantage to\nOCG is bank-tracking. Because the PIC devices use banked memory pages (for\nboth RAM and SFRs), most source code liters bank-select statements everywhere.\n\nMost of the other optimizations \u2014 removal of dead code, unused variables,\nunreachable code, unused return expressions, and redundant assignments \u2014 seem\nonly relevant to poorly-maintained code.\n\nXC16 and XC32 use GCC. Microchip doesn\u2019t advertise the source code, but it\u2019s\navailable from their Archives page.\n\nNuvoton provides an entire transcript of the reference manual attached to each\nsymbol in their header file, which is a huge step above other header-based\ndocumentation.\n\n# Header Files\n\nI didn\u2019t realize how important good header files were until I started working\nwith some of these parts that simply have horrendous headers.\n\nSince MCUs rely on setting, clearing, toggling, and inspecting bits in\nregisters, it\u2019s convenient for the compiler and header files to provide\nmethods for setting and clearing individual bits (and preferably bit ranges)\ninside registers \u2014 even if the architecture doesn\u2019t support atomic bit\ninstructions.\n\n#### Bit-Addressable Register Access\n\nAll Microchip PIC parts, Atmel SAM D10, and the RL-78 all support bit-\naddressable register access. The SAM D10, in particular, is the only Arm part\nI\u2019ve ever seen this feature in \u2014 and it\u2019s fantastically useful \u2014 even if their\nnotation is a bit heavy-handed. I\u2019d love to see them go through and #define\nflat symbols to point to those structs, so instead of:\n\n    \n    \n    TCC0->CTRLA.bit.ENABLE = true;\n\nI could write\n\n    \n    \n    TCC0_CTRLA_ENABLE = true;\n\nBut at this point, I\u2019m just nit-picking.\n\nWhile Renesas provides bit-addressable register definitions, there are\nabsolutely zero docs in the header files. Same goes for Microchip PIC \u2014\nthere\u2019s next to no documentation in the header files for the PIC16, PIC24, and\nPIC32.\n\nIt\u2019s 2017 \u2014 storage is basically free. Header files should come chock-full of\ndocumentation, so you can keep your focus on your code \u2014 instead of having to\njump around inside PDFs.\n\n#### Header Documentation\n\nBy far, the best-documented header files were from the Nuvoton M051.\nEssentially they copy-and-pasted the entire reference manual into their header\nfiles. You get every register name and description, with every bit described\nin the same detail as in the official documentation. This is absolutely\nincredible, and really sets the standard in the industry.\n\nRenesas, while not having RL-78 header documentation, does have a bizarre pop-\nup PDF viewer thing that displays the relevant reference manual section when\nyou hover-over a variable. I kind of like it, but it\u2019s pretty heavy, and I\nthink if I used the architecture more, I\u2019d prefer the Nuvoton approach.\n\nOther than that, Infineon, ST, NXP, and Texas Instruments provided good\ndocumentation in their header files \u2014 though I have to fault Eclipse for not\ndisplaying this more prominently in tooltips. Often, I had to click-through to\nthe device header file to read the register description. Atmel Studio handled\ndoc display much better.\n\nSilicon Labs also provided excellent documentation, and along with the other\n8051s, had all bit-addressable registers defined clearly. But because of the\n8051 architecture, not all registers are bit-addressable \u2014 in fact, most\naren\u2019t.\n\nI wish Keil C51 could be coaxed into generating ORL and ANDL bitwise\ninstructions from some sort of proprietary bit definition structure that would\nallow *all* bits to be manipulated independently in the same way.\n\nEven more puzzling is why there are no bitfield register definitions for the\ntinyAVR or megaAVR, even though the architecture clearly supports bit\nmanipulation. Surely there could be a proprietary AVR-GCC attribute that\nallowed Atmel to build header files that the compiler could use to generate\nsbit and clrbit instructions, right?\n\n#### Predefined Offset Bitmasks\n\nA (slightly inferior) alternative to bit-level register access is predefined\noffset macros. This is the route Silicon Labs, Texas Instruments, Infineon,\nNXP, and Microchip go (though again, the first three provide much better\ndocumentation). Atmel also provides this \u2014 but only for their tinyAVR.\n\n#### The Worst Headers\n\nThe worst header files were from the megaAVR, the PSoC 4000S, the Kinetis\nKE04, the HT-66, the Sanyo LC-87. These header files have zero documentation,\nno predefined bit offsets, and no bit-addressable register definitions. Their\nheader files are little more than register names attached to addresses.\n\nFrom left, the STM32, PSoC 4000S, Microchip SAM D10, Silicon Labs EFM8, and\nNXP Kinetis KL03 development boards.\n\n# Development Tools\n\nDevelopment tools have been shrinking and simplifying over the last few years;\nno longer should you plan on spending hundreds of dollars on a giant beast\nthat combines every peripheral imaginable into a horrible mess of poorly-\ndocumented schematics.\n\nFor general-purpose projects that these MCUs are geared toward, I still often\nbreadboard a first iteration of the system (usually with break-out boards for\nthe MCU, plus modules for the peripherals). If I\u2019m working with a big\nmicrocontroller that has a lot of support circuitry, I\u2019ll typically use an\noff-the-shelf dev board. For smaller parts, I\u2019ll toss them on a breakout\nboard.\n\n#### Breakout-Friendly Dev Boards\n\nIn terms of overall form factor, I\u2019ll allow my personal preferences to gush\nout: I love dev boards that integrate a debugger and a microcontroller, with\nnothing more than break-out pins. I think a dev board should have a row of\njumpers that allow you to completely disconnect the target from the debugger.\n\nRegardless of what marketing departments think, dev boards should be free of\nextraneous sensors, buttons, LEDs, or anything else that a user can easily\nbreadboard. I\u2019m OK with capacitive-touch sliders, as long as there isn\u2019t a lot\nof junk (passives) hanging off the lines.\n\nConsequently, I really enjoyed the MSP430 (and all Texas Instruments)\nLaunchPad boards. The integrated power measurement functionality is wonderful,\nand I love the no-frills jumper arrangement used to disconnect the target from\nthe on-board debugger.\n\nI didn\u2019t get a chance to play with the Microchip Curiosity boards, but these\nlook appealing as well.\n\n#### Snap-Apart\n\nThe snap-apart dev boards were also fun to play with \u2014 the Nuvoton N76 and\nM051 boards, the STM32Discovery, and the Infineon XMC1100 board. Having said\nthat, you think they\u2019re going to be great until you try to put them back\ntogether again. I spent several minutes in front of my bench grinder cleaning\nup all the snap-apart boards so they could accept standard 0.1\u201d headers and\njumpers.\n\n#### Arduino UNO Form-Factor\n\nOne pet peeve of mine is the insistence on building Arduino Uno form-factor\ndev boards.\n\nI\u2019m totally cool with vendors building UNO-compatible boards that support\nWiring programming. This is a great way to get beginners interested in moving\nbeyond Arduino. Nuvoton does a good job of this with the M0 series. Their\nNuMaker Uno board uses a 5V-compatible Arm Cortex-M0 part, and they provide a\nboard support package for the Arduino IDE.\n\nBut a lot of vendors build boards that are cosmetically similar to Arduino UNO\ndev boards, but have none of the software support necessary to use them with\nArduino libraries or the Wiring environment in general.\n\nWhile many vendors are guilty of this, I have to chastise NXP specifically for\nthis.\n\nNXP used to build fantastic little dev boards \u2013 the LPCXpresso \u201cstick\u201d boards\n\u2014 that were the first in the industry to have snap-off (well, cut-off)\ndebuggers. They broke out all the pins of the MCU onto sensible 0.1\u201d headers,\nmaking breadboard prototyping easy. These boards were great.\n\nUnfortunately, they\u2019ve discontinued them and switched to their new LPCXpresso\nMAX boards. These new boards cram their processors \u2014 which are very unlike the\nATMega328p \u2014 into an Arduino Uno form-factor.\n\nThis is especially stupid for parts like the LPC81x series, which only have 11\nGPIO pins (excluding SWD and crystal) and don\u2019t even have an ADC.\n\nSo what does NXP do to fit their square peg into a round hole? They throw in\nrandom I^2C GPIO and ADC peripherals to pad the LPC\u2019s I/O count (and endow it\nwith an ADC it doesn\u2019t inherently have) \u2014 and then provide zero software on\ntheir downloads page for actually interacting with these peripherals.\n\nAnd in targeting this form factor, NXP hilariously misses the point. Do they\nprovide Wiring support for these boards to be used inside Arduino? Nope. Do\nthey provide libraries for all the Arduino shields that are supported by their\nMAX boards? Nope. Do they even have a list of which shields are compatible,\nand which ones are incompatible with various boards? No way.\n\nSo, they\u2019ve saved me 30 seconds by allowing me to plug a shield directly into\nthis board (without having to use jumper wires), but haven\u2019t done any of the\nactual work for me.\n\nAt the same time, their debugger is no longer separable from their target,\nthere\u2019s a boat-load of random crap on the board that must be removed for\naccurate power consumption figures, and the pins no longer line up with\nstandard 0.1\u201d breadboards.\n\nAnd even if it were properly executed, I think I reject the underlying goal of\nthis strategy. The whole purpose of using an Arduino UNO form-factor is to\nsupport Arduino shields \u2014 yet I have never seen an Arduino shield on the desk\nof a professional engineer or advanced hobbyist. At least, not one plugged\ninto one of these \u201cUno form-factor\u201d dev boards.\n\n#### Dev Board Surgery\n\nFor the low-power part of this project, I had to do some minor surgery to the\nSTC8, Nuvoton, and the three Atmel Xplained Mini boards covering the tinyAVR,\nmegaAVR, and SAMD10. This mostly involved removing LEDs or separating a power\ntrace. The schematics were clearly documented, and I consider these changes to\nbe completely routine \u2014 just the price of admission of trying to do low-power\ndevelopment.\n\nWhile the Cypress PSoC 4000S dev board looks uncomplicated, I struggled to get\naccurate power consumption without several hacks that weren\u2019t clearly\ndocumented.\n\nThe Infineon board\u2019s power subsystem was slightly confusing, as there\u2019s no\npower going between the debugger and the rest of the board once you snap the\ntwo apart. Once I figured that out, I had no further issues, and I like that\nthey took the time to put headers on the board in a way that allows the two\nparts to be re-joined together.\n\nI hate to say this because I was a huge fan when they first came out, but I\u2019ve\ngrown to fundamentally hate the Freescale (now NXP) FRDM dev boards. To even\nget my project to work, I had to do major reworking on the Kinetis KL03 FRDM\nboard, which contained random filtering capacitors on UART RX pins. These\nweren\u2019t mentioned in the documentation and were only traceable by studying six\npages of schematics that came with the board.\n\nTrying to get accurate low-power measurements was a further struggle on the\nFRDM board, which is full of button pull-ups, LEDs, I2C sensors, and no good\npower separation capabilities. This dev board is a total disaster \u2014 I wouldn\u2019t\nrecommend it to my worst enemy. NXP needs to take a step back, simplify the\nboard to its essence, and try again.\n\nI also had to do major hacking of the Renesas RL-78 promotional board, but\nthis was because I was trying to be a cheap-skate and convert the kit to a\ngeneral-purpose RL-78 programmer (since I needed to target a completely\ndifferent microcontroller) \u2014 I can\u2019t fault Renesas for that, but I do wish\ntheir boards had debugger jumpers that would have kept me away from the\nsoldering iron.\n\n#### On-Board Debugging & Other Features\n\nAll dev boards tested have built-in on-board debuggers, but they varied widely\nin capabilities.\n\nIn terms of functionality, the best dev board in the round-up is the Silicon\nLabs SLSTK boards have a full, USB 2.0 high-speed J-Link On-Board debugger\nthat has been augmented with a high-dynamic-range energy monitor, which is an\namazing deal considering the cost of the dev boards ($30). While I only\nreviewed the EFM8 series in this review, the EFM32 ARM processors they make\nhave nearly identical development boards.\n\nThe MSP430 LaunchPad also has an energy monitor, which is still a rare feature\nto find in this pricing.\n\nWhile other manufacturers have J-Link OB debuggers, they\u2019re usually USB 2.0\nfull speed, not high speed. This is the case with the Freescale KL03 and\nInfineon XMC1100 boards.\n\nCypress and Microchip\u2019s SAM D10 went with CMSIS-DAP debuggers on their boards,\nwhile the Nuvoton used their proprietary NuLink for both their Arm and 8051\ncontrollers.\n\nBoth Freescale and ST enable reprogramming the debugger firmware on their dev\nkits with SEGGER J-Link firmware. I don\u2019t think anyone in the industry\ndisagrees that J-Link is, by far, the best Arm debugger \u2014 and even operating\nat USB 2.0 full-speed specs (12 Mbps), flash download is snappy, and stepping\nthrough code is a breeze.\n\n## Debug Adapters\n\nWhile you can hack all current development boards to provide off-board\ndebugging, at best this is clunky, and at worst it can be a violation of the\nEULA for the dev board. Serious hobbyists and professionals usually have\ndedicated debug adapters laying around that can easily plug into different\ntargets they\u2019re designing.\n\nIn the Microchip camp, your choices are the PicKit3 ($48), ICD4 ($249), and\nRealICE ($499) \u2014 all of these debug adapters will work with all current\nMicrochip PIC parts, but the PicKit3 is substantially slower than the ICD4,\nand only supports two breakpoints.\n\nThe Microchip (n\u00e9e Atmel) AVR and SAM parts are a different story: the $130\nAtmel-ICE is your only option, assuming you want a debugger that can target\nall current Atmel parts. If you\u2019re only interested in debugging older parts,\nlike the megaAVR and non-1-Series tinyAVR parts, you can get by with a $49 AVR\nDragon.\n\nThe Silicon Labs EFM8 ecosystem has some of the fastest debug times, as well\nas some of the lowest-cost debugger hardware. Price descending, your options\ninclude the SEGGER J-Link debugger ($60-1000), the USB Debug Adapter ($35),\nthe ToolStick Base Adapter ($19), semi-sanctioned eBay clone adapters ($10),\nor the bare debugger chip you can use in your own design ($1.78).\n\nIn the Arm ecosystem, just shut up and buy a J-Link. Seriously. It works in\nevery Arm IDE, with every Arm part on the market. It has the fastest debug\nspeeds, supports any target voltage, and has unlimited software breakpoints.\nIf you\u2019re a student, you can get a J-Link EDU Mini for $18 (cheaper than\nclones), or the full EDU version for $60. If you\u2019re a professional, buy the\n$600 commercial version \u2014 it\u2019s worth the handful of billable hours you\u2019ll have\nto charge to pay for it.\n\nDebug adapters varied widely in speed \u2014 with the PIC16, PIC32MM, and SAM D10\ntaking the longest to program flash memory \u2014 the latter two took 20 seconds to\nprogram their entire flash, which is entirely too long.\n\nThese parts also had the most inconsistent speeds \u2014 sometimes if I restarted\nmy computer, they would be significantly slower or faster. I didn\u2019t spend time\nfully characterizing their ineptitude, though, so your mileage may vary.\n\nThe fastest IDE flash load times came from the Infineon XMC1100, running the\nJ-Link firmware, which could fill its entire 8 KB of flash and run to main()\nin 2.47 seconds. That\u2019s impressive, coming from an Eclipse-based IDE not known\nfor its debugging kick-off abilities.\n\nActually, the Sanyo LC87 beat it out at 1.87 seconds, but this is using their\nspecial RD87 application, which requires jumping away from their IDE to use\n(and has a ton of manual steps involved in loading the flash file), thus I\u2019d\ntake this result with a grain of salt.\n\nOther than that, the EFM8, STM8, and STC8 all had sub-5-second debug speeds\nwhen loading average-sized programs, and none took more than 6.2 seconds to\nfill their flash memory.\n\nPerformance\n\n# Bit Toggling\n\nAtmel tinyAVR 4 Cycles\n\nAtmel megaAVR 3 Cycles\n\nAtmel SAM D10 3 Cycles\n\nCypress PSoC 4000S 11 Cycles\n\nFreescale KE04 3 Cycles\n\nFreescale KL03 4 Cycles\n\nHoltek HT66 16 Cycles\n\nInfineon XMC1100 9 Cycles\n\nMicrochip PIC16 20 Cycles\n\nMicrochip PIC24 10 Cycles\n\nMicrochip PIC32MM 3 Cycles\n\nNuvoton N76 7 Cycles\n\nNuvoton M051 8 Cycles\n\nNXP LPC811 4 Cycles\n\nRenesas RL78 5 Cycles\n\nSanyo LC87 18 Cycles\n\nSilicon Labs EFM8 8 Cycles\n\nST STM8 4 Cycles\n\nST STM32F0 9 Cycles\n\nSTC STC8 4 Cycles\n\nTI MSP430FR 7 Cycles\n\nSome Cortex-M0+, megaAVR, and PIC32MM were able to hit 3 cycles with the help\nof single-cycle GPIO toggling and two-cycle jump instructions.\n\nCortex-M0 parts can theoretically hit 5 cycles (which the XMC1100 did when\nrunning from RAM), but many of the Arm microcontrollers tested need much more\n\u2014 as much as 11 \u2014 due to flash caching strategies or the lack of GPIO toggle\nregisters.\n\nFlash reading also plagued the EFM8 Laser Bee, which takes 8 cycles to\nunconditionally jump when operating at 72 MHz (though, oddly, its 8-cycle\ntoggling performance is better than the 10 cycles it should take, if one\ntrusts the datasheet). The N76 turned in poor results caused by poor bit math\nperformance, while the STC8\u2018s 4-cycle toggle was right up there with the best.\n\nThe tinyAVR is a bit slower than the megaAVR due to its 16-bit peripheral\naddress space, but there are special provisions for remapping specific GPIO\nports into the 64-byte address space, which will give it identical performance\n(at the expense of only being able to access a single GPIO port from this\nmode).\n\nAt the bottom of the pack are the 4T and 3T architectures \u2014 the Holtek HT66,\nthe Microchip PIC16, and the Sanyo LC87, These 8-bit architectures must\nessentially load the working register with the toggle bit, XOR it into the\nport latches, and then jump back to the top. I\u2019m not sure why the working\nregister has to be reloaded each time (does the result of the XOR operation\nend up back in the working register before being written to the latch\noutputs?), and I\u2019m planning on investigating some strange bank-select code\nthat XC8 injects in the PIC16 loop.\n\nSpeaking of weird Microchip compiler issues, XC16 \u2014 even with the\noptimizations cranked all the way up \u2014 generates 5-machine-cycle bit-wiggling\ncode for the Microchip PIC24, instead of a \u201cbtg\u201d followed by a jump (which\nshould be three machine cycles \u2014 6 clock cycles \u2014 total).\n\n# Biquad Filtering\n\n  * Filtering Speed\n  * Clock Cycles\n  * Power Consumption\n  * Efficiency\n\n#### Filtering Speed\n\nAtmel tinyAVR 159.80 ksps\n\nAtmel megaAVR 123.27 ksps\n\nAtmel SAM D10 1822.32 ksps\n\nCypress PSoC 4000S 885.69 ksps\n\nFreescale KE04 1715.36 ksps\n\nFreescale KL03 1645.24 ksps\n\nHoltek HT66 2.71 ksps\n\nInfineon XMC1100 805.84 ksps\n\nMicrochip PIC16 21.83 ksps\n\nMicrochip PIC24 838.46 ksps\n\nMicrochip PIC32MM 829.88 ksps\n\nNuvoton N76 38.79 ksps\n\nNuvoton M051 1732.07 ksps\n\nNXP LPC811 731.93 ksps\n\nRenesas RL78 731.68 ksps\n\nSanyo LC87 23.55 ksps\n\nSilicon Labs EFM8 202.40 ksps\n\nST STM8 79.49 ksps\n\nST STM32F0 1647.79 ksps\n\nSTC STC8 156.56 ksps\n\nTI MSP430FR 129.95 ksps\n\n#### Clock Cycles\n\nAtmel tinyAVR 63 Cycles\n\nAtmel megaAVR 65 Cycles\n\nAtmel SAM D10 27 Cycles\n\nCypress PSoC 4000S 27 Cycles\n\nFreescale KE04 28 Cycles\n\nFreescale KL03 29 Cycles\n\nHoltek HT66 1333 Cycles\n\nInfineon XMC1100 40 Cycles\n\nMicrochip PIC16 1466 Cycles\n\nMicrochip PIC24 38 Cycles\n\nMicrochip PIC32MM 30 Cycles\n\nNuvoton N76 412 Cycles\n\nNuvoton M051 29 Cycles\n\nNXP LPC811 41 Cycles\n\nRenesas RL78 33 Cycles\n\nSanyo LC87 510 Cycles\n\nSilicon Labs EFM8 272 Cycles\n\nST STM8 201 Cycles\n\nST STM32F0 29 Cycles\n\nSTC STC8 153 Cycles\n\nTI MSP430FR 123 Cycles\n\n#### Power Consumption\n\nAtmel tinyAVR 3.34 mA\n\nAtmel megaAVR 3.11 mA\n\nAtmel SAM D10 5.09 mA\n\nCypress PSoC 4000S 3.66 mA\n\nFreescale KE04 14.31 mA\n\nFreescale KL03 5.21 mA\n\nHoltek HT66 1.89 mA\n\nInfineon XMC1100 4.24 mA\n\nMicrochip PIC16 3.61 mA\n\nMicrochip PIC24 10.74 mA\n\nMicrochip PIC32MM 7.65 mA\n\nNuvoton N76 3.64 mA\n\nNuvoton M051 19.16 mA\n\nNXP LPC811 4.43 mA\n\nRenesas RL78 3.79 mA\n\nSanyo LC87 6.51 mA\n\nSilicon Labs EFM8 14.15 mA\n\nST STM8 6.45 mA\n\nST STM32F0 12.15 mA\n\nSTC STC8 11.87 mA\n\nTI MSP430FR 2.41 mA\n\n#### Efficiency\n\nAtmel tinyAVR 69.01 nJ/Sample\n\nAtmel megaAVR 83.26 nJ/Sample\n\nAtmel SAM D10 9.22 nJ/Sample\n\nCypress PSoC 4000S 13.64 nJ/Sample\n\nFreescale KE04 27.53 nJ/Sample\n\nFreescale KL03 10.45 nJ/Sample\n\nHoltek HT66 2304.95 nJ/Sample\n\nInfineon XMC1100 17.36 nJ/Sample\n\nMicrochip PIC16 545.76 nJ/Sample\n\nMicrochip PIC24 42.27 nJ/Sample\n\nMicrochip PIC32MM 30.42 nJ/Sample\n\nNuvoton N76 309.68 nJ/Sample\n\nNuvoton M051 36.50 nJ/Sample\n\nNXP LPC811 20.00 nJ/Sample\n\nRenesas RL78 17.09 nJ/Sample\n\nSanyo LC87 912.36 nJ/Sample\n\nSilicon Labs EFM8 176.20 nJ/Sample\n\nST STM8 267.76 nJ/Sample\n\nST STM32F0 24.33 nJ/Sample\n\nSTC STC8 192.24 nJ/Sample\n\nTI MSP430FR 61.20 nJ/Sample\n\nI\u2019m going to discuss the 8-bit and 16/32-bit results separately, as there are\nnearly three orders of magnitude of variation among all the parts \u2014 with a\nclear demarcation between the 8-bit and 16/32-bit parts.\n\n## 16/32-bit Processors\n\nExcept for the MSP430 \u2014 which doesn\u2019t have a hardware multiplier in the part I\ntested \u2014 all the 16- and 32-bit microcontrollers had similar results in terms\nof clock-cycle efficiency.\n\nThe Arm parts were the fastest in the round-up. I think the Atmel D10\u2018s PLL\nwas running a bit hotter than 48 MHz, which allowed it to edge out over the\nother 48 MHz ARM parts.\n\nLooking at clock efficiency, I suspect the variation we see between parts is\nprimarily the result of flash caching. Parts that have good flash caching can\nget near 27 clock cycles per filtering loop.\n\nThe PSoC doesn\u2019t need a flash accelerator since it can only run at 24 MHz \u2014\nthus, it can access flash at full speed with no wait-states, and can\nconsequently hit 27 cycles.\n\nThe Infineon XMC1100, on the other hand, only seems to be able to read flash\nwith no wait-states when operating at 8 MHz or below. It has no flash\naccelerator either, which deeply penalizes its scores. However, when the part\nruns code from RAM instead of flash, it hits 27 cycles (at very low power\nfigures, too). I discuss this more in the XMC1100 article.\n\nThe MIPS-based 32-bit Microchip PIC32 holds its own \u2014 just three cycles shy of\nthe Cortex-M0+ results. Like the PSoC 4000S, this part runs slow enough to not\nneed a flash accelerator. Before committing to higher-speed PIC32MX devices,\nI\u2019d have to investigate the flash caching.\n\nI was blown away by the performance of the 16-bit Renesas RL-78, which only\nhas 8-bit data pathways. It was only 6 cycles away from the hot-rod Cortex-M0+\nparts, and pulled 7 cycles faster than the PIC24, which is a true 16-bit\ndesign. I only wish it had a faster core speed.\n\n## 8-Bit Processors\n\nCompared to the 16/32-bit results, the 8-bit processors can be described as\neither \u201cmediocre\u201d or \u201cabsolutely awful.\u201d\n\nThe Microchip PIC16 and Holtek HT-66 \u2014 with similar single-register 4T\narchitectures \u2014 arrive at the party dead-last in terms of clock cycle count.\nThese parts simply aren\u2019t built to be doing much math at all; let along 16-bit\nmultiplies and accumulates.\n\nBecause slow microcontrollers take a long time to process data, they\u2019re often\noverwhelmed by static power consumption, and this test verifies this. The\nHT66, LC87, and PIC16 both required more than 500 nJ/sample to process the\ndata \u2014 so much that I ended up clipping the data in the graph to help better\nshow the variation of the more-efficient parts (without resorting to\nlogarithmic plots).\n\nAt the other end of the spectrum lies the tinyAVR and megaAVR processors,\nwhich both brought in excellent clock-cycle counts.\n\nBy the way, it\u2019s important to note that neither of these AVR parts are running\nat full speed in this test. The tinyAVR has an internal 20 MHz oscillator that\nhas to be scaled down to 10 MHz so I can run the part at 3.3V without\nviolating the ratings in the datasheet. The megaAVR only has an 8 MHz internal\noscillator, so that\u2019s what I have to run it on.\n\nBoth these parts are capable of 20 MHz operation, so it\u2019s a little silly to\nhave to down-clock them because Atmel doesn\u2019t build these parts on a modern\nprocess allowing 1.8-3.6V operation at full speed, like most other parts\ntested. Every other part tested has a full-speed, better-than-2% oscillator;\nthe megaAVR is stuck with an atrociously inaccurate 8 MHz job that severely\nlimits the performance you can get out of this part. It\u2019s 2017 \u2014 crystals on\nMCUs should only be necessary for RTCs and RF.\n\nAnyway, back to the data: this should settle the PIC vs AVR debate about\nperformance. Yes, the AVR typically has a lower clock speed, but unless you\ncan run a PIC16 at 176 MHz, an 8 MHz AVR is going to win the math performance\ntests handily.\n\nThe Sanyo LC87 and STM8 are both better than the HT66 and the PIC16, but both\nhave slow core speeds that limit their performance.\n\n## Battle of the 8051s\n\nOne of the most interesting narrative that came out of this test was the\nwildly different performance numbers the 8051s produced.\n\nFirst thing\u2019s first: Keil C51 struggled to generate good code in the biquad\nexperiment \u2014 the biggest problem being the 16-bit multiplication. Rather than\nproducing raw assembly that operates on whichever registers end up with these\nvariables, Keil generates function calls into a signed-16-bit multiply library\nroutine. This has drastic performance implications when compared to the much-\nbetter AVR-GCC code.\n\nWith that said, the three different 8051s running identical binary images\nproduced very different results \u2014 caused by both clock-cycle efficiency and\ncore speed. Let\u2019s dig in a bit:\n\n  * STC8\n  * EFM8\n  * STC15W\n  * Nuvoton N76\n\nI\u2019ve plotted a cycle-count cumulative distribution above \u2014 I\u2019ve included the\nSTC15, an older part closely related to the STC8 (and mentioned extensively in\nthe STC8 review). The STC8 manages to execute 82% of its instruction set in a\nsingle cycle, and 96% of its instructions in three or fewer cycles. The other\nparts \u2014 the EFM8, older STC15W, and N76 \u2014 have much fewer single-cycle\ninstructions. The EFM8 starts to catch up to the STC8, while the N76 remains\nmuch further behind.\n\nMultiplies are two-cycle instructions on the STC8 and STC15 \u2014 twice as fast as\nthe EFM8 and N76.((The N76 and STC15 have poor performance at bit arithmetic\n(4 and 3 cycles, respectively) compared to the single-cycle EFM8 and STC8, but\nthis shouldn\u2019t affect the results of this experiment.))\n\nThe big advantage the STC8 has, though, is memory operations. STCmicro gave\nthis part a large, parallel-fetch interface that allows it to read three or\nmore bytes out of flash in a single cycle. That allows it to perform long op-\ncode instructions \u2014 like \u201cload immediate value into RAM location\u201d \u2014 in a\nsingle cycle. This is a three-byte instruction which takes three cycles on the\nN76 and EFM8. While these architectures are pipelined, they still have a\nsingle-byte fetch, which means the length of the instruction is the main\nfactor dictating how many cycles it will take to execute.\n\nWhen pitted against the 8-bit darling of the RISC movement \u2014 the AVR \u2014 things\nget interesting.\n\nOn the AVR, there simply is no instruction to do anything with RAM other than\nmove it from/to registers \u2014 so to \u201cload immediate value into RAM location\u201d you\nmust first load an immediate value into a register (1 cycle), and then load\nthe register into RAM (2 cycles). This is a three-cycle operation in total.\n\nThis may look like there\u2019s no performance difference between the AVR and the\n8051, but there\u2019s a major hiccup for the 8051: there are only 128 bytes of\ntrue RAM in the 8051 \u2014 not enough to hold the 64-word 16-bit data arrays in\nthis experiment.\n\nOn the 8051, to access 16-bit extended memory (XRAM), you have to load the RAM\naddress in the DPTR, load the direct value into the accumulator, and then move\nthe accumulator to @DPTR. On the slowest 8051 \u2014 the N76 \u2014 those operations\ntake 3, 2, and 6 cycles, respectively \u2014 10 cycles total. On the EFM8, those\noperations take 3, 2, and 3 cycles \u2014 8 cycles total.\n\nCompare that to the two-instruction, three-cycle AVR routine, which can\nactually store the immediate value to any RAM address \u2014 all 65,535 of them.\n\nThe STC8 comes closest to the AVR: it can perform these XRAM operations in 4\ncycles total.\n\nWhile this is still a penalty to pay when compared to AVR, consider that\nalmost all RAM move instructions \u2014 and RAM arithmetic instructions \u2014 are\nsingle-cycle on the STC8. Since STC8 RAM is no slower than access to the 8\navailable registers the 8051 has, you get essentially 128 extra registers for\nfree.\n\nWhile the lousy Keil C51 code prevents you from comparing across AVR and 8051\nparts in this experiment, note that the STC8 only needs 153 clock cycles \u2014\ncompared to the 272 and 413 of the EFM8 and N76.\n\nSure, the EFM8 wins the overall prize in the 8-bit segment in this test. But\nit chugs to the finish line relying exclusively on its 72 MHz clock, which is\nrunning 9 times faster than the megaAVR\u2018s 8 MHz oscillator, while only\nperforming about twice as fast as it is.\n\nAnd the EFM8 uses so much power that the standard adage \u2014 run as fast as\npossible to minimize static power \u2014 goes out the window. The slower megaAVR\nand tinyAVR both use less power than the EFM8 and STC8.\n\n# DMX-512 Receiver\n\n  * Power\n  * ISR Latency\n  * ISR Cycles\n  * ISR Total\n  * Flash\n  * Flash (%)\n\n#### Power\n\nAtmel tinyAVR 1430 microamps\n\nAtmel megaAVR 1270 microamps\n\nAtmel SAM D10 3410 microamps\n\nCypress PSoC 4000S 1030 microamps\n\nFreescale KE04 3340 microamps\n\nFreescale KL03 1340 microamps\n\nHoltek HT66 568 microamps\n\nInfineon XMC1100 1390 microamps\n\nMicrochip PIC16 470 microamps\n\nMicrochip PIC24 667 microamps\n\nMicrochip PIC32MM 493 microamps\n\nNuvoton N76 1750 microamps\n\nNuvoton M051 1970 microamps\n\nNXP LPC811 3440 microamps\n\nRenesas RL78 516 microamps\n\nSanyo LC87 6420 microamps\n\nSilicon Labs EFM8 607 microamps\n\nST STM8 1620 microamps\n\nST STM32F0 769 microamps\n\nSTC STC8 5470 microamps\n\nTI MSP430FR 279 microamps\n\n#### ISR Latency\n\nAtmel tinyAVR 33 Cycles\n\nAtmel megaAVR 34 Cycles\n\nAtmel SAM D10 391 Cycles\n\nCypress PSoC 4000S 35 Cycles\n\nFreescale KE04 25 Cycles\n\nFreescale KL03 33 Cycles\n\nHoltek HT66 73 Cycles\n\nInfineon XMC1100 16 Cycles\n\nMicrochip PIC16 34 Cycles\n\nMicrochip PIC24 22 Cycles\n\nMicrochip PIC32MM 62 Cycles\n\nNuvoton N76 32 Cycles\n\nNuvoton M051 35 Cycles\n\nNXP LPC811 45 Cycles\n\nRenesas RL78 25 Cycles\n\nSanyo LC87 28 Cycles\n\nSilicon Labs EFM8 26 Cycles\n\nST STM8 39 Cycles\n\nST STM32F0 24 Cycles\n\nSTC STC8 6 Cycles\n\nTI MSP430FR 16 Cycles\n\n#### ISR Cycles\n\nAtmel tinyAVR 36 Cycles\n\nAtmel megaAVR 33 Cycles\n\nAtmel SAM D10 86 Cycles\n\nCypress PSoC 4000S 89 Cycles\n\nFreescale KE04 255 Cycles\n\nFreescale KL03 69 Cycles\n\nHoltek HT66 166 Cycles\n\nInfineon XMC1100 56 Cycles\n\nMicrochip PIC16 201 Cycles\n\nMicrochip PIC24 31 Cycles\n\nMicrochip PIC32MM 29 Cycles\n\nNuvoton N76 71 Cycles\n\nNuvoton M051 54 Cycles\n\nNXP LPC811 115 Cycles\n\nRenesas RL78 15 Cycles\n\nSanyo LC87 131 Cycles\n\nSilicon Labs EFM8 59 Cycles\n\nST STM8 79 Cycles\n\nST STM32F0 58 Cycles\n\nSTC STC8 15 Cycles\n\nTI MSP430FR 56 Cycles\n\n#### ISR Total\n\nAtmel tinyAVR 69 Cycles\n\nAtmel megaAVR 67 Cycles\n\nAtmel SAM D10 477 Cycles\n\nCypress PSoC 4000S 124 Cycles\n\nFreescale KE04 281 Cycles\n\nFreescale KL03 102 Cycles\n\nHoltek HT66 239 Cycles\n\nInfineon XMC1100 72 Cycles\n\nMicrochip PIC16 235 Cycles\n\nMicrochip PIC24 53 Cycles\n\nMicrochip PIC32MM 91 Cycles\n\nNuvoton N76 103 Cycles\n\nNuvoton M051 89 Cycles\n\nNXP LPC811 159 Cycles\n\nRenesas RL78 40 Cycles\n\nSanyo LC87 159 Cycles\n\nSilicon Labs EFM8 85 Cycles\n\nST STM8 118 Cycles\n\nST STM32F0 83 Cycles\n\nSTC STC8 21 Cycles\n\nTI MSP430FR 73 Cycles\n\n#### Flash\n\nAtmel tinyAVR 962 Bytes\n\nAtmel megaAVR 700 Bytes\n\nAtmel SAM D10 3720 Bytes\n\nCypress PSoC 4000S 2280 Bytes\n\nFreescale KE04 2728 Bytes\n\nFreescale KL03 2732 Bytes\n\nHoltek HT66 226 Bytes\n\nInfineon XMC1100 2680 Bytes\n\nMicrochip PIC16 372 Bytes\n\nMicrochip PIC24 618 Bytes\n\nMicrochip PIC32MM 3904 Bytes\n\nNuvoton N76 0 Bytes\n\nNuvoton M051 5876 Bytes\n\nNXP LPC811 2828 Bytes\n\nRenesas RL78 1118 Bytes\n\nSanyo LC87 481 Bytes\n\nSilicon Labs EFM8 534 Bytes\n\nST STM8 1903 Bytes\n\nST STM32F0 3544 Bytes\n\nSTC STC8 376 Bytes\n\nTI MSP430FR 1076 Bytes\n\n#### Flash (%)\n\nAtmel tinyAVR 6%\n\nAtmel megaAVR 4%\n\nAtmel SAM D10 23%\n\nCypress PSoC 4000S 14%\n\nFreescale KE04 34%\n\nFreescale KL03 34%\n\nHoltek HT66 3%\n\nInfineon XMC1100 34%\n\nMicrochip PIC16 3%\n\nMicrochip PIC24 15%\n\nMicrochip PIC32MM 12%\n\nNuvoton N76 0%\n\nNuvoton M051 49%\n\nNXP LPC811 35%\n\nRenesas RL78 11%\n\nSanyo LC87 2%\n\nSilicon Labs EFM8 3%\n\nST STM8 6%\n\nST STM32F0 22%\n\nSTC STC8 1%\n\nTI MSP430FR 29%\n\nThere\u2019s a lot going on in this project, so let\u2019s break it down separately into\nperformance (in this case, power consumption), development process, peripheral\nlibrary bloat, and other platform-specific eccentricities.\n\nIn terms of performance, the MSP430 is the clear favorite. The next-lowest-\nconsuming part, the PIC16, used almost 70% more power.\n\nMost Arm chips struggled with this test. The SAM D10 was the worst \u2014 Atmel\nSTART\u2019s ASF4 peripheral libraries have an insanely high-level UART abstraction\nmechanism that took almost 500 clock cycles to process a single byte.\nProcessor Expert\u2019s equally high-level interface fared considerably better \u2014\nexecuting in 281 clock cycles on the KE04. But both were abysmal compared to\nthe rest of the field.\n\nIt was Infineon DAVE-generated XMCLib code that brought in the fastest Arm\nperformance: it took only 72 cycles in the ISR to process data on the XMC1100.\nThe XMC1100 also got closest to the theoretical 15-cycle interrupt latency of\nthe ARM Cortex-M0+. STM32Cube-generated STM32 peripheral libraries also\nperformed well on the STM32F0 \u2014 needing only 83 clock cycles to process data.\n\nThe Nuvoton M051, with its lightweight, relatively easy-to-use peripheral\nlibrary did moderately well, but the NXP Kinetis KL03 (running Kinetis SDK)\nand the LPC811 (running LPCware) both brought in mediocre numbers (102 and 159\ncycles, respectively).\n\nAs mentioned before, the HT66 has a markedly similar architecture to the\nPIC16, and yet again in this test, these two 4T parts have very similar\nperformance characteristics.\n\nHalfway through my review, I noticed the PIC16 got really really slow. Sure,\nenough the infamous messages started popping up: \u201cUsing Omniscient Code\nGeneration that is available in PRO mode, you could have produced up to 60%\nsmaller and 400% faster code\u201d \u2014 my 60-day evaluation license had expired. And\nthey\u2019re absolutely right \u2014 I had to double my device\u2019s clock speed to hit the\noriginal performance numbers I had. The numbers mentioned in this review were\nfrom optimized code, so if you\u2019re a student or indie developer (or even a\nprofessional who has better things to buy than a compiler), take the results\nwith a big grain of salt.\n\nThe EFM8 proved to be the most flexible 8-bitter in the round-up. It beat out\nall 8-bit parts in the high-performance biquad math tests, and it turned\naround and achieved the third-lowest power consumption figures in the DMX\ntest, too \u2014 needing only 607 \u03bcA, while running at a cool 1.531 MHz core speed.\nAgain, a multi-byte FIFO helped immensely.\n\nThe tinyAVR and megaAVR both performed poorly \u2014 they consistently look like\nbigger, beefier 16- or 32-bit parts in performance testing: they bring in\ngreat math performance and run-mode active current, but they had some of the\nhighest interrupt latencies among 8-bit parts that don\u2019t have FIFO UARTs\n((While interrupt latency is a property of the core \u2014 not the peripherals \u2014 we\noften measure interrupt latency relative to an actual event happening. Here,\nperipherals play a major role in determining latency. UARTs with FIFOs in this\ntest had significantly higher interrupt latencies than UARTs without FIFOs.)),\nand they both struggle with stop-mode and low-speed run-mode current.\n\nAnother 8-bit part that stood out was the STC8, which recorded a 6-cycle\ninterrupt latency \u2014 that\u2019s 6 cycles from the stop bit being received, all the\nway to your C interrupt handler executing. Interrupt latency is one major\nadvantage these 8051 parts continue to press over the fancier RISC-based AVR\nand Arm cores, which have long prologue and epilogue code. Unfortunately, the\nSTC8 simply does not care about power consumption \u2014 so it barrels along at\n5.47 mA.\n\nAs for ease of development, things were split across the board \u2014 even between\nparts that had code-gen tools, only peripheral libraries, or nothing at all.\n\nWith Cypress PSoC Creator, I had to write a custom ISR from scratch, as the\ngenerated code didn\u2019t contain functions for handling this scenario. I got\nburned by the function documentation a bit \u2014 but was able to get it working\nafter quite a bit of reading.\n\nInfineon DAVE essentially cheated in this competition by providing a pre-\nbuilt, one-click DMX-512 Receiver Dave APP. Consequently, I simply had to glue\nits callback to the LEDs by writing three set-duty-cycle calls. It was\nbeautiful.\n\nExcluding DAVE, the easiest to get going was actually the Renesas code\ngenerator, which provided function prototypes for me to implement that it\ncalled from the interrupt. I have no idea why more vendors don\u2019t provide\nstatically-invoked callback functions from their generated interrupt code.\nThey either provide no callbacks at all (STM32CubeMX, Microchip MCC, Cypress\nPSoC Creator), or they provide a weird, super heavy-handed dynamically-invoked\ncallback register event system (like Atmel), or provide a user callback can\u2019t\ndirectly handle the (private) data, or manipulate the internal state of the\ndriver \u2014 like in the case of Processor Expert on the KE04.\n\nFor this particular project I enjoyed Silicon Labs\u2019 approach with Simplicity\nConfigurator \u2014 it will automatically create the interrupt for you, and will\neven make sure it gets enabled in start-up code. It will give you helpful\ncomments above the interrupt, telling you which flags to clear. But, the\ngenerated interrupt functions are just stubs \u2014 they contain no actual code.\nThis is definitely the most flexible and lightest-weight route to take. And\nwhile some vendors (Microchip MCC, ST STM32CubeMX, NXP Processor Expert)\nprovide \u201cinit-only\u201d drivers, they don\u2019t automatically stub the ISR, nor do\nthey automatically enable the interrupt.\n\nThe HT66\u2019s peripherals were simple to configure by hand \u2014 and it required the\nfewest bytes of flash.\n\nThe PSoC was the most efficient of the 32-bit parts \u2014 owing to the fact that\nthe majority of code required for this project (peripheral initialization)\nlives in a compact bitstream representation inside the PSoC.\n\nThe Nuvoton runtime libraries are huge (since they\u2019re so simple to use), and\nI\u2019m not positive that CoIDE was properly doing link-time-optimization (I\u2019ll\nneed to investigate further).\n\nDiscussion\n\n#### Silcon Labs EFM8: Fantastic value and ease-of-use from the only 8-bit\npart with a totally-free cross-platform vendor ecosystem\n\nThe EFM8 was the fastest 8-bit part in my round-up, and admittedly, my\nfavorite 8-bit architecture to develop with overall. What these parts lack in\nbrains they make up for in brawns \u2014 14-bit ADCs, 12-bit DACs, lots of timers,\nand a 72 MHz core clock speed that gives you timing options not found in any\nother part in the round-up.\n\nPlus, this is the only 8-bit part with a totally-free, cross-platform, vendor-\nprovided ecosystem. Let that sink in.\n\nKeil C51 is a silly compiler, but Silicon Labs does an excellent job hiding it\nunder the hood \u2014 even when running its Eclipse-based Simplicity Studio on\nLinux or macOS.\n\nSimplicity Configurator is the lightest-weight code generator in our round-up,\nusing only 534 bytes of flash to house the entire DMX-512 receiver project. It\nwas one of the easiest to use, and seemed to strike a good balance between\nabstraction, performance, and ease of use.\n\nDebugging speeds are snappy with a J-Link debugger, but at $35, the official\nSilicon Labs USB Debug Adapter is one of the cheapest first-party debugger in\nthe round-up, and clones of the hardware are even cheaper.\n\nAnd call me old-fashioned, but I think the 8051 definitely has a place in 2017\n\u2014 especially among hobbyists and students, where its bit-addressable memory,\neasy-to-use peripherals, and fuse-free configuration help get students\ncomfortable with microcontrollers quickly.\n\n#### Microchip megaAVR & tinyAVR 1-Series: Different strokes for different\nfolks \u2014 still with the best 8-bit toolchain available\n\nThe megaAVR came in surprisingly flat for me: especially when compared with\nits lower-cost, new sibling, the tinyAVR 1-Series.\n\nThere\u2019s no comparison when it comes to price: tinyAVR has incredible value \u2014\npacking in a nice assortment of timers, analog peripherals (including a DAC),\nand a new 20 MHz internal oscillator \u2014 while costing 20-40% less than the\nmegaAVR.\n\nWhile the megaAVR has a perplexing debugging experience that requires two\ncompletely different interfaces and protocols to work with the part, the new\none-wire UPDI interface the tinyAVR sports worked flawlessly in my testing.\n\nBut that\u2019s the crux of the problem for the tinyAVR \u2014 by shedding many of its\nmegaAVR roots, Microchip ended up with a wonderful microcontroller that will\nbe challenging to use for a large base of Atmel fans: indie developers and\nhobbyists who use low-cost, open-source programmers (which don\u2019t support the\nUPDI interface).\n\nWhile the tinyAVR wasn\u2019t the fastest part in the round-up (even among\n8-bitters), it was the most efficient \u2013 both in terms of active-mode power and\nclock efficiency. Amazingly, the AVR only uses about twice as many\ninstructions as 16- and 32-bit parts when performing 16-bit math.\n\nUnfortunately, the AVR system as a whole is not without its issues. The\nWindows-only Atmel Studio is still buggy (especially with older megaAVR\ndevices and AVR Dragon stuff in my tests), and there isn\u2019t an under-$50 low-\ncost debugger available (other than hacking apart Xplained Mini dev boards).\n\nIn many ways, there seems to be a tacit demarcation Atmel creates between its\nhobbyist/indie developers, and the professional shops that use Atmel parts.\n\nAs a professional embedded developer, I most definitely have access to Windows\ncomputers, and I have no problem blowing a few billable hours\u2019 worth of pay on\na $140 debugger.\n\nBut even as popular as Atmel is among hobbyists, Atmel has largely stayed out\nof this space directly. Instead, they\u2019ve secured small-volume AVR sales by\nrelying on the open-source community to build their own tools for themselves:\nturning out a slew of hardware and software used to program the megaAVR\ndevices.\n\nWhile I applaud the efforts of these developers, these tools are inferior to\nAtmel\u2019s. Their programming speeds are terrible, they don\u2019t support the new\ntinyAVR 1-Series devices, and they have absolutely no debug capability.\n\nHaving said that, both the megaAVR and tinyAVR have the best toolchain\navailable for 8-bit MCU development. The part supports a full, end-to-end\nMakefile-based GCC toolchain.\n\nIf you love printf() debugging, would never touch a proprietary toolchain, and\nhate IDEs, megaAVR and old tinyAVR parts are definitely for you. The older\nones are still available in DIP packages, and as you probably know, there are\na ton of low-cost programmers available across the world. The online community\nis massive, and as clunky as I find Atmel START to be, I have to applaud its\nsupport for Makefile-based project generation.\n\nConsequently, the megaAVR remains the most open-source 8-bit microcontroller\non the market \u2014 by a long shot.\n\nBut I\u2019d really like to see Microchip provide a PicKit-priced debugger with\nUPDI support \u2014 and allow off-board debugging the way their PIC Curiosity\nBoards do.\n\nI also hope these open-source projects can add UPDI support to their tools, so\nthat hobbyists and indie developers can start integrating the tinyAVR into\ntheir projects \u2014 it\u2019s a much better part, and if you\u2019re an AVR user with\naccess to Atmel Studio, you really ought to buy an Xplained Mini board and\ntake it for a spin.\n\n#### STM32F0: A low-cost, no-nonsense part with arguably the best Arm\ndevelopment ecosystem tested\n\nThe STM32F0 was the lowest-power Arm microcontroller in the round-up, and also\none of the easiest to use. STM32CubeMX doesn\u2019t generate the most compact code\non Arm (that honor belongs to Cypress PSoC Creator and Infineon DAVE), but it\nhas a snappy interface, and the generated code is easy enough to manipulate\nfor your own goals.\n\nI love the nearly-stock Eclipse-based environment that System Workbench for\nSTM32 provides, and the ST-Link and excellent Discovery/Nucleo boards seals\nthe deal for me.\n\nMost pros have used ST parts in their work, but for all these reasons, any\nhobbyist looking at moving to Arm should probably pick up a dev board from\nthis ecosystem, too. ST has a huge market footprint, so there\u2019s tons of\nresources online \u2014 aimed at both hobbyists and professionals.\n\n#### SAM D10: Killer performance & peripherals, but with runtime library\nhiccups\n\nThe Microchip/Atmel SAM D10 (and the broader D11/D20/D21 ecosystem) has good\nvalue (considering their analog portfolio includes a DAC, and they have good\ntiming options), and the SAM D10 was the most efficient part tested when\nrunning at full speed.\n\nProfessionals will like the easy-to-use, well-documented header files, and\nhobbyists will appreciate the 1.27mm-pitch SOIC package options and GCC\ncompilers that come with the Arm ecosystem. But before I grab this part for a\nproject, Microchip really needs to fix the extremely slow, bloated peripheral\nlibrary, and update their code-gen tool to do proper error-checking of clock\nand peripheral configurations.\n\nAs it is, whenever I use Atmel START on the D10, I want to STOP almost\nimmediately. And there are no current, stand-alone peripheral drivers that\nMicrochip has released for this part, so unless you want to do register\nprogramming from scratch, you\u2019ll be relying on third-party, open-source\nprojects \u2014 like Alex Taradov\u2019s code examples.\n\n#### Infineon XMC1100: Interesting peripheral perks make this Cortex-M0 stand\nout\n\nThe most interesting Arm chip was, without a doubt, the Infineon XMC1100 \u2014 and\nI think professionals who may be wary of getting out of the ST/NXP/Atmel Arm\necosystem need to take a second look at these XMC1000 (and XMC4000) parts.\n\nThe timer options are amazingly flexible, and you can squeeze fantastic\nperformance out of the USIC module.\n\nI\u2019m going to go out on a limb and recommend that serious hobbyists who are\nbuilding motor / lighting control projects look into these parts, too. DAVE\nmakes setting up these complex peripherals painless, and the 38-pin TSSOP\nchips will be substantially easier to solder than the 0.5mm QFNs and QFPs you\nusually end up with in these pin counts.\n\nLike many of the parts reviewed here, the biggest problem for hobbyists and\nindie developers is the tiny online communities and lack of GitHub repos with\nopen-source projects that use these chips. My advice \u2014 be bold, and post in\nthe forums. Infineon employees monitor and usually respond within a day or so.\n\n#### PIC16: Tons of peripherals with a slower, power-efficient core\n\nWhen you compare the PIC16 with other 8-bit parts out there, it\u2019s obviously a\npart built for low-power applications, and not processing power. And while the\ndevelopment ecosystem is workable, there are other parts more friendlier\npathways \u2014 especially for smaller shops, hobbyists, and students who need\nextremely low-cost tools (and free software).\n\nTo add fuel to the PIC-vs-AVR debate, my testing found that a 32 MHz PIC16 is\nroughly equivalent to an AVR part running at 1.4 MHz (in terms of math\nperformance), and 9 MHz (in terms of bit-shuffling performance).\n\nHaving said that, the DMX-512 receiver seems a perfect match for the PIC16,\nand that\u2019s where it looks best in my testing: the PIC16 was the lowest-power\n8-bit part in my testing.\n\nIt\u2019s also full of timers and digital logic-oriented peripherals that make it\nsuitable for funky special-purpose projects that require some crafty use of\nconfigurable logic and and the numerically-controlled oscillator \u2014 these\nperipherals help offload the (relatively slow) CPU, at the expense of\nrequiring more developer familiarity with the device and these peripherals.\n\nThe usual Microchip gotchas apply: clunky IDE, expensive compilers, and\nexpensive debuggers.\n\nThe usual Microchip advantages apply: huge online community, seemingly\ninfinite product lifetime guarantees, and DIP, SOIC, QFP, and QFN package\navailability.\n\n#### PIC24: An expensive MSP430 wannabe that doesn\u2019t hit the mark\n\nThe PIC24 is nearly forgettable. In the biquad test, it\u2019s marginally faster\nthan the Renesas RL-78 but uses almost three times as much power. In the\nDMX-512 test, both the RL-78 and MSP430 beat it, too. It was also one of the\nleast-endowed parts in the round-up (which really just means it\u2019s expensive \u2014\nhigher-end PIC24 parts have no shortage of peripherals).\n\nThe usual Microchip gotchas apply: clunky IDE, expensive compilers, and\nexpensive debuggers.\n\nThe usual Microchip advantages apply: huge online community, seemingly\ninfinite product lifetime guarantees, and DIP, SOIC, QFP, and QFN package\navailability.\n\n#### PIC32: An excellent 32-bit part that balances performance and power\nconsumption\n\nThe PIC32MM was my favorite Microchip part in the review. It brought in the\nlowest-power performance of every 32-bit part tested. Unfortunately, it was\nalso the least-efficient 32-bit part tested in terms of math performance\n(well, excluding the couldn\u2019t-care-less-about-power Nuvoton M051), and it\u2019s\npretty spartan on peripherals \u2014 it doesn\u2019t even have a hardware I2C\ncontroller.\n\nBut PIC32MM parts have good flash / RAM density, and have simpler clocking /\nperipheral gating configurations than some of the more-flexible Arm parts,\nwhich makes them feel easier to program at a register level.\n\nPlus, they have a lot of headroom: I think the high-end PIC32MZ DA devices\nhave a home among small industrial dev shops that need Linux-like HMI\nfunctionality but don\u2019t have the resources to bring a product like that to\nmarket.\n\nThe usual Microchip gotchas apply: clunky IDE, expensive compilers, and\nexpensive debuggers.\n\nThe usual Microchip advantages apply: huge online community, seemingly\ninfinite product lifetime guarantees, and DIP, SOIC, QFP, and QFN package\navailability.\n\n#### Renesas RL-78: An agile, low-power, easy-to-use 16-bit part you really\nought to try\n\nI had never picked up a Renesas part before, and when I went shopping for dev\nkits and stumbled on only a smattering of expensive, traditional systems, I\nwas a little anxious. But I found the $25 RL78L1A Promotion Board, gave it a\nshot, and really enjoyed it.\n\nThe RL-78 is a snappy architecture that competes with Arm parts in math\nperformance, yet it\u2019s also relatively inexpensive \u2014 especially compared to the\nMSP430 and PIC24. It can\u2019t quite hit the MSP430 sleep-mode power consumption\nfigures, but it gets close \u2014 and is, by far, the most power-efficient\n5V-capable part in the review.\n\nThe code generator tool produces readable yet efficient code, and the IDE,\ne2studio, is Eclipse-based \u2014 and is getting Linux and macOS support in the\nnext release.\n\nI\u2019d complain about the dev board, but the new YRPBRL78G13 RL78/G13 development\nkit should remedy basically all my complains with it \u2014 I can\u2019t wait for U.S.\ndistributors to start carrying these. They could use a more active community\nand more people publishing code online, but I hope this article will help\ninspire some remedies for that.\n\n#### N76, HT66, and STM8: Low-cost parts with a smattering of development\nheadaches\n\nThe STM8 is probably the nicest of the \u201ccheapie\u201d parts. It has nice\nperipherals and really good performance for an 8-bit part running at its\nfrequency, but I think the entry-level 38-cent STM8S103F2P6 is a more\ncompelling part than the higher-end one reviewed here \u2014 simply because of its\nultra-low price. The part I reviewed here looks a lot like the other 8-bit\nmicrocontrollers \u2014 but with an ancient-looking IDE that\u2019s not nearly as\nproductive as the competition. And almost everything out there has better\npower consumption figures.\n\nStill, this part is relatively cheap to get going (ahoy, $5 ST-Link clones),\nand the IDE and toolchain are completely free. But in that regard, you get\nwhat you pay for: STVD feels trapped in 2002, and there\u2019s no way to set up a\nmore modern development and debugging environment for it ((Though, there\u2019s\nsome emerging SDCC / GDB support for pairing it with an ST-Link in an open-\nsource fashion, which might help it make inroads with the classic tinyAVR and\nmegaAVR users)).\n\nYou\u2019ll be forking over quite a bit of money for a Keil C51 license to develop\nfor the N76 \u2014 all for a part that doesn\u2019t look much different than some entry-\nlevel EFM8s that have a day-and-night difference in ease of development.\nStill, at 23 cents per unit, it\u2019s tough to beat for volume applications \u2014 and\nhobbyists and hackers can probably get by with the 2K code limit of Keil\u2019s\nevaluation version. SDCC users need not apply: there\u2019s no stand-alone tools\nfor loading code into this part, and I doubt \u03bcVision can be coaxed into\nloading an SDCC-compiled hex file.\n\nThe Holtek HT-66 has terrible processing performance, but barely uses any run-\nmode current \u2014 there\u2019s plenty of application-specific models to choose from,\nand while the IDE is goofy, I found it to be fairly productive \u2014 and it\u2019s\ncompletely free. Careful, though: only the more-expensive \u201cV\u201d parts have on-\nchip debugging.\n\n#### STC8: A neat performance-heavy part for hacking \u2014 but probably not for\nserious, professional work\n\nI think every hacker and advanced hobbyist really ought to throw $10 at\nAliExpress/Taobao and get some STC15 and STC8 parts \u2014 just for fun.\n\nBoth are jam-packed full of peripherals and memory (more than every other part\nreviewed), and the STC8 is also really fast. There are some interesting\nprojects you can do with a part that hits your C interrupt code 10 clock\ncycles after an interrupt occurs \u2014 that\u2019s 320 nanoseconds. Both these parts\nsupport debugging over UART, so there\u2019s no proprietary debugger to purchase.\n\nI wouldn\u2019t seriously consider using these parts in U.S-based commercial work,\nas we have no access to STC inventory here, but the part is just plain fun to\nplay with.\n\n#### ON Semiconductor LC-87: Skip\n\nYou can probably skip over the ON Semiconductor LC87. This is a rare part\noutside the Japanese market, and it looks like it\u2019s on its way out the door. I\ncalled Altium to try to get an evaluation version of the Tasking LC87 toolset,\nand the person I talked to had never heard of the LC87 before, and was almost\npositive they hadn\u2019t made a compiler for it for at least three years. This\npart has terrible power consumption, few peripherals, and the worst\ndevelopment environment I saw in this review. Skip.\n\n#### Kinetis KL03: Sleep-mode specialist not for beginners\n\nWhile the Kinetis KL03 has excellent deep-sleep current and ultra-tiny CSP\npackage availability, it definitely feels like a specialized part not useful\nfor the applications I evaluated. It has far fewer peripherals than the other\nparts reviewed, and despite NXP\u2019s low-power claims, was consistently in the\nmiddle of my Arm rankings for the DMX-512 receiver test \u2014 though it nearly\nmatches the SAM D10 in full-speed active mode.\n\nKinetis SDK is awkward to use, and the dev boards are terrible \u2014 requiring a\nlot of reverse-engineering and hacking to get the board doing anything other\nthan running pre-written demos (especially if you\u2019re interested in measuring\npower consumption). Still, MCUXpresso is a productive, modern Eclipse-based\nIDE, and the KL03 has some of the lowest-leakage power modes out there, which\nmeans you can get 8-bit-like performance when you\u2019re running an RTC or\ninterrupt wake-up project from a coin-cell battery.\n\n#### Kinetis KE04: Decent peripheral assortment with a powerful \u2014 yet clunky \u2014\ncode gen tool\n\nThe Kinetis KE04 had pretty heavy power consumption in my testing \u2014 but this\nwas largely due to the heavy-handed Processor Expert code that Kinetis Design\nStudio generated. This environment is really suited to much larger, faster\nmicrocontrollers running RTOSes and not needing especially good low-level I/O\nperformance.\n\nBut, hey, if you don\u2019t really care about performance, the nice thing about\nProcessor Expert is it abstracts the peripherals to such a high level that\nyou\u2019ll never need to crack open a datasheet for the part if you\u2019re using the\nperipherals in normal configurations.\n\nPlus, the KE04 (and KE02) are 5V-compatible parts, and they\u2019re available in\nold-school, easy-to-solder 1.27mm SOIC and 0.8mm packages \u2014 so I could imagine\nhobbyists would find this part useful.\n\n#### LPC811: Few perks, and less interesting than the LPC810\n\nThe LPC810 drew people in with its odd, 8-pin DIP form-factor. That chip has\nsince been discontinued, but the LPC81x line remains. The LPC811 reviewed here\nis sparse on peripherals \u2014 not even having an ADC \u2014 and brought in poor\nperformance. There\u2019s really nothing that this part does that you can\u2019t get\nfrom one of the other vendors; but don\u2019t discredit NXP completely \u2014 their\nhigher-end offerings have some interesting capabilities (like dual-core\nCortex-M4/M0 designs), and their development environment, MCUXpresso, is an\ninoffensive Eclipse system.\n\n#### PSoC 4000S & MSP430: Bottom-of-the-barrel parts that offer a glimpse into\nnice ecosystems\n\nI hesitated to review the PSoC and MSP430 because they tend to be relatively\nexpensive parts, so in a $1 shoot-out, you end up with bottom-end parts that\ndon\u2019t look nearly as useful as their higher-cost relatives. If you really want\nto get a feel for what the MSP430 or PSoC parts can do, I recommend buying\ninto a higher-end part \u2014 preferably on one of the excellent dev boards that\nthese manufacturers make.\n\nPSoC Creator and the reconfigurable digital and analog blocks in the PSoC line\ndraw many professional and hobbyist users into the architecture \u2014 but instead\nof grabbing the 4000S from this review, reach for a PSoC5 (or soon-to-launch\nPSoC6) dev board to get a feel for the platform.\n\nSame with the MSP430. In the DMX-512 test, it dominated in power consumption,\nbut barely put up marks in any other category (this is especially challenging\nwhen you have no hardware multiplier, and only a smattering of peripherals).\n\nStill, the part has a solid development ecosystem with Code Composer Studio\nand a choice between the proprietary (but now free) TI compiler, and the open-\nsource GCC one. Plus, hobbyists will love the easy Arduino migration path\n(with Code Composer Studio directly supporting Energia *.ino sketch projects)\nand $10 dev boards.\n\nAnd really, everyone starting a battery-based product needs to go buy an\nMSP430 Launch Pad and play around with it \u2014 these really are amazing parts\nthat still have a lot of relevance in 2017.\n\n#### Nuvoton M051: Ecosystem issues stifle a performance-packed part\n\nThe Nuvoton M051 \u2014 one of the most-endowed parts reviewed \u2014 suffers ecosystem\nissues that Nuvoton could easily remedy in the future, so I\u2019ll reserve\njudgment. There\u2019s no manufacturer-provided Eclipse-based IDE \u2014 instead, the\nonly IDE options are CooCox, and Keil \u03bcVision \u2014 neither of which I\u2019m\nparticularly fond of.\n\nI was able to get CooCox working (though the peripheral libraries that are in\nthe CooCox repo are old and full of bugs). The M0 had some of the worst power-\nconsumption figures in the review, but it makes up for that with tons of\ncommunications peripherals, beautiful 32-bit control-friendly timers, and\neasily-digestible runtime libraries and documentation that are far easier to\nuse than other vendors\u2019. When Nuvoton fixes the IDE absence, I\u2019ll definitely\nmove this part from the \u201cmeh\u201d to \u201cyeah\u201d column \u2014 since it accomplishes all of\nthese feats while remaining one of the lowest-cost Arm microcontrollers out\nthere.\n\nConclusion\n\nI had a ton of fun playing with all these different parts for the last few\nmonths for this microcontroller review, and in many ways, came away thinking\nwhat I already knew: there is no perfect microcontroller \u2014 no magic bullet\nthat will please all users. What I did learn, however, is it\u2019s getting easier\nand easier to pick up a new architecture you\u2019ve never used before, and there\nhave never been more exciting ecosystems to choose from.\n\nAnd that\u2019s what I want people to think about as they walk away from this\nmicrocontroller review. If you\u2019re an Arduino hobbyist looking where to go\nnext, I hope you realize there are a ton of great, easy-to-use choices. And\nfor professional developers and hardcore hackers, perhaps there\u2019s an odd-ball\narchitecture you\u2019ve noticed before, but never quite felt like plunging into \u2014\nnow\u2019s the time.\n\nIt\u2019s an exciting time to be involved with electronics \u2014 whatever parts you\nchoose to pick up, I hope you\u2019ve enjoyed learning about what\u2019s out there, and\ncan get inspired to go build something great. Definitely leave a note in the\ncomments below if you\u2019ve got something to contribute to the discussion!\n\n## Comments (111)\n\nCharles\n\nNovember 6, 2017 at 1:18 pm\n\nReply\n\nPurchase links would be appreciated ?\n\nAlain\n\nNovember 6, 2017 at 1:19 pm\n\nReply\n\nImpressive work! I\u2019m a big user of Atmega, SAMD and STM32F0, and I learned a\nlot in this article. I agree that SAMD is a great series of chips that comes\nwith poor libraries. STM32F0 has better libraries but peripherals are\nsometimes a bit quirky... So it\u2019s good to play with both worlds. And I see\nfrom this article that there is a lot more!\n\nstef\n\nNovember 6, 2017 at 1:21 pm\n\nReply\n\nwell done, great comparison, appreciate Your work, Thanks a lot.\n\nPeter\n\nNovember 6, 2017 at 1:38 pm\n\nReply\n\nA wonderful article! It would have been interesting to include the EFM32ZG\n(https://www.silabs.com/products/mcu/32-bit/efm32-zero-gecko) in this\ncomparison. Another ARM Cortex-M0+ that can be had for just under a dollar\nwith 4KB flash and 2KB RAM.\n\nSudhir Kamat\n\nJuly 2, 2021 at 8:10 am\n\nReply\n\nGreat work in compiling this data !! Been there and done that on a few of your\ntests. Nice comprehensive comparison. Cheers !!\n\nPete\n\nNovember 6, 2017 at 2:30 pm\n\nReply\n\nDetail-packed review! I\u2019d often thought I\u2019d like to do a series on various\nlow-cost MCUs and their ease of climbing the complexity ladder from blinking a\nLED to something more advanced. Your review here covers nearly everything I\nwould have done and then some. Thanks!\n\nZach Fredin\n\nNovember 6, 2017 at 3:13 pm\n\nReply\n\nExcellent article. I really appreciate the attention to detail \u2014 peripherals,\nfirmware, packaging, toolchain, everything.\n\nI\u2019ve had good luck with the relatively new STM32L0 series. Might be worth a\nlook \u2014 it addresses the above-average power consumption concern you listed for\nthe F0. I have used the cheaper versions (STM32L011x) in a few designs and\nit\u2019s a nice little chip. And cheap.\n\nDavid L Jenkins\n\nNovember 6, 2017 at 4:50 pm\n\nReply\n\nGreat work and very much appreciated. I will take a few days to digest it. But\nI still can\u2019t believe that you can get a powerful machine like this for only a\ndollar.\n\nDaniel\n\nNovember 6, 2017 at 7:47 pm\n\nReply\n\nVery interesting and detailed post. It pretty much agrees with a lot I\u2019ve\nexperienced myself. Just two cents from my side: It\u2019s not just Atmel Start\nwhich is horrible but the whole peripheral section of the ATSAMD are rather\nshitty with their dozens of unsychronized running clocks which tend to lock up\nthe system rather easily and hard if one forgets even just one of the\nobligatory waiting loops. Just thinking of them makes me want to cry out loud\nin horror, only emphasised by the largely incomplete documentation with\nthousands of errors and discrepancies and a complete lack of examples both in\nand outside of documentation. I will gladly take any opportunity I get to stay\nthe hell away from them.\n\nThe other thing I wanted to add is that STM32CUBEMX can not only generate code\nfor the rather sizeable HAL API (it\u2019s actually a nice touch that it can also\ngenerate Makefile projects and include all required APIs for that), but also\ncode for the much slimmer (and hence for me) more useful LL API.\n\nKat\n\nNovember 6, 2017 at 7:56 pm\n\nReply\n\nWhat about ESP8266 ?\n\nBob Seeley\n\nNovember 6, 2017 at 9:48 pm\n\nReply\n\nIncredibly well done. It certainly has opened up a lot of information that I\ndidn\u2019t know existed. Thank you very much.\n\nByron Shilly\n\nNovember 6, 2017 at 10:47 pm\n\nReply\n\nQuality piece. Keep up the good work.\n\nPatrick O\n\nNovember 7, 2017 at 8:24 am\n\nReply\n\nThis. As popular as the ESP8266 is, I\u2019m also disappointed it wasn\u2019t included\nhere. Probably the lack of documentation. Nonetheless, this was a great write\nup.\n\nPaul George\n\nNovember 6, 2017 at 10:50 pm\n\nReply\n\n??? Bro. Came here as a part of the hackernews hug of death . Technical\nLiterature of this kind is badly needed by the embedded community. Hats off ,\nIn aggreement with most of the discussion on the hacker news post . I\nstruggled with the selection of a microcontroller for a product I had to\ndevelop, and SEO in this domain is poor .\n\nYou\u2019ve Earned yourself a Email Subscriber. I`m personally engaged with the\ndevelopment of RISC-V Cores as a part of the Shakti Processor project at IIT\nMadras . I\u2019d love to lend a hand towards the extensive homework needed to keep\nthese going !! Kudos !\n\nautarchex\n\nNovember 6, 2017 at 11:49 pm\n\nReply\n\nThis is an amazing and thorough treatment, thank you! This beats the pants off\nevery MCU roundup I\u2019ve ever seen.\n\nI would like to suggest a minor correction to the ARM Cortex-M0 description,\nthough: \u201cAnother problem with ARM processors is the severe 12-cycle interrupt\nlatency. When coupled with the large number of registers that are saved and\nrestored in the prologue and epilogue of the ISR handlers, these cycles start\nto add up.\u201d\n\nAs I understand it the majority of those 12 cycles *are* the save/restore of\nregisters on entry/exit of the ISR, which is performed automatically by\nhardware. The use of \u2018when coupled with\u2019 implies that the 12 cycle hit is\nextended beyond this, but unless the compiler is incredibly naive or the ISR\nis (too) complicated, there should be no prologue/epilogue code and no\nadditional latency.\n\nsteph_tsf\n\nNovember 7, 2017 at 9:41 am\n\nReply\n\nautarchex \u2013 Sorry buddy, you understood it the wrong way. The interrupt\nlatency takes 12 cycles, for your interrupt code to start executing. And,\nspeaking of a microcontroller that is not featuring a shadow register set,\nyour interrupt code is supposed to start with the IRS prologue (possibly\nautomatically generated by the compiler) that\u2019s saving the context (all CPU\nregisters that your ISR does modify).\n\nDaniel\n\nNovember 9, 2017 at 8:03 am\n\nReply\n\nErr, no: \u201cTo make the Cortex-M devices easy to use and program, and to support\nthe automatic handling of nested exceptions or interrupts, the interrupt\nresponse sequence includes a number of stack push operations. This enables all\nof the interrupt handlers to be written as normal C subroutines, and enables\nthe ISR to start real work immediately without the need to spend time on\nsaving current context.\u201d\n\n[https://community.arm.com/processors/b/blog/posts/beginner-guide-on-\ninterrupt-latency-and-interrupt-latency-of-the-arm-cortex-m-processors]\n\nHowever it\u2019s not 12 cycles but 15/16 minimum for Cortex-M0.\n\nRich Webb\n\nNovember 7, 2017 at 2:52 am\n\nReply\n\nYes, excellent write-up. It\u2019s going to take more than one read-through to\ndigest it all.\n\nBummer that the Arm M0 chips don\u2019t include bit banding, which would have\ncovered the bit-addressable register topic, but one can\u2019t have everything.\n\nE Shull\n\nNovember 7, 2017 at 8:41 am\n\nReply\n\nIncredible writeup; thanks for putting this out there!\n\nBecause sometimes I can\u2019t avoid proofreading, a couple formatting issues I\nnoticed: * Under the Peripherals comparison section, the notes for the PWM tab\nare on the previous (timers) tab. * In the discussion of code generation for\nthe ST STM32CubeMX, you appear to have an inadvertent paragraph break in the\nmiddle of the sentence \u201cThe other problem is how basic some of the periphe\u201d\n\nJay\n\nNovember 7, 2017 at 4:41 pm\n\nReply\n\nActually, the TimerMark score includes PWM channels as part of the criteria;\nthe separate PWM tab is just for convenience \u2014 I will add some clarity to that\nsection in the future. And thanks for spotting that random line break!\nAppreciate the editing help ?\n\nsteph_tsf\n\nNovember 7, 2017 at 9:45 am\n\nReply\n\nDo all 8051 clones (reviewed here) feature shadow registers sets (register\nbank switching)?\n\nJay\n\nNovember 7, 2017 at 5:12 pm\n\nReply\n\nThanks for the good question. While the EFM8LB1 and N76 do, the STC8 actually\nmaps some of its peripherals into XRAM (controversial, but considering most of\nthese register interactions are one-time initialization, I\u2019m not opposed to\nthe slower speed).\n\nLower-end EFM8 parts \u2014 like the Busy Bee (EFM8BB1) \u2014 do not, either (since all\ntheir peripherals fit into the register set).\n\nGary Bergstrom\n\nNovember 7, 2017 at 10:23 am\n\nReply\n\nNice article. Of course I\u2019ve got a comment about the micro I use most \u2013 the\nMSP430. You can get a quite full featured (a/d, dma, multiplier etc) part in\nthe family for $1.10. Not quite the $1 price of your eval. And if you let that\nnumber creep then you get thousands of parts. And it gets more difficult to do\nany kind of eval. I\u2019m moving to the Arm Cortex parts and I\u2019m pretty happy with\nthe newer Cypress devices. But most of the things I look at cost much more\nthan $1. I do lower volume, harder to do things. The cost of the CPU is way\ndown the list. IDE tools may be the most important as development costs dwarf\nthe micro cost when you only build 1000 (or less!) of something.\n\nBut again, nice article.\n\nJon Smirl\n\nNovember 7, 2017 at 1:53 pm\n\nReply\n\nWhat about the ESP32? About $1.50\n\nAnother group, the ONVIF camera chips.\n\nHI3518e, GM8135S \u2014 ARM9 + 128MB RAM, $3.50 Allwinner V3S \u2014 Cortex-A9 + 128MB,\n$3.50 These chips contain two dies inside the package.\n\nJay\n\nNovember 7, 2017 at 5:36 pm\n\nReply\n\nThese are all interesting parts that deserve study (especially those Allwinner\nchips that integrate DDR with the CPU), but they\u2019re all way more than $1, and\nreally have little to do with anything else on the page. Thanks for the\nrecommendations, though \u2014 I\u2019ll have to do a future project with one of these\ndevices.\n\nJoseph Chiu\n\nNovember 7, 2017 at 2:42 pm\n\nReply\n\nWow, amazing body of work! I fully agree with your PSoC assessment \u2014 if you\ncan\u2019t make use of the virtual peripheral and touch sense capabilities, it\u2019s\nfar less interesting.\n\nThe value of a good toolchain and IDE cannot be stressed enough for people\ntrying to \u201cgrow up\u201d past using the standard Arduino environment. You get so\nmuch more accomplished with a proper environment to write and debug code in!\n\nDoctor Wizard\n\nNovember 7, 2017 at 3:22 pm\n\nReply\n\nIf you are not already familiar with it, you should check the VisualMicro\nextension for Visual Studio. It works with any controller that has an Arduino-\nlike GCC/Wiring platform. And you get intellisense and all the other bells and\nwhistles of Visual Studio. (Great if you are already used to Visual Studio and\ndo non-microcontroller related stuff too). I use it with AVR, Arm, STM8 and\nSTM32, ESP8266 and ESP32, ChipKit and PIC32.\n\nMatheus\n\nNovember 7, 2017 at 4:41 pm\n\nReply\n\nCongrats for the really amazing work on this comparison!\n\nThere is so much information here that I haven\u2019t had enough time to read\neverything yet but sure I will\n\nI\u2019d like to know which tools did you use to get the current measurements. I\u2019m\nin need of a tool to provide this kind of information while developint at my\nwork.\n\nRegards,\n\nJay\n\nNovember 8, 2017 at 1:36 am\n\nReply\n\nThanks! I used a Silicon Labs STK for current measurement. I\u2019ve updated the\narticle with this information.\n\nBoz\n\nNovember 7, 2017 at 7:33 pm\n\nReply\n\nMy only real bug-bears on the PIC MPLABX IDE is the removal of the\noptimization on the non-paid for C Compilers which happens to the 32 bit and\n24 bit compilers as well as the 8 bit ones!\n\nJavier Cano\n\nNovember 8, 2017 at 2:38 pm\n\nReply\n\nCongratulations for this EPIC uCs review Jay, kudos for you!\n\nI use to dig with ATmegaAVRs just with command line tools (avrdude and the\ngood old Nano editor) on my Mac, so IDE stuff is no issue at all for people\nlike me, and believe me, there is a lot more fun in a plain terminal than in\nIDEs.\n\nYou have one more email suscriber!\n\nBest regards.\n\nmohamed Fezari\n\nNovember 9, 2017 at 2:42 am\n\nReply\n\nImpressive work, great comparison , we apreciat this work that can help in\nchoice of microcontroller to design an application. I have learned a lot. Many\nThanks\n\nBah\n\nNovember 11, 2017 at 10:13 am\n\nReply\n\nThis is one excreably crappy site. There\u2019s text but I can\u2019t read it because\nall the shitty reinventing-the-obvious with much too much javascript.\n\nTroll Detector\n\nJanuary 9, 2018 at 10:34 am\n\nReply\n\nTroll Alert\n\nCameron\n\nNovember 13, 2017 at 3:44 pm\n\nReply\n\nCheers Jay, Thank you for such a deep comparison. Judging from the other\nthings on your site, I\u2019d love to see a write-up from you on embedded Linux /\nRTOS functionality on the bigger brothers of some of these. You\u2019ve got me as a\nsubscriber, no matter what you\u2019re working non next. -cb\n\nGeorge A. Chapman\n\nNovember 14, 2017 at 10:20 pm\n\nReply\n\nAVR 1. \u201cAnd interrupts are one of the weak points of the AVR core: there\u2019s\nonly one interrupt priority, ...\u201d tinyAVR 1-series has two interrupt priority\nlevels (datasheet, CPUINT) 2. like megaAVR, tinyAVR 1-series is Harvard\narchitecture but with unified memory (datasheet, Memories, Memory Map) 3.\ntinyAVR 1-series UPDI is more capable than megaAVR debugWIRE\n\nParametric Reach megaAVR XMEGA AVR are a follow-on to some megaAVR. \u2014\nATmega2561 \u2013 16MHz, 64 pins, 256KB, 8KB ATxmega384C3 \u2013 32MHz, 64 pins, 384KB,\n32KB \u2014 ATmega1280 \u2013 16MHz, 100 pins, 128KB, 8KB + 56KB on EBI ATxmega128A1U \u2013\n32MHz, 100 pins, 128KB, 8KB + 16MB on EBI\n\nAtmel Studio \u201cThe excellent IntelliSense engine that Microsoft spent years\nperfecting has been replaced by some sort of Atmel-proprietary \u201cVisual Assist\u201d\ntechnology that ...\u201d 1. IntelliSense and AVR is available from third\nparty(ies) 2. Visual Assist from Whole Tomato Software\n\nMicrochip Customizations \u201cAs these compilers [XC] are quite expensive and ...\u201d\nAbout 1USD/day though the dongle is 1495USD\n\nDiscussion megaAVR \u201cWhile the megaAVR has a perplexing debugging experience\nthat requires two completely different interfaces and protocols to work with\nthe part, ...\u201d fyi, once debugWIRE is enabled then stay with it until done.\n\u201c... low-cost, open-source programmers (which don\u2019t support the UPDI\ninterface).\u201d pyupdi is Python UPDI programming via an inexpensive USB UART;\ndebug via UPDI is currently only Atmel-ICE or Power Debugger\n\nPIC32 \u201c... expensive compilers ...\u201d Can chipKIT PIC32 GCC be invoked from\nMPLAB X?\n\nThank you!\n\n\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014 Notes 1. IntelliSense with most AVR is available from VisualGDB\n2. IntelliSense is in Visual Studio Code and AVR might be available via the\nNative Debug extension 3. The next release of PlatformIO may restore AVR\ndebugging; Visual Studio(s) are some of the IDE that integrate PlatformIO 4.\nLLVM AVR may be a current or future alternate to AVR GCC 5. ATmega328PB is\napproaching 1USD each for 100 though it has a supply and demand problem that\u2019s\neasing 17Q4 (should be resolved 18Q1) 6. 32KB tinyAVR 1-series is likely for\n\u201918 and probably under the price limit\n\nRef. VisualGDB, https://visualgdb.com/tutorials/avr/ Visual Studio Code,\nhttps://code.visualstudio.com/ Native Debug,\nhttps://marketplace.visualstudio.com/items?itemName=webfreak.debug PlatformIO,\nAVR, http://platformio.org/platforms/atmelavr PlatformIO for Visual Studio\nCode,\nhttps://marketplace.visualstudio.com/items?itemName=formulahendry.platformio\nWhole Tomato Software, https://www.wholetomato.com/default.asp XC8 PRO\nsubscription,\nhttp://www.microchip.com/Developmenttools/ProductDetails.aspx?PartNO=SW006021-SUB\nFeatured MPLAB XC Compiler Licenses,\nhttp://new.microchipdirect.com/product/Cat10_SubCat12 LLVM, Changes to the AVR\nTarget, http://releases.llvm.org/5.0.0/docs/ReleaseNotes.html#changes-to-the-\navr-target Python UPDI driver for programming \u201cnew\u201d tinyAVR devices,\nhttps://github.com/mraardvark/pyupdi/ chipKIT, http://chipkit.net/\n\nDmitry\n\nNovember 19, 2017 at 12:42 pm\n\nReply\n\nSome little nitpicks: > From left, the STM32, PSoC 4000S, Microchip SAM D10,\nSilicon Labs EFM8, and NXP Kinetis KL03 development boards. The first board on\nthis photo is actually an STM8 board. You also tell that STM32Discovery is a\nsnap-apart board \u2014 that\u2019s again an attribute of STM8Discovery.\n\n> I also hope these open-source projects can add UPDI support to their tools\n> There is an open-source UPI programmer already! And it is really simple to\n> make: https://github.com/mraardvark/pyupdi Unfortunately, I don\u2019t have new\n> tiny parts lying around, so I couldn\u2019t test this one.\n\nBrett Smith\n\nNovember 19, 2017 at 1:07 pm\n\nReply\n\nGreat write up, confirms my feeling that the STM32 is the right choice for my\nnext project. One small corrections.\n\nOne small correction. DMX-512 has 512 bytes after the start bit (the \u201c0\u201d) not\n511. The \u201c0\u201d is an optional start code to say that the data is something other\nthan raw control data.\n\nPaul Carpenter\n\nNovember 21, 2017 at 10:31 am\n\nReply\n\nActually yes DMX-512 is up to 512 bytes after a START code like a \u20180\u2019 See\nstandard avalailable from http://www.plasa.org\n\nHowever the \u20180\u2019 is NOT optional it is mandatory as this is theDimmer\nCl;assData stating that up to the next 512 bytes are 8 bit fader levels.\n\nThe START code MUST be processed and actioned appropriately depending on its\nvalue and should NEVER be assumed to always be \u20180\u2019 (NULL as defined in the\nstandard). It is never optional.\n\nDMX-512 Annex D states other start codes are reserved with codes in DECIMAL\n\n23 ASCII text packet 85 Test packet (network test) 144 UTF-8 Text packet 146 \u2013\n169 reserved 171 \u2013 205 reserved 207 System Information Packet 240 \u2013 247\nexperimental do not use\n\nMorsy\n\nNovember 19, 2017 at 2:23 pm\n\nReply\n\nThank you\n\nRando\n\nNovember 20, 2017 at 7:54 pm\n\nReply\n\nDouble Thank You!\n\nAndy\n\nNovember 20, 2017 at 8:48 pm\n\nReply\n\nGreat post, very interesting. I\u2019m a big fan of the MSP430 myself, mainly for\nthe low power capability. I find them relative easy to program/debug with GCC.\nThough its not a $1 part TI have a special offer($4.30) on the new FR2433\nLaunchpad if you want to grab some, I just got 2. I have just built a custom\nboard with mighty MSP430FR5994., 4 UART and 4SPI/I2C. Nowhere near 1$ but\nmakes me smile.\n\nThanks again\n\nTomasz\n\nNovember 21, 2017 at 9:44 am\n\nReply\n\nVery good job! And I\u2019d have suggestion to make another review of \u2018under fiver\u2019\nwireless SoC\u2019s. Whatever usable for sensor apps etc. Recently I started using\nNordic nRF52 and I\u2019m impressed by these Arm-CortexM4 capabilities, say nothing\nabout low power power operation and excellent wireless (I use Nordic custom\nprotocols and shy away from BLE stack) . All important is excellent SDK with\nexamples, all producing small efficient code. Cheers!\n\nJohnny Hansen\n\nNovember 21, 2017 at 2:14 pm\n\nReply\n\nReally impressive work.\n\nPlease concider Renesas Rx100 series as well. Extreemly core efficient and\n<1USD as well.\n\nMartin Klingensmith\n\nNovember 29, 2017 at 6:47 am\n\nReply\n\nThe PIC16 discussion is nostalgic to me because I spent several years writing\nassembly code for PIC16 and PIC18. The old version of MPLAB before it became\nNetBeans was very quick. Low on fancy features, but you could\ncompile/program/debug in seconds. The newer MPLABX was a tough pill to\nswallow.\n\nAlso I\u2019m glad to see you reinforce my experience with Atmel START. Should be\ncalled Atmel STOP.\n\nLarry Affelt\n\nDecember 1, 2017 at 8:45 pm\n\nReply\n\nGreat article with good comparative analysis! I started out with the Intel \u201951\ncores (still have my UV eraser), thru the Phillips/NXP \u201951 OTP and flash\nchips, and now my company is a Microchip house. Yes, the debugging has\nsignifigant delays but I have learned to live with that, I\u2019ve had worse! I\nhave used everything from 8 pin PIC12F\u2019s to 144 pin PIC32MZ parts and found\nthat the upgrade paths are rather easy as the pinouts rarely change within the\nsame package, and once you get used to the IDE and have a good code base to\nwork from I can develop new designs fairly quickly. Besides, once you get used\nto an environment it is such a pain to switch to another manufacturer\u2019s tools\n...\n\nThanks, I am looking forward to reading more of your website and updates!\n\nBerwyn\n\nDecember 1, 2017 at 11:17 pm\n\nReply\n\nThis is impressive. I\u2019m a complete fan.\n\nOne thing missing is packaging \u2014 from the comparison tables. Many projects\nneed to make choices based on this. Depending on project, selection commonly\nincludes conflicting criteria: \u2013 smallest package \u2013 most I/O pins \u2013 hand-\nsolderable Having these in a comparison table would be very useful.\n\nAjoy Raman\n\nDecember 2, 2017 at 6:06 am\n\nReply\n\nWonderful work!\n\nI have been using PIC devices which are 8-10 years old and experimenting with\nthe Arduino and MSP430 series. Your excellent comparative study will be a\ngreat help while migrating to current devices. \u2014 IDE licencing aspects could\nbe a point worth enumerating.\n\nmichael\n\nDecember 2, 2017 at 9:33 am\n\nReply\n\nHi\n\nI\u2019m quite impressed by the work you have done. It\u2019s a lot of material to read\nand reading it reminded me how many hours i have spent in frustration. As for\nmy personal point of view what is the best to choose . Well i believe every\nexperienced engineer finds it\u2019s way to work effectively with mcu weaknesses\nafter crossing the 8 bit gap and moving to 32 bits .As to what is the best to\nuse the most important thing is \u201cSecond source \u201d or compatible chip. Strange\nyou might think but bottom line that\u2019s the weak point of all MCU vendors No\nmatter how good or bad a chip is the menace of all is when you have to buy at\ndouble price or wait 4-6 months . Using MCU\u2019s as hobby is ok but when you\ndecide to make a leaving things change . Based on that i believe the choise is\nclear among various chips you examined . Thank you for the good job you made\n!!!!!\n\nAlvin P Schmitt\n\nDecember 3, 2017 at 4:11 am\n\nReply\n\nDo you have a .pdf of this paper?\n\nSome Guy\n\nJune 29, 2018 at 7:03 pm\n\nReply\n\nChrome will print to pdf\n\nfreescaleisdead\n\nDecember 6, 2017 at 3:19 pm\n\nReply\n\nGreat work. And I applaud you for having the guts to state the sad truth about\nthe direction NXP has chosen with their Espresso toolset. Abandoning Processor\nExpert is a crime. It has been one of the best tools of its kind. I understand\ntheir need to have a toolset that supports all of the legacy NXP processors,\nbut they are penalizing all of the Freescale users in the process. It\u2019s going\nto make me think twice on what platform I use for future projects. ST is\nlooking quite good at this point!\n\nAndrew Kowalczyk\n\nDecember 17, 2017 at 10:06 pm\n\nReply\n\nI just want to say thank you, I\u2019ve been reading over this for the past two\ndays and I feel like I could keep doing that for weeks or months with all the\nexcellent information here. I\u2019ve worked a lot with msp430s and STM32s lately,\nbut I now really want to try the SiLabs 8-bit and 32-bit offerings (even\nthough they\u2019re not listed).\n\nOne of the things that I think this addresses better than any other \u201cgetting\nstarted\u201d is the toolchains and debuggers, I\u2019m a huge fan of Eclipse-based\nofferings like Code Composer and Atollic TrueStudio, so anything with a\nsimilar debug setup seems like a good idea to try out. Same goes for debug\ntools: this is the first time I\u2019ve seen debug tools as a consideration for a\ncomparison for part usability, and it echoes the same problems I encountered\ntrying to work with the AVR and PIC parts on Windows.\n\nThanks again, and I look forward to seeing future projects.\n\nBrandon\n\nDecember 27, 2017 at 9:19 am\n\nReply\n\nGreat comparison. I\u2019m an Atmel fan myself \u2013 Atmel Studio has been nicely\nstable for me for the last couple years, although I remember when it was far\nworse. And the AtmelICE is actually a deal for a hobbyist \u2013 for $140 (less if\nyou skip some accessories), you have complete source-level debugging to all\nAVR and SAM devices \u2013 that\u2019s a big tool to put in the toolbox.\n\nAtmel ASF can be good or bad. I like the minimalist approach on AVRs \u2013 sure,\nit doesn\u2019t give you structure bit fields, but I know what to do to get that\nkind of operation anyway. On the other hand, some of the SAM ASF packages have\nbeen nightmares to work with \u2013 confusing, bloated and hazy documentation (I\u2019m\nlooking at you, Cortex M0+ parts...).\n\nI was glad to see information about Renasas \u2013 that\u2019s one brand I\u2019ve wondered\nabout but thought it was kind of out of reach. Maybe it\u2019s worth a closer look\nnow.\n\nasdf\n\nJanuary 25, 2018 at 4:42 pm\n\nReply\n\nNitpick: The PIC32MM uses the microAptiv UC core, not M4K like the older\nPIC32MX.\n\nJim K.\n\nJanuary 29, 2018 at 1:09 pm\n\nReply\n\nGreat article...lots of good work!!!!\n\nThe MSP430FR2111 is out of the price range for this shootout. I looked on\nFindchips. Arrow has it for $1.38. Digikey sells quantity of one at $1.25.\nYour chart lists the Flash size at 16K. It\u2019s actually a paultry 3.75 K.\n\nA more comparable part is MSP430FR2433 15.K of Flash and 4K of ram...$2.27 for\nquantity 1 from Arrow. Not a cheap family.\n\nThe new ATTiny chips run from $0.75-$0.98 for quantities of one at Digikey.\nI\u2019m waiting for the 32K part to hit the market.\n\nDavid\n\nJanuary 30, 2018 at 8:55 pm\n\nReply\n\nExcellent!\n\nBut I have a double about the \u201cPERIPHERALS/FLASH/Holtek HT66 8K\u201d\n\nWhich MCU do you select? The HT66F0185 have only 4K flash. And the new\nHT66F019 have 8K.\n\nThanks.\n\nDean\n\nFebruary 2, 2018 at 9:55 pm\n\nReply\n\nExcellent write up, thank you for investing the time, extremely useful. Would\nbe great to see the comparison with ESP32, or another article on the wireless\nchips.\n\nSerg\n\nFebruary 16, 2018 at 7:46 am\n\nReply\n\nhttps://www.digikey.com/product-\ndetail/en/stmicroelectronics/STM32F318K8U6/STM32F318K8U6-ND/5268270 1.3$ with\nFPU\n\nJonathan\n\nFebruary 20, 2018 at 9:56 am\n\nReply\n\nHi, thanks very much for your excellent write-up. Just a point to note \u2013 since\nST bought Atollic at the end of 2017, the TrueStudio IDE is now free for\nSTM32s. Paired with STs ST-Link V2 debugger, it makes a nice (and cheap)\ndevelopment environment for the STMs.\n\nEelco\n\nFebruary 24, 2018 at 3:40 am\n\nReply\n\nDear Jay,\n\nI can\u2019t thank you enough. Bringing together all of this information is\nabsolutely great! Yet, like everyone else I have some personal preferences\nwhen choosing an microcontroller. I\u2019m an old fart and grew up programming the\nMC6809 CPU in assembly with it\u2019s lovely CISC core. Fast forward to 2018 if I\nhad to choose now I would probably not go for a ARM cortex-m0 MCU but look\ntoward the S12Z MagniV MCU series from NXP (Freescale). Unlike the older S12X\nseries from NXP the S12Z has a nice CISC CPU core with real 32-bit registers\nand a real 24-bit programcounter so swapping pages is not needed any more.\nThese are automotive parts and can withstand some electrical abuse. The errata\nfrom the S12ZVL ($2,45 @ DigiKey) is only six pages long! I know in this day\nan age one should be programming in a high level language like C and not pay\nattention to what is underneath. But I like to know what\u2019s underneath and\nstill be able to program the things underneath in assembly language.\n\nhobby16\n\nFebruary 25, 2018 at 1:46 pm\n\nReply\n\nThank you for your awesome review, simply awewome!\n\nAbout the STM8S that I know well, I must add that what it makes it very\nattractive is there are plenty of cheap Chinese functioning modules based on\nit, thermostat with led display, adjustable power supplies, pwm generator...\nYou can buy them for peanuts and then reprogram them for your own purpose. For\nexample, a STM8S003F3 based thermostat board with led display, buttons, relay\nand NTC costs less than 2$ (!). See a (very partial) list here :\nhttps://github.com/TG9541/stm8ef/wiki/STM8S-Value-Line-Gadgets\n\nAnother thing, you said \u201cin that regard, you get what you pay for: STVD feels\ntrapped in 2002, and there\u2019s no way to set up a more modern development and\ndebugging environment for it\u201d. That would be unfair if you don\u2019t mention the\nIAR IDE, which let you do codes up to 8kB which is precisely enough for the\nSTM8S003F3 & STM8S103F3 which has 8kB. It\u2019s works at the get go, you can use\nit to compile a very efficient code and debug in realtime with the ST-Link\ndongle\u2019s SWIM interface. I use the IAR IDE to develop and reprogram a digital\nVolt-ammeter to make the \u201cCharge Doctor\u201d, a product quite well known by\nelectric wheelers : http://hobby16.neowp.fr/2016/11/07/charge-\ndoctor-v2-firmware-v-2-03-2/ All the code is less than 8kB, something I could\nnot cram in using the SDCC, so IAR has a really really good IDE and compiler,\nall for free, as long as the code doesn\u2019t exceed 8kB.\n\nLast word, the STM8S003F3 has been so successful that Nuvoton has now its pin-\nto-pin compatible SSOP-20 chip N76E003. It seems a good replacement, with 12\nbit adc (instead of 10 bit) and 16k (instead of 8k) and costing just around 15\ncts, half the price of the STM8S003F3 (!). The STM8S003F3 in some of the\nmodules above are now shipped with the N76E003. I have bought a batch of one\nhundred Volt-ammeters expecting them to have the STM8S but instead they have\nthe N76E003, it was quite a bad surprise. Now it would be neat if I can find a\nway to port (and debug, if possible) my code to the N76E003 without paying a\nfull fledged IDE from Keil or IAR. I\u2019m still searching, if someone knows...\n\nBiteFeek\n\nDecember 12, 2018 at 2:20 am\n\nReply\n\nUse CODE BLOCS +SDCC 3.8.3+ (snapshot build) \u2013 will work out of the box, load\nwith Nu MICRO ICP programm tool (same for their ARM chips). The stable SDCC\n3.8.0 will have a bug with TA protected SFR (I used peephole optimization and\naltered headers ). With SDCC 3.8.3+, you can just port headers from Keil\nversion. IAR with 8051 sucks- you need do almoust the same as in SDCC and pay\nfor it..., IAR the only way if you need C++ compiler for 8051... Porting from\nKeil to SDCC works almoust as copy-paste (that the reason I use Keil to debug\nhard snipset of code using IAP, other way UART is quite anought right from\nSDCC) Here good article how to start with SDCC+Nuvoton N76E003\nhttps://danchouzhou.blogspot.com/2018/06/sdccn76e003-1t-8051.html (use\ntranslate option in Chrome \u2013 advise from Captain Obvious)\n\nBiteFeek\n\nDecember 12, 2018 at 11:55 pm\n\nReply\n\nThe legal way to use N76E003 is CodeBlocks + SDCC 3.8.3+ (snap build) and\nNuMicro ICP for download with Nu-link (this is the same as for their Cortex).\nStable SDCC 3.8.0 will brought problem with TA protected SFR (possible to use\npeep hole optimization for skip this in 3.8.0). KEIL permit on-chip debug with\nNu-link, and I use it for debug snipsets of code. Hiders for SDCC you can port\nfrom Keil version easy and code porting from Keil is almoust copy-pase. IAR\nfor 8051 is sucks,but it is only way if you use C++.\nSo...https://danchouzhou.blogspot.com/2018/06/sdccn76e003-1t-8051.html \u2013 you\ncan look here for start with N76E003 (use option Translate in Chrome, advise\nby Cap.)\n\nMax Chan\n\nApril 3, 2018 at 8:47 am\n\nReply\n\nSTC is very heavily used in Chinese products. (I am from China...) but the\ncompany behind it (along with a good selection of other Chinese companies)\ndoes not want to provide support for foreign customers likely due to a\nlanguage barrier: there isn\u2019t enough Chinese FAE that is proficient enough in\nEnglish. Their parts are certainly dead cheap too, with the cheapest fetching\n20 US cents each or lower.\n\nHarry\n\nJuly 10, 2018 at 1:09 pm\n\nReply\n\nWhich company is behind STC? we are looking for micros under $0.10 US\n\nDaniel\n\nMay 30, 2018 at 7:01 pm\n\nReply\n\nI\u2019m incredibly impressed not only with the shear amount of detailed\ninformation present here, but also the high quality of your website. I heard\nabout \u201cThe amazing $1 microcontroller\u201d on the MacroFab Engineering Podcast\n(https://macrofab.com/blog/podcast/) episode #119. I\u2019ll be keeping an eye out\nfor future posts! Keep up the great work.\n\nGeorge A. Chapman\n\nJuly 3, 2018 at 7:17 pm\n\nReply\n\nATmega3208 in QFN has crossed the 1USD threshold :\nhttps://www.microchipdirect.com/product/ATMEGA3208\nhttps://www.microchip.com/wwwproducts/en/ATMEGA3208 It could be considered as\na follow-on to ATmega328PB and is in the megaAVR 0-series. megaAVR 0-series\nhas unified memory (typical AVR has multiple memory areas) AVR GCC 8.1 is\nreleased and may be relatively easy to extend to megaAVR 0-series; otherwise,\nthe Microchip AVR GCC toolchain.\n\nStephen\n\nJuly 9, 2018 at 5:48 am\n\nReply\n\nGreat article, i will share this article to my technical friends. Great jobs\nyou have done.\n\nPierre\n\nJuly 21, 2018 at 8:33 pm\n\nReply\n\nAmazing work and article ! Thank you. As others already have pointed out, I\u2019d\nlove to read about embedded Linux / RTOS functionality on the bigger brothers\nof some of these, and/or about wireless chips. Hats off !\n\nRom\n\nAugust 8, 2018 at 3:24 am\n\nReply\n\nActually, there is a standalone tool for loading code into this part. It\u2019s\ncalled NuMicro ICP Programming Tool, which I\u2019m currently using with a clone\nprogrammer.\n\nMarco Becagli\n\nAugust 26, 2018 at 7:04 am\n\nReply\n\nHello Jay Many thanks for the article -excellent-, that helps me to choose an\nMCU to replace the -now obsolete- NXP\u2019s LPC family, built with 8051 core.\n\nMicrochip states on its websites that il still producing AT89LP51ID2 (and\nother MCUs engineered by ATMEL, acquired by Microchip two years ago), with\n8051 core and PLCC package, good for hobbiest propotypes. Why you didn\u2019t\ninclude an ATMEL 8051 core MCU between the others (AVR and ARM type) listed\nfrom the same factory?\n\nMany thanks Marco Becagli\n\nJay\n\nOctober 11, 2018 at 5:13 pm\n\nReply\n\nMarco \u2014 thanks for the suggestion! I\u2019m wondering if Microchip has slashed\nprices on these AT89 parts recently \u2014 if I remember right, at the time of the\nreview, these parts were all more than $1 @ 100 qty. I might be mistaken,\nthough.\n\nEven then, I\u2019m not sure I\u2019d make space in the review for these crusty, old\nparts. In the $1 price bracket, the AT89s are severely lacking: no ADC, no I2C\nperipheral (and few have a dedicated SPI peripheral), only two timers, no\nXRAM, and no on-chip debugging. Basically just a stock 8051. Definitely relics\nfrom a different era \u2014 especially when compared to modern 8051s from SiLabs\nand the Chinese/Taiwanese companies.\n\nJCF\n\nMay 9, 2019 at 7:07 am\n\nReply\n\nAT89LPs are one clock per cycle parts with some members that include built in\n(but really bad) ADCs. They include SPI, I2C, 3 16-bit times plus PCA, and\nindependent baud rate generator. Furthermore, some of them have a 16\u00d716\nmultiply\u2013accumulate unit that will result on a extremely fast filter\nimplementation. Additionally, the stack can be configured to use xdata memory!\n\navg\n\nOctober 11, 2018 at 4:36 pm\n\nReply\n\nThank you for this great writeup. I cannot imagine how much time and effort\nyou put into it!\n\nIts a little bit unfortunate that esp8266 and esp32 did not made it into\ncomparison ?\n\nJay\n\nOctober 11, 2018 at 5:24 pm\n\nReply\n\nThanks!\n\nRegarding the ESP stuff, there have been several requests for that. At the\ntime, neither of those MCUs were available from U.S.-based vendors for less\nthan $1 (especially when you figure in the external SPI flash you need).\nThat\u2019s the technical disqualification.\n\nBut more broadly, this is a comparison article, and the ESP32 and ESP8266 are\nquite different parts than the general-purpose MCUs in this write-up. I feel\nlike if you\u2019re struggling to choose between a PIC16, an STM32F0, and an\nESP8266, you probably need to take a step back and re-evaluate your product\nrequirements\n\nB. Perry\n\nNovember 13, 2018 at 5:22 pm\n\nReply\n\nThis is an excellent comparison. Best I\u2019ve ever seen.\n\nmeena\n\nJanuary 18, 2019 at 7:27 am\n\nReply\n\nThank you!\n\nRobert J Rossi\n\nFebruary 11, 2019 at 5:43 pm\n\nReply\n\nThank you for doing such a great job. Really Great! Thank you.\n\nGreg\n\nFebruary 11, 2019 at 6:38 pm\n\nReply\n\nIt would be helpful to have an overall performance ranking as well as\ncomparison table of key criteria when for making chip selections.\n\nGreat article though.\n\nTom\n\nMay 7, 2019 at 6:41 pm\n\nReply\n\nwow, been researching the web for several years looking for a comparison like\nthis. great job\n\nJim Frimmel\n\nMay 7, 2019 at 7:32 pm\n\nReply\n\nGreat comparison study! I suggest that you might add the Espressif ESP and\nESP32 devices at\n\nhttps://www.espressif.com/en/products/hardware/socs\n\nThese are based on the Xtensa 32-bit processor architecture by Cadence\nTensilica:\n\nhttps://ip.cadence.com/ipportfolio/tensilica-ip\n\nPatrick\n\nMay 26, 2019 at 6:56 pm\n\nReply\n\nThank you for the time you took to assemble this information. Very useful!\n\nAdil Khan\n\nSeptember 30, 2019 at 2:00 am\n\nReply\n\nThank you for such a structured article and the comparison is just wonderful\nand insightful. I am enjoying these series of articles, please when you can\nadd more to STM32F4 controllers. I am also a fan of ESP-32 and would like to\nsee what your thoughts are on multi-core controllers, specifically are they\nworth the effort and time investment? One curious controller is the Parallex\nCOG processor, do you have any comments on it when comparing it to ESP-32?\n\nLaur\n\nOctober 14, 2019 at 5:46 am\n\nReply\n\nMicrochip supports UPDI in PicKit 4, supposedly since this July.\n\nmdolton\n\nOctober 24, 2019 at 6:42 pm\n\nReply\n\nExcellent write up. A comprehensive aggregation of metrics for any engineer,\nespecially those who may be entrenched with one particular micro line or\nanother. It is great to see creative score keeping and a homogenized analysis\namong different micro variants.\n\nOne additional metric under peripherals that would be helpful to the audience,\nespecially when using the DMX protocol as a test method, is serial (UART) baud\nrate accuracy. That is, how much error each micro scores at higher baud rates\nwith their respective clock trees. This analysis may help avoid the proverbial\nresponse \u201cJust run it at 9600 baud and you\u2019ll be fine\u201d\n\nJay\n\nOctober 24, 2019 at 11:13 pm\n\nReply\n\nIt\u2019s been a while since I wrote this article, but I think I mentioned the\ninternal oscillator accuracy on the parts where it was an issue. Most modern\nparts seem to have a ~1% oscillator; the theoretical worst-case 8N1 UART\nallowable error rate is 5%, so you shouldn\u2019t have any problems with UART baud\naccuracy. The other source of error is UART baud divider rounding error, but\nDMX nicely side-steps that problem by using a 250 kbps data rate \u2014 evenly\ndivisible from any integer-MHz clock source. If you wanted to generate, say,\n115200, or one of the other weird UART bauds, obviously that can become an\nissue, but nicer parts have more flexible UART clock dividers. Honestly,\nbesides cell modems, GPS chips, and Bluetooth devices, UART is so rarely used\nfor actual interfacing, being able to generate accurate UART bauds is much\nless critical than it used to be. Even printing tracing messages over UART is\ngoing out of fashion with the Arm SWO debugging stuff.\n\nPeter Kobl\n\nDecember 27, 2019 at 5:54 am\n\nReply\n\nTremendous write-up, Jay Makes the internet all worth-while Thanks!\n\nSwedish IAR has a really really good IDE and compiler, all for free (as long\nas the code doesn\u2019t exceed 8kB). The general consensus seems to be that their\nC/C++ compiler is the best in the industry.\n\nThe IAR IDE is fast and compact (unlike Eclipse based IDEs) . The graphical\ninterface looks like something from the previous millennium but, for me, it\nhas done everything that Eclipse can do, but has done it leaner, faster, and\nbetter.\n\nIAR is an IDE kind of company. A software company, no hardware (actually not\nquite true as they started selling their own debug probe, I think recently).\n\nHundreds or thousands of MCUs from all kind of vendors are supported from the\nbasically identical IDE. Across the range from 8-bit MCUs to 32-bit ARMs.\n\nMany different debugging probes are supported including st-link, j-link,\nsegger, PE Micro etc. St-link is low low cost ($2) and personally I have used\nthe same st-link to program/debug msp432, stm32, and mkl03.\n\nSo, 1 IDE + 1 probe to learn about, in order to develop for hundreds of\ndifferent MCUs from most mainstream vendors, and as they say \u201cthe best IDE is\nthe one you know.\u201d\n\nDisclaimer: I am not associated with the IAR company\n\nPeter Kobl\n\nDecember 27, 2019 at 6:24 am\n\nReply\n\nHi Jay, Having just checked current pricing of some of your contending\nmicrocontrollers, I realize that the price on one of my go-tos, the\nSTM32F030F4P6TR, has dropped from $0.35 to $0.21 (quantity 10pcs, on\nAliexpress).\n\n$0.21 for an 48 MHz ARM Cortex-M0, SOIC-20, 16KB flash, 4KB RAM\n\nAn amazing 1 quarter ARM microcontroller (:-)\n\nGB Clark\n\nJanuary 4, 2020 at 8:20 am\n\nReply\n\nGreetings, With the discussion of the STM32F0 you only mention 2 other lines\nthe F4 and F7, but none of the other,s when it\u2019s much easier to go from the F0\nto the F1 or F3 than it is to the F4 or F7. Yes, the F1 and F3 have 72Mhz max,\nbut it\u2019s also an upgrade from the Cortext-M0 to either a Cortex-M3 or M4.\n\nOne of the things I love about the STM32\u2019s is once you hit 48\npins(specifically the LQFP48 package) it is easy to switch between the various\nlines. What I mean by easy having to modify no more than 3 or 4 pins to\nswitch. And in some cases you don\u2019t have to make ANY changes at all to make an\nupgrade. As an example of this is when recently I wanted to upgrade a meter\nthat at time was using a \u201cBlue Pill\u201d F103 board as it controller to a F3\nchip(floating point and DSP). I was literally able to take hot air to a Blue\nPill and remove the F103 and put a F303CC in it\u2019s place in about 10 min. This\nupgraded the controller from a 64K/20K M3 to a 256K/40K M4 with DSP and\nhardware floating point. Sure I had to change the firmware, but even that is\neasy if your using a good HAL layer.\n\nThe reverse also applies. The Cortext-M0/M0+ architectures do not support the\nfull debug capabilities that either the M3 or M4 support. So I\u2019ll do my intial\nhardware design using a F103 and then \u201cdowngrade\u201d to a F0XX.\n\nLeo Gray\n\nFebruary 21, 2020 at 7:43 am\n\nReply\n\nLove your work. This is amazing to look at and I have run out of words to\ndiscribe it.\n\nI didn\u2019t even know some of the company exists before you mentioned it.\n\nI wish I have saw this eariler which will save my a couple hundard parts\nbuying debuggers and wrong chips.\n\nJ. Krueger\n\nMarch 28, 2020 at 8:36 pm\n\nReply\n\nI miss the parts from ZILOG. Their 8-bit-derivates are z8 and 8051, too.\n\nJohn W Koon\n\nSeptember 11, 2020 at 6:59 pm\n\nReply\n\nNice\n\nlyrl\n\nOctober 17, 2020 at 1:21 pm\n\nReply\n\nThank you for sharing your valuable experience.\n\nWilliam J Sell\n\nOctober 22, 2020 at 6:00 pm\n\nReply\n\nVery great work. I think it would be interesting to redo the review on the\nIDE\u2019s and Code Generators to see which vendor continues to fully support and\nenhance their tools. MCUXpresso has definitely improved with the code\ngeneration tool. Atmel code generator is still god-awful (IMO), and the code\nbloat it generates really turns me off the SAMD10; a great shame as the chip\nis very good. Code Composer has also improved a great deal and as you\nmentioned the enumerations of the register is a god-send. Ultimately I think\nwe build in prejudices over the years and migrate to where we feel\ncomfortable. Certainly articles like this pique interest again into vendors we\nmay have long ago abandoned\n\nKen Perry\n\nDecember 15, 2020 at 7:36 am\n\nReply\n\nYou really should add the Propeller 32 bit into this review.\nhttps://www.parallax.com/propeller-2/\n\nIt has an older propeller 1 as well that still is a very good chip but this\npropeller 2 is just amazing.\n\nJay Carlson\n\nDecember 15, 2020 at 9:41 am\n\nReply\n\nYou think I should add a $15 processor to a review called The Amazing $1\nMicrocontroller? I\u2019ll take it under consideration.\n\nVictor\n\nJanuary 5, 2021 at 4:07 am\n\nReply\n\nThank you so much for this blog. It is extremely useful and well explained.\nBest site I have seen in the internet in a while.\n\nTom Bull\n\nJanuary 31, 2021 at 12:27 pm\n\nReply\n\nAnother MCU with an integrated MAC + PHY is the WizNet W7500P, they have a\nCortex M0 with a fairly meh selection of peripherals, an ethernet MAC based on\nthe W5500, and a PHY based on the IP101G all integrated. And they\u2019re about $3\nin quantities of 100, which is \u2013 I believe \u2013 the cheapest of the MCUs that\nincludes a PHY.\n\nRK\n\nFebruary 23, 2021 at 1:02 am\n\nReply\n\nAny thoughts on the Simplicity Studio 5 overhaul, vs. version 4?\n\nJohn C\n\nApril 8, 2021 at 5:11 am\n\nReply\n\nGreat work, I would love to know where the Renesas RX series fits in. Thanks\nagain.\n\nFabi\u00e1n Romo\n\nApril 21, 2021 at 8:42 pm\n\nReply\n\nAny mention of Harmony 3? (MCHP)\n\nGeorg Icking-Konert\n\nMay 13, 2021 at 1:15 am\n\nReply\n\nHi Jay,\n\ngreat overview, thanks for that!\n\nFor STM8, which compiler toolchain did you use for the performance tests, and\nhow do I interpret the result? Specifically I re-ran the biquad test using the\nOSS SDCC toolchain with PlatformIO IDE. The measured GPIO frequency/period is\n758.7Hz/1318\u03bcs, which is nowhere near the shown value of 79.49ksps. Can you\nplease \u201ctranslate\u201d?\n\nThanks a lot in advance and have a great day!\n\nBerg\n\nMay 19, 2021 at 6:28 pm\n\nReply\n\nThe STM32F103 could therefore be useful as the brains of some kind of a device\nto plug into your computer. The SiFive folks found this chip suitable to use\nas a USB-to-serial converter (providing a virtual serial port device over\nUSB), in Arduino Cinque \u2013 the RISC-V, ESP32, WiFi, Bluetooth Arduino. An\nalternative to purpose-built serial-USB chips like the FT232 or SiLabs CP2102,\ncommon in inexpensive ESP8266 boards. But the STM32F103 as a general-purpose\nmicrocontroller may be more flexible. There are plenty of device classes\nsupported by USB, this chip could become nearly any of them.\n\nDali liu\n\nJune 6, 2021 at 9:16 pm\n\nReply\n\nhey guys,I\u2019m an EE student from China,sorry to my broken English.In\nfact,usually we use STC MCU just because they are cheap enough and have a good\ndatasheet in Chinese(sorry but they offer the most detailed datasheet in\nChinese). And the college always taught us 8051 chips. In the recent fewer\nyears, a lot of Cortex-m devices which was made in China has been built and\nbecame more and more popular.They are cheap enough, just less than one dollar\nbefore the Covid-19 if you are live in China and use second-hand chip like\nus.I know this maybe very hard to understand but they are cheap enough for a\nstudent. If I choose the chip we need to check. Maybe I would buy some Cortex\nM3 and M4 devices and the 80251 chip like STC just launched. Best wishes.\n\nMarkus Aberle\n\nNovember 15, 2021 at 3:11 pm\n\nReply\n\nHi Jay, will you add the Raspberry Pi RP2040 also to your list?\nhttps://www.raspberrypi.com/products/rp2040/specifications/ And thank you for\nthe great overview. Best wishes\n\nMark\n\nFebruary 14, 2022 at 2:26 am\n\nReply\n\nThe ATtiny1616 is in fact an AVRxt core not AVRe.\n\nMatthew\n\nFebruary 26, 2022 at 3:43 pm\n\nReply\n\nWhen was this written and/or last updated? The microcontroller space changes\nso rapidly that it\u2019s hard to know how useful this is without understanding\nwhen it was all written.\n\nMario\n\nNovember 15, 2022 at 3:46 pm\n\nReply\n\nI miss the WCH microcontrollers under 1\u20ac and USB native: the 8bit 8051 style\nCH54X and CH55X (the CH552G is getting very popular nowadays) and the CH32Vxxx\n(RiscV with stm32 like peripherals).\n\nMaybe some other MCUs with integrated peripherals like the 32Bit Risc V\nCH579/CH582 (having PHY and/or Bluetooth peripherals).\n\nZoe\n\nNovember 3, 2023 at 5:33 pm\n\nReply\n\nDid you think about creating a universal HAL since you have tried that many\nenvironment?\n\nAdil Khan\n\nDecember 26, 2023 at 9:04 am\n\nReply\n\nThank you for such a informative and very enjoyable reading on a touch\nsubject. I like the thoroughness and treatment of various aspects of the MCUs\nand their peripherals. Another areas was the IDEs and development tools. I did\nnot see any details around the subject of Debugging the MCUs, but non the less\nyour writeup is extremely useful for anyone using these MCUs.\n\nThank you, Adil Khan USA\n\n### Leave a comment Cancel reply\n\n  * Rules\n  * Contenders\n  * Specs\n\n    * Core\n    * Peripherals\n    * Parametrics\n  * Ecosystem\n\n    * Dev Environments\n    * Code Generators\n    * Compilers\n    * Header Files\n    * Dev Tools\n  * Performance\n\n    * Bit Toggling\n    * Biquad\n    * DMX Receiver\n  * Discussion\n  * Conclusion\n\n2016 \u00a9 Copyrights CodexThemes\n\n", "frontpage": false}
