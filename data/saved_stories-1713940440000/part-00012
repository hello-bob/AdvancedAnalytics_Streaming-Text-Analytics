{"aid": "40135942", "title": "Spritely Goblins v0.13.0: Object persistence and easier IO", "url": "https://spritely.institute/news/spritely-goblins-v0130-object-persistence-and-easier-io.html", "domain": "spritely.institute", "votes": 22, "user": "paroneayea", "posted_at": "2024-04-23 19:11:10", "comments": 3, "source_title": "Spritely Goblins v0.13.0: Object Persistence and Easier IO!", "source_text": "Spritely Goblins v0.13.0: Object Persistence and Easier IO! -- Spritely\nInstitute\n\n[Donate]| [About]| [Jobs]| [News]| [Community]| [Goblins]| [Hoot]| [OCapN]  \n---|---|---|---|---|---|---|---  \n  \n# Spritely Goblins v0.13.0: Object Persistence and Easier IO!\n\nChristine Lemmer-Webber -- Tue 23 April 2024\n\nWe are thrilled to announce the release of our distributed programming\nenvironment Spritely Goblins version 0.13.0 for Goblins on Guile! This release\nhas two major new features: a powerful new object persistence mechanism (to\nsave your running programs to disk and wake them up later!), as well as a new\nabstraction which makes writing IO code much easier!\n\n(Note that there are no major protocol updates to OCapN functionality in this\nrelease, and there is not an accompanying release of Racket Goblins this\ntime.)\n\n## Persistence comes to Goblins\n\nImagine you're building out a fantasy dungeon crawler, modifiable by your\nusers at runtime. Your users are building rooms and putting NPCs here and\nthere and your world is evolving. But oh no -- it's time to restart your\ncomputer! How can you keep track of all these objects and bring them back\nlater?\n\nNow Spritely Goblins has the answer, incorporating a powerful new persistence\nmechanism (codenamed \"Aurie\") which empowers you to save relevant parts of a\nrunning Goblins program and wake them up later! But that's not all -- you can\nalso use Goblins' persistence system to upgrade your saved objects as they\nevolve, and it even helps making live hacking even more powerful since you can\nchange objects and reload them with upgraded behavior live!\n\nHere's an example of our persistence system in action:\n\nAbove we see a user playing a space shooter game named Terminal Phase written\non top of Spritely Goblins. In it, you can observe the player saving,\nquitting, and reopening the game. Although internally, reopening the game\ninitializes a distinct new process, which previously meant a new game state\nstarting at the beginning of the game, with the release of Goblins 0.13.0, we\nwere able to save all the state-setting Goblins objects to disk in the first\nsession and set them as the state of the new one. In other words, the player\ncan resume their session right where they left off!\n\nUnlike persistence systems common to some other Lisps and Smalltalk, Goblins'\npersistence system does not use \"orthogonal persistence\". Orthogonal\npersistence relies on the underlying programming language to implement\npersistence support and saves a \"running snapshot\" of the program as the\nprogramming language itself sees it. While a powerful approach, orthogonal\npersistence suffers from generally saving much more than the programmer may\nneed and tends to result in difficult to upgrade systems.\n\nGoblins' persistence system takes a different approach by using a technique\nwhich qualifies as \"manual persistence\", but in reality Goblins has also\nprovided tooling which makes most actors \"just work\" in terms of persistence,\nproviding the best of both of the worlds of manual and orthogonal persistence.\n\nGoblins' persistence system was also designed so that only the information\nwhich needs to be saved is saved. For instance, in the Terminal Phase example\nabove, the entire level need not be stored to memory, only the parts which are\non screen and the filename of the current level and progress therein in terms\nof how far the player has gotten need be stored. Every persisted object is\nalso tagged with a version (defaulting to 0 if none is provided) permitting\nthe user to perform an uprade at restoration time if appropriate.\n\nFor most use cases, adopting Goblins' persistence system will be\nstraightforward. Here is a classic and simple \"cell\" actor which may be\nfamiliar to many Goblins users:\n\n    \n    \n    (define (^cell bcom #:optional val) (case-lambda ;; Called with no arguments; return the current value [() val] ;; Called with one argument, we become a version of ourselves ;; with this new value [(new-val) (bcom (^cell bcom new-val))]))\n\nThe only thing that is needed to convert this cell to a persistence-compatible\ncell is to switch the top-level define to the new define-actor syntax:\n\n    \n    \n    (define-actor (^cell bcom #:optional val) (case-lambda ;; Called with no arguments; return the current value [() val] ;; Called with one argument, we become a version of ourselves ;; with this new value [(new-val) (bcom (^cell bcom new-val))]))\n\nThat's it! define-actor is a fancy new macro which takes the boilerplate out\nof writing most persisted objects. The above roughly expands to:\n\n    \n    \n    (define (^cell bcom #:optional val) (define cell-behavior (case-lambda ;; Called with no arguments; return the current value [() val] ;; Called with one argument, we become a version of ourselves ;; with this new value [(new-val) (bcom (^cell bcom new-val))])) ;; The self-portrait gives the information necessary to restore this ;; object later, by default by applying to the actor's constructor. (define (self-portrait) (list val)) (portraitize cell-behavior self-portrait))\n\nHowever, users in general will rarely need to use portraitize... for most\nusers, define-actor will be enough!\n\nEven though objects self-describe, Goblins' serialization system follows the\nsame capability security properties as Goblins itself. Objects cannot describe\nthemselves with more power than they actually have access to.\n\nOur persistence system also takes advantage of Goblins' transactional nature;\nwe can serialize only the delta of objects which have changed between messages\nhandled in the event loop by introspecting Goblins' transaction data,\nresulting in faster snapshots and less data saved to disk!\n\nThis is the first release of Goblins containing our persistence system; as\nsuch, we expect that usage will have some rough edges. In particular,\npersistence really only works for references to objects contained within one\nvat. We hope to remove this restriction in a future version of Goblins.\n\n## New, simpler IO\n\nOne of the most frequent requests for Goblins has been to introduce an IO\nsystem which \"felt like\" using Goblins. Previously, users had to understand\nthe details of programming in Fibers, the event loop system on which Goblins\nprograms run by default.\n\nNo longer! We are happy to announce a new addition to Goblins' actor-lib\nstandard library, the ^io actor from (goblins actor-lib io)! This object wraps\na protected IO resource and ensures that only one IO operation is handled at a\ntime without blocking the vat (event loop) in which the IO actor is spawned.\n\n## Getting the release\n\nThis release also includes a number of other bugfixes and minor features. See\nthe NEWS file for more information!\n\nYou can also get the latest Guile Goblins release using Guix:\n\n    \n    \n    $ guix pull $ guix install guile-goblins\n\nSee also the README for more ways to get guile-goblins for your operating\nsystem or distribution!\n\n## Bonus history!\n\nGoblins' persistence system was a major effort with a long history behind it.\nThe codename \"Aurie\" (and the flame-and-crystal-character associated with it,\nnamed after the Aurora Borealis) came from its predecessor, an independent\nlibrary for the Racket verison of Goblins.\n\nThe original conceptual designs from original-Aurie remain intact within\nSpritely Goblins, but the implementation and interface have been significantly\nrefactored.\n\nThe original version of Aurie was cumbersome to use; it is thanks to Jessica\nTallon, Spritely's enchantress of the goblin realm, who took Christine Lemmer-\nWebber's original proof-of-concept and transformed it into something much\neasier to use. We are all excited that Spritely Goblins now includes a\npowerful persistence system.\n\nFor more on the ideas behind Aurie, read Safe Serialization Under Mutual\nSuspicion by Mark S. Miller, by which Aurie is designed. Aurie also borrows\nheavily from an observation by Jonathan A. Rees made to Mark Miller, that\nserialization is uneval / unapply... we take exactly this technique in our\nimplementation, as Aurie can be thought of as a metacircular evaluator running\nin reverse!\n\n## Onwards we go!\n\nOf course, there's plenty more to do, and we're already working and looking\nahead to the next release! We are planning for v0.14 of Goblins to focus on\nimprovements to networking tooling in particular as well as various quality of\nlife improvements.\n\nIf you're making something with Goblins, or want to contribute to Goblins\nitself, join our community: community.spritely.institute for our forum and\n#spritely on irc.libera.chat for real-time chat! Hope to see you there!\n\nSite contents released under Creative Commons Attribution 4.0 International.\nPowered by Haunt.\n\n", "frontpage": true}
