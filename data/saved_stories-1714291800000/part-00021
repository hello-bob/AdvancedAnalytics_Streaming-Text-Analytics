{"aid": "40183317", "title": "Dependency Hell", "url": "https://en.wikipedia.org/wiki/Dependency_hell", "domain": "wikipedia.org", "votes": 1, "user": "mtmail", "posted_at": "2024-04-27 20:42:14", "comments": 0, "source_title": "Dependency hell", "source_text": "Dependency hell - Wikipedia\n\nJump to content\n\nSearch\n\n# Dependency hell\n\n  * \u0627\u0644\u0639\u0631\u0628\u064a\u0629\n  * \u010ce\u0161tina\n  * \ud55c\uad6d\uc5b4\n  * Hrvatski\n  * Magyar\n  * Polski\n  * Portugu\u00eas\n  * \u0420\u0443\u0441\u0441\u043a\u0438\u0439\n  * \u0423\u043a\u0440\u0430\u0457\u043d\u0441\u044c\u043a\u0430\n  * \u4e2d\u6587\n\nEdit links\n\nFrom Wikipedia, the free encyclopedia\n\nColloquial term for software requiring many conflicting dependencies\n\nDependency hell is a colloquial term for the frustration of some software\nusers who have installed software packages which have dependencies on specific\nversions of other software packages.^[1]\n\nThe dependency issue arises when several packages have dependencies on the\nsame shared packages or libraries, but they depend on different and\nincompatible versions of the shared packages. If the shared package or library\ncan only be installed in a single version, the user may need to address the\nproblem by obtaining newer or older versions of the dependent packages. This,\nin turn, may break other dependencies and push the problem to another set of\npackages.\n\n## Problems[edit]\n\nDependency hell takes several forms:\n\nMany dependencies\n\n    An application depends on many libraries, requiring lengthy downloads, large amounts of disk space, and being very portable (all libraries are already ported enabling the application itself to be ported easily). It can also be difficult to locate all the dependencies, which can be fixed by having a repository (see below). This is partly inevitable; an application built on a given computing platform (such as Java) requires that platform to be installed, but further applications do not require it. This is a particular problem if an application uses a small part of a big library (which can be solved by code refactoring), or a simple application relies on many libraries.^[2]\nLong chains of dependencies\n\n    If app depends on liba, which depends on libb, ..., which depends on libz. This is distinct from \"many dependencies\" if the dependencies must be resolved manually, e.g., on attempting to install app, the user is prompted to install liba first and on attempting to install liba, the user is then prompted to install libb, and so on. Sometimes, however, during this long chain of dependencies, conflicts arise where two different versions of the same package are required^[3] (see conflicting dependencies below). These long chains of dependencies can be solved by having a package manager that resolves all dependencies automatically. Other than being a hassle (to resolve all the dependencies manually), manual resolution can mask dependency cycles or conflicts.\nConflicting dependencies\n\n    Solving the dependencies for one software may break the compatibility of another in a similar fashion to whack-a-mole. If app1 depends on libfoo 1.2, and app2 depends on libfoo 1.3, and different versions of libfoo cannot be simultaneously installed, then app1 and app2 cannot simultaneously be used (or installed, if the installer checks dependencies). When possible, this is solved by allowing simultaneous installations of the different dependencies. Alternatively, the existing dependency, along with all software that depends on it, must be uninstalled in order to install the new dependency. A problem on Linux systems with installing packages from a different distributor (which is not recommended)^[citation needed] is that the resulting long chain of dependencies may lead to a conflicting version of the C standard library (e.g. the GNU C Library), on which thousands of packages depend. If this happens, the user will be prompted to uninstall all those packages.\nCircular dependencies\n\n    If application A depends upon and can't run without a specific version of application B, but application B, in turn, depends upon and can't run without a specific version of application A, then upgrading any application will break another. This scheme can be deeper in branching. Its impact can be quite heavy if it affects core systems or update software itself: a package manager (A), which requires specific run-time library (B) to function, may break itself (A) in the middle of the process when upgrading this library (B) to next version. Due to incorrect library (B) version, the package manager (A) is now broken, thus no rollback or downgrade of library (B) is possible. The usual solution is to download and deploy both applications, sometimes from within a temporary environment.\nPackage manager dependencies\n\n    It is possible^[4] for dependency hell to result from installing a prepared package via a package manager (e.g. APT), but this is unlikely since major package managers have matured and official repositories are well maintained. This is the case with current releases of Debian and major derivatives such as Ubuntu. Dependency hell, however, can result from installing a package directly via a package installer (e.g. RPM or dpkg).\nDiamond dependency\n\n    When a library A depends on libraries B and C, both B and C depend on library D, but B requires version D.1 and C requires version D.2. The build fails because only one version of D can exist in the final executable.\n    Package managers like yum^[5] are prone to have conflicts between packages of their repositories, causing dependency hell in Linux distributions such as CentOS and Red Hat Enterprise Linux.\n\n## Solutions[edit]\n\nRemoving dependencies\n\n    Many software libraries are written in a generous way, in an attempt to fulfill most users' needs, but sometimes only a small portion of functions are required in the host code. By examining the source, the functionality can be rewritten in a much more compact way (with respect to the license). In general, this can reduce significantly the application code and, later, the maintenance costs, and programmers can improve their software writing skills.\n\nVersion numbering\n\n    A very common solution to this problem is to have a standardized numbering system, wherein software uses a specific number for each version (aka major version), and also a subnumber for each revision (aka minor version), e.g.: 10.1, or 5.7. The major version only changes when programs that used that version will no longer be compatible. The minor version might change with even a simple revision that does not prevent other software from working with it. In cases like this, software packages can then simply request a component that has a particular major version, and any minor version (greater than or equal to a particular minor version). As such, they will continue to work, and dependencies will be resolved successfully, even if the minor version changes. Semantic Versioning (aka \"SemVer\"^[6]) is one example of an effort to generate a technical specification that employs specifically formatted numbers to create a software versioning scheme.\nPrivate per application versions\n\n    Windows File Protection introduced in Windows 2000 prevented applications from overwriting system DLLs. Developers were instead encouraged to use \"Private DLLs\", copies of libraries per application in the directory of the application. This uses the Windows search path characteristic that the local path is always prioritized before the system directory with the system wide libraries. This allows easy and effective shadowing of library versions by specific application ones, therefore preventing dependency hell.^[7]\n    PC-BSD, up to and including version 8.2, a predecessor of TrueOS (an operating system based on FreeBSD) places packages and dependencies into self-contained directories in /Programs, which avoids breakage if system libraries are upgraded or changed. It uses its own \"PBI\" (Push Button Installer) for package management.^[8]\nSide-by-side installation of multiple versions\n\n    The version numbering solution can be improved upon by elevating the version numbering to an operating system supported feature. This allows an application to request a module/library by a unique name and version number constraints, effectively transferring the responsibility for brokering library/module versions from the applications to the operating system. A shared module can then be placed in a central repository without the risk of breaking applications which are dependent on previous or later versions of the module. Each version gets its own entry, side by side with other versions of the same module.\n    This solution is used in Microsoft Windows operating systems since Windows Vista, where the Global Assembly Cache is an implementation of such a central registry with associated services and integrated with the installation system/package manager. Gentoo Linux solves this problem with a concept called slotting, which allows multiple versions of shared libraries to be installed.^[9]\nSmart package management\n\n    Some package managers can perform smart upgrades, in which interdependent software components are upgraded at the same time, thereby resolving the major number incompatibility issue too.\n    Many current Linux distributions have also implemented repository-based package management systems to try to solve the dependency problem. These systems are a layer on top of the RPM, dpkg, or other packaging systems that are designed to automatically resolve dependencies by searching in predefined software repositories. Examples of these systems include Apt, Yum, Urpmi, ZYpp, Portage, Pacman and others. Typically, the software repositories are FTP sites or websites, directories on the local computer or shared across a network or, much less commonly, directories on removable media such as CDs or DVDs. This eliminates dependency hell for software packaged in those repositories, which are typically maintained by the Linux distribution provider and mirrored worldwide. Although these repositories are often huge, it is not possible to have every piece of software in them, so dependency hell can still occur. In all cases, dependency hell is still faced by the repository maintainers.^[4]\nInstaller options\n\n    Because different pieces of software have different dependencies, it is possible to get into a vicious circle of dependency requirements, or an ever-expanding tree of requirements, as each new package demands several more be installed. Systems such as Debian's Advanced Packaging Tool can resolve this by presenting the user with a range of solutions, and allowing the user to accept or reject the solutions, as desired.\nEasy adaptability in programming\n\n    If application software is designed in such a way that its programmers are able to easily adapt the interface layer that deals with the OS, window manager or desktop environment to new or changing standards, then the programmers would only have to monitor notifications from the environment creators or component library designers and quickly adjust their software with updates for their users, all with minimal effort and a lack of costly and time-consuming redesign. This method would encourage programmers to pressure those upon whom they depend to maintain a reasonable notification process that is not onerous to anyone involved.\nStrict compatibility requirement in code development and maintenance\n\n    If the applications and libraries are developed and maintained with guaranteed downward compatibility in mind, any application or library can be replaced with a newer version at any time without breaking anything. While this does not alleviate the multitude of dependency, it does make the jobs of package managers or installers much easier.\nSoftware appliances\n\n    Another approach to avoiding dependency issues is to deploy applications as a software appliance. A software appliance encapsulates dependencies in a pre-integrated self-contained unit such that users no longer have to worry about resolving software dependencies. Instead the burden is shifted to developers of the software appliance. Containers and their images (such as those provided by Docker and Docker Hub) can be seen as an implementation of software appliances.\nPortable applications\n\n    An application (or version of an existing conventional application) that is completely self-contained and requires nothing to be already installed. It is coded to have all necessary components included, or is designed to keep all necessary files within its own directory, and will not create a dependency problem. These are often able to run independently of the system to which they are connected. Applications in RISC OS and the ROX Desktop for Linux use application directories, which work in much the same way: programs and their dependencies are self-contained in their own directories (folders).^[10]\n    This method of distribution has also proven useful when porting applications designed for Unix-like platforms to Windows, the most noticeable drawback being multiple installations of the same shared libraries. For example, Windows installers for gedit, GIMP, and HexChat all include identical copies of the GTK toolkit, which these programs use to render widgets. On the other hand, if different versions of GTK are required by each application, then this is the correct behavior and successfully avoids dependency hell.\n\n## Platform-specific[edit]\n\nOn specific computing platforms, \"dependency hell\" often goes by a local\nspecific name, generally the name of components.\n\n  * DLL Hell \u2013 a form of dependency hell occurring on 16-bit Microsoft Windows.\n  * Extension conflict \u2013 a form of dependency hell occurring on the classic Mac OS.\n  * JAR hell \u2013 a form of dependency hell occurring in the Java Runtime Environment before build tools like Apache Maven solved this problem in 2004.^[citation needed]\n  * RPM hell \u2013 a form of dependency hell occurring in the Red Hat distribution of Linux and other distributions that use RPM as a package manager.^[11]\n\n## See also[edit]\n\n  * Catch-22 a literary depiction of situations where something depends on its own negation\n  * Configuration management \u2013 techniques and tools for managing software versions\n  * Coupling \u2013 forms of dependency among software artifacts\n  * Dynamic dead code elimination\n  * Package manager\n  * PBI\n  * Software appliance\n  * Static library\n  * Supply chain attack\n  * Nix package manager\n  * Left-pad\n\n## References[edit]\n\n  1. ^ Michael Jang (2006). Linux annoyances for geeks. O'Reilly Media. p. 325. ISBN 9780596552244. Retrieved 2012-02-16.\n  2. ^ Donald, James (2003-01-25). \"Improved Portability of Shared Libraries\" (PDF). Princeton University. Archived from the original (PDF) on 2007-09-26. Retrieved 2010-04-09.\n  3. ^ Stevens, Al (2001-05-01). \"It's Good Work When You Can Find It; The Dependency Carousel\". J-DDJ. 26 (5). www.drdobbs.com/blog: 121\u2013124. ISSN 1044-789X. Archived from the original on 2011-08-11. Retrieved 2010-04-10.\n  4. ^ Jump up to: ^a ^b Pjotr Prins; Jeeva Suresh & Eelco Dolstra (2008-12-22). \"Nix fixes dependency hell on all Linux distributions\". linux.com. Archived from the original on 2015-07-08. Retrieved 2013-05-22. \"All popular package managers, including APT, RPM and the FreeBSD Ports Collection, suffer from the problem of destructive upgrades. When you perform an upgrade -- whether for a single application or your entire operating system -- the package manager will overwrite the files that are currently on your system with newer versions. As long as packages are always perfectly backward-compatible, this is not a problem, but in the real world, packages are anything but perfectly backward-compatible. Suppose you upgrade Firefox, and your package manager decides that you need a newer version of GTK as well. If the new GTK is not quite backward-compatible, then other applications on your system might suddenly break. In the Windows world a similar problem is known as the DLL hell, but dependency hell is just as much a problem in the Unix world, if not a bigger one, because Unix programs tend to have many external dependencies.\"\n  5. ^ \"Yum Dependency Hell\". Archived from the original on 2016-12-19. Retrieved 2015-12-28.\n  6. ^ \"Project website: semver.org\".\n  7. ^ Anderson, Rick (2000-01-11). \"The End of DLL Hell\". microsoft.com. Archived from the original on 2001-06-05. Retrieved 2010-07-07.\n  8. ^ pbiDIR\n  9. ^ Slotting on gentoo.org\n  10. ^ \"Application directories\". Retrieved 7 September 2013.\n  11. ^ Weinstein, Paul (2003-09-11). \"Is Linux Annoying?\". linuxdevcenter.com. Retrieved 2010-04-10.\n\n## External links[edit]\n\n  * Context independence\n  * Dependency walker\n  * Implicit dependency\n  * MacDependency\n\nRetrieved from\n\"https://en.wikipedia.org/w/index.php?title=Dependency_hell&oldid=1214980629\"\n\nCategories:\n\n  * Package management systems\n  * Version control systems\n  * Computer errors\n  * Software engineering folklore\n\nHidden categories:\n\n  * Articles with short description\n  * Short description is different from Wikidata\n  * All articles with unsourced statements\n  * Articles with unsourced statements from June 2022\n  * Articles with unsourced statements from March 2017\n\n  * This page was last edited on 22 March 2024, at 11:58 (UTC).\n  * Text is available under the Creative Commons Attribution-ShareAlike License 4.0; additional terms may apply. By using this site, you agree to the Terms of Use and Privacy Policy. Wikipedia\u00ae is a registered trademark of the Wikimedia Foundation, Inc., a non-profit organization.\n\n  * Privacy policy\n  * About Wikipedia\n  * Disclaimers\n  * Contact Wikipedia\n  * Code of Conduct\n  * Developers\n  * Statistics\n  * Cookie statement\n  * Mobile view\n  * Edit preview settings\n\n", "frontpage": false}
