{"aid": "40062978", "title": "Ensuring Atomicity: A Tale of Dragonfly Transactions", "url": "https://www.dragonflydb.io/blog/transactions-in-dragonfly", "domain": "dragonflydb.io", "votes": 1, "user": "yla92", "posted_at": "2024-04-17 11:16:37", "comments": 0, "source_title": "Ensuring Atomicity: A Tale of Dragonfly Transactions", "source_text": "Ensuring Atomicity: A Tale of Dragonfly Transactions\n\nBack to All Posts\n\nengineering\n\n# Ensuring Atomicity: A Tale of Dragonfly Transactions\n\nDive into Dragonfly's transactional framework through a metaphorical journey,\nuncovering how it maintains atomicity and serializability in a kingdom of\ndata.\n\nVlad Oleshko\n\nApril 9, 2024\n\n## Introduction\n\nDragonfly is a multi-threaded data store. It uses multiple threads not only to\nmanage I/O operations but also to execute data operations in parallel. One\nthread might be computing the intersection of a few sets; another might be\nextending a list with data; and a third might be preparing to flush the data\nstore.\n\nDevelopers generally know that thread synchronization is difficult and\nexpensive, both from a logical and computational perspective. Firstly, we need\nto ensure exclusive access to keys, but we certainly don't want to slow the\nwhole system down by lock contentions and burning all our computational\nresources on a single hot key. Secondly, the data store itself has dozens of\nstate parameters that control replication, snapshotting, memory limits, client\npauses, cluster mode, and many other aspects. Some of these state parameters\nhave to be changed carefully without interrupting any running commands; others\nare accessed frequently, so global synchronization across many threads would\nhave a devastating cost.\n\n## Shared-Nothing Architecture\n\nOur shared-nothing architecture addresses the problems described above. Its\nphilosophy is dead simple: making each thread as independent as possible. The\nfirst problem, exclusive access to keys, is solved by dividing the entire\ndataset into smaller sections called shards. Keys in a single shard are\nmanaged exclusively by one dedicated thread, which is known as a shard-thread.\nConversely, most of our state parameters are copied across all threads and are\nupdated with specific routines on the threads themselves. Eventually, it's\nconsistent, but it very well could be that one thread is starting to snapshot\nall of its keys while another, unknowingly, is still finishing an expensive\noperation.\n\nNavigating through this seemingly sophisticated architecture of Dragonfly\nmight lead one to wonder: How does it manage to maintain atomicity and\nserializability for complex multi-key operations? Consider commands like\nSINTERSTORE or the execution of Lua scripts with atomicity guarantees. How\ndoes Dragonfly ensure these operations are performed efficiently without\nhindering the system's ability to handle other non-overlapping commands,\nespecially when such multi-key operations are in progress? To find out the\nanswer, we have to examine Dragonfly's transactional framework. It is based on\nthe very lightweight locking (VLL) algorithm, though it has evolved over time\nand grown with custom optimizations and logic.\n\nLet's start our journey by exploring the transactional framework through a\nmetaphorical lens.\n\n## A Metaphorical Journey - Transactions in Dragonfly\n\nImagine yourself as the trade master in a small, mystical kingdom composed of\nthree distinct towns: one red, one green, and one blue. The people in each\ntown have a unique preference\u2014they only appreciate items in their town's color\nand strongly disapprove of any other hues. Your role involves managing the\ndistribution and storage of colorful goods, which are regularly brought to you\nby pilgrims and visitors. These goods vary in color, requiring careful\nallocation to the respective towns based on their color preferences.\n\nYou employ couriers to transport these goods to the appropriate towns.\nHowever, there's a catch: the kingdom is full of curious pilgrims and visitors\nwho often inquire about the inventory across all three towns. Providing\naccurate information is crucial, as any mistake or inconsistency in your\nreports can disappoint them. They will get upset and won't come back again.\n\nYou might quickly spot similarities to our problems and realize the metaphor\nwe are using:\n\n  * The towns represent different shards in Dragonfly, each handles specific keys.\n  * The pilgrims and visitors are client SDKs, issuing write and read commands.\n  * And you, the trade master, are carrying out the role of the transactional framework.\n\nOne day, you receive a blue teacup and dispatch a courier to store it in the\nBlue Town. Shortly thereafter, you're asked about the total number of blue\ncookware items in preparation for a tea party. You send another courier to\nBlue Town to calculate. It's crucial that this count includes the newly\ndispatched teacup, even if it hasn't physically arrived yet, because the\nvisitors exchanging this information expect immediate and accurate answers.\n\nTo avoid any mistakes in relaying information, you instruct all your couriers\nto travel only along a single road to Blue Town and never overtake each other.\nMoreover, recognizing that couriers might not arrive at the destination in the\norder they were sent, you also assign successive numbers to couriers, so they\nknow how to reorder themselves once they queue up on the road.\n\nIn Dragonfly, this orderly procession is mirrored by what's called a shard's\ntransaction queue. This queue holds all pending operations for a specific\nshard. The sequential numbers of couriers are reflected as transaction IDs\n(txid), assigned by incrementing a single global atomic counter. Multi-key\noperations, such as MSET, which mimics storing multiple goods in different\ncolors, are broken into separate operations. These operations are then managed\nby the corresponding shards, but share the same transaction ID.\n\n## Tricky Questions by Visitors - Shard Locks\n\nThe concept of sharding, as we've discussed, might seem straightforward to\nthose familiar with distributed systems. However, the scenario complicates\nwhen we consider more unpredictable interactions, much like dealing with\ncapricious pilgrimage visitors in our metaphorical kingdom.\n\nImagine a pilgrim man who has whimsical thoughts and asks the number of\nflowers you possess, with his offering depending on your answer. If you report\nplenty, he might worry that you will forget to water them and leave you\nwithout more flowers. His decision could vary\u2014he might choose to give you\nsomething else or ask additional questions. More importantly, your answers\ncan't change while you're talking to him, even though you might be interrupted\nby other pilgrims offering you goods. If another visitor wants to discuss\nflowers, you'd need to politely ask them to wait, ensuring the first pilgrim's\ninquiry is addressed with undivided attention.\n\nTechnically speaking, the interaction with you, the trade master, should be\natomic\u2014as if no two visitors spoke with you at the same time. Those\ncomplicated interactions might remind us of MULTI/EXEC transactions, Lua\nscripts, or regular multi-key commands like SINTERSTORE, where the write\noperation depends on the preceding read.\n\nA strategy is employed for these prolonged conversations: the courier locks\nthe town upon departure, ensuring that any information collected won\u2019t change\nby the time they return. Although the courier must queue to enter the town for\nthe first visit, subsequent visits allow bypassing the queue, effectively\nlocking the town for their exclusive access. As shown below, the whole Blue\nTown is locked because of this traveling courier. This is called a shard lock\nin Dragonfly.\n\nThis strategy ensures each prolonged conversation, or transaction, is atomic,\neliminating the need to keep track of all ongoing interactions. Couriers, upon\ntheir return, provide updates and necessary information, streamlining the\nprocess and maintaining the integrity of each transaction.\n\nIn Dragonfly, a transaction occupying the shard is called a continuation\nbecause, as the name suggests, it aims to proceed without interruption. While\nactive, no other transactions can be processed on that shard. The shard's\ntransaction queue is effectively paused until the continuation concludes. Now\nthe importance of our linear order with unique transaction IDs comes into\nplay\u2014if such an order is ensured on all the roads, it is impossible to reach a\ndeadlock. As couriers with lower IDs always have priority, the system is\nguaranteed to be lively.\n\n## Avoid Locking Entire Towns - Intent Locks\n\nAs your kingdom expands and the flow of trading goods increases, you realize\nthat locking up entire towns is becoming prohibitively expensive. The roads\nare clogged with queues, and you have to lock down all towns for a single\nquestion about various items of different colors\u2014the whole country will come\nto a standstill!\n\nTo tackle this problem, you devise a clever strategy: sending couriers in\npairs. One courier holds a spot in the queue, ensuring their place is secure\nand preventing any accidental overtaking. Meanwhile, the other courier\nadvances, checking with those ahead in the queue and the town guard to see if\nthe town is locked for a reason relevant to their mission. If there's no\nconflict of interest, they can proceed into town to fulfill the delivery. This\nmethod not only streamlines the process but also allows for flexibility.\nSometimes, the fellow courier in the queue can withdraw without needing to\nenter the town, reducing unnecessary congestion.\n\nThis kind of record system is technically known as intent locks. Unlike\ntraditional locks, where actors gain exclusive control of resources, intent\nlocks are about declaring a future intention to acquire such control. This\nmechanism relies on a predetermined order\u2014fortunately, something we have\nalready established in our system. In the meantime, to avoid the inefficiency\nof scanning the entire transaction queue, Dragonfly keeps a compact table of\nintent locks in every thread.\n\nDifferent kinds of items in our metaphor are simply different keys. A\ntransaction that can execute before it reaches the front of the queue is known\nas an out-of-order transaction. In practice, most commands in Dragonfly are\nexpected to execute out-of-order. Long transaction queues are only accumulated\nif excessively frequently accessed keys are involved.\n\n## Conclusion\n\nIn this journey, we have demonstrated in a metaphorical way how Dragonfly,\nwith its sophisticated yet accessible transactional framework, brings order\nand efficiency to complex data operations. By implementing effective\nmechanisms and leveraging clever optimizations, Dragonfly achieves the\natomicity and serializability standards expected of a modern in-memory data\nstore.\n\nDragonfly is officially integrated with background job processing systems like\nBullMQ and Sidekiq, which heavily rely on Lua scripts and multi-key\noperations. The transactional framework ensures that these operations are\nexecuted efficiently, which makes Dragonfly an outstanding choice as the\nbackend store for these libraries. Get started with Dragonfly today and\nexperience the power of a high-throughput, multi-threaded in-memory data\nstore!\n\n## Stay up to date on all things Dragonfly\n\nSubscribe to receive a monthly newsletter with new content, product\nannouncements, events info, and more!\n\nStart building today\n\nDragonfly is fully compatible with the Redis ecosystem and requires no code\nchanges to implement.\n\nInstallRequest Trial\n\n## Footer\n\n### Dragonfly\n\n  * Features\n  * Blog\n  * Dragonfly Cloud\n  * Security\n\n### Developers\n\n  * Documentation\n  * Discord\n  * Github\n\n### Company\n\n  * Careers\n  * Privacy\n  * Terms of Use\n\n### Resources\n\n  * In-Memory\n  * Redis Alternative\n  * Memcached Alternative\n\nXDiscordGitHubLinkedIn\n\nRedis is a registered trademark of Redis Ltd. Any rights therein are reserved\nto Redis Ltd. Any use by DragonflyDB Ltd. is for referential purposes only and\ndoes not indicate any sponsorship, endorsement or affiliation between Redis\nand DragonflyDB Ltd.\n\n", "frontpage": false}
