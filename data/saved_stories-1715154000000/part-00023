{"aid": "40293363", "title": "How to Get a Perfect Deep Equal in JavaScript", "url": "https://webdeveloper.beehiiv.com/p/get-perfect-deep-equal-javascript", "domain": "webdeveloper.beehiiv.com", "votes": 1, "user": "zacharylee", "posted_at": "2024-05-08 01:13:36", "comments": 0, "source_title": "How to Get a Perfect Deep Equal in JavaScript", "source_text": "How to Get a Perfect Deep Equal in JavaScript\n\n  * Web Developer\n  * Posts\n  * How to Get a Perfect Deep Equal in JavaScript\n\n# How to Get a Perfect Deep Equal in JavaScript\n\n## Achieve almost perfect Deep Equal based on React Shallow Equal.\n\nZachary Lee May 07, 2024\n\nIn JavaScript, we can use == , === operator and Object.is method to judge the\nequality of two variable values. But if we want to compare two variable values\ndeeply, can they meet our needs? Follow me to analyze it.\n\n### ==\n\nThe == operator is a loose equality operator. When comparing two different\ntypes of values, it will first try to convert them to the same type, and then\ncompare them. The specific algorithm used is Abstract Equality Comparison\nAlgorithm, its rules are complex and difficult to remember, you can also check\nits short description here, and you can also experience its conversion process\ninteractively through this link.\n\nIt is arguably the least rigorous equality operator, and many results may\nsurprise you.\n\n### ===\n\nThe === operator is a strict equality operator. It always considers operands\nof different types to be different. The specific algorithm used is Strict\nEquality Comparison Algorithm, its rules are easier to remember, you can also\ncheck its short description here.\n\nIt is our most used equality operator. It looks strict, but it has flaws in\nthe following cases:\n\n  * Numbers must have the same numeric values. +0 and -0 are considered to be the same value.\n\n  * If either operand is NaN, it will return false.\n\n  * If both operands are objects, it will only judge whether their reference addresses are the same.\n\n### Object.is\n\nThe Object.is method behaves the same as the === operator in most cases, but\nhas the opposite result of the === operator in the following two cases:\n\n  * +0 and -0 are considered different values and will return false.\n\n  * NaN and NaN are considered to be the same value and will return true.\n\nIt doesn\u2019t mean that Object.isis stricter than === operator. We should deal\nwith the corresponding usage requirements according to the specific\ncharacteristics of Object.is .\n\nNote that Object.is behaves the same as the === operator if the two operands\nare objects, or only determines whether their reference addresses are the\nsame.\n\n### How to get a Deep Equal?\n\nFor the case where the operands are all objects, we expect Deep Equal to give\nthe answer we want. For example, for any non-primitive objects x and y which\nhave the same structure but are distinct objects themselves, we would expect\nDeep Equal to return true.\n\nI explained the characteristics of JavaScript data types in the How to Get a\nPerfect Deep Copy in JavaScript article published earlier. It is precise\nbecause of these characteristics that a perfect Deep Equal needs to consider\nmany edge cases, and its performance is destined to be poor. , so in React, we\ndo not use Deep Equal to judge whether the state has changed before and after,\nbut Shallow Equal.\n\nSo let\u2019s take a look at how Shallow Equal in React is implemented?\n\n### Shallow Equal in React\n\nI don\u2019t change the original logic here, just remove the compatibility code to\nimprove readability. Its original file is here, you can check it out for\ncomparison.\n\nNote my comments in the code that start with P , I\u2019ll explain in units of it:\n\nP1: The first-level comparison is performed through Object.is, and if it is\nequal, it returns true, which has the effect of first-level filtering.\n\nP2: Make sure both are objects and return false if either is not.\n\nP3: At this point both are objects, but their reference addresses are not the\nsame. So the next step is to loop through the key array of one of the objects,\ndetermine whether the key is its own property (as opposed to inheriting it) of\nanother object, and determine whether the value corresponding to the key of\nthese two objects can pass Object.is , that is, here React does not choose\nrecursive judgment for performance, which means that only one layer is\ncompared.\n\nAfter reading the Shallow Equal in React, I believe you have some ideas. Let\u2019s\nrealize a perfect Deep Equal based on it.\n\n### Get the perfect Deep Equal based on Shallow Equal\n\nJs (forked) - StackBlitz\n\nBlank starter project for building ES6 apps.\n\nstackblitz.com/edit/js-zl2f8a?file=index.js\n\nThe test code here uses the deep copy function implemented in the previous\narticle. Of course, you can also modify and test the results directly on\nStackBlitz, for example, you can remove the comments at the end of the code to\nsee the change in the result.\n\n    \n    \n    const deepEqual = (objA, objB, map = new WeakMap()) => { // P1 if (Object.is(objA, objB)) return true; // P2 if (objA instanceof Date && objB instanceof Date) { return objA.getTime() === objB.getTime(); } if (objA instanceof RegExp && objB instanceof RegExp) { return objA.toString() === objB.toString(); } // P3 if ( typeof objA !== 'object' || objA === null || typeof objB !== 'object' || objB === null ) { return false; } // P4 if (map.get(objA) === objB) return true; map.set(objA, objB); // P5 const keysA = Reflect.ownKeys(objA); const keysB = Reflect.ownKeys(objB); if (keysA.length !== keysB.length) { return false; } for (let i = 0; i < keysA.length; i++) { if ( !Reflect.has(objB, keysA[i]) || !deepEqual(objA[keysA[i]], objB[keysA[i]], map) ) { return false; } } return true; };\n\nP1: Like Shadow Equal, use Object.is for first-level filtering.\n\nP2: Special handling is required for Date and RegExp, so use\nDate.prototype.getTime() for Date to get the timestamp and compare, and\nRegExp.prototype.toString() for RegExp to get string and compare.\n\nP3: Like Shadow Equal, make sure both are objects and return false if either\nis not.\n\nP4: Use WeakMap as a hash table to solve the circular reference problem. If\nthe two have been compared before, it will return true, which means that it\nwill not affect the final result.\n\nP5: Compared to Shadow Equal, we upgrade to Reflect.ownKeys to get all keys.\nThen we also judge the length of the attribute array, and then loop through\nall the attribute keys of objA, and use Reflect.has to judge whether there are\nthe same attributes on objB. Finally, we upgrade Object.is to recursive\nprocessing, and constantly judge whether the deep values are equal.\n\nIf you look at the deep copy functions implemented earlier, do you feel\nsimilarities between them? Yes, they are very similar in some logical\njudgments. You can learn by comparison. I believe it can deepen your\nunderstanding of JavaScript data structure.\n\nIf you find it helpful, please consider subscribing to me. I'll share more\narticles about web development. Thanks for reading.\n\nWeb Developer\n\nSubscribe for the latest updates, tools, and essential articles on web\ndevelopment.\n\nHome\n\nPosts\n\n\u00a9 2024 Web Developer.\n\nPrivacy Policy\n\nTerms of Use\n\nPowered by beehiiv\n\n", "frontpage": false}
