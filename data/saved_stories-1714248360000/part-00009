{"aid": "40178323", "title": "Why I choose Kotlin", "url": "https://rockyj-blogs.web.app/2024/04/27/why-kotlin.html", "domain": "web.app", "votes": 2, "user": "rockyj", "posted_at": "2024-04-27 08:29:12", "comments": 0, "source_title": "Rocky Jaiswal - Why Kotlin?", "source_text": "Rocky Jaiswal - Why Kotlin?\n\n# Still Learning\n\nand some weekend hacking\n\n## Why Kotlin?\n\n27/04/2024\n\nThis is another short post simply because this is an opinion and not a huge\ntopic. I am working with Java again for a while and Java 21 does make me happy\nbut I miss some things from Kotlin so I thought I should put my thoughts in a\npost.\n\nProgramming language preferences are quite subjective so I have tried to\ndivide this post in two sections - one which I consider \"objective\" or clear\nadvantages and one section of \"subjective\" or personal preferences.\n\nLet's start with what I consider objective or clear advantages of using Kotlin\nover Java.\n\n## Null safety\n\nOften referred to as a \"billion dollar mistake\", null pointer exceptions\n(NPEs) are common in Java. For a language that is very strong on \"types\" there\nis still a huge problem with \"null\". Java on its part has tried to solve it\nwith Optional and some annotations (JSR-380) but the problem is not properly\naddressed and there is no consensus in the community.\n\nKotlin on the other hand, has clear types and solutions for null out-of-the-\nbox -\n\n    \n    \n    var str: String = \"abc\" // cannot be set to null var str: String? = \"abc\" // can be set to null\n\nThen, you have some syntax sugar on top -\n\n    \n    \n    val b: String? = null b?.length // safe operator val l = b?.length ?: 0 // the Elvis operator :)\n\nWith these simple changes, we see a huge benefit in day-to-day code and fewer\nunexpected nulls. If we are careful we can detect & eliminate a lot of NPE at\ncompile time.\n\n## Immutability\n\nAfter \"null\" this is perhaps the most important feature for me. Kotlin's clear\nval based declarations are not only concise but give the peace of mind that a\nvariable cannot be mutated. With a little bit of care, we can use immutable\nfields, parameters, collections and data classes with \"vals\"\n\n    \n    \n    data class User(val name: String, val age: Int) // cannot change fields once created\n\nAll this makes immutability easy and with some care we can always deal with\nimmutable objects, parameters and fields unless needed. Mutability is still\npossible when needed but Kotlin makes it easy to isolate, identify and\nminimize it.\n\n## Structured Concurrency\n\nThis is also a big one. Java has a good multi-threading story but when it\ncomes to \"asynchronous\" operations the developer experience is not so great.\nYou either go with \"CompletableFuture\" or \"Reactive\" programming models for\nexample, both of which are good enough but not so easy to use / setup. Kotlin\non the other hand has in-built Coroutines, which makes async programming much\neasier.\n\nLet's take an example - A user signs up, we insert a record in the DB, then\nthere are few things which we need to do but can be done in the background,\nlet's say - send the user an email and send a request to a CRM system. The\nlast two calls can also be done in parallel.\n\nThe Kotlin code for doing things in the background and/or in parallel is\nsimple and does not need a lot of lines. The example requirement above can be\nwritten as -\n\n    \n    \n    private fun <T> runVirtual(context: CoroutineContext = EmptyCoroutineContext, block: suspend CoroutineScope.() -> T): T = Executors.newVirtualThreadPerTaskExecutor().use { threadPool -> runBlocking(context + threadPool.asCoroutineDispatcher(), block) } class AsyncDemo { suspend fun insertUserInDB(): Int { delay(1000) // pretend we are doing something asynchronous here println(\"inserting user in DB ...\") return 101 } suspend fun sendEmail(): String { delay(2000) // change me to change the delay println(\"sending an email ...\") return \"email_receipt\" } suspend fun updateCRM(): String { delay(3000) println(\"calling CRM ...\") return \"crm_response\" } } // main function fun main() { val demo = AsyncDemo() val start = Instant.now().toEpochMilli() runVirtual { demo.insertUserInDB() val res1 = async { demo.updateCRM() } val res2 = async { demo.sendEmail() } println(res1.await()) println(res2.await()) } println(\"${Instant.now().toEpochMilli() - start} millisecs consumed\") }\n\nWe can play around with the delay numbers and async blocks to see that the\ntotal time to execute the program depends on what is run asynchronously or in\nparallel. As you can see this setup is easy to develop and easy to understand\nwhich is not the case with Java.\n\nYou can also \"launch\" thousands of Coroutines with no problem -\n\n    \n    \n    fun main() { val demo = AsyncDemo() val start = Instant.now().toEpochMilli() runVirtual { (1..100000).forEach { launch(Dispatchers.Default) { demo.insertUserInDB() } } } println(\"${Instant.now().toEpochMilli() - start} millisecs consumed\") }\n\nThe code above ran on my laptop easily in a few seconds and used all my CPU\ncores without taxing the memory. Although some knowledge is needed to\nunderstand Dispatchers, Couroutine Context etc.\n\n## Some subjective opinions\n\n  * The FP story is much better, you can have functions inside functions, functions outside classes, you do not have to explicitly declare the interface for a function / lambda.\n  * Kotlin is much easier with collections with a functional approach. No need for streams, you can simply do things like\n\n    \n    \n    numberStrings .map { it.first } .map { Integer.parseInt(it) } .fold(1) { acc, i -> acc * i }\n\n  * Kotlin is well supported by Spring & Micronaut, so the big frameworks are there in case you need them.\n  * The syntax is very close to TypeScript. So if you are working on a TypeScript frontend, the switch to backend is not huge. async and await developers will feel right at home.\n  * Some great FP libraries like Arrow exist and provide solid features if you need them.\n  * Finally, with Type Inference, no semi-colons and some syntatic sugar Kotlin feels much terse and easy to read.\n\n## What I miss\n\nCurrying is not so easy, at-least not as easy as TypeScript.\n\n    \n    \n    fun addCurried(a: Int): (Int) -> Int { return { b -> a + b } } println(addCurried(2)(3))\n\nvs TypeScript\n\n    \n    \n    const addCurried = (a: number) => (b: number) => (c: number) => a + b + c; console.log(addCurried(add(2)(3)(5)))\n\n## Conclusion\n\nSo there you have it, Kotlin certainly adds some great features on top of Java\nand justifies its adoption. The only downside is you move away from a language\nthat has been there for the last 25+ years, but with the JVM and Google's\nsupport for Kotlin I feel that Kotlin is not going anywhere as well, and the\ndeveloper experience is much better than Java.\n\n", "frontpage": false}
