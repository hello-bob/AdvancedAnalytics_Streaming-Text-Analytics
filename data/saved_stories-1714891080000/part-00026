{"aid": "40261319", "title": "A (Mostly) Complete Guide to React Rendering Behavior", "url": "https://blog.isquaredsoftware.com/2020/05/blogged-answers-a-mostly-complete-guide-to-react-rendering-behavior/", "domain": "isquaredsoftware.com", "votes": 1, "user": "robertvc", "posted_at": "2024-05-05 00:03:48", "comments": 0, "source_title": "Blogged Answers: A (Mostly) Complete Guide to React Rendering Behavior", "source_text": "Blogged Answers: A (Mostly) Complete Guide to React Rendering Behavior \u00b7\nMark's Dev Blog\n\n# Mark's Dev Blog\n\n  * About\n\nRandom musings on React, Redux, and more, by Redux maintainer Mark \"acemarke\"\nErikson\n\nSponsor @markerikson\n\nHome\n\n# Blogged Answers: A (Mostly) Complete Guide to React Rendering Behavior\n\nPosted on May 17, 2020\n\n#react #context #redux #greatest-hits\n\nThis is a post in the Blogged Answers series.\n\nDetails on how React rendering behaves, and how use of Context and React-Redux\naffect rendering\n\nI've seen a lot of ongoing confusion over when, why, and how React will re-\nrender components, and how use of Context and React-Redux will affect the\ntiming and scope of those re-renders. After having typed up variations of this\nexplanation dozens of times, it seems it's worth trying to write up a\nconsolidated explanation that I can refer people to. Note that all this\ninformation is available online already, and has been explained in numerous\nother excellent blog posts and articles, several of which I'm linking at the\nend in the \"Further Information\" section for reference. But, people seem to be\nstruggling to put the pieces together for a full understanding, so hopefully\nthis will help clarify things for someone.\n\n> Note: Updated October 2022 to cover React 18 and future React updates\n\nI also did a talk based on this post for React Advanced 2022:\n\nReact Advanced 2022 - A (Brief) Guide to React Rendering Behavior\n\n### Table of Contents \ud83d\udd17\ufe0e\n\n  * What is \"Rendering\"?\n\n    * Rendering Process Overview\n    * Render and Commit Phases\n  * How Does React Handle Renders?\n\n    * Queuing Renders\n    * Standard Render Behavior\n    * Rules of React Rendering\n    * Component Metadata and Fibers\n    * Component Types and Reconciliation\n    * Keys and Reconciliation\n    * Render Batching and Timing\n    * Async Rendering, Closures, and State Snapshots\n    * Render Behavior Edge Cases\n  * Improving Rendering Performance\n\n    * Component Render Optimization Techniques\n    * How New Props References Affect Render Optimizations\n    * Optimizing Props References\n    * Memoize Everything?\n    * Immutability and Rerendering\n    * Measuring React Component Rendering Performance\n  * Context and Rendering Behavior\n\n    * Context Basics\n    * Updating Context Values\n    * State Updates, Context, and Re-Renders\n    * Context Updates and Render Optimizations\n  * React-Redux and Rendering Behavior\n\n    * React-Redux Subscriptions\n    * Differences between connect and useSelector\n  * Future React Improvements\n\n    * \"React Forget\" Memoizing Compiler\n    * Context Selectors\n  * Summary\n  * Final Thoughts\n  * Further Information\n\n## What is \"Rendering\"? \ud83d\udd17\ufe0e\n\nRendering is the process of React asking your components to describe what they\nwant their section of the UI to look like, now, based on the current\ncombination of props and state.\n\n### Rendering Process Overview \ud83d\udd17\ufe0e\n\nDuring the rendering process, React will start at the root of the component\ntree and loop downwards to find all components that have been flagged as\nneeding updates. For each flagged component, React will call either\nFunctionComponent(props) (for function components), or\nclassComponentInstance.render() (for class components) , and save the render\noutput for the next steps of the render pass.\n\nA component's render output is normally written in JSX syntax, which is then\nconverted to React.createElement() calls as the JS is compiled and prepared\nfor deployment. createElement returns React elements, which are plain JS\nobjects that describe the intended structure of the UI. Example:\n\n    \n    \n    // This JSX syntax: return <MyComponent a={42} b=\"testing\">Text here</MyComponent> // is converted to this call: return React.createElement(MyComponent, {a: 42, b: \"testing\"}, \"Text Here\") // and that becomes this element object: {type: MyComponent, props: {a: 42, b: \"testing\"}, children: [\"Text Here\"]} // And internally, React calls the actual function to render it: let elements = MyComponent({...props, children}) // For \"host components\" like HTML: return <button onClick={() => {}}>Click Me</button> // becomes React.createElement(\"button\", {onClick}, \"Click Me\") // and finally: {type: \"button\", props: {onClick}, children: [\"Click me\"]}\n\nAfter it has collected the render output from the entire component tree, React\nwill diff the new tree of objects (frequently referred to as the \"virtual\nDOM\"), and collects a list of all the changes that need to be applied to make\nthe real DOM look like the current desired output. The diffing and calculation\nprocess is known as \"reconciliation\".\n\nReact then applies all the calculated changes to the DOM in one synchronous\nsequence.\n\n> Note: The React team has downplayed the term \"virtual DOM\" in recent years.\n> Dan Abramov said:\n>\n> I wish we could retire the term \u201cvirtual DOM\u201d. It made sense in 2013 because\n> otherwise people assumed React creates DOM nodes on every render. But people\n> rarely assume this today. \u201cVirtual DOM\u201d sounds like a workaround for some\n> DOM issue. But that\u2019s not what React is. React is \u201cvalue UI\u201d. Its core\n> principle is that UI is a value, just like a string or an array. You can\n> keep it in a variable, pass it around, use JavaScript control flow with it,\n> and so on. That expressiveness is the point \u2014 not some diffing to avoid\n> applying changes to the DOM. It doesn\u2019t even always represent the DOM, for\n> example <Message recipientId={10} /> is not DOM. Conceptually it represents\n> lazy function calls: Message.bind(null, { recipientId: 10 }).\n\n### Render and Commit Phases \ud83d\udd17\ufe0e\n\nThe React team divides this work into two phases, conceptually:\n\n  * The \"Render phase\" contains all the work of rendering components and calculating changes\n  * The \"Commit phase\" is the process of applying those changes to the DOM\n\nAfter React has updated the DOM in the commit phase, it updates all refs\naccordingly to point to the requested DOM nodes and component instances. It\nthen synchronously runs the componentDidMount and componentDidUpdate class\nlifecycle methods, and the useLayoutEffect hooks.\n\nReact then sets a short timeout, and when it expires, runs all the useEffect\nhooks. This step is also known as the \"Passive Effects\" phase.\n\nReact 18 added \"Concurrent Rendering\" features like useTransition. This gives\nReact the ability to pause the work in the rendering phase to allow the\nbrowser to process events. React will either resume, throw away, or\nrecalculate that work later as appropriate. Once the render pass has been\ncompleted, React will still run the commit phase synchronously in one step.\n\nA key part of this to understand is that \"rendering\" is not the same thing as\n\"updating the DOM\", and a component may be rendered without any visible\nchanges happening as a result. When React renders a component:\n\n  * The component might return the same render output as last time, so no changes are needed\n  * In Concurrent Rendering, React might end up rendering a component multiple times, but throw away the render output each time if other updates invalidate the current work being done\n\nThis excellent interactive React hooks timeline diagram helps illustrate the\nsequencing of rendering, committing, and executing hooks:\n\nFor additional visualizations, see:\n\n  * React hooks flow diagram\n  * React hooks render/commit phase diagram\n  * React class lifecycle methods diagram\n\n## How Does React Handle Renders? \ud83d\udd17\ufe0e\n\n### Queuing Renders \ud83d\udd17\ufe0e\n\nAfter the initial render has completed, there are a few different ways to tell\nReact to queue a re-render:\n\n  * Function components:\n\n    * useState setters\n    * useReducer dispatches\n  * Class components:\n\n    * this.setState()\n    * this.forceUpdate()\n  * Other:\n\n    * Calling the ReactDOM top-level render(<App>) method again (which is equivalent to calling forceUpdate() on the root component)\n    * Updates triggered from the new useSyncExternalStore hook\n\nNote that function components don't have a forceUpdate method, but you can get\nthe same behavior by using a useReducer hook that always increments a counter:\n\n    \n    \n    const [, forceRender] = useReducer((c) => c + 1, 0);\n\n### Standard Render Behavior \ud83d\udd17\ufe0e\n\nIt's very important to remember that:\n\nReact's default behavior is that when a parent component renders, React will\nrecursively render all child components inside of it!\n\nAs an example, say we have a component tree of A > B > C > D, and we've\nalready shown them on the page. The user clicks a button in B that increments\na counter:\n\n  * We call setState() in B, which queues a re-render of B.\n  * React starts the render pass from the top of the tree\n  * React sees that A is not marked as needing an update, and moves past it\n  * React sees that B is marked as needing an update, and renders it. B returns <C /> as it did last time.\n  * C was not originally marked as needing an update. However, because its parent B rendered, React now moves downwards and renders C as well. C returns <D /> again.\n  * D was also not marked for rendering, but since its parent C rendered, React moves downward and renders D too.\n\nTo repeat this another way:\n\nRendering a component will, by default, cause all components inside of it to\nbe rendered too!\n\nAlso, another key point:\n\nIn normal rendering, React does not care whether \"props changed\" - it will\nrender child components unconditionally just because the parent rendered!\n\nThis means that calling setState() in your root <App> component, with no other\nchanges altering the behavior, will cause React to re-render every single\ncomponent in the component tree. After all, one of the original sales pitches\nfor React was \"act like we're redrawing the entire app on every update\".\n\nNow, it's very likely that most of the components in the tree will return the\nexact same render output as last time, and therefore React won't need to make\nany changes to the DOM. But, React will still have to do the work of asking\ncomponents to render themselves and diffing the render output. Both of those\ntake time and effort.\n\nRemember, rendering is not a bad thing - it's how React knows whether it needs\nto actually make any changes to the DOM!\n\n### Rules of React Rendering \ud83d\udd17\ufe0e\n\nOne of the primary rules of React rendering is that rendering must be \"pure\"\nand not have any side effects!\n\nThis can be tricky and confusing, because many side effects are not obvious,\nand don't result in anything breaking. For example, strictly speaking a\nconsole.log() statement is a side effect, but it won't actually break\nanything. Mutating a prop is definitely a side effect, and it might not break\nanything. Making an AJAX call in the middle of rendering is also definitely a\nside effect, and can definitely cause unexpected app behavior depending on the\ntype of request.\n\nSebastian Markbage wrote an excellent document entitled The Rules of React. In\nit, he defines the expected behaviors for different React lifecycle methods,\nincluding render, and what kinds of operations would be considered safely\n\"pure\" and which would be unsafe. It's worth reading that in its entirety, but\nI'll summarize the key points:\n\n  * Render logic must not:\n\n    * Can't mutate existing variables and objects\n    * Can't create random values like Math.random() or Date.now()\n    * Can't make network requests\n    * Can't queue state updates\n  * Render logic may:\n\n    * Mutate objects that were newly created while rendering\n    * Throw errors\n    * \"Lazy initialize\" data that hasn't been created yet, such as a cached value\n\n### Component Metadata and Fibers \ud83d\udd17\ufe0e\n\nReact stores an internal data structure that tracks all the current component\ninstances that exist in the application. The core piece of this data structure\nis an object called a \"fiber\", which contains metadata fields that describe:\n\n  * What component type is supposed to be rendered at this point in the component tree\n  * The current props and state associated with this component\n  * Pointers to parent, sibling, and child components\n  * Other internal metadata that React uses to track the rendering process\n\nIf you've ever heard the phrase \"React Fiber\" used to describe a React version\nor feature, that's really referring to the rewrite of React's internals that\nswitched the rendering logic to rely on these \"Fiber\" objects as the key data\nstructure. That was released as React 16.0, so every version of React since\nthen has used this approach.\n\nThe shortened version of the Fiber type looks like:\n\n    \n    \n    export type Fiber = { // Tag identifying the type of fiber. tag: WorkTag; // Unique identifier of this child. key: null | string; // The resolved function/class/ associated with this fiber. type: any; // Singly Linked List Tree Structure. child: Fiber | null; sibling: Fiber | null; index: number; // Input is the data coming into this fiber (arguments/props) pendingProps: any; memoizedProps: any; // The props used to create the output. // A queue of state updates and callbacks. updateQueue: Array<State | StateUpdaters>; // The state used to create the output memoizedState: any; // Dependencies (contexts, events) for this fiber, if any dependencies: Dependencies | null; };\n\n(You can see the full definition of the Fiber type as of React 18 here.)\n\nDuring a rendering pass, React will iterate over this tree of fiber objects,\nand construct an updated tree as it calculates the new rendering results.\n\nNote that these \"fiber\" objects store the real component props and state\nvalues. When you use props and state in your components, React is actually\ngiving you access to the values that were stored on the fiber objects. In\nfact, for class components specifically, React explicitly copies\ncomponentInstance.props = newProps over to the component right before\nrendering it. So, this.props does exist, but it only exists because React\ncopied the reference over from its internal data structures. In that sense,\ncomponents are sort of a facade over React's fiber objects.\n\nSimilarly, React hooks work because React stores all of the hooks for a\ncomponent as a linked list attached to that component's fiber object. When\nReact renders a function component, it gets that linked list of hook\ndescription entries from the fiber, and every time you call another hook, it\nreturns the appropriate values that were stored in the hook description object\n(like the state and dispatch values for useReducer.\n\nWhen a parent component renders a given child component for the first time,\nReact creates a fiber object to track that \"instance\" of a component. For\nclass components, it literally calls const instance = new\nYourComponentType(props) and saves the actual component instance onto the\nfiber object. For function components, React just calls\nYourComponentType(props) as a function.\n\n### Component Types and Reconciliation \ud83d\udd17\ufe0e\n\nAs described in the \"Reconciliation\" docs page, React tries to be efficient\nduring re-renders, by reusing as much of the existing component tree and DOM\nstructure as possible. If you ask React to render the same type of component\nor HTML node in the same place in the tree, React will reuse that and just\napply updates if appropriate, instead of re-creating it from scratch. That\nmeans that React will keep component instances alive as long as you keep\nasking React to render that component type in the same place. For class\ncomponents, it actually does use the same actual instance of your component. A\nfunction component has no true \"instance\" the way a class does, but we can\nthink of <MyFunctionComponent /> as representing an \"instance\" in terms of \"a\ncomponent of this type is being shown here and kept alive\".\n\nSo, how does React know when and how the output has actually changed?\n\nReact's rendering logic compares elements based on their type field first,\nusing === reference comparisons. If an element in a given spot has changed to\na different type, such as going from <div> to <span> or <ComponentA> to\n<ComponentB>, React will speed up the comparison process by assuming that\nentire tree has changed. As a result, React will destroy that entire existing\ncomponent tree section, including all DOM nodes, and recreate it from scratch\nwith new component instances.\n\nThis means that you must never create new component types while rendering!\nWhenever you create a new component type, it's a different reference, and that\nwill cause React to repeatedly destroy and recreate the child component tree.\n\nIn other words, don't do this:\n\n    \n    \n    // \u274c BAD! // This creates a new `ChildComponent` reference every time! function ParentComponent() { function ChildComponent() { return <div>Hi</div>; } return <ChildComponent />; }\n\nInstead, always define components separately:\n\n    \n    \n    // \u2705 GOOD // This only creates one component type reference function ChildComponent() { return <div>Hi</div>; } function ParentComponent() { return <ChildComponent />; }\n\n### Keys and Reconciliation \ud83d\udd17\ufe0e\n\nThe other way that React identifies component \"instances\" is via the key\npseudo-prop. React uses key as a unique identifier that it can use to\ndifferentiate specific instances of a component type.\n\nNote that key isn't actually a real prop - it's an instruction to React. React\nwill always strip that off, and it will never be passed through to the actual\ncomponent, so you can never have props.key - it will always be undefined.\n\nThe main place we use keys is rendering lists. Keys are especially important\nhere if you are rendering data that may be changed in some way, such as\nreordering, adding, or deleting list entries. It's particularly important here\nthat keys should be some kind of unique IDs from your data if at all possible\n- only use array indices as keys as a last resort fallback!\n\n    \n    \n    // \u2705 Use a data object ID as the key for list items todos.map((todo) => <TodoListItem key={todo.id} todo={todo} />);\n\nHere's an example of why this matters. Say I render a list of 10\n<TodoListItem> components, using array indices as keys. React sees 10 items,\nwith keys of 0..9. Now, if we delete items 6 and 7, and add three new entries\nat the end, we end up rendering items with keys of 0..10. So, it looks to\nReact like I really just added one new entry at the end because we went from\n10 list items to 11. React will happily reuse the existing DOM nodes and\ncomponent instances. But, that means that we're probably now rendering\n<TodoListItem key={6}> with the todo item that was being passed to list item\n#8. So, the component instance is still alive, but now it's getting a\ndifferent data object as a prop than it was previously. This may work, but it\nmay also produce unexpected behavior. Also, React will now have to go apply\nupdates to several of the list items to change the text and other DOM\ncontents, because the existing list items are now having to show different\ndata than before. Those updates really shouldn't be necessary here, since none\nof those list items changed.\n\nIf instead we were using key={todo.id} for each list item, React will\ncorrectly see that we deleted two items and added three new ones. It will\ndestroy the two deleted component instances and their associated DOM, and\ncreate three new component instances and their DOM. This is better than having\nto unnecessarily update the components that didn't actually change.\n\nKeys are useful for component instance identity beyond lists as well. You can\nadd a key to any React component at any time to indicate its identity, and\nchanging that key will cause React to destroy the old component instance and\nDOM and create new ones. A common use case for this is a list + details form\ncombination, where the form shows the data for the currently selected list\nitem. Rendering <DetailForm key={selectedItem.id}> will cause React to destroy\nand re-create the form when the selected item changes, thus avoiding any\nissues with stale state inside the form.\n\n### Render Batching and Timing \ud83d\udd17\ufe0e\n\nBy default, each call to setState() causes React to start a new render pass,\nexecute it synchronously, and return. However, React also applies a sort of\noptimization automatically, in the form of render batching. Render batching is\nwhen multiple calls to setState() result in a single render pass being queued\nand executed, usually on a slight delay.\n\nThe React community often describes this as \"state updates may be\nasynchronous\". The new React docs also describe it as \"State is a Snapshot\".\nThat's a reference to this render batching behavior.\n\nIn React 17 and earlier, React only did batching in React event handlers such\nas onClick callbacks. Updates queued outside of event handlers, such as in a\nsetTimeout, after an await, or in a plain JS event handler, were not queued,\nand would each result in a separate re-render.\n\nHowever, React 18 now does \"automatic batching\" of all updates queued in any\nsingle event loop tick. This helps cut down on the overall number of renders\nneeded.\n\nLet's look at a specific example.\n\n    \n    \n    const [counter, setCounter] = useState(0); const onClick = async () => { setCounter(0); setCounter(1); const data = await fetchSomeData(); setCounter(2); setCounter(3); };\n\nWith React 17, this executed three render passes. The first pass will batch\ntogether setCounter(0) and setCounter(1), because both of them are occurring\nduring the original event handler call stack, and so they're both occurring\ninside the unstable_batchedUpdates() call.\n\nHowever, the call to setCounter(2) is happening after an await. This means the\noriginal synchronous call stack is done, and the second half of the function\nis running much later in a totally separate event loop call stack. Because of\nthat, React will execute an entire render pass synchronously as the last step\ninside the setCounter(2) call, finish the pass, and return from setCounter(2).\n\nThe same thing will then happen for setCounter(3), because it's also running\noutside the original event handler, and thus outside the batching.\n\nHowever, with React 18, this executes two render passes. The first two,\nsetCounter(0) and setCounter(1), are batched together because they're in one\nevent loop tick. Later, after the await, both setCounter(2) and setCounter(3)\nare batched together - even though they're much later, that's also two state\nupdates queued in the same event loop, so they get batched into a second\nrender.\n\n### Async Rendering, Closures, and State Snapshots \ud83d\udd17\ufe0e\n\nOne extremely common mistake we see all the time is when a user sets a new\nvalue, then tries to log the existing variable name. However, the original\nvalue gets logged, not the updated value.\n\n    \n    \n    function MyComponent() { const [counter, setCounter] = useState(0); const handleClick = () => { setCounter(counter + 1); // \u274c THIS WON'T WORK! console.log(counter); // Original value was logged - why is this not updated yet?????? }; }\n\nSo, why doesn't this work?\n\nAs mentioned above, it's common for experienced users to say \"React state\nupdates are async\". This is sort of true, but there's a bit more nuance then\nthat, and actually a couple different problems at work here.\n\nStrictly speaking, the React render is literally synchronous - it will be\nexecuted in a \"microtask\" at the very end of this event loop tick. (This is\nadmittedly being pedantic, but the goal of this article is exact details and\nclarity.) However, yes, from the point of view of that handleClick function,\nit's \"async\" in that you can't immediately see the results, and the actual\nupdate occurs much later than the setCounter() call.\n\nHowever, there's a bigger reason why this doesn't work. The handleClick\nfunction is a \"closure\" - it can only see the values of variables as they\nexisted when the function was defined. In other words, these state variables\nare a snapshot in time.\n\nSince handleClick was defined during the most recent render of this function\ncomponent, it can only see the value of counter as it existed during that\nrender pass. When we call setCounter(), it queues up a future render pass, and\nthat future render will have a new counter variable with the new value and a\nnew handleClick function... but this copy of handleClick will never be able to\nsee that new value.\n\nThe new React docs cover this in more detail in the section State as a\nSnapshot, which is highly recommended reading.\n\nGoing back to the original example: trying to use a variable right after you\nset an updated value is almost always the wrong approach, and suggests you\nneed to rethink how you are trying to use that value.\n\n### Render Behavior Edge Cases \ud83d\udd17\ufe0e\n\n#### Commit Phase Lifecycles \ud83d\udd17\ufe0e\n\nThere's some additional edge cases inside of the commit-phase lifecycle\nmethods: componentDidMount, componentDidUpdate, and useLayoutEffect. These\nlargely exist to allow you to perform additional logic after a render, but\nbefore the browser has had a chance to paint. In particular, a common use case\nis:\n\n  * Render a component the first time with some partial but incomplete data\n  * In a commit-phase lifecycle, use refs to measure the real size of the actual DOM nodes in the page\n  * Set some state in the component based on those measurements\n  * Immediately re-render with the updated data\n\nIn this use case, we don't want the initial \"partial\" rendered UI to be\nvisible to the user at all - we only want the \"final\" UI to show up. Browsers\nwill recalculate the DOM structure as it's being modified, but they won't\nactually paint anything to the screen while a JS script is still executing and\nblocking the event loop. So, you can perform multiple DOM mutations, like\ndiv.innerHTML = \"a\"; div.innerHTML = b\";, and the \"a\" will never appear.\n\nBecause of this, React will always run renders in commit-phase lifecycles\nsynchronously. That way, if you do try to perform an update like that\n\"partial->final\" switch, only the \"final\" content will ever be visible on\nscreen.\n\nAs far as I know, state updates in useEffect callbacks are queued up, and\nflushed at the end of the \"Passive Effects\" phase once all the useEffect\ncallbacks have completed.\n\n#### Reconciler Batching Methods \ud83d\udd17\ufe0e\n\nReact reconcilers (ReactDOM, React Native) have methods to alter render\nbatching.\n\nFor React 17 and earlier, you can wrap multiple updates that are outside of\nevent handlers in unstable_batchedUpdates() to batch them together. (Note that\ndespite the unstable_ prefix, it's heavily used and depended on by code at\nFacebook and public libraries - React-Redux v7 used unstable_batchedUpdates\ninternally)\n\nSince React 18 automatically batches by default, React 18 has a flushSync()\nAPI that you can use to force immediate renders and opt out of automatic\nbatching.\n\nNote that since these are reconciler-specific APIs, alternate reconcilers like\nreact-three-fiber and ink may not have them exposed. Check the API\ndeclarations or implementation details to see what's available.\n\n#### <StrictMode> \ud83d\udd17\ufe0e\n\nReact will double-render components inside of a <StrictMode> tag in\ndevelopment. That means the number of times your rendering logic runs is not\nthe same as the number of committed render passes, and you cannot rely on\nconsole.log() statements while rendering to count the number of renders that\nhave occurred. Instead, either use the React DevTools Profiler to capture a\ntrace and count the number of committed renders overall, or add logging inside\nof a useEffect hook or componentDidMount/Update lifecycle. That way the logs\nwill only get printed when React has actually completed a render pass and\ncommitted it.\n\n#### Setting State While Rendering \ud83d\udd17\ufe0e\n\nIn normal situations, you should never queue a state update while in the\nactual rendering logic. In other words, it's fine to create a click callback\nthat will call setSomeState() when the click happens, but you should not call\nsetSomeState() as part of the actual rendering behavior.\n\nHowever, there is one exception to this. Function components may call\nsetSomeState() directly while rendering, as long as it's done conditionally\nand isn't going to execute every time this component renders. This acts as the\nfunction component equivalent of getDerivedStateFromProps in class components.\nIf a function component queues a state update while rendering, React will\nimmediately apply the state update and synchronously re-render that one\ncomponent before moving onwards. If the component infinitely keeps queueing\nstate updates and forcing React to re-render it, React will break the loop\nafter a set number of retries and throw an error (currently 50 attempts). This\ntechnique can be used to immediately force an update to a state value based on\na prop change, without requiring a re-render + a call to setSomeState() inside\nof a useEffect.\n\n## Improving Rendering Performance \ud83d\udd17\ufe0e\n\nAlthough renders are the normal expected part of how React works, it's also\ntrue that that render work can be \"wasted\" effort at times. If a component's\nrender output didn't change, and that part of the DOM didn't need to be\nupdated, then the work of rendering that component was really kind of a waste\nof time.\n\nReact component render output should always be entirely based on current props\nand current component state. Therefore, if we know ahead of time that a\ncomponent's props and state haven't changed, we should also know that the\nrender output would be the same, that no changes are necessary for this\ncomponent, and that we can safely skip the work of rendering it.\n\nWhen trying to improve software performance in general, there are two basic\napproaches: 1) do the same work faster, and 2) do less work. Optimizing React\nrendering is primarily about doing less work by skipping rendering components\nwhen appropriate.\n\n### Component Render Optimization Techniques \ud83d\udd17\ufe0e\n\nReact offers three primary APIs that allow us to potentially skip rendering a\ncomponent:\n\nThe primary method is React.memo(), a built-in \"higher order component\" type.\nIt accepts your own component type as an argument, and returns a new wrapper\ncomponent. The wrapper component's default behavior is to check to see if any\nof the props have changed, and if not, prevent a re-render. Both function\ncomponents and class components can be wrapped using React.memo(). (A custom\ncomparison callback may be passed in, but it really can only compare the old\nand new props anyway, so the main use case for a custom compare callback would\nbe only comparing specific props fields instead of all of them.)\n\nThe other options are:\n\n  * React.Component.shouldComponentUpdate: an optional class component lifecycle method that will be called early in the render process. If it returns false, React will skip rendering the component. It may contain any logic you want to use to calculate that boolean result, but the most common approach is to check if the component's props and state have changed since last time, and return false if they're unchanged.\n  * React.PureComponent: since that comparison of props and state is the most common way to implement shouldComponentUpdate, the PureComponent base class implements that behavior by default, and may be used instead of Component + shouldComponentUpdate.\n\nAll of these approaches use a comparison technique called \"shallow equality\".\nThis means checking every individual field in two different objects, and\nseeing if any of the contents of the objects are a different value. In other\nwords, obj1.a === obj2.a && obj1.b === obj2.b && ......... This is typically a\nfast process, because === comparisons are very simple for the JS engine to do.\nSo, these three approaches do the equivalent of const shouldRender =\n!shallowEqual(newProps, prevProps).\n\nThere's also a lesser-known technique as well: if a React component returns\nthe exact same element reference in its render output as it did the last time,\nReact will skip re-rendering that particular child. There's at least a couple\nways to implement this technique:\n\n  * If you include props.children in your output, that element is the same if this component does a state update\n  * If you wrap some elements with useMemo(), those will stay the same until the dependencies change\n\nExamples:\n\n    \n    \n    // The `props.children` content won't re-render if we update state function SomeProvider({ children }) { const [counter, setCounter] = useState(0); return ( <div> <button onClick={() => setCounter(counter + 1)}>Count: {counter}</button> <OtherChildComponent /> {children} </div> ); } function OptimizedParent() { const [counter1, setCounter1] = useState(0); const [counter2, setCounter2] = useState(0); const memoizedElement = useMemo(() => { // This element stays the same reference if counter 2 is updated, // so it won't re-render unless counter 1 changes return <ExpensiveChildComponent />; }, [counter1]); return ( <div> <button onClick={() => setCounter1(counter1 + 1)}> Counter 1: {counter1} </button> <button onClick={() => setCounter1(counter2 + 1)}> Counter 2: {counter2} </button> {memoizedElement} </div> ); }\n\nConceptually, we could say that the difference between these two approaches\nis:\n\n  * React.memo(): controlled by the child component\n  * Same-element references: controlled by the parent component\n\nFor all of these techniques, skipping rendering a component means React will\nalso skip rendering that entire subtree, because it's effectively putting a\nstop sign up to halt the default \"render children recursively\" behavior.\n\n### How New Props References Affect Render Optimizations \ud83d\udd17\ufe0e\n\nWe've already seen that by default, React re-renders all nested components\neven if their props haven't changed. That also means that passing new\nreferences as props to a child component doesn't matter, because it will\nrender whether or not you pass the same props. So, something like this is\ntotally fine:\n\n    \n    \n    function ParentComponent() { const onClick = () => { console.log('Button clicked'); }; const data = { a: 1, b: 2 }; return <NormalChildComponent onClick={onClick} data={data} />; }\n\nEvery time ParentComponent renders, it will create a new onClick function\nreference and a new data object reference, then pass them as props to\nNormalChildComponent. (Note that it doesn't matter whether we're defining\nonClick using the function keyword or as an arrow function - it's a new\nfunction reference either way.)\n\nThat also means there's no point in trying to optimize renders for \"host\ncomponents\" like a <div> or a <button> by wrapping them up in a React.memo().\nThere's no child component underneath those basic components, so the rendering\nprocess would stop there anyway.\n\nHowever, if the child component is trying to optimize renders by checking to\nsee whether props have changed, then passing new references as props will\ncause the child to render. If the new prop references are actually new data,\nthis is good. However, what if the parent component is just passing down a\ncallback function?\n\n    \n    \n    const MemoizedChildComponent = React.memo(ChildComponent); function ParentComponent() { const onClick = () => { console.log('Button clicked'); }; const data = { a: 1, b: 2 }; return <MemoizedChildComponent onClick={onClick} data={data} />; }\n\nNow, every time ParentComponent renders, these new references are going to\ncause MemoizedChildComponent to see that its props values have changed to new\nreferences, and it will go ahead and re-render... even though the onClick\nfunction and the data object should be basically the same thing every time!\n\nThis means that:\n\n  * MemoizedChildComponent will always re-render even though we wanted to skip rendering most of the time\n  * The work that it's doing to compare its old and new props is wasted effort\n\nSimilarly, note that rendering <MemoizedChild><OtherComponent\n/></MemoizedChild> will also force the child to always render, because\nprops.children is always a new reference.\n\n### Optimizing Props References \ud83d\udd17\ufe0e\n\nClass components don't have to worry about accidentally creating new callback\nfunction references as much, because they can have instance methods that are\nalways the same reference. However, they may need to generate unique callbacks\nfor separate child list items, or capture a value in an anonymous function and\npass that to a child. Those will result in new references, and so will\ncreating new objects as child props while rendering. React doesn't have\nanything built-in to help optimize those cases.\n\nFor function components, React does provide two hooks to help you reuse the\nsame references: useMemo for any kind of general data like creating objects or\ndoing complex calculations, and useCallback specifically for creating callback\nfunctions.\n\n### Memoize Everything? \ud83d\udd17\ufe0e\n\nAs mentioned above, you don't have throw useMemo and useCallback at every\nsingle function or object you pass down as a prop - only if it's going to make\na difference in behavior for the child. (That said, the dependency array\ncomparisons for useEffect do add another use case where the child might want\nto receive consistent props references, which does make things more\ncomplicated.)\n\nThe other question that comes up all the time is \"Why doesn't React wrap\neverything in React.memo() by default?\".\n\nDan Abramov has repeatedly pointed out that memoization does still incur the\ncost of comparing props, and that there are many cases where the memoization\ncheck can never prevent re-renders because the component always receives new\nprops. As an example, see this Twitter thread from Dan:\n\n> Why doesn\u2019t React put memo() around every component by default? Isn\u2019t it\n> faster? Should we make a benchmark to check?\n>\n> Ask yourself:\n>\n> Why don\u2019t you put Lodash memoize() around every function? Wouldn\u2019t that make\n> all functions faster? Do we need a benchmark for this? Why not?\n\nAlso, while I don't have a specific link on it, it's possible that trying to\napply this to all components by default might result in bugs due to cases\nwhere people are mutating data rather than updating it immutably.\n\nI've had some public discussion with Dan about this on Twitter. I personally\nthink it's likely that using React.memo() on a widespread basis would likely\nbe a net gain in overall app rendering perf. As I said in an extended Twitter\nthread last year:\n\n> The React community as a whole seems to be over obsessed with \"perf\", yet\n> much of the discussion revolves around outdated \"tribal wisdom\" passed down\n> via Medium posts and Twitter comments rather than based on concrete usage.\n>\n> There's definitely collective misunderstanding about the idea of a \"render\"\n> and the perf impact. Yes, React is totally based around rendering - gotta\n> render to do anything at all. No, most renders aren't overly expensive.\n>\n> \"Wasted\" rerenders certainly aren't the end of the world. Neither is\n> rerendering the whole app from the root. That said, it's also true that a\n> \"wasted\" rerender with no DOM update is CPU cycles that didn't need to be\n> burned. Is that a problem for most apps? Probably not. Is it something that\n> can be improved? Probably.\n>\n> Are there apps where default \"rerender it all\" approaches aren't sufficient?\n> Of course, that's why sCU, PureComponent, and memo() exist.\n>\n> Should users wrap everything in memo() by default? Probably not, if only\n> because you should think about your app's perf needs. Will it actually hurt\n> if you do? No, and realistically I expect it does have a net benefit\n> (despite Dan's points about wasted comparisons)\n>\n> Are benchmarks flawed, and results highly variable based on scenarios and\n> apps? Of course. That said, it would be REALLY REALLY HELPFUL if folks could\n> start pointing at hard numbers for these discussions instead of playing the\n> telephone game of \"I saw a comment once...\"\n>\n> I'd love to see a bunch of benchmark suites from the React team and the\n> larger community to measure a bunch of scenarios so we could stop arguing\n> about most of this stuff once and for all. Function creation, render cost,\n> optimization... CONCRETE EVIDENCE, PLEASE!\n\nBut, no one's put together any good benchmarks that would demonstrate whether\nor not this is true:\n\n> Dan's standard answer is that app structure and update patterns vary\n> drastically, so it's hard to make a representative benchmark.\n>\n> I still think some actual numbers would be useful to aid the discussion\n\nThere's also an extended issue discussion on \"When should you NOT use\nReact.memo? in the React issues.\n\nNote that the new React docs specifically address the \"memo everything?\"\nquestion:\n\n> Optimizing with memo is only valuable when your component re-renders often\n> with the same exact props, and its re-rendering logic is expensive. If there\n> is no perceptible lag when your component re-renders, memo is unnecessary.\n> Keep in mind that memo is completely useless if the props passed to your\n> component are always different, such as if you pass an object or a plain\n> function defined during rendering. This is why you will often need useMemo\n> and useCallback together with memo.\n>\n> There is no benefit to wrapping a component in memo in other cases. There is\n> no significant harm to doing that either, so some teams choose to not think\n> about individual cases, and memoize as much as possible. The downside of\n> this approach is that code becomes less readable. Also, not all memoization\n> is effective: a single value that\u2019s \u201calways new\u201d is enough to break\n> memoization for an entire component.\n\nSee the details section under that link for further suggestions on avoiding\nunnecessary memoization and improving performance.\n\n### Immutability and Rerendering \ud83d\udd17\ufe0e\n\nState updates in React should always be done immutably. There are two main\nreasons why:\n\n  * depending on what you mutate and where, it can result in components not rendering when you expected they would render\n  * it causes confusion about when and why data actually got updated\n\nLet's look at a couple specific examples.\n\nAs we've seen, React.memo / PureComponent / shouldComponentUpdate all rely on\nshallow equality checks of the current props vs the previous props. So, the\nexpectation is that we can know if a prop is a new value, by doing\nprops.someValue !== prevProps.someValue.\n\nIf you mutate, then someValue is the same reference, and those components will\nassume nothing has changed.\n\nNote that this is specifically when we're trying to optimize performance by\navoiding unnecessary re-renders. A render is \"unnecessary\" or \"wasted\" if the\nprops haven't changed. If you mutate, the component may wrongly think nothing\nhas changed, and then you wonder why the component didn't re-render.\n\nThe other issue is the useState and useReducer hooks. Every time I call\nsetCounter() or dispatch(), React will queue up a re-render. However, React\nrequires that any hook state updates must pass in / return a new reference as\nthe new state value, whether it be a new object/array reference, or a new\nprimitive (string/number/etc).\n\nReact applies all state updates during the render phase. When React tries to\napply a state update from a hook, it checks to see if the new value is the\nsame reference. React will always finish rendering the component that queued\nthe update. However, if the value is the same reference as before, and there\nare no other reasons to continue rendering (such as the parent having\nrendered), React will then throw away the render results for the component and\nbail out of the render pass completely. So, if I mutate an array like this:\n\n    \n    \n    const [todos, setTodos] = useState(someTodosArray); const onClick = () => { todos[3].completed = true; setTodos(todos); };\n\nthen the component will fail to re-render.\n\n(Note that React does actually have a \"fast path\" bailout mechanism that will\nattempt to check the new value before queuing the state update in some cases.\nSince this also relies on a direct reference check, it's another example of\nneeding to do immutable updates.)\n\nTechnically, only the outermost reference has to be immutably updated. If we\nchange that example to:\n\n    \n    \n    const onClick = () => { const newTodos = todos.slice(); newTodos[3].completed = true; setTodos(newTodos); };\n\nthen we have created a new array reference and passed it in, and the component\nwill re-render.\n\nNote that there is a distinct difference in behavior between the class\ncomponent this.setState() and the function component useState and useReducer\nhooks with regards to mutations and re-rendering. this.setState() doesn't care\nif you mutate at all - it always completes the re-render. So, this will re-\nrender:\n\n    \n    \n    const { todos } = this.state; todos[3].completed = true; this.setState({ todos });\n\nAnd in fact, so will passing in an empty object like this.setState({}).\n\nBeyond all the actual rendering behavior, mutation introduces confusion to the\nstandard React one-way data flow. Mutation can lead other code to see\ndifferent values when the expectation was they haven't changed at all. This\nmakes it harder to know when and why a given piece of state was actually\nsupposed to update, or where a change came from.\n\nBottom line: React, and the rest of the React ecosystem, assume immutable\nupdates. Any time you mutate, you run the risk of bugs. Don't do it.\n\n### Measuring React Component Rendering Performance \ud83d\udd17\ufe0e\n\nUse the React DevTools Profiler to see what components are rendering in each\ncommit. Find components that are rendering unexpectedly, use the DevTools to\nfigure out why they rendered, and fix things (perhaps by wrapping them in\nReact.memo(), or having the parent component memoize the props it's passing\ndown.)\n\nAlso, remember that React runs way slower in dev builds. You can profile your\napp in development mode to see which components are rendering and why, and do\nsome comparisons of relative time needed to render components in comparison to\neach other (\"Component B took 3 times as long to render in this commit than\ncomponent A\" did). But, never measure absolute render times using a React\ndevelopment build - only measure absolute times using production builds! (or\nelse Dan Abramov will have to come yell at you for using numbers that aren't\naccurate). Note that you'll need to use a special \"profiling\" build of React\nif you want to actually use the profiler to capture timing data from a prod-\nlike build.\n\n## Context and Rendering Behavior \ud83d\udd17\ufe0e\n\nReact's Context API is a mechanism for making a single user-provided value\navailable to a subtree of components, Any component inside of a given\n<MyContext.Provider> can read the value from that context instance, without\nhaving to explicitly pass that value as a prop through every intervening\ncomponent.\n\nContext is not a \"state management\" tool. You have to manage the values that\nare passed into context yourself. This is typically done by keeping data in\nReact component state, and constructing context values based on that data.\n\n### Context Basics \ud83d\udd17\ufe0e\n\nA context provider receives a single value prop, like <MyContext.Provider\nvalue={42}>. Child components may consume the context by rendering the context\nconsumer component and providing a render prop, like:\n\n<MyContext.Consumer>{ (value) => <div>{value}</div>}</MyContext.Consumer>\n\nor by calling the useContext hook in a function component:\n\nconst value = useContext(MyContext)\n\n### Updating Context Values \ud83d\udd17\ufe0e\n\nReact checks to see if a context provider has been given a new value when the\nsurrounding component renders the provider. If the provider's value is a new\nreference, then React knows the value has changed, and that the components\nconsuming that context need to be updated.\n\nNote that passing a new object to a context provider will cause it to update:\n\n    \n    \n    function GrandchildComponent() { const value = useContext(MyContext); return <div>{value.a}</div>; } function ChildComponent() { return <GrandchildComponent />; } function ParentComponent() { const [a, setA] = useState(0); const [b, setB] = useState('text'); const contextValue = { a, b }; return ( <MyContext.Provider value={contextValue}> <ChildComponent /> </MyContext.Provider> ); }\n\nIn this example, every time ParentComponent renders, React will take note that\nMyContext.Provider has been given a new value, and look for components that\nconsume MyContext as it continues looping downwards. When a context provider\nhas a new value, every nested component that consumes that context will be\nforced to re-render.\n\nNote that from React's perspective, each context provider only has a single\nvalue - doesn't matter whether that's an object, array, or a primitive, it's\njust one context value. Currently, there is no way for a component that\nconsumes a context to skip updates caused by new context values, even if it\nonly cares about part of a new value.\n\nIf a component only needs value.a, and an update is made to cause a new\nvalue.b reference... the rules of immutable updates and context rendering\nrequire that value be a new reference also, and so the component reading\nvalue.a will also render too.\n\n### State Updates, Context, and Re-Renders \ud83d\udd17\ufe0e\n\nIt's time to put some of these pieces together. We know that:\n\n  * Calling setState() queues a render of that component\n  * React recursively renders nested components by default\n  * Context providers are given a value by the component that renders them\n  * That value normally comes from that parent component's state\n\nThis means that by default, any state update to a parent component that\nrenders a context provider will cause all of its descendants to re-render\nanyway, regardless of whether they read the context value or not!.\n\nIf we look back at the Parent/Child/Grandchild example just above, we can see\nthat the GrandchildComponent will re-render, but not because of a context\nupdate - it will re-render because ChildComponent rendered!. In this example,\nthere's nothing trying to optimize away \"unnecessary\" renders, so React\nrenders ChildComponent and GrandchildComponent by default any time\nParentComponent renders. If the parent puts a new context value into\nMyContext.Provider, the GrandchildComponent will see the new value when it\nrenders and use it, but the context update didn't cause GrandchildComponent to\nrender - it was going to happen anyway.\n\n### Context Updates and Render Optimizations \ud83d\udd17\ufe0e\n\nLet's modify that example so that it does actually try to optimize things, but\nwe'll add one other twist by putting a GreatGrandchildComponent at the bottom:\n\n    \n    \n    function GreatGrandchildComponent() { return <div>Hi</div> } function GrandchildComponent() { const value = useContext(MyContext); return ( <div> {value.a} <GreatGrandchildComponent /> </div> } function ChildComponent() { return <GrandchildComponent /> } const MemoizedChildComponent = React.memo(ChildComponent); function ParentComponent() { const [a, setA] = useState(0); const [b, setB] = useState(\"text\"); const contextValue = {a, b}; return ( <MyContext.Provider value={contextValue}> <MemoizedChildComponent /> </MyContext.Provider> ) }\n\nNow, if we call setA(42):\n\n  * ParentComponent will render\n  * A new contextValue reference is created\n  * React sees that MyContext.Provider has a new context value, and thus any consumers of MyContext need to be updated\n  * React will try to render MemoizedChildComponent, but see that it's wrapped in React.memo(). There are no props being passed at all, so the props have not actually changed. React will skip rendering ChildComponent entirely.\n  * However, there was an update to MyContext.Provider, so there may be components further down that need to know about that.\n  * React continues downwards and reaches GrandchildComponent. It sees that MyContext is read by GrandchildComponent, and thus it should re-render because there's a new context value. React goes ahead and re-renders GrandchildComponent, specifically because of the context change.\n  * Because GrandchildComponent did render, React then keeps on going and also renders whatever's inside of it. So, React will also re-render GreatGrandchildComponent.\n\nIn other words, as Sophie Alpert said:\n\n> That React Component Right Under Your Context Provider Should Probably Use\n> React.memo\n\nThat way, state updates in the parent component will not force every component\nto re-render, just the sections where the context is read. (You could also get\nbasically the same result by having ParentComponent render\n<MyContext.Provider>{props.children}</MyContext.Provider>, which leverages the\n\"same element reference\" technique to avoid child components re-rendering, and\nthen rendering <ParentComponent><ChildComponent /></ParentComponent> from one\nlevel up.)\n\nNote, however, that once GrandchildComponent rendered based on the next\ncontext value, React went right back to its default behavior of recursively\nre-rendering everything. So, GreatGrandchildComponent was rendered, and\nanything else under there would have rendered too.\n\n### Context and Renderer Boundaries \ud83d\udd17\ufe0e\n\nNormally, a React app is built entirely with a single renderer like ReactDOM\nor React Native. But, the core rendering and reconciling logic is published as\na package called react-reconciler, and you can use that to build your own\nversion of React that targets other environments. Good examples of this are\nreact-three-fiber, which uses React to drive Three.js models and WebGL\nrendering, and ink, which draws terminal text UIs using React.\n\nOne long-standing limitation is that if you have multiple renderers in an app,\nsuch as showing React-Three-Fiber content inside of ReactDOM, context\nproviders won't pass through the renderer boundary. So, if the component tree\nlooks like this:\n\n    \n    \n    function App() { return ( <MyContext.Provider> <DomComponent> <ReactThreeFiberParent> <ReactThreeFiberChild /> </ReactThreeFiberParent> </DomComponent> </MyContext.Provider> ); }\n\nwhere ReactFiberParent creates and shows content rendered with React-Three-\nFiber, then <ReactThreeFiberChild> will not be able to see the value from\n<MyContext.Provider>.\n\nThis is a known limitation of React and there is currently no official way to\nsolve this.\n\nThat said, the Poimandres org behind React-Three-Fiber has had some internal\nhacks that made context bridging feasible, and they recently released a lib\ncalled https://github.com/pmndrs/its-fine that includes a useContextBridge\nhook that is a valid workaround.\n\n## React-Redux and Rendering Behavior \ud83d\udd17\ufe0e\n\nThe various forms of \"CONTEXT VS REDUX?!?!??!\" seem to be the single most-\nasked question I see in the React community right now. (That question is a\nfalse dichotomy to begin with, as Redux and Context are different tools that\ndo different things.)\n\nThat said, one of the recurring things that people point out when this comes\nup is that \"React-Redux only re-renders the components that actually need to\nrender, so that makes it better than context\".\n\nThat's somewhat true, but the answer is a lot more nuanced than that.\n\n### React-Redux Subscriptions \ud83d\udd17\ufe0e\n\nI've seen a lot of folks repeat the phrase \"React-Redux uses context inside.\"\nAlso technically true, but React-Redux uses context to pass the Redux store\ninstance, not the current state value. That means that we always pass the same\ncontext value into our <ReactReduxContext.Provider> over time.\n\nRemember that a Redux store runs all its subscriber notification callbacks\nwhenever an action is dispatched. UI layers that need to use Redux always\nsubscribe to the Redux store, read the latest state in their subscriber\ncallbacks, diff the values, and force a re-render if the relevant data has\nchanged. The subscription callback process happens outside of React entirely,\nand React only gets involved if React-Redux knows that the data needed by a\nspecific React component has changed (based on the return values of mapState\nor useSelector).\n\nThis results in a very different set of performance characteristics than\ncontext. Yes, it's likely that fewer components will be rendering all the\ntime, but React-Redux will always have to run the mapState/useSelector\nfunctions for the entire component tree every time the store state is updated.\nMost of the time, the cost of running those selectors is less than the cost of\nReact doing another render pass, so it's usually a net win, but it is work\nthat has to be done. However, if those selectors are doing expensive\ntransformations or accidentally returning new values when they shouldn't, that\ncan slow things down.\n\n### Differences between connect and useSelector \ud83d\udd17\ufe0e\n\nconnect is a higher-order component. You pass in your own component, and\nconnect returns a wrapper component that does all the work of subscribing to\nthe store, running your mapState and mapDispatch, and passing the combined\nprops down to your own component.\n\nThe connect wrapper components have always acted equivalent to\nPureComponent/React.memo(), but with a slightly different emphasis: connect\nwill only make your own component render if the combined props it's passing\ndown to your component have changed. Typically, the final combined props are a\ncombination of {...ownProps, ...stateProps, ...dispatchProps}, so any new prop\nreferences from the parent will indeed cause your component to render, same as\nPureComponent or React.memo(). Besides parent props, any new references\nreturned from mapState will also cause your component to render. . (Since you\ncould customize how ownProps/stateProps/dispatchProps are merged, it's also\npossible to alter that behavior.)\n\nuseSelector, on the other hand, is a hook that is called inside of your own\nfunction components. Because of that, useSelector has no way of stopping your\ncomponent from rendering when the parent component renders!.\n\nThis is a key performance difference between connect and useSelector. With\nconnect, every connected component acts like PureComponent, and thus acts as a\nfirewall to prevent React's default render behavior from cascading down the\nentire component tree. Since a typical React-Redux app has many connected\ncomponents, this means that most re-render cascades are limited to a fairly\nsmall section of the component tree. React-Redux will force a connected\ncomponent to render based on data changes, the next 2-3 components below it\nmight render as well, then React runs into another connected component that\ndidn't need to update and that stops the rendering cascade.\n\nIn addition, having more connected components means that each component is\nprobably reading smaller pieces of data from the store, and thus is less\nlikely to have to re-render after any given action.\n\nIf you're exclusively using function components and useSelector, then it's\nlikely that larger parts of your component tree will re-render based on Redux\nstore updates than they would with connect, since there aren't other connected\ncomponents to stop those render cascades from continuing down the tree.\n\nIf that becomes a performance concern, then the answer is to wrap components\nin React.memo() yourself as needed, to prevent unnecessary re-renders caused\nby parent components.\n\n## Future React Improvements \ud83d\udd17\ufe0e\n\n### \"React Forget\" Memoizing Compiler \ud83d\udd17\ufe0e\n\nEver since React hooks first came out and we started dealing with dependency\narrays for hooks like useEffect and useMemo, the React team had said they\nintended the hooks deps arrays to be something that \"a sufficiently advanced\ncompiler could generated automatically\". In other words, use a variable named\ncounter inside of a hook, and the compiler would automatically insert the\n[counter] deps array for you at build time.\n\nDespite popping up in several discussions, the \"sufficiently advanced\ncompiler\" never materialized. The community tried creating their own auto-\nmemoization approaches like a Babel macro, but no official compiler\nappeared...\n\nuntil ReactConf 2021, when the React team gave a talk entitled \"React Without\nMemo\". In that talk they gave a demo of an experimental compiler code-named\n\"React Forget\". It's designed to rewrite the body of function components in\norder to automatically add memoization capabilities.\n\nWhat's really exciting about React Forget is that not only does it try to\nmemoize hook dependency arrays, it also memoizes JSX element return values.\nAnd since we know from earlier that React has a \"same-element reference\"\noptimization that can prevent re-rendering children, this means that React\nForget could, potentially, effectively eliminate unnecessary renders\nthroughout a React component tree!.\n\nAs of October 2022, the React Forget compiler has not yet been released, but\nthe bits of news trickling out of the React team are encouraging. Supposedly\n3-4 engineers are working on building it full-time, with a goal of having\nFacebook.com fully working before it's released publicly for the community to\ntry out. There's also been other hints that the work is going well - the\nuseEvent RFC was closed on the grounds that it might not be entirely necessary\nif React Forget works out, and other discussions have generally suggested\n\"what if the too many renders problem just goes away in the future thanks to\nauto-memoization?\".\n\nSo, no guarantees at this point, but there's reason to be optimistic about the\nchances of React Forget panning out.\n\n### Context Selectors \ud83d\udd17\ufe0e\n\nWe said earlier that the biggest weakness of the Context API is that a\ncomponent cannot selectively subscribe to parts of a context value, so all\ncomponents reading that context will re-render when the value is updated.\n\nIn July 2019, a community member wrote an RFC proposing a \"context selectors\"\nAPI, which would allow components to selectively subscribe to just part of a\ncontext. That RFC sat around for a while, and finally showed signs of life.\nAndrew Clark then implemented a proof of concept approach for context\nselectors in React in January 2021, with the new ability hidden behind an\ninternal feature flag for experimentation.\n\nSadly, there has been no further movement on the context selectors feature\nsince then. From the discussion and PR, the proof of concept version will\nalmost definitely require changes and iteration to the API design before it\ncould be finalized. It's also possible that this may be another feature that\nis semi-obsolete if the React Forget compiler works out.\n\nIf this feature actually does ever get released, it will make the Context +\nuseReducer combo a more viable option for larger amounts of React app state.\n\nIt's worth noting that there is a useContextSelector library from Daishi Kato\n(maintainer of Zustand and Jotai) that may be useful as a polyfill in the\nmeantime.\n\n## Summary \ud83d\udd17\ufe0e\n\n  * React always recursively renders components by default, so when a parent renders, its children will render\n  * Rendering by itself is fine - it's how React knows what DOM changes are needed\n  * But, rendering takes time, and \"wasted renders\" where the UI output didn't change can add up\n  * It's okay to pass down new references like callback functions and objects most of the time\n  * APIs like React.memo() can skip unnecessary renders if props haven't changed\n  * But if you always pass new references down as props, React.memo() can never skip a render, so you may need to memoize those values\n  * Context makes values accessible to any deeply nested component that is interested\n  * Context providers compare their value by reference to know if it's changed\n  * A new context values does force all nested consumers to re-render\n  * But, many times the child would have re-rendered anyway due to the normal parent->child render cascade process\n  * So you probably want to wrap the child of a context provider in React.memo(), or use {props.children}, so that the whole tree doesn't render all the time when you update the context value\n  * When a child component is rendered based on a new context value, React keeps cascading renders down from there too\n  * React-Redux uses subscriptions to the Redux store to check for updates, instead of passing store state values by context\n  * Those subscriptions run on every Redux store update, so they need to be as fast as possible\n  * React-Redux does a lot of work to ensure that only components whose data changed are forced to re-render\n  * connect acts like React.memo(), so having lots of connected components can minimize the total number of components that render at a time\n  * useSelector is a hook, so it can't stop renders caused by parent components. An app that only has useSelector everywhere should probably add React.memo() to some components to help avoid renders from cascading all the time.\n  * The \"React Forget\" auto-memoizing compiler may drastically simplify all this if it does get released.\n\n## Final Thoughts \ud83d\udd17\ufe0e\n\nClearly, the whole situation is a lot more complex than just \"context makes\neverything render, Redux doesn't, use Redux\". Don't get me wrong, I want\npeople to use Redux, but I also want people to clearly understand the\nbehaviors and tradeoffs involved in different tools so they can make informed\ndecisions about what's best for their own use cases.\n\nSince everyone always seems to ask \"When should I use Context, and when should\nI use (React-)Redux?\", let me go ahead and recap some standard rules of thumb:\n\n  * Use context if:\n\n    * You just need to pass some simple values that don't change often\n    * You have some state or functions that need to be accessed through part of the app, and you don't want to pass them as props all the way down\n    * You want to stick with what's built in to React and not add additional libraries\n  * Use (React-)Redux if:\n\n    * You have large amounts of application state that are needed in many places in the app\n    * The app state is updated frequently over time\n    * The logic to update that state may be complex\n    * The app has a medium or large-sized codebase, and might be worked on by many people\n\nPlease note that these are not hard, exclusive rules - they are just some\nsuggested guidelines for when these tools might make sense! As always, please\ntake some time to decide for yourself what the best tool is for whatever\nsituation you're dealing with.\n\nOverall, hopefully this explanation helps folks understand the bigger picture\nof what's actually going on with React's rendering behavior in various\nsituations.\n\n## Further Information \ud83d\udd17\ufe0e\n\nI recorded a conference talk version of this post for React Advanced in\nOctober 2022:\n\n  * React Advanced 2022 - A (Brief) Guide to React Rendering Behavior\n\nI've seen several other good articles specifically covering \"how does React\nrendering work?\" recently, and I'll point to those as recommended:\n\n  * Recommended React Rendering articles:\n\n    * Josh Comeau: Why React Re-Renders\n    * Zhenghao He: When does React render your component?\n    * Alex Sidorenko: Visual Guide to React Rendering series\n    * Nadia Makarevich: React re-renders guide\n\nBeyond that, see these additional resources:\n\n  * General\n\n    * Dave Ceddia: A Visual Guide to References in JavaScript\n  * React Render Behavior\n\n    * React docs: Reconciliation\n    * React class lifecycle methods diagram\n    * React hooks lifecycle diagram\n    * React issues: bailing out of context and hooks\n    * React issues: why setState is async\n    * Seb Markbage: \"Context is good for low-frequency updates, not Flux-like state propagation\"\n    * Ryan Florence: React, Inline Functions, and Performance\n    * James K Nelson: React context and performance\n    * Will It Render? A visualization for component rendering\n  * Optimizing Render Performance\n\n    * React docs: Optimizing Performance\n    * Kent C Dodds: Fix the slow render before you fix the re-render\n    * Kent C Dodds: When to useMemo and useCallback\n    * Kent C Dodds: One simple trick to optimize React re-renders\n    * React issues: When should you NOT use React.memo?\n  * Profiling React Components\n\n    * React docs: Introducing the React DevTools Profiler\n    * React DevTools profiler interactive tutorial\n    * Kent C Dodds: Profile a React App for Performance\n    * Shawn Wang: Using the React DevTools Profiler to Diagnose React App Performance Issues\n    * Use the React Profiler for Performance\n  * React-Redux Performance\n\n    * Practical Redux, Part 6: Connected Lists and Performance\n    * Idiomatic Redux: The History and Implementation of React-Redux\n    * React-Redux docs: mapState Usage Guide - Performance\n    * High-Performance Redux\n    * React-Redux links: React/Redux Performance\n\nThis is a post in the Blogged Answers series. Other posts in this series:\n\n  * Aug 08, 2023 - Blogged Answers: My Experience Modernizing Packages to ESM\n  * Jul 06, 2022 - Blogged Answers: How I Estimate NPM Package Market Share (and how Redux usage compares to other libraries)\n  * Jun 22, 2021 - Blogged Answers: The Evolution of Redux Testing Approaches\n  * Jan 18, 2021 - Blogged Answers: Why React Context is Not a \"State Management\" Tool (and Why It Doesn't Replace Redux)\n  * Jun 21, 2020 - Blogged Answers: React Components, Reusability, and Abstraction\n  * May 17, 2020 - Blogged Answers: A (Mostly) Complete Guide to React Rendering Behavior\n  * May 12, 2020 - Blogged Answers: Why I Write\n  * Feb 22, 2020 - Blogged Answers: Why Redux Toolkit Uses Thunks for Async Logic\n  * Feb 22, 2020 - Blogged Answers: Coder vs Tech Lead - Balancing Roles\n  * Jan 19, 2020 - Blogged Answers: React, Redux, and Context Behavior\n  * Jan 01, 2020 - Blogged Answers: Years in Review, 2018-2019\n  * Jan 01, 2020 - Blogged Answers: Reasons to Use Thunks\n  * Jan 01, 2020 - Blogged Answers: A Comparison of Redux Batching Techniques\n  * Nov 26, 2019 - Blogged Answers: Learning and Using TypeScript as an App Dev and a Library Maintainer\n  * Jul 10, 2019 - Blogged Answers: Thoughts on React Hooks, Redux, and Separation of Concerns\n  * Jan 19, 2019 - Blogged Answers: Debugging Tips\n  * Mar 29, 2018 - Blogged Answers: Redux - Not Dead Yet!\n  * Dec 18, 2017 - Blogged Answers: Resources for Learning Redux\n  * Dec 18, 2017 - Blogged Answers: Resources for Learning React\n  * Aug 02, 2017 - Blogged Answers: Webpack HMR vs React-Hot-Loader\n  * Sep 14, 2016 - How I Got Here: My Journey Into the World of Redux and Open Source\n\n  * \u2190 Older\n\n# Mark Erikson\n\nCollector of interesting links, answerer of questions\n\n  * Newer \u2192\n\n## Recent Posts\n\nReact Summit US 2023: What's New in Redux Toolkit 2.0 React Advanced 2023 -\nBuilding Better React DevTools with Replay Time Travel React Rally 2023 - A\n(Brief) Guide to React Rendering Behavior Blogged Answers: My Experience\nModernizing Packages to ESM Presentations: Debugging JavaScript\n\n## Top Tags\n\n(All Tags)\n\n60 redux 56 javascript 47 react 30 greatest-hits 27 presentation\n\n## Greatest Hits\n\nGreatest Hits: The Most Popular and Most Useful Posts I've Written Redux - Not\nDead Yet! Why React Context is Not a \"State Management\" Tool (and Doesn't\nReplace Redux) A (Mostly) Complete Guide to React Rendering Behavior\nPresentations: Modern Redux with Redux Toolkit When (and when not) to reach\nfor Redux The Tao of Redux, Part 1 - Implementation and Intent The History and\nImplementation of React-Redux Thoughts on React Hooks, Redux, and Separation\nof Concerns React Boston 2019: Hooks HOCs, and Tradeoffs Using Git for Version\nControl Effectively\n\n## Series\n\n21 Blogged Answers 4 Codebase Conversion 4 Coding Career Advice 2\nDeclaratively Rendering Earth In 3d 5 How Web Apps Work 8 Idiomatic Redux 6\nNewsletter 13 Practical Redux 28 Presentations 5 Site Administrivia\n\nAbout\n\nSponsor @markerikson\n\n", "frontpage": false}
