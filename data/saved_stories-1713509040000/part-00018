{"aid": "40081102", "title": "Absolut 0.2.1", "url": "https://www.fuzzypixelz.com/blog/absolut-yeet-z3/", "domain": "fuzzypixelz.com", "votes": 1, "user": "fuzzypixelz", "posted_at": "2024-04-18 21:48:19", "comments": 0, "source_title": "fuzzypixelz", "source_text": "Mahmoud Mazouz\n\n\u0645\n\nAnnouncing Absolut 0.2.1Yeeting Z3Published on 18 April 2024Last updated on 18\nApril 2023\n\nIn Autogenerated Bytewise SIMD-Optimized Look-Up Tables I introduced Absolut,\na Rust library to facilitate the implementation of bytewise SIMD lookup\ntables. Version 0.1.1 of Absolut heavily relied on the Z3 Theorem Prover to\ncompute lookup tables from declarative map definitions. This resulted in a few\nissues:\n\n  1. The z3 crate either uses a system-installed copy of Z3 or builds a locally bundled copy of it. Needless to say, this is too much software bloat for what Absolut essentially is: a set of procedural macros.\n\n  2. An SMT solver is a relatively opaque program. When Absolut inevitably fails to generate a lookup table because Z3 deemed it unsatisfiable, it's hard to determine the reason for the failure.\n\n  3. The execution time of Z3 is unpredictable. While it's possible to set an upper limit to it, such a change would result in less chances of finding a solution.\n\nPutting aside technical issues around the use of Z3, the project suffered from\na lack of documentation: except for the aforementioned post, I provided no\nREADME and no rustdoc documentation. At the time, I was so focused on getting\na proof of concept off the ground that I neglected everything I didn't believe\nto be not strictly essential.\n\n## Moving away from SMT\n\nIn version 0.1.1, Absolut formulated the problem of generating a lookup table\n(referred to from now on as \"The Problem\") in first order logic. This allowed\nfor expressing The Problem in terms of Z3's supported theories (e.g. fixed-\nsize bit-vectors) at a relatively high level. In other words, using an SMT\nsolver provided greater expressive power to implement and maintain Absolut.\n\nOn the downside, I was locked into the ecosystem of SMT solvers, which are\ncomplex and hard to embed into a small Rust library. So I reformulated The\nProblem in terms of propositional logic to use an SAT solver instead. A SAT\nsolver is relatively easier to implement and there even exist two notable\nCDCL-based implementations for Rust: Varisat and Splr.\n\nMy goal at this point was to implement an embedded SAT solver for Absolut. I\nstarted out by implementing Donald Knuth's SAT0 algorithm in Rust, but I\nwasn't satisfied with its performance (or rather lack thereof). It often\nfailed to terminate after multiple hours when used to generate a lookup table.\n\nBefore putting enormous effort into implementing a more sophisticated SAT\nsolver, I asked on StackOverflow if I would benefit from a specialized SAT\nsolver in the first place. The answer was the following:\n\n> [...] That points to the main weakness of the SAT formulation: it\u2019s highly\n> symmetric, and basic branching strategies will struggle. Sophisticated SAT\n> solvers can detect symmetry and prune redundant branches, but the logic is\n> complicated, and you really don\u2019t want to implement it yourself for one\n> application.\n>\n> \u2014 David Eisenstat, stackoverflow.com\n\nAt this point, my goal of implementing a specialized SAT solver specifically\noptimized for usage inside Absolut grew more daunting. So I set out to\nevaluate the existing Rust-based SAT solvers to see if they work well enough\nfor my use case.\n\nI proceeded to contact Jannis Harder aka jix, the author of Varisat, to\ninquire about the state of the project. They told me that they would write\nVarisat very differently had they started it today, but there are no\noutstanding issues with the code nonetheless. They added that Splr on the\nother hand is closer to the state of art than Varisat and is being actively\ndeveloped.\n\nI didn't put too much thought into choosing between Varisat and Splr. In any\ncase, the SAT solver is well encapsulated in the code of Absolut and could be\nreadily swapped if needed. Ultimately, I was more familiar with Varisat as I\nhad played with it in the past, So I went with it as I didn't encounter any\nissues with it while developing Absolut 0.2.0.\n\n## Moving away from SAT\n\nDavid Eisenstat also pointed out in the StackOverflow answer that I can do\nwithout a SAT solver in some particular cases. To understand why, we need a\nquick recap of what The Problem is. Consider the following lookup table,\ndescribed using Absolut:\n\n    \n    \n    #[absolut::one_hot] enum Brainfuck { #[matches(b'<', b'>')] IncDec, #[matches(b'+', b'-')] IncDecPtr, #[matches(b',', b'.')] ReadWrite, // My syntax highlighter is struggling (;\u2323\u0300_\u2323\u0301) #[matches(b'[', b']')] Jump, #[wildcard] Ignored, }\n\nThe above Brainfuck lookup table maps < and > to Brainfuck::IncDec, maps + and\n- to Brainfuck::IncDecPtr, maps , and . to Brainfuck::ReadWrite, maps [ and ]\nto Brainfuck::Jump and maps everything else to Brainfuck::Ignored.\n\nSuch a lookup table could be useful for quickly identifying Brainfuck commands\nin source code, while quickly ignoring comments^1. The following lookup\nfunction illustrates, using non-vectorized code for demonstration purposes,\nhow to use the Brainfuck lookup table:\n\n    \n    \n    fn lookup(input: &[u8; 16], output: &mut [u8; 16]) { for (index, byte) in input.iter().copied().enumerate() { let (lo, hi) = (byte & 0b1111, byte >> 4); output[index] = Brainfuck::TABLE_LOW_NIBBLES[lo as usize] & Brainfuck::TABLE_HIGH_NIBBLES[hi as usize]; } }\n\nAbsolut solves for the Brainfuck::TABLE_LOW_NIBBLES and\nBrainfuck::TABLE_HIGH_NIBBLES tables, as well as all of the enum variants of\nBrainfuck. To do this, it suffices to encode the variants using the One-hot\nbinary encoding. Such that every variant is an 8-bit integer with exactly one\nset bit, except for the #[wildcard]-annotated variant which is always 0.\n\nThis is because the set of bytes matched by each variant can be expressed as a\nCartesian product, e.g. IncDec matches {0x3} \u2a2f {0xE, 0xC} == {(0x3, 0xE),\n(0x3, 0xC)} where (0x3, 0xE) encodes 0x3E == b'<' and (0x3, 0xC) encodes 0x3C\n== b'>'. When this property is satisfied, one can simply set the exact same\nbit position in Brainfuck::TABLE_LOW_NIBBLES[0x3],\nBrainfuck::TABLE_HIGH_NIBBLES[0xE], Brainfuck::TABLE_LOW_NIBBLES[0xC] and\nBrainfuck::IncDec.\n\n    \n    \n    Brainfuck::IncDec as u8 == Brainfuck::TABLE_LOW_NIBBLES[0x3] & Brainfuck::TABLE_HIGH_NIBBLES[0xE];\n    \n    \n    Brainfuck::IncDec as u8 == Brainfuck::TABLE_LOW_NIBBLES[0x3] & Brainfuck::TABLE_HIGH_NIBBLES[0xC];\n\nThis algorithm is implemented in the absolut::one_hot procedural macro. The\ndownside of one_hot is that it only supports up to 9 variants. On the upside,\nit's much simpler to implement and reason about.\n\nAbsolut 0.2.1 introduces yet another lookup table generation algorithm, called\nabsolut::composite, which allows for arbitrary byte-to-byte maps using NEON on\nAArch64. If we change the above Brainfuck lookup table to use\n#[absolut::composite] instead of #[absolut::one_hot], then the lookup function\nbecomes:\n\n    \n    \n    fn lookup(input: &[u8; 16], output: &mut [u8; 16]) { for (index, byte) in input.iter().copied().enumerate() { output[index] = match byte { 0..=63 => Brainfuck::TABLE_QUARTERS[0][byte as usize], 64..=127 => Brainfuck::TABLE_QUARTERS[1][byte as usize - 64], 128..=191 => Brainfuck::TABLE_QUARTERS[2][byte as usize - 128], 192..=255 => Brainfuck::TABLE_QUARTERS[3][byte as usize - 192], }; } }\n\nThe idea here is to use four distinct lookup tables, one for each quarter of\nthe range of all bytes. I recommend reading Arbitrary byte-to-byte maps using\nARM NEON? by Daniel Lemire for more information. I also came across an\napplication of this idea in Beating the Fastest Lexer Generator in Rust by\nAdrian Alic.\n\n## rustdoc shenanigans\n\nWhen writing rustdoc documentation for Absolut 0.2.1, I couldn't figure out\nhow to get the \"Available on crate feature feature only.\" notices. rustdoc by\ndefault only builds documentation for default crate features. However, if you\nenable a non-default feature in the rustdoc build, rustdoc doesn't mark the\nfeatured-gated items as such. To achieve that, you need to enable the\ndoc_auto_cfg unstable language feature.\n\nBut that doesn't work in Stable Rust! Thankfully, the docs.rs build uses\nNightly Rust. So it's possible to enable it there only:\n\n    \n    \n    [package.metadata.docs.rs] all-features = true rustdoc-args = [\"--cfg\", \"doc_auto_cfg\"]\n\nWhat took me the longest time to realize was how to test the build with\ndoc_auto_cfg locally without building with Nightly Rust and adding\n#![feature(doc_auto_cfg)] in the crate root. For that something like\n#![cfg_attr(absolut_docs, feature(doc_auto_cfg))] is needed, which means that\nif and only if the crate is configured with --cfg absolut_docs then the\nattribute should expand to #![feature(doc_auto_cfg)], otherwise no feature is\nenabled.\n\n^1\n\nIf you manage to implement such a thing, please email me! Bonus points if it's\nfaster than scalar code!\n\n\u21a9\n\nThis article is licensed under CC BY 4.0.\n\n", "frontpage": false}
