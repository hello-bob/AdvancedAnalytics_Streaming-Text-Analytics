{"aid": "40176597", "title": "Laws of Software Evolution", "url": "https://two-wrongs.com/laws-of-software-evolution", "domain": "two-wrongs.com", "votes": 4, "user": "thunderbong", "posted_at": "2024-04-27 02:27:58", "comments": 0, "source_title": "Laws of Software Evolution", "source_text": "Laws of Software Evolution\n\n# Two Wrongs\n\n## Laws of Software Evolution\n\n# Laws of Software Evolution\n\nby kqr, published 2024-03-25\n\nTags:\n\n  * design\n  * management\n  * organisations\n  * product_development\n\nAndrew Kelly has written a thoughtful article on why we can\u2019t have nice\nsoftware. He acknowledges that software often gets continuous maintenance, and\nnotes that this is curious, since \u201cbits don\u2019t actually rot\u201d on their own, i.e.\nsoftware should not get worse just by existing. He searches for another\nexplanation for this maintenance effort, and settles on it being a\nmanufactured demand. Andrew Kelly says continuous maintenance is a corporate\nconspiracy where in order to make profits companies make changes that are not\nnecessary.\n\nI take issue with this simplification. It\u2019s true that some types of software\ncan be written to a detailed specification and once it is fulfilled to the\nletter the software is done.\n\nMost software I come in contact with is not of that type.\n\n# Lehman\u2019s Laws of Software Evolution\n\nThe software I encounter most is software that interacts with a changing\nworld. It\u2019s software that needs to adapt to other software, but critically, it\nneeds to adapt to its users \u2013 to people! People change their attitudes and\nprocesses in response to the environment, and the software needs to adapt\naround that.^1 This is ultimately a good thing. Imagine if we didn\u2019t change\nhow we build roads in response to new types of vehicles! Or didn\u2019t change how\nwe handle user data in response to security breaches. In almost any human\nbehaviour change, there is a software system that will struggle to accept it,\nbecause software is not good at improvisation.\n\nBased on this, Lehman formulated some laws of software evolution.^2 On\nunderstanding laws, evolution, and conservation in the large-program life\ncycle; Lehman; Journal of Systems and Software; 1980. This was in 1974, before\ncompanies had started with the practises Andrew Kelly discusses, so the idea\nof software needing continuous maintenance may be older than exploiting\nfinished software for more profit.\n\nMany of the observations Lehman offers in his 1980 article directly contradict\nobservations I\u2019ve made myself, so I don\u2019t propose a blind acceptance of all he\nsays.^3 I suggest reading his paper to evaluate the scientific basis more\nclearly for yourself. But the first two laws he summarises I carry close to my\nheart:\n\n  1. Software exists to support a real-world task, and as the real world changes, the software must change with it or become increasingly less relevant.\n  2. As software is changed, its complexity will increase, increasing the cost of further changes \u2013 unless effort is spent countering this effect.\n\nI have found these laws to be useful guides through multiple problems I\u2019ve\nencountered professionally. One example was when a team was stuck in a\nreinforcing feedback loop of increasing difficulty of change, and the way out\nwas to establish stricter quality controls on changes to turn the loop around.\n\nAnother case was when a product was discontinued but bug fixes were supported\nfor existing customers of that product. There was a temptation to make fixes\nthrough ugly hacks to spend as little development time as possible on that\nproduct. As sensible as that sounds, in this case the customers would not be\nmigrated off that product for several years. When problems are solved with\nquick hacks, the second law of software evolution is accelerated, and thus\nmaintenance will cost more and more as time goes on. On a long time frame,\nsuch as in that case, the better choice is to spend more on fixes up front, to\nreduce the total cost. The cost savings of discontinuing the product should\ncome from a reduced number of fixes (only fix critical bugs, not long-lived\nquirks), rather than reduced effort per bug fix.\n\n# Bonus content: requirements and change\n\nRe-reading the Lehman article I want to quote two sections that seem\nparticularly insightful. One concerns the complex network of relationships\nsoftware forms with its environment.\n\n> Good intentions, hopes of correctness, wishful thinking, even managerial\n> edict cannot change the semantics of the code as written or its effect when\n> executed. Nor can they after the fact affect the relationship between the\n> desires, needs, and requirements of users and the program [...]\n> implementation; nor between any of these and operational circumstances \u2013 the\n> real world.\n\nWe often think of software development as a ticket-in-code-out business but\nthis is really only a very small portion of the entire thing. Completely\nindependently of the work done as a programmer, there exists users with\ndifferent jobs they are trying to perform, and they may or may not find it\nconvenient to slot our software into that job. A manager is not necessarily\nthe right person to evaluate how good a job we are doing because they also\nexist independently of the user\u2013software\u2013programmer network, and have their\nown sets of priorities which may or may not align with the rest of the system.\n\nThen we move on to how software change is different from change in many other\nengineering fields.\n\n> A widely held view is that the details of a desired change need \u201conly\u201d be\n> written down and then applied without further real effort to all instnaces\n> of the system. As a consequence, changes are superimposed in a current\n> embodiment. This contrasts strongly with normal industrial practice where\n> conceptual changes are inputs to a redesign and recreation process that\n> ultimately produces a new instance of the system.\n\nCode is malleable enough that we think of applying changes on top of existing\ncode to get a new product, slightly different from the previous one. In this\nway, code is more similar to genetic material than other types of design.\nThere are two possible takeaways from this:\n\n  * Either we can take note on how other industries are doing things and set up redesign processes to reduce the effects of the second law of software evolution; or\n  * we should embrace the malleability of code and avoid redesign processes at all costs! We do this in full knowledge that it accelerates the second law of software evolution, so we invest significantly in continuous refactoring to work toward a better shape for the software.\n\nI\u2019m in the second camp, but then again, I haven\u2019t work in other engineering\nfields so what do I know?\n\n# Sidenotes\n\n^1\n\nThis is ultimately a good thing. Imagine if we didn\u2019t change how we build\nroads in response to new types of vehicles! Or didn\u2019t change how we handle\nuser data in response to security breaches. In almost any human behaviour\nchange, there is a software system that will struggle to accept it, because\nsoftware is not good at improvisation.\n\n^2\n\nOn understanding laws, evolution, and conservation in the large-program life\ncycle; Lehman; Journal of Systems and Software; 1980.\n\n^3\n\nI suggest reading his paper to evaluate the scientific basis more clearly for\nyourself.\n\nIf you liked this and want more you should buy me a coffee. That helps me turn\nmy 110+ ideas backlog into articles.\n\nShoutout to my amazing wife without whose support I would never make it past\nthe first sentence. \u2665\n\nS = k log W.\n\nComments? Send me an email.\n\n", "frontpage": true}
