{"aid": "40104866", "title": "Our Journey Migrating to AWS IMDSv2", "url": "https://slack.engineering/our-journey-migrating-to-aws-imdsv2/", "domain": "slack.engineering", "votes": 1, "user": "kiyanwang", "posted_at": "2024-04-21 11:36:22", "comments": 0, "source_title": "Our Journey Migrating to AWS IMDSv2 - Slack Engineering", "source_text": "Our Journey Migrating to AWS IMDSv2 - Slack Engineering\n\nSkip to content\n\nOur Journey Migrating to AWS IMDSv2\n\n# Our Journey Migrating to AWS IMDSv2\n\nArchie Gunasekara Staff Software Engineer, Cloud Foundations\n\n11 minutes \u2022 Written 4 months ago\n\nWe are heavy users of Amazon Compute Compute Cloud (EC2) at Slack \u2014 we run\napproximately 60,000 EC2 instances across 17 AWS regions while operating\nhundreds of AWS accounts. A multitude of teams own and manage our various\ninstances.\n\nThe Instance Metadata Service (IMDS) is an on-instance component that can be\nused to gain an insight to the instance\u2019s current state. Since it first\nlaunched over 10 years ago, AWS customers used this service to gather useful\ninformation about their instances. At Slack, IMDS is used heavily for instance\nprovisioning, and also used by tools that need to understand their running\nenvironments.\n\nInformation exposed by IMDS includes IAM credentials, metrics about the\ninstance, security group IDs, and a whole lot more. This information can be\nhighly sensitive \u2013 if an instance is compromised, an attacker may be able to\nuse instance metadata to gain access to other Slack services on the network.\n\nIn 2019, AWS released a new version of IMDS (IMDSv2) where every request is\nprotected by session authentication. As part of our commitment to high\nsecurity standards, Slack moved the entire fleet and tools to IMDSv2. In this\narticle, we are going to discuss the pitfalls of using IMDSv1 and our journey\ntowards fully migrating to IMDSv2.\n\n## The v2 difference\n\nIMDSv1 uses a simple request-and-response pattern that can magnify the impact\nof Server Side Request Forgery (SSRF) vulnerabilities \u2014 if an application\ndeployed on an instance is vulnerable to SSRF, an attacker can exploit the\napplication to make requests on their behalf. Since IMDSv1 supports simple GET\nrequests, they can extract credentials using its API.\n\nIMDSv2 eliminates this attack vector by using session-oriented requests.\nIMDSv2 works by requiring these two steps:\n\n  1. Make a PUT request with the header X-aws-ec2-metadata-token-ttl-secondsheader, and receive a token that is valid for the TTL provided in the request\n  2. Use that token in a HTTP GET request with the header named X-aws-ec2-metadata-token to make any follow-up IMDS calls\n\nWith IMDSv2, rather than simply making HTTP GET requests, an attacker needs to\nexploit vulnerabilities to make PUT requests with headers. Then they will have\nto use the obtained credentials to make follow-up GET requests with headers to\naccess IMDS data. This makes it much more challenging for attackers to access\nIMDS via vulnerabilities such as SSRF.\n\n## Our journey towards IMDSv2\n\nAt Slack there are several instance provisioning mechanisms at play, such as\nTerraform, CloudFormation and various in-house tools that call the AWS EC2\nAPI. As an organization, we rely heavily on IMDS to get insights into our\ninstances during provisioning and the lifecycle of these instances.\n\nWe create AWS accounts per environment (Sandbox, Dev and Prod) and per service\nteam and sometimes even per application \u2013 so we have hundreds of AWS accounts.\n\nWe have a single root AWS organization account. All our child accounts are\nmembers of this organization. When we create an AWS account, the account\ncreation process writes information about the account (such as the account ID,\nowner details, and account tags) to a DynamoDB table. Information in this\ntable is accessible via an internal API called Archipelago for account\ndiscovery.\n\n### Figuring out the scale of the problem\n\nBefore migrating, first we needed to understand how many instances in our\nfleet used IMDSv1. For this we used the EC2 CloudWatch metric called\nMetadataNoToken that counts how often the IMDSv1 API was used for a given\ninstance.\n\nWe created an application called imds-cw-metric-collector to map those metrics\nand instance IDs we collected to alert various service teams and applications.\nThe application used our internal Archipelago API to get a list of our AWS\naccounts, the aforementioned MetadataNoToken metric, and talked to our\ninstance provisioning services to collect info like owner IDs and Chef Roles\n(for instances that are using Chef to configure them). Our custom app sent all\nthose metrics to our Prometheus monitoring system.\n\nA dashboard aggregated these metrics to track all instances that made IMDSv1\ncalls. This information was then used to connect with service teams, and work\nwith them to update their services to use IMDSv2.\n\nHowever, the list of EC2 instance IDs and their owners was only a part of the\nequation. We also needed to understand which processes on these instances were\nmaking these calls to the IMDSv1 API.\n\nAt Slack, for the most part, we use Ubuntu and Amazon Linux on our EC2\ninstances. For IMDSv1 call detection, AWS provides a tool called AWS\nImdsPacketAnalyzer. We decided to build the tool and package it up as a Debian\nLinux distribution package (*.deb) in our APT repository. This allowed the\nservice teams to install this tool on demand and investigate IMDSv1 calls.\n\nThis worked perfectly for our Ubuntu 22.04 (Jammy Jellyfish) and Amazon Linux\ninstances. However, the ImdsPacketAnalyzer does not work on our legacy Ubuntu\n18.04 (Bionic Beaver) instances so we had to resort to using tools such as\nlsof and netlogs in some cases.\n\nAs a last resort on some of our dev instances we just turned off IMDSv1 and\nlisted things that were broken.\n\n## Stop calling IMDSv1\n\nOnce we had a list of instances and processes on those instances that were\nmaking the IMDSv1 calls, it was time for us to get to work and update each one\nto use IMDSv2 instead.\n\nUpdating our bash scripts was the easy part, as AWS provides very clear steps\non switching from IMDSv1 and IMDSv2 for these. We also upgraded our AWS CLI to\nthe latest version to get IMDSv2 support. However doing this for services that\nare written using other languages was a bit more complicated. Luckily AWS has\na comprehensive list of libraries that we should be using to enforce IMDSv2\nfor various languages. We worked with service teams to upgrade their\napplications to IMDSv2 supported versions of libraries and roll these out\nacross our fleet.\n\nOnce we had rolled out those changes, the number of instances using IMDSv1\ndropped precipitously.\n\n## Turning off IMDSv1 for new instances\n\nPreventing our services from using the IMDSv1 API only solved part of the\nproblem. We also needed to turn off IMDSv1 on all future instances. To solve\nthis problem, we turned to our provisioning tools.\n\nFirst we looked at our most commonly used provisioning tool, Terraform. Our\nteam provides a set of standard Terraform modules for service teams to use to\ncreate things such as AutoScaling groups, S3 buckets, and RDS instances. These\ncommon modules enable us to make a change in a single place and roll it out to\nmany teams. Service teams that just want to build an AutoScaling group do not\nneed to know the nitty-gritty configurations of Terraform to use one of these\nmodules.\n\nHowever we didn\u2019t want to roll out this change to all our AWS child accounts\nat the same time, as there were service teams that were actively working on\nswitching to IMDSv1 at this time. Therefore we needed a way to exclude those\nteams and their child accounts. We came up with a custom Terraform module\ncalled accounts_using_imdsv1 as the solution.Then we were able to use this\nmodule in our shared Terraform modules to keep or terminate IMDSv1 as per the\nexample below:\n\n    \n    \n    module \"accounts_using_imdsv1\" { source = \"../slack/accounts_using_imdsv\" } resource \"aws_instance\" \"example\" { ami = data.aws_ami.amzn-linux-2023-ami.id instance_type = \"c6a.2xlarge\" subnet_id = aws_subnet.example.id metadata_options { http_endpoint = \"enabled\" http_tokens = module.accounts_using_imdsv1.is_my_account_using_imdsv1 ? \"optional\" : \"required\" } }\n\nWe started with a large list of accounts in the accounts_using_imdsv1 module\nas using IMDSv1, but we were slowly able to remove them as service teams\nmigrated to IMDSv2.\n\n## Blocking instances with IMDSv1 from launching\n\nThe next step for us was to block launching instances with IMDSv1 enabled. For\nthis we turned to AWS Service control policies (SCPs). We updated our SCPs to\nblock launching IMDSv1 supported instances across all our child accounts.\nHowever, similar to the AutoScaling group changes we discussed earlier, we\nwanted to exclude some accounts at the beginning while the service owners were\nworking to switch to IMDSv2. Our accounts_using_imdsv1 Terraform module came\nto the rescue here too. We were able to use this module in our SCPs as below.\nWe blocked the ability to launch instances with IMDSv1 support and also\nblocked the ability to turn on IMDSv1 on existing instances.\n\n    \n    \n    # Block launching instances with IMDSv1 enabled statement { effect = \"Deny\" actions = [ \"ec2:RunInstances\", ] resources = [ \"arn:aws:ec2:*:*:instance/*\", ] condition { test = \"StringNotEquals\" variable = \"ec2:MetadataHttpTokens\" values = [\"required\"] } condition { test = \"StringNotEquals\" variable = \"aws:PrincipalAccount\" values = module.accounts_using_imdsv1.accounts_list_using_imdsv1 } } # Block turning on IMDSv1 if it's already turned off statement { effect = \"Deny\" actions = [ \"ec2:ModifyInstanceMetadataOptions\", ] resources = [ \"arn:aws:ec2:*:*:instance/*\", ] condition { test = \"StringNotEquals\" variable = \"ec2:Attribute/HttpTokens\" values = [\"required\"] } condition { test = \"StringNotEquals\" variable = \"aws:PrincipalAccount\" values = module.accounts_using_imdsv1.accounts_list_using_imdsv1 } } }\n\n## How effective are these SCPs?\n\nSCPs are effective when it comes to blocking most IMDSv1 usage. However there\nare some places where they do not work.\n\nSCPs do not apply to the AWS root organization\u2019s account, and only apply to\nchild accounts that are members of the organization. Therefore, SCPs do not\nprevent launching instances with IMDSv1 enabled, nor turning on IMDSv1 on an\nexisting instance in the root AWS account.\n\nSCPs also do not apply to service-linked roles. For example, if an autoscaling\ngroup launches an instance in response to a scaling event, under the hood the\nAutoScaling service is using a service-linked IAM role managed by AWS and\nthose instance launches are not impacted by the above SCPs.\n\nWe looked at preventing teams from creating AWS Launch Templates that do not\nenforce IMDSv2, but AWS Launch Template policy condition keys currently do not\nprovide support for ec2:Attribute/HttpTokens.\n\n## What other safety mechanisms are in place?\n\nAs there is no 100%-foolproof way to stop someone from launching an\nIMDSv1-enabled EC2 instance, we put in a notification system utilizing AWS\nEventBridge and Lambda.\n\nWe created two EventBridge rules in each of our child accounts using\nCloudTrail events for EC2 events. One rule captures requests to the EC2 API\nand the second captures responses from the EC2 API, telling us when someone is\nmaking a EC2:RunInstances call with IMDSv1 enabled.\n\nRule 1: Capturing the requests\n\n    \n    \n    { \"detail\": { \"eventName\": [\"RunInstances\"], \"eventSource\": [\"ec2.amazonaws.com\"], \"requestParameters\": { \"metadataOptions\": { \"httpTokens\": [\"optional\"] } } }, \"detail-type\": [\"AWS API Call via CloudTrail\"], \"source\": [\"aws.ec2\"] }\n\nRule 2: Capturing the responses\n\n    \n    \n    { \"detail\": { \"eventName\": [\"RunInstances\"], \"eventSource\": [\"ec2.amazonaws.com\"], \"responseElements\": { \"instancesSet\": { \"items\": { \"metadataOptions\": { \"httpTokens\": [\"optional\"] } } } } }, \"detail-type\": [\"AWS API Call via CloudTrail\"], \"source\": [\"aws.ec2\"] }\n\nThese event rules have a target setup to point them at a central event bus\nliving in an account managed by our team.\n\nEvents matching these rules are sent to the central event bus. The Central\nEvent bus captures these events via a similar set of rules. Next it sends them\nthrough an Input Transformer to format the event similar to the following:\n\nInput path:\n\n    \n    \n    { \"account\": \"$.account\", \"instanceid\": \"$.detail.responseElements.instancesSet.items[0].instanceId\", \"region\": \"$.region\", \"time\": \"$.time\" }\n\nInput template:\n\n    \n    \n    { \"source\" : \"slack\", \"detail-type\": \"slack.api.postMessage\", \"version\": 1, \"account_id\": \"<account>\", \"channel_tag\": \"event_alerts_channel_imdsv1\", \"detail\": { \"text\": \":importantred: :provisioning: instance `<instanceid> (<region>)` in the AWS account `<account>` was launched with `IMDSv1` support\" } }\n\nFinally the transformed events get sent a Lambda function in our account.\n\nThis Lambda function uses the account ID from the event and our internal\nArchipelago API to determine the Slack Channel, then sends this event to\nSlack.\n\nThis flow looks like the following:\n\nWe also have a similar alert in place for when IMDSv1 is turned on for an\nexisting instance.\n\n## What about the instances with IMDSv1 enabled?\n\nLaunching new instances with IMDSv2 is cool and all, but what about our\nthousands of existing instances? We needed a way to enforce IMDSv2 on them as\nwell. As we saw above, SCPs do not block launching instances with IMDSv1\nentirely.\n\nThis is why we created a service called IMDSv1 Terminator. It\u2019s deployed on\nEKS and uses an IAM OIDC provider to obtain IAM credentials. These credentials\nhave access to assume a highly restricted role in all our child accounts\ncreated for this very purpose.\n\nThe policy attached to the role assumed by IMDSv1 Terminator in child accounts\nis as below:\n\n    \n    \n    { \"Statement\": [ { \"Action\": \"ec2:ModifyInstanceMetadataOptions\", \"Condition\": { \"StringEquals\": { \"ec2:Attribute/HttpTokens\": \"required\" } }, \"Effect\": \"Allow\", \"Resource\": \"arn:aws:ec2:*:*:instance/*\", \"Sid\": \"\" }, { \"Action\": [ \"ec2:DescribeRegions\", \"ec2:DescribeInstances\" ], \"Effect\": \"Allow\", \"Resource\": \"*\", \"Sid\": \"\" } ], \"Version\": \"2012-10-17\" }\n\nSimilar to our earlier metric collector application, this also uses the\ninternal Archipelago API to get a list of our AWS accounts, lists our EC2\ninstances in batches and analyzes each one and checks if IMDSv1 is enabled. If\nit is, the service will enforce IMDSv2 on the instance.\n\nWhen the service remediates an instance, we get notified in Slack.\n\nInitially we saw hundreds of these messages for existing instances, but as\nthey were remediated and only new instances were launched with IMDSv2, we\nstopped seeing these messages. Now if an instance gets launched with IMDSv1\nsupport enabled we have the comfort of knowing that it\u2019ll get remediated and\nwe\u2019ll get notified.\n\nThis service also sends metrics to our Prometheus monitoring system about the\nIMDS status of our instances. We can easily visualize what AWS accounts and\nregions that are still running IMDSv1 enabled instances, if there are any.\n\n## Some last words\n\nBeing able to enforce IMDSv2 across Slack\u2019s vast network was a challenging but\nrewarding experience for the Cloud Foundations team. We worked with our large\nnumber of service teams to accomplish this goal, in particular our SecOps team\nwho went above and beyond to help us complete the migration.\n\nWant to help us build out our cloud infrastructure? We're hiring! Apply now\n\n  * aws\n  * cloud-computing\n  * infrastructure\n  * security\n\n#### Post Types\n\n  * Post (161)\n\n#### Categories\n\n  * Uncategorized (139)\n\n#### Tags\n\n  * infrastructure (23)\n  * javascript (20)\n  * android (13)\n  * performance (13)\n  * software-development (13)\n\n#### Year\n\n  * 2024 (2)\n  * 2023 (16)\n  * 2022 (21)\n  * 2021 (24)\n  * 2020 (26)\n\n## Most Recent\n\n### How We Built Slack AI To Be Secure and Private\n\n@Slack Engineering\n\nScared Robot\n\n### The Scary Thing About Automating Deploys\n\n@Sean McIlroy\n\n### Building Custom Animations in the Workflow Builder\n\n@Christina Mudarth\n\n### @SlackEng how can I stay up-to-date on what's happening over there?\n\n### Follow us on Twitter\n\n## Recommended Reading\n\n### Slack\u2019s Migration to a Cellular Architecture\n\n@Cooper Bethea\n\n### Executing Cron Scripts Reliably At Scale\n\n@Claire Adams\n\n### Traffic 101: Packets Mostly Flow\n\n@Slack Engineering\n\nSlack uses cookies to allow us to better understand how the site is used. By\ncontinuing to use this site, you consent to this policy. Click to learn more.\n\n# Search results\n\nFiltersShow filters\n\nSort by:\n\n\u2022\u2022\n\n## No results found\n\n## Filter options\n\nSearch powered by Jetpack\n\n", "frontpage": false}
