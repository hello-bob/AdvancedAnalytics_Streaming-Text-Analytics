{"aid": "40285571", "title": "Rethinking string encoding: a 37.5% space efficient encoding than UTF-8 in Fury", "url": "https://fury.apache.org/blog/fury_meta_string_37_5_percent_space_efficient_encoding_than_utf8/", "domain": "apache.org", "votes": 14, "user": "chaokunyang", "posted_at": "2024-05-07 14:02:25", "comments": 11, "source_title": "Meta String: A 37.5% space efficient string encoding than UTF-8 in Fury serialization", "source_text": "Meta String: A 37.5% space efficient string encoding than UTF-8 in Fury serialization | Apache Fury (incubating)\n\nSkip to main content\n\n# Meta String: A 37.5% space efficient string encoding than UTF-8 in Fury\nserialization\n\nMay 6, 2024 \u00b7 7 min read\n\nShawn Yang\n\nApache Fury PPMC Member\n\n## Background\n\nIn rpc/serialization systems, we often need to send\nnamespace/path/filename/fieldName/packageName/moduleName/className/enumValue\nstring between processes.\n\nThose strings are mostly ascii strings. In order to transfer between\nprocesses, we encode such strings using utf-8 encodings. Such encoding will\ntake one byte for every char, which is not space efficient actually.\n\nIf we take a deeper look, we will found that most chars are lowercase chars,\n., $ and _, which can be expressed in a much smaller range 0~32. But one byte\ncan represent range 0~255, the significant bits are wasted, and this cost is\nnot ignorable. In a dynamic serialization framework, such meta will take\nconsiderable cost compared to actual data.\n\nSo we proposed a new string encoding algorithm which we called meta string\nencoding in Fury. It will encode most chars using 5 bits instead of 8 bits in\nutf-8 encoding, which can bring 37.5% space cost savings compared to utf-8\nencoding.\n\n## Meta String Introduction\n\nMeta string encoding algorithm is mainly used to encode meta strings such as\nfield names, namespace, packageName, className, path and filename. Such a\nstring is enumerated and limited, so the encoding performance is not important\nsince we can cache the encoding result.\n\nMeta string encoding uses 5/6 bits instead of 8 bits in utf-8 encoding for\nevery chars. Since it uses less bits than utf8, it can bring 37.5% space cost\nsavings compared to utf-8 and has a smaller encoded binary size, which uses\nless storage and makes the network transfer faster.\n\nMore details about meta string spec can be found in Fury xlang serialization\nspecification.\n\n## Encoding Algorithms\n\nString binary encoding algorithm:\n\nAlgorithm| Pattern| Description  \n---|---|---  \nLOWER_SPECIAL| a-z._$|| every char is written using 5 bits, a-z:\n0b00000~0b11001, ._$|: 0b11010~0b11101, prepend one bit at the start to\nindicate whether strip last char since last byte may have 7 redundant bits(1\nindicates strip last char)  \nLOWER_UPPER_DIGIT_SPECIAL| a-zA-Z0~9._| every char is written using 6 bits,\na-z: 0b00000~0b11001, A-Z: 0b11010~0b110011, 0~9: 0b110100~0b111101, ._:\n0b111110~0b111111, prepend one bit at the start to indicate whether strip last\nchar since last byte may have 7 redundant bits(1 indicates strip last char)  \nUTF-8| any chars| UTF-8 encoding  \n  \nIf we use LOWER_SPECIAL/LOWER_UPPER_DIGIT_SPECIAL, we must add a strip last\nchar flag in encoded data. This is because every char will be encoded using\n5/6 bits, and the last char may have 1~7 bits which are unused by encoding,\nsuch bits may cause an extra char to be read, which we must strip off.\n\nHere is encoding code snippet in java, see\norg.apache.fury.meta.MetaStringEncoder#encodeGeneric(char[], int) for more\ndetails:\n\n    \n    \n    private byte[] encodeGeneric(char[] chars, int bitsPerChar) { int totalBits = chars.length * bitsPerChar + 1; int byteLength = (totalBits + 7) / 8; // Calculate number of needed bytes byte[] bytes = new byte[byteLength]; int currentBit = 1; for (char c : chars) { int value = (bitsPerChar == 5) ? charToValueLowerSpecial(c) : charToValueLowerUpperDigitSpecial(c); // Encode the value in bitsPerChar bits for (int i = bitsPerChar - 1; i >= 0; i--) { if ((value & (1 << i)) != 0) { // Set the bit in the byte array int bytePos = currentBit / 8; int bitPos = currentBit % 8; bytes[bytePos] |= (byte) (1 << (7 - bitPos)); } currentBit++; } } boolean stripLastChar = bytes.length * 8 >= totalBits + bitsPerChar; if (stripLastChar) { bytes[0] = (byte) (bytes[0] | 0x80); } return bytes; }\n    \n    private int charToValueLowerSpecial(char c) { if (c >= 'a' && c <= 'z') { return c - 'a'; } else if (c == '.') { return 26; } else if (c == '_') { return 27; } else if (c == '$') { return 28; } else if (c == '|') { return 29; } else { throw new IllegalArgumentException(\"Unsupported character for LOWER_SPECIAL encoding: \" + c); } }\n    \n    private int charToValueLowerUpperDigitSpecial(char c) { if (c >= 'a' && c <= 'z') { return c - 'a'; } else if (c >= 'A' && c <= 'Z') { return 26 + (c - 'A'); } else if (c >= '0' && c <= '9') { return 52 + (c - '0'); } else if (c == specialChar1) { return 62; } else if (c == specialChar2) { return 63; } else { throw new IllegalArgumentException( \"Unsupported character for LOWER_UPPER_DIGIT_SPECIAL encoding: \" + c); } }\n\nHere is decoding code snippet in golang, see\ngo/fury/meta/meta_string_decoder.go:70 for more details:\n\n    \n    \n    func (d *Decoder) decodeGeneric(data []byte, algorithm Encoding) ([]byte, error) { bitsPerChar := 5 if algorithm == LOWER_UPPER_DIGIT_SPECIAL { bitsPerChar = 6 } // Retrieve 5 bits every iteration from data, convert them to characters, and save them to chars // \"abc\" encodedBytes as [00000] [000,01] [00010] [0, corresponding to three bytes, which are 0, 68, 0 // Take the highest digit first, then the lower, in order\n    \n    // here access data[0] before entering the loop, so we had to deal with empty data in Decode method // totChars * bitsPerChar <= totBits < (totChars + 1) * bitsPerChar stripLastChar := (data[0] & 0x80) >> 7 totBits := len(data)*8 - 1 - int(stripLastChar)*bitsPerChar totChars := totBits / bitsPerChar chars := make([]byte, totChars) bitPos, bitCount := 6, 1 // first highest bit indicates whether strip last char for i := 0; i < totChars; i++ { var val byte = 0 for i := 0; i < bitsPerChar; i++ { if data[bitCount/8]&(1<<bitPos) > 0 { val |= 1 << (bitsPerChar - i - 1) } bitPos = (bitPos - 1 + 8) % 8 bitCount++ } ch, err := d.decodeChar(val, algorithm) if err != nil { return nil, err } chars[i] = ch } return chars, nil }\n\n## Select Best Encoding\n\nFor most lowercase characters, meta string will use 5 bits to encode every\nchar. For string containing uppercase chars, meta string will try to convert\nthe string into a lower case representation by inserting some markers, and\ncompare used bytes with 6 bits encoding, then select the encoding which has\nsmaller encoded size.\n\nHere is the common encoding selection strategy:\n\nEncoding Flag| Pattern| Encoding Algorithm  \n---|---|---  \nLOWER_SPECIAL| every char is in a-z._|| LOWER_SPECIAL  \nFIRST_TO_LOWER_SPECIAL| every char is in a-z._ except first char is upper\ncase| replace first upper case char to lower case, then use LOWER_SPECIAL  \nALL_TO_LOWER_SPECIAL| every char is in a-zA-Z._| replace every upper case char by | + lower case, then use LOWER_SPECIAL, use this encoding if it's smaller than Encoding LOWER_UPPER_DIGIT_SPECIAL  \nLOWER_UPPER_DIGIT_SPECIAL| every char is in a-zA-Z._| use\nLOWER_UPPER_DIGIT_SPECIAL encoding if it's smaller than Encoding\nFIRST_TO_LOWER_SPECIAL  \nUTF8| any utf-8 char| use UTF-8 encoding  \nCompression| any utf-8 char| lossless compression  \n  \nFor package name, module name or namespace, LOWER_SPECIAL will be used mostly.\nALL_TO_LOWER_SPECIAL can be used too, since it can represent the same chars as\nLOWER_SPECIAL without using more bits, but also support string with uppercase\nchars.\n\nFor className, FIRST_TO_LOWER_SPECIAL will be used mostly. If there are\nmultiple uppercase chars, then ALL_TO_LOWER_SPECIAL will be used instead. If a\nstring contains digits, then LOWER_UPPER_DIGIT_SPECIAL will be used.\n\nFinally, utf8 will be the fallback encoding if the string contains some chars\nwhich is not in range a-z0-9A-Z.\n\n## Encoding Flags and Data jointly\n\n  * Depending on the case, one can choose encoding flags + data jointly, using 3 bits of first byte for flags and other bytes for data. This can be useful since there are some holes remaining in last byte, adding flags in data doesn't always increase serialized bytes size.\n  * Or one can use a header to encode such flags with other meta such as encoded size, this is what Fury does in https://github.com/apache/incubator-fury/pull/1556\n\n## Benchmark\n\nutf8 encoding uses 30 bytes for string org.apache.fury.benchmark.data, fury\nmeta string uses only 19 bytes. utf8 encoding uses 12 bytes for string\nMediaContent, but fury meta string uses only 9 bytes.\n\n    \n    \n    // utf8 use 30 bytes, we use only 19 bytes assertEquals(encoder.encode(\"org.apache.fury.benchmark.data\").getBytes().length, 19); // utf8 uses 12 bytes, we use only 9 bytes. assertEquals(encoder.encode(\"MediaContent\").getBytes().length, 9);\n\nTags:\n\n  * fury\n\n  * Background\n  * Meta String Introduction\n  * Encoding Algorithms\n  * Select Best Encoding\n  * Encoding Flags and Data jointly\n  * Benchmark\n\nCommunity\n\n  * Mailing list\n  * Slack\n  * Twitter\n\nDocs\n\n  * Install\n  * Usage\n  * Benchmark\n\nRepositories\n\n  * Fury\n  * Website\n\nApache Fury is an effort undergoing incubation at The Apache Software\nFoundation (ASF), sponsored by the Apache Incubator. Incubation is required of\nall newly accepted projects until a further review indicates that the\ninfrastructure, communications, and decision making process have stabilized in\na manner consistent with other successful ASF projects. While incubation\nstatus is not necessarily a reflection of the completeness or stability of the\ncode, it does indicate that the project has yet to be fully endorsed by the\nASF.\n\nCopyright \u00a9 2024 The Apache Software Foundation, Licensed under the Apache\nLicense, Version 2.0. Apache, the names of Apache projects, and the feather\nlogo are either registered trademarks or trademarks of the Apache Software\nFoundation in the United States and/or other countries.\n\n", "frontpage": true}
