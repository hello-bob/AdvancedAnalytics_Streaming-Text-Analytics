{"aid": "40188183", "title": "Book Review: Template Metaprogramming with C++", "url": "https://lemire.me/blog/2022/10/26/book-review-template-metaprogramming-with-c/", "domain": "lemire.me", "votes": 1, "user": "ibobev", "posted_at": "2024-04-28 12:43:29", "comments": 0, "source_title": "Book Review : Template Metaprogramming with C++", "source_text": "Book Review : Template Metaprogramming with C++ \u2013 Daniel Lemire's blog\n\nSkip to content\n\nDaniel Lemire's blog\n\nDaniel Lemire is a computer science professor at the Data Science Laboratory\nof the Universit\u00e9 du Qu\u00e9bec (T\u00c9LUQ) in Montreal. His research is focused on\nsoftware performance.\n\n## Support my work!\n\nI do not accept any advertisement. However, you can you can sponsor my open-\nsource work on GitHub.\n\nJoin over 12,500 email subscribers:\n\nYou can follow this blog on telegram. You can find me on twitter as @lemire or\non Mastodon.\n\n## Recent Posts\n\n## Recent Comments\n\n## Pages\n\n## Archives\n\n## Boring stuff\n\n# Book Review : Template Metaprogramming with C++\n\nI have spent the last few years programming often in C++. The C++ langage is\nprobably one of the hardest to master. I still learn something new every week.\nFurthermore, C++ is getting upgrades all the time: C++17 was a great step\nforward and C++20 brings even more exiting improvments.\n\nIn C++, we often use \u2018templates\u2019. As the name suggests, they allow us to\ncreate C++ functions and classes from a generic recipe. For example, the\nfollowing template allows us to create functions that sum up two values:\n\n    \n    \n    template <class T> T f(T x, T y) { return x + y; }\n\nIt gets automatically instantiated when you need it. The following function\nwill return the sum of two integers.\n\n    \n    \n    int g(int x, int y) { return f(x,y); }\n\nTemplates are very powerful. They allow us to create highly efficient code,\nbecause everything happens at compile time: the optimizer can do it is work.\nWith great power, comes great responsibility: templates can be infuriating\nsince they may lead to unreadable error messages, and they can greatly\nincrease the compile time. I use templates sparingly when programming in C++.\n\nI spent the last few weeks reading Template Metaprogramming with C++ by Marius\nB\u0103ncil\u0103. It is currently 50$ on Amazon.\n\nThough, technically, the book is about advanced \u2018template\u2019 techniques, it is\nmuch more broad and practical. It is one of the \u2018good programming books\u2019. If\nyou are an experienced C++ programmer, you should give it a peek. It is full\nof practical code.\n\nThe book reminded me of the following features.\n\nExplicit instantiation declaration: In my example above, the template f with\ntype int gets compiled as soon as I invoke it. In that particular case, it is\nnot worrisome. However, it can be helpful to pre-compile the functions to\nreduce compile time in large projects, involving large pieces of code. We\ntypically achieve the desire results in C and C++ by separating function\ndeclaration (put in a header file) and function definition (put in a source\nfile). It is somewhat trickier to do with templates. Yet we can do so by\nputting the following line in the header:\n\n    \n    \n    extern template int f(int,int);\n\nFollowed by the following in a source file:\n\n    \n    \n    template int f(int,int);\n\nAnd voil\u00e0!\n\nLambda templates. It is cumbersome in C and C++ to define a function. In C++,\nyou can create \u2018lambdas\u2019 which are effectively locally defined functions. For\nexample, the following code first defines an \u2018addition\u2019 function (called\nlambda) and then it applies it to add two numbers:\n\n    \n    \n    int g(int x, int y) { auto lambda = [](int x, int y) -> int { return x + y; }; return lambda(x, y); }\n\nUp until recently, you could not mix templates and lambdas, but now you can\nwith C++20:\n\n    \n    \n    int g(int x, int y) { auto lambda = []<class T>(T x, T y) -> T { return x + y; }; return lambda(x, y); }\n\nVariable templates. Sometimes you need constants that depend on a type. For\nexample, the number pi might different depending on the precision of the type\nyou are using. That is where variable templates shine:\n\n    \n    \n    template <typename T> constexpr T PI = T(3.1415926535897932384626433832795028841971693993751); std::cout << PI<double> << std::endl; std::cout << PI<float> << std::endl;\n\nThere is plenty more to explore in B\u0103ncil\u0103\u2019s book.\n\nI posted some code examples on GitHub.\n\nDisclosure: I got a free copy of the book from the editor in exchange for a\npromise that I would do a review if I liked the book. I did not agree\nbeforehand to produce a positive review. I do not get paid if you buy the\nbook.\n\nDaniel Lemire, \"Book Review : Template Metaprogramming with C++,\" in Daniel\nLemire's blog, October 26, 2022.\n\n## Published by\n\n### Daniel Lemire\n\nA computer science professor at the University of Quebec (TELUQ). View all\nposts by Daniel Lemire\n\nPosted on October 26, 2022May 19, 2023Author Daniel LemireCategories\n\n## 3 thoughts on \u201cBook Review : Template Metaprogramming with C++\u201d\n\n  1. Denis says:\n\nOctober 26, 2022 at 8:05 pm\n\n\u201cUp until recently, you could not mix templates and lambdas, but now you can\nwith C++20:\u201d\n\nYou could since C++14.\n\nint g(int x, int y) { auto lambda = [](auto x, auto y) { return x + y; };\nreturn lambda(x, y); }\n\nIt\u2019s the same as https://godbolt.org/z/f59cezsje\n\nReply\n\n    1. Jonathan O'Connor says:\n\nNovember 3, 2022 at 9:41 am\n\nI think the change in C++20 was to make it easier to get the type of x and y.\nBefore C++20, you\u2019d need the following code:\n\nint g(int x, int y) { auto lambda = [](auto x, auto y) { using T =\ndecltype(x); return T(x + y); }; return lambda(x, y); }\n\nC++20 allows the following:\n\nint g(int x, int y) { auto lambda = [](T x, T y) { return T(x + y); }; return\nlambda(x, y); }\n\nThis last example also ensures that x and y have the same type, which the\nC++14 example does not.\n\nReply\n\n  2. Denis says:\n\nOctober 26, 2022 at 8:06 pm\n\n\u201cUp until recently, you could not mix templates and lambdas, but now you can\nwith C++20:\u201d\n\nYou could since C++14.\n\nint g(int x, int y) { auto lambda = [](auto x, auto y) { return x + y; };\nreturn lambda(x, y); }\n\nIt\u2019s the same as\n\n[](T1 x, T2 y) { return x + y; };\n\nhowever, hence the C++20 syntax. https://godbolt.org/z/f59cezsje\n\nReply\n\n### Leave a Reply Cancel reply\n\nYou may subscribe to this blog by email.\n\nTerms of use Proudly powered by WordPress\n\n", "frontpage": false}
