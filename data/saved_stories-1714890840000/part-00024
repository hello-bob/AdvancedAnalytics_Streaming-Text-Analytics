{"aid": "40260771", "title": "Show HN: CLI tool for using Timeular tracker with other time-tracking software", "url": "https://github.com/krzysztof-ciszewski/timeular-reader", "domain": "github.com/krzysztof-ciszewski", "votes": 1, "user": "TwoInvisibleMan", "posted_at": "2024-05-04 22:21:45", "comments": 0, "source_title": "GitHub - krzysztof-ciszewski/timeular-reader", "source_text": "GitHub - krzysztof-ciszewski/timeular-reader\n\nSkip to content\n\n## Navigation Menu\n\nSign in\n\n# Search code, repositories, users, issues, pull requests...\n\nSearch syntax tips\n\nSign in\n\nSign up\n\nYou signed in with another tab or window. Reload to refresh your session. You\nsigned out in another tab or window. Reload to refresh your session. You\nswitched accounts on another tab or window. Reload to refresh your session.\nDismiss alert\n\nkrzysztof-ciszewski / timeular-reader Public\n\n  * Notifications\n  * Fork 0\n  * Star 1\n\n### License\n\nMIT license\n\n1 star 0 forks Branches Tags Activity\n\nStar\n\nNotifications\n\n# krzysztof-ciszewski/timeular-reader\n\nThis commit does not belong to any branch on this repository, and may belong\nto a fork outside of the repository.\n\n1 Branch\n\n1 Tags\n\n## Folders and files\n\nName| Name| Last commit message| Last commit date  \n---|---|---|---  \n  \n## Latest commit\n\nkrzysztof-ciszewskirelease build optimizationsMay 4, 2024c623ba4 \u00b7 May 4,\n2024May 4, 2024\n\n## History\n\n16 Commits  \n  \n### src\n\n|\n\n### src\n\n| fixed config path| May 4, 2024  \n  \n### .gitignore\n\n|\n\n### .gitignore\n\n| added config as file| Jun 18, 2022  \n  \n### Cargo.lock\n\n|\n\n### Cargo.lock\n\n| allow to choose handler, improved setup| May 3, 2024  \n  \n### Cargo.toml\n\n|\n\n### Cargo.toml\n\n| release build optimizations| May 4, 2024  \n  \n### LICENSE\n\n|\n\n### LICENSE\n\n| Initial commit| Jun 11, 2022  \n  \n### README.md\n\n|\n\n### README.md\n\n| added example mod and readme| May 4, 2024  \n  \n## Repository files navigation\n\n# Timeular Reader\n\nHave you bought the expensive Timeular tracker and don't want to pay on top of\nthat for their propriatery app? This project is for you. With Timeular Reader\nyou can connnect your tracker to your favourite time tracking app.\n\n## Usage\n\nFirst run the command with --setup flag, this will generate config and let you\nlabel the sides of your device.\n\n    \n    \n    timeular-reader --setup\n\nYou don't have to set up all the sides, press q on a side you don't want to\nuse and config will generate with the ones you set up.\n\nAfter the initial setup you can modify config.toml\n\nTo control output verbosity you can pass --verbose or -v, you can add multiple\n-vvv to make it more verbose.\n\nThere is also --quiet, -q mode to mute all output.\n\n### Toggl\n\nTo get your project id and workspace id, on the left panel under Manage, click\nProjects. Then click on the project name you want to use. The url should look\nlike this https://track.toggl.com/{workspace_id}/projects/{project_id}/team\n\n### Clockify\n\nTo generate your api key go to your profile settings on the top right. After\nscrolling down you'll see an option to generate API Key.\n\nTo get your workspace id, in the top right, click Your Workspace, go to Manage\nthen settings, you should have workspace id in the url. It should look\nsomething like this https://app.clockify.me/workspaces/{workspace_id}/settings\n\n> Note project id is optional\n\nTo get your project id on the left side, click projects, then click on your\nprojects. The url will contain project id. Should look something like this\nhttps://app.clockify.me/projects/{project_id}/edit\n\n### Hackaru\n\nTODO\n\n### Traggo\n\nTODO\n\n## Creating your own handler\n\nFirst you need to create a new mod and register it here let's call it example.\n\nYou create the mod by creating a file src/handler/example.rs and adding pub\nmod example; into the file linked above. The example.rs has to have a public\nfunction called async create_handler(setup: bool), and that function has to\nreturn a struct that implements Handler The implementation needs annotation\n#[async_trait]\n\nIt is most likely your mod will require some configuration. You can implement\neverything in the main example.rs file, but to keep it clean I recommend\ndeclaring new mod config. The config mod will be responsible for creating a\ndefault config and saving it to the main config file config.toml.\n\nFirst we need to add pub mod config; to example.rs and create file\nsrc/handler/example/config.rs. In config.rs we need to create a struct that\nwill hold all the configuration data we will need, let's call it\nExampleConfig.\n\n> The derives are necessary\n    \n    \n    #[derive(Serialize, Deserialize, Clone, Debug)] pub struct ExampleConfig { base_url: String, api_key: String, }\n\nWe need to then implement Default and crate::config::Config. The Default\nimplementation can create the struct with the stuff that doesn't change much,\nlike an API base url. For example:\n\n    \n    \n    impl Default for ExampleConfig { fn default() -> Self { ExampleConfig { base_url: String::from(\"https://api.example.com\"), api_key: String::new(), } } }\n\nThe crate::config::Config implementation can be empty, it's just about\ninheriting the type and a lifetime, it can look like this:\n\n    \n    \n    impl<'de> Config<'de> for ExampleConfig {}\n\nIf you want to save your config the main config file, you need to have a\nunique key that it will be saved under.\n\nFor convenience, you can implement methods for getting and updating the\nconfig(from/to a file). Otherwise, you will have to call\ncrate::config::get_config, and crate::config::update_config. These functions\ncan look like this:\n\n    \n    \n    const CONFIG_KEY: &str = \"example\"; pub fn create_config() -> ExampleConfig { crate::config::get_config::<ExampleConfig>(CONFIG_KEY) } pub fn update_config(config: &ExampleConfig) { crate::config::update_config(CONFIG_KEY, config); }\n\nAfter that we need to register the new handler. In src/handler.rs you need to\nadd our mod Example to the Handlers enum and assign it number.\n\n    \n    \n    pub enum Handlers { Toggl = 1, Clockify = 2, Traggo = 3, Hackaru = 4, + Example = 5, }\n\nThen in CreateHandler, the example key has to accept the implementation of the\nHandler:\n\n    \n    \n    pub enum CreateHandler { #[default] None, Toggl(Toggl), Clockify(Clockify), Traggo(Traggo), Hackaru(Hackaru), + Example(crate::handler::example::Example) }\n\nthen we need to adjust TryFrom<u8>:\n\n    \n    \n    fn try_from(v: u8) -> Result<Self, Self::Error> { match v { x if x == Handlers::Toggl as u8 => Ok(Handlers::Toggl), x if x == Handlers::Clockify as u8 => Ok(Handlers::Clockify), x if x == Handlers::Traggo as u8 => Ok(Handlers::Traggo), x if x == Handlers::Hackaru as u8 => Ok(Handlers::Hackaru), + x if x == Handlers::Example as u8 => Ok(Handlers::Example), _ => Err(()), } }\n\nsame in TryFrom<&String>:\n\n    \n    \n    fn try_from(v: &String) -> Result<Self, Self::Error> { match v { x if x.to_lowercase() == format!(\"{:?}\", Handlers::Toggl).to_lowercase() => { Ok(Handlers::Toggl) } x if x.to_lowercase() == format!(\"{:?}\", Handlers::Clockify).to_lowercase() => { Ok(Handlers::Clockify) } x if x.to_lowercase() == format!(\"{:?}\", Handlers::Traggo).to_lowercase() => { Ok(Handlers::Traggo) } x if x.to_lowercase() == format!(\"{:?}\", Handlers::Hackaru).to_lowercase() => { Ok(Handlers::Hackaru) } + x if x.to_lowercase() == format!(\"{:?}\", Handlers::Example).to_lowercase() => { + Ok(Handlers::Example) + } _ => Err(()), } }\n\nthen in get_create_handler:\n\n    \n    \n    return match handler { Handlers::Toggl => CreateHandler::Toggl(toggl::create_handler(setup).await), Handlers::Clockify => CreateHandler::Clockify(clockify::create_handler(setup).await), Handlers::Traggo => CreateHandler::Traggo(traggo::create_handler(setup).await), Handlers::Hackaru => CreateHandler::Hackaru(hackaru::create_handler(setup).await), + Handlers::Example => CreateHandler::Example(example::create_handler(setup).await), };\n\nand lastly handle:\n\n    \n    \n    match create_handler { CreateHandler::Toggl(h) => { h.handle(side, duration).await; } CreateHandler::Clockify(h) => { h.handle(side, duration).await; } CreateHandler::Traggo(h) => { h.handle(side, duration).await; } CreateHandler::Hackaru(h) => { h.handle(side, duration).await; } + CreateHandler::Example(h) => { + h.handle(side, duration).await; + } CreateHandler::None => { panic!(\"CreateHandler should never be none\") } }\n\nI have added the example tracker to the repository, you can base your module\non that.\n\n## Build\n\nSimply run\n\n    \n    \n    cargo build\n\n## About\n\nNo description or website provided.\n\n### Topics\n\ntime-tracker timetracker time-tracking timetracking timeular\n\n### Resources\n\nReadme\n\n### License\n\nMIT license\n\nActivity\n\n### Stars\n\n1 star\n\n### Watchers\n\n1 watching\n\n### Forks\n\n0 forks\n\nReport repository\n\n## Releases\n\n1 tags\n\n## Packages 0\n\nNo packages published\n\n## Languages\n\n  * Rust 100.0%\n\n## Footer\n\n\u00a9 2024 GitHub, Inc.\n\nYou can\u2019t perform that action at this time.\n\n", "frontpage": false}
