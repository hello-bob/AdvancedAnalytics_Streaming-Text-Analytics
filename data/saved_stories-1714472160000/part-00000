{"aid": "40207179", "title": "Ruby's Complex Branching Options", "url": "https://naildrivin5.com/blog/2024/04/29/ruby-s-complex-branching-options.html", "domain": "naildrivin5.com", "votes": 2, "user": "ilikepi", "posted_at": "2024-04-30 04:13:46", "comments": 0, "source_title": "Ruby's Complex Branching Options", "source_text": "Ruby's Complex Branching Options\n\nBlack Lives Matter. See post\n\n# naildrivin5.com\n\n## Website of David Bryant Copeland\n\n# Ruby's Complex Branching Options\n\n## April 29, 2024 \ud83d\udcec Get My Weekly Newsletter \u261e\n\nWorking on some personal projects where I\u2019m not constrained by older versions\nof Ruby or on Rails, I\u2019ve been trying to learn and use features of Ruby\nintroduced in the last few years. One feature is pattern-matching, and it\u2019s\ncaused me to ask the question: what is the best way to create a branching\ncontrol structure in Ruby?\n\nBefore going into this, I was solidly team if statements, but now I\u2019m not so\nsure.\n\nLet\u2019s say we are writing code to validate HTML forms, server-side. The basic\ninteraction we want, in Sinatra-esque pseudo-code is:\n\n    \n    \n    post \"/widgets\" do result = NewWidget.call(params) if results failed data validation render \"widgets/new\", widget: params, errors: results' validation errors else redirect_to \"/widgets\", message: \"Your widget was created\" end end\n\nTo say in words, we want to try to create a widget based on the form\nsubmission. If the submitted data has validation errors, we want to show those\nto the user and let them try again. If the submitted data was valid, we want\nthe widget to be created. This is a basic structure we see in Rails apps all\nthe time.\n\nThere are three ways to implement this that could be considered idiomatic\nRuby, or at least could be done without introducing an internal DSL^1:\n\n  * Using if statements based on a protocol the returned result object conforms to, e.g. if result.valid?.\n  * Using pattern-matching based on type, e.g. if we get some sort of InvalidResult object, we consider that a validation errors.\n  * Using deconstruction-based pattern matching on the structure of the object, e.g. if it \u201cmatches\u201d { errors: ... } we consider that a validation error.\n\nNone of these are perfect, and each has problems, so let\u2019s see what they are.\n\n## Good \u2018Ole if. Nothin\u2019 Beats if\n\nThis is the most basic way to do this and will result in code that pretty much\nanyone can understand, especially if they have experience with Rails. Our code\nwould look like so:\n\n    \n    \n    post \"/widgets\" do result = NewWidget.call(params) if result.invalid? render \"widgets/new\", widget: params, errors: result.errors else redirect_to \"/widgets\", message: \"Your widget was created\" end end\n\nThis assumes that NewWidget.call(...) returns an object that must respond to\n.invalid? and if .invalid? returns true, that same object must respond to\n.errors, which we can assume is some sort of array or hash-like structure of\nerrors that allows the view to show the user what went wrong.\n\nThis has a lot going for it:\n\n  * Pretty much anyone with any programming experience can understand this code.\n  * The code is coupled to a protocol and not a particular type. As long as whatever comes back from call responds to invalid? and, potentially, .errors, this code will be fine.\n  * The implementation of the protocol is also going to be pretty simple.\n\nThere are some downsides, however:\n\n  * Our business logic\u2014NewWidget.call\u2014is required to return an object related to form validations. That\u2019s a somewhat odd abstraction, and perhaps isn\u2019t that convienient. What if we wanted the created widget to be returned if everything worked? result would have to have some additional method to access that, and it could be vague like .record, or specific like .widget, but it seems awkward.\n  * If we needed to do further branching based on the type of errors that were returned, that could lead to a complicated, nested set of if statements, or a complicated set of query methods, e.g. .error?(:name).\n\nThese trade-offs are usually fine\u2014most conventional programming languages have\nthe ability to write if statements and we manage the downsides as best we can.\n\n## Pattern-matching Based on Type\n\nBefore Ruby allowed structural-based pattern-matching, you could use a case\nstatement and rely on the implementation of ===. In this instance, we could\nrely on Class.=== responding true if the object passed is an instance of that\nclass. That turns our code into the following:\n\n    \n    \n    post \"/widgets\" do result = NewWidget.call(params) case result when ValidationResult::Invalid render \"widgets/new\", widget: params, errors: result.errors else redirect_to \"/widgets\", message: \"Your widget was created\" end end\n\nThis means that our back-end code would look like so:\n\n    \n    \n    class ValidationResult::Invalid attr_reader :errors def initialize(errors) @errors = errors end end class NewWidget def self.call(params) errors = self.validate(params) if errors.any? return ValidationResult::Invalid.new(errors) end # create the widget widget end end\n\nWithout this pattern-matching, our NewWidget class is akward: it returns a\nwidget if things worked and a totally different class if not. But with the\npattern-matching, it doesn\u2019t seem so bad.\n\nPros:\n\n  * The only return type that matters is when there were validation errors. If there were not validation errors, we can return other classes. This means that we can expand the possible results however we need without having to require that all return values conform to the same interface.\n  * Because we are branching on type, we have a stronger guarantee that any methods we call are supported. Given that Ruby has no concept of an interface that a compiler ensures is implemented, showing the types directly should reduce mistakes.\n\nCons:\n\n  * While the \u201cany return type\u201d feature is flexible, it can also be confusing. If the number of possible return types increases, the code might be hard to follow, predict or manage. Requiring an interface be used would constrain this problem.\n  * The code is coupled to a specific class. This means that the business logic must always use this exact class (or a subclass) to communicate validation errors. This tight-coupling could make refactoring difficult.\n  * This is fairly verbose. If you imagine that Invalid is part of some library you are using for validations, its class name might be even longer than the one I\u2019ve used here. Typing that out all the time and having to read it could be tedious.\n\nWe can somewhat split the difference with deconstructing.\n\n## Pattern-Matching on Shape with Deconstruction\n\nRecent versions of Ruby enhanced pattern matching beyond the use of ===. You\ncan deconstruct a hash or array by default, but you can also allow any object\nto be deconstructed by implementing deconstruct or deconstruct_keys. This\nwould allow our code to look like so:\n\n    \n    \n    post \"/widgets\" do result = NewWidget.call(params) case result in errors: render \"widgets/new\", widget: params, errors: errors else redirect_to \"/widgets\", message: \"Your widget was created\" end end\n\nTo make this work, the return type of NewWidget.call would need to use an\nobject that could be deconstructed into a hash that has an errors: key.\n\n    \n    \n    class ValidationResult::Invalid def initialize(errors) @errors = errors end \u2192 def deconstruct_keys(keys) \u2192 { errors: @errors } \u2192 end end class NewWidget def self.call(params) # as before ... end end\n\nThe case statement\u2019s in section will effectively call deconstruct_keys on\nresult, then see if it matches errors:. If it does, it assigns the value of\nthat key in the Hash to a local variable of the same name.\n\nThis has some advantages over the other approaches:\n\nPromotion\n\n# Fix Your Crappy Dev Environment\n\n## Docker and Bash Have you Covered\n\n### Buy Now $19.95\n\n  * Not coupled to a specific class or implementation.\n  * No requirement that the return type conform to any particular interface.\n  * If the return type could be one of many different classes or with many different shapes and the code was called in a lot of different contexts, being able to \u201cpick and choose\u201d what you wanted out of the return object based on use case could be valuable and reduce coupling. For a service wrapper of a complex HTTP API, this could be a really nice interface.\n\nThat said, there are some downsides:\n\n  * Because of the structural matching, an object that can be deconstructed into a { errors: ... } Hash will match, even if that isn\u2019t intended by the caller. This could be addressed by being more specific, e.g. validation_errors: but the looser coupling could result in unexpected matches, especially if highly dynamic data might be returned.\n  * It\u2019s conceptually dense, requiring knowledge of a lot of implicit behavior to understand.\n  * You lose almost all definition of the contract between the caller and the result of NewWidget.call. Granted, deconstruct_keys is a stronger construct than using Hashes everywhere, but it\u2019s still basically using Hashes everywhere, which means your code works based on correctly typing out a lot of strings.\n\n### You Can Do Both\n\nIt\u2019s possible to match on both class and structure, like so:\n\n    \n    \n    case result \u2192 in ValidationResult::Invalid(errors:) render \"widgets/new\", widget: params, errors: errors else redirect_to \"/widgets\", message: \"Your widget was created\" end\n\nThis would eliminate the possibility of matching any old Hash with an errors:\nkey, but of course create coupling to a specific class and to the return value\nof a method of that class, which I would find somewhat confusing.\n\n## Summary\n\nI\u2019m hard-pressed to choose the best construct here. Using if statements is a\nvery safe choice because it\u2019s the simpleset and most widely understood. Still,\nthe pattern-matching deconstruction syntax does provide extremely loose\ncoupling which can be an advantage.\n\nFor me, I want to be able to understand how a piece of code works as quickly\nas possible, with as little context as possible. Time saved writing the code\nor on compactness isn\u2019t that valuable to me. Generally, more abstractions\nmeans code is harder to understand, however which of these approaches has more\nabstractions?\n\nThe if-based approach largely requires some sort of return type abstraction\nthat can handle any outcome of the method call. The pattern-matching\napproaches do not require these, even though they themselves are additional\nabstractions. Of course, they are abstractions provided by the programming\nlanguage and thus easier to learn and more translatable to other projects.\n\nFor science, I\u2019m going to try the deconstruction-based approach and see what\nit\u2019s like in earnest.\n\n  1. ^1At this point in the history of Ruby and programming in general, I think any introduction of an internal domain specific language (DSL) is a serious code smell and should generally be avoided at all costs. Rails is the only example I can think of of a really well done internal DSL and I think it still has many flaws and can be very confusing due to this design decision. Creating a solid API, using the basic features of your programming language where one can easily trace callsites is always going to be a better solution. \u21a9\n\n# Latest Posts\n\n  * \ud83d\udcec My Weekly Newsletter \u261e Short-form, Quick Reads on Tech\n  * Sustainable Dev Environments with Docker and Bash Available Now April 01, 2024\n  * Methods Don't Succeed our Fail: they Have Outcomes March 01, 2024\n\nCopyright \u00a9 2006-2024, by David Bryant Copeland, All Rights Reserved. Unless\notherwise stated, all content on this page was created without any assistance\nfrom a Generative AI.\n\nTypos or other issues? Feel free to reach out on Mastodon, or email me (yes, I\nread and respond to all my email). To discuss the content, consider doing so\non Hacker News, Reddit, Mastodon, or lobste.rs\n\n", "frontpage": false}
