{"aid": "40204524", "title": "A Not-So-Random Challenge: Deciphering Jonathan.e's Bytes", "url": "https://widening.re/research/challenge-sent-by-jonathan/", "domain": "widening.re", "votes": 2, "user": "widening", "posted_at": "2024-04-29 21:48:41", "comments": 0, "source_title": "A Not-So-Random Challenge: Deciphering Jonathan.e's Bytes", "source_text": "A Not-So-Random Challenge: Deciphering Jonathan.e's Bytes\n\n# A Not-So-Random Challenge: Deciphering Jonathan.e's Bytes\n\nPublished at 2024-04-29\n\nWe here at \u2207 Widening love a good challenge. We spend our days untangling the\ncomplexities of cyber threats, so a little reverse engineering puzzle every\nnow and then is a welcome test of our skills. That\u2019s why we threw out an open\ninvitation to the cyber-security community: send us your toughest reverse\nengineering challenge.\n\nColor us intrigued when a user named jonathan.e submitted his entry exactly 24\nhours later the release of our website, even if we did not promote it. The\nfile arrived with a cryptic message: \u201cMay the odds be ever in your favor.\u201d\nAttached was...well, it certainly looked like a file. A .exe file, to be\nprecise with the name message.exe (SHA256:\nff0f4157e58285c3aaf37529a422d3c35d80ec7087090327b51ef146110d80ec).\n\nOur team eagerly fired up their analysis tools including PE-Info just to take\na look quickly, and then we moved to IDA Pro. The header and a couple of\ninformations (such as some specific sections such as text) all indicated a\nWindows PE (Portable Executable) file, the kind you\u2019d normally expect to be a\nprogram. But when we dove deeper, things went sideways. The internal structure\nwas scrambled, the code nonsensical. \u201cIt was like staring into a bowl of\ndigital alphabet soup\u201d one could comment.\n\nFor starters, let\u2019s dissect this \u201cprogram\u201d a bit further. A typical PE file,\nlike the one jonathan.e sent, is like a well-organized toolbox. It\u2019s divided\ninto sections, each with a specific purpose. There\u2019s the MS-DOS stub, a legacy\nholdover that helps the program launch even on older systems. Then there\u2019s the\nsection for code (text), where the actual instructions for the program reside.\nWe also have sections for data (initialized variables), resources (icons,\ndialog boxes), and more.\n\nThe problem with jonathan.e\u2019s file is that everything\u2019s a mess. The code\nsection is gibberish, the data section nonsensical. It\u2019s like someone took the\ntoolbox and jumbled all the tools together. But here\u2019s the thing that keeps us\nintrigued: the PE header itself seems legitimate. There are no weird fields\nthat contain and the various programs that do parse the Windows PE file format\ndo not show any symptoms of something illegal.\n\nThe header contains information like the program\u2019s entry point, the address\nwhere execution should begin, the architecture supported. This dedicated\nsection, typically starting right after the MS-DOS Stub, holds the core\ninformation about the program, including its entry point, section table, and\nvarious flags. This tells us one thing. There might still be a program in\nthere somewhere, hidden beneath the layers of obfuscation. The sections are\napparently normal and all the sections .\n\nThis is where the real reverse engineering fun begins. We\u2019re employing various\ntechniques to try and untangle the mess. (Note: for people that work already\nin reverse engineering, you can skip this part because it is written for\nnewbie people.) Disassemblers are helping us convert the scrambled code back\ninto a (hopefully) readable format. Debuggers are standing by, ready to step\nthrough the program line by line, if we can even get it to run.\n\nThis isn\u2019t always a straightforward process, but it allows us to see the raw\ninstructions the program is trying to execute. However, assembly language is\nstill very low-level and difficult to understand. That\u2019s where decompilers\ncome in. These tools attempt to reverse engineer the assembly code back into a\nhigher-level programming language, like C or C++. While decompilation isn\u2019t\nperfect, it can provide valuable clues about the program\u2019s true functionality.\n\n## Decrypting the challenge\n\nBefore unleashing jonathan.e\u2019s creation, we need to get it inside the sandbox.\nThis transfer can\u2019t be a casual copy-and-paste job. We need to ensure the\nprocess is secure and doesn\u2019t introduce any vulnerabilities. Popular sandbox\nsolutions often come equipped with built-in file transfer functionalities.\n\nOnce the file resides within the sandbox, it\u2019s time for the main event. We\u2019ll\nutilize the sandbox\u2019s built-in process monitoring capabilities. Imagine a\ndigital magnifying glass, allowing us to observe the program\u2019s every action\nwithin the isolated environment. As jonathan.e\u2019s file launches and executes,\nwe\u2019ll be watching with hawk-like focus.\n\nThe true test lies in how the program interacts with the sandboxed system.\nHere\u2019s where we become digital detectives, looking for any signs of malicious\nintent. Is the program attempting to access sensitive areas of the sandbox,\nlike system folders or user files? Does it exhibit a sudden urge to establish\nnetwork connections, potentially trying to phone home to a malicious server?\nIs it meddling with system settings in an unauthorized way? Any of these\nactions would raise a red flag, prompting us to dig deeper into the program\u2019s\nfunctionality.\n\nEven if the program manages to evade detection during its execution, we have\nanother trick up our sleeve: memory forensics. This technique involves\ncreating a snapshot of the sandbox\u2019s memory after the program has run its\ncourse. Think of it as a digital crime scene investigation. We\u2019ll employ\nspecialized forensic tools to analyze this memory dump, searching for any\nremnants of the program\u2019s activity. These tools can potentially reveal traces\nthe program might have tried to hide, such as loaded libraries with suspicious\nfunctionalities, function calls made within the system, or even network\nconnections the program attempted to establish.\n\n## Real World Implications\n\nStatic analysis can identify suspicious code patterns, while dynamic analysis\nin a sandbox helps unveil a program\u2019s true nature. Memory forensics provides a\nfinal layer of investigation, even if the program attempts to vanish without a\ntrace.\n\nHowever, it\u2019s crucial to remember that this is just a simulation. Real-world\nattackers are constantly evolving their tactics, and there\u2019s no guaranteed\nfoolproof method. By staying vigilant and continuously improving our analysis\ntechniques, we can stay ahead of the curve and protect critical systems from\nthe shadows.\n\nOne thing\u2019s for sure: this isn\u2019t just about winning a challenge anymore. It\u2019s\nabout understanding the intent behind it. Is this a playful exercise, or a\npotential security threat disguised as a game? We\u2019ll keep you updated on our\nprogress :)\n\n## About \u2207 Widening\n\n\u2207 Widening is a boutique Italian cybersecurity firm with deep expertise in\nsoftware analysis. We work in the context of MATE attack and defence. We have\nplenty of experience in terms of building, and disrupting software protections\nto achieve client needs.\n\nWe use reverse engineering, software attacks, and static analysis to uncover\nthe inner workings of any software, from desktop applications to malicious\nsoftware.\n\nContact us for a quote Send us a challenge\n\nMade in Italy, near the Alps \u2013 2024 \u2013 VAT number available upon request \u2013\ncontact@widening.re\n\n", "frontpage": false}
