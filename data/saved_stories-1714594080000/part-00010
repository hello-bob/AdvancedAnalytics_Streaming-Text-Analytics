{"aid": "40221797", "title": "Azure AI 'Hybrid' search gotcha: returning unexpected/unmatching results", "url": "https://jakobs.dev/showcase-azure-ai-hybrid-search-unexpected-results-gotcha/", "domain": "jakobs.dev", "votes": 1, "user": "js98", "posted_at": "2024-05-01 11:18:22", "comments": 0, "source_title": "Showcase: Azure AI Hybrid Search unexpected results gotcha | Jakob Serlier's Personal Site", "source_text": "Showcase: Azure AI Hybrid Search unexpected results gotcha | Jakob Serlier's Personal Site\n\n## Showcase: Azure AI Hybrid Search unexpected results gotcha\n\n#### April 30, 2024 \u2022 Written by Jakob Serlier\n\n###### Tags: Azure AI Search, Embeddings, Search, tech\n\n\\---\n\n# Showcase: Azure AI Hybrid Search unexpected results gotcha\n\nThis document describes a gotcha in Azure AI Search hybrid queries where\nunexpected results are returned.\n\nThe context is of these findings are an ISE engagement with a customer\nindexing millions of documents in Azure AI Search. During this, I set out to\nanswer questions on filtering and matching syntax as well as pre/post-filter\nperformance for hybrid search. Views and opinions are my own.\n\n## Key takeaway\n\nTraditional full-text search return matches if and only if there is a match.\nVector search always returns k number of matches, which can be nonsensical\n(see here). Given the way hybrid search reranks the sum of results from full-\ntext and vector search, hybrid search can return results which would not be\nexpected given (regex) matching constraints in the search_text argument.\n\nIf you are simply filtering on a field, use filter (filter syntax refs). This\nis a 'hard' filter, meaning that results which do not match are not included\nin the end-results for (hybrid) search.\n\n## Brief reiteration on search methods\n\nAzure AI Search offers these three search methods:\n\n  1. Keyword search: fulltext and semantic\n\n    1. Fulltext: queryType sets the parser: simple, or full. The default simple query parser is optimal for full text search. Full enables Lucene query parser: for advanced query constructs like regular expressions, proximity search, fuzzy and wildcard search. Full-text query how-to - Azure AI Search | Microsoft Learn\n    2. Semantic: Semantic ranker is a collection of query-related capabilities that improve the quality of an initial BM25-ranked or RRF-ranked search result for text-based queries. When you enable it on your search service, semantic ranking extends the query execution pipeline in two ways:\n\n      1. Secondary ranking score & captions and answers in the response. Semantic ranking - Azure AI Search | Microsoft Learn\n  2. Vector search: docs - uses embeddings and distance in latent space to retrieve semantically relevant documents.\n  3. Hybrid search: combines both results, and reranks, e.g. using RRF (docs)\n\n## Technique - filtering and matching documents in Azure AI Search\n\nFor matching and filtering documents, these two approaches were most useful\nfor our use-cases:\n\n  1. Using OData language and filter argument: OData language overview - Azure AI Search | Microsoft Learn\n  2. Using the search_text argument and query_type=\"full\" so we are able to use the Lucene queryparser syntax: we can match results e.g., using regular expressions Lucene query syntax - Azure AI Search | Microsoft Learn.\n\n## Gotcha example - Where things turn sour\n\nImagine the following query. We are interesed in filtering on a specific id\n(the full set only contains one document with this ID), but we also match the\nid to contain 1234 using a regex lucene query. Obviously, this matches and we\nget a result:\n\n    \n    \n    limit = 10 select = 'id,content' search_text = \"id:/.*1234.*/\" search_client = sc result = await search_client.search( search_text=search_text, top=limit, select=select, query_type=\"full\", # Set query type to full to enable lucene/regex queries filter = \"id eq 'A001-AB-1234_chunk_0'\" ) async for doc in result: print(doc) # > # {'id': 'A001-AB-1234_chunk_0', 'content':.... #\n\nNow, we change the regex query to (not) match 4321 in the id, and we obviously\nget no result:\n\n    \n    \n    limit = 10 select = 'id,content' search_text = \"id:/.*4321.*/\" search_client = sc result = await search_client.search( search_text=search_text, top=limit, select=select, query_type=\"full\", # Set query type to full to enable lucene/regex queries filter = \"id eq 'A001-AB-1234_chunk_0'\" ) async for doc in result: print(doc) # > # NO RESULTS #\n\nWhat happens if we add hybrid search to the mix, but still include the\nunmatching 4321 in the id?\n\n    \n    \n    # Hybrid search with regex-like query, yielding unexpected (1234) result (hybrid). # (using helper function to set up the embedding, ...) async for doc in await vector_search_with_lucene( limit=10, query_to_embed=\"failing gear unit\", # some query which closely resembles the text in the content search_text = \"id:/.*4321.*/\", query_type= \"full\", select='id,content', search_client=sc, vector_filter_mode=\"preFilter\", filter = \"id eq 'A001-AB-1234_chunk_0'\" ): print(doc) # > # {'id': 'A001-AB-1234_chunk_0', 'content':.... #\n\nNotice how in this case, we do get the result back, but the id doesn't match\nthe regex query.\n\nReasoning:\n\nAzure AI Hybrid search reranks documents after both the vector search and\nfulltext search are finished. The search_text argument allows for strict\n(regex) matching, but this matching only applies to the fulltext search. Since\nwe pre-filter on a specific document, vector search will always yield this\nresult (note: this holds even if the neighbor of the embedded query isn't too\nsimilar, since we always try to return 10 results - which then must include\nour single document). After both the vector and text search are executed, the\nhybrid results include results which would not be expected from just full-text\nsearch.\n\nBack to Home\n\nSo long, and thanks for all the fish.\n\ncopyright Jakob Serlier 2023-2023 || contact: mail@jakobs.dev\n\n", "frontpage": false}
