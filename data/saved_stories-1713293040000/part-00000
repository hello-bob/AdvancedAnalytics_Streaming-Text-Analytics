{"aid": "40051220", "title": "Podman on FreeBSD-14.0", "url": "https://podman.io/docs/installation#installing-on-freebsd-140", "domain": "podman.io", "votes": 1, "user": "BSDobelix", "posted_at": "2024-04-16 12:42:47", "comments": 0, "source_title": "Podman Installation | Podman", "source_text": "Podman Installation | Podman\n\nSkip to main content\n\n# Podman Installation Instructions\n\nLooking for a GUI? You can find Podman Desktop here.\n\n## Installing on Mac & Windows\n\nWhile \"containers are Linux,\" Podman also runs on Mac and Windows, where it\nprovides a native podman CLI and embeds a guest Linux system to launch your\ncontainers. This guest is referred to as a Podman machine and is managed with\nthe podman machine command. Podman on Mac and Windows also listens for Docker\nAPI clients, supporting direct usage of Docker-based tools and programmatic\naccess from your language of choice.\n\n### macOS\n\nOn Mac, each Podman machine is backed by a virtual machine. Once installed,\nthe podman command can be run directly from the Unix shell in Terminal, where\nit remotely communicates with the podman service running in the Machine VM.\n\nThough not recommended, Podman can also be obtained through Homebrew, the\npackage manager.\n\nAfter installing, you need to create and start your first Podman machine:\n\n    \n    \n    podman machine init podman machine start\n\nYou can then verify the installation information using:\n\n    \n    \n    podman info\n\nWe also provide binaries and a pkginstaller on our Github release page\n\n### Windows\n\nOn Windows, each Podman machine is backed by a virtualized Windows Subsystem\nfor Linux (WSLv2) distribution. Once installed, the podman command can be run\ndirectly from your Windows PowerShell (or CMD) prompt, where it remotely\ncommunicates with the podman service running in the WSL environment.\nAlternatively, you can access Podman directly from the WSL instance if you\nprefer a Linux prompt and Linux tooling.\n\nSee the Podman for Windows guide for setup and usage instructions.\n\n## Installing on Linux\n\n### Linux Distributions\n\n#### Arch Linux & Manjaro Linux\n\n    \n    \n    sudo pacman -S podman\n\nIf you have problems when running Podman in rootless mode follow the\ninstructions here\n\nFor more information on Podman on ArchLinux click here\n\n#### Alpine Linux\n\n    \n    \n    sudo apk add podman\n\nFor further details, please refer to the instructions on the Alpine Linux\nwiki.\n\n#### CentOS\n\nPodman is available in the default Extras repos for CentOS 7 and in the\nAppStream repo for CentOS 8 and Stream.\n\n    \n    \n    sudo yum -y install podman\n\n#### Debian\n\nThe podman package is available in the Debian 11 (Bullseye) repositories and\nlater.\n\n    \n    \n    sudo apt-get -y install podman\n\n#### Fedora\n\n    \n    \n    sudo dnf -y install podman\n\n#### Fedora CoreOS, Fedora Silverblue\n\nBuilt-in, no need to install\n\n#### Gentoo\n\n    \n    \n    sudo emerge app-containers/podman\n\n#### OpenEmbedded\n\nBitbake recipes for Podman and its dependencies are available in the meta-\nvirtualization layer. Add the layer to your OpenEmbedded build environment and\nbuild Podman using:\n\n    \n    \n    bitbake podman\n\n#### openSUSE\n\n    \n    \n    sudo zypper install podman\n\n#### openSUSE Kubic\n\nBuilt-in, no need to install\n\n#### Raspberry Pi OS arm64 (beta)\n\nRaspberry Pi OS use the standard Debian repositories, so it is fully\ncompatible with Debian's arm64 repository. You can simply follow the steps for\nDebian to install Podman.\n\n#### RHEL7\n\nSubscribe, then enable Extras channel and install Podman.\n\n    \n    \n    sudo subscription-manager repos --enable=rhel-7-server-extras-rpms sudo yum -y install podman\n\n#### RHEL8\n\nPodman is included in the container-tools module, along with Buildah and\nSkopeo.\n\n    \n    \n    sudo yum module enable -y container-tools:rhel8 sudo yum module install -y container-tools:rhel8\n\nThe container-tools:rhel8 is the fast application stream, containing most\nrecent rolling versions of the tools. Use the container-tools:2.0 stream for\nstable versions of Podman 1.6. The command yum module list container-tools\nshows the available streams.\n\n#### Ubuntu\n\nThe podman package is available in the official repositories for Ubuntu 20.10\nand newer.\n\n    \n    \n    # Ubuntu 20.10 and newer sudo apt-get update sudo apt-get -y install podman\n\n#### Linux Mint\n\nFollow the steps for Ubuntu (or Debian if you use LMDE).\n\nReplace $(lsb_release -rs) with $(grep DISTRIB_RELEASE= /etc/upstream-release/lsb-release | cut -d \"=\" -f 2) for Ubuntu steps.\n\n### Installing development versions of Podman\n\n#### Fedora\n\nYou can test the very latest Podman in Fedora's updates-testing repository\nbefore it goes out to all Fedora users.\n\n    \n    \n    sudo dnf update --refresh --enablerepo=updates-testing podman\n\nIf you use a newer Podman package from Fedora's updates-testing, we would\nappreciate your +1 feedback in Bodhi, Fedora's update management system.\n\n### Installing bleeding-edge versions of Podman\n\nIf you like danger and are interested in testing the latest unreleased bits of\nPodman on Fedora, CentOS and RHEL, we have a Copr repository.\n\nCAUTION: This repository contains rpm builds generated using the main branch\nof upstream container tools repositories, and simply CANNOT be recommended for\nany production use.\n\nRHEL8 / CentOS 8 Stream users would first need to disable the container-tools\nmodule. All other users can skip this step.\n\n    \n    \n    sudo dnf module disable container-tools -y\n\nEnable the Copr and install podman.\n\n    \n    \n    sudo dnf copr enable rhcontainerbot/podman-next -y sudo dnf install podman\n\n## Installing on FreeBSD 14.0\n\n> [!WARNING] The FreeBSD port of the Podman container engine is experimental\n> and should be used for evaluation and testing purposes only.\n\nYou can install Podman on FreeBSD using pkg:\n\n    \n    \n    pkg install podman\n\nThere's also a podman-suite meta package that will pull additional packages\nfor you (buildah, skopeo).\n\n#### Initial configuration\n\nTo properly support Podman's container restart policy, conmon needs fdescfs(5)\nto be mounted on /dev/fd.\n\nIf /dev/fd is not already mounted:\n\n    \n    \n    mount -t fdescfs fdesc /dev/fd\n\nTo make it permanent, add the following line to /etc/fstab:\n\n    \n    \n    fdesc /dev/fd fdescfs rw 0 0\n\nTo start Podman after reboot:\n\n    \n    \n    service podman enable\n\n##### Networking\n\nContainer networking relies on NAT to allow container network packets out to\nthe host's network. This requires a PF firewall to perform the translation. A\nsimple example is included - to use it:\n\n    \n    \n    cp /usr/local/etc/containers/pf.conf.sample /etc/pf.conf\n\nEdit /etc/pf.conf and set v4egress_if, v6egress_if variables to your network\ninterface(s)s\n\nEnable and start pf:\n\n    \n    \n    service pf enable service pf start\n\nThe sample PF configuration includes support for port redirections. These are\nimplemented as redirect rules in anchors nested under cni-rdr.\n\nSupport for redirecting connections from the container host to services\nrunning inside a container is included for FreeBSD 13.3 and later. To enable\nthis, first load the pf kernel module and enable PF support for these\nredirections using sysctl:\n\n    \n    \n    echo 'pf_load=\"YES\"' >> /boot/loader.conf kldload pf sysctl net.pf.filter_local=1 echo 'net.pf.filter_local=1' >> /etc/sysctl.conf.local service pf restart\n\nRedirect rules will work if the destination address is localhost (e.g.\n127.0.0.1 or ::1) - to enable this, the following line must be included in\nyour /etc/pf.conf:\n\n    \n    \n    nat-anchor \"cni-rdr/*\"\n\nif upgrading from an older version, this needs to be added to /etc/pf.conf.\n\nFor example if host port 1234 is redirected to an http service running in a\ncontainer, you could connect to it using:\n\n    \n    \n    fetch -o- http://$(hostname):1234\n\nor\n\n    \n    \n    fetch -o- http://localhost:1234\n\n##### Storage\n\nContainer images and related state is stored in /var/db/containers. It is\nrecommended to use ZFS for this:\n\n    \n    \n    zfs create -o mountpoint=/var/db/containers zroot/containers\n\nIf your system cannot use ZFS, change storage.conf to use the vfs storage\ndriver:\n\n    \n    \n    sed -I .bak -e 's/driver = \"zfs\"/driver = \"vfs\"/' /usr/local/etc/containers/storage.conf\n\n##### Verification\n\nAfter following these steps you should be able to run native images:\n\n    \n    \n    podman run --rm docker.io/dougrabson/hello\n\n##### Linux Emulation\n\nIt is possible to run many Linux container images using FreeBSD's Linux\nemulation:\n\n    \n    \n    sudo sysrc linux_enable=YES sudo service linux start sudo podman run --rm --os=linux alpine cat /etc/os-release | head -1 NAME=\"Alpine Linux\"\n\n## Building from Source\n\n### Build and Run Dependencies\n\nRequired\n\nOn Fedora:\n\n    \n    \n    # Install build dependencies sudo dnf -y builddep rpm/podman.spec\n    \n    # Install runtime dependencies sudo dnf -y install catatonit conmon containers-common-extra\n\nOn all RHEL and CentOS Stream, first install dnf-builddep:\n\n    \n    \n    sudo dnf -y install 'dnf-command(builddep)'\n\nInstall build dependencies:\n\n    \n    \n    # CentOS Stream 8 sudo dnf -y builddep rpm/podman.spec --enablerepo=powertools\n    \n    # CentOS Stream 9 sudo dnf -y builddep rpm/podman.spec --enablerepo=crb\n    \n    # RHEL (8 and newer) sudo dnf -y builddep rpm/podman.spec --enablerepo=codeready-builder-for-rhel-$(rpm --eval %{?rhel})-$(uname -m)-rpms\n\nInstall runtime dependencies:\n\n    \n    \n    sudo dnf -y install \\ conmon \\ containers-common \\ crun \\ iptables \\ netavark \\ nftables \\ slirp4netns\n\nDebian, Ubuntu, and related distributions:\n\n    \n    \n    sudo apt-get install \\ btrfs-progs \\ crun \\ git \\ golang-go \\ go-md2man \\ iptables \\ libassuan-dev \\ libbtrfs-dev \\ libc6-dev \\ libdevmapper-dev \\ libglib2.0-dev \\ libgpgme-dev \\ libgpg-error-dev \\ libprotobuf-dev \\ libprotobuf-c-dev \\ libseccomp-dev \\ libselinux1-dev \\ libsystemd-dev \\ netavark \\ pkg-config \\ uidmap\n\nThe netavark package may not be available on older Debian / Ubuntu versions.\nInstall the containernetworking-plugins package instead.\n\nOn openSUSE Leap 15.x and Tumbleweed:\n\n    \n    \n    sudo zypper -n in libseccomp-devel libgpgme-devel\n\nOn Manjaro (and maybe other Linux distributions):\n\nMake sure that the Linux kernel supports user namespaces:\n\n    \n    \n    > zgrep CONFIG_USER_NS /proc/config.gz CONFIG_USER_NS=y\n\nIf not, please update the kernel. For Manjaro Linux the instructions can be\nfound here: https://wiki.manjaro.org/index.php/Manjaro_Kernels\n\nAfter that enable user namespaces:\n\n    \n    \n    sudo sysctl kernel.unprivileged_userns_clone=1\n\nTo enable the user namespaces permanently:\n\n    \n    \n    echo 'kernel.unprivileged_userns_clone=1' > /etc/sysctl.d/userns.conf\n\n### Building missing dependencies\n\nIf any dependencies cannot be installed or are not sufficiently current, they\nhave to be built from source. This will mainly affect Debian, Ubuntu, and\nrelated distributions, or RHEL where no subscription is active (e.g. Cloud\nVMs).\n\n#### golang\n\nBe careful to double-check that the version of golang is new enough (i.e. go\nversion), as of January 2022 version is 1.16.x or higher is required. The\ncurrent minimum required version can always be found in the go.mod file. If\nneeded, golang kits are available at https://golang.org/dl/. Alternatively, go\ncan be built from source as follows (it's helpful to leave the system-go\ninstalled, to avoid having to bootstrap go:\n\n    \n    \n    export GOPATH=~/go git clone https://go.googlesource.com/go $GOPATH cd $GOPATH cd src ./all.bash export PATH=$GOPATH/bin:$PATH\n\n#### conmon\n\nThe latest version of conmon is expected to be installed on the system. Conmon\nis used to monitor OCI Runtimes. To build from source, use the following:\n\n    \n    \n    git clone https://github.com/containers/conmon cd conmon export GOCACHE=\"$(mktemp -d)\" make sudo make podman\n\n#### crun / runc\n\nThe latest version of at least one container runtime is expected to be\ninstalled on the system. crun or runc are some of the possibilities, and one\nis picked up as the default runtime by Podman (crun has priority over runc).\nSupported versions of crun or runc are available for example on Ubuntu 22.04.\nrunc version 1.0.0-rc4 is the minimal requirement, which is available since\nUbuntu 18.04.\n\nTo double-check, runc --version should produce at least spec: 1.0.1, otherwise\nbuild your own:\n\n    \n    \n    git clone https://github.com/opencontainers/runc.git $GOPATH/src/github.com/opencontainers/runc cd $GOPATH/src/github.com/opencontainers/runc make BUILDTAGS=\"selinux seccomp\" sudo cp runc /usr/bin/runc\n\n#### Add configuration\n\n    \n    \n    sudo mkdir -p /etc/containers sudo curl -L -o /etc/containers/registries.conf https://src.fedoraproject.org/rpms/containers-common/raw/main/f/registries.conf sudo curl -L -o /etc/containers/policy.json https://src.fedoraproject.org/rpms/containers-common/raw/main/f/default-policy.json\n\n#### Optional packages\n\nFedora, CentOS, RHEL, and related distributions:\n\n(no optional packages)\n\nDebian, Ubuntu, and related distributions:\n\n    \n    \n    apt-get install -y \\ libapparmor-dev\n\n### Get Source Code\n\nFirst, ensure that the go version that is found first on the $PATH is 1.16.x\nor higher. Instruction above will help you compile newer version of Go if\nneeded. Then we can build Podman:\n\n    \n    \n    git clone https://github.com/containers/podman/ cd podman make BUILDTAGS=\"selinux seccomp\" PREFIX=/usr sudo make install PREFIX=/usr\n\n#### Build Tags\n\nOtherwise, if you do not want to build Podman with seccomp or selinux support\nyou can add BUILDTAGS=\"\" when running make.\n\n    \n    \n    make BUILDTAGS=\"\" sudo make install\n\nPodman supports optional build tags for compiling support of various features.\nTo add build tags to the make option the BUILDTAGS variable must be set, for\nexample:\n\n    \n    \n    make BUILDTAGS='seccomp apparmor'\n\nBuild Tag| Feature| Dependency  \n---|---|---  \napparmor| apparmor support| libapparmor  \ncni| CNI networking  \nexclude_graphdriver_btrfs| exclude btrfs| libbtrfs  \nexclude_graphdriver_devicemapper| exclude device-mapper| libdm  \nlibdm_no_deferred_remove| exclude deferred removal in libdm| libdm  \nseccomp| syscall filtering| libseccomp  \nselinux| selinux process and mount labeling  \nsystemd| journald logging| libsystemd  \n  \nNote that Podman does not officially support device-mapper. Thus, the\nexclude_graphdriver_devicemapper tag is mandatory.\n\n### Vendoring - Dependency Management\n\nThis project is using go modules for dependency management. If the CI is\ncomplaining about a pull request leaving behind an unclean state, it is very\nlikely right about it. After changing dependencies, make sure to run make\nvendor to synchronize the code with the go module and repopulate the ./vendor\ndirectory.\n\n#### Ansible\n\nAn Ansible Role is also available to automate the installation of the above\nstatically linked binary on its supported OS:\n\n    \n    \n    sudo su - mkdir -p ~/.ansible/roles cd ~/.ansible/roles git clone https://github.com/alvistack/ansible-role-podman.git podman cd ~/.ansible/roles/podman pip3 install --upgrade --ignore-installed --requirement requirements.txt molecule converge molecule verify\n\n## Configuration files\n\n### registries.conf\n\n#### Man Page: registries.conf.5\n\n/etc/containers/registries.conf\n\nregistries.conf is the configuration file which specifies which container\nregistries should be consulted when completing image names which do not\ninclude a registry or domain portion.\n\n#### Example from the Fedora containers-common package\n\n    \n    \n    $ cat /etc/containers/registries.conf # For more information on this configuration file, see containers-registries.conf(5). # # NOTE: RISK OF USING UNQUALIFIED IMAGE NAMES # We recommend always using fully qualified image names including the registry # server (full dns name), namespace, image name, and tag # (e.g., registry.redhat.io/ubi8/ubi:latest). Pulling by digest (i.e., # quay.io/repository/name@digest) further eliminates the ambiguity of tags. # When using short names, there is always an inherent risk that the image being # pulled could be spoofed. For example, a user wants to pull an image named # `foobar` from a registry and expects it to come from myregistry.com. If # myregistry.com is not first in the search list, an attacker could place a # different `foobar` image at a registry earlier in the search list. The user # would accidentally pull and run the attacker's image and code rather than the # intended content. We recommend only adding registries which are completely # trusted (i.e., registries which don't allow unknown or anonymous users to # create accounts with arbitrary names). This will prevent an image from being # spoofed, squatted or otherwise made insecure. If it is necessary to use one # of these registries, it should be added at the end of the list. # # # An array of host[:port] registries to try when pulling an unqualified image, in order. unqualified-search-registries = [\"registry.fedoraproject.org\", \"registry.access.redhat.com\", \"docker.io\"] # # [[registry]] # # The \"prefix\" field is used to choose the relevant [[registry]] TOML table; # # (only) the TOML table with the longest match for the input image name # # (taking into account namespace/repo/tag/digest separators) is used. # # # # If the prefix field is missing, it defaults to be the same as the \"location\" field. # prefix = \"example.com/foo\" # # # If true, unencrypted HTTP as well as TLS connections with untrusted # # certificates are allowed. # insecure = false # # # If true, pulling images with matching names is forbidden. # blocked = false # # # The physical location of the \"prefix\"-rooted namespace. # # # # By default, this equal to \"prefix\" (in which case \"prefix\" can be omitted # # and the [[registry]] TOML table can only specify \"location\"). # # # # Example: Given # # prefix = \"example.com/foo\" # # location = \"internal-registry-for-example.net/bar\" # # requests for the image example.com/foo/myimage:latest will actually work with the # # internal-registry-for-example.net/bar/myimage:latest image. # location = \"internal-registry-for-example.com/bar\" # # # (Possibly-partial) mirrors for the \"prefix\"-rooted namespace. # # # # The mirrors are attempted in the specified order; the first one that can be # # contacted and contains the image will be used (and if none of the mirrors contains the image, # # the primary location specified by the \"registry.location\" field, or using the unmodified # # user-specified reference, is tried last). # # # # Each TOML table in the \"mirror\" array can contain the following fields, with the same semantics # # as if specified in the [[registry]] TOML table directly: # # - location # # - insecure # [[registry.mirror]] # location = \"example-mirror-0.local/mirror-for-foo\" # [[registry.mirror]] # location = \"example-mirror-1.local/mirrors/foo\" # insecure = true # # Given the above, a pull of example.com/foo/image:latest will try: # # 1. example-mirror-0.local/mirror-for-foo/image:latest # # 2. example-mirror-1.local/mirrors/foo/image:latest # # 3. internal-registry-for-example.net/bar/image:latest # # in order, and use the first one that exists. # # short-name-mode=\"enforcing\"\n    \n    [[registry]] location=\"localhost:5000\" insecure=true\n\n### mounts.conf\n\n/usr/share/containers/mounts.conf and optionally /etc/containers/mounts.conf\n\nThe mounts.conf files specify volume mount directories that are automatically\nmounted inside containers when executing the podman run or podman build\ncommands. Container process can then use this content. The volume mount\ncontent does not get committed to the final image.\n\nUsually these directories are used for passing secrets or credentials required\nby the package software to access remote package repositories.\n\nFor example, a mounts.conf with the line\n\"/usr/share/rhel/secrets:/run/secrets\", the content of /usr/share/rhel/secrets\ndirectory is mounted on /run/secrets inside the container. This mountpoint\nallows Red Hat Enterprise Linux subscriptions from the host to be used within\nthe container.\n\nNote this is not a volume mount. The content of the volumes is copied into\ncontainer storage, not bind mounted directly from the host.\n\n#### Example from the Fedora containers-common package:\n\n    \n    \n    cat /usr/share/containers/mounts.conf /usr/share/rhel/secrets:/run/secrets\n\n### seccomp.json\n\n/usr/share/containers/seccomp.json\n\nseccomp.json contains the whitelist of seccomp rules to be allowed inside of\ncontainers. This file is usually provided by the containers-common package.\n\nThe link above takes you to the seccomp.json\n\n### policy.json\n\n/etc/containers/policy.json\n\n#### Man Page: policy.json.5\n\n#### Example from the Fedora containers-common package:\n\n    \n    \n    cat /etc/containers/policy.json { \"default\": [ { \"type\": \"insecureAcceptAnything\" } ], \"transports\": { \"docker-daemon\": { \"\": [{\"type\":\"insecureAcceptAnything\"}] } } }\n\nEdit this page\n\nDocs\n\n  * Installation Instructions\n  * Documentation\n  * Podman CLI Commands\n\nCommunity\n\n  * Discord\n  * Blog\n  * Mailing List\n  * RSS Feed\n\nProjects\n\n  * Podman GitHub\n  * Podman Desktop GitHub\n  * Podman Website GitHub\n  * Podman Desktop Website\n\nCopyright \u00a9 2024 Podman. Built with Docusaurus.\n\n", "frontpage": false}
