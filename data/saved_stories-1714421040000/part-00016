{"aid": "40196333", "title": "500 Byte Images: The Haiku Vector Icon Format (2016)", "url": "http://blog.leahhanson.us/post/recursecenter2016/haiku_icons.html", "domain": "leahhanson.us", "votes": 2, "user": "smartmic", "posted_at": "2024-04-29 09:37:42", "comments": 0, "source_title": "500 Byte Images: The Haiku Vector Icon Format | Leah Hanson", "source_text": "500 Byte Images: The Haiku Vector Icon Format | Leah Hanson\n\n# Leah Hanson\n\n  * About\n  * Posts\n  * Speaking\n  * RSS\n\n# 500 Byte Images: The Haiku Vector Icon Format\n\nSep 1, 2016 #batch2 #haiku #images\n\nHaiku uses a custom vector image format to store icons. This is surprising\nboth because most OSes consider bitmaps to be totally sufficient to represent\nicons and because there are plenty of vector graphics formats out this (e.g.\nSVG). The goal of the Haiku Vector Icon Format (HVIF) is to make vector icon\nfiles as small as possible. This allows Haiku to display icons as several\nsizes while still keeping the files small enough to fit into an inode (i.e.,\ninside a file\u2019s metadata). The goal of keeping the icons in the metadata is to\nreduce the disk reads needed to display a folder \u2013 it allows each file to only\nrequire one disk read to display.\n\nThis blog post examines the details of the HVIF format using a hex editor and\nthe canonical parser\u2019s source code. In the process of dissecting an example\nicon, I\u2019ll also show you an optimization bug in the icon image editor.\n\n## The Problem Space: Icons\n\nHVIF is designed especially for the icons that appear when you look at the\nfiles in a folder.. This include the files on your desktop, which is just a\nspecial folder. Each file has an icon associated with it, based on the file\ntype. While some OSes use thumbnails for PDFs and common image types, HVIF is\nfocused only on the symbolic, abstract icons, not on file previews.\n\nIcons are often represented as bitmaps, and BeOS took a fairly standard\napproach. It had two icon sizes (16x16 and 32x32 pixels) and represented each\nicon as two bitmaps (one for each size). Because bitmaps are arrays of pixel\ncolors without metadata about the \u201cmeaning\u201d of a given pixel, resizing\ninvolves applying transformations somewhat blindly, and general creates\ndistortions, making the image blurry or pixelated. Because there are a small,\nknown set of sizes for icons, each size is created separately as its own image\nand stored separately as well.\n\nThe two bitmap files were very small \u2013 a 16x16 bitmap is 256 bytes and a 32x32\nbitmap is 1024, for a total of 1280 bytes per icon. Icons have been getting\nbigger since the 90\u2019s (when BeOS was developed), and modern OSes have 64x64\nand 128x128 icons. Even if you only add 64x64 icons, that moves your total\nbytes per icon from just over 1kb to just over 5kb. Each of these jumps in\nsize (doubling the edges) quadruples the number of pixels, and thus the\nstorage space needed for the image.\n\n(image from the Icon-O-Matic documentation.)\n\nBesides bitmaps, the major option for representing images are vector formats.\nHaiku uses vector icons, IRIX used vector icons, even mainstream Linux\ndesktops like Gnome and KDE can use vector icons. Vector representations work\nbest for images that can be decomposed into lines and color gradients \u2013 which\nis a good fit for the abstract style common in icons. One of the big\nadvantages of vector formats is that they\u2019re easy to resize; because you know\nwhat the shape is supposed to be (i.e. a circle), you can render it very small\nor very large without distorting it. This means that you only need one file\nper icon; it doesn\u2019t matter how many sizes you want to render icons at. In the\nimage above, you can see the same icon rendered in three different file\nformats \u2013 bitmaps and two vector formats. The bitmaps are 16x16 and 32x32;\nadding a larger size there will make a big difference to the file size. The\nvector image file sizes will remain constant as new icon display sizes are\nintroduced. You can see below why bitmaps need all those different files for\ndifferent display sizes; when a 32x32` bitmap is blown up to larger sizes it\nbecomes dramatically pixelated. When a vector images is scaled up, it looks\njust as good as at its native size. The drawback to using vector images is\nthat it can take longer to render a vector image than a bitmap; you basically\nneed to turn the vector image into a bitmap at the size you want to display on\nthe screen.\n\n(image from the Icon-O-Matic documentation.)\n\nThe promise of vector formats for icons is that one file could be used to\nrepresent all display sizes without loss of clarity. Having one file (rather\nthan three) could save some work for the icon artist and maybe save some file\nsize. However, if you work with web images, you probably know that SVGs (a\nvector file format) aren\u2019t always smaller than bitmap formats like PNG/JPG of\nthe same image. Bitmaps have fairly predictable sizes based on the number of\npixels in the image and the number of colors those pixels can take on. Vector\nimages have file sizes based on the complexity of the image; it takes space to\nstore each line/color-gradient and more space to store complex lines.\n\nIn terms of size, HVIF images compare well to BeOS\u2019s bitmaps: real-world icons\ntend to be 500 to 700 bytes. You can also make ones that are under 250 bytes\nor a bit over 1000 bytes. This is much smaller than storing even just a 64x64\nbitmap and also smaller than other vector formats (e.g., SVG). This small size\nis achieved by using a binary file format designed to save space (unlike SVG\u2019s\nplain-text XML format). Part of the space saving design involves placing\nlimits on the complexity of files (e.g. you can only have 256 paths).\n\n### Why do Haiku\u2019s developers care about the size of icon files?\n\nOne kilobyte is a pretty small amount of memory on modern hard drives, or even\nin RAM, and it\u2019s not like there are millions (or even tens of thousands) of\nicons in one operating system. They care because having especially small icon\nfiles allows an optimization that makes displaying the files in a folder\nfaster.\n\nIf you use the standard bitmap icon formats, you\u2019ll probably store them in\ntheir own files, separate from the files that use them. In order to display\neach file in a folder, the operating system will need to read the metadata for\nthe file (including its name and file type) and then read the icon file for\nthat file type. If the icon file were so small that you could store it in the\nsame place as the file metadata, then you could save a read from the hard\ndrive \u2013 you could get the metadata and the icon all in one read.\n\nSaving one read per file doesn\u2019t sound exciting \u2013 it\u2019s just one. However,\nreading from disk is among the slowest operations: a CPU cycle can be a\nquarter of a nanosecond; a read from RAM is about 60 nanoseconds; a read from\na relatively fast modern SSD is 20 microseconds (20,000 nanoseconds); a read\nfrom a slow disk is 10 milliseconds (10,000,000 nanoseconds). The reads from\ndisk dominate the time it takes to display a file in a folder; it could be a\nsignificant performance gain to halve the number of disk reads even if\nrendering a vector image takes longer than rendering a bitmap.\n\n## Implementation Details\n\nBecause the interesting part of the file format is how small it can be, I\nreally wanted to learn the nitty-gritty details of how it works. There\u2019s a\ncouple posts by Stephan Assmus, the creator of the file format, and one of\nthem covers some key details of how the format saves space. Unfortunately,\nthis post didn\u2019t include enough details to satisfy my curiosity, so I used the\nparser\u2019s source code and a sample HVIF file (in a hex editor) to learn more.\n\n### Example\n\nI constructed a file in Icon-O-Matic, the application for creating/editing\nHVIF files. It has two shapes - a letter H on top of a blobby shape.^1 The H\nis white and the blob has a color gradient from blue to red. The rest of the\nbackground (the 64x64 canvas) is blank/transparent. The H has been scaled up\nfrom its original size to take up most of the space.\n\nThe benefit of having such a simple logo to examine is that it\u2019s very small\n(128 bytes) \u2013 only 8 lines in the hex editor.\n\nAbove is Haiku\u2019s hex editor. At the right, it the bytes interpreted as ASCII\ncharacters, with . for non-printable/invalid characters. In the middle is the\nbytes of the file printed as hexadecimal; each pair of characters (e.g. 6e) is\none byte. Each line shows 16 bytes. On the left are character counts in hex\n(0x00, 0x10, 0x20, ..., which would be 0, 16, 32, ..., respectively in\ndecimal) . Theses character counts act like line numbers; they\u2019re counting the\nnumber of characters that came before that character count/line number.\n\nBinary formats are much harder for humans to read than most plain text\nformats; I deciphered this file by reading the parsing code that reads these\nfiles. The file has styles, paths, and shapes, each in their own sections;\nshapes come last because they\u2019re each a combination of a style and one or more\npaths. Here\u2019s an overview of what all these bytes mean:\n\nThe first four bytes (6e 63 69 66) are a magic number that identifies this as\nan HVIF file; the letters ficn was chosen to represent \u2018flat icon\u2019. Then there\nare three sections (yellow, blue, green); these sections appear in every HVIF\nfile and each one of them starts with a count of the objects in that section\n(all of which are 02 in this file). The yellow section is the two styles: a\nflat white and a red to blue gradient. The blue section is two paths: the\noutline of the H and the outline of the blob. The green section is two shapes;\nthese each combine a style and a path to make the white H and colorful blob.\nThe shape for the H also has a transformation matrix to scale it up.\n\n### Magic Number\n\nWhen you\u2019re parsing a file, it helps to be able to tell right away if it\u2019s the\ntype you were expecting, which is why the first four bytes are devoted to\nthis. This is common in binary file formats. While the letters are ficn, they\nappear in the hex editor as ncif because the magic number is a single int32\nwritten in little endian order, which determines the ordering of the bytes. In\nlittle-endian, the least significant byte (the n) goes first and the most\nsignificant byte (the f) goes last.\n\n### Styles\n\nStyles are gradients and flat colors. Each shape can have one style, which is\nused to fill the shape with a color/gradient pattern. In order to get examples\nof both a color and a gradient, I made the H flat white and the blob a\ngradient. The first byte of this section, 02, tells us there are two styles.\nThe first style starts right after that.\n\nEach style will start with a style type (1 byte), which tells you how to parse\nthe rest of that style. All of the styles include at least one color; the\ngradients have more colors and also have more other properties than the flat\ncolors. HVIF represents colors as aRGB \u2013 each color has four channels: alpha\n(opacity), red, green, blue. Each channel takes one byte to represent (a\nuint8).\n\nThe first style is the flat white, represented by 05 ff. I know that the style\nis this long because I\u2019ve already parsed it before explaining the file to you;\notherwise, I\u2019d have to look at the first byte (the style type, 05) and then\ninterpret the rest from there. Objects (styles/paths/shapes) in HVIF are all\nvariable length, to allow objects with simple or common special-case formats\n(like this one) to be stored very compactly. The first byte is the style type,\nwhich corresponds to an enum in the parser code. (An enum in C/C++ lets you\ngive numeric values names; they\u2019re often used as a way to assign different\nvalues to a related set of names \u2013 like these style types.) There are five\npossible style types:\n\n    \n    \n    STYLE_TYPE_SOLID_COLOR = 1, STYLE_TYPE_GRADIENT = 2, STYLE_TYPE_SOLID_COLOR_NO_ALPHA = 3, STYLE_TYPE_SOLID_GRAY = 4, STYLE_TYPE_SOLID_GRAY_NO_ALPHA = 5,\n\nThe flat white is STYLE_TYPE_SOLID_GRAY_NO_ALPHA. This tells us that this is:\na flat color, not a gradient; a gray, meaning that the red, green, and blue\nchannels are all equal; and completely opaque, so the alpha value will be 255.\nThat\u2019s a lot of information to put into one bit! Leveraging overly specific\ntypes to pack common cases into very few bits is important to keeping the\nfiles small.\n\nBecause this is a flat color, it is defined by one aRGB color. The alpha value\nis given by the type (NO_ALPHA). The red/green/blue value is given by the\nsecond byte: ff. All three of the color channels will be set to 255; (255,\n255, 255, 255) is how aRGB represents pure white.\n\nWe\u2019re already done with the first style. There aren\u2019t any padding/delimiters\nin HVIF; that would use up space. Instead, we go straight into the second\nstyle, the gradient for the blob.\n\nThe bytes for the second style are 02 03 04 02 00 ff 00 00 86 00 00 ff. Based\non the enum, 02 is STYLE_TYPE_GRADIENT; I do like that the type values are so\neasily human readable in the file \u2013 2 is just 02. A gradient starts with a\ngradient type, gradient flags, and a gradient stop count; each of these is one\nbyte. The gradient type here is 03, and I\u2019ll used another enum from the parser\nto interpret it.\n\n    \n    \n    enum gradients_type { GRADIENT_LINEAR = 0, GRADIENT_CIRCULAR, GRADIENT_DIAMOND, GRADIENT_CONIC, GRADIENT_XY, GRADIENT_SQRT_XY };\n\nThe enum starts at zero and increments by one with each new name, so 03\nmatches to the fourth name, GRADIENT_CONIC. We don\u2019t actually need to\nunderstand this to parse the style because the gradient type affects the\nrendering, not the structure of the file. Every gradient has colors that start\nand stop at different places (i.e. starts as opaque as the aRGB color is and\neventually become transparent); the gradient type determines how the renderer\nwill fade between the colors.\n\nThe next byte, the gradient flags (04), does affect the parsing. Many HVIF\nobjects have a flags byte near the beginning; this allows for space saving in\na similar way to the various flat color types. Each bit in the flags byte has\na meaning, determined by another enum:\n\n    \n    \n    GRADIENT_FLAG_TRANSFORM = 1 << 1, GRADIENT_FLAG_NO_ALPHA = 1 << 2, GRADIENT_FLAG_16_BIT_COLORS = 1 << 3, // not yet used GRADIENT_FLAG_GRAYS = 1 << 4,\n\nA byte has 8 bits; for 04 this is 0000 0100. The fact that there is only one\nbit that\u2019s a 1 means that only one flag is set. Flags are checked using\nstatements like gradientFlags & GRADIENT_FLAG_TRANSFORM, with a resulting\nvalue of anything greater than zero being true/the flag is set. Each flag\nvalue only has one 1 in it, so the the only one that\u2019s set is the one whose\nvalue is 4. This means that only the GRADIENT_FLAG_NO_ALPHA is set because 1\n<< 2 (one left-shifted twice) is 0000 0100. This flag means that the alpha\nvalue for all the colors in the gradient is 255 (completely opaque).\n\nYou may have noticed that the flag values start at 0000 0010 and continue to\n0001 0000. While not using all the bits (due to not having enough flags to\nneed to) is fine, it seems odd to me that 0000 0001 isn\u2019t used. I don\u2019t have\nan explanation for why.\n\nThis is a gradient where the colors will not include alpha values (all are\nopaque), so the next step is to look at the stop count to find out how many\ncolors there are. In this case, that\u2019s 02, which is just 2. Each of these two\ncolors will be 4 bytes - a stop offset plus red, green, blue. The bytes for\nthe first color are 00 ff 00 00, which means that the stop offset is zero and\nthe color is 100% red. The second color is 86 00 00 ff \u2013 a stop offset of 86\nand 100% blue. This the end of this gradient, and (since we\u2019ve parsed two\nstyles) the end of the styles section.\n\n### Paths\n\nThe paths section is:\n\n    \n    \n    02 0a 0c 2b b3 da 2b b5 72 30 b5 72 30 b3 da 31 b3 da 31 b7 70 30 b7 70 30 b5 d8 2b b5 d8 2b b7 70 2a b7 70 2a b3 da 06 08 de 6e 40 24 28 28 b8 18 b3 6d b4 47 b8 f2 40 2c 54 b5 79 c6 39 ba 16 c9 36 3c 58 50 54 4c 54 c7 3d 54 58 40 24\n\nThis is the biggest section of the file, mostly because each point in each\npath needs to be encoded, plus even more points for the curved section of the\nblob-path.\n\nA path is made of line segments; each segment can be straight or curved. The H\npath is entirely straight lines, but the blob-path has a mix of straight lines\nand curves. This lets me show you two different ways paths are encoded. These\ndifferences offer space savings, like the other complexity-increasing encoding\nchoices.\n\nThe first byte is 02 to say that there are two paths. Each path starts with a\npath flags byte and a point count. For the first path, this is 0a for the\nflags and 0c for the point count. For the flags, we care about the pattern of\nbits rather than the value; 0a in hex is 0000 1010 in binary. Two of the flags\nare set (since there are two 1s), but I\u2019ll need another enum to decode what\nthose mean:\n\n    \n    \n    PATH_FLAG_CLOSED = 1 << 1, PATH_FLAG_USES_COMMANDS = 1 << 2, PATH_FLAG_NO_CURVES = 1 << 3,\n\nThis flag byte works the same way as the gradient style\u2019s flag byte:\nPATH_FLAG_CLOSED and PATH_FLAG_NO_CURVES are true for this path.\nPATH_FLAG_CLOSED is direction to the renderer \u2013 \u201cplease connect the last point\nto the first one with a line\u201d. This flag does not affect parsing.\nPATH_FLAG_NO_CURVES means there are only straight lines in this path. As\nimportant as the flags that are set, PATH_FLAG_USES_COMMANDS being false means\nthat this path will be encoded as a list of points (we don\u2019t have to worry\nabout commands yet). Because this path is only straight lines, each segment\nwill be defined by one (x,y) point.\n\nThe point count is 0c in hex \u2013 meaning 12. The first point is 2b b3 da; this\nis composed of an x coordinate (2b) and a y coordinate (b3 da). Each\ncoordinate can be 1 or 2 bytes, so each point can be 2, 3, or 4 bytes. In this\nfirst path, all the points happen to have 1 byte x\u2019s and 2 byte y\u2019s.\n\nEach coordinate is encoded in a special number format designed for the HVIF\nformat. This allows integer values in the range -32 to +95 to be represented\nwith one byte and integer values in the range -128 to +192 to be represented\nwith two bytes. All non-integer values are represented using two bytes, and\nthey can be in the range -128 to +192. The first bit of the first byte of a\ncoordinate is 0 if the coordinate takes one byte and 1 if it takes two bytes.\nTo get the value of a one byte coordinate, interpret the byte as a uint8 and\nthen subtract 32. To get the value of a two byte coordinate, set the first bit\nto 0, interpret the two bytes as a uint16, divide the result by 102, and then\nsubtract 128.\n\nThis is the code that reads one coordinate:\n\n    \n    \n    // read_coord bool read_coord(LittleEndianBuffer& buffer, float& coord) { uint8 value; if (!buffer.Read(value)) return false; if (value & 128) { // high bit set, the next byte is part of the coord uint8 lowValue; if (!buffer.Read(lowValue)) return false; value &= 127; uint16 coordValue = (value << 8) | lowValue; coord = (float)coordValue / 102.0 - 128.0; } else { // simple coord coord = (float)value - 32.0; } return true; }\n\nWhile the ranges of the one-byte integers and two-byte integers are documented\nelsewhere, the code seems to be the only source for how to interpret a two-\nbyte coordinate. All coordinates are 32-bit floating point numbers in the\nimplementation, but I don\u2019t think that\u2019s essential to the format.\n\nThe range on the 1-byte coordinates initially confused me: why would you have\na range like -32 to +95, instead of being centered at 0? An important point to\nremember here is that the core range is 0-64 \u2013 the coordinates that are\nactually on the native 64x64 canvas. Thus, the center of that range is the\nnatural center of the coordinate system. There are 7 bits available in one\nbyte (8 minus the flag bit), so there\u2019s room for 127 values. By adding 32/31\nvalues on each side of the core 0-64 range, you end up at -32 to +95. (A quick\nway to check whether a range might be sized to take up a given number of bits\nis by adding the endpoints \u2013 i.e. +32 + +95 = 127.)\n\nThis format actually makes parsing the x/y coordinates by hand pretty easy.\nI\u2019m not trying to understand every single number, just figure out what each\npart is for. The first bit says whether this coordinate is one or two bytes;\nin the hex editor, this will be a letter pair that starts with 8, 9, or a\nletter (A through F). When I\u2019m reading a coordinate, I can quickly figure out\nif this is one or two bytes and move forward; I don\u2019t try to determine the\nvalues of all of them because it\u2019s not interesting or useful to me.\n\nHere are the 12 points:\n\nPoint #| x1| x2| y1| y2  \n---|---|---|---|---  \n1| 2b| b3| da  \n2| 2b| b5| 72  \n3| 30| b5| 72  \n4| 30| b3| da  \n5| 31| b3| da  \n6| 31| b7| 70  \n7| 30| b7| 70  \n8| 30| b5| d8  \n9| 2b| b5| d8  \n10| 2b| b7| 70  \n11| 2a| b7| 70  \n12| 2a| b3| da  \n  \nEven without turning the bytes into decimal numbers, it\u2019s clear that most of\nthe line segments are vertical or horizontal. I\u2019m not sure why Icon-O-Matic\nchose to store the path this way, when HVIF has a special space-saving way to\nstore horizontal or vertical line segments. Those special line segments are\nstored as one coordinate only, rather than the two for a basic line segment.\n\nUsing the horizontal and vertical segment types does require changing the type\nof the path. While lines-only paths and curves-only paths have segments of all\none time, command paths allow each segment in the path to have a different\ntype. There are four supported segment types: line, cubic curve, horizontal\nline, and vertical line. Command bytes near the beginning of the path \u2013\nbetween the point count and the first point \u2013 contain a 2-bit tag for each\nsegment in the path. A 12-point path would need three command bytes \u2013 2 bits\nper point * 12 points / 8 bits per byte = 3 bytes.\n\nThe simple lines-only path requires (12 points * 3 bytes per point =) 36 bytes\nto represent the points. A command path would need 3 bytes to represent the\nsegment types, but only 6 + 7 + 7 = 20 bytes to represent the points.\n\nPoint #| Segment Type| x1| x2| y1| y2  \n---|---|---|---|---|---  \n1| Line| 2b| b3| da  \n2| Vertical Line| b5| 72  \n3| Horizontal Line| 30  \n4| Vertical Line| b3| da  \n5| Horizontal Line| 31  \n6| Vertical Line| b7| 70  \n7| Horizontal Line| 30  \n8| Vertical Line| b5| d8  \n9| Horizontal Line| 2b  \n10| Vertical Line| b7| 70  \n11| Horizontal Line| 2a  \n12| Vertical Line| b3| da  \nTotal Bytes Used:| 6| 0| 7| 7  \n  \nUsing a different path type would save (36 - 23 =) 13 bytes; while that\u2019s not\na huge difference, it seems relevant in the canonical implementation of a file\nformat designed to save space. To make sure I\u2019m not confused about the way a\ncommand path would be represented in the file, I\u2019m going to edit the file to\njust change the representation of this one path. There\u2019s one more thing to\nfigure out before jumping into editing: the format of a command byte.\n\nFrom looking at the command byte parsing code, commands are read right to left\nwithin a byte, judging by the parsing code:\n\nEach pair of bits matches up to a segment type:\n\n    \n    \n    PATH_COMMAND_H_LINE = 0, PATH_COMMAND_V_LINE = 1, PATH_COMMAND_LINE = 2, PATH_COMMAND_CURVE = 3,\n\nSo, the command bytes would be 0100 0110, 0100 0100, and 0100 0100, which is\n46 44 44 in hex, assuming that the bytes are read from left to right (while\nthe bits within a byte are read right to left).\n\nI\u2019ll also need to change the flags byte from 0a (no curves, closed) to 06\n(commands, closed). I wanted to set it to 0e (no curves, commands, closed),\nbut that doesn\u2019t work due to the ordering of an if statement in the parsing\ncode:\n\n    \n    \n    if (pathFlags & PATH_FLAG_NO_CURVES) { if (!read_path_no_curves(buffer, path, pointCount)) error = true; } else if (pathFlags & PATH_FLAG_USES_COMMANDS) { if (!read_path_with_commands(buffer, path, pointCount)) error = true; } else { if (!read_path_curves(buffer, path, pointCount)) error = true; }\n\nThe code for the H path changes from:\n\n    \n    \n    0a 0c 2b b3 da 2b b5 72 30 b5 72 30 b3 da 31 b3 da 31 b7 70 30 b7 70 30 b5 d8 2b b5 d8 2b b7 70 2a b7 70 2a b3 da\n\nTo:\n\n    \n    \n    06 0c 46 44 44 2b b3 da b5 72 30 b3 da 31 b7 70 30 b5 d8 2b b7 70 2a b3 da\n\nIn addition to logically representing the same path (i.e the same end points\nfor a series of line segments), the file with this path changed also looks\nidentical to the original icon. Using the more space-expensive way of storing\nthis path seems like a bug in Icon-O-Matic (a minor one in this case) that I\ncould probably fix since Icon-O-Matic is open-source (like the rest of Haiku),\nbut let\u2019s get back to the substance of this post \u2013 understanding the image\nformat.\n\nNow that you\u2019ve seen a command path, the second path will be easy to\nunderstand. It\u2019s a command path, and the only new feature it uses are curves.\nAll curves in HVIF are cubic curves; each one is defined by three (x,y)\npoints. In the parser code, these are referred to as x, y, x_in, y_in, x_out,\nand y_out. These six values are written in the order I just named them.\n\nThe second path is:\n\n    \n    \n    06 08 de 6e 40 24 28 28 b8 18 b3 6d b4 47 b8 f2 40 2c 54 b5 79 c6 39 ba 16 c9 36 3c 58 50 54 4c 54 c7 3d 54 58 40 24\n\nThe first byte (06; 0000 0110) is the flags: a closed path using commands.\nThis time the zero on the \u201cno curves\u201d flag is correct; this path does have\ncurves. The second byte (08) is the point count; there are 8 points in this\npath. The reason this path takes more bytes despite having 60% the number of\npoints of the previous path is that curves take a lot of bytes (6) to\nrepresent. I never thought I\u2019d say six bytes was a lot.\n\nThe command bytes are de 6e; the segments will match up to the commands in de\n(1101 1110) and then the commands in 6e (0110 1110). The commands within each\nbyte are read right to left. This results in the following commands:\n\nBits| Decimal Value| Meaning  \n---|---|---  \n10| 2| line  \n11| 3| curve  \n01| 1| vertical line  \n11| 3| curve  \n10| 2| line  \n11| 3| curve  \n10| 2| line  \n01| 1| vertical line  \n  \nEditing the first path confirmed the interpretation of the command bytes; this\nis important because if the ordering of commands is wrong but the types are\ncorrect, then the file will look ok, but the rendered result will be\ndifferent. The number of coordinates for each segment type is set, but if they\nare parsed in the wrong order, the coordinates will be grouped differently.\n\nUsing this command listing results in the following understanding of the path:\n\nType| X| Y| Xin| Yin| Xout| Yout  \n---|---|---|---|---|---|---  \nLine| 40| 24  \nCurve| 28| 28| b8 18| b3 6d| b4 47| b8 f2  \nVertical Line| <28>| 40  \nCurve| 2c| 54| b5 79| c6 39| ba 16| c9 36  \nLine| 3c| 58  \nCurve| 50| 54| 4c| 54| c7 3d| 54  \nLine| 58| 40  \nVertical Line| <58>| 24  \n  \nThe <28> and <58> in the table represent the implied values for the vertical\nline segments; being a vertical line means copying the x of the previous\npoint. This path is a weird mix of types since I drew it by hand, with the\ngoal of getting as many line segment types as I could. The final path is\nhorizontal; the shape being closed means that the final point (58, 24) is\nconnected to the first point (40, 24) by a line segment. I intentionally made\nthat segment horizontal, not realizing that it wouldn\u2019t appear as a horizontal\nline segment in the file.\n\n### Shapes\n\nThe shapes section tells you what the renderer will actually draw. Each shape\nhas a style and one or more paths. The space inside the path (or between the\npaths) will be filled with the style. The shapes are ordered back to front, so\nthe first shape you parse will be the bottom-most layer of the image. In the\nlogo I\u2019m dissecting, this means the blob-shape will be first and then H-shape\nwill be second.\n\nThe shapes section starts with a shape count \u2013 02 because there are two shapes\n\u2013 and then jumps straight into the first shape. The bytes for this one are 0a\n01 01 01 00 \u2013 pretty small compared to those paths.\n\nThere is only one type of shape, so both shapes in this file start with 0a,\nthe shape type for SHAPE_TYPE_PATH_SOURCE (another enum). I\u2019m not really sure\nwhat this means, but since there\u2019s only one shape type, it\u2019s pretty\nmeaningless. The next byte of a shape is the style index. The 01 here means\nthis shape is using the second style in this file (it\u2019s indexed from zero);\nthat\u2019s the red-to-blue gradient. The next two bytes (01 01) are the path count\nand a path index; this shape has one path and it\u2019s the second one in the file\n\u2013 the blob-y one. The last byte (00) is the shape flags; none of them are set,\nso I\u2019ll wait for the next shape to discuss what the flags mean, other than\nthat setting any of them would mean we\u2019d have more to read for this shape.\n\nBecause shapes refer to styles (and paths) by one byte, there can only be 256\neach of styles and paths in a single icon/file. (256 is the number of distinct\nvalues you can fit in 8 bits.) This is probably plenty for icons, but not\nenough for all complex vector graphics; being specifically for icons allows\nHVIF to produce smaller files by placing this limitation on complexity.\n\nThe second shape takes up more bytes: 0a 00 01 00 02 44 00 00 00 00 00 00 00\n00 44 47 1c c9 00 00 be 6a aa. The first section is very similar to the first\nshape: the only valid shape type 0a, the first style (flat white), and one\npath \u2013 the first one (H). That\u2019s the first four bytes, so we\u2019re up to the\nshape flags byte \u2013 02. Each bit in the flags byte represents a different\nadditional feature a shape could have.\n\n    \n    \n    SHAPE_FLAG_TRANSFORM = 1 << 1, SHAPE_FLAG_HINTING = 1 << 2, SHAPE_FLAG_LOD_SCALE = 1 << 3, SHAPE_FLAG_HAS_TRANSFORMERS = 1 << 4, SHAPE_FLAG_TRANSLATION = 1 << 5,\n\nSince I\u2019m not giving a full manual on the HVIF format, just looking at one\nexample, I\u2019m going to skip explaining what the other flags mean. The one\nthat\u2019s set in 02 is SHAPE_FLAG_TRANSFORM. This mens that there will be a six-\nvalue matrix that\u2019s used to scale/translate/skew/rotate the path. I\u2019m not\nreally sure, but I think the difference between this flag and\nSHAPE_FLAG_HAS_TRANSFORMERS is that this flag means there\u2019s only one\ntransformation matrix.\n\nThe rest of this shape is six numbers. The numbers in this matrix are 24-bit\nfloats in a format created for HVIF. Icons don\u2019t need the precision of 32-bit\nfloats, so using a smaller format helps save a lot of space. However, I\u2019m not\nsure why 24-bit floats were chosen over 16-bit floats (a more standard\nformat). In any case, here\u2019s the six numbers:\n\nByte1| Byte2| Byte3  \n---|---|---  \n1| 44| 00| 00  \n2| 00| 00| 00  \n3| 00| 00| 00  \n4| 44| 47| 1c  \n5| c9| 00| 00  \n6| be| 6a| aa  \n  \nThis is one of the only parts of the format that\u2019s not variable length \u2013 as\nsoon as you read that the shape flags were 02, you\u2019d know that the next (3\nbytes per float x 6 floats = ) 18 bytes are a transformation matrix.\n\nSince only that one flag bit was set, that\u2019s the end of this shape. This\nmatrix scales the H path up and moves it to the center of the image. I got the\nH by copy-pasting text into Icon-O-Matic, but the shape wasn\u2019t big enough for\nmy taste initially, so I scaled it up.\n\n## Conclusion\n\nI like playing with Haiku; after trying a number of less-popular-than-Linux\noperating systems, it\u2019s the most stable and usable of the ones I tried. It\u2019s\nalso different enough from Linux to have an interesting point of view. This\nvector icon format is just one example of that.\n\nThis vector format is interesting to me because it\u2019s a binary format (I hadn\u2019t\nparsed binary files before), it\u2019s a vector image format (which I haven\u2019t\nlooked at in detail before), it has a clear constraint to optimize around\n(which makes the reasons behind design decisions easier to guess), and it was\ncreated mostly by one person (so it should be simple enough for me to figure\nout). Parsing it by hand made me a lot more comfortable converting between hex\nand binary and thinking about bytes as a collection of bits. Editing the files\nto investigate how command bytes work made me feel super cool \u2013 I edited a\nfile by hand in a hex editor AND IT STILL WORKED! That\u2019s a power I\u2019d\npreviously ascribed only to wizards with a specialty in low-level programming.\n\nI recommend digging into the details of a binary file format with an open-\nsource parser. Having the source code to look at while interpreting the hex\nwas invaluable; it would have been much harder to do this without the code\navailable. Reading about the features of HVIF and then following my curiosity\nabout how exactly those features worked was very satisfying, and I learned new\nskills in the process (even if knowing the details of HVIF has very limited\napplicability).\n\n### Acknowledgements\n\nThanks to Dan Luu for comments on the post and help with the \u201chow slow is\nreading from disk?\u201d calculation, David Turner for catching awkward wording and\nlots of spelling mistakes, Bert Muthalaly for positive comments that make me\nwant to write more posts, and Julia Evans for finding the confusing parts.\nThanks to @davecporter for catching a typo. :)\n\n  1. This is actually my second example file; the first one was too big. I had the entire word \u2018Hello\u2019, which introduces four more paths with many more segments. In the file I constructed next, I made sure to keep things to two styles and two paths, while covering as much of the feature space as I could. One style is a flat color and the other is a gradient; the colors (e.g. fully saturated blue) were chosen to be easy to check while hand parsing the hex. One path is all straight lines (H) and the other has a mix of curves and lines (to ensure it would be encoded as a command path). The reason I used letter paths is because you can paste text into Icon-O-Matic and it just automatically makes paths for you \u2013 i.e. it\u2019s the easiest way to make paths. \u21a9\ufe0e\n\nShareThis Copy and Paste\n\n", "frontpage": false}
