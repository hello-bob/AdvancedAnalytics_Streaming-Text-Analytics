{"aid": "40058761", "title": "Write once, run forever: The power of Bash scripts", "url": "https://opensource.com/article/19/12/automation-bash-scripts", "domain": "opensource.com", "votes": 3, "user": "billybuckwheat", "posted_at": "2024-04-16 23:45:19", "comments": 0, "source_title": "Introduction to automation with Bash scripts", "source_text": "Introduction to automation with Bash scripts | Opensource.com\n\nSkip to main content\n\n# Introduction to automation with Bash scripts\n\nIn the first article in this four-part series, learn how to create a simple\nshell script and why they are the best way to automate tasks.\n\nBy\n\nDavid Both (Correspondent)\n\nDecember 18, 2019 | 0 Comments | %t min read\n\nSysadmins, those of us who run and manage Linux computers most closely, have\ndirect access to tools that help us work more efficiently. To help you use\nthese tools to their maximum benefit to make your life easier, this series of\narticles explores using automation in the form of Bash shell scripts. It\ncovers:\n\n  * The advantages of automation with Bash shell scripts\n  * Why using shell scripts is a better choice for sysadmins than compiled languages like C or C++\n  * Creating a set of requirements for new scripts\n  * Creating simple Bash shell scripts from command-line interface (CLI) programs\n  * Enhancing security through using the user ID (UID) running the script\n  * Using logical comparison tools to provide execution flow control for command-line programs and scripts\n  * Using command-line options to control script functionality\n  * Creating Bash functions that can be called from one or more locations within a script\n  * Why and how to license your code as open source\n  * Creating and implementing a simple test plan\n\nI previously wrote a series of articles about Bash commands and syntax and\ncreating Bash programs at the command line, which you can find in the\nreferences section at the end of this article. But this series of four\narticles is as much about creating scripts (and some techniques that I find\nuseful) as it is about Bash commands and syntax.\n\n## Why I use shell scripts\n\nIn Chapter 9 of The Linux Philosophy for Sysadmins, I write:\n\n> \"A sysadmin is most productive when thinking\u2014thinking about how to solve\n> existing problems and about how to avoid future problems; thinking about how\n> to monitor Linux computers in order to find clues that anticipate and\n> foreshadow those future problems; thinking about how to make [their] job\n> more efficient; thinking about how to automate all of those tasks that need\n> to be performed whether every day or once a year.\n>\n> \"Sysadmins are next most productive when creating the shell programs that\n> automate the solutions that they have conceived while appearing to be\n> unproductive. The more automation we have in place, the more time we have\n> available to fix real problems when they occur and to contemplate how to\n> automate even more than we already have.\"\n\nThis first article explores why shell scripts are an important tool for the\nsysadmin and the basics of creating a very simple Bash script.\n\n## Why automate?\n\nHave you ever performed a long and complex task at the command line and\nthought, \"Glad that's done. Now I never have to worry about it again!\"? I\nhave\u2014frequently. I ultimately figured out that almost everything that I ever\nneed to do on a computer (whether mine or one that belongs to an employer or a\nconsulting customer) will need to be done again sometime in the future.\n\nSkip to content\n\nMore on Bash\n\n  * Bash cheat sheet\n  * An introduction to programming with Bash\n  * A sysadmin's guide to Bash scripting\n  * Latest Bash articles\n\nOf course, I always think that I will remember how I did the task. But, often,\nthe next time is far enough into the future that I forget that I have ever\ndone it, let alone how to do it. I started writing down the steps required for\nsome tasks on bits of paper, then thought, \"How stupid of me!\" So I\ntransferred those scribbles to a simple notepad application on my computer,\nuntil one day, I thought again, \"How stupid of me!\" If I am going to store\nthis data on my computer, I might as well create a shell script and store it\nin a standard location, like /usr/local/bin or ~/bin, so I can just type the\nname of the shell program and let it do all the tasks I used to do manually.\n\nFor me, automation also means that I don't have to remember or recreate the\ndetails of how I performed the task in order to do it again. It takes time to\nremember how to do things and time to type in all the commands. This can\nbecome a significant time sink for tasks that require typing large numbers of\nlong commands. Automating tasks by creating shell scripts reduces the typing\nnecessary to perform routine tasks.\n\n## Shell scripts\n\nWriting shell programs\u2014also known as scripts\u2014is the best strategy for\nleveraging my time. Once I write a shell program, I can rerun it as many times\nas I need to. I can also update my shell scripts to compensate for changes\nfrom one release of Linux to the next, installing new hardware and software,\nchanging what I want or need to accomplish with the script, adding new\nfunctions, removing functions that are no longer needed, and fixing the not-\nso-rare bugs in my scripts. These kinds of changes are just part of the\nmaintenance cycle for any type of code.\n\nEvery task performed via the keyboard in a terminal session by entering and\nexecuting shell commands can and should be automated. Sysadmins should\nautomate everything we are asked to do or decide needs to be done. Many times,\ndoing the automation upfront saves me time the first time.\n\nOne Bash script can contain anywhere from a few commands to many thousands. I\nhave written Bash scripts with only one or two commands, and I have written a\nscript with over 2,700 lines, more than half of which are comments.\n\n## Getting started\n\nHere's a trivial example of a shell script and how to create it. In my earlier\nseries on Bash command-line programming, I used the example from every book on\nprogramming I have ever read: \"Hello world.\" From the command line, it looks\nlike this:\n\n    \n    \n    [student@testvm1 ~]$ echo \"Hello world\" Hello world\n\nBy definition, a program or shell script is a sequence of instructions for the\ncomputer to execute. But typing them into the command line every time is quite\ntedious, especially when the programs are long and complex. Storing them in a\nfile that can be executed with a single command saves time and reduces the\npossibility for errors to creep in.\n\nI recommend trying the following examples as a non-root user on a test system\nor virtual machine (VM). Although the examples are harmless, mistakes do\nhappen, and being safe is always wise.\n\nThe first task is to create a file to contain your program. Use the touch\ncommand to create the empty file, hello, then make it executable:\n\n    \n    \n    [student@testvm1 ~]$ touch hello [student@testvm1 ~]$ chmod 774 hello\n\nNow, use your favorite editor to add the following line to the file:\n\n    \n    \n    echo \"Hello world\"\n\nSave the file and run it from the command line. You can use a separate shell\nsession to execute the scripts in this series:\n\n    \n    \n    [student@testvm1 ~]$ ./hello Hello world!\n\nThis is the simplest Bash program you may ever create\u2014a single statement in a\nfile. For this exercise, your complete shell script will be built around this\nsimple Bash statement. The function of the program is irrelevant for this\npurpose, and this simple statement allows you to build a program structure\u2014a\ntemplate for other programs\u2014without being concerned about the logic of a\nfunctional purpose. You can concentrate on the basic program structure and\ncreating your template in a very simple way, and you can create and test the\ntemplate itself rather than a complex functional program.\n\n## Shebang\n\nThe single statement works fine as long as you use Bash or a shell compatible\nwith the commands used in the script. If no shell is specified in the script,\nthe default shell will be used to execute the script commands.\n\nThe next task is to ensure that the script will run using the Bash shell, even\nif another shell is the default. This is accomplished with the shebang line.\nShebang is the geeky way to describe the #! characters that explicitly specify\nwhich shell to use when running the script. In this case, that is Bash, but it\ncould be any other shell. If the specified shell is not installed, the script\nwill not run.\n\nAdd the shebang line as the first line of the script, so now it looks like\nthis:\n\n    \n    \n    #!/usr/bin/bash echo \"Hello world!\"\n\nRun the script again\u2014you should see no difference in the result. If you have\nother shells installed (such as ksh, csh, tcsh, zsh, etc.), start one and run\nthe script again.\n\n## Scripts vs. compiled programs\n\nWhen writing programs to automate\u2014well, everything\u2014sysadmins should always use\nshell scripts. Because shell scripts are stored in ASCII text format, they can\nbe viewed and modified by humans just as easily as they can by computers. You\ncan examine a shell program and see exactly what it does and whether there are\nany obvious errors in the syntax or logic. This is a powerful example of what\nit means to be open.\n\nI know some developers consider shell scripts something less than \"true\"\nprogramming. This marginalization of shell scripts and those who write them\nseems to be predicated on the idea that the only \"true\" programming language\nis one that must be compiled from source code to produce executable code. I\ncan tell you from experience that this is categorically untrue.\n\nI have used many languages, including BASIC, C, C++, Pascal, Perl, Tcl/Expect,\nREXX (and some of its variations, including Object REXX), many shell languages\n(including Korn, csh and Bash), and even some assembly language. Every\ncomputer language ever devised has had one purpose: to allow humans to tell\ncomputers what to do. When you write a program, regardless of the language you\nchoose, you are giving the computer instructions to perform specific tasks in\na specific sequence.\n\nScripts can be written and tested far more quickly than compiled languages.\nPrograms usually must be written quickly to meet time constraints imposed by\ncircumstances or the pointy-haired boss. Most scripts that sysadmins write are\nto fix a problem, to clean up the aftermath of a problem, or to deliver a\nprogram that must be operational long before a compiled program could be\nwritten and tested.\n\nWriting a program quickly requires shell programming because it enables a\nquick response to the needs of the customer\u2014whether that is you or someone\nelse. If there are problems with the logic or bugs in the code, they can be\ncorrected and retested almost immediately. If the original set of requirements\nis flawed or incomplete, shell scripts can be altered very quickly to meet the\nnew requirements. In general, the need for speed of development in the\nsysadmin's job overrides the need to make the program run as fast as possible\nor to use as little as possible in the way of system resources like RAM.\n\nMost things sysadmins do take longer to figure out how to do than to execute.\nThus, it might seem counterproductive to create shell scripts for everything\nyou do. It takes some time to write the scripts and make them into tools that\nproduce reproducible results and can be used as many times as necessary. The\ntime savings come every time you can run the script without having to figure\nout (again) how to do the task.\n\n## Final thoughts\n\nThis article didn't get very far with creating a shell script, but it did\ncreate a very small one. It also explored the reasons for creating shell\nscripts and why they are the most efficient option for the system\nadministrator (rather than compiled programs).\n\nIn the next article, you will begin creating a Bash script template that can\nbe used as a starting point for other Bash scripts. The template will\nultimately contain a Help facility, a GNU licensing statement, a number of\nsimple functions, and some logic to deal with those options, as well as others\nthat might be needed for the scripts that will be based on this template.\n\n## Resources\n\n  * How to program with Bash: Syntax and tools\n  * How to program with Bash: Logical operators and shell expansions\n  * How to program with Bash: Loops\n\nThis series of articles is partially based on Volume 2, Chapter 10 of David\nBoth's three-part Linux self-study course, Using and Administering Linux\u2014Zero\nto SysAdmin.\n\nWhat to read next\n\n## Generate random passwords with this Bash script\n\nTake the hassle out of picking passwords with this simple Bash script.\n\nGreg Pittman\n\nNovember 19, 2019\n\n## How to program with Bash: Syntax and tools\n\nLearn basic Bash programming syntax and tools, as well as how to use variables\nand control operators, in the first article in this three-part series.\n\nDavid Both\n\n(Correspondent)\n\nOctober 21, 2019\n\n## 3 command line games for learning Bash the fun way\n\nLearning useful Bash skills can be fun with these command line games.\n\nSeth Kenlon\n\n(Team, Red Hat)\n\nOctober 2, 2019\n\nTags\n\nBash\n\nAutomation\n\nDavid Both\n\nDavid Both is an Open Source Software and GNU/Linux advocate, trainer, writer,\nand speaker. He has been working with Linux and Open Source Software since\n1996 and with computers since 1969. He is a strong proponent of and evangelist\nfor the \"Linux Philosophy for System Administrators.\"\n\nMore about me\n\n## Comments are closed.\n\nThese comments are closed.\n\n## Related Content\n\nMake a web-safe color guide with Bash\n\nHow I configure Vim as my default editor on Linux\n\nHow I dynamically generate Jekyll config files\n\nThis work is licensed under a Creative Commons Attribution-Share Alike 4.0\nInternational License.\n\n## About This Site\n\nThe opinions expressed on this website are those of each author, not of the\nauthor's employer or of Red Hat.\n\nOpensource.com aspires to publish all content under a Creative Commons license\nbut may not be able to do so in all cases. You are responsible for ensuring\nthat you have the necessary permission to reuse any work on this site. Red Hat\nand the Red Hat logo are trademarks of Red Hat, Inc., registered in the United\nStates and other countries.\n\nA note on advertising: Opensource.com does not sell advertising on the site or\nin any of its newsletters.\n\nCopyright \u00a92024 Red Hat, Inc.\n\n", "frontpage": false}
