{"aid": "40096176", "title": "Zig 0.12.0 Release Notes", "url": "https://ziglang.org/download/0.12.0/release-notes.html", "domain": "ziglang.org", "votes": 6, "user": "GalaxySnail", "posted_at": "2024-04-20 10:09:23", "comments": 0, "source_title": "0.12.0 Release Notes \u26a1 The Zig Programming Language", "source_text": "0.12.0 Release Notes \u26a1 The Zig Programming Language\n\n# 0.12.0 Release Notes\n\nDownload & Documentation\n\nZig is a general-purpose programming language and toolchain for maintaining\nrobust, optimal, and reusable software.\n\nZig development is funded via Zig Software Foundation, a 501(c)(3) non-profit\norganization. Please consider a recurring donation so that we can offer more\nbillable hours to our core team members. This is the most straightforward way\nto accelerate the project along the Roadmap to 1.0.\n\nThis release features 8 months of work: changes from 268 different\ncontributors, spread among 3688 commits.\n\nIn the past, these release notes have been extremely long, attempting to take\nnote of all enhancements that occurred during the release cycle. In the\ninterest of not overwhelming the reader as well as the maintainers creating\nthese notes, this document is abridged. Many changes, including API breaking\nchanges, are not mentioned here.\n\n## Table of Contents \u00a7\n\n  * Table of Contents\n  * Support Table\n\n    * Tier System\n\n      * Tier 1 Support\n      * Tier 2 Support\n      * Tier 3 Support\n      * Tier 4 Support\n  * Redesign How Autodoc Works\n\n    * Installed Standard Library Documentation\n    * Time to Generate Documentation\n    * New Autodoc Features\n\n      * Reliable Linkification\n      * Interactive Source Listings\n      * Embedded Source Listings\n      * Search Includes Doc Comments\n      * Error Set View\n      * Correct Type Detection\n      * Correct Implementation of Scroll History\n  * Language Changes\n\n    * Unnecessary Use of var\n    * Result Location Semantics\n    * Aggregate Destructuring\n    * Namespace Type Equivalence\n    * Comptime Memory Changes\n    * @fieldParentPtr\n    * Disallow alignment on function type\n    * @errorCast\n    * @abs\n  * Standard Library\n\n    * Windows Command Line Argument Parsing\n    * Bring-Your-Own-OS API Layer Regressed\n    * std.os renamed to std.posix\n    * Ryu Floating-Point Formatting\n    * Reworked HTTP\n\n      * Removal of std.http.Headers\n      * Rework Server Entirely\n    * deflate reimplemented from first principles\n    * std.posix APIs Gain Type Safety\n    * std.builtin Enum Fields Lowercased\n    * Global Configuration\n    * Pointer Stability Locks\n  * Build System\n\n    * System Package Mode\n\n      * Ability to Declare Optional System Library Integration\n      * System Integration Help Section\n      * Using the System Integration Options\n      * New Release Option\n      * Avoid Fetching in System Mode\n    * Lazy Dependencies\n    * introduce b.path; deprecate LazyPath.relative\n    * Header Installation\n    * dependencyFromBuildZig\n  * Compiler\n\n    * x86 Backend\n  * Windows Resources\n  * Linker\n  * Cache System\n  * Bug Fixes\n\n    * Comptime Pointer Access\n    * This Release Contains Bugs\n  * Toolchain\n\n    * LLVM 17\n    * musl 1.2.4\n    * glibc 2.38\n    * mingw-w64\n  * Roadmap\n\n    * Async/Await Feature Status\n  * Thank You Contributors!\n  * Thank You Sponsors!\n\n## Support Table \u00a7\n\n### Tier System \u00a7\n\nA green check mark (\u2705) indicates the target meets all the requirements for the\nsupport tier. The other icons indicate what is preventing the target from\nreaching the support tier. In other words, the icons are to-do items. If you\nfind any wrong data here please submit a pull request!\n\n#### Tier 1 Support \u00a7\n\n  * Not only can Zig generate machine code for these targets, but the Standard Library cross-platform abstractions have implementations for these targets.\n  * The CI server automatically tests these targets on every commit to master branch. The \ud83e\uddea icon means this target does not yet have CI test coverage.\n  * The CI server automatically produces pre-built binaries for these targets, on every commit to master, and updates the download page with links. The \ud83d\udce6 icon means the download page is missing this target.\n  * These targets have debug info capabilities and therefore produce stack traces on failed assertions.\n  * libc is available for this target even when cross compiling.\n  * All the behavior tests and applicable standard library tests pass for this target. All language features are known to work correctly. Experimental features do not count towards disqualifying an operating system or architecture from Tier 1. The \ud83d\udc1b icon means there are known bugs preventing this target from reaching Tier 1.\n  * zig cc, zig c++, and related toolchain commands support this target.\n  * If the Operating System is proprietary then the target is not marked deprecated by the vendor. The \ud83d\udc80 icon means the OS is officially deprecated, such as macos/x86.\n\nfreestanding| Linux 3.16+| macOS 11+| Windows 10+| WASI  \n---|---|---|---|---  \nx86_64| \u2705| \u2705| \u2705| \u2705| N/A  \nx86| \u2705| #1929 \ud83d\udc1b| \ud83d\udc80| #537 \ud83d\udc1b| N/A  \naarch64| \u2705| #2443 \ud83d\udc1b| \u2705| #16665 \ud83d\udc1b| N/A  \narm| \u2705| #3174 \ud83d\udc1b| \ud83d\udc80| \ud83d\udc1b\ud83d\udce6\ud83e\uddea| N/A  \nmips| \u2705| #3345 \ud83d\udc1b\ud83d\udce6| N/A| N/A| N/A  \nriscv64| \u2705| #4456 \ud83d\udc1b| N/A| N/A| N/A  \nsparc64| \u2705| #4931 \ud83d\udc1b\ud83d\udce6\ud83e\uddea| N/A| N/A| N/A  \npowerpc64| \u2705| \ud83d\udc1b| N/A| N/A| N/A  \npowerpc| \u2705| \ud83d\udc1b| N/A| N/A| N/A  \nwasm32| \u2705| N/A| N/A| N/A| \u2705  \n  \n#### Tier 2 Support \u00a7\n\n  * The Standard Library supports this target, but it is possible that some APIs will give an \"Unsupported OS\" compile error. One can link with libc or other libraries to fill in the gaps in the standard library. The \ud83d\udcd6 icon means the standard library is too incomplete to be considered Tier 2 worthy.\n  * These targets are known to work, but may not be automatically tested, so there are occasional regressions. \ud83d\udd0d means that nobody has really looked into this target so whether or not it works is unknown.\n  * Some tests may be disabled for these targets as we work toward Tier 1 Support.\n\nfree standing| Linux 3.16+| macOS 11+| Windows 10+| FreeBSD 12.0+| NetBSD\n8.0+| Dragon FlyBSD 5.8+| OpenBSD 7.3+| UEFI  \n---|---|---|---|---|---|---|---|---  \nx86_64| Tier 1| Tier 1| Tier 1| Tier 1| \u2705| \u2705| \u2705| \u2705| \u2705  \nx86| Tier 1| \u2705| \ud83d\udc80| \u2705| \ud83d\udd0d| \ud83d\udd0d| N/A| \ud83d\udd0d| \u2705  \naarch64| Tier 1| \u2705| Tier 1| \u2705| \ud83d\udd0d| \ud83d\udd0d| N/A| \ud83d\udd0d| \ud83d\udd0d  \narm| Tier 1| \u2705| \ud83d\udc80| \ud83d\udd0d| \ud83d\udd0d| \ud83d\udd0d| N/A| \ud83d\udd0d| \ud83d\udd0d  \nmips64| \u2705| \u2705| N/A| N/A| \ud83d\udd0d| \ud83d\udd0d| N/A| \ud83d\udd0d| N/A  \nmips| Tier 1| \u2705| N/A| N/A| \ud83d\udd0d| \ud83d\udd0d| N/A| \ud83d\udd0d| N/A  \npowerpc64| Tier 1| \u2705| \ud83d\udc80| N/A| \ud83d\udd0d| \ud83d\udd0d| N/A| \ud83d\udd0d| N/A  \npowerpc| Tier 1| \u2705| \ud83d\udc80| N/A| \ud83d\udd0d| \ud83d\udd0d| N/A| \ud83d\udd0d| N/A  \nriscv64| Tier 1| \u2705| N/A| N/A| \ud83d\udd0d| \ud83d\udd0d| N/A| \ud83d\udd0d| \ud83d\udd0d  \nsparc64| Tier 1| \u2705| N/A| N/A| \ud83d\udd0d| \ud83d\udd0d| N/A| \ud83d\udd0d| N/A  \n  \n#### Tier 3 Support \u00a7\n\n  * The standard library has little to no knowledge of the existence of this target.\n  * If this target is provided by LLVM, LLVM has the target enabled by default.\n  * These targets are not frequently tested; one will likely need to contribute to Zig in order to build for these targets.\n  * The Zig compiler might need to be updated with a few things such as\n\n    * what sizes are the C integer types\n    * C ABI calling convention for this target\n    * start code and default panic handler\n  * zig targets is guaranteed to include this target.\n\nfreestanding| Linux 3.16+| Windows 10+| FreeBSD 12.0+| NetBSD 8.0+| UEFI  \n---|---|---|---|---|---  \nx86_64| Tier 1| Tier 1| Tier 1| Tier 2| Tier 2| Tier 2  \nx86| Tier 1| Tier 2| Tier 2| \u2705| \u2705| Tier 2  \naarch64| Tier 1| Tier 2| Tier 2| \u2705| \u2705| \u2705  \narm| Tier 1| Tier 2| \u2705| \u2705| \u2705| \u2705  \nmips64| Tier 2| Tier 2| N/A| \u2705| \u2705| N/A  \nmips| Tier 1| Tier 2| N/A| \u2705| \u2705| N/A  \nriscv64| Tier 1| Tier 2| N/A| \u2705| \u2705| \u2705  \npowerpc32| Tier 2| Tier 2| N/A| \u2705| \u2705| N/A  \npowerpc64| Tier 2| Tier 2| N/A| \u2705| \u2705| N/A  \nbpf| \u2705| \u2705| N/A| \u2705| \u2705| N/A  \nhexagon| \u2705| \u2705| N/A| \u2705| \u2705| N/A  \namdgcn| \u2705| \u2705| N/A| \u2705| \u2705| N/A  \nsparc| \u2705| \u2705| N/A| \u2705| \u2705| N/A  \ns390x| \u2705| \u2705| N/A| \u2705| \u2705| N/A  \nlanai| \u2705| \u2705| N/A| \u2705| \u2705| N/A  \ncsky| \u2705| \u2705| N/A| \u2705| \u2705| N/A  \nfreestanding| emscripten  \n---|---  \nwasm32| Tier 1| \u2705  \n  \n#### Tier 4 Support \u00a7\n\n  * Support for these targets is entirely experimental.\n  * If this target is provided by LLVM, LLVM may have the target as an experimental target, which means that you need to use Zig-provided binaries for the target to be available, or build LLVM from source with special configure flags. zig targets will display the target if it is available.\n  * This target may be considered deprecated by an official party, in which case this target will remain forever stuck in Tier 4.\n  * This target may only support -femit-asm and cannot emit object files, in which case -fno-emit-bin is enabled by default and cannot be overridden.\n\nTier 4 targets:\n\n  * avr\n  * riscv32\n  * xcore\n  * nvptx\n  * msp430\n  * r600\n  * arc\n  * tce\n  * le\n  * amdil\n  * hsail\n  * spir\n  * kalimba\n  * shave\n  * renderscript\n  * 32-bit x86 macOS, 32-bit ARM macOS, powerpc32 and powerpc64 macOS, because Apple has officially dropped support for them.\n\n## Redesign How Autodoc Works \u00a7\n\nThis release deletes the previous (experimental) Autodoc implementation and\nreplaces it with a new (not experimental!) one.\n\nThe old implementation looked like this:\n\n    \n    \n    5987 src/Autodoc.zig 435 src/autodoc/render_source.zig 10270 lib/docs/commonmark.js 1245 lib/docs/index.html 5242 lib/docs/main.js 2146 lib/docs/ziglexer.js 25325 total\n\nAfter compilation (sizes are for standard library documentation):\n\n    \n    \n    272K commonmark.js 3.8M data-astNodes.js 360K data-calls.js 767K data-comptimeExprs.js 2.2M data-decls.js 896K data-exprs.js 13K data-files.js 45 data-guideSections.js 129 data-modules.js 15 data-rootMod.js 294 data-typeKinds.js 3.2M data-types.js 38K index.html 158K main.js 36M src/ (470 .zig.html files) 78K ziglexer.js\n\nTotal output size: 47M (5.7M gzipped)\n\nsrc/Autodoc.zig processed ZIR code, outputting JSON data for a web application\nto consume. This resulted in a lot of code ineffectively trying to reconstruct\nthe AST from no-longer-available data.\n\nlib/docs/commonmark.js was a third-party markdown implementation that\nsupported too many features; for example I do not want it to be possible to\nhave HTML tags in doc comments, because that would make source code uglier.\nOnly markdown that looks good both as source and rendered should be allowed.\n\nlib/docs/ziglexer.js was an implementation of Zig language tokenization in\nJavaScript, despite Zig already exposing its own tokenizer in the standard\nlibrary. When I saw this added to the zig project, a little part of me died\ninside.\n\nsrc/autodoc/render_source.zig was a tool that converted .zig files to a\nsyntax-highlighted but non-interactive .zig.html files.\n\nThe new implementation looks like this:\n\n    \n    \n    942 lib/docs/main.js 403 lib/docs/index.html 933 lib/docs/wasm/markdown.zig 226 lib/docs/wasm/Decl.zig 1500 lib/docs/wasm/markdown/Parser.zig 254 lib/docs/wasm/markdown/renderer.zig 192 lib/docs/wasm/markdown/Document.zig 941 lib/docs/wasm/main.zig 1038 lib/docs/wasm/Walk.zig 6630 total\n\nAfter compilation (sizes are for standard library documentation):\n\n    \n    \n    12K index.html 32K main.js 192K main.wasm 12M sources.tar\n\nTotal output size: 12M (2.3M gzipped)\n\nAs you can see, it is both dramatically simpler in terms of implementation as\nwell as build artifacts. Now there are exactly 4 files instead of many, with a\n4x reduction in total file size of the generated web app.\n\nHowever, not only is it simpler, it is actually more powerful than the old\nsystem, because instead of processing ZIR, this system processes the source\nfiles directly, meaning it has 100% of the information and never needs to\npiece anything together backwards.\n\nThis strategy uses a WebAssembly module written in Zig. This allows it to\nreuse components from the compiler, such as the tokenizer, parser, and other\nutilities for operating on Zig code.\n\nThe sources.tar file, after being decompressed by the HTTP layer, is fed\ndirectly into the wasm module's memory. The tar file is parsed using std.tar\nand source files are parsed in place, with some additional computations added\nto hash tables on the side.\n\nThere is room for introducing worker threads to speed up the parsing, although\nsingle-threaded it is already so fast that it does not seem necessary.\n\n### Installed Standard Library Documentation \u00a7\n\nIn Zig 0.11.0, a Zig installation comes with a docs/std/ directory that\ncontains those 47M of output artifacts mentioned above.\n\nThis rewrite removed those artifacts from Zig installations, instead offering\nthe zig std command, which hosts std lib autodocs and spawns a browser window\nto view them. When this command is activated, lib/compiler/std-docs.zig is\ncompiled from source to perform this operation.\n\nThe HTTP server creates the requested files on the fly, including rebuilding\nmain.wasm if any of its source files changed, and constructing sources.tar,\nmeaning that any source changes to the documented files, or to the autodoc\nsystem itself are immediately reflected when viewing docs. Prefixing the URL\nwith /debug results in a debug build of the WebAssembly module.\n\nThis means contributors can test changes to Zig standard library\ndocumentation, as well as autodocs functionality, by pressing refresh in their\nbrowser window, using a only binary distribution of Zig.\n\nIn total, this reduced the Zig installation size from 317M to 268M (-15%).\n\nA ReleaseSmall build of the compiler shrinks from 10M to 9.8M (-1%).\n\n### Time to Generate Documentation \u00a7\n\nAutodocs generation is now done properly as part of the pipeline of the\ncompiler rather than tacked on at the end. It also no longer has any\ndependencies on other parts of the pipeline.\n\nThis is how long it now takes to generate standard library documentation:\n\n    \n    \n    Benchmark 1 (3 runs): old/zig test /home/andy/dev/zig/lib/std/std.zig -fno-emit-bin -femit-docs=docs measurement mean \u00b1 \u03c3 min ... max outliers delta wall_time 13.3s \u00b1 405ms 12.8s ... 13.6s 0 ( 0%) 0% peak_rss 1.08GB \u00b1 463KB 1.08GB ... 1.08GB 0 ( 0%) 0% cpu_cycles 54.8G \u00b1 878M 54.3G ... 55.8G 0 ( 0%) 0% instructions 106G \u00b1 313K 106G ... 106G 0 ( 0%) 0% cache_references 2.11G \u00b1 35.4M 2.07G ... 2.14G 0 ( 0%) 0% cache_misses 41.3M \u00b1 455K 40.8M ... 41.7M 0 ( 0%) 0% branch_misses 116M \u00b1 67.8K 116M ... 116M 0 ( 0%) 0% Benchmark 2 (197 runs): new/zig build-obj -fno-emit-bin -femit-docs=docs ../lib/std/std.zig measurement mean \u00b1 \u03c3 min ... max outliers delta wall_time 24.6ms \u00b1 1.03ms 22.8ms ... 28.3ms 4 ( 2%) \u26a1- 99.8% \u00b1 0.3% peak_rss 87.3MB \u00b1 60.6KB 87.2MB ... 87.4MB 0 ( 0%) \u26a1- 91.9% \u00b1 0.0% cpu_cycles 38.4M \u00b1 903K 37.4M ... 46.1M 13 ( 7%) \u26a1- 99.9% \u00b1 0.2% instructions 39.7M \u00b1 12.4K 39.7M ... 39.8M 0 ( 0%) \u26a1-100.0% \u00b1 0.0% cache_references 2.65M \u00b1 89.1K 2.54M ... 3.43M 3 ( 2%) \u26a1- 99.9% \u00b1 0.2% cache_misses 197K \u00b1 5.71K 186K ... 209K 0 ( 0%) \u26a1- 99.5% \u00b1 0.1% branch_misses 184K \u00b1 1.97K 178K ... 190K 6 ( 3%) \u26a1- 99.8% \u00b1 0.0%\n\nIt used to take upwards of 13 seconds. Now it takes 25ms.\n\n### New Autodoc Features \u00a7\n\n#### Reliable Linkification \u00a7\n\nThis stems from the fact that with full source files we have all the\ninformation, and can write more robust code to look up identifiers from the\ncontext they occur in.\n\n#### Interactive Source Listings \u00a7\n\nPress u to go to source code for any declaration:\n\nThe links take you to the API page for that specific link by changing the\nlocation hash.\n\n#### Embedded Source Listings \u00a7\n\n#### Search Includes Doc Comments \u00a7\n\n#### Error Set View \u00a7\n\nMerged error sets are detected:\n\nErrors that come from other declarations are linked:\n\nErrors are also shown on function view:\n\n#### Correct Type Detection \u00a7\n\nPrevious implementation guesses wrong on the type of options as well as\nDynLib.\n\n#### Correct Implementation of Scroll History \u00a7\n\nThe previous implementation implemented scroll history in JavaScript, which is\nimpossible to do correctly. The new system makes careful use of the 'popstate'\nevent combined with the history API to scroll to the top of the window only\nwhen the user navigates to a new link - respecting the browser's saved scroll\nhistory in all other cases.\n\nFor more details see the commit diff.\n\n## Language Changes \u00a7\n\n### Unnecessary Use of var \u00a7\n\nZig 0.12.0 introduces a new compile error which is emitted when a local\nvariable is declared as a var, but the compiler can infer that const would\nsuffice.\n\nunnecessary_var.zig\n\n    \n    \n    const expectEqual = @import(\"std\").testing.expectEqual; test \"unnecessary use of var\" { var x: u32 = 123; try expectEqual(123, x); }\n\nShell\n\n    \n    \n    $ zig test unnecessary_var.zig docgen_tmp/unnecessary_var.zig:3:9: error: local variable is never mutated var x: u32 = 123; ^ docgen_tmp/unnecessary_var.zig:3:9: note: consider using 'const'\n\nAs indicated by the error message, the solution is simple: use const instead\nwhere applicable.\n\n### Result Location Semantics \u00a7\n\nZig 0.12.0 contains several enhancements to Result Location Semantics (RLS).\n\nThis release implements forwarding of result types through the address-of\noperator (&). This allows syntactic constructs which rely on result types,\nsuch as anonymous initializations .{ ... } and casting builtins like @intCast,\nto function correctly in the presence of the address-of operator:\n\naddress_of_rls.zig\n\n    \n    \n    const S = struct { x: u32 }; const int: u64 = 123; const val: *const S = &.{ .x = @intCast(int) }; comptime { _ = val; }\n\nShell\n\n    \n    \n    $ zig test address_of_rls.zig All 0 tests passed.\n\nIn addition, Zig 0.12.0 removes the ability for result locations to propagate\nthrough @as and explicitly-typed aggregate initializations T{ ... }. This\nrestriction is in place to simplify the language design: previous releases\ncontained several bugs relating to incorrect casting of result pointers.\n\n### Aggregate Destructuring \u00a7\n\nZig 0.12.0 introduces a new syntax to allow destructuring indexable\naggregates: that is, tuples, vectors, and arrays. Writing a sequence of\nlvalues or local variable declarations on the left-hand side of the assignment\nwill attempt to destructure the value specified on the right-hand side:\n\ndestructure.zig\n\n    \n    \n    const std = @import(\"std\"); const assert = std.debug.assert; const expectEqual = std.testing.expectEqual; test \"destructure array\" { var z: u32 = undefined; const x, var y, z = [3]u32{ 1, 2, 3 }; y += 10; try expectEqual(1, x); try expectEqual(12, y); try expectEqual(3, z); } test \"destructure vector\" { // Comptime-known values are propagated as you would expect. const x, const y = @Vector(2, u32){ 1, 2 }; comptime assert(x == 1); comptime assert(y == 2); } test \"destructure tuple\" { var runtime: u32 = undefined; runtime = 123; const x, const y = .{ 42, runtime }; // The first tuple field is a `comptime` field, so `x` is comptime-known even // though `y` is runtime-known. comptime assert(x == 42); try expectEqual(123, y); }\n\nShell\n\n    \n    \n    $ zig test destructure.zig 1/3 destructure.test.destructure array... OK 2/3 destructure.test.destructure vector... OK 3/3 destructure.test.destructure tuple... OK All 3 tests passed.\n\nSlices cannot be directly destructured. To destructure values from a slice,\nconvert it to an array by slicing with comptime-known bounds, such as\nslice[0..3].*.\n\n### Namespace Type Equivalence \u00a7\n\nIn Zig, struct, enum, union, and opaque types are special. They do not use\nstructural equivalence, like tuples and arrays do; instead, they create\ndistinct types. These types have namespaces, and thus may contain\ndeclarations. For this reason, they can be referred to collectively as\n\"namespace types\".\n\nIn 0.11.0, every time a declaration of such a type was semantically analyzed,\na new type was created. Equivalence of generic types was handled via\nmemoization of comptime function calls; i.e. std.ArrayList(u8) ==\nstd.ArrayList(u8) held because the ArrayList function was only called once,\nand its results memoized.\n\nIn 0.12.0, this has changed. Namespace types are now deduplicated based on two\nfactors: their source location, and their captures.\n\nThe \"captures\" of a type refers to the set of comptime-known types and values\nwhich it closes over. In other words, it is the set of values referenced\nwithin the type but declared outside of it. For instance, the comptime T: type\nparameter of std.ArrayList is captured by the type it returns. If two\nnamespace types are declared by the same piece of code and have the same\ncaptures, they are now considered to be precisely the same type.\n\nNote that the compiler will still memoize comptime calls: that hasn't changed.\nHowever, this memoization no longer has a meaningful impact on language\nsemantics.\n\nIt is unlikely that this change will cause breakage in existing code. The most\nlikely scenario where it could is something like the following:\n\nopaque_generator.zig\n\n    \n    \n    fn MakeOpaque(comptime n: comptime_int) type { _ = n; return opaque {}; } const A = MakeOpaque(0); const B = MakeOpaque(1);\n\nIn Zig 0.11.0, this code would create two distinct types, because the calls to\nMakeOpaque are distinct and thus the opaque declaration was analyzed\nseparately for each call. In Zig 0.12.0, these types are identical (A == B),\nbecause while the function is called twice, the declaration does not capture\nany value.\n\nThis code can be fixed by forcing the type declaration to capture n:\n\nopaque_generator.zig\n\n    \n    \n    fn MakeOpaque(comptime n: comptime_int) type { return opaque { comptime { _ = n; } }; } const A = MakeOpaque(0); const B = MakeOpaque(1);\n\nSince n is referenced within the opaque declaration, this code creates two\ndistinct types.\n\n### Comptime Memory Changes \u00a7\n\nZig 0.12.0 overhauls the compiler's internal representation of comptime\nmemory, and more specifically comptime-mutable memory (i.e. comptime var).\nThis overhaul comes with some user-facing changes in the form of new\nrestrictions on what you can do with a comptime var.\n\nThe first, and most significant, new rule is that a pointer to a comptime var\nis never allowed to become runtime-known. For instance, consider the following\nsnippet:\n\ncomptime_var_ptr_runtime.zig\n\n    \n    \n    test \"runtime-known comptime var pointer\" { comptime var x: u32 = 123; // `var` makes `ptr` runtime-known var ptr: *const u32 = undefined; ptr = &x; if (ptr.* != 123) return error.TestFailed; }\n\nShell\n\n    \n    \n    $ zig test comptime_var_ptr_runtime.zig docgen_tmp/comptime_var_ptr_runtime.zig:5:11: error: runtime value contains reference to comptime var ptr = &x; ^~ docgen_tmp/comptime_var_ptr_runtime.zig:5:11: note: comptime var pointers are not available at runtime\n\nIn previous versions of Zig, this test passed as you might expect. In Zig\n0.12.0, it emits a compile error, because the assignment to ptr makes the\nvalue &x - which is a pointer to a comptime var - runtime-known.\n\nSuch pointers can also become runtime-known by, for instance, being passed to\na function called at runtime:\n\ncomptime_var_ptr_runtime_arg.zig\n\n    \n    \n    test \"comptime var pointer as runtime argument\" { comptime var x: u32 = 123; if (load(&x) != 123) return error.TestFailed; } fn load(ptr: *const u32) u32 { return ptr.*; }\n\nShell\n\n    \n    \n    $ zig test comptime_var_ptr_runtime_arg.zig docgen_tmp/comptime_var_ptr_runtime_arg.zig:3:14: error: runtime value contains reference to comptime var if (load(&x) != 123) return error.TestFailed; ^~ docgen_tmp/comptime_var_ptr_runtime_arg.zig:3:14: note: comptime var pointers are not available at runtime\n\nThis test also emits a compile error in Zig 0.12.0. The call to load occurs at\nruntime, and its ptr parameter is not marked comptime, so ptr is runtime-known\nwithin the body of load. This means the call to load makes the pointer &x\nruntime-known, hence the compile error.\n\nThis restriction was put in place to fix some soundness bugs. When a pointer\nto a comptime var becomes runtime-known, mutations to it become invalid since\nthe pointed-to data becomes constant, but the type system fails to reflect\nthis, leading to the potential for runtime segmentation faults in what appears\nto be valid code. In addition, the value you read from such a pointer at\nruntime would be its \"final\" comptime value, which was an unintuitive\nbehavior. Thus, these pointers can no longer be runtime-known.\n\nThe second new restriction is that a pointer to a comptime var is never\nallowed to be contained within the resolved value of a global declaration. For\ninstance, consider the following snippet:\n\ncomptime_var_ptr_global.zig\n\n    \n    \n    const ptr: *const u32 = ptr: { var x: u32 = 123; break :ptr &x; }; comptime { _ = ptr; }\n\nShell\n\n    \n    \n    $ zig test comptime_var_ptr_global.zig docgen_tmp/comptime_var_ptr_global.zig:1:30: error: global variable contains reference to comptime var const ptr: *const u32 = ptr: { ~~~~~^ referenced by: comptime_0: docgen_tmp/comptime_var_ptr_global.zig:6:9 remaining reference traces hidden; use '-freference-trace' to see all reference traces\n\nHere, ptr is a global declaration whose value is a pointer to a comptime var.\nThis declaration was permitted in Zig 0.11.0, but raises a compile error in\nZig 0.12.0. The same rule applies in more complex cases, such as when the\npointer is contained within a struct field:\n\ncomptime_var_ptr_global_struct.zig\n\n    \n    \n    const S = struct { ptr: *const u32 }; const val: S = blk: { var x: u32 = 123; break :blk .{ .ptr = &x }; }; comptime { _ = val; }\n\nShell\n\n    \n    \n    $ zig test comptime_var_ptr_global_struct.zig docgen_tmp/comptime_var_ptr_global_struct.zig:2:21: error: global variable contains reference to comptime var const val: S = blk: { ~~~~~^ referenced by: comptime_0: docgen_tmp/comptime_var_ptr_global_struct.zig:7:9 remaining reference traces hidden; use '-freference-trace' to see all reference traces\n\nThis code raises the same compile error as the previous example. This\nrestriction has been put in place primarily to aid the implementation of\nincremental compilation in the Zig compiler, which depends on the fact that\nanalysis of global declarations is order-independent, and the dependencies\nbetween declarations can be easily modeled.\n\nThe most common way for this to manifest as a compile error in existing code\nis if a function constructs a slice at comptime which is then used at runtime.\nFor instance, consider the following snippet:\n\nconstruct_slice_comptime.zig\n\n    \n    \n    fn getName() []const u8 { comptime var buf: [9]u8 = undefined; // In practice there would likely be more complex logic here to populate `buf`. @memcpy(&buf, \"some name\"); return &buf; } test getName { try @import(\"std\").testing.expectEqualStrings(\"some name\", getName()); }\n\nShell\n\n    \n    \n    $ zig test construct_slice_comptime.zig docgen_tmp/construct_slice_comptime.zig:5:12: error: runtime value contains reference to comptime var return &buf; ^~~~ docgen_tmp/construct_slice_comptime.zig:5:12: note: comptime var pointers are not available at runtime referenced by: decltest.getName: docgen_tmp/construct_slice_comptime.zig:8:64 remaining reference traces hidden; use '-freference-trace' to see all reference traces\n\nA call to getName returns a slice whose ptr field is a pointer to a comptime\nvar. This means the value cannot be used at runtime, nor can it appear in the\nvalue of a global declaration. This code can be fixed by promoting the\ncomputed data to a const after filling the buffer:\n\nconstruct_slice_comptime.zig\n\n    \n    \n    fn getName() []const u8 { comptime var buf: [9]u8 = undefined; // In practice there would likely be more complex logic here to populate `buf`. @memcpy(&buf, \"some name\"); const final_name = buf; return &final_name; } test getName { try @import(\"std\").testing.expectEqualStrings(\"some name\", getName()); }\n\nShell\n\n    \n    \n    $ zig test construct_slice_comptime.zig 1/1 construct_slice_comptime.decltest.getName... OK All 1 tests passed.\n\nLike in previous versions of Zig, comptime-known consts have infinite\nlifetime, and the restrictions discussed here do not apply to them. Therefore,\nthis code functions as expected.\n\nAnother possible failure mode is in code which used the old semantics to\ncreate global mutable comptime state. For instance, the following snippet\nattempts to create a global comptime counter:\n\nglobal_comptime_counter.zig\n\n    \n    \n    const counter: *u32 = counter: { var n: u32 = 0; break :counter &n; }; comptime { counter.* += 1; }\n\nShell\n\n    \n    \n    $ zig test global_comptime_counter.zig docgen_tmp/global_comptime_counter.zig:1:32: error: global variable contains reference to comptime var const counter: *u32 = counter: { ~~~~~~~~~^ referenced by: comptime_0: docgen_tmp/global_comptime_counter.zig:6:5 remaining reference traces hidden; use '-freference-trace' to see all reference traces\n\nThis code emits a compile error in Zig 0.12.0. This use case is not and will\nnot be supported by Zig: any mutable comptime state must be represented\nlocally.\n\n### @fieldParentPtr \u00a7\n\nThe first argument is removed in favor of using the result type.\n\nMigration guide:\n\nsample_code\n\n    \n    \n    const parent_ptr = @fieldParentPtr(Parent, \"field_name\", field_ptr);\n\n\u2193\n\nsample_code\n\n    \n    \n    const parent_ptr: *Parent = @fieldParentPtr(\"field_name\", field_ptr);\n\nor\n\nsample_code\n\n    \n    \n    const parent_ptr: *Parent = @alignCast(@fieldParentPtr(\"field_name\", field_ptr));\n\ndepending on what parent pointer alignment the compiler is able to prove. The\nsecond form is more portable, since it's possible for the @alignCast to be\nneeded for some targets but not others.\n\n### Disallow alignment on function type \u00a7\n\nZig 0.11.0 allowed function types to specify an alignment. This is disallowed\nin Zig 0.12.0, because is it a property of function declarations and pointers,\nnot of function types.\n\nfunc_type_align.zig\n\n    \n    \n    comptime { _ = fn () align(4) void; }\n\nShell\n\n    \n    \n    $ zig test func_type_align.zig docgen_tmp/func_type_align.zig:2:21: error: function type cannot have an alignment _ = fn () align(4) void; ^\n\n### @errorCast \u00a7\n\nPrevious releases of Zig included an @errSetCast builtin which performed a\nsafety-checked cast from one error set to another, potentially smaller, one.\nIn Zig 0.12.0, this builtin is replaced with @errorCast. Previous uses will\ncontinue to work, but in addition, this new builtin can cast the error set of\nan error union:\n\nerror_cast.zig\n\n    \n    \n    const testing = @import(\"std\").testing; test \"@errorCast error set\" { const err: error{Foo, Bar} = error.Foo; const casted: error{Foo} = @errorCast(err); try testing.expectEqual(error.Foo, casted); } test \"@errorCast error union\" { const err: error{Foo, Bar}!u32 = error.Foo; const casted: error{Foo}!u32 = @errorCast(err); try testing.expectError(error.Foo, casted); } test \"@errorCast error union payload\" { const err: error{Foo, Bar}!u32 = 123; const casted: error{Foo}!u32 = @errorCast(err); try testing.expectEqual(123, casted); }\n\nShell\n\n    \n    \n    $ zig test error_cast.zig 1/3 error_cast.test.@errorCast error set... OK 2/3 error_cast.test.@errorCast error union... OK 3/3 error_cast.test.@errorCast error union payload... OK All 3 tests passed.\n\n### @abs \u00a7\n\nPrevious releases of Zig included the @fabs builtin. This has been replaced\nwith a new @abs builtin, which is able to operate on integers as well as\nfloats:\n\nabs.zig\n\n    \n    \n    const expectEqual = @import(\"std\").testing.expectEqual; test \"@abs on float\" { const x: f32 = -123.5; const y = @abs(x); try expectEqual(123.5, y); } test \"@abs on int\" { const x: i32 = -12345; const y = @abs(x); try expectEqual(12345, y); }\n\nShell\n\n    \n    \n    $ zig test abs.zig 1/2 abs.test.@abs on float... OK 2/2 abs.test.@abs on int... OK All 2 tests passed.\n\n## Standard Library \u00a7\n\n### Windows Command Line Argument Parsing \u00a7\n\nOn Windows, the command line arguments of a program are a single WTF-16\nencoded string and it's up to the program to split it into an array of\nstrings. In C/C++, the entry point of the C runtime takes care of splitting\nthe command line and passing argc/argv to the main function.\n\nPreviously, ArgIteratorWindows matched the behavior of CommandLineToArgvW, but\nit turns out that CommandLineToArgvW's behavior does not match the behavior of\nthe C runtime post-2008. In 2008, the C runtime argv splitting changed how it\nhandles consecutive double quotes within a quoted argument (it's now\nconsidered an escaped quote, e.g. \"foo\"\"bar\" post-2008 would get parsed into\nfoo\"bar), and the rules around argv[0] were also changed.\n\nThis release makes ArgIteratorWindows match the behavior of the post-2008 C\nruntime. The motivation here is roughly the same as when the same change was\nmade in Rust, that is (paraphrased):\n\n  * Consistent behavior between Zig and modern C/C++ programs\n  * Allows users to escape double quotes in a way that can be more straightforward\n\nAdditionally, the suggested mitigation for BatBadBut relies on the post-2008\nargv splitting behavior for roundtripping of the arguments given to cmd.exe.\n\nThe BadBatBut mitigation did not make the 0.12.0 release cutoff.\n\n### Bring-Your-Own-OS API Layer Regressed \u00a7\n\nPrevious versions of Zig allowed applications to override the POSIX API layer\nof the standard library. This release intentionally removes this ability, with\nno migration path offered.\n\nThis was a mistake from day one. This is the wrong abstraction layer to do\nthis in.\n\nThe alternate plan for this is to make all I/O operations require an IO\ninterface parameter, similar to how allocations require an Allocator interface\nparameter today.\n\nSuch a plan is not yet implemented, so applications which require this\nfunctionality must maintain a fork of the standard library until then.\n\n### std.os renamed to std.posix \u00a7\n\nMigration guide:\n\nsample_code\n\n    \n    \n    std.os.abort();\n\n\u2193\n\nsample_code\n\n    \n    \n    std.posix.abort();\n\nGenerally, one should prefer to use the higher-level cross-platform\nabstractions rather than reaching into the POSIX API layer. For example,\nstd.process.exit is more portable than std.posix.exit. You should generally\nexpect the API inside std.posix to be available on a given OS when the OS\nimplements that corresponding POSIX functionality.\n\n### Ryu Floating-Point Formatting \u00a7\n\nZig 0.12.0 replaces the previous errol floating point formatting algorithm\nwith one based on Ryu, a modern algorithm for converting IEEE-754 floating-\npoint numbers to decimal strings.\n\nThe improvements this brings are:\n\n  * Ability to format f80 and f128 types\n  * More accurate f16 and f32 formatting\n  * Complete round-trip support for every float type\n  * Generic backend that can be used to print any float of a general number of bits (less than or equal to 128 bits)\n\nBehavior Differences:\n\n  * Exponents are no longer padded with a leading 0 to 2-digits and if positive, the sign is no longer printed:\n    \n        errol: 1e+02 ryu: 1e2\n\n  * Fractional values of 0 are omitted in full precision mode:\n    \n        errol: 2.0e+00 ryu: 2e0\n\n  * Full precision output is more accurate in all cases other than f64, since we no longer do a cast internally to f64:\n    \n        # Ryu 3.1234567891011121314151617181920212E0 :f128 3.1234567891011121314E0 :f80 3.1234567891011121314E0 :c_longdouble 3.123456789101112E0 :f64 3.1234567E0 :f32 3.123E0 :f16 ## Errol 3.123456789101112e+00 :f128 3.123456789101112e+00 :f80 3.123456789101112e+00 :c_longdouble 3.123456789101112e+00 :f64 3.12345671e+00 :f32 3.123046875e+00 :f16\n\n  * Additionally, rounding behaviour in these cases can differ in the fixed precision case as the shortest representation will typically differ:\n    \n        # bits: 141333 # precision: 3 # std_shortest: 1.98049715e-40 # ryu_shortest: 1.9805e-40 # type: f32 | | std_dec: 0.000 | ryu_dec: 0.000 | | std_exp: 1.980e-40 | ryu_exp: 1.981e-40\n\nPerformance: ~2.3x performance improvement\n\nCode Size: roughly +5KB (2x)\n\nSource for those stats\n\n### Reworked HTTP \u00a7\n\nFirst, some pretty straightforward changes:\n\n  * don't emit Server HTTP header. Let the user add that if they wish to. It's not strictly necessary, and arguably a harmful default.\n  * correct the error set of finish to not have NotWriteable and MessageTooLong in it\n  * protect against zero-length chunks in Server\n  * add missing redirect behavior option to FetchOptions and make it an enum instead of 2 fields\n  * error.CompressionNotSupported is renamed to error.CompressionUnsupported, matching the naming convention from all the other errors in the same set.\n  * Removed documentation comments that were redundant with field and type names.\n  * Disabling zstd decompression in the server for now; see #18937.\n  * Automatically handle expect: 100-continue requests\n\nNext, removed the ability to heap-allocate the buffer for headers. The buffer\nfor HTTP headers is now always provided via a static buffer. As a consequence,\nOutOfMemory is no longer a member of the read() error set, and the API and\nimplementation of Client and Server are simplified.\nerror.HttpHeadersExceededSizeLimit is renamed to error.HttpHeadersOversize.\n\nFinally, the big changes:\n\n#### Removal of std.http.Headers \u00a7\n\nInstead, some headers are provided via explicit field names populated while\nparsing the HTTP request/response, and some are provided via new fields that\nsupport passing extra, arbitrary headers. This resulted in simplification of\nlogic in many places, as well as elimination of the possibility of failure in\nmany places. There is less deinitialization code happening now. Furthermore,\nit made it no longer necessary to clone the headers data structure in order to\nhandle redirects.\n\nhttp_proxy and https_proxy fields are now pointers since it is common for them\nto be unpopulated.\n\nloadDefaultProxies is changed into initDefaultProxies to communicate that it\ndoes not actually load anything from disk or from the network. The function\nnow is leaky; the API user must pass an already instantiated arena allocator.\nRemoves the need to deinitialize proxies.\n\nBefore, proxies stored arbitrary sets of headers. Now they only store the\nauthorization value.\n\nRemoved the duplicated code between https_proxy and http_proxy. Finally,\nparsing failures of the environment variables result in errors being emitted\nrather than silently ignoring the proxy.\n\n#### Rework Server Entirely \u00a7\n\nMainly, this removes the poorly named wait, send, finish functions, which all\noperated on the same \"Response\" object, which was actually being used as the\nrequest.\n\nNow, it looks like this:\n\n  1. std.net.Server.accept() gives you a std.net.Server.Connection\n  2. std.http.Server.init() with the connection\n  3. Server.receiveHead() gives you a Request\n  4. Request.reader() gives you a body reader\n  5. Request.respond() is a one-shot, or Request.respondStreaming() creates a Response\n  6. Response.writer() gives you a body writer\n  7. Response.end() finishes the response; Response.endChunked() allows passing response trailers.\n\nIn other words, the type system now guides the API user down the correct path.\n\nreceiveHead allows extra bytes to be read into the read buffer, and then will\nreuse those bytes for the body or the next request upon connection reuse.\n\nrespond(), the one-shot function, will send the entire response in one\nsyscall.\n\nStreaming response bodies no longer wastefully wraps every call to write with\na chunk header and trailer; instead it only sends the HTTP chunk wrapper when\nflushing. This means the user can still control when it happens but it also\ndoes not add unnecessary chunks.\n\nEmpirically, the usage code is significantly less noisy, it has less error\nhandling while handling errors more correctly, it's more obvious what is\nhappening, and it is syscall-optimal.\n\nsample_code\n\n    \n    \n    var read_buffer: [8000]u8 = undefined; accept: while (true) { const connection = try http_server.accept(); defer connection.stream.close(); var server = std.http.Server.init(connection, &read_buffer); while (server.state == .ready) { var request = server.receiveHead() catch |err| { std.debug.print(\"error: {s}\\n\", .{@errorName(err)}); continue :accept; }; try static_http_file_server.serve(&request); } }\n\nsample_code\n\n    \n    \n    pub fn serve(context: *Context, request: *std.http.Server.Request) ServeError!void { // ... return request.respond(content, .{ .status = status, .extra_headers = &.{ .{ .name = \"content-type\", .value = @tagName(file.mime_type) }, }, });\n\nAdditionally:\n\n  * Uncouple std.http.HeadParser from protocol.zig\n  * Delete std.Server.Connection; use std.net.Server.Connection instead.\n\n    * The API user supplies the read buffer when initializing the http.Server, and it is used for the HTTP head as well as a buffer for reading the body into.\n  * Replace and document the State enum. No longer is there both \"start\" and \"first\".\n\nstd.http.Client has not yet been reworked in a similar manner as\nstd.http.Server.\n\n### deflate reimplemented from first principles \u00a7\n\nIn Zig 0.11.0, the deflate implementation was ported from the Go standard\nlibrary, which had a bunch of undesirable properties, such as incorrect use of\nglobal variables, comments about Go's optimizer in Zig's codebase, and the\nrequirement of dynamic memory allocation.\n\nZig 0.12.0 has a new implementation that is not a port of an existing\ncodebase.\n\nThe new implementation is roughly 1.2-1.4x faster in decompression and\n1.1-1.2x faster in compression. Compressed sizes are pretty much the same in\nboth cases (source).\n\nThe new code uses static allocations for all structures, doesn't require\nallocator. That makes sense especially for deflate where all structures,\ninternal buffers are allocated to the full size. Little less for inflate where\nthe previous verision used less memory by not preallocating to theoretical max\nsize array which are usually not fully used.\n\nFor deflate the new implementaiton allocates 395K while previous\nimplementation used 779K. For inflate the new implementation allocates 74.5K\nwhile the old one around 36K.\n\nInflate difference is because we here use 64K history instead of 32K\npreviously.\n\nMigration guide:\n\nsample_code\n\n    \n    \n    const std = @import(\"std\"); // To get this file: // wget -nc -O war_and_peace.txt https://www.gutenberg.org/ebooks/2600.txt.utf-8 const data = @embedFile(\"war_and_peace.txt\"); pub fn main() !void { var gpa = std.heap.GeneralPurposeAllocator(.{}){}; defer std.debug.assert(gpa.deinit() == .ok); const allocator = gpa.allocator(); try oldDeflate(allocator); try new(std.compress.flate, allocator); try oldZlib(allocator); try new(std.compress.zlib, allocator); try oldGzip(allocator); try new(std.compress.gzip, allocator); } pub fn new(comptime pkg: type, allocator: std.mem.Allocator) !void { var buf = std.ArrayList(u8).init(allocator); defer buf.deinit(); // Compressor var cmp = try pkg.compressor(buf.writer(), .{}); _ = try cmp.write(data); try cmp.finish(); var fbs = std.io.fixedBufferStream(buf.items); // Decompressor var dcp = pkg.decompressor(fbs.reader()); const plain = try dcp.reader().readAllAlloc(allocator, std.math.maxInt(usize)); defer allocator.free(plain); try std.testing.expectEqualSlices(u8, data, plain); } pub fn oldDeflate(allocator: std.mem.Allocator) !void { const deflate = std.compress.v1.deflate; // Compressor var buf = std.ArrayList(u8).init(allocator); defer buf.deinit(); // Remove allocator // Rename deflate -> flate var cmp = try deflate.compressor(allocator, buf.writer(), .{}); _ = try cmp.write(data); try cmp.close(); // Rename to finish cmp.deinit(); // Remove // Decompressor var fbs = std.io.fixedBufferStream(buf.items); // Remove allocator and last param // Rename deflate -> flate // Remove try var dcp = try deflate.decompressor(allocator, fbs.reader(), null); defer dcp.deinit(); // Remove const plain = try dcp.reader().readAllAlloc(allocator, std.math.maxInt(usize)); defer allocator.free(plain); try std.testing.expectEqualSlices(u8, data, plain); } pub fn oldZlib(allocator: std.mem.Allocator) !void { const zlib = std.compress.v1.zlib; var buf = std.ArrayList(u8).init(allocator); defer buf.deinit(); // Compressor // Rename compressStream => compressor // Remove allocator var cmp = try zlib.compressStream(allocator, buf.writer(), .{}); _ = try cmp.write(data); try cmp.finish(); cmp.deinit(); // Remove var fbs = std.io.fixedBufferStream(buf.items); // Decompressor // decompressStream => decompressor // Remove allocator // Remove try var dcp = try zlib.decompressStream(allocator, fbs.reader()); defer dcp.deinit(); // Remove const plain = try dcp.reader().readAllAlloc(allocator, std.math.maxInt(usize)); defer allocator.free(plain); try std.testing.expectEqualSlices(u8, data, plain); } pub fn oldGzip(allocator: std.mem.Allocator) !void { const gzip = std.compress.v1.gzip; var buf = std.ArrayList(u8).init(allocator); defer buf.deinit(); // Compressor // Rename compress => compressor // Remove allocator var cmp = try gzip.compress(allocator, buf.writer(), .{}); _ = try cmp.write(data); try cmp.close(); // Rename to finisho cmp.deinit(); // Remove var fbs = std.io.fixedBufferStream(buf.items); // Decompressor // Rename decompress => decompressor // Remove allocator // Remove try var dcp = try gzip.decompress(allocator, fbs.reader()); defer dcp.deinit(); // Remove const plain = try dcp.reader().readAllAlloc(allocator, std.math.maxInt(usize)); defer allocator.free(plain); try std.testing.expectEqualSlices(u8, data, plain); }\n\n### std.posix APIs Gain Type Safety \u00a7\n\nFor example, let's look at std.posix.termios:\n\n  * Add missing API bits to termios and the types of its fields for all 12 operating systems\n  * Correct API bits on Linux (they were wrong for some CPU architectures)\n  * Consolidate std.c definitions\n  * Add type safety to all integers\n\nFor example previously this is how you would set immediate mode on a tty:\n\nsample_code\n\n    \n    \n    const in = std.io.getStdIn(); // copy original settings and restore them once done const original_termios = try std.posix.tcgetattr(in.handle); defer std.posix.tcsetattr(in.handle, .FLUSH, original_termios) catch {}; // set immediate input mode var termios = original_termios; termios.lflag &= ~@as(std.posix.system.tcflag_t, std.posix.system.ICANON); // flush changes try std.posix.tcsetattr(in.handle, .FLUSH, termios);\n\nNow the middle part looks like this:\n\nsample_code\n\n    \n    \n    // set immediate input mode var termios = original_termios; termios.lflag.ICANON = false;\n\nThis is thanks to the new definitions based on packed struct. Here's for\nexample the definition of lflag for Linux:\n\nsample_code\n\n    \n    \n    pub const tc_lflag_t = switch (native_arch) { .powerpc, .powerpcle, .powerpc64, .powerpc64le => packed struct(u32) { _0: u1 = 0, ECHOE: bool = false, ECHOK: bool = false, ECHO: bool = false, ECHONL: bool = false, _5: u2 = 0, ISIG: bool = false, ICANON: bool = false, _9: u1 = 0, IEXTEN: bool = false, _11: u11 = 0, TOSTOP: bool = false, _23: u8 = 0, NOFLSH: bool = false, }, .mips, .mipsel, .mips64, .mips64el => packed struct(u32) { ISIG: bool = false, ICANON: bool = false, _2: u1 = 0, ECHO: bool = false, ECHOE: bool = false, ECHOK: bool = false, ECHONL: bool = false, NOFLSH: bool = false, IEXTEN: bool = false, _9: u6 = 0, TOSTOP: bool = false, _: u16 = 0, }, else => packed struct(u32) { ISIG: bool = false, ICANON: bool = false, _2: u1 = 0, ECHO: bool = false, ECHOE: bool = false, ECHOK: bool = false, ECHONL: bool = false, NOFLSH: bool = false, TOSTOP: bool = false, _9: u6 = 0, IEXTEN: bool = false, _: u16 = 0, }, };\n\nMany more std.posix APIs were adjusted in a similar way.\n\n### std.builtin Enum Fields Lowercased \u00a7\n\nZig 0.12.0 takes the opportunity to adjust the field names of some enums in\nstd.builtin to align with our current naming conventions, which dictate that\nenum fields should be snake_case. The following enums have been updated:\n\n  * std.builtin.AtomicOrder\n  * std.builtin.ContainerLayout\n  * std.builtin.Endian\n  * std.builtin.FloatMode\n  * std.builtin.GlobalLinkage\n  * std.builtin.LinkMode\n\n### Global Configuration \u00a7\n\nPreviously, when one wanted to override defaults, such as the logging function\nused by std.log, they would have to define std_options in their root file,\nlike so:\n\nsample_code\n\n    \n    \n    pub const std_options = struct { pub const logFn = myLogFn; };\n\nNote how std_options above is a struct type definiton. In this release\nstd_options is now an instance of std.Options, making the process of defining\noverrides less error-prone.\n\nThe code above would look like this now:\n\nsample_code\n\n    \n    \n    pub const std_options: std.Options = .{ .logFn = myLogFn, };\n\nAnd this is the definition of std.Options to see what else you can override.\n\nsample_code\n\n    \n    \n    pub const Options = struct { enable_segfault_handler: bool = debug.default_enable_segfault_handler, /// Function used to implement `std.fs.cwd` for WASI. wasiCwd: fn () os.wasi.fd_t = fs.defaultWasiCwd, /// The current log level. log_level: log.Level = log.default_level, log_scope_levels: []const log.ScopeLevel = &.{}, logFn: fn ( comptime message_level: log.Level, comptime scope: @TypeOf(.enum_literal), comptime format: []const u8, args: anytype, ) void = log.defaultLog, fmt_max_depth: usize = fmt.default_max_depth, cryptoRandomSeed: fn (buffer: []u8) void = @import(\"crypto/tlcsprng.zig\").defaultRandomSeed, crypto_always_getrandom: bool = false, crypto_fork_safety: bool = true, /// By default Zig disables SIGPIPE by setting a \"no-op\" handler for it. Set this option /// to `true` to prevent that. /// /// Note that we use a \"no-op\" handler instead of SIG_IGN because it will not be inherited by /// any child process. /// /// SIGPIPE is triggered when a process attempts to write to a broken pipe. By default, SIGPIPE /// will terminate the process instead of exiting. It doesn't trigger the panic handler so in many /// cases it's unclear why the process was terminated. By capturing SIGPIPE instead, functions that /// write to broken pipes will return the EPIPE error (error.BrokenPipe) and the program can handle /// it like any other error. keep_sigpipe: bool = false, /// By default, std.http.Client will support HTTPS connections. Set this option to `true` to /// disable TLS support. /// /// This will likely reduce the size of the binary, but it will also make it impossible to /// make a HTTPS connection. http_disable_tls: bool = false, side_channels_mitigations: crypto.SideChannelsMitigations = crypto.default_side_channels_mitigations, };\n\n### Pointer Stability Locks \u00a7\n\nThis adds std.debug.SafetyLock and uses it in standard library hash maps by\nadding lockPointers() and unlockPointers().\n\nThis provides a way to detect when an illegal modification has happened and\npanic rather than invoke undefined behavior:\n\nsafety_locks.zig\n\n    \n    \n    const std = @import(\"std\"); pub fn main() !void { const gpa = std.heap.page_allocator; var map: std.AutoHashMapUnmanaged(i32, i32) = .{}; const gop = try map.getOrPut(gpa, 1234); map.lockPointers(); defer map.unlockPointers(); gop.value_ptr.* = try calculate(gpa, &map); } fn calculate(gpa: std.mem.Allocator, m: anytype) !i32 { try m.put(gpa, 42, 420); return 999; }\n\nShell\n\n    \n    \n    $ zig build-exe safety_locks.zig $ ./safety_locks thread 188810 panic: reached unreachable code /home/andy/local/lib/zig/std/debug.zig:403:14: 0x1036b4d in assert (safety_locks) if (!ok) unreachable; // assertion failure ^ /home/andy/local/lib/zig/std/debug.zig:2845:15: 0x10375fb in lock (safety_locks) assert(l.state == .unlocked); ^ /home/andy/local/lib/zig/std/hash_map.zig:1331:44: 0x1066683 in getOrPutContextAdapted__anon_6584 (safety_locks) self.pointer_stability.lock(); ^ /home/andy/local/lib/zig/std/hash_map.zig:1318:56: 0x1037505 in getOrPutContext (safety_locks) const gop = try self.getOrPutContextAdapted(allocator, key, ctx, ctx); ^ /home/andy/local/lib/zig/std/hash_map.zig:1244:52: 0x103765a in putContext (safety_locks) const result = try self.getOrPutContext(allocator, key, ctx); ^ /home/andy/local/lib/zig/std/hash_map.zig:1241:35: 0x1034023 in put (safety_locks) return self.putContext(allocator, key, value, undefined); ^ /home/andy/docgen_tmp/safety_locks.zig:15:14: 0x1033fb6 in calculate__anon_3194 (safety_locks) try m.put(gpa, 42, 420); ^ /home/andy/docgen_tmp/safety_locks.zig:11:36: 0x10341eb in main (safety_locks) gop.value_ptr.* = try calculate(gpa, &map); ^ /home/andy/local/lib/zig/std/start.zig:511:37: 0x1033ec5 in posixCallMainAndExit (safety_locks) const result = root.main() catch |err| { ^ /home/andy/local/lib/zig/std/start.zig:253:5: 0x10339e1 in _start (safety_locks) asm volatile (switch (native_arch) { ^ ???:?:?: 0x0 in ??? (???) (process terminated by signal)\n\nSomething nice about this is that if you use the \"assume capacity\" variants\nthen such mutations are actually well-defined, and don't trigger the problem:\n\nassume_capacity.zig\n\n    \n    \n    const std = @import(\"std\"); pub fn main() !void { const gpa = std.heap.page_allocator; var map: std.AutoHashMapUnmanaged(i32, i32) = .{}; try map.ensureUnusedCapacity(gpa, 2); const gop = map.getOrPutAssumeCapacity(1234); map.lockPointers(); defer map.unlockPointers(); gop.value_ptr.* = calculate(&map); } fn calculate(m: anytype) i32 { m.putAssumeCapacity(42, 420); return 999; }\n\nShell\n\n    \n    \n    $ zig build-exe assume_capacity.zig $ ./assume_capacity\n\nFollow-up tasks that did not make the release cutoff:\n\n  * introduce pointer stability safety locks to array lists\n  * introduce pointer stability safety locks to MultiArrayList\n  * add stack traces to pointer stability safety locks\n\n## Build System \u00a7\n\n### System Package Mode \u00a7\n\nMakes the zig build system significantly more friendly to system package\nmaintainers by introducing System Integration Options.\n\nLet's examine this feature using groovebasin as an example project:\n\n#### Ability to Declare Optional System Library Integration \u00a7\n\n    \n    \n    --- a/build.zig +++ b/build.zig @@ -5,18 +5,8 @@ pub fn build(b: *std.Build) void { const optimize = b.standardOptimizeOption(.{ .preferred_optimize_mode = .ReleaseSafe, }); - const libgroove_optimize_mode = b.option( - std.builtin.OptimizeMode, - \"libgroove-optimize\", - \"override optimization mode of libgroove and its dependencies\", - ); const use_llvm = b.option(bool, \"use-llvm\", \"LLVM backend\"); - const groove_dep = b.dependency(\"groove\", .{ - .optimize = libgroove_optimize_mode orelse .ReleaseFast, - .target = target, - }); - b.installDirectory(.{ .source_dir = .{ .path = \"public\" }, .install_dir = .lib, @@ -31,7 +21,22 @@ pub fn build(b: *std.Build) void { .use_llvm = use_llvm, .use_lld = use_llvm, }); - server.linkLibrary(groove_dep.artifact(\"groove\")); + + if (b.systemIntegrationOption(\"groove\", .{})) { + server.linkSystemLibrary(\"groove\"); + } else { + const libgroove_optimize_mode = b.option( + std.builtin.OptimizeMode, + \"libgroove-optimize\", + \"override optimization mode of libgroove and its dependencies\", + ); + const groove_dep = b.dependency(\"groove\", .{ + .optimize = libgroove_optimize_mode orelse .ReleaseFast, + .target = target, + }); + server.linkLibrary(groove_dep.artifact(\"groove\")); + } + b.installArtifact(server); const run_cmd = b.addRunArtifact(server);\n\nWith this diff plus some similar changes in the project's dependency tree...\n\n#### System Integration Help Section \u00a7\n\nThere is a new --help section:\n\n    \n    \n    System Integration Options: --system [dir] System Package Mode. Disable fetching; prefer system libs -fsys=[name] Enable a system integration -fno-sys=[name] Disable a system integration --host-target [triple] Use the provided target as the host --host-cpu [cpu] Use the provided CPU as the host --host-dynamic-linker [path] Use the provided dynamic linker as the host Available System Integrations: Enabled: groove no z no mp3lame no vorbis no ogg no\n\n#### Using the System Integration Options \u00a7\n\nShell\n\n    \n    \n    [nix-shell:~/dev/groovebasin]$ zig build -fsys=z [nix-shell:~/dev/groovebasin]$ ldd zig-out/bin/groovebasin linux-vdso.so.1 (0x00007fff054c7000) libz.so.1 => /nix/store/8mw6ssjspf8k1ija88cfldmxlbarl1bb-zlib-1.2.13/lib/libz.so.1 (0x00007fe164675000) libm.so.6 => /nix/store/whypqfa83z4bsn43n4byvmw80n4mg3r8-glibc-2.37-45/lib/libm.so.6 (0x00007fe164595000) libc.so.6 => /nix/store/whypqfa83z4bsn43n4byvmw80n4mg3r8-glibc-2.37-45/lib/libc.so.6 (0x00007fe1643ae000) /nix/store/whypqfa83z4bsn43n4byvmw80n4mg3r8-glibc-2.37-45/lib64/ld-linux-x86-64.so.2 (0x00007fe164696000)\n\nNow, re-run the command but removing -fsys=z:\n\nShell\n\n    \n    \n    [nix-shell:~/dev/groovebasin]$ ~/Downloads/zig/build-release/stage4/bin/zig build [nix-shell:~/dev/groovebasin]$ ldd zig-out/bin/groovebasin linux-vdso.so.1 (0x00007ffcc23f6000) libm.so.6 => /nix/store/whypqfa83z4bsn43n4byvmw80n4mg3r8-glibc-2.37-45/lib/libm.so.6 (0x00007f525feea000) libc.so.6 => /nix/store/whypqfa83z4bsn43n4byvmw80n4mg3r8-glibc-2.37-45/lib/libc.so.6 (0x00007f525fd03000) /nix/store/whypqfa83z4bsn43n4byvmw80n4mg3r8-glibc-2.37-45/lib64/ld-linux-x86-64.so.2 (0x00007f525ffcc000)\n\n#### New Release Option \u00a7\n\nSystem package maintainers can provide the new --release option in order to\nset a system-wide preference for optimization mode, while respecting the\napplication developer's choice.\n\n    \n    \n    --release[=mode] Request release mode, optionally specifying a preferred optimization mode: fast, safe, small\n\nShell\n\n    \n    \n    andy@ark ~/d/a/zlib (main)> zig build --release the project does not declare a preferred optimization mode. choose: --release=fast, --release=safe, or --release=small error: the following build command failed with exit code 1: /home/andy/dev/ayb/zlib/zig-cache/o/6f46a03cb0f5f70d2c891f31086fecc9/build /home/andy/Downloads/zig/build-release/stage3/bin/zig /home/andy/dev/ayb/zlib /home/andy/dev/ayb/zlib/zig-cache /home/andy/.cache/zig --seed 0x3e999c60 --release andy@ark ~/d/a/zlib (main) [1]> zig build --release=safe andy@ark ~/d/a/zlib (main)> vim build.zig andy@ark ~/d/a/zlib (main)> git diff diff --git a/build.zig b/build.zig index 76bbb01..1bc13e6 100644 --- a/build.zig +++ b/build.zig @@ -5,7 +5,9 @@ pub fn build(b: *std.Build) void { const lib = b.addStaticLibrary(.{ .name = \"z\", .target = b.standardTargetOptions(.{}), - .optimize = b.standardOptimizeOption(.{}), + .optimize = b.standardOptimizeOption(.{ + .preferred_optimize_mode = .ReleaseFast, + }), }); lib.linkLibC(); lib.addCSourceFiles(.{ andy@ark ~/d/a/zlib (main)> zig build --release andy@ark ~/d/a/zlib (main)> zig build --release=small andy@ark ~/d/a/zlib (main)>\n\nThis option may be set even if the project's build script does not explicitly\nexpose an optimization configuration option.\n\n#### Avoid Fetching in System Mode \u00a7\n\n\\--system prevents Zig from fetching packages. Instead, a directory of\npackages is provided, populated presumably by the system package manager.\n\nShell\n\n    \n    \n    [nix-shell:~/dev/2Pew]$ zig build --system ~/tmp/p -fno-sys=SDL2 error: lazy dependency package not found: /home/andy/tmp/p/1220c5360c9c71c215baa41b46ec18d0711059b48416a2b1cf96c7c2d87b2e8e4cf6 info: remote package fetching disabled due to --system mode info: dependencies might be avoidable depending on build configuration [nix-shell:~/dev/2Pew]$ zig build --system ~/tmp/p [nix-shell:~/dev/2Pew]$ mv ~/.cache/zig/p/1220c5360c9c71c215baa41b46ec18d0711059b48416a2b1cf96c7c2d87b2e8e4cf6 ~/tmp/p [nix-shell:~/dev/2Pew]$ zig build --system ~/tmp/p -fno-sys=SDL2 steps [5/8] zig build-lib SDL2 ReleaseFast native... Compile C Objects [75/128] e_atan2... ^C [nix-shell:~/dev/2Pew]$\n\n### Lazy Dependencies \u00a7\n\n    \n    \n    --- a/build.zig +++ b/build.zig - const groove_dep = b.dependency(\"groove\", .{ - .optimize = libgroove_optimize_mode orelse .ReleaseFast, - .target = target, - }); + if (b.lazyDependency(\"groove\", .{ + .optimize = libgroove_optimize_mode orelse .ReleaseFast, + .target = target, + })) |groove_dep| { + server.linkLibrary(groove_dep.artifact(\"groove\")); + }\n    \n    \n    --- a/build.zig.zon +++ b/build.zig.zon @@ -5,6 +5,7 @@ .groove = .{ .url = \"https://github.com/andrewrk/libgroove/archive/66745eae734e986cd478e7220664f2de902d10a1.tar.gz\", .hash = \"1220285f0f6b2be336519a0e612a11617c655f78b0efe1cac12fc73fc1e50c7b3e14\", + .lazy = true, }, }, .paths = .{\n\nThis makes the dependency only get fetched if it is actually used. The build\nrunner will be rebuilt if any missing lazy dependencies are encountered.\n\nThere is an error for using dependency() instead of lazyDependency():\n\nShell\n\n    \n    \n    $ zig build -h thread 2904684 panic: dependency 'groove' is marked as lazy in build.zig.zon which means it must use the lazyDependency function instead /home/andy/Downloads/zig/lib/std/debug.zig:434:22: 0x11901a9 in panicExtra__anon_18741 (build) std.builtin.panic(msg, trace, ret_addr); ^ /home/andy/Downloads/zig/lib/std/debug.zig:409:15: 0x1167399 in panic__anon_18199 (build) panicExtra(null, null, format, args); ^ /home/andy/Downloads/zig/lib/std/Build.zig:1861:32: 0x1136dca in dependency__anon_16705 (build) std.debug.panic(\"dependency '{s}{s}' is marked as lazy in build.zig.zon which means it must use the lazyDependency function instead\", .{ b.dep_prefix, name }); ^ /home/andy/dev/groovebasin/build.zig:33:40: 0x10e8865 in build (build) const groove_dep = b.dependency(\"groove\", .{ ^ /home/andy/Downloads/zig/lib/std/Build.zig:1982:33: 0x10ca783 in runBuild__anon_8952 (build) .Void => build_zig.build(b), ^ /home/andy/Downloads/zig/lib/build_runner.zig:310:29: 0x10c6708 in main (build) try builder.runBuild(root); ^ /home/andy/Downloads/zig/lib/std/start.zig:585:37: 0x10af845 in posixCallMainAndExit (build) const result = root.main() catch |err| { ^ /home/andy/Downloads/zig/lib/std/start.zig:253:5: 0x10af331 in _start (build) asm volatile (switch (native_arch) { ^ ???:?:?: 0x8 in ??? (???) Unwind information for `???:0x8` was not available, trace may be incomplete error: the following build command crashed: /home/andy/dev/groovebasin/zig-cache/o/20af710f8e0e96a0ccc68c47688b2d0d/build /home/andy/Downloads/zig/build-release/stage3/bin/zig /home/andy/dev/groovebasin /home/andy/dev/groovebasin/zig-cache /home/andy/.cache/zig --seed 0x513e8ce9 -Z4472a09906216280 -h\n\nIt's allowed to do the reverse - lazyDependency() when the manifest file does\nnot mark it as lazy.\n\nIt's probably best practice to always use lazyDependency() in build.zig.\n\n### introduce b.path; deprecate LazyPath.relative \u00a7\n\nThis adds the *std.Build owner to LazyPath so that lazy paths returned from a\ndependency can be used in the application's build script without friction or\nfootguns.\n\nMigration guide:\n\nSource-Relative LazyPath:\n\nsample_code\n\n    \n    \n    .root_source_file = .{ .path = \"src/main.zig\" },\n\n\u2193\n\nsample_code\n\n    \n    \n    .root_source_file = b.path(\"src/main.zig\"),\n\nLazyPath.relative\n\nsample_code\n\n    \n    \n    .root_source_file = LazyPath.relative(\"src/main.zig\"),\n\n\u2193\n\nsample_code\n\n    \n    \n    .root_source_file = b.path(\"src/main.zig\"),\n\nTest Runner\n\nsample_code\n\n    \n    \n    .test_runner = \"path/to/test_runner.zig\",\n\n\u2193\n\nsample_code\n\n    \n    \n    .test_runner = b.path(\"path/to/test_runner.zig\"),\n\n### Header Installation \u00a7\n\nThe intent for Compile.installHeader and friends has always been to bundle the\nheaders alongside an artifact, have them be installed together with the\nartifact and get automatically added to the include search paths of modules\nthat link with the artifact.\n\nIn Zig 0.11.0, however, these functions modified the default install top-level\nstep of the builder, lead to a number of unexpected results such as installing\nor not installing the headers depending on which top-level build steps are\ninvoked.\n\nZig 0.12.0 changes it so that installed headers are added to the compile step\nitself instead of modifying the top-level install step. To handle the\nconstruction of the include search path for dependent linking modules, an\nintermediary WriteFile step responsible for constructing the appropriate\ninclude tree is created and set up the first time a module links to an\nartifact.\n\nMigration guide:\n\ninstallHeader now takes a LazyPath:\n\nsample_code\n\n    \n    \n    for (headers) |h| lib.installHeader(h, h);\n\n\u2193\n\nsample_code\n\n    \n    \n    for (headers) |h| lib.installHeader(b.path(h), h);\n\nCompile.installConfigHeader has had its second argument removed and now uses\nthe value of include_path as its sub path, for parity with\nModule.addConfigHeader. Use artifact.installHeader(config_h.getOutput(),\n\"foo.h\") if you want to set the sub path to something different.\n\nsample_code\n\n    \n    \n    lib.installConfigHeader(avconfig_h, .{});\n\n\u2193\n\nsample_code\n\n    \n    \n    lib.installConfigHeader(avconfig_h);\n\nCompile.installHeadersDirectory/installHeadersDirectoryOptions have been\nconsolidated into Compile.installHeadersDirectory, which takes a LazyPath and\nallows exclude/include filters just like InstallDir.\n\nsample_code\n\n    \n    \n    lib.installHeadersDirectoryOptions(.{ .source_dir = upstream.path(\"\"), .install_dir = .header, .install_subdir = \"\", .include_extensions = &.{ \"zconf.h\", \"zlib.h\", }, });\n\n\u2193\n\nsample_code\n\n    \n    \n    lib.installHeadersDirectory(upstream.path(\"\"), \"\", .{ .include_extensions = &.{ \"zconf.h\", \"zlib.h\", }, });\n\n  * [Breaking] b.addInstallHeaderFile now takes a LazyPath.\n  * [Breaking] As a workaround for resurrect emit-h, the generated -femit-h header is now never emitted even when the user specifies an override for h_dir. If you absolutely need the emitted header, you now need to do install_artifact.emitted_h = artifact.getEmittedH() until -femit-h is fixed.\n  * Added WriteFile.addCopyDirectory, which functions very similar to InstallDir.\n  * InstallArtifact has been updated to install the bundled headers alongide the artifact. The bundled headers are installed to the directory specified by h_dir (which is zig-out/include by default).\n\n### dependencyFromBuildZig \u00a7\n\nGiven a struct that corresponds to the build.zig of a dependency,\nb.dependencyFromBuildZig returns that same dependency. In other words, if you\nhave already a @imported a depdency's build.zig, you can use this function to\nobtain the corresponding Dependency:\n\nsample_code\n\n    \n    \n    // in consumer build.zig const foo_dep = b.dependencyFromBuildZig(@import(\"foo\"), .{});\n\nThis function is also important for packages that expose functions from their\nbuild.zig files that need to use their corresponding Dependency (for example,\nfor package-relative paths, or for running system commands and returning the\noutput as lazy paths). This would be accomplished through:\n\nsample_code\n\n    \n    \n    // in dependency build.zig pub fn getImportantFile(b: *std.Build) std.Build.LazyPath { const this_dep = b.dependencyFromBuildZig(@This(), .{}); return this_dep.path(\"file.txt\"); } // in consumer build.zig const file = @import(\"foo\").getImportantFile(b);\n\n## Compiler \u00a7\n\n### x86 Backend \u00a7\n\nThe x86 backend is now passing 1765/1828 (97%) of the behavior test suite,\ncompared to the LLVM backend. It is far enough along that it is sometimes\nuseful while developing, mainly due to the fact that it offers dramatically\nfaster compilation speed:\n\n    \n    \n    Benchmark 1 (8 runs): zig-0.12.0 build-exe hello.zig measurement mean \u00b1 \u03c3 min ... max outliers delta wall_time 667ms \u00b1 26.7ms 643ms ... 729ms 1 (13%) 0% peak_rss 175MB \u00b1 19.3MB 168MB ... 223MB 1 (13%) 0% cpu_cycles 3.42G \u00b1 532M 3.21G ... 4.74G 1 (13%) 0% instructions 6.20G \u00b1 1.05G 5.83G ... 8.79G 1 (13%) 0% cache_references 241M \u00b1 19.9M 234M ... 291M 1 (13%) 0% cache_misses 48.3M \u00b1 1.26M 47.7M ... 51.4M 1 (13%) 0% branch_misses 35.3M \u00b1 4.07M 33.7M ... 45.4M 1 (13%) 0% Benchmark 2 (26 runs): zig-0.12.0 build-exe hello.zig -fno-llvm -fno-lld measurement mean \u00b1 \u03c3 min ... max outliers delta wall_time 196ms \u00b1 5.77ms 187ms ... 208ms 0 ( 0%) \u26a1- 70.6% \u00b1 1.7% peak_rss 88.7MB \u00b1 721KB 87.8MB ... 90.4MB 2 ( 8%) \u26a1- 49.3% \u00b1 4.3% cpu_cycles 842M \u00b1 6.01M 836M ... 866M 1 ( 4%) \u26a1- 75.4% \u00b1 6.0% instructions 1.60G \u00b1 9.62K 1.60G ... 1.60G 0 ( 0%) \u26a1- 74.1% \u00b1 6.5% cache_references 56.6M \u00b1 378K 56.0M ... 57.3M 0 ( 0%) \u26a1- 76.6% \u00b1 3.2% cache_misses 8.43M \u00b1 104K 8.30M ... 8.79M 2 ( 8%) \u26a1- 82.5% \u00b1 1.0% branch_misses 7.20M \u00b1 30.2K 7.15M ... 7.28M 2 ( 8%) \u26a1- 79.6% \u00b1 4.4%\n\nThis backend can be accessed when compiling for an x86_64 target by passing\nthe CLI options -fno-llvm -fno-lld, or by setting the build system flags\nuse_llvm and use_lld on std.Build.Step.Compile to false. This backend is now\nable to compile many Zig projects, including the compiler itself.\n\nRemaining tasks until it can be selected by default instead of LLVM for debug\nbuilds:\n\n  * 100% behavior tests passing\n  * Improved debug info\n  * Improved runtime performance\n\n## Windows Resources \u00a7\n\nZig now supports compiling (and cross-compiling) Windows resource scripts (.rc\nfiles) and .manifest files, and linking the resulting .res files into the\nresource table of PE/COFF binaries.\n\n  * Add a .rc -> .res compiler to the Zig compiler\n  * Add zig rc subcommand, a (cross-platform) drop-in replacement for rc.exe\n  * Add preliminary support for Windows .manifest files\n\nSee Zig is now also a Windows resource compiler for some use-cases of this\nfeature and details of how to use it.\n\n## Linker \u00a7\n\nZig now supports ELF linking for x86_64, aarch64, and partial support for\nriscv64.\n\nDependency on LLD is expected to be dropped during the next release cycle.\n\nThe -fno-lld flag can be used to use Zig's linker where it is not currently\nthe default.\n\n## Cache System \u00a7\n\nThis rather annoying bug is fixed now: error: StreamTooLong when recompiling;\nduplicate source files in cache manifest\n\nThe fix, which deduplicates files listed in the cache manifest, makes cache\nhits significantly faster. Data point: cache hit building hello world with\nstatic musl libc\n\n    \n    \n    Benchmark 1 (61 runs): master/zig build-exe hello.c -target native-native-musl -lc measurement mean \u00b1 \u03c3 min ... max outliers delta wall_time 81.4ms \u00b1 1.76ms 77.7ms ... 87.1ms 1 ( 2%) 0% peak_rss 64.6MB \u00b1 77.7KB 64.4MB ... 64.7MB 0 ( 0%) 0% cpu_cycles 97.2M \u00b1 1.04M 95.1M ... 101M 1 ( 2%) 0% instructions 153M \u00b1 11.1K 152M ... 153M 0 ( 0%) 0% cache_references 2.21M \u00b1 97.1K 2.05M ... 2.54M 2 ( 3%) 0% cache_misses 529K \u00b1 24.4K 486K ... 600K 4 ( 7%) 0% branch_misses 409K \u00b1 6.45K 397K ... 437K 1 ( 2%) 0% Benchmark 2 (189 runs): cache-dedup/zig build-exe hello.c -target native-native-musl -lc measurement mean \u00b1 \u03c3 min ... max outliers delta wall_time 25.8ms \u00b1 1.26ms 23.9ms ... 30.7ms 11 ( 6%) \u26a1- 68.4% \u00b1 0.5% peak_rss 65.2MB \u00b1 61.8KB 65.1MB ... 65.4MB 2 ( 1%) \ud83d\udca9+ 1.0% \u00b1 0.0% cpu_cycles 41.2M \u00b1 608K 40.1M ... 46.3M 4 ( 2%) \u26a1- 57.6% \u00b1 0.2% instructions 64.3M \u00b1 12.6K 64.3M ... 64.4M 2 ( 1%) \u26a1- 57.8% \u00b1 0.0% cache_references 1.28M \u00b1 34.5K 1.21M ... 1.35M 0 ( 0%) \u26a1- 41.9% \u00b1 0.7% cache_misses 348K \u00b1 18.6K 297K ... 396K 0 ( 0%) \u26a1- 34.2% \u00b1 1.1% branch_misses 199K \u00b1 1.34K 197K ... 206K 6 ( 3%) \u26a1- 51.2% \u00b1 0.2%\n\n## Bug Fixes \u00a7\n\nFull list of the 502 bug reports closed during this release cycle.\n\nMany bugs were both introduced and resolved within this release cycle. Most\nbug fixes are omitted from these release notes for the sake of brevity.\n\n### Comptime Pointer Access \u00a7\n\nZig has had several long-standing bugs relating to accessing pointers at\ncompile time. When attempting to access pointers in a non-trivial way, such as\nloading a slice of an array or reinterpreting memory, you would at times be\ngreeted with a false positive compile error stating that the comptime\ndereference required a certain type to have a well-defined layout.\n\nThe merge of #19630 resolves this issue. In Zig 0.12.0, the compiler should no\nlonger emit incorrect compile errors when doing complex things with comptime\nmemory. This change also includes some fixes to the logic for comptime\n@bitCast; in particular, bitcasting aggregates containing pointers no longer\nincorrectly forces the operation to occur at runtime.\n\n### This Release Contains Bugs \u00a7\n\nZig has known bugs and even some miscompilations.\n\nZig is immature. Even with Zig 0.12.0, working on a non-trivial project using\nZig will likely require participating in the development process.\n\nWhen Zig reaches 1.0.0, Tier 1 Support will gain a bug policy as an additional\nrequirement.\n\n## Toolchain \u00a7\n\n### LLVM 17 \u00a7\n\nThis release of Zig upgrades to LLVM 17.0.6.\n\nZig now generates LLVM bitcode module files directly and then passes those to\nLLVM. This means that a Zig compiler built without LLVM libraries can still\nproduce .bc files, which can then be passed to clang for compilation.\n\n### musl 1.2.4 \u00a7\n\nAlthough musl v1.2.5 is now available upstream, this version of Zig continues\nto provide v1.2.4. The next release of Zig is expected to have the updated\nmusl.\n\n### glibc 2.38 \u00a7\n\nglibc versions 2.35, 2.36, 2.37, and 2.38 are now available when cross-\ncompiling.\n\n### mingw-w64 \u00a7\n\nBased on a suggestion from Martin Storsj\u00f6, Zig now tracks the latest master\nbranch commit of mingw-w64.\n\n## Roadmap \u00a7\n\nThe major theme of the 0.13.0 release cycle will be compilation speed.\n\nSome upcoming milestones we will be working towards in the 0.13.0 release\ncycle:\n\n  * Making the x86 Backend the default backend for debug mode.\n  * Linker support for COFF. Eliminate dependency on LLD.\n  * Enabling incremental compilation for fast rebuilds.\n  * Introduce Concurrency to semantic analysis to further increase compilation speed.\n\nThe idea here is that prioritizing faster compilation will increase\ndevelopment velocity on the Compiler itself, leading to more bugs fixed and\nfeatures completed in the following release cycles.\n\nIt also could potentially lead to language changes that unblock fast\ncompilation.\n\n### Async/Await Feature Status \u00a7\n\nAsync functions regressed with the release of 0.11.0 (the previous release to\nthis one). Their future in the Zig language is unclear due to multiple\nunsolved problems:\n\n  * LLVM's lack of ability to optimize them.\n  * Third-party debuggers' lack of ability to debug them.\n  * The cancellation problem.\n  * Async function pointers preventing the stack size from being known.\n\nThese problems are surmountable, but it will take time. The Zig team is\ncurrently focused on other priorities.\n\n## Thank You Contributors! \u00a7\n\nHere are all the people who landed at least one contribution into this\nrelease:\n\n  * Andrew Kelley\n  * Jakub Konka\n  * Jacob Young\n  * Matthew Lugg\n  * Robin Voetter\n  * Igor Ani\u0107\n  * Ryan Liptak\n  * Veikka Tuominen\n  * antlilja\n  * Carl \u00c5stholm\n  * Luuk de Gram\n  * Michael Dusan\n  * Dominic\n  * Krzysztof Wolicki\n  * Casey Banner\n  * Ali Chraghi\n  * Nameless\n  * Ian Johnson\n  * David Rubin\n  * Meghan Denny\n  * Marc Tiehuis\n  * Techatrix\n  * Xavier Bouchoux\n  * Bogdan Romanyuk\n  * Pat Tullmann\n  * Frank Denis\n  * Tristan Ross\n  * Loris Cro\n  * Stephen Gregoratto\n  * xdBronch\n  * Evan Haas\n  * John Schmidt\n  * Ryan Zezeski\n  * expikr\n  * Elaine Gibson\n  * MrDmitry\n  * e4m2\n  * Adam Goertz\n  * Jan Philipp Hafer\n  * Jay Petacat\n  * Jonathan Marler\n  * Travis Staloch\n  * Wooster\n  * XXIV\n  * joadnacer\n  * Jae B\n  * Kai Jellinghaus\n  * Linus Groh\n  * frmdstryr\n  * Garrett Beck\n  * Josh Wolfe\n  * Karl Seguin\n  * Sahnvour\n  * february cozzocrea\n  * fn \u2303 \u2325\n  * Carter Snook\n  * Eric Joldasov\n  * Erik Arvstedt\n  * Gordon Cassie\n  * HydroH\n  * JustinWayland\n  * Lucas Santos\n  * Luis C\u00e1ceres\n  * Motiejus Jak\u0161tys\n  * Nguy\u1ec5n Gia Phong\n  * Paul Berg\n  * Pavel Verigo\n  * Piotr Szlachciak\n  * Prokop Rand\u00e1\u010dek\n  * Ratakor\n  * Stevie Hryciw\n  * SuperAuguste\n  * Zachary Raineri\n  * amp-59\n  * garrisonhh\n  * Alex Kladov\n  * Ben Crist\n  * Eric Eastwood\n  * Jan200101\n  * Jari Vetoniemi\n  * Jeremy Volkman\n  * Kang Seonghoon\n  * Manlio Perillo\n  * Markus F.X.J. Oberhumer\n  * Michael Ortmann\n  * Pascal S. de Kloe\n  * Philipp L\u00fchmann\n  * Ruben Dimas\n  * Sean\n  * Tobias Simetsreiter\n  * Tom Read Cutting\n  * Tw\n  * Vlad P\u0103n\u0103zan\n  * cipharius\n  * jimying\n  * nikneym\n  * none\n  * ocrap7\n  * riverbl\n  * snoire\n  * tjog\n  * xEgoist\n  * Abhinav Gupta\n  * Adri\u00e0 Arrufat\n  * Ahmed\n  * Alex\n  * Alexander Heinrich\n  * AlliedEnvy\n  * Ambareesh \"Amby\" Balaji\n  * Amir Alawi\n  * Andre Herbst\n  * Andre Weissflog\n  * Andreas Herrmann\n  * Anubhab Ghosh\n  * Arnau\n  * Artem Kolichenkov\n  * Aven Bross\n  * Banacial\n  * Becker A\n  * Ben Sinclair\n  * Brandon Black\n  * Brandon Botsch\n  * CPestka\n  * Chadwain Holness\n  * Chris Boesch\n  * Chris Burgess\n  * Christian Flicker\n  * Christiano Haesbaert\n  * Christofer Nolander\n  * Constantin Bilz\n  * Constantin Pestka\n  * Craig O'Connor\n  * Curtis Tate Wilkinson\n  * Daniel A.C. Martin\n  * Daniel Guzman\n  * David Gonzalez Martin\n  * DilithiumNitrate\n  * Dillen Meijboom\n  * DraagrenKirneh\n  * Emil Lerch\n  * Emil Tywoniak\n  * F3real\n  * Federico Stra\n  * Felix Kollmann\n  * Gregory Anders\n  * Gregory Mullen\n  * Guillaume Wenzek\n  * Gustavo C. Viegas\n  * Hashi364\n  * Hong Shick Pak\n  * Ian Kerins\n  * Igor Sadikov\n  * IntegratedQuantum\n  * Jacob G-W\n  * James Chen-Smith\n  * Jan Weidner\n  * Jeremia Dominguez\n  * Jiacai Liu\n  * Jim Calabro\n  * Joachim Schmidt\n  * Joel Gustafson\n  * Johan Jansson\n  * John Benediktsson\n  * Jordyfel\n  * Justus Klausecker\n  * Kamil T\n  * Karl B\u00f6hlmark\n  * Khang Nguyen Duy\n  * Kirk Scheibelhut\n  * Koakuma\n  * Lateef Jackson\n  * Lauri Tirkkonen\n  * Lee Cannon\n  * Leo Emar-Kar\n  * Leonardo Gatti\n  * Lewis Gaul\n  * LinuxUserGD\n  * Littleote\n  * Liviu Dudau\n  * LordMZTE\n  * Luca Ivaldi\n  * Lucas Culverhouse\n  * Maciej 'vesim' Kuli\u0144ski\n  * Marcius\n  * Mason Remaley\n  * Matt Knight\n  * Matthew Wozniak\n  * Maximilian\n  * Michael Bradshaw\n  * Michael Lynch\n  * Michael Pfaff\n  * Michael Scott\n  * Michal Ziulek\n  * Mikko Kaihlavirta\n  * Minsoo Choo\n  * Mustafa Uzun\n  * Naboris\n  * Nan Zhong\n  * Niles Salter\n  * Nitin Prakash\n  * OK Ryoko\n  * PanSashko\n  * Paul Jimenez\n  * PauloCampana\n  * Peng He\n  * Phil Richards\n  * Prcuvu\n  * Purrie\n  * Pyry Kovanen\n  * Qusai Hroub\n  * Rafael Fern\u00e1ndez L\u00f3pez\n  * Rahul Prabhu\n  * Reokodoku\n  * Robinson Collado\n  * Roman Fro\u0142ow\n  * Ryan Barth\n  * Samuel Fiedler\n  * Samuel Nevarez\n  * Scott Schwarz\n  * Sebastien Marie\n  * Simon Brown\n  * Stefan Su\n  * Stephen Gutekanst\n  * Tim Culverhouse\n  * Tobias Simetsreiter\n  * Tomasz Lisowski\n  * Vitalijus Valantiejus\n  * Winter\n  * andrewkraevskii\n  * arbrk1\n  * bfredl\n  * binarycraft007\n  * castholm\n  * cdrmack\n  * cfillion\n  * crayon\n  * cryptocode\n  * danielsan901998\n  * davideger\n  * dbandstra\n  * dhash\n  * dundargoc\n  * emberfade\n  * hdert\n  * iwVerve\n  * jacwil\n  * jaina heartles\n  * jd\n  * leap123\n  * lockbox\n  * loris\n  * mataha\n  * melonedo\n  * mllken\n  * ndbn\n  * notcancername\n  * pancelor\n  * paoda\n  * radar roark\n  * regeliv\n  * salo-dea\n  * sammy j\n  * tinusgraglin\n  * tison\n  * vinnichase\n  * yunsh1\n  * zhylmzr\n  * \u0410\u043d\u0434\u0440\u0435\u0439 \u041a\u0440\u0430\u0435\u0432\u0441\u043a\u0438\u0439\n\n## Thank You Sponsors! \u00a7\n\nSpecial thanks to those who sponsor Zig. Because of recurring donations, Zig\nis driven by the open source community, rather than the goal of making profit.\nIn particular, these fine folks sponsor Zig for $50/month or more:\n\n  * Josh Wolfe\n  * Matt Knight\n  * Stevie Hryciw\n  * Jethro Nederhof\n  * Karrick McDermott\n  * Jos\u00e9 M Rico\n  * drfuchs\n  * Joran Dirk Greef\n  * Rui Ueyama\n  * bfredl\n  * Simon A. Nielsen Knights\n  * Stephen Gutekanst\n  * Derek Collison\n  * Daniele Cocca\n  * Rafael Batiati\n  * Aras Pranckevi\u010dius\n  * Terin Stock\n  * Lo\u00efc Tosser\n  * Kirk Scheibelhut\n  * Mitchell Hashimoto\n  * Brian Gold\n  * Paul Harrington\n  * Clark Gaebel\n  * Bun\n  * Marcus Eagan\n  * Ken Chilton\n  * Sebastian\n  * Will Manning\n  * Fulcrum Labs\n  * Alex Mackenzie at Tapestry VC\n  * Alok Parlikar\n  * Viktor Tratsevskyy\n  * johnpyp\n  * Huly\u00ae PlatformTM\n  * Reuben Dunnington\n  * Isaac Yonemoto\n  * Luuk de Gram\n  * Auguste Rame\n  * Jay Petacat\n  * Dirk de Visser\n  * Santiago Andaluz\n  * Andrew Mangogna\n  * Yaroslav Zhavoronkov\n  * Christian Wesselhoeft\n  * Anton Kochkov\n  * Max Bernstein\n  * James McGill\n  * Luke Champine\n  * AG.\u738b\u7231\u56fd\n  * Wojtek Mach\n  * Nicola Larosa\n  * Daniel Hensley\n  * cryptocode\n  * Erik M\u00e5llberg\n  * Collin Kemper\n  * Fabio Arnold\n  * Tom Read Cutting\n  * Ross Rheingans-Yoo\n  * Emily A. Bellows\n  * Justin \"J.R.\" Hill\n  * Mykhailo Tsiuptsiun\n  * Kiril Mihaylov\n  * Brett Slatkin\n  * Sean Carey\n  * Yurii Rashkovskii\n  * Benjamin Ebby\n  * Ralph Brorsen\n  * OM PropTech GmbH\n  * Alex Sergeev\n  * Pierre Curto\n  * Kemal Akkoyun\n  * Marco Munizaga\n  * Josh Ashby\n  * Chris Baldwin\n  * Malcolm Still\n  * Viktor Hellstr\u00f6m\n  * Francis Bouvier\n  * Fawzi Mohamed\n  * Alve Larsson\n  * Nicolas Goy\n  * Ian Johnson\n  * Carlos Pizano Uribe\n  * Rene Schallner\n  * Linus Groh\n  * Jinkyu Yi\n  * jake hemmerle\n  * Will Pragnell\n  * Nathan Youngman\n  * Peter Snelgrove\n  * Jeff Fowler\n  * Nate\n  * Samu\n  * foxnne\n  * Christian Gibson\n  * 11sync.net\n  * impactaky\n  * Dylan Conway\n  * Hlib Kanunnikov\n  * merkleplant\n  * Omar AlSuwaidi\n\n", "frontpage": true}
