{"aid": "40079616", "title": "DB Indexes Do Not Magically Compose", "url": "https://rtpg.co/2024/04/14/db-indexes-do-not-magically-compose/", "domain": "rtpg.co", "votes": 1, "user": "PaulHoule", "posted_at": "2024-04-18 19:02:56", "comments": 0, "source_title": "DB Indexes Do Not Magically Compose", "source_text": "DB Indexes Do Not Magically Compose\n\n  * Home\n  * About\n  * Subscribe (RSS/Email)\n\n# DB Indexes Do Not Magically Compose\n\n2024-04-14\n\nDisclaimer: as with every performance discussion, nothing beats measuring.\n\nDisclaimer 2: Metaphors are great at hiding important distinctions between two\nsituations through massive context flattening.\n\nHaving said that, metaphor time.\n\nYou have just graduated from the Very Fancy School With An Important Alumni\nNetwork. As a graduation gift, you are given two school alumni contact books:\n\n  * One is a list of alumni, sorted by the year of graduation, then sorted by their name.\n\n  * Another is a list of graduates, sorted by their current place of residence, then sorted by their name.\n\nLater on, you try and answer some questions.\n\nHow many alumni are in New York City? Easy question to answer with one of the\ncontact books!\n\nHow many alumni graduated in 1986? Again, easy question to answer!\n\nAre there any graduates by the name of Paula Plum in New York City? Easy\nquestion to answer!\n\nYou are then asked how many people who graduated in the 90s who live in New\nYork City. This is a bit trickier. You can cross reference the list of NYC\ngraduates with 10 lists of graduates from the 90s. At least they're all sorted\nby name so you can \"optimize\" a bit, and just look at the 11 lists.\n\nNow, I ask you whether, in the history of the school, anybody named Paula Plum\ngraduated from the school. Maybe you pick up the \"place of residence\" alumni\nbook and hope they don't live in Yorktown. Or you pick up the \"year of\ngraduation\" alumni book and hope that Paula Plum was a popular name in 1956.\n\nYour database indexes are just data organized in a certain order. If you have\na query that only partly aligns with a part of your index, then your database\nmight not have any choice but to look at \"everything\" to answer your\nquestions.\n\nFor example, if your alumni table has indexes on:\n\n  * (graduation_year, name)\n  * (place_of_residence, name)\n\nYou don't magically get an index on name from this! Questions that only look\nat names can still end up pretty slow, unless you also end up filtering\nsomehow by graduation_year and place_of_residence.\n\nSimilarly, if you just have indexes on name, graduation_year and\nplace_of_residence, if you query on two of those properties, a question like\n\"everyone whose name starts with C living in California\" will likely end up as\n\"get everyone whose name starts with C, then check one by one\". Or maybe\nyou'll use both indexes, but it will involve pulling a lot of data from both\ncategories.\n\nOf course, on small datasets, or queries where one property is \"sufficiently\ndistinct\" (if you only have 4 people named Paula Plum, your DB will probably\npick that index quickly), you're all golden.\n\nBut in a multi-tenant system, where almost every single query has ... AND\nowner_id = ? in it, then any index that doesn't include owner_id is likely to\nnot be carrying its own weight.\n\nFor example, imagine a document table, with title and owner_id columns and\nindividual indexes on those columns.\n\nA query like select * from document where title = 'foo' and owner_id = 32 can\nend up being resolved in a couple ways:\n\n  * Look up documents where title = 'foo' across your entire system via an index. Even though you only want one tenant's documents, you'll look for all the documents, then filter down to only that tenant's document by looking inside the document data itself (way costlier than just traversing an index).\n\n  * Look up all of the documents where owner_id = 32 via an index. Even though you only want the documents where title = 'foo', you're going to get all of this tenant's documents, then check which ones have the title you care about.\n\nIn either case you're potentially looking at a massive performance decrease in\ncases where one field is often the same across many rows (title = 'New\nDocument' for example).\n\nIf instead you made sure your indexes have your tenancy key first (on\n(owner_id, title)), then a filter via owner_id = 32 and title = 'foo' is going\nto be mostly instant! You will have already organized your data in a way\nmatching how you query it.\n\nYour DB planner does not have magic inside of it. Help it out with the right\nkind of index from the outset.\n\nPreviously:\n\n  * Type Unions Don't Always Compose Well\n  * Trying To Understand Copilot's Type Spaghetti\n  * Property Testing Stateful Code in Rust\n\nSubcribe to get an e-mail when I post something new:\n\n", "frontpage": false}
