{"aid": "40284311", "title": "The trouble of separate module atexit-stacks", "url": "https://www.luke1410.de/blog/2017/02/the-trouble-of-separate-module-atexit-stacks/", "domain": "luke1410.de", "votes": 2, "user": "Davidbrcz", "posted_at": "2024-05-07 11:27:53", "comments": 0, "source_title": "The trouble of separate module atexit-stacks", "source_text": "The trouble of separate module atexit-stacks \u2013 Luke's Blog\n\nSkip to content\n\nLuke's Blog\n\nFocusing on programming (Java/C++) and related topics.\n\n# The trouble of separate module atexit-stacks\n\nThe demo project (Visual Studio 2015 solution) demonstrating the behavior in\nthis article can be downloaded here.\n\n# Introduction\n\nUsing atexit() to specify functions to be called if an application terminates\nis quite common practice. This is especially true for libraries since the\nC-standard specified atexit()-function is a way for the library to register\nits cleanup logic without relying on the 3rd-party application to properly\ncall a specific cleanup function.\n\nThis is also what the library the author was working with did. Since the usage\nof the atexit()-function is nothing uncommon, it was quite surprising to\nobserve that obviously the cleanup handling (which got registered via the\natexit()-function) occurred after some resources were already freed when\ncompiling the code with Microsoft\u2019s Universal C runtime. In this particular\ncase, this fact resulted in the cleanup function being stuck in an endless\nloop with the result of the app never terminating.\n\n# Well known behavior of atexit()\n\nTo understand the root cause of the problem, let\u2019s first take a look at a\nsimple case of using an atexit()-registered function to stop a thread and wait\nuntil the thread terminated before the hosting application closes cleanly:\n\nC++\n\n123456789101112131415161718192021222324252627282930313233| #define\nWIN32_LEAN_AND_MEAN#include <windows.h>#include <iostream>static int\nthreadCounter = 0;static HANDLE handle = nullptr;static bool running =\ntrue;static void terminateThread(void){running =\nfalse;WaitForSingleObject(handle, INFINITE);std::cout << \"done waiting -\ncounter is: \" << threadCounter << \"\\n\";}static DWORD WINAPI\ndummy_worker(void*){threadCounter++;while (running) { Sleep(1000);\n}threadCounter--;return 0;}int main(void){atexit(&terminateThread);handle =\nCreateThread(NULL, 0, &dummy_worker, nullptr, 0, nullptr);Sleep(100);return\n0;}  \n---|---  \n  \n(Sidenote on this code: The code is kept as simple as possible to demonstrate\nthe actual problem. The fact that it\u2019s not really thread-safe is not relevant\nfor this topic.)\n\nAs we see, the test case is quite simple. main() spawns a simple worker thread\n(dummy_worker()) which increments a threadCounter when it\u2019s started, waits\nuntil running is set to false just to decrement the threadCounter again. In\nmain() we register the terminateThread()-function using atexit() so to make\nsure that we cleanly shut down the running thread. To do that,\nterminateThread() sets running to false and waits until the thread got\nsignaled (i.e. terminated) via WaitForSingleObject() just to print out the\ncurrent thread counter value (which we certainly expect to be 0 at this\npoint). Right before we return from main() we give the thread some time to\nensure it\u2019s started.\n\nRunning this app, we see it behaves as we expected and get the output: done\nwaiting \u2013 counter is: 0\n\nNo big surprise here.\n\n# atexit() and DLLs\n\nNow let\u2019s make things a bit more interesting and move that code inside a DLL\n(into the startThread()-function) and call that from the application\u2019s\nmain()-function.\n\napplication main()\n\nC++\n\n12345678910| #define WIN32_LEAN_AND_MEAN#include <windows.h>#include\n\"testdll.h\"int main(void){startThread();Sleep(100);return 0;}  \n---|---  \n  \nDLL code\n\nC++\n\n12345678910111213141516171819202122232425262728293031| #define\nWIN32_LEAN_AND_MEAN#include <windows.h>#include <iostream>static int\nthreadCounter = 0;static HANDLE handle = nullptr;static bool running =\ntrue;static void terminateThread(void){running =\nfalse;WaitForSingleObject(handle, INFINITE);std::cout << \"done waiting -\ncounter is: \" << threadCounter << \"\\n\";}static DWORD WINAPI\ndummy_worker(void*){threadCounter++;while (running) { Sleep(1000);\n}threadCounter--;return 0;}void\nstartThread(void){atexit(&terminateThread);handle = CreateThread(NULL, 0,\n&dummy_worker, nullptr, 0, nullptr);}  \n---|---  \n  \nCertainly we expect to see the same behavior we saw before. So let\u2019s get the\nconsole output: \u201cdone waiting \u2013 counter is: 1\u201d\n\nThis is not quite what we expected to see. In the end we did cleanly terminate\nthe thread... Or didn\u2019t we?\n\n# Understanding what\u2019s going on\n\nTo get a better feeling of what\u2019s going on here, let\u2019s add some debug output.\n\n  1. We add another atexit()-registered function (in the application\u2019s main()-function).\n  2. We add some output to DllMain() to see how attaching and detaching of threads/processes works.\n  3. We print out the state of returning from main() right before it returns.\n  4. We add some output at the start of the terminateThread()-function.\n\napplication main()\n\nC++\n\n1234567891011121314151617181920| #define WIN32_LEAN_AND_MEAN#include\n<windows.h>#include <iostream>#include \"testdll.h\"void\natExitMainPorcess(void){std::cout << \"atExitMainProcess\\n\";}int\nmain(void){atexit(&atExitMainPorcess);startThread();Sleep(100);std::cout <<\n\"returning from process main\\n\";return 0;}  \n---|---  \n  \nDLL code\n\nC++\n\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051|\nstatic int threadCounter = 0;static HANDLE handle = nullptr;static bool\nrunning = true;static void terminateThread(void){std::cout << \"terminating\nthread\\n\";running = false;WaitForSingleObject(handle, INFINITE);std::cout <<\n\"done waiting - counter is: \" << threadCounter << \"\\n\";}static DWORD WINAPI\ndummy_worker(void*){threadCounter++;while (running) { Sleep(1000);\n}threadCounter--;return 0;}void\nstartThread(void){atexit(&terminateThread);handle = CreateThread(NULL, 0,\n&dummy_worker, nullptr, 0, nullptr);}BOOL APIENTRY DllMain( HMODULE\nhModule,DWORD ul_reason_for_call,LPVOID lpReserved){switch\n(ul_reason_for_call){case DLL_PROCESS_ATTACH:std::cout << \"process\nattach\\n\";break;case DLL_THREAD_ATTACH:std::cout << \"thread\nattach\\n\";break;case DLL_THREAD_DETACH:std::cout << \"thread\ndetach\\n\";break;case DLL_PROCESS_DETACH:std::cout << \"process\ndetach\\n\";break;}return TRUE;}  \n---|---  \n  \nRunning that code, we get the following output (numbers represent line numbers\nfor reference): 1: process attach 2: thread attach 3: returning from process\nmain 4: atExitMainProcess 5: process detach 6: terminating thread 7: done\nwaiting \u2013 counter is: 1\n\nWe see that atExitMainProcess() gets called after main() returns, followed by\nthe process detach signal the DLL got, followed by the call to\nterminateThread() which we registered in the DLL via atexit().\n\nThis gives us two interesting hints:\n\n  1. there is no output for the detaching of the thread\n  2. the atexit()-registered function of the DLL is called after the atexit()-registered function from the main process\n\n# Digging into the depths\n\nTo understand the first part, we\u2019ve to know that terminating a process issues\na call to ExitProcess() in the VS runtime if the process returned from main().\n[1] The first thing ExitProcess() does is to terminate all threads of the\nprocess (excluding the calling thread) WITHOUT receiving a DLL_THREAD_DETACH\nnotification. [2] That explains the fact that we do not receive the thread\ndetach output. Keep in mind the following additional facts to understand the\nconclusion further down:\n\n  * after threads were terminated, they become signaled\n  * for all DLLs the process-detach notification is sent (that corresponds to line 5 in the output) Note, that before that step in the ExitThread() processing, the atexit()-registered function in main() was called (output: line 4)\n\nLet\u2019s keep these facts in mind and take a look at the second part now:\n\nWe got the output from the process\u2019 atexit()-registered function BEFORE the\noutput of the function we registered via the atexit()-call in startThread(),\neven though atexit() is defined to run the registered functions in LIFO order\n[3]. So why did we not get the call to terminateThread() before\natExitMainProcess() was called?\n\nThe explanation is that in the VC runtime each module (i.e. each DLL and each\nprocess) has its own separate atexit-stack (as Dough Harrison explains in\nthese threads [4/8]). This minor detail makes a fundamental difference in this\nscenario because it means that the order of the registered atexit()-functions\nis not only dependent on the order of atexit()-calls, but also in which\ncontext (i.e. module) they got called.\n\n# Understanding the behavior\n\nNow we got to the point of understanding what is going on here.\n\n  1. Upon the process termination, the process\u2019 atexit()-function stack is processed (ouput: line 4).\n  2. ExitProcess() is called and terminates our thread without the thread-detach notification.\n  3. The thread is signaled.\n  4. The process detached notification is sent to the DLL (output: line 5).\n  5. The DLL is unloaded and processes its own atexit()-function-stack which calls our terminateThread() function (output: line 6).\n  6. The call to WaitForSingleObject() returns immediately (since the thread got signaled already).\n\nHence, we end up with threadCounter still being set to 1.\n\n# What the standard says\n\nThe question would arise whether this behavior actually violates the C or C++\nstandard. As far as the author can determine there is no violation of the\nstandard. Actually it turns out that the termination of threads prior to their\natexit()-functions being called is to prevent undefined behavior as it\u2019s\nspecified in the standard itself [5] which explicitly states that threads can\nbe terminated prior to the execution of std::atexit registered functions in\norder to prevent undefined behavior. This is particular noted to allow thread\nmanagers as static-storage-duration objects.\n\nOn the other side the specification of atexit() [6/7] doesn\u2019t prevent the\nusage of different atexit()-function-stacks per module. So again, there\u2019s no\nstandard violation here.\n\nThat said: It\u2019s an implementation detail that there are multiple different\natexit-stacks and it\u2019s also an implementation detail when the atexit-functions\nare called in relation to when threads are terminated.\n\n# How developers can deal with the facts\n\nFor library developers it seems that there are limited options to cope with\nthe situation. Here\u2019s a list of possible approaches to compensate for the\ndifference in when atexit()-registered functions are called:\n\n  * ensure your cleanup code actually handles the scenarios where resources were freed already prior to the cleanup function having been called\n  * do not use atexit() at all (or at least not in the context of DLLs) but rather provide your own cleanup function which is documented to be required to be called by 3rd-party applications utilizing your library to ensure proper resource cleanup\n  * do not provide means to do explicit cleanup, but rather leave that task with the OS (which implicitly will cleanup resources eventually)\n\n# Conclusion\n\nThe combination of using separate per module atexit-stacks and the fact that\nthreads which are registered from a module are killed (without notifications)\nprior to the module\u2019s atexit()-registered functions having been called, makes\nthe usage of atexit()-registered functions kind of unsuitable in situations\nwithout complete control about how the code is utilized (i.e. in libraries).\n\nThe lack of explicit requirements from the C/C++ standard in this regards,\nwhich might have been intentional and done that way for completely valid and\nsound reasons (which however would be beyond the author\u2019s knowledge) does not\nhelp much with the situation unfortunately. It also raises the question\nwhether this behavior makes sense from a design point of view and whether such\na behavior doesn\u2019t defeat the purpose of the atexit-design/-purpose (and\ntherefore could be argued to be a defect in the standard).\n\nThe usage of per module exit stacks is at least questionable in the opinion of\nthe author, because as it stands, at least for platform and compiler\nindependent library development the lack of an explicit requirement in the\nstandard adds additional complexity to the design requirements of functions\nbeing utilized via atexit()-calls.\n\n# Acknowledgments\n\nThe author would like to thank Branko \u010cibej and Bert Huijben for their\ncontributions in investigating the topic and sharing their own opinions on\nthis matter.\n\n# References\n\n[1] = Windows Kits 10.0.10240.0 source code: ucrt/startup/exit.cpp:\nexit_or_terminate_process() [2] = https://msdn.microsoft.com/en-\nus/library/windows/desktop/ms682658(v=vs.85).aspx [3] =\nhttps://msdn.microsoft.com/en-us/library/tze57ck3.aspx [4] =\nhttps://groups.google.com/d/msg/microsoft.public.vc.language/Hyyaz2Jpx-Q/t1ADCsPTikoJ\n[5] = C++ Working Draft N3242=00-0012 \u2013 3.6.3 paragraph 4 [6] = C++ Working\nDraft N3242=00-0012 \u2013 18.5 paragraph 5-8 [7] = WG14/N1256 Cinnuttee Draft \u2014\nSeptember 7, 2007 ISO/IEC 9899:TC3 \u2013 7.20.4.2 [8] =\nhttps://groups.google.com/forum/?hl=en#!msg/microsoft.public.vc.mfc/iRo37usY3vU/4Txo3KHfi0MJ\n\n## Author: luke1410\n\nStarting the experience with programming in 1989 (back then with GW-Basic and\nQBasic), Stefan studied Computer Science at the HTW Aalen (Germany). Following\nhis studies he has been working for the games industry in different areas of\ngame engines (especially focusing on the languages C++ and Lua) for 14 years\nbefore switching industries where he is primarily focusing on Java\ndevelopment. View all posts by luke1410\n\nAuthor luke1410Posted on 02/04/201706/12/2017Categories C++, ProgrammingTags\nC++\n\n## 2 thoughts on \u201cThe trouble of separate module atexit-stacks\u201d\n\n  1. yeolual says:\n\n05/20/2019 at 16:57\n\n\u0421\u043f\u0430\u0441\u0438\u0431\u043e \u0437\u0430 \u0438\u043d\u0444\u043e\u0440\u043c\u0430\u0446\u0438\u044e!!!!!\n\nReply\n\n  2. stsp says:\n\n02/08/2017 at 11:13\n\nhttp://man.openbsd.org/atexit contains some relevant notes and warnings:\n\natexit() is very difficult to use correctly without creating exit(3)-time\nraces. Unless absolutely necessary, please avoid using it.\n\nThe behavior when a shared object is unloaded is an extension to that\nstandard.\n\nReply\n\n## Leave a Reply Cancel reply\n\nThis site uses Akismet to reduce spam. Learn how your comment data is\nprocessed.\n\n## Recent Posts\n\n  * Putty 0.76\n  * Transitioning from C++ to Java\n  * Partial commits with TortoiseSVN\n  * C++ 11 Feature: nullptr\n  * Detecting invalidated iterators in Visual Studio\n\n## Recent Comments\n\n  * luke1410 on Initialization order of globals in Visual Studio.\n  * dbjdbj on Initialization order of globals in Visual Studio.\n  * dbjdbj on Initialization order of globals in Visual Studio.\n  * Igor on Initialization order of globals in Visual Studio.\n  * yeolual on The trouble of separate module atexit-stacks\n\n## Archives\n\n  * September 2021\n  * July 2020\n  * September 2019\n  * March 2019\n  * September 2018\n  * February 2017\n  * December 2016\n  * June 2015\n  * May 2015\n  * December 2009\n\n## Categories\n\n  * Administration\n  * C++\n  * Confluence\n  * Java\n  * JIRA\n  * Programming\n  * SVN\n  * Uncategorized\n\n## Meta\n\n  * Log in\n  * Entries RSS\n  * Comments RSS\n  * WordPress.org\n\nLuke's Blog Proudly powered by WordPress\n\n", "frontpage": false}
