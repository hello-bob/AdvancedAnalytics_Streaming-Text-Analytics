{"aid": "40051452", "title": "Some useful types for database-using Rust web apps", "url": "https://boinkor.net/2024/04/some-useful-types-for-database-using-rust-web-apps/", "domain": "boinkor.net", "votes": 1, "user": "todsacerdoti", "posted_at": "2024-04-16 13:11:58", "comments": 0, "source_title": "Some useful types for database-using Rust web apps", "source_text": "Some useful types for database-using Rust web apps - Andreas Fuchs\u2019 Journal\n\nSkip to main content\n\n# Andreas Fuchs' Journal\n\n# Some useful types for database-using Rust web apps\n\nI\u2019ve been writing a little web app in rust lately, and in it I decided to try\nto do it without an ORM. Instead, I modeled data access in a way that\nresembles the Data Access Layer pattern: You make a set of abstractions that\nmaps the \u201cbusiness logic\u201d to how the data is stored in the data store. Here\nare some types that I found useful in this journey so far.\n\n## The IdType trait\n\nThe first item is a very subtle little thing that I wasn\u2019t sure would work.\nBut it does, and it\u2019s really pleasing! Introducing IdType, a trait that marks\na type used for database identifiers. Say you have a struct Bookmark in sqlite\nthat is has a u64 as a primary key. What prevents you from passing\naccidentally just about any u64 (say, a user ID) into a struct and reading any\nbookmark in the database? Right, that\u2019s why we make newtypes.\n\nSo you make a newtype that wraps u64 and define your bookmark struct like\nso^1:\n\n    \n    \n    struct BookmarkId(u64); pub struct Bookmark { pub id: BookmarkId, pub url: Url, }\n\nSweet, but how do you create a new bookmark? Your database is what assigns\nthese IDs, so do you make a second struct BookmarkForInsertion and sync struct\nfields? Or do you extract the ID fields and make a struct two layers deep?\nPass all bookmark fields to an add function? All of these seemed unpleasant to\nme. Here\u2019s what I do instead:\n\n    \n    \n    pub trait IdType<T>: Copy + fmt::Display { type Id; /// Returns the inner ID. fn id(self) -> Self::Id; } #[derive(Serialize, Deserialize, PartialEq, Eq, Hash, Debug, Clone, Copy, sqlx::Type)] #[sqlx(transparent)] #[serde(transparent)] pub struct BookmarkId(i64); impl IdType<BookmarkId> for BookmarkId { type Id = i64; fn id(self) -> Self::Id { self.0 } }\n\nOK, so that\u2019s more complicated. What does that allow us to do? Let\u2019s update\nour Bookmark struct to use it:\n\n    \n    \n    pub struct Bookmark<ID: IdType<BookmarkId>> { pub id: ID, pub url: Url, // ... }\n\nSo what this does is, now you can handle \u201cexisting\u201d bookmarks like before, but\nalso you can specify that a bookmark doesn\u2019t have an ID yet:\n\n    \n    \n    pub fn update_bookmark(bm: Bookmark<BookmarkId>) { ... } // and pub fn create_bookmark(bm: Bookmark<NoId>) -> Bookmark<BookmarkId> { ... }\n\nWhat\u2019s more, the IdTrait<T> takes a type parameter that tells us what the\nexpected ID type would be. That comes into play with the NoId type above: It\u2019s\na little empty type that just says \u201cI\u2019m not an ID yet\u201d:\n\n    \n    \n    #[derive(PartialEq, Eq, Clone, Copy, Default, Serialize, Debug)] pub struct NoId; impl<T> IdType<T> for NoId { type Id = std::convert::Infallible; fn id(self) -> Self::Id { unreachable!(\"You mustn't try to access non-IDs.\"); } }\n\nSome neat things in this: One, NoId is a generic placeholder for all ID types\n- meaning a function signature can always take a struct representation of a\ndatabase object that doesn\u2019t exist in the database yet. Neat thing two, the\n\u201cinner\u201d Id can not be retrieved from it. (It doesn\u2019t exist, after all!) It\u2019s\nconvert::Infallible, the \u201cnever\u201d type, meaning any attempt at retrieving that\nID will fail at compile time. The compiler won\u2019t let us look at the IDs of\nobjects that haven\u2019t gotten any yet! One day, when the never type is\nstabilized, we can use that. In the meantime, this is equivalent enough!\n\nWhat\u2019s more, the NoId type tells serde to not expect an id field whenever you\ndeserialize a Bookmark, say from JSON input on an API route:\n\n    \n    \n    /// NoId can be deserialized from any source, even if the field is not /// present. impl<'de> Deserialize<'de> for NoId { fn deserialize<D>(_deserializer: D) -> Result<Self, D::Error> where D: Deserializer<'de>, { Ok(NoId) } }\n\nI didn\u2019t expect this pattern to work so well, but it\u2019s been extremely helpful\nin this CRUD app to not have to write multiple structs with the same (and then\nout-of-sync) fields in them; and it feels even better to do that with\nstructures that feel like the business logic needs to feel - rather than how\nthe database layout requires them to be.\n\nBut how do we use those structs? I thought we weren\u2019t making an ORM?\n\n## The read-only/read-write transaction pattern\n\nMy app is a really reasonably \u201cnormal\u201d one where a logged-in user makes a\nrequest, and that triggers one or multiple database operations, and if\neverything went right, commits any changes. That\u2019s a transaction! And what is\na transaction other than a collection of business logic that gets applied to a\ndata store?\n\nHence, the Transaction type. It wraps a lower-level (sqlite, in my case)\nTransaction handle that can\u2019t be retrieved (so code can\u2019t play with the\ndatabase directly), and exposes methods that allow code to perform operations\non the database:\n\n    \n    \n    struct Transaction { txn: sqlx::Transaction<'static, sqlx::sqlite::Sqlite>, } impl Transaction { /// Commit any changes made in the transaction. pub async fn commit(&mut self) { self.txn.commit().await; } /// Add a new bookmark and return its ID. pub async fn add_bookmark( &mut self, bm: Bookmark<NoId>, ) -> Result<BookmarkId, sqlx::Error> { // ... } /// Retrieve the bookmarks that belong to the current user. pub async fn list_bookmarks( &mut self ) -> Result<Vec<Bookmark<BookmarkId>>> { // ... } }\n\nSo that\u2019s neat! But we can get something even neater. You may have seen this\narticle about running sqlite on a server, and it recommends having two\nconnection pools: One for read-only ops and one for read-write ops. Let\u2019s make\na read-only and a read-write transaction that gets created from each of these\ntwo pools:\n\n    \n    \n    pub trait TransactionMode {} pub struct ReadOnly {} impl TransactionMode for ReadOnly {} pub struct ReadWrite {} impl TransactionMode for ReadWrite {} pub struct Transaction<M: TransactionMode = ReadWrite> { txn: sqlx::Transaction<'static, sqlx::sqlite::Sqlite>, marker: PhantomData<M>, } impl Connection { pub async fn begin_for_user( &self, user: User<UserId>, ) -> Result<Transaction<ReadWrite>, sqlx::Error> { // ... } pub async fn begin_ro_for_user( &self, user: User<UserId>, ) -> Result<Transaction<ReadOnly>, RoTransactionError> { // ... } }\n\nSo that gives us two methods - Connection::begin and Connection::begin_ro. And\nnow, it\u2019s pretty easy to split that Transaction implementation into two\nblocks, one for the read-only operation and one for the read-write one:\n\n    \n    \n    impl Transaction<ReadWrite> { /// Commit any changes made in the transaction. pub async fn commit(&mut self) { self.txn.commit().await; } /// Add a new bookmark and return its ID. pub async fn add_bookmark( &mut self, bm: Bookmark<NoId>, ) -> Result<BookmarkId, sqlx::Error> { // ... } } impl<M: TransactionMode> Transaction<M> { /// Retrieve the bookmarks that belong to the current user. pub async fn list_bookmarks( &mut self, user_id: UserId, ) -> Result<Vec<Bookmark<BookmarkId>>> { // ... } }\n\nSo the ReadWrite impl block looks reasonable, but why is the read-only block\ngeneric? That\u2019s because the method is available in both - ReadWrite and\nReadOnly modes. You could also define methods that aren\u2019t available in read-\nwrite modes - say, if they\u2019re heavyweight enough that blocking your single\nwrite-capable connection with them would be wasteful. Then you write a impl\nTransaction<ReadOnly> block and the compiler will take care of the rest - any\nmethod defined on the \u201cwrong\u201d transaction type is definitely not callable -\nthe compiler won\u2019t even be able to find it.\n\n...but the compiler will tell you that you got the wrong mode. Here\u2019s how an\nerror looks like if I accidentally call .commit() on a read-only transaction:\n\n    \n    \n    error[E0599]: no method named `commit` found for struct `DbTransaction` in the current scope --> src/lz-web/src/ui.rs:51:9 | 51 | txn.commit(); | ^^^^^^ method not found in `DbTransaction` | ::: src/lz-web/src/db.rs:45:1 | 45 | pub struct DbTransaction<M: lz_db::TransactionMode = lz_db::ReadOnly> { | --------------------------------------------------------------------- method `commit` not found for this struct | = note: the method was found for - `DbTransaction<ReadWrite>`\n\n### A neat addition: Keeping extra data on the transaction\n\nEvery operation is made by a logged-in user, and so the transaction can encode\nwho is making the request (since the authentication is checked as part of an\naxum extractor). That gives us the opportunity to always know on whose behalf\nsomething is happening, and our data access methods can add restrictions to\nthe query that ensures even faulty/manipulated input data doesn\u2019t touch\nanother user\u2019s data!\n\n    \n    \n    pub struct Transaction<M: TransactionMode = ReadWrite> { txn: sqlx::Transaction<'static, sqlx::sqlite::Sqlite>, user: User<UserId>, // <- this is new! marker: PhantomData<M>, }\n\nand... rework the methods that begin a transaction such that they require a\nusername, and you can do stuff like this:\n\n    \n    \n    impl<M: TransactionMode> Transaction<M> { /// Retrieve the bookmarks that belong to the current user. pub async fn list_bookmarks( &mut self ) -> Result<Vec<Bookmark<BookmarkId>>> { // ... query_builder.push(\"WHERE user_id = \"); query_builder.push_bind(self.user.id); // ... } }\n\nAll that, together, feels pretty neat (and honestly, not allllll that\n\u201cclever\u201d)! I have no doubt a sufficiently powerful ORM could have let me do\nthese things too, with plugins and various other generics. But doing them this\nway feels somewhat more right - defining these structs and the logic operating\non them allows for a lot of flexibility in coming up with efficient data\nrepresentations & queries, while the various niceties that the language gives\nus (automatic json representation/parsing with serde! Transaction rollback on\nearly-return!) make it feel really easy to write and maintain. I\u2019ve been\nthrough a bunch of refactors of this app already, and the basic structure has\nheld up pretty nicely.\n\n  1. Please note that approximately none of the code listed here will compile out of the box. Very sorry - this post is meant to provide a basis for a dialog with the rust compiler, not to be an entirely copy/pasteable framework; that would require a bit more boilerplate and wouldn\u2019t add much to the quality of the content. You are smart! You got this! \u21a9\ufe0e\n\n2024-04-15\n\nhttps://boinkor.net/2024/04/some-useful-types-for-database-using-rust-web-\napps/ Andreas Fuchs\n\n  * Hacks\n\n  * #rust\n\n\u00a9 Andreas Fuchs, 2024 Powered by Hugo, theme Anubis.\n\nAndreas Fuchs / asf@boinkor.net\n\n", "frontpage": false}
