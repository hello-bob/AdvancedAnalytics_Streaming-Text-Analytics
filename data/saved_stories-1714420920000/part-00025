{"aid": "40196115", "title": "Functional Semantics in Imperative Clothing (Richard Feldman)", "url": "https://rtfeldman.com/imperative-clothing", "domain": "rtfeldman.com", "votes": 7, "user": "lwboswell", "posted_at": "2024-04-29 08:56:17", "comments": 0, "source_title": null, "source_text": "# Functional Semantics in Imperative Clothing\n\nApril 29, 2024\n\nThere's an old joke about programming with pure functions:\n\n> \u201cEventually you have to do some effects. Otherwise you're just heating up\n> the CPU.\u201d\n\nI've always wanted the purely functional Roc programming language to be\ndelightful for I/O-heavy use cases. But when I recently sat down to port an\nI/O-heavy shell script from Bash to Roc, I wasn't happy with how the code\nfelt.\n\nFortunately, all it took was a bit of syntax sugar to change that. Thanks to\none little operator, purely functional I/O in Roc has now become a real\ndelight!\n\n## From Bash to Roc\n\nThe shell script in question assembles some static assets for the roc-lang.org\nwebsite. Here's part of the Bash version of the script:\n\n    \n    \n    cp -r public/ build/ # If this is set, assume we're on a build server if [ -v GITHUB_TOKEN ]; then echo 'Fetching latest roc nightly...' # Get roc release archive curl -fOL https://github.com... # Extract archive ls | grep \"roc_nightly\" | xargs tar -xzvf # Delete archive ls | grep \"roc_nightly.*tar.gz\" | xargs rm roc='./roc_nightly/roc' else # Build the `roc` CLI from source cargo build --release roc=target/release/roc fi $roc --version echo 'Building site markdown content' $roc run www/main.roc www/content/ www/build/\n\nHere's how this code can now look in Roc, thanks to the new syntax sugar that\nour awesome contributor Luke Boswell recently implemented: the ! suffix.\n\n    \n    \n    Dir.copyAll! \"public/\" \"build/\" pathToRoc = # If this is set, assume we're on a build server if Result.isOk (Env.var! \"GITHUB_TOKEN\") then Stdout.line! \"Fetching latest roc nightly...\" # Get Roc release archive filename = \"nightly.tar.gz\" Http.download! \"https://github.com...\" filename Cmd.exec! \"tar\" [\"-xzvf\", filename] # Delete archive File.removeIfExists! filename \"./roc_nightly/roc\" else # Build the `roc` CLI from source Cmd.exec! \"cargo\" [\"build\", \"--release\"] \"target/release/roc\" roc = \\args -> Cmd.exec! pathToRoc args roc! [\"--version\"] Stdout.line! \"Building site markdown content\" roc! [\"www/main.roc\", \"www/content/\", \"www/build/\"]\n\nI really like how this reads! It looks totally imperative, which is a nice fit\nfor a script that's doing lots of I/O and not much else.\n\nIn fact, it's so visually similar to the Bash version, you might not even\nguess that the Roc version desugars to a big pile of 100% statically type-\nchecked pure functions.\n\nIt's functional semantics in imperative clothing!\n\n## Desugaring the Sugar\n\nTo explain how this imperative-looking code can actually be compiling down to\nnothing but pure functions, I need to start by explaining how the ! suffix\nworks.\n\nIt's very similar to the await keyword in other languages. For example, this\nline...\n\n    \n    \n    if Result.isOk (Env.var! \"GITHUB_TOKEN\") then\n\n...might look like this in JavaScript:\n\n    \n    \n    if (Result.isOk(await Env.var(\"GITHUB_TOKEN\"))) {\n\nBefore we had the ! suffix, code like this didn't look nearly as nice. The\nclosest we had was backpassing, which was unhelpful in nested expressions;\nthis one line would probably have been two lines instead:\n\n    \n    \n    result <- Env.var \"GITHUB_TOKEN\" |> Task.await if Result.isOk result then\n\nEven when conditionals weren't involved, seeing <\\- for some assignments and =\nfor others, plus lots of |> Task.await, wasn't nearly as nice as the style we\nhave now.\n\nIt might look like a minor difference when comparing one small line to\nanother, but multplied across the whole program, the ! version of the script\nfelt much nicer.\n\nSo what does the ! suffix actually do? It basically desugars into two things:\n\n  1. A call to Task.await\n  2. An anonymous function which gets passed to that Task.await call\n\nLet's walk through an example.\n\n    \n    \n    html = Http.getUtf8! url path = Path.fromStr filename File.writeUtf8! path html Stdout.line! \"Wrote HTML to: $(filename)\"\n\nThis desugars to the following Roc code.\n\n    \n    \n    Task.await (Http.getUtf8 url) \\html -> path = Path.fromStr filename Task.await (File.writeUtf8 path html) \\_ -> Stdout.line \"Wrote HTML to: $(filename)\"\n\nIf you wanted to, you could have written the code this way and it would have\ncompiled to exactly the same program! Going line by line:\n\n    \n    \n    html = Http.getUtf8! url\n\n...becomes:\n\n    \n    \n    Task.await (Http.getUtf8 url) \\html ->\n\nThe Task.await function plays a similar role as the await keyword in other\nlanguages: it says \"wait until this Task successfully completes, then pass its\noutput to a function.\" (A Task in Roc is a value that represents an\nasynchronous effect; the Http.getUtf8 function returns a Task.)\n\nTasks can be chained together using the Task.await function, similarly to how\nJavaScript Promises can be chained together using a Promise's then() method.\n(You might also know functions in other languages similar to Task.await which\ngo by names like andThen, flatMap, or bind.)\n\nThe next line in our example was path = Path.fromStr filename, but that line\nwas unchanged since it didn't use ! at all. The next ! was in this line:\n\n    \n    \n    File.writeUtf8! path html\n\nIt desugars to:\n\n    \n    \n    Task.await (File.writeUtf8 path html) \\_ ->\n\nNotice that here, since we didn't have html = at the start (because we don't\ncare about the output of a file write), we also didn't have the named argument\n\\html -> in the function being passed to Task.await. Instead we had \\\\_ ->,\nwhich is how in Roc we write a function that ignores its argument.\n\nIt's worth noting that both Http.getUtf8 and File.writeUtf8 are operations\nthat can fail. If they do, the whole chain of tasks will short-circuit to some\nerror-handling code. That's part of what Task.await has always done, and the !\nsugar doesn't affect error handling at all.\n\nFinally, we had:\n\n    \n    \n    Stdout.line! \"Wrote HTML to: $(filename)\"\n\nThis desugars to:\n\n    \n    \n    Stdout.line \"Wrote HTML to: $(filename)\"\n\nSince this is the last task in a chain, the ! doesn't do anything and isn't\nnecessary...so we just drop it during desugaring instead of giving a compiler\nerror or generating an unnecessary Task.await. This allows for a more\nconsistent visual style, where async I/O operations always end in the !\nsuffix, but doesn't have any runtime cost.\n\n## I/O from Pure Functions\n\nEarlier I said that this style of Roc code \"desugars to a big pile of 100%\nstatically type-checked pure functions.\"\n\nThe 100% statically type-checked part is easy to explain: Roc has full type\ninference, so your types always get checked, but you never need to write type\nannotations. You can optionally add annotations anywhere you think they'll be\nhelpful, but for this shell script I didn't think they'd be worth including.\n(For Roc programs that aren't shell scripts, the common practice is to\nannotate all top-level functions and that's usually about it.)\n\nWhat about the \"all pure functions\" part? By definition, pure functions don't\nhave side effects, right? (A side effect is when a function changes some state\noutside the function itself, like a global variable or the file system.)\nSo...how can these functions be pure if all this I/O is happening?\n\nIt's surprisingly simple:\n\n  1. Each function returns a value describing what I/O it wants done.\n  2. The compiled program has a runtime which looks at those values and actually performs the I/O they describe.\n\nThere are practical benefits to separating things this way (more on those\nlater), but to illustrate what's happening behind the scenes here, let's go\nback to that example from earlier:\n\n    \n    \n    html = Http.getUtf8! url path = Path.fromStr filename File.writeUtf8! path html Stdout.line! \"Wrote HTML to: $(filename)\"\n\nWe already went through how that code desugars to this code:\n\n    \n    \n    Task.await (Http.getUtf8 url) \\html -> path = Path.fromStr filename Task.await (File.writeUtf8 path html) \\_ -> Stdout.line \"Wrote HTML to: $(filename)\"\n\nThis code in turn compiles down to something which looks similar to the\nfollowing at runtime. (I'm using JavaScript syntax here rather than Roc, which\nwill be convenient in the next example.)\n\n    \n    \n    { operation: \"Http.getUtf8\", args: [url], afterwards: (html) => { const path = Path.fromStr(filename) return { operation: \"File.writeUtf8\", args: [path, html], afterwards: () => { operation: \"Stdout.line\", args: [`Wrote HTML to ${filename}`], afterwards: () => { operation: \"done\" } } } } }\n\nNothing but nested object literals where one field is a function that returns\nanother object literal. No side effects anywhere! (This structure isn't\nexactly how Roc represents Task values in memory\u2014the operation isn't a string,\nfor example\u2014but let's go with it for simplicity's sake.)\n\n## Implementing a Runtime\n\nNow let's look at how a runtime can translate those nested object literals\ninto I/O.\n\nIn Node.js I could do this by writing a loop which:\n\n  * Starts with one of these \"Task\" values to run\n  * Looks at the task's operation field and performs the requested I/O operation\n  * Calls the function in the task's afterwards field, passing the output of that I/O operation. (This function will return another Task value.)\n  * Loops back to the start to repeat this process until we encounter a Task whose operation field is \"done\", which tells us we're done.\n\nHere's how that would look in code:\n\n    \n    \n    while task.operation != \"done\" { if task.operation == \"Http.getUtf8\" { const [url] = task.args const response = httpRequest(url) task = task.afterwards(response.text()) } else if task.operation == \"File.writeUtf8\" { const [path, content] = task.args fs.writeFileSync(path, content) task = task.afterwards() } else if task.operation == \"Stdout.line\" { const [line] = task.args console.log(line) task = task.afterwards() } }\n\nAlthough this would work, Node encourages doing asynchronous I/O instead of\nsynchronous like we've done here.\n\nFortunately, one of the benefits of representing effects as values that hold\n\"afterwards\" continuation functions like this is that the Task value can also\nbe translated into async I/O. Here's the same Node code done in an\nasynchronous callback style instead\u2014and using recursion instead of a while\nloop.\n\n    \n    \n    const interpretTask = (task) => { if task.operation == \"Http.getUtf8\" { const [url] = task.args fetch(url, (response) => { const text = response.text() const nextTask = task.afterwards(text) return interpretTask(nextTask) }) } else if task.operation == \"File.writeUtf8\" { const [path, content] = task.args fs.writeFile(path, content, () => { const nextTask = task.afterwards() return interpretTask(nextTask) }) } else if task.operation == \"Stdout.line\" { const [line] = task.args console.log(line) const nextTask = task.afterwards() return interpretTask(nextTask) } else if task.operation == \"done\" { // Don't recurse. We're done! } }\n\nThe actual I/O can be implemented in any number of styles. Promises, for\nexample. Or async/await. Outside of JavaScript, it could be done with high-\nperformance low-level async I/O operating system primitives like io_uring in\nC, Zig, or Rust\u2014including inside async runtimes like Tokio.\n\nSeparating these I/O descriptions from the runtime that performs the actual\nI/O lets you drop in whatever async I/O runtime system you want, without\nhaving to change your application code at all!\n\nIn fact, one of the main motivations for representing effects as values like\nthis is so that future Roc platforms can do all this \"traversing the data\nstructure\" work behind the scenes to quietly give you excellent async I/O\nperformance that's potentially even tailored to a particular domain (e.g. web\nservers, CLIs, games), while your application code gets to look as\nstraightforward as it would in any imperative language:\n\n    \n    \n    html = Http.getUtf8! url path = Path.fromStr filename File.writeUtf8! path html Stdout.line! \"Wrote HTML to: $(filename)\"\n\nPlatform authors can also use this representation to offer features like \"dry-\nrun mode\" in which all the requests for disk I/O are performed on a fake in-\nmemory filesystem (perhaps using the current state of the real filesystem for\nits initial structure) so that scripts can be tried out without their \"I/O\noperations\" affecting the actual disk. Or automatic logging of all I/O\noperations, with the application code specifying the logging system to use.\nThe list goes on!\n\nBesides platforms being able to apply different I/O runtimes to the same\napplication, the functional semantics underneath the sugar have benefits for\napplication authors too. For example, they unlock nicer testability.\n\n## Testability\n\nWe've seen how individual functions can be pure while resulting in an overall\nprogram that does I/O. But at the end of the day, if the code is just\nresulting in the I/O being performed anyway, what could possibly make it\neasier to test?\n\nThe key is that we can run a test on the value being returned, instead of\nhanding it off to the runtime. That means no actual I/O gets performed, and\nthe test is completely deterministic\u2014yet all of the actual logic around the\nI/O can be tested!\n\nFor example, here's a test I can write using only Task values:\n\n    \n    \n    expect task.operation == \"Http.getUtf8\" expect task.args == [\"example.com/something\"] fakeResponse = \"<html><body>testing!</body></html>\" next = task.afterwards [fakeResponse] expect next.operation == \"writeUtf8\" expect answer.args == [filename, fakeResponse]\n\nThis test will run extremely quickly, and it will never flake. All it does is\nlook at values!\n\nI could also write a property test to randomly run this a bunch of times with\nrandom inputs and verify that (for example) no matter what lines are in the\nfiles, the output has commas there instead. I could simulate that a third-\nparty server I have no control over is timing out, or returning 500 errors,\nand verify that my application is handling that correctly...all without\nactually contacting that server!\n\n(By the way, you can already write tests in Roc using the built-in expect\nkeyword and the roc test CLI command, although writing simulation-style tests\nof Tasks relies on a language feature that hasn't been fully implemented yet.\nI plan to write about that after it ships!)\n\nOf course, many programming languages have ways to test logic without actually\nrunning I/O, such as monkey patching, mocking, and so on. What I like about\nthis \"simulation\" style is that I don't have to guess which APIs need to be\nmonkey patched, I don't have to make my implementation more generic than I\nwant it to be (just so I can swap in doubles for testing), and the simulation\nworks just fine even if third-party packages are involved in assembling the\nTask values.\n\nTo be fair, any language can benefit from representing effects as values\nwithout going as far as to make all functions in the language pure, but there\nare separate practical benefits to having all functions be pure. Some of the\nother benefits take longer to explain than testability, so I'll stick to just\nthat one example in this article...but I'd like to write more about some of\nthe others in the future!\n\n## Trying Out Roc\n\nIf you're intrigued by this \"functional semantics in imperative clothing\" idea\nand want to give Roc a try for yourself, the tutorial is the easiest way to\nget up and running. It takes you from no Roc experience whatsoever to building\nyour first program, while explaining language concepts along the way.\n\nI also highly recommend dropping in to say hi on Roc Zulip Chat. There are\nlots of friendly people on there, and we love to help beginners get started\nwith the language!\n\nFinally, if you'd like to meet up with a bunch of Roc enthusiasts in person,\nthere will be 3 different Roc talks at Software You Can Love 2024 in Milan\nthis May, and we expect it to be the largest in-person gathering of Roc\nprogrammers to date. It's going to be amazing!\n\n", "frontpage": true}
