{"aid": "40214692", "title": "Rama is a testament to the power of Clojure", "url": "https://blog.redplanetlabs.com/2024/04/30/rama-is-a-testament-to-the-power-of-clojure/", "domain": "redplanetlabs.com", "votes": 22, "user": "winkywooster", "posted_at": "2024-04-30 18:48:32", "comments": 0, "source_title": "Rama is a testament to the power of Clojure", "source_text": "Rama is a testament to the power of Clojure \u2013 Blog\n\nSkip to content\n\nBlog\n\n# Rama is a testament to the power of Clojure\n\nApril 30, 2024 ~ Nathan Marz\n\nIt took more than ten years of full-time work for Rama to go from an idea to a\nproduction system. I shudder to think of how long it would have taken without\nClojure.\n\nRama is a programming platform that integrates and generalizes backend\ndevelopment. Whereas previously backends were built with a hodgepodge of\ndatabases, application servers, queues, processing systems, deployment tools,\nmonitoring systems, and more, Rama can build end-to-end backends at any scale\non its own in a tiny fraction of the code. At its core is a new programming\nlanguage implementing a new programming paradigm, at the same level as the\n\u201cobject-oriented\u201d, \u201cimperative\u201d, \u201clogic\u201d, and \u201cfunctional\u201d paradigms. Rama\u2019s\nClojure API gives access to this new language directly, and Rama\u2019s Java API is\na thin wrapper around a subset of this language.\n\nThere\u2019s a lot in Clojure\u2019s design that\u2019s been instrumental to developing Rama.\nThree things stand out in particular: its flexibility for defining\nabstractions, its emphasis on immutability, and its orientation around\nprogramming with plain data structures. Besides these being essential to\nmaintaining simplicity in Rama\u2019s implementation, Rama also embraces these\nprinciples in its approach to distributed programming and indexing.\n\n## Ability to do in libraries what requires language support in other\nlanguages\n\nRama\u2019s language is Turing-complete and defined largely via Clojure macros. So\nit\u2019s still Clojure, but its semantics are different in many fundamental ways.\nAt its core, Rama generalizes the concept of a function into something called\na \u201cfragment\u201d. Whereas a function works by taking in any number of input\nparameters and then returning a single value as the last thing it does, a\nfragment can output many times (called \u201cemitting\u201d), can output to multiple\n\u201coutput streams\u201d, and can do more work between or after emitting. A function\nis just a special case of a fragment. Rama fragments compile to efficient\nbytecode, and fragments that happen to be functions execute just as\nefficiently as functions in Java or Clojure.\n\nEven though Rama contains this new programming language implementing this new\nprogramming paradigm, it\u2019s still Clojure. So it interoperates perfectly. Rama\ncode can invoke Clojure code directly, and Clojure code can invoke Rama\ndirectly as well. There\u2019s no friction between them. Rama itself is implemented\nin a mixture of regular Clojure code and Rama code.\n\nNeither Rich Hickey nor John McCarthy ever envisioned this completely\ndifferent programming paradigm being built within their abstractions, much\nless one that reformulates the basis of nearly every programming language (the\nfunction). They didn\u2019t need to. Clojure, along with its Lisp predecessors, are\nlanguages that put almost no limitations on your ability to form abstractions.\nWith every other language you at least have to conform to their syntax and\nbasic semantics, and you have limited ability to control what happens at\ncompile-time versus runtime. Lisps have great control over what happens at\ncompile-time, which lets you do incredible things.\n\nLisp programmers have struggled ever since it was invented to explain why this\nis so powerful and why this has a major impact on simplifying software\ndevelopment. So I won\u2019t try to explain how powerful this is in general and\nwill focus on how instrumental it was for Rama. I\u2019ll instead point you to Paul\nGraham\u2019s essay \u201cBeating the Averages\u201d, which was the essay that first inspired\nme to learn Lisp back when I was in college. When I first read that essay I\ndidn\u2019t understand it completely, but I was particularly compelled by the lines\n\u201cA big chunk of our code was doing things that are very hard to do in other\nlanguages. The resulting software did things our competitors\u2019 software\ncouldn\u2019t do. Maybe there was some kind of connection.\u201d\n\nThe new language at Rama\u2019s core is an example of this. Other languages can\nonly have multiple fundamentally different paradigms smoothly interoperating\nif designed and implemented at the language level. Otherwise, you have to\nresort to string manipulation (as is done with SQL), which is not smooth and\ncreates a mess of complexity. No amount of abstraction can hide this\ncomplexity completely, and attempting to often creates new complexities (like\nORMs).\n\nWith Clojure, you can do this at the library level. We required no special\nlanguage support and built Rama on top of Clojure\u2019s basic primitives.\n\nRama\u2019s language is not our only example of mixing paradigms like this. Another\nexample is Specter. Specter is a generically useful library for querying and\nmanipulating data structures. It\u2019s also a critical part of Rama\u2019s API (since\nviews in Rama, called PStates, are durable data structures of any\ncomposition), and it\u2019s a critical part of Rama\u2019s implementation. About 1% of\nthe lines of code in Rama\u2019s source and tests are Specter callsites.\n\nYou can define Specter\u2019s abstractions in any language. What makes it special\nin Clojure is how performant it is. Queries and manipulations with Specter are\nfaster than even hand-rolled Clojure code. The key to Specter\u2019s performance is\nits inline caching and compilation system. Inline caching is a technique I\u2019ve\nonly seen used before at the language or VM level. It\u2019s a critical part of how\nthe JVM implements polymorphism, for example. Because of the flexibility of\nClojure, and the ability to program what happens at compile-time for a Specter\ncallsite, we\u2019re able to utilize the technique at the library level. It\u2019s all\ndone completely behind the scenes, and users of Specter get an expressive and\nconcise API that\u2019s extremely fast.\n\n## Power of immutability and data structure orientation\n\nClojure is unique among Lisps in the degree that it emphasizes immutability.\nIt\u2019s core API is oriented to working with immutable data structures.\nAdditionally, Clojure encourages representing program state with plain data\nstructures and having an expressive API for working with those data\nstructures. The quote \u201cIt\u2019s better to have 100 functions operate on one data\nstructure than to have 10 functions operate on 10 data structures.\u201d is part of\nClojure\u2019s rationale.\n\nThese philosophies have had a major impact on Rama\u2019s development, helping a\ntremendous amount in managing complexity within Rama\u2019s implementation. The\nless state you have to think about in a section of code, the easier it is to\nreason about. When a project gets as big as Rama (190k lines of source, 220k\nlines of tests), with many layers of abstractions and innumerable subsystems,\nit\u2019s impossible to keep even a fraction of the whole system \u201cin your head\u201d for\nreasoning. I frequently have to re-read sections of code to remind myself on\nthe details of that particular subsystem. The dividends you get from lowering\ncomplexity of the system, with immutability being a huge part of that,\ncompounds more and more the bigger the codebase gets.\n\nClojure doesn\u2019t force immutability for every situation, which is also\nimportant. Rama tracks a lot of different kinds of state, and we find it much\nsimpler in some cases to use mutability rather than work with state indirectly\nas you would through something like the State Monad in Haskell. There are also\nsome algorithms that are much simpler to write when they use a volatile\ninternal in the implementation. That said, the vast majority of code in Rama\nis written in an immutable style. When we use mutability it\u2019s almost always\nisolated within a single thread. Rather than have concurrent mutability using\nsomething like an atom, we use a volatile and send events to its owning thread\nto interact with it.\n\nRama embraces and expands upon Clojure\u2019s principles of immutability and\norienting code around data structures. These principles are fundamental to\nRama\u2019s approach for expressing end-to-end backends. A lot of Rama programming\nrevolves around materializing views (PStates), which are literally just data\nstructures interacted with using the exact same Specter API as used to\ninteract with in-memory data structures. This stands in stark contrast with\ndatabases, which have fixed data models and special APIs for interacting with\nthem. Any database can be replicated in a PState in both expressivity and\nperformance, since a data model is just a specific combination of data\nstructures (e.g. key/value is a map, column-oriented is a map of sorted maps,\ndocument is a map of maps, etc.).\n\nRama\u2019s language extends Clojure\u2019s immutable principles into writing\ndistributed, fault-tolerant, and async code. There\u2019s a lot of similarities\nwith Clojure like anonymous operations with lexical closures, immutable local\nvariables, and identical semantics when it comes to shadowing. Rama takes\nthings a step further for distributed computation, doing things like scope\nanalysis to determine what vars needs to be transferred across network\nboundaries. Rama\u2019s loops have similar syntax to Clojure and have the\nadditional capability of being able to be a distributed computation that hops\naround the cluster during loop iterations. With Rama this is all written\nlinearly through the power of dataflow, with switching threads/nodes being an\noperation like anything else (called a \u201cpartitioner\u201d).\n\nClojure\u2019s principles are just sound ideas that really do make a huge impact on\nsimplifying software development. These principles are even more relevant in\ndistributed systems / databases which historically have been overrun with\ncomplexity. That\u2019s why these principles are so core to Rama and its\nimplementation.\n\n## Conclusion\n\nThere\u2019s a seeming contradiction here \u2013 if Clojure enables such productivity\ngains, then why is it still a niche language in the industry? Why aren\u2019t those\nusing Clojure crushing their competition so thoroughly that every programmer\nis now rushing to adopt Clojure to even the playing field?\n\nI believe this is simply because Clojure does not address all aspects of\nsoftware development. This is not a criticism of Clojure but a recognition of\nits scope. Things like durable data storage, deployment, monitoring, evolving\nan application\u2019s state and logic over time, fault-tolerance, and scaling are\nhuge costs of building end-to-end software. Oftentimes the principles of\nClojure are corrupted when using a database, as the database forces you to\norient your code around its data model and capabilities.\n\nThis is why we\u2019re so excited about Rama and have worked so long on it, because\nRama does address everything involved in building end-to-end backends, no\nmatter the scale. Rama provides flexible data storage expressed in terms of\ndata structures, has deployment and monitoring built-in, has first-class\nfeatures for evolving an application and updating it, is completely fault-\ntolerant, and is inherently scalable. It does all this while maintaining\nClojure\u2019s great principles and functional programming roots.\n\nIf you\u2019d like to discuss on the Clojure Slack, we\u2019re active in the #rama\nchannel.\n\n### Leave a ReplyCancel reply\n\n# Follow Us\n\n  * Twitter\n  * GitHub\n\n# RSS\n\n# Recent Posts\n\n  * Rama is a testament to the power of Clojure\n  * 2.5x better performance: Rama vs. MongoDB and Cassandra\n  * Everything wrong with databases and why their complexity is now unnecessary\n  * How Rama is tested: a primer on testing distributed systems\n\nContents\n\n1\\. Ability to do in libraries what requires language support in other\nlanguages\n\n2\\. Power of immutability and data structure orientation\n\n3\\. Conclusion\n\n## Discover more from Blog\n\nSubscribe now to keep reading and get access to the full archive.\n\nContinue reading\n\n", "frontpage": true}
