{"aid": "40264042", "title": "Take a look at traefik, even if you don't use containers", "url": "https://j6b72.de/article/why-you-should-take-a-look-at-traefik/", "domain": "j6b72.de", "votes": 28, "user": "q2loyp", "posted_at": "2024-05-05 11:31:17", "comments": 4, "source_title": "Why you should take a look at traefik, even if you don't use containers", "source_text": "Why you should take a look at traefik, even if you don't use containers\n\nj6b72s site\n\nPublished on: 2024-04-30\n\n# Why you should take a look at traefik, even if you don't use containers\n\nTraefik got really popular over the last few years in the bubble of home-lab\nyoutubers, that\u2019s when I first heard about it.\n\nTraefik is more comparable to HAProxy than to nginx/caddy/apache2 - it\nforwards requests to services and returns the responses, can even modify\nheaders and other aspects of the request and response, but it can\u2019t serve\nfiles.\n\nThis article states my experience with traefik in an environment without\ncontainers.\n\n## What traefik is known for\n\nTraefiks site states their mission to help the microservices world. All these\nyoutubers share that they own some kind of container infrastructure, either\ndocker or kubernetes. Traefik runs as container too, you mount the docker\nsocket into the traefik container and gain the ability to auto-detect other\ncontainers that you might want to expose using traefik. You can configure the\nproxying behavior right on the specific container via labels. Traefik can\nautomatically request a TLS certificate from Let\u2019s Encrypt and makes your\nservice available as soon as it detects the existence of new container.\n\nAs I don\u2019t use linux containers that much right now, I thought traefik wasn\u2019t\nfor me. But I was wrong. It\u2019s fantastic!\n\n## Why it\u2019s also viable for non-container usage\n\n### Common Misconception: no container engine required\n\nTraefik doesn\u2019t need to run in a container engine, and your services don\u2019t\nneed to run in a container engine.\n\nTraefik is written in Golang and compiles to a single executable file, which\nyou can download from their releases page. I don\u2019t know why, but I get a\nreally good feeling when I encounter software that is written in Golang and\ncompiles to a single binary. It makes it so easy to \u201cdeploy\u201d the thing and you\nget to keep full control.\n\nAn example systemd service unit is contained in their repository, and that\u2019s,\napart from the configuration files, all you need. For security, you should\ncreate a user and correctly set the permissions on the your configuration\nfiles, though.\n\n### Common Misconception: also supports config files\n\nIf you don\u2019t use containers, you can\u2019t use container labels - but I find these\nlabels confusing and hard to read anyway.\n\nThe good thing: Traefik can also be configured with configuration files.\n\nAs a rule of thumb, Traefik splits its configuration in two parts - a \u201cstatic\u201d\nconfiguration that contains your certificate provider (e.g. Let\u2019s Encrypt) and\nentrypoints (the ports traefik listens on) and a \u201cdynamic\u201d configuration that\ncontains your routers, services and middlewares.\n\nTraefik listens to file system events and can hot reload the dynamic part.\n\nThe config file isn\u2019t thaaaat complicated. See my configuration at the bottom\nof this article.\n\n### Their documentation is great!\n\nIt explains all the concepts that Traefik builds upon clearly, has a\nconfiguration example for whichever way of configuring your instance you took\nat the beginning of the relevant pages (which, let\u2019s be real, is the thing\nwe\u2019re searching for most of the time) and their docs covered most of the\ndemands that I had.\n\nIf you didn\u2019t understand the terms I used earlier (certificate provider,\nentrypoint, routers, services & middlewares), the documentation will help you\nin sub-10 minutes. Try it out yourself. The sidebar is your friend.\n\n### Traefik feels robust and well thought-out\n\nTraefik warns you if your configuration doesn\u2019t make sense and I haven\u2019t run\ninto random issues yet.\n\nTraefik doesn\u2019t seem to log much by default, but the way your request takes is\neasy to understand and I was up and running really fast without any\nfrustration.\n\n## Features I really like\n\n### TLS Passthrough & PROXY protocol\n\nTraefik supports TLS Passthrough and HAProxys PROXY protocol (in and out).\n\nTLS passthrough means that you can forward traffic to web services that supply\ntheir own TLS certificate (even request it themselves from Let\u2019s Encrypt,\nthrough Traefik, which just forwards everything to the service so that can\nwork) without terminating TLS on the proxy. The proxy can\u2019t see what\u2019s being\ntransmitted.\n\nThe decision which virtual host is selected normally happens via the\n\u201cHost\u201d-Header - but as that\u2019s in the encrypted body, that\u2019s not possible. TLS\nhas a solution for that problem - the \u201cServer Name Indication\u201d (SNI), and\nTraefik and many other web servers / proxies use that to make the selection.\n\nAs an addition, HAProxys PROXY protocol is a more secure way of transmitting\nthe info that gets lost due to the user first reaching the proxy - in the\npast, you would\u2019ve used the \u201cX-Forwarded-<...>\u201d headers, but I always disliked\nthose, as making them secure isn\u2019t trivial and requires testing, as header\nhandling often times isn\u2019t well documented.\n\nNote: the PROXY protocol has to be supported by the target service too - but\nfor apache2 and nginx (and therefore, PHP) that\u2019s the case, and the list of\nservices that support the protocol is growing.\n\n## Things I miss when using traefik\n\n### Authentication\n\nOn NGINX, I use the great Vouch Proxy (also a Golang one-binary program :>) to\nsecure certain services with Azure AD (sorry, Microsoft Entra...)\nAuthentication. (If you know NGINX, you\u2019ll understand how it works just by\nlooking at this: https://github.com/vouch/vouch-proxy?tab=readme-ov-\nfile#installation-and-configuration)\n\nTraefik supports something similar to NGINX\u2019s auth using ForwardAuth. Sadly,\nVouch Proxy doesn\u2019t work yet for Traefik (open issue).\n\nYou could roll your own keycloak instance, integrate that with AAD and use\nthat for ForwardAuth. The internet says that works. But it also requires you\nto keep that keycloak instance secure and up-to-date and set it up in the\nfirst place. For bigger projects, that might be viable.\n\nOften recommended is traefik-forward-auth. Sadly, that project has had its\nlast update in June of 2020, the developer disappeared from GitHub and the\ndependencies need updating. There are open pull requests, which will probably\nnever be handled. Not viable for me.\n\nI\u2019ve had a bad experience with oauth2-proxy in the past (but to give them\ncredit: also golang and a single executable :>). I don\u2019t want to proxy to a\nproxy, as things HTTP2/3, timeouts, body size and WebSockets require\nconfiguration on all proxies between the user and the service. Feels too\nerror-prone to me.\n\nBut the Traefik ForwardAuth seems simple enough, so I might write my own\nsimple tool for integrating with AAD. Or maybe someone should fork and audit\ntraefik-forward-auth, and update its dependencies.\n\n### Blocking of user agents and IP addresses\n\nI don\u2019t want my internal services to be archived by archive.org. As robots.txt\nand similar headers don\u2019t work for disallowing Archive.org, there are only two\npossibilities to block their Crawler: Blocking the \u201carchive.org_bot\u201d user\nagent, or blocking their IP range.\n\nIn Traefik, you can only block user agents or IP addresses via a third-party\nplugin. I don\u2019t like third-party plugins as I need to keep them in mind when\nupdating, and they can introduce security vulnerabilities.\n\nYou could block IPs by using the IPAllowList middleware, and just allow\neverything but the IPs that you want to disallow. You can calculate the IP\nranges. That\u2019ll work and isn\u2019t any worse than blocking directly, but doesn\u2019t\nfeel very elegant at all as you can\u2019t see what subnets are exactly blocked\njust by looking at the ones that are left.\n\n## Configuration example\n\nThe following example sets up:\n\n  * entrypoints on :80 and :443\n\n    * with the http endpoint redirecting to https without exceptions\n  * Let\u2019s Encrypt for certificates with the TLS challenge\n  * tls passthrough proxying for cloud.xx.xyz (service on another host)\n\n    * with enabled PROXY protocol\n  * tls-terminating proxying to git.xx.xyz (service on the local host)\n  * redirect middleware from https://xx.xyz/redirmepls to https://google.com\n  * header-adding middleware to add a x-robots-header\n\n### /etc/traefik/traefik.yml\n\n    \n    \n    providers: file: filename: /etc/traefik/dynamic.yml watch: true entryPoints: https: address: :443 http: address: :80 http: redirections: entryPoint: to: https scheme: https certificatesResolvers: le: acme: email: xx@xx.xyz storage: /etc/traefik/acme.json tlsChallenge: {} # Required as per https://blog.alexanderhopgood.com/traefik/letsencrypt/2020/12/09/traefik-http-challenge.html\n\n### /etc/traefik/dynamic.yml\n\n    \n    \n    tcp: routers: nextcloud-router: rule: \"HostSNI(`cloud.xx.xyz`)\" service: nextcloud entrypoints: - https tls: passthrough: true services: nextcloud: loadBalancer: servers: - address: 10.33.1.2:4433 proxyProtocol: version: 2 http: routers: gitea: rule: \"Host(`git.xx.xyz`)\" entrypoints: - https service: gitea middlewares: - noindex tls: certResolver: le xx.xyz: rule: \"Host(`xx.xyz`)\" entrypoints: - https middlewares: - my-redirect tls: certResolver: le service: dummy middlewares: my-redirect: redirectRegex: regex: \"https://xx.xyz/redirmepls\" replacement: \"https://google.com\" noindex: headers: customResponseHeaders: X-Robots-Tag: noindex, nofollow, nosnippet, noarchive services: gitea: loadBalancer: servers: - url: http://127.0.0.1:3000 dummy: loadBalancer: servers: []\n\nhi@j6b72.de // github.com/j6b72\n\n", "frontpage": true}
