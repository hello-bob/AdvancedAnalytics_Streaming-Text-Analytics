{"aid": "40157456", "title": "Prune Your Monorepo's Docker Build", "url": "https://spin.atomicobject.com/prune-monorepo-docker/", "domain": "atomicobject.com", "votes": 1, "user": "philk10", "posted_at": "2024-04-25 13:41:01", "comments": 0, "source_title": "Prune Your Monorepo\u2019s Docker Build", "source_text": "Prune Your Monorepo's Docker Build\n\n\u2190 Back to Blog Home\n\n# Prune Your Monorepo\u2019s Docker Build\n\nJavaScript\n\nby: John Ruble\n\nApril 25, 2024\n\n  * Twitter\n  * Facebook\n  * Linkedin\n  * Hackernews\n\n### Article summary\n\n  * Monorepo and Workspaces\n  * Shared node_modules\n  * Pruning Projects\n  * Pruning devDependencies\n  * Docker\n  * So many stages\n  * Results\n\nIf your JavaScript monorepo deploys node modules, you may be deploying more\nthan you need. Here\u2019s how my software team and I slimmed ours down.\n\n## Monorepo and Workspaces\n\nThough the term \u201cmonorepo\u201d technically has a more general definition, in the\nJavaScript ecosystem it typically refers to a git repository holding a small\nnumber of related projects, usually organized with the \u201cworkspaces\u201d feature of\na popular package manager. This post (and my current project) use pnpm, but\nthe same concepts apply to other package managers (yarn, npm).\n\nHere\u2019s an example workspace structure, holding a shared library and two apps:\n\n    \n    \n    \u251c\u2500\u2500 package.json \u251c\u2500\u2500 pnpm-lock.yaml \u251c\u2500\u2500 shared-lib \u2502 \u2514\u2500\u2500 package.json \u251c\u2500\u2500 cloud-app \u2502 \u2514\u2500\u2500 package.json \u2514\u2500\u2500 client-app \u2514\u2500\u2500 package.json\n\nNote that the projects depend on each other: both client-app and cloud-app\nreference shared-lib.\n\n## Shared node_modules\n\nEach project\u2019s package.json file expresses its own set of third-party\ndependencies. For efficiency, package managers prefer to produce a single\nshared lock file and a single shared node_modules directory at the top level.\nTypically, when you run e.g. pnpm install, that will pull down all the\ndependencies for all the projects. This is usually what you want as a\ndeveloper.\n\nFor distribution, though, this behavior is likely not what you want. Say\nyou\u2019re publishing client-app in the example above: there\u2019s no need to bring\nalong the third-party dependencies of cloud-app.\n\n> Side note: bundling. This post is about optimizing the node_modules you\u2019re\n> publishing. If your distributed artifacts don\u2019t contain any, good for you!\n> You don\u2019t need this.\n\n## Pruning Projects\n\nSo, given a multi-workspace pnpm project, and an intent to build and publish a\nsingle project, how can we narrow this down? I\u2019ve often wanted a command like\npackage-manager install --subtree-beginning-with client-app, that would pull\ndown dependencies for client-app and shared-lib, but exclude cloud-app. I\u2019m\nsure this will exist someday, but as far as I know, it doesn\u2019t yet.\n\nThankfully, Turbo has filled this need with a prune command:\n\n    \n    \n    > pnpm turbo prune client-app Generating pruned monorepo for client-app in /Users/jrr/example-project/out - Added client-app - Added shared-lib\n\nThis produces a reduced copy of your repo, excluding unneeded projects. It\neven filters down the lockfile!\n\n## Pruning devDependencies\n\nA second kind of pruning has been around longer: separating development\ndependencies from production dependencies. I\u2019ve seen many projects that never\nbothered with this distinction, but if you\u2019re at all sensitive to the size of\nyour deployed node_modules, you should look into it. In short, package\nmanagers can be asked to skip installing devDependencies to avoid deploying\ndevelopment tools like compilers, test frameworks, etc.\n\nI should warn you to be careful when you make this change in an existing\nproject. The first time you slice off what you think are development\ndependencies, you may learn that some of them are, in fact, needed by the\ndeployed app at runtime :).\n\n## Docker\n\nOn my current project, our Git repository contains two applications: one\ndeployed to the cloud, and another running on devices. The device deployment\nartifacts are Docker images, with conspicuous file sizes and deploy times.\n\nWe recently applied both of the above pruning techniques to great effect,\nusing a multistage Dockerfile based on Turbo\u2019s guidance.\n\nIn hopes that this may be useful for your project, here\u2019s a walk through the\nmany stages of our Dockerfile structure:\n\n### Base\n\nThere\u2019s not much here. This is the lowest common denominator of all the\nstages.\n\nDocker\n\n    \n    \n    FROM node:20-bookworm-slim as base WORKDIR /usr/src/app RUN npm i -g pnpm@8.15.5\n\n### Project Pruning\n\nFirst, we copy in the project sources from disk, then run turbo prune to\nproduce a couple of pruned subtrees of the project, and copy them into\nseparate named stages:\n\nDocker\n\n    \n    \n    FROM base as prune RUN npm i -g turbo@1.13.0 COPY . . RUN turbo prune --docker device-app FROM base as pruned_project_files COPY --from=prune /usr/src/app/out/json/ . FROM base as pruned_sources COPY --from=prune /usr/src/app/out/full/ . COPY --from=prune /usr/src/app/tsconfig.json . COPY --from=prune /usr/src/app/out/pnpm-lock.yaml .\n\n### node_modules\n\nThis is where the devDependencies vs dependencies installation happens. First,\nwe start with the smaller set (--prod true):\n\nDocker\n\n    \n    \n    FROM pruned_project_files as node_modules_for_run RUN install_packages wget python3 make g++ RUN pnpm install --prod true\n\nThen we derive another stage from that and install the rest (--prod false):\n\nDocker\n\n    \n    \n    FROM node_modules_for_run as node_modules_for_build RUN pnpm install --prod false --force\n\n### Build\n\nTo build the application, we take all the sources and copy in the needed\nnode_modules.\n\nDocker\n\n    \n    \n    FROM pruned_sources as build COPY --from=node_modules_for_build /usr/src/app/node_modules /usr/src/app/node_modules COPY --from=node_modules_for_build /usr/src/app/modules/shared/node_modules /usr/src/app/modules/shared/node_modules COPY --from=node_modules_for_build /usr/src/app/apps/device/node_modules /usr/src/app/apps/device/node_modules ARG example_build_input ENV EXAMPLE_BUILD_INPUT=${example_build_input}} RUN pnpm turbo --filter device-app build\n\n### Run\n\nThe final stage copies in the smaller set of node_modules and the built\nartifacts.\n\nDocker\n\n    \n    \n    FROM pruned_sources as run RUN install_packages vim ENV PORT=80 HEALTHCHECK --start-period=30s --timeout=30s --interval=30s --retries=3 \\ CMD curl --silent --fail localhost:80 COPY --from=node_modules_for_run /usr/src/app/node_modules /usr/src/app/node_modules COPY --from=node_modules_for_run /usr/src/app/apps/device/node_modules /usr/src/app/apps/device/node_modules COPY --from=node_modules_for_run /usr/src/app/modules/shared/node_modules /usr/src/app/modules/shared/node_modules COPY --from=build /usr/src/app/apps/device/build /usr/src/app/apps/device/build CMD [\"pnpm\", \"--filter\", \"device-app\", \"start\"]\n\n## So many stages\n\nIn case you lost track, here\u2019s a diagram:\n\nYes, it\u2019s a lot of stages, but they\u2019re cheap. I value being able to name\nintermediate states, and they work nicely with Docker\u2019s caching.\n\n## Results\n\nApplying these optimizations to our Docker build reduced the image size by\nhalf (!). A working example of this structure can be found on GitHub at\njrr/prune-monorepo-example.\n\ndockermonorepo\n\nJohn Ruble Software Consultant & Developer at Atomic Object Grand Rapids.\nLoves a good refactor.\n\nAll Posts \u2192\n\n### Related Posts\n\n  * JavaScript\n\n## Automatically Watch and Build Your Turborepo Monorepo with Turbotree\n\n  * JavaScript\n\n## Improving Unit Test Efficiency: Leveraging Assert and Expect for Type\nSafety\n\n  * JavaScript\n\n## Tips for Effective Code Documentation: How to Make Your Next App Readable\n\n## Keep up with our latest posts.\n\nWe\u2019ll send our latest tips, learnings, and case studies from the Atomic\nbraintrust on a monthly basis.\n\n[mailpoet_form id=\"1\"]\n\nConversation\n\n### Join the conversation Cancel reply\n\n### Platforms & Languages Category\n\n  * PostgreSQL\n  * GitHub Actions\n  * Realm\n  * Azure\n  * Vue\n  * C#\n  * React Native\n  * React / Redux\n  * Kotlin\n  * Blockchain\n  * Scala\n  * Desktop Apps\n  * JavaScript\n  * Rust\n  * FaunaDB\n  * Flutter\n  * Angular\n  * AWS\n  * Prisma\n  * Functional Programming\n  * Web Apps\n  * Mobile Apps\n  * Embedded Systems\n  * DevOps & System Admin.\n  * Android Development\n  * C & C++\n  * Java\n  * Ember.js\n  * iOS / OS X\n  * jRuby\n  * .NET / WPF\n  * Objective-C\n  * Presenter First\n  * Python\n  * Ruby\n  * Ruby Motion\n  * Ruby on Rails\n  * Swift\n  * TypeScript\n\nRelated Posts\n\nJavaScript\n\n# Automatically Watch and Build Your Turborepo Monorepo with Turbotree\n\nJavaScript\n\n# Improving Unit Test Efficiency: Leveraging Assert and Expect for Type Safety\n\nJavaScript\n\n# Tips for Effective Code Documentation: How to Make Your Next App Readable\n\n### Tell Us About Your Project\n\nWe\u2019d love to talk with you about your next great software project. Fill out\nthis form and we\u2019ll get back to you within two business days.\n\nShare Your Project\n\nAtomic is a software design + development consultancy.\n\n\u00a9 2024 Atomic Object LLC\n\n##### Explore\n\n  * Careers\n  * Diversity\n  * Resources\n  * Atomic Blog\n\n##### Offices\n\n  * Grand Rapids\n  * Ann Arbor\n  * Chicago\n  * Raleigh-Durham\n\n##### Details\n\n  * Contact\n  * Media\n  * Privacy Policy\n\nLoading Comments...\n\n", "frontpage": false}
