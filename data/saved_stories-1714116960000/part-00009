{"aid": "40162418", "title": "The Dark Sides of the Open-Closed Principle", "url": "https://chi.pl/2024/01/25/The-Dark-Sides-of-the-Open-Closed-Principle.html", "domain": "chi.pl", "votes": 1, "user": "tfij", "posted_at": "2024-04-25 20:13:20", "comments": 0, "source_title": "The Dark Sides of the Open-Closed Principle", "source_text": "The Dark Sides of the Open-Closed Principle | Programming Chi - Tomasz Fija\u0142kowski\u2019s blog\n\n# Programming Chi\n\nTomasz Fija\u0142kowski's programming blog.\n\n# The Dark Sides of the Open-Closed Principle\n\nJan 25 2024 by Tomasz Fija\u0142kowski\n\nThis article is also available on detektywi.it as Mroczne strony Open-Closed\nPrinciple [Polish]\n\n> Simplicity is the goal.\n>\n> \u2013 Sean Parent, Menlo Innovations\n\nThe Open-Closed Principle, described in SOLID, ensures project flexibility,\nbut does it always lead to optimal, future-ready code? It sounds promising -\nopen for extension, closed for modification. Let\u2019s take a closer look.\n\n## Overengineering in Light of Open-Closed\n\nThe Open-Closed Principle seems like a reasonable approach. By designing our\ncode to easily add new features without modifying existing code, we become\nprepared for unexpected changes and project expansions. However, is this\nalways necessary? This is where the problem of overengineering arises.\n\nOverengineering is when our code is more complicated than necessary to prepare\nfor changes and scenarios that may never occur. It\u2019s like building a bridge in\nthe desert, hoping it might someday be useful as a trade corridor.\n\nAnticipating potential, but unknown, changes can lead to excessive code\nabstraction. Additional layers, interfaces, and structures intended to provide\nflexibility introduce unnecessary complexity. Additional complexity is\nintroduced to avoid touching individual pieces of code in the future. It is\nthe fear of future change that drives overengineering. Fear stemming from\npoor-quality code.\n\n## Proper Engineering\n\nInstead of focusing on creating code that is ready for every eventuality, it\nis worth concentrating on proper engineering. Rather than avoiding changes,\nlet\u2019s focus on creating code that is easy to change. High-quality code, clean\ncode, automated testing, modularization, high cohesion, etc. - these are the\nfoundations that make our code flexible without unnecessary abstractions.\n\nEngineering should focus on creating solutions that are simple and efficient.\nFor example, when you have one discount calculation algorithm, you don\u2019t need\nto implement the strategy pattern thinking, \u201cmaybe someday we\u2019ll have a second\nalgorithm, and it will be easy to replace\u201d. This is overengineering entirely\nconsistent with the open-closed principle. If the code is of good quality,\nintroducing abstractions when needed shouldn\u2019t be a problem.\n\n## Message for Today\n\nHandle the Open-Closed Principle with care. Code should be easy to modify, not\nnecessarily prepared for specific, uncertain changes.\n\n#### About\n\nProgramming Chi (or Qi) is a blog about the humble ideas, bugs, and failures I\nencounter on a daily basis. Fortunately, alongside failures, there are also\nnumerous successes and elegant solutions, which I hope to write about as well.\n\n#### Elsewhere\n\n  1. GitHub\n  2. Twitter\n  3. Linkedin\n\nI hope it was helpful @TomaszFijalkows\n\nBack to top\n\nSubscribe to: Posts (Atom)\n\n", "frontpage": false}
