{"aid": "40247373", "title": "Identifiers are better off without meaning", "url": "https://varoa.net/2024/05/01/identifiers-are-better-off-without-meaning.html", "domain": "varoa.net", "votes": 1, "user": "srvaroa", "posted_at": "2024-05-03 13:20:57", "comments": 0, "source_title": "Identifiers are better off without meaning", "source_text": "Identifiers are better off without meaning\n\nGalo Navarro\n\n# Identifiers are better off without meaning\n\nOnce at Last.fm we had an integer overflow in an identify field. I can\u2019t\nrecall where exactly. But I do remember that the inconvenience of having a\nbunch of Hadoop jobs disrupted while we rushed to update the relevant type\ncouldn\u2019t spoil the collective pride for having more than 2 billion of whatever\nneeded so many ids.\n\nBeing frugal with identifiers is seldom a good idea, but for me the worst\nidentifier-related headaches came from IDs that had semantic value.\n\nAt Tuenti (once the largest social network in Spain) there was a concept\nsimilar to Facebook pages. Pages had types and subtypes. A page type might\nhave been \u201cgroup\u201d, which had subtypes \u201cbusiness\u201d or \u201ccommunity\u201d. Another type\ncould be \u201cplace\u201d with subtypes like \u201cstore\u201d or \u201clandmark\u201d.\n\nPage identifiers were strings composed by concatenating numeric identifiers of\nthe type, subtype, and then an increment field in a DB. If you visited\nhttps://tuenti.com/p/3_2_6691 you\u2019d instantly know the meaning. It was a\n\u201cplace\u201d (3) of type \u201cstore\u201d (2), and the store ID was 6691. Page IDs\ndecomposed in this way would be useful for multiple purposes. Chosing a type-\nspecific implementation of controllers to compose the relevant page, routing\nto a database shard, that kind of thing.\n\nAt some point Product wanted to change the classification of pages. To their\nfrustration, this became problematic because the entire taxonomy was encrusted\nacross the code all the way from URLs to databases.\n\nAnother example are New Relic entities. Entities are an abstraction that\nbroadly represents anything that can send telemetry to New Relic. A host, a\nKubernetes cluster, an application, a JVM or a network router can be entities.\nOf course those are all things you want to identify, so entities have Global\nUnique IDentifier, or GUID. Every single telemetry datapoint is stamped with\nthe GUID of the entity that produced it, so they act as the keystone of the\nNew Relic platform. Features like Service maps, distributed tracing, entity\nrelationships, and many others are built upon them.\n\nEntity GUIDs have meaning. An example of a GUID is 1|APM|APPLICATION|23 where\n1 is the account, APM is the domain, APPLICATION is the unique type within\nthat domain, and 23 is a unique identifier within the domain and type. That\napplication might be running in a host 1|INFRA|HOST|12. If we wanted to store\nthat relation, we\u2019d have an entry in some database saying:\n\n\"1|INFRA|HOST|12\" RUNS \"1|APM|APPLICATION|23\".\n\nLike at Tuenti, these semantics come handy. If you\u2019re processing millions of\ntelemetry datapoints per second, it\u2019s useful to tell the type of reporting\nentity on the fly by decomposing the GUID, rather than perform an expensive\nlookup to an external service. Account IDs can be used to route data to cells\n(this talk from Andrew Bloomgarden explains how NR used this pattern to\nscale).\n\nDomains like INFRA or APM corresponded to the original product verticals at\nNew Relic. Years later Product decided (with good criteria) that they created\nunnecessary fragmentation on the user experience. Types change, get renamed or\nmerged with others. Sometimes (more often than it seems) entities had to\nmigrate from one account to another. In all these cases you would be altering\nthe identifier of many entities.\n\nIt was painful but possible to work around many of these problems. But\nreplacing GUIDs with semantic-free identifiers was straight impossible. By\nvirtue of being present in thousands of URLs, NRQL queries, etc. GUIDs had\nbecome a public API that thousands of customers relied upon. A technical\nsolution to replace identifiers would have been a major project, but doable.\nWhat wasn\u2019t possible was to run a find/replace across the private\ndocumentation and workflows of your entire customer base.\n\nIf you look closely, the world is full of semantic identifiers. They are\nalmost invariably a pain in the neck because they embed a specific model of\nthe world. But models become obsolete faster than we\u2019d like.\n\nAddresses make notable examples. The \u201ccomplex and idiosyncratic\u201d Japanese\naddress system reflects the organic growth of its urban areas. In British\npostal codes the final part can designate anything from a street to a flat\ndepending on the amount of mail received by the premises.\n\nWhen I was a kid, license plates would give up the province where the owner\nlived causing an array of nuisances. They were alleviated with the adoption of\nEuropean standards. But partly. The root problem being that, like the Domain\nName System identifiers (\u201cGalo\u2019s website\u201d) remain tied to administrative\nauthorities (\u201c.net\u201d), which can change regulations, or even disappear.\n\nNowadays I find most semantic identifiers in resource management. For some\nreason, when infrastructure teams define access rules to the resources of a\nparticular service, they prefer to create a group named after the team that\nowns that service, something like \u201cowner-team-access-list\u201d. Identifiers tied\nto the org chart don\u2019t like it when the service moves to another team, or\nowner-team is reorged away.\n\nMay 1, 2024\n\nAny thoughts? send me an email!\n\nTo get notifications for new posts, subscribe to my mailing list, the RSS feed\nor follow me on Twitter / Mastodon.\n\n## Archive\n\n  * Identifiers are better off without meaning\n  * Alert on symptoms, not causes\n  * How about we forget the concept of test types?\n  * How organisations cripple engineering teams with good intentions\n  * Migrating an Eureka-based microservice fleet to Kubernetes\n  * Talk write-up: \"How to build a PaaS for 1500 engineers\"\n  * Kubernetes made my latency 10x higher\n  * Sizing Kubernetes pods for JVM apps without fearing the OOM Killer\n  * GC forensics by example: multi-second pauses and allocation pressure\n  * How does the default hashCode() work?\n  * Frugal memory management on the JVM (Meetup)\n  * DirectBuffer creation / disposal has hidden contention on sun.misc.Cleaner\n\n\u00a9 2024 Galo Navarro\n\n", "frontpage": false}
