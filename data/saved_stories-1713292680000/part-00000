{"aid": "40050748", "title": "How do Spotify Codes work? (2020)", "url": "https://boonepeter.github.io/posts/2020-11-10-spotify-codes/", "domain": "boonepeter.github.io", "votes": 1, "user": "promiseofbeans", "posted_at": "2024-04-16 11:35:15", "comments": 0, "source_title": "How do Spotify Codes work?", "source_text": "How do Spotify Codes work? - Peter Boone\n\n# How do Spotify Codes work?\n\nNovember 13, 2020 \u00b7 10 min \u00b7 Peter Boone \u00b7 Source\n\nSpotify Codes are QR-like codes that can be generated to easily share Spotify\nsongs, artists, playlists, and users. I set out to figure out how they worked,\nwhich led me on a winding journey through barcode history, patents, packet\nsniffing, error correction, and Gray tables.\n\n## Spotify URIs#\n\nLet\u2019s start with Spotify URIs (Uniform Resource Identifiers). Different pieces\nof media (artists, albums, songs, playlists, users) all have a URI.\n\nThe ABBA song \u201cTake a Chance on Me\u201d has this URI:\n\nspotify:track:6vQN2a9QSgWcm74KEZYfDL.\n\nThe ABBA Album \u201cThe Album\u201d has the following URI:\n\nspotify:album:5GwbPSgiTECzQiE6u7s0ZN\n\nAs you can see, the URIs can be broken up into components:\n\nspotify:<media type>:<22 characters>.\n\nThe 22 characters are the numbers 0-9, characters a-z and A-Z. This means\nthere are 10 + 26 + 26 = 62 possibilities for each character (almost Base64).\nSo the potential number of Spotify URIs is 62^22 which is equal to 2.7e39 or\n\n    \n    \n    2,707,803,647,802,660,400,290,261,537,185,326,956,544\n\nTo illustrate that number:\n\n    \n    \n    x = 62 ** 22 # the number of milliseconds in a year x //= 365 * 24 * 60 * 60 * 1000 # the number of words in the bible (about 1 million) x //= 1000000\n\nIf Spotify printed a whole Bible\u2019s worth of URIs every millisecond they could\ndo this for 85,863,890,404,701,306,452,633 years. Safe to say Spotify is not\ngoing to run out of URIs anytime soon.\n\n## Barcode background#\n\nThe history of barcodes is quite extensive. Information is encoded into\ndifferent barcodes in a variety of ways.\n\nA lot of barcodes encode data in the widths of vertical bars. Universal\nproduct codes (UPCs) encode 12 digits using combinations of vertical bars of\ndifferent widths:\n\nAnother barcode uses colors to encode data:\n\nQR codes use a 2d matrix of dots to encode data.\n\nA lot of mail barcodes encode data using the height of the bars (like the\nIntelligent Mail barcode).\n\n## Spotify Codes#\n\nSpotify codes work like the Intelligent Mail Barcode. Information can be\nstored in the bars by setting them to different heights.\n\nThis is the Spotify code for the ABBA song \u201cTake a Chance on Me\u201d:\n\nWhen the bars are sorted by height you can see that there are 8 discrete\nheights that they fall into.\n\nThis means the data is encoded in octal.\n\nThe Spotify logo\u2019s diameter is the same as the height of the highest bar. This\nmakes it easy to generate ratios of the bars\u2019 heights.\n\nIn this function I use scikit-image to calculate the sequence of bar heights\nfrom a logo.\n\n    \n    \n    from skimage import io from skimage.measure import label, regionprops from skimage.filters import threshold_otsu from skimage.color import rgb2gray def get_heights(filename: str) -> list: \"\"\"Open an image and return a list of the bar heights. \"\"\" # convert to grayscale, then binary image = io.imread(filename) im = rgb2gray(image) binary_im = im > threshold_otsu(im) # label connected regions as objects labeled = label(binary_im) # get the dimensions and positions of bounding box around objects bar_dimensions = [r.bbox for r in regionprops(labeled)] # sort by X bar_dimensions.sort(key=lambda x: x[1], reverse=False) # the first object (spotify logo) is the max height of the bars logo = bar_dimensions[0] max_height = logo[2] - logo[0] sequence = [] for bar in bar_dimensions[1:]: height = bar[2] - bar[0] ratio = height / max_height # multiply by 8 to get an octal integer ratio *= 8 ratio //= 1 # convert to integer (and make 0 based) sequence.append(int(ratio - 1)) return sequence\n\nThis is the sequence of the \u201cTake On Me\u201d Spotify code:\n\n    \n    \n    >>> get_heights(\"/imgs/spotify/spotify_track_6vQN2a9QSgWcm74KEZYfDL.jpg\") [0, 5, 1, 2, 0, 6, 4, 3, 7, 1, 6, 7, 7, 7, 7, 3, 1, 6, 3, 7, 0, 7, 0]\n\nHere are those results overlaid on the barcode:\n\nAfter looking at a few barcodes, I realized that the first and last bars are\nalways 0, and the 12th bar is always a 7. This must help in identifying if the\nbarcode is valid. Having the 12th bar as the max height also helps you\ncalculate the ratios of the bar heights. I suspect setting the first and last\nbar set to 0 is an aesthetic choice: it makes the barcode look more like a\nsound wave. Here are a few barcodes printed out so you can see that the first\nand last are always equal to 0 and the 12th is equal to 7.\n\n    \n    \n    [0, 3, 3, 0, 5, 2, 2, 2, 2, 5, 1, 7, 0, 0, 5, 6, 0, 7, 7, 7, 1, 5, 0] [0, 5, 6, 5, 3, 5, 4, 2, 7, 2, 5, 7, 1, 3, 1, 1, 6, 1, 1, 6, 7, 6, 0] [0, 4, 6, 6, 6, 4, 4, 1, 6, 6, 6, 7, 7, 3, 6, 0, 7, 6, 0, 2, 1, 7, 0] [0, 0, 3, 3, 7, 5, 2, 3, 1, 1, 4, 7, 5, 5, 5, 3, 3, 7, 5, 1, 4, 3, 0] [0, 6, 2, 2, 1, 5, 2, 6, 2, 2, 3, 7, 7, 6, 6, 4, 5, 6, 0, 1, 4, 3, 0] [0, 7, 7, 1, 4, 7, 1, 0, 4, 7, 1, 7, 6, 5, 6, 3, 1, 6, 4, 4, 7, 7, 0] [0, 1, 1, 1, 5, 7, 1, 3, 3, 1, 0, 7, 7, 0, 7, 3, 2, 3, 0, 6, 0, 0, 0] [0, 7, 6, 6, 7, 4, 4, 6, 7, 0, 6, 7, 0, 4, 1, 7, 3, 2, 0, 5, 4, 7, 0] [0, 0, 0, 6, 1, 3, 3, 2, 2, 0, 2, 7, 3, 2, 4, 1, 6, 0, 1, 5, 0, 4, 0]\n\nThe barcode consists of 23 bars, of which only 20 actually contain\ninformation. This means that there are 8^20 pieces of information that can be\nencoded into the code.\n\n## URIs to Barcodes#\n\nHow do you convert a 63^22 bit URI into an 8^20 bit barcode? There is 2.3e+21\ntimes as much information in the URI than there is in the barcode. This is\nwhen I started asking questions and hunting for answers. This question was a\nstart, but I ended up asking this SO question and getting a couple of answers\nthat linked to the relevant patents and contained more info about Spotify\u2019s\nlook up table.\n\nHere is one patent.\n\nHere is another, more recent patent\n\n> \u201cPatents are the worst\u201d - Peter Boone\n\nLet me just say: patents are the worst. They are so dense. I used to think\nacademic papers were full of jargon until I read some technical patents.\n\n### The Process#\n\nWhen you visit Spotify codes and input a Spotify URI, a \u201cmedia reference\u201d is\ncreated by Spotify. This media reference is 37 bits long and is the key that\nlinks a barcode to a given URI. The media reference may just be the hash of an\nincrementing index. After extracting a media reference from a barcode, you\ncheck with Spotify\u2019s database (a look-up table) to determine what URI it\ncorresponds to. A Stack Overflow user discovered that you can sniff the\nrequest that your phone makes when scanning the barcode to determine the media\nreference and API endpoint.\n\n    \n    \n    heights = [0, 2, 6, 7, 1, 7, 0, 0, 0, 0, 4, 7, 1, 7, 3, 4, 2, 7, 5, 6, 5, 6, 0] media_reference = \"67775490487\" uri = \"spotify:user:jimmylavallin:playlist:2hXLRTDrNa4rG1XyM0ngT1\"\n\nThere are a few steps required to turn a media reference into a Spotify code\n(and vis versa).\n\n### Cyclic Redundancy Check#\n\nA Cyclic redundancy check is calculated for the media ref. Based on the fact\nthat 8 bits are calculated, I am assuming Spotify uses CRC8.\n\n    \n    \n    import crc8 hash = crc8.crc8() media_ref = 67775490487 ref_bytes = media_ref.to_bytes(5, byteorder=\"big\") print(ref_bytes) # b'\\x0f\\xc7\\xbb\\xe9\\xb7' hash.update(ref_bytes) check_bits = hash.digest() print(check_bits) # b'\\x0c'\n\nAppend the crc to the media reference:\n\n    \n    \n    media_reference = b'\\x0f\\xc7\\xbb\\xe9\\xb7\\x0c'\n\n### Forward error correction#\n\nNext forward error correction (FEC) is used to add some redundancy to the\ncode. This makes the decoding process more reliable. Decoding Spotify codes\ninvolves going from analog (bar lengths) to digital (media reference), so it\nis a good candidate for this error correction.\n\n> The fundamental principle of [error correction] is to add redundant bits in\n> order to help the decoder to find out the true message that was encoded by\n> the transmitter.\n\nA simple example of error correction would be to replicate each bit twice. So\ninstead of sending 1, you would send 111. When that triplet is sent across a\n\u201cnoisy\u201d communication channel, some of the bits could get flipped. But since\nthere are 2 redundant bits, the receiver can guess what the value was meant to\nbe:\n\nTriplet received| Interpreted as  \n---|---  \n000| 0 (error-free)  \n001| 0  \n010| 0  \n100| 0  \n111| 1 (error-free)  \n110| 1  \n101| 1  \n011| 1  \n  \nThe patents don\u2019t specify what forward error correction schema Spotify uses,\nbut they do say that they add 15 bits at this step. The code rate of an error\ncorrection scheme is the ratio of the information bits to the total encoded\nbit length. Spotify adds 15 bits to the 45 bit code, so the code rate is 45 /\n60 = 0.75. This code rate is high (close to 1) meaning it is fairly weak. It\nfacilitates a limited amount of error correction, but that is okay. If you are\nsending a message to a deep space probe you want a very strong code. A Spotify\ncode is pretty low risk: it\u2019s easy to ping the server a few times if you\ndecode the wrong media reference.\n\nThe total forward error corrected code is 60 bits long, which is the exact\namount of information that can be encoded in the 20 octals (bar heights) in\nthe Spotify barcode!\n\nThe patents do mention that Spotify uses the Viterbi algorithm to decode the\nmedia reference from the forward error corrected code. I won\u2019t go into it\nhere, but that algorithm uses the redundant bits from the forward error\ncorrection to determine the best guess of the actual media reference.\n\n### Gray Code#\n\nI really like this part of the Spotify codes.\n\nGray code is an alternative way to represent a binary number. If you look\nclosely at the following table, you will see that Gray code works by changing\nonly one bit at a time.\n\nDecimal| Binary| Gray  \n---|---|---  \n0| 000| 000  \n1| 001| 001  \n2| 010| 011  \n3| 011| 010  \n4| 100| 110  \n5| 101| 111  \n6| 110| 101  \n7| 111| 100  \n  \nWhy does Spotify use Gray code? What is wrong with normal binary\nrepresentation of the code?\n\nThe difference between 3 and 4 in Gray code is only 1 bit (010 -> 110). In\nnormal binary representation, that difference is 3 bits (100 -> 011). When\ngoing from analog (the height of a given bar) to binary, using Gray codes\nreduces the number of bits that are \u201cwrong\u201d if we calculate the wrong height.\n\nIf the height of a bar is supposed to be 3, but we calculate that it is 3.51\nand we round up to 4, the binary representation of that number in Gray code\nwill only be off by one bit. This makes the forward error correction more\nuseful.\n\nI think it is cool how Spotify uses \u201cold school\u201d computer science techniques.\nFrank Gray being concerned about how physical switches operate in 1947 is\nstill applicable today. When you are at the interface between analog and\ndigital, a lot of older concepts become more relevant.\n\n## Final thoughts#\n\nI was hoping to be able to implement my own Spotify Code to URI tool, but I\nwasn\u2019t quite able to. I don\u2019t know exactly what forward error correction\nSpotify uses. I also don\u2019t know for sure if they are using CRC8. There is also\nanother step that I didn\u2019t mention where they shuffle the bars around, and I\ndon\u2019t know how they do that. I haven\u2019t quite given up, though. I plan to spend\nsome more time studying a lot of sequences to see if I can figure out the\nerror detection. I need to generate a bunch of corresponding URI, media\nreference, and Spotify code triplets.\n\nI didn\u2019t expect to learn quite this much when I started exploring Spotify\ncodes, but that is the cool part about scratching the \u201ccuriosity itch\u201d!\n\n## Update#\n\nPart 2 is out now! You can read it here. In this post I present exactly how\nSpotify Codes are encoded.\n\n  * tech\n  * spotify\n  * python\n\n\u00a9 2024 Peter Boone \u00b7 Powered by Hugo \u00b7 Theme PaperMod \u00b7 Subscribe\n\n", "frontpage": false}
