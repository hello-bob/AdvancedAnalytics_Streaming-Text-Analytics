{"aid": "40280367", "title": "Experimental gradual set-theoretic types in Elixir", "url": "https://hexdocs.pm/elixir/main/gradual-set-theoretic-types.html", "domain": "hexdocs.pm", "votes": 1, "user": "clessg", "posted_at": "2024-05-06 22:46:28", "comments": 0, "source_title": "Gradual set-theoretic types \u2014 Elixir v1.17.0-dev", "source_text": "Gradual set-theoretic types \u2014 Elixir v1.17.0-dev\n\n# View Source Gradual set-theoretic types\n\nElixir is in the process of incorporating set-theoretic types into the\ncompiler. This document outlines the current stage of our implementation.\n\nThe current milestone aims to infer types from patterns and guards and use\nthem to type check programs, enabling the Elixir compiler to find faults and\nbugs in codebases without requiring changes to existing software. The\nunderlying principles, theory, and roadmap of our work have been outlined in\n\"The Design Principles of the Elixir Type System\" by Giuseppe Castagna,\nGuillaume Duboc, Jos\u00e9 Valim.\n\n## Supported types\n\nAt the moment, Elixir developers will interact with set-theoretic types only\nthrough warnings found by the type system. All data types in the language are\nmodelled:\n\n  * binary(), integer(), float(), pid(), port(), reference() - these types are indivisible. This means both 1 and 13 get the same integer() type.\n\n  * atom() - it represents all atoms and it is divisible. For instance, the atom :foo and :hello_world are also valid (distinct) types.\n\n  * map() and structs - maps can be \"closed\" or \"open\". Closed maps only allow the specified keys, such as %{key: atom(), value: integer()}. Open maps support any other keys in addition to the ones listed and their definition starts with ..., such as %{..., key: atom(), value: integer()}. Structs are closed maps with the __struct__ key.\n\n  * tuple(), list(), and function() - currently they are modelled as indivisible types. The next Elixir versions will also introduce fine-grained types here.\n\n## Set operations\n\nWe can compose set-theoretic types by using set operations (hence the name).\nFor example, to say a function returns either atoms or integers, one could\nwrite: atom() or integer().\n\nIntersections are available via the and operator, such as atom() and\ninteger(), which in this case it becomes the empty set none(). term() is the\nunion of all types, also known as the \"top\" type.\n\nIntersections are useful when modelling functions. For example, imagine the\nfollowing function:\n\n    \n    \n    def negate(x) when is_integer(x), do: -x def negate(x) when is_boolean(x), do: not x\n\nIf you give it an integer, it negates it. If you give it a boolean, it negates\nit.\n\nWe can say this function has the type (integer() -> integer()) because it is\ncapable of receiving an integer and returning an integer. In this case,\n(integer() -> integer()) is a set that represents all functions that can\nreceive an integer and return an integer. Even though this function can\nreceive other arguments and return other values, it is still part of the\n(integer() -> integer()) set.\n\nThis function also has the type (boolean() -> boolean()), because it receives\nthe booleans and returns booleans. Therefore, we can say the overall type of\nthe function is (integer() -> integer()) and (boolean() -> boolean()). The\nintersection means the function belongs to both sets.\n\nAt this point, some may ask, why not a union? As a real-world example, take a\nt-shirt with green and yellow stripes. We can say the t-shirt belongs to the\nset of \"t-shirts with green color\". We can also say the t-shirt belongs to the\nset of \"t-shirts with yellow color\". Let's see the difference between unions\nand intersections:\n\n  * (t_shirts_with_green() or t_shirts_with_yellow()) - contains t-shirts with either green or yellow, such as green, green and red, green and yellow, yellow, yellow and red, etc.\n\n  * (t_shirts_with_green() and t_shirts_with_yellow()) - contains t-shirts with both green and yellow (and also other colors)\n\nSince the t-shirt has both colors, we say it belongs to the intersection of\nboth sets. The same way that a function that goes from (integer() and\ninteger()) and (boolean() -> boolean()) is also an intersection. In practice,\nit does not make sense to define the union of two functions in Elixir, so the\ncompiler will always point to the right direction.\n\nFinally, we can also negate types by using not. For example, to express all\natoms, except the atoms :foo and :bar, one can write: atom() and not (:foo or\n:bar).\n\n## The dynamic() type\n\nExisting Elixir programs do not have type declarations, but we still want to\nbe able to type check them. This is done with the introduction of the\ndynamic() type.\n\nWhen Elixir sees the following function:\n\n    \n    \n    def negate(x) when is_integer(x), do: -x def negate(x) when is_boolean(x), do: not x\n\nElixir type checks it as if the function had the type (dynamic() ->\ndynamic()). We say dynamic() is a gradual type, which leads us to gradual set-\ntheoretic types.\n\nThe simplest way to reason about dynamic() in Elixir is that it is a range of\ntypes. If you have a type atom() or integer(), the underlying code needs to\nwork with both atom() or integer(). For example, if you call\nInteger.to_string(var), and var has type atom() or integer(), the type system\nwill emit a warning, because Integer.to_string/1 does not accept atoms.\n\nHowever, by intersecting a type with dynamic(), we make the type gradual and\ntherefore only a subset of the type needs to be valid. For instance, if you\ncall Integer.to_string(var), and var has type dynamic() and (atom() or\ninteger()), the type system will not emit a warning, because\nInteger.to_string/1 works with at least one of the types. For convenience,\nmost programs will write dynamic(atom() or integer()) instead of the\nintersection. They are equivalent.\n\nCompared to other gradually typed languages, the dynamic() type in Elixir is\nquite powerful: it restricts our program to certain types, via intersections,\nwhile still emitting warnings once it is certain the code will fail. This\nmakes dynamic() an excellent tool for typing existing Elixir code with\nmeaningful warnings.\n\nOnce Elixir introduces typed function signatures, typed Elixir programs will\nbehave as a statically typed code, unless the dynamic() type is used. This\nbrings us to one last remark about dynamic types in Elixir: dynamic types are\nalways at the root. For example, when you write a tuple of type {:ok,\ndynamic()}, Elixir will rewrite it to dynamic({:ok, term()}). While this has\nthe downside that you cannot make part of a tuple/map/list gradual, only the\nwhole tuple/map/list, it comes with the upside that dynamic is always\nexplicitly at the root, making it harder to accidentally sneak dynamic() in a\nstatically typed program.\n\n## Roadmap\n\nThe current milestone is to implement type inference and type checking of\nElixir programs without changes to the Elixir language. At this stage, we want\nto collect feedback on the quality of error messages and performance, and\ntherefore the type system has no user facing API.\n\nIf the results are satisfactory, the next milestone will include a mechanism\nfor defining typed structs. Elixir programs frequently pattern match on\nstructs, which reveals information about the struct fields, but it knows\nnothing about their respective types. By propagating types from structs and\ntheir fields throughout the program, we will increase the type system\u2019s\nability to find errors while further straining our type system implementation.\nProposals including the required changes to the language surface will be sent\nto the community once we reach this stage.\n\nThe third milestone is to introduce set-theoretic type signatures for\nfunctions. Unfortunately, the existing typespecs are not precise enough for\nset-theoretic types and they will be phased out of the language and moved into\na separate library once this stage concludes.\n\n## Acknowledgements\n\nThe type system was made possible thanks to a partnership between CNRS and\nRemote. The research was partially supported by Supabase and Fresha. The\ndevelopment work is sponsored by Fresha, Starfish*, and Dashbit.\n\n\u2190 Previous Page Compatibility and deprecations\n\nNext Page \u2192 Library guidelines\n\nDownload ePub version\n\nBuilt using ExDoc (v0.32.1) for the Elixir programming language\n\n", "frontpage": false}
