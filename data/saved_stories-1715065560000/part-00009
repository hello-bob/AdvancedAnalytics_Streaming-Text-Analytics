{"aid": "40278380", "title": "Automatic checking of cfgs at compile-time", "url": "https://blog.rust-lang.org/2024/05/06/check-cfg.html", "domain": "rust-lang.org", "votes": 1, "user": "weinzierl", "posted_at": "2024-05-06 19:13:11", "comments": 0, "source_title": "Automatic checking of cfgs at compile-time | Rust Blog", "source_text": "Automatic checking of cfgs at compile-time | Rust Blog\n\n## Automatic checking of cfgs at compile-time\n\nMay 6, 2024 \u00b7 Urgau on behalf of The Cargo Team\n\nThe Cargo and Compiler team are delighted to announce that starting with Rust\n1.80 (or nightly-2024-05-05) every reachable #[cfg] will be automatically\nchecked that they match the expected config names and values.\n\nThis can help with verifying that the crate is correctly handling conditional\ncompilation for different target platforms or features. It ensures that the\ncfg settings are consistent between what is intended and what is used, helping\nto catch potential bugs or errors early in the development process.\n\nThis addresses a common pitfall for new and advanced users.\n\nThis is another step to our commitment to provide user-focused tooling and we\nare eager and excited to finally see it fixed, after more than two years since\nthe original RFC 3013^1.\n\n## A look at the feature\n\nEvery time a Cargo feature is declared that feature is transformed into a\nconfig that is passed to rustc (the Rust compiler) so it can verify with it\nalong with well known cfgs if any of the #[cfg], #![cfg_attr] and cfg! have\nunexpected configs and report a warning with the unexpected_cfgs lint.\n\nCargo.toml:\n\n    \n    \n    [package] name = \"foo\" [features] lasers = [] zapping = []\n\nsrc/lib.rs:\n\n    \n    \n    #[cfg(feature = \"lasers\")] // This condition is expected // as \"lasers\" is an expected value // of the `feature` cfg fn shoot_lasers() {} #[cfg(feature = \"monkeys\")] // This condition is UNEXPECTED // as \"monkeys\" is NOT an expected // value of the `feature` cfg fn write_shakespeare() {} #[cfg(windosw)] // This condition is UNEXPECTED // it's supposed to be `windows` fn win() {}\n\ncargo check:\n\n## Custom cfgs and build scripts\n\n> In Cargo point-of-view: a custom cfg is one that is neither defined by rustc\n> nor by a Cargo feature. Think of tokio_unstable, has_foo, ... but not\n> feature = \"lasers\", unix or debug_assertions\n\nSome crates use custom cfgs that they either expected from the environment\n(RUSTFLAGSor other means) or is enabled by some logic in the crate build.rs.\nFor those crates Cargo provides a new instruction: cargo::rustc-check-cfg^2\n(or cargo:rustc-check-cfg for older Cargo version).\n\nThe syntax to use is described in the rustc book section checking\nconfiguration, but in a nutshell the basic syntax of --check-cfg is:\n\n    \n    \n    cfg(name, values(\"value1\", \"value2\", ..., \"valueN\"))\n\nNote that every custom cfgs must always be expected, regardless if the cfg is\nactive or not!\n\n### build.rs example\n\nbuild.rs:\n\n    \n    \n    fn main() { println!(\"cargo::rustc-check-cfg=cfg(has_foo)\"); // ^^^^^^^^^^^^^^^^^^^^^^ new with Cargo 1.80 if has_foo() { println!(\"cargo::rustc-cfg=has_foo\"); } }\n\n> Each cargo::rustc-cfg should have an accompanying unconditional\n> cargo::rustc-check-cfg directive to avoid warnings like this: unexpected cfg\n> condition name: has_foo.\n\n### Equivalence table\n\ncargo::rustc-cfg| cargo::rustc-check-cfg  \n---|---  \nfoo| cfg(foo) or cfg(foo, values(none()))  \nfoo=\"\"| cfg(foo, values(\"\"))  \nfoo=\"bar\"| cfg(foo, values(\"bar\"))  \nfoo=\"1\" and foo=\"2\"| cfg(foo, values(\"1\", \"2\"))  \nfoo=\"1\" and bar=\"2\"| cfg(foo, values(\"1\")) and cfg(bar, values(\"2\"))  \nfoo and foo=\"bar\"| cfg(foo, values(none(), \"bar\"))  \n  \nMore details can be found in the rustc book.\n\n## Frequently asked questions\n\n### Can it be disabled?\n\nFor Cargo users, the feature is always on and cannot be disabled, but like any\nother lints it can be controlled: #![warn(unexpected_cfgs)].\n\n### Does the lint affect dependencies?\n\nNo, like most lints, unexpected_cfgs will only be reported for local packages\nthanks to cap-lints.\n\n### How does it interact with the RUSTFLAGS env?\n\nYou should be able to use the RUSTFLAGS environment variable like it was\nbefore. Currently --cfg arguments are not checked, only usage in code are.\n\nThis means that doing RUSTFLAGS=\"--cfg tokio_unstable\" cargo check will not\nreport any warnings, unless tokio_unstable is used within your local crates,\nin which case crate author will need to make sure that that custom cfg is\nexpected with cargo::rustc-check-cfg in the build.rs of that crate.\n\n### How to expect custom cfgs without a build.rs?\n\nThere is currently no way to expect a custom cfg other than with cargo::rustc-\ncheck-cfg in a build.rs.\n\nCrate authors that don't want to use a build.rs are encouraged to use Cargo\nfeatures instead.\n\n### How does it interact with other build systems?\n\nNon-Cargo based build systems are not affected by the lint by default. Build\nsystem authors that wish to have the same functionality should look at the\nrustc documentation for the --check-cfg flag for a detailed explanation of how\nto achieve the same functionality.\n\n  1. The stabilized implementation and RFC 3013 diverge significantly, in particular there is only one form for --check-cfg: cfg() (instead of values() and names() being incomplete and subtlety incompatible with each other). \u21a9\n\n  2. cargo::rustc-check-cfg will start working in Rust 1.80 (or nightly-2024-05-05). From Rust 1.77 to Rust 1.79 (inclusive) it is silently ignored. In Rust 1.76 and below a warning is emitted when used without the unstable Cargo flag -Zcheck-cfg. \u21a9\n\n#### Get help!\n\n  * Documentation\n  * Contact the Rust Team\n\n#### Terms and policies\n\n  * Code of Conduct\n  * Licenses\n  * Logo Policy and Media Guide\n  * Security Disclosures\n  * All Policies\n\n#### Social\n\n#### RSS\n\n  * Main Blog\n  * \"Inside Rust\" Blog\n\nMaintained by the Rust Team. See a typo? Send a fix here!\n\n", "frontpage": false}
