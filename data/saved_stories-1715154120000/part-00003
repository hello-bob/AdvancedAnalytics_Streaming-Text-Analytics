{"aid": "40293505", "title": "Needle: A DFA Based Regex Library That Compiles to JVM ByteCode", "url": "https://justinblank.com/experiments/needle.html", "domain": "justinblank.com", "votes": 5, "user": "todsacerdoti", "posted_at": "2024-05-08 01:38:49", "comments": 0, "source_title": "Needle: A DFA Based Regex Library that Compiles to JVM ByteCode", "source_text": "Needle: A DFA Based Regex Library that Compiles to JVM ByteCode\n\n  * ABOUT\n  * NOTEBOOKS\n  * EXPERIMENTS\n\n# Needle: A DFA Based Regex Library that Compiles to JVM ByteCode\n\nMany years ago, Kragen complained about the implementation and performance of\nJava regexes, and suggested that an implementation that emitted JVM bytecode\ncould perform better. It's been a minute, but I'm happy to report that\ncomplaining on the Internet has served its purpose.\n\nToday, I'm releasing the 0.0.1 version of needle, a library that compiles\nregular expressions to JVM bytecode. It compiles each regular expression to a\nDeterministic Finite Automaton (DFA), which is then compiled to a Java class.\nThe code analyzes the DFA to extract information that helps match more\nefficiently. It detects required prefixes, suffixes and infixes that can be\nfound using String.indexOf, as well as cases where the first character can be\neasily tested in a while loop (e.g. [Ss]). This lets the class spend less time\ninside the DFA automaton, and more in a fast loop.\n\n## Benchmarks\n\nRegex performance resists concise summarization, and the design of needle\nmakes this even more true. For instance, one optimization computes the minimum\nand maximum length of a match, and uses that to bail out early when a match is\nnot possible. This effect will show up when testing that an entire string\nmatches a regex, or when searching in a sufficiently small string, but won't\nshow up when finding substrings that match inside of a large string.\n\nI've written a number of benchmarks, covering many different cases, but need\nto write code to repeatably report and compare results. In the meantime, I've\nincluded the results for one specific benchmark (SherlockBenchmark).\n\nFor each regex, we search the Project Gutenberg edition of The Adventures of\nSherlock Holmes, finding all matches for the pattern. For each regex, we\ncompare the Java standard library, Needle, and the brics automaton library,\nwhich is an efficient DFA implementation.\n\nThere are three categories of patterns in the test:\n\n### Literals\n\nThese patterns have no repetition or meta-characters, and could be found using\nString.indexOf. Needle recognizes the literal, and includes a call to\nString.indexOf. The standard library is still significantly slower, but does\nsurprisingly well on these.\n\nOf course, doing well on these strings is not necessarily that interesting--\nunless there's a level of indirection, you could just replace the regex use\nwith a String.indexOf.\n\n  1. Sherlock\n  2. Adler\n  3. zqj\n  4. aqj\n  5. let us hear a true\n\nThese results include the time it takes to use String.indexOf in a loop.\nSubsequent graphs don't, because it no longer makes sense as a comparison.\n\n### Substring/Initial Character Searches\n\nThese patterns are not literals, but have literal components that let us\nnarrow the search space by using String.indexOf.\n\n  1. [Ss]herlock\n  2. anywhere|somewhere\n  3. Holmes.{0,25}Watson|Watson.{0,25}Holmes\n  4. the\\s\\w{1,20}\\s\\agency\n  5. Sherlock\\s\\w{1,20}ed\n  6. Sherlock|Street\n  7. the\\s+\\w+\n  8. [a-zA-Z]+ing\n  9. \\s[a-zA-Z]{0,12}ing\\s\n  10. [a-z][a-e]{6}z\n\n### Everything Else\n\nThese patterns have no substring to search for using String.indexOf so the\nmatching is done entirely by the automaton.\n\n  1. Sherlock|Holmes\n  2. Sherlock|Holmes|Watson|Irene|Adler|John|Baker\n  3. ([Ss]herlock)|([Hh]olmes)\n  4. Adler|Watson\n\nNeedle is slower than brics on these patterns, but still much faster than the\nstandard library. This is because the core loop of the needle automaton is\nslower than the brics automaton. When we have a usable substring for\nsearching, the performance of the regex is dominated by the speed of searching\nfor that substring, and the automata speed is less important. But when there\nis no substring, brics wins.\n\nThere are two things that I'd like to do here. First, we can probably expand\nthe cases where we do a fast loop searching for the initial character of our\nregex (or extend the search to non-initial characters). Looking at the cases\nabove, we have various facts about the initial character (it must be\nuppercase, it's one of four characters, etc). Some of these predicates should\nallow us to emit a call that efficiently checks if they're true.\n\nSecond, for the remaining regexes, that do not allow using a fast initial\nloop, I'll have to change the generated code to match or exceed the\nperformance of brics. I don't have a plan, but structurally, it has to be\npossible. Since we can compile each regex to an independent set of code, we\ncould in principle just output a loop with the same structure as the brics\nautomaton. It's unlikely that's the best approach, but it implies that there's\nno structural reason needle couldn't match any competitor's performance. The\nonly constraint is how much complexity we can handle in compiling different\nregexes.\n\n\u00a9 2023 Justin Blank\n\nI would love suggestions for material not covered in these links. For the time\nbeing, there is no automated way to leave feedback, but you can comment on HN,\nLobsters, or email me.\n\n", "frontpage": true}
