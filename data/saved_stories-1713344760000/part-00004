{"aid": "40059720", "title": "Identifying Dependencies Used via Dlopen()", "url": "https://lwn.net/SubscriberLink/969908/d900adbe85747cac/", "domain": "lwn.net", "votes": 1, "user": "tgamblin", "posted_at": "2024-04-17 02:17:08", "comments": 0, "source_title": "Identifying dependencies used via dlopen() [LWN.net]", "source_text": "Identifying dependencies used via dlopen() [LWN.net]\n\nLWN .net News from the source\n\n  * Content\n\n    * Weekly Edition\n    * Archives\n    * Search\n    * Kernel\n    * Security\n    * Events calendar\n    * Unread comments\n    * LWN FAQ\n    * Write for us\n\n| |\n\nSubscribe / Log in / New account\n\n# Identifying dependencies used via dlopen()\n\n## [LWN subscriber-only content]\n\n### Welcome to LWN.net\n\nThe following subscription-only content has been made available to you by an LWN subscriber. Thousands of subscribers depend on LWN for the best news from the Linux and free software communities. If you enjoy this article, please consider accepting the trial offer on the right. Thank you for visiting LWN.net!| | \n\n### Free trial subscription\n\nTry LWN for free for 1 month: no payment or credit card required. Activate\nyour trial subscription now and see why thousands of readers subscribe to\nLWN.net.  \n---  \n  \nBy Daroc Alden April 16, 2024\n\nThe recent XZ backdoor has sparked a lot of discussion about how the open-\nsource community links and packages software. One possible security\nimprovement being discussed is changing how projects like systemd link to\ndynamic libraries that are only used for optional functionality: using\ndlopen() to load those libraries only when required. This could shrink the\nattack surface exposed by dependencies, but the approach is not without\ndownsides \u2014 most prominently, it makes discovering which dynamic libraries a\nprogram depends on harder. On April 11, Lennart Poettering proposed one way to\neliminate that problem in a systemd RFC on GitHub.\n\nThe systemd project had actually already been moving away from directly\nlinking optional dependencies \u2014 but not for security reasons. In Poettering's\nexplanation of his proposal on Mastodon he noted: \"\"The primary reason for\n[using dlopen()] was to make it easier to build small disk images without\noptional components, in particular for the purpose of initrds or container\ndeployments.\"\" Some people have speculated that this change is what pushed\n\"Jia Tan\" to launch their attack at the beginning of April, instead of waiting\nuntil it was more robust.\n\nThere are several problems with using dlopen() for dependencies, however. One\nis that, unlike normal dynamic linking, using dlopen() exposes the functions\nprovided by the dependency as void pointers, which must be cast to the correct\ntype. If the type in the dependency does not match the type in the dependent\nprogram, this can open a potential avenue for type-confusion attacks. Several\nrespondants to Poettering's explanation on Mastodon worried that promoting the\nuse of dlopen() would be a detriment to security for this reason. James\nHenstridge said: \"\"I imagine you could hide some interesting bugs via not-\nquite-compatible function signatures (e.g. cause an argument to be truncated\nat 32 bits).\"\" Poettering replied:\n\n> In current systemd git we systematically use some typeof() macro magic that\n> ensures we always cast the func ptrs returned by dlopen() to the actual\n> prototype listed in the headers of the library in question. Thus we should\n> get the exact same type safety guarantees as you'd get when doing regular\n> dynamic lib linking. Took us a bit to come up with the idea that typeof()\n> can be used for this, but it's amazing, as we don't have to repeat other\n> libraries' prototypes in our code at all anymore.\n\nHenstridge agreed after looking at the code that it was \"\"quite elegant. It\nalso neatly solves the problem of assigning a symbol to the wrong function\npointer.\"\" Not all of the problems are so easily dismissed, however. The real\nproblem, according to Poettering's announcement is the fact that using\ndlopen() removes information from the program's ELF headers about what its\ndependencies are.\n\n> Now, I think there are many pros of this approach, but there are cons too. I\n> personally think the pros by far outweigh the cons, but the cons *do* exist.\n> The most prominent one is that turning shared library dependencies into\n> dlopen() dependencies somewhat hides them from the user's and tools view, as\n> the aforementioned tools won't show them anymore. Tools that care about this\n> information are package managers such as rpm/dpkg (which like to generate\n> automatic package dependencies based on ELF dependencies), as well initrd\n> generators such as dracut.\n\nHis proposed solution is to adopt a new convention for explicitly listing\noptional dependencies as part of the program itself. In the systemd RFC, he\ngave an example of a macro that could be used to embed the name of optional\ndependencies in a special section of the binary called \".note.uapi.dlopen\".\n\"UAPI\" stands for Userspace API \u2014 referring to the Linux Userspace API Group,\na relatively recent collaboration between distributions, package managers, and\nlarge software projects to define standardized interfaces for user-space\nsoftware. The initial proposal for what to encode in the note section was\nfairly bare-bones \u2014 just a type field, the string \"uapi\" denoting the ELF\nsection \"vendor\", and the name of the dependency in question.\n\nPoettering was also clear that it wouldn't be useful to implement this for\nsystemd on its own; the note would only be useful if other tooling decided to\nread it, and other projects choose to implement it. Mike Yuan was quick to\ncomment positively about the possibility of adding support to mkinitcpio, Arch\nLinux's initramfs generation tool, and pacman, the Arch package manager.\n\nLuca Boccassi agreed that he could \"\"look into adding a debhelper addon for\nthis\"\", but wondered if there should be some way to indicate whether a\ndependency is truly optional or that the program will fail if the dependency\nis missing. Poettering responded: \"\"If it is a hard dep, then it should not be\na dlopen() one. The whole reason for using dlopen() over regular ELF shared\nlibrary deps is after all that they can be weak\"\", although he did point out\nthat the type field means that \"\"the door is open to extend this later.\"\"\n\nAntonio \u00c1lvarez Feijoo raised another concern, pointing out: \"\"Some people are\nvery picky about the size of the initrd and don't like to include things that\naren't really necessary. [...] So yes, it's great to know which libraries are\nnecessary, but how to know what systemd component requires them?\"\" Boccassi\nreplied that this was an example of a situation where information on whether a\ndependency is required or recommended could be useful. Poettering disagreed,\nasserting that \"\"which libraries to actually include in an initrd is up to\nlocal configuration or distro policy.\"\" Ultimately, consumers of the new note\nsection can do whatever they would like with the information, including\nautomatically generating dependencies, or merely using them as a \"\"linter\"\" to\ncomplain about new weak dependencies that are not already known.\n\n> I think all such approaches are better than the status quo though: we'll add\n> a weak dep or turn a regular dep into a weak dep, and unless downstream\n> actually read NEWS closely (which well, they aren't necessarily good at)\n> they'll just rebuild their packages/initrd and now everything is hosed.\n\nThis appealed to Feijoo, who agreed that using the information as a sanity-\ncheck on package definitions made sense.\n\nCarlos O'Donell asked whether Poettering cared about exposing the specific\nsymbols and symbol versions that systemd uses, pointing out that existing ELF\nheaders include this information. He asserted that RPM uses this information\nwhen packaging a program. Poettering said that was a good question, but\nreplied:\n\n> To speak for the systemd usecase: even though we dlopen() quite a number of\n> libraries these days (21 actually), and we actually do provide symbol\n> versioning for our own libraries, we do not bother with listing symbol\n> versions for the stuff we dlopen(). We use plain dlsym() for all of them,\n> not dlvsym().\n\nHe went on to point out that requiring people to pin down symbol versions\nwould be \"\"a major additional ask\"\".\n\nPoettering did seem to think that there was some benefit to integrating this\nnew proposal into the existing implementation of dynamic linking in the GNU C\nlibrary (glibc). He asked O'Donell and Florian Weimer \u2014 who are both involved\nin the glibc project \u2014 \"\"should we proceed with this being some independent\nspec somewhere that just says '.note.uapi.dlopen contains this data, use it or\ndon't, bla bla bla'. Or did the concept of weak leaking interest you enough\nthat you think this should be done natively in glibc, binutils and so on?\"\"\nSome other operating systems \u2014 notably macOS \u2014 have a native concept of \"weak\nlinking\" for optional dependencies, so the idea of incorporating this\ninformation into the build system and standard library are not new.\n\nZbigniew J\u0119drzejewski-Szmek brought up an additional question about the\nformatting of the new section, asking whether it would make sense to use \"\"a\ncompact JSON representation\"\". J\u0119drzejewski-Szmek said that this could make it\neasy to add a human-meaningful description of what the dependency is used for.\nWith that addition, \"\"it should be fairly easy to integrate this in the rpm\nbuild system.\"\" Boccassi agreed that the payload should be JSON. Poettering\nreplied: \"\"I have nothing against using JSON for this, but it's key we can\nreasonably generate this from a simple no-deps C macro I'd say.\"\"\n\nUltimately, the idea of having a standard encoding for optional dependencies\nseems to have been well-received, with several package managers potentially\ninterested in adding support. With discussion still ongoing and the final\nformat of the added information up in the air, however, it's too soon to say\nexactly what form the information will take. Anything intended to help\nameliorate the pain of removing traditional dynamically linked dependencies\nseems like a good idea, though, since they reduce the surface open to XZ-\nbackdoor-like attacks.\n\n> Did you like this article? Please accept our trial subscription offer to be\n> able to see more content like it and to participate in the discussion.  \n> ---  \n  \n(Log in to post comments)\n\n### Identifying dependencies used via dlopen()\n\nPosted Apr 16, 2024 21:16 UTC (Tue) by andresfreund (subscriber, #69562)\n[Link]\n\nHi,\n\nIt seems the medium to long term solution ought to be to properly support\n\"lazily loaded dependencies\" at the ELF level. Implementing this via dlopen()\nin various places doesn't scale all that well and makes it harder to centrally\nimprove performance and security. The dlopen() approach pretty much requires\nindirect function calls via modifiable pointers, which isn't great. And as the\narticle points out, it makes stuff like symbol versioning much more onerous.\n\nWith proper support by the dynamic linker, each lazy-loaded library could get\na distinct \"range\" in an SO's GOT that could separately get remapped. That\nstill would increase exposure over the non-lazy -z now -z relro binaries, but\nnot to the degree that dlopen() ends up doing (and we just have seen -z now\nhas its own risks).\n\nGreetings,\n\nAndres\n\n### Identifying dependencies used via dlopen()\n\nPosted Apr 16, 2024 22:06 UTC (Tue) by ibukanov (subscriber, #3942) [Link]\n\nThe main problem with using normally linked libraries is that the loader can\nrun arbitrary code coming from the library on the application startup even if\nthe library is never used. Stop that and the problem solved. Of cause that\nrequires quite a lot of work to ensure that the library initialisation code\nwill be properly run on the first use before the library function is called,\nbut long term this should be doable.\n\n### Identifying dependencies used via dlopen()\n\nPosted Apr 17, 2024 1:49 UTC (Wed) by azumanga (subscriber, #90158) [Link]\n\nWhile this is a longer-time goal, I really hope we can get to full sandboxing,\nmaybe via something like WASM?\n\nThere really is no need for something like xz, when used as a library\ndependancy, to have any more access than \"input data goes here, output data\ngoes here\".\n\n### Identifying dependencies used via dlopen()\n\nPosted Apr 16, 2024 22:30 UTC (Tue) by flussence (subscriber, #85566) [Link]\n\nYes please. This looks like a good start. Long-term I'd like to see something\nshaped like WebExtensions manifests but for ELF files to declare what they\nwant to do up front.\n\nFew ideas: - A fixed list of dlopen patterns like this needs basic shell globs\nand a subset of variables if possible (so you can have desktop applications\ndeclare intent to load from ~/.local/<foo>/plugins/ or $XDG_RUNTIME_FOOBAR\ninstead of just giving up). - A capability bounding set stored in the binary\nwould be good for system services instead of leaving that as a sysadmin\nguessing game. I can count on one hand the number of daemons I've encountered\nthat bother to fill in that part of their systemd .service files, it needs to\nbe ubiquitous and frictionless to get any adoption. This would be\ncomplementary to xattr caps since those are about increasing privileges (and\nalso they don't work over NFS). - It's probably unreasonable to try to cram\nseccomp or network rules in here, given that understanding either of those\nseems to be a full time job. Unless it's something *extremely* simple like\n\"disallow all network and socket access\" or \"give me seccomp mode 1\"... but\nthen that'd break \"/bin/true --help\" on a GNU system.\n\n### Identifying dependencies used via dlopen()\n\nPosted Apr 17, 2024 2:36 UTC (Wed) by Cyberax (\u272d supporter \u272d, #52523) [Link]\n\nBlergh. Bad ideas on top of bad ideas. dlopen() should NOT be used at all\nnormally.\n\nOK, you screwed up with libsystemd exploding it in size until it became a\nproblem. So live with it, and create another separate library that only\ncontains lean stuff (\"liblightsystemd\" or whatever). Split the heavy\ndependencies into a separate \"libjournald\".\n\nInstead we're now getting hacks upon hacks that further complicate the system.\n\nCopyright \u00a9 2024, Eklektix, Inc. Comments and public postings are copyrighted\nby their creators. Linux is a registered trademark of Linus Torvalds\n\n", "frontpage": false}
