{"aid": "40214892", "title": "What Happens When Python Starts Up? CPython Runtime Internals", "url": "https://codeconfessions.substack.com/p/cpython-runtime-internals", "domain": "codeconfessions.substack.com", "votes": 1, "user": "lairv", "posted_at": "2024-04-30 19:03:53", "comments": 0, "source_title": "What Happens When Python Starts Up? CPython Runtime Internals", "source_text": "What Happens When Python Starts Up? CPython Runtime Internals\n\nShare this post\n\n#### What Happens When Python Starts Up? CPython Runtime Internals\n\ncodeconfessions.substack.com\n\n# What Happens When Python Starts Up? CPython Runtime Internals\n\n### CPython JIT Internals, Part 1: What is the Runtime and How is it\ninitialized?\n\nAbhinav Upadhyay\n\nApr 26, 2024\n\n\u2219 Paid\n\n15\n\nShare this post\n\n#### What Happens When Python Starts Up? CPython Runtime Internals\n\ncodeconfessions.substack.com\n\nShare\n\nI recently announced that I will be writing a series on CPython\u2019s JIT compiler\ninternals. But, before we get to the JIT compiler we need to cover a lot of\nground about the things which happen before it, because all of that context is\nrequired to understand how the JIT compiler is implemented in CPython.\n\nThe following things happen in the CPython runtime before the JIT compiler\nactually kicks in:\n\n  * When the CPython process starts up, it performs runtime initialization. The runtime contains critical data required for the operation of the rest of the virtual machine.\n\n  * Next, the Python code gets parsed and compiled into bytecode instructions, this is called tier-1 bytecode. This compiled bytecode is interpreted by the tier-1 bytecode interpreter.\n\n  * The tier-1 bytecode interpreter further profiles the instructions and the hot paths are optimized and converted into tier-2 bytecode. The tier-2 bytecode is interpreted by a tier-2 bytecode interpreter.\n\n  * Finally, the JIT compiler translates tier-2 bytecode into native code.\n\nYou can clearly see the dependency between the different stages of code\nexecution within CPython. It is possible to explain the JIT compiler\nindependently of everything else, but we cannot go into the implementation\ndetails. So, I am starting from the beginning and going to cover all of these\nstages.\n\nThis first article starts at the CPython runtime and talks about what the\nCPython runtime is, how it is represented and how it is initialized when we\nstart executing a Python program.\n\n> Early Access: I\u2019m writing this whole CPython JIT internals series in early\n> access mode where the articles will first be behind the paywall until the\n> series is finished. I will open these once all the articles of the series\n> are published. This whole series is a lot of work, this article itself is\n> roughly 17 pages long, so I hope you\u2019ll support me.\n\nPhoto by Kevin Canlas on Unsplash\n\n##\n\nWhat Happens When We Execute a Python Program?\n\nBefore we dive into the specifics of the internal implementation details of\nthe CPython, let\u2019s do a high level overview of the set of things that happen\nwhen executing a Python program. This will help us understand why we are\nstarting at the runtime and not directly at the bytecode interpreter.\n\nThe following figure illustrates the set of events that take place when we\nstart the Python interpreter.\n\nBefore CPython can start executing any Python code it first needs to\ninitialize the runtime and then invoke the bytecode interpreter to execute the\nbytecode\n\nBroadly, it happens in three parts:\n\n  * First the main function of the CPython implementation starts up.\n\n  * The main function first performs the runtime initialization. The CPython runtime includes the main interpreter, the main execution thread, any statically initialized objects (such as small integers, free list cache), memory allocators, interned strings cache etc. Here, the main interpreter and the thread are the important bits of the runtime state which are critical for the operation of the bytecode interpreter.\n\n  * Finally, once the runtime is in place, then the main function triggers the code execution path where the user\u2019s Python code is parsed and compiled to bytecode and then the bytecode interpreter comes into the picture to interpret the bytecode.\n\nSince we are just getting started, we will focus on the runtime initialization\npart.\n\n##\n\nThe CPython Runtime Representation\n\nThe whole focus of this article is around the initialization of the CPython\nruntime, so we must first look at how this runtime is represented in code.\n\nThe CPython runtime state is represented by the struct _PyRuntimeState which\nis defined in the file Include/internal/pycore_runtime.h. It\u2019s a very large\nstruct but the following figure shows some of its key fields which will be our\nfocus during this article series as well.\n\nThe definition of the _PyRunttimeState struct which represents CPython\u2019s\nruntime state\n\nThe two main things in the CPython runtime are all the interpreters and all\nthe threads because these are the ones responsible for all the Python code\nexecution.\n\nThe CPython process starts with one main interpreter and usually that is the\nonly interpreter.However, user code can also start one or more\nsubinterpreters.\n\nThe CPython runtime tracks the state of these interpreters using a linked list\nof interpreter state objects. The head of this linked list is the main\ninterpreter and every subinterpreter when created gets added to this linked\nlist.\n\nSimilarly, there is one main thread which is associated with the main\ninterpreter. The runtime tracks the state of this thread using the main_tstate\nfield.\n\nLet\u2019s now see the definition of the interpreter state and thread state\nobjects.\n\n##\n\nRepresentation of the Interpreter State in CPython\n\nEvery interpreter in the CPython has a state which is represented using the\nPyInterpreterState struct defined in the file\nInclude/internal/pycore_interp.h. The struct is pretty large so I cannot show\nits full definition, however, the following figure shows and annotates some of\nits most important fields.\n\nThe definition of the PyInterpreterStruct which represents the interpreter\nstate in CPython\n\nThe annotations do a pretty good job of explaining the important fields of the\nPyInterpreterState struct. From the point of view of the bytecode interpreter,\nthe threads field is the most important one. It maintains a linked list of the\nstates of all the threads within that interpreter, and it also holds a\nreference to the thread state of the main thread (the threads.main field).\n\nThe thread state of the main thread contains the stack frame of the function\nthat is currently executing on the interpreter, the stack, instruction pointer\netc. These details are exactly what represent the state of the interpreter.\n\n##\n\nThe Thread State Representation\n\nIn CPython runtime, each OS thread has at least one associated thread state.\nThis state is represented by the struct PyThreadState which is defined in the\nfile Include/cpython/pystate.h.\n\nThe definition of the PyThreadState struct which represents the state of the\nthread in the CPython runtime\n\nAgain, this struct is too big to show all of it. I\u2019ve truncated it and shown\nsome of the important fields which are relevant from the point of view of the\nbytecode interpreter code.\n\nThe most important field in the thread state is the frame pointer which points\nto the stack frame of the currently executing Python function on the bytecode\ninterpreter (VM). The stack frame contains the bytecode of the function being\nexecuted, instruction pointer, the stack and all the related states. We will\ndiscuss it in more detail in the next article when we get to see the bytecode\ninterpreter implementation.\n\n###\n\nHow the Thread State is Stored and Accessed?\n\nAs there can be multiple threads in the interpreter and each of those have\ntheir own thread states, the interpreter needs a fast and safe mechanism to\nget the thread state of the currently active thread.\n\nTo enable this, each thread\u2019s current thread state is stored in a thread local\nvariable called _Py_tss_tstate and it is defined in the file Python/pystate.c.\n\n> Thread local storage (TLS) is a private area in the memory of each thread\n> which is not shared with other threads in the process. Any object stored in\n> the thread local storage means that each thread will have its own copy of\n> that object and when we try to access that object, we will get the object\n> from the local storage of the currently active thread.\n\nIn order to get the currently active thread state, CPython implements an\ninline function called _PyThreadState_GET which is used throughout the VM\nimplementation. The following figure shows its definition.\n\nThe PyThreadState_Get() function is used to get the thread state of the\ncurrent thread\n\nIt is also possible for one OS thread to have multiple thread states, in which\ncase it switches these thread states using the function _PyThreadState_Swap\ndefined in the file Python/pystate.c.\n\nThe definition of the _PyThreadState_Swap function which is used to swap\nthread states of a thread in CPython runtime.\n\n##\n\nSummary of CPython Runtime State\n\nThis pretty much covers the important details that we need to know about the\nCPython\u2019s runtime state in order to dive into its bytecode interpreter\nimplementation. Let\u2019s summarize it quickly:\n\n  * The CPython runtime state is represented by the struct _PyRuntimeState.\n\n  * It maintains all the global state of the runtime. The couple of important fields from the point of view of the bytecode interpreter are the list of interpreter states and the main thread\u2019s thread state fields.\n\n  * Usually there will only be one main interpreter but it is also possible to have many subinterpreters, all of these are tracked by the runtime using a linked list. The runtime state holds reference to the main interpreter\u2019s state and then that has the reference to the next interpreter\u2019s state.\n\n  * The interpreter state is represented by the struct PyInterpreterState. Even though it tracks a lot of things related to the execution of the interpreter, the most important field is the threads field which is a linked list of all the thread states active in the interpreter. Usually the interpreter will only have one main thread state, but if more threads are created, then their states are attached to this linked list. At any point of time, the threads.main field will point to the thread state of the currently active thread in the interpreter.\n\n  * Finally, the state of a thread is represented by the struct PyThreadState. Each thread state is associated with only one OS thread and only one interpreter. However, one OS thread may have multiple associated thread states. The currently active thread state is stored in a thread local variable and can be accessed via the function _PyThreadState_GET.\n\nThis covers what the runtime state is and what information it stores. The next\npart of the article covers a walk through of the CPython code to show how\nexactly all of this state is initialized when we start executing a Python\nprogram.\n\nIf you don\u2019t want to become a paid subscriber, you can also buy me a coffee\nand I will give you one month complimentary paid subscription.\n\nBuy me a coffee\n\n## This post is for paid subscribers\n\nAlready a paid subscriber? Sign in\n\n\u00a9 2024 Abhinav Upadhyay\n\nPrivacy \u2219 Terms \u2219 Collection notice\n\nStart WritingGet the app\n\nSubstack is the home for great culture\n\nShare\n\n", "frontpage": false}
