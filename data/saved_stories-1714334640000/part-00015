{"aid": "40187534", "title": "Chip-8 on the COSMAC VIP: The Character Set", "url": "https://www.laurencescotford.net/2020/07/19/chip-8-on-the-cosmac-vip-the-character-set/", "domain": "laurencescotford.net", "votes": 1, "user": "hggh", "posted_at": "2024-04-28 10:35:41", "comments": 0, "source_title": "Chip-8 on the COSMAC VIP: The Character Set \u2013 Laurence Scotford", "source_text": "Chip-8 on the COSMAC VIP: The Character Set \u2013 Laurence Scotford\n\nSkip to content\n\nLaurence Scotford\n\nIdeas for digital learning and games\n\n# Sidebar\n\n## Recent Posts\n\n  * Games programming from the ground up with C: Validating and processing player moves\n  * Games programming from the ground up with C: Building a form\n  * Getting my head in the cloud\n  * Give your web API some front\n  * Creating slide out or drop down mobile menus with CSS\n\n## Recent Comments\n\nNo comments to show.\n\n# Chip-8 on the COSMAC VIP: The Character Set\n\nPublished by Laurence Scotford on July 19, 2020\n\nThis is part of a series of posts analysing the Chip-8 interpreter on the RCA\nCOSMAC VIP computer. These posts may be useful if you are building a Chip-8\ninterpreter on another platform or if you have an interest in the operation of\nthe COSMAC VIP. For other posts in the series refer to the index or\ninstruction index.\n\nINSTRUCTION GROUP: FX29 Load I with address of sprite for the character in VX\n\nThe only means of getting data onto the Chip-8 display is using the DXYN\ninstruction to display a sprite. So Chip-8 has a character set, consisting of\nall the hexadecimal digits, in which each digit is stored as a pre-defined\nsprite, allowing the programmer to use the DXYN instruction to display these.\n\nThe character set sprites are stored in the ROM. Each character is just four\npixels wide. As Chip-8 sprites are one byte wide, the characters are aligned\nto the left side of the sprite and the rightmost four pixels of the sprite are\nset to 0. Each character is five pixels high. If they were stored in a linear\nfashion, this would require 80 bytes of memory (16 characters, each consuming\n5 bytes). Today we wouldn\u2019t worry about losing 80 bytes any more than we\u2019d\nworry about a penny that slipped through our fingers and rolled down a drain.\nHowever, when your ROM is only 512 bytes, every byte suddenly becomes\nsignificant. So the Chip-8 character set sprites were designed in such a way\nthat the data for some characters overlaps. Here\u2019s what that looks like:\n\nA diagram showing how the Chip-8 character set is stored in the COSMAC VIP\u2019s\nROM\n\nThis little trick cuts the space requirement from 80 to 51 bytes. Of course\nthe advantage of having the characters stored linearly, with each occupying\nits own five-byte space, would be that you could calculate the start address\nof a sprite simply by multiplying the required digit by five and adding this\nto the base address. With the sprites compressed the way they are in the\nCOSMAC VIP that\u2019s not an option, so the ROM also contains a look-up table with\nthe low-order byte of the address of each sprite. This adds an overhead of 16\nbytes. Even so, this still saves 13 bytes over the standard way of doing\nthings. That doesn\u2019t sound like it would be worth the effort until you realise\nthat 13 bytes is 2.5% of the total ROM! This really is a case of having to\nmake every byte count.\n\nChip-8 provides an instruction, FX29, that puts the address of the sprite for\nthe character in VX into the index variable I. This is then ready to be used\nwith a DXY5 instruction to display the character on screen at coordinates X,\nY. It works by getting the least significant digit of VX and using this as an\noffset into the look-up table. The value of the relevant byte in the look-up\ntable is then combined with the high order byte 0x81 to create the full\naddress to the start of the sprite data for the requested character.\n\nHere\u2019s the code for that routine:\n\nLabels Address (hex)| Code (hex) Assembly| Comments  \n---|---|---  \nFX29: 0129| F8 81 LDI 0x81| Both the look up table and the sprite data are\nlocated in the ROM in page 0x81.  \n012B| BA PHI A| Store this in the high order byte of I (RA.1).  \n012C| 06 LDN 6| Get the value in VX (R6).  \n012D| FA 0F ADI 0x0F| Apply a mask to save just the least significant digit.  \n012F| AA PLO A| I now points to the correct entry in the look-up table.  \n0130| 0A LDN A| Get the low-order byte of the sprite address from the look-up\ntable.  \n0131| AA PLO A| I now points to the start of the data for the correct sprite.  \n0132| D4 SEP 4| Return to the fetch and decode routine.  \n  \nExecution time for this routine is 16 machine cycles (72.64 microseconds). As\nthis is an FXXX instruction, the small overhead for the second stage decoding\nof these instructions needs to be added. See this earlier post for details.\n\nIn contemporary Chip-8 interpreters it is customary to store the character set\nsprites in the first 80 bytes of the memory space that would have originally\nbeen occupied by the Chip-8 interpreter, i.e. from address 0x0000. Also, now\nthat memory is not at a premium, the following more regular character set,\nwithout any shared data between characters, is often used instead of the\noriginal set (note that characters are stored consecutively in memory \u2013 the\nblank lines included here between characters are for clarity only):\n\nA diagram showing the usual arrangement of the character set in contemporary\nChip-8 interpreters\n\nPublished inProgrammingRetro Computing\n\n  * chip-8\n  * cosmac vip\n  * programming\n  * rca-1802\n  * retro computing\n\n## Be First to Comment\n\n### Leave a Reply Cancel reply\n\nAuthor WordPress Theme by Compete Themes\n\n", "frontpage": false}
