{"aid": "40256489", "title": "Little Helper \u2013 An ESP32-based USB hardware display", "url": "https://iamyekta.com/post/2024/05/little-helper--an-esp32-based-usb-hardware-display/", "domain": "iamyekta.com", "votes": 1, "user": "yekta_", "posted_at": "2024-05-04 10:32:03", "comments": 0, "source_title": "Little Helper -- An ESP32-based USB hardware display - Yekta Leblebici", "source_text": "Little Helper -- An ESP32-based USB hardware display - Yekta Leblebici\n\n8 min read\n\n# Little Helper -- An ESP32-based USB hardware display\n\nMay 1, 2024\n\n## What is it?\n\nIt\u2019s a touch-enabled LCD screen that shows me hardware metrics from my main\nPC, mainly the ones related to utilization and temperature. Currently its\nfeatures are:\n\n  * Per-core CPU Utilization\n  * CPU Temperature (Max, Avg)\n  * GPU Utilization and Temperature (NVIDIA only)\n  * RAM Usage\n  * VRAM Usage\n  * Notification bar\n  * Date & Time\n\nTop three gauges are utilization percentages, and the bottom three are\ntemperature in Celsius. RAM and VRAM bars alternate every few seconds.\n\nI find it pretty useful with a custom-built gaming PC, as it helps me tell\nwhat is being a bottleneck at a glance, and temperature information is good\nsignal of something being wrong, or if the system will be throttling soon.\n\nAnd hey, bars and gauges look cool.\n\n## How does it work?\n\nHere is the bill of materials:\n\n  * Lilygo T-Display-S3 Touch\n  * LEGO Box 11028\n  * AmazonBasics USB-C to USB-A 2.0 Cable ^1\n\nSo, the hardware is basically an ESP32-S3 with a touch display, and housed in\na LEGO case because I wanted an excuse for building something with LEGOs. \ud83d\ude0a\n\nOn the software side, there are two components:\n\n  * Little Helper: the ESP32-side software written using Arduino in C++, with PlatformIO for ease of deployment.\n  * Little Companion: Windows program written in Go.\n\nThe Go program collects hardware metrics, and sends it over USB to the ESP32,\nwhich then visualizes the information on its screen.\n\n## What else could be done?\n\nThere are some more possibilities that come to my mind, but haven\u2019t\nimplemented them yet as I wanted to start out with something simpler. If\nyou\u2019re interested in building your own, here are some ideas straight from my\nTODO list:\n\n  * Display hanging/frozen apps, and one-touch kill them (sometimes can be useful on Windows)\n  * Display efficiency cores in a different color\n  * Disk I/O\n  * Network I/O\n  * Themes: wouldn\u2019t it be cool to display information on a Pip-Boy?\n  * Display some pixel art animation, because why not!\n\n## Little Helper: the ESP32 code\n\nLittle Helper is the name I gave to this project, and also the software that\nruns on ESP32. Since I didn\u2019t know much about writing software for it, I\nsimply copied some examples over from the MIT-licensed example repository for\nLilygo and started building on top of it. Basically it\u2019s Arduino and\nPlatformIO IDE to simplify deploying it.\n\nJust like many other Arduino programs, it has a short setup() function to\ninitialize itself and the display, and then runs the loop(). In my program it\nsleeps for around 100ms between refreshes, which is pretty frequent\nconsidering new data is received once a second.\n\nBecause it can\u2019t keep time (or at least I couldn\u2019t) while powered off, each\ntime it comes up it asks for the time from the Companion, and receives a UNIX\ntimestamp.\n\nAs for visualization, I\u2019ve simply used the excellent TFT_eSPI library which\nhad everything I needed: arcs, rectangles, text, colors and sprites.\n\n## Little Companion: the Go program on Windows\n\nThe Companion consumes about 10MB of memory. Although I haven\u2019t extensively\nbenchmarked it, from the Task Manager its CPU use shows up as 0%.\n\nStarting out I thought collecting metrics would be easy, and figuring out how\nto interface with the ESP32 would take some effort. It turned out to be\nopposite, thanks to the excellent cross-platform bugst/go-serial library\nsending data over USB was a breeze.\n\nCollecting the metrics on the other hand took more effort:\n\n  * For CPU and Memory utilization, I could easily use gopsutil, it\u2019s another excellent library, but doesn\u2019t support most other metrics I wanted on Windows.\n  * CPU Temperature: this has been such a hassle, it has a section of its own as an appendix below.\n  * GPU Utilization/Temperature: handled it by loading nvml.dll dynamically and calling its procedures. It took me some time to understand what I needed to do, but looking through the sys/windows package helped me out here.\n  * VRAM: Fun fact, initially I didn\u2019t even think of it. Then I noticed NVML returns both GPU and Memory utilization from nvmlDeviceGetUtilizationRates call, so I just made use of it.\n\nI also implemented monitoring for hung windows, in the process I\u2019ve learned\nwhat \u201cNot Responding\u201d actually means. This is what I do:\n\n  * Call windows.EnumWindows() to get a list of all windows.\n  * Call IsWindowVisible from user32.dll to check if it\u2019s a visible window. I don\u2019t care for invisible ones, sometimes they stop responding on their own and become false positives.\n  * Call IsHungAppWindow from user32.dll to check if the window is hung or not.\n  * Finally, if hung, I call GetWindowTextW and windows.GetWindowThreadProcessId() to get the name of the window to display and the PID in case I\u2019d like to terminate it.\n\nIt\u2019s most likely a premature optimization to find another way, and this will\nmost likely land on some idle E-core of my system anyway, but still it feels\nlike a bit too much work to run on a loop every second. I haven\u2019t found a\nbetter way of doing it though.\n\n## The protocol\n\nI made up a binary protocol between the two, in the current iteration it is\nsomething like this:\n\n    \n    \n    // Message received: 0x0, 0x1, 0x3, 0xFF // Time request: 0x0, 0x3, 0xFF // Time update: 0x0, 0x3, timestamp (4 bytes), 0xFF // Metric update: 0x0, 0x2, flags, cpuCoreCount, cpuLoadPct (1 byte * core), avgCpuTemp, highestCpuTemp, gpuLoadPct, gpuTemp, gpuMemUtilPct, memUsedPct, memUsedMegabytes (2 bytes), 0xFF\n\nAnd that\u2019s all folks!\n\n## Appendix: Getting per-core CPU temperature on Windows\n\nI have to admit, I started out implementing the hardware monitors knowing next\nto nothing about how to get the information I wanted. The vague thoughts in my\nmind were somewhere around \u201cI guess you\u2019d read them from /proc or /sys on a\nLinux machine\u201d and \u201cIt must be easy\u201d. I was wrong.\n\nAs a challenge for this blog post, I gave myself five minutes of Googling time\nto find out how to get per-core temperature on my Intel NUC running Linux. One\nof the first results just worked:\n\n    \n    \n    /sys/devices/platform/coretemp.0/hwmon/hwmon3 $ grep -Ri \"\" temp* temp2_crit:105000 temp2_crit_alarm:0 temp2_input:38000 temp2_label:Core 0 temp2_max:105000 [...]\n\nWell that was easy. To be fair I was probably lucky with this one, maybe\nrunning the right CPU on the right distro with the right version of Linux\nkernel. Still, can you believe how easy this was?\n\nNow let\u2019s do this on Windows.\n\nI won\u2019t pretend to be a Windows developer, most development I\u2019ve ever done on\na Windows box is usually done through SSH to a Linux box. This very blog post?\nI\u2019m writing on a self-hosted Visual Studio Code instance I have open on my\nbrowser. My Windows editor of choice is notepad.exe. ^2\n\nSo I started out with some googling and ChatGPT-ing. After being misled bunch\nof times with both (don\u2019t bother with WMI.), I changed course and instead went\nto read the code of some proper open source software and learn from my\nbetters.\n\nLibreHardwareMonitor is one of the most well-known hardware monitor software\non Windows, and as the name implies it is open source. After a short jumping\naround I learned that they read it from MSR, or Model Specific Registers from\nthe CPU. Now I won\u2019t be easily disheartened by having to find whatever I need\nfrom hundreds of pages long documentations, I consider that fun. What was\ndisheartening followed next:\n\n  * You can only RDMSR (Read MSR) from Ring 0.\n  * There seems to be no other interface that could relay the information I need on Windows.\n  * Except for an abandonware driver called WinRing0, which has a very nasty looking CVE against it.\n  * LibreHardwareMonitor still uses this very driver.\n  * Everyone is aware of its situation.\n  * But they can\u2019t do much because Windows won\u2019t let you load an unsigned driver, and getting it signed sounds like a huge ordeal. (and likely not possible for individuals at all).\n\nLast time I checked, this issue was still open and seemed far from getting\nresolved:\nhttps://github.com/LibreHardwareMonitor/LibreHardwareMonitor/issues/984/.\n\nI haven\u2019t needed to dive any deeper than the one liner on Linux, but a quick\ngoogling tells me there are msr and msr_safe modules (does it mean msr is not\nsafe? idk) and even a Go library seems to be available. What a luxury.\n\nAt this point, not wanting to disable any of the protections, and losing hope\nafter reading the issue on LHM, I threw the towel.\n\nOkay I still wanted to get CPU temperature data. I couldn\u2019t completely throw\nthe towel. Instead, I gave up on the idea of implementing everything in a\nsingle executable, and had to depend on another process: a well-known, but\nclosed source tool called Core Temp offers a shared memory interface, and\ncomes with its own, signed driver to read the data itself.\n\nOnce I walked the path of shame\u2014 I mean once I agreed to run another process\nin the background ^3 and have their .dll loaded to my Go program, everything\nbecame much simpler. In fact there was already a Go library called\ncoretempsdk-go and I practically needed nothing else.\n\nAs for Core Temp, it\u2019s a small footprint, pretty nice program that has a\ndaringly Web 1.0 website, and with its commercial version and being last\nupdated on late 2023, gives me some hope that maybe it\u2019s being maintained\nwell. Am I happy with this arrangement? No. But I am content with it, which is\nall I could get out of Windows for today.\n\n  1. Initially I had a much nicer USB-C to USB-A 3.0 cable, for some reason I did not work correctly. Device would show up but I couldn\u2019t open a serial connection to it. \u21a9\ufe0e\n\n  2. Joking. I have Visual Studio Code installed locally too. I rarely find a use for it though, except for projects such as this one. \u21a9\ufe0e\n\n  3. I was already using their software with a Logitech G13 for years before this project, so I just agreed to not uninstall it. \ud83d\ude42 \u21a9\ufe0e\n\n\u00a9 Yekta Leblebici\n\n  * RSS\n  * Fork me!\n\n", "frontpage": false}
