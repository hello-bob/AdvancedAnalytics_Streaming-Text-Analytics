{"aid": "40060198", "title": "Perlis's Programming Epigrams", "url": "https://www.cs.yale.edu/homes/perlis-alan/quotes.html", "domain": "yale.edu", "votes": 4, "user": "nomilk", "posted_at": "2024-04-17 03:43:18", "comments": 2, "source_title": null, "source_text": "Perlisisms - \"Epigrams in Programming\" by Alan J. Perlis\n\n# EPIGRAMS IN PROGRAMMING\n\n1\\. One man's constant is another man's variable.\n\n2\\. Functions delay binding; data structures induce binding. Moral: Structure\ndata late in the programming process.\n\n3\\. Syntactic sugar causes cancer of the semicolon.\n\n4\\. Every program is a part of some other program and rarely fits.\n\n5\\. If a program manipulates a large amount of data, it does so in a small\nnumber of ways.\n\n6\\. Symmetry is a complexity-reducing concept (co-routines include\nsubroutines); seek it everywhere.\n\n7\\. It is easier to write an incorrect program than understand a correct one.\n\n8\\. A programming language is low level when its programs require attention to\nthe irrelevant.\n\n9\\. It is better to have 100 functions operate on one data structure than 10\nfunctions on 10 data structures.\n\n10\\. Get into a rut early: Do the same process the same way. Accumulate\nidioms. Standardize. The only difference(!) between Shakespeare and you was\nthe size of his idiom list - not the size of his vocabulary.\n\n11\\. If you have a procedure with ten parameters, you probably missed some.\n\n12\\. Recursion is the root of computation since it trades description for\ntime.\n\n13\\. If two people write exactly the same program, each should be put into\nmicrocode and then they certainly won't be the same.\n\n14\\. In the long run every program becomes rococo - then rubble.\n\n15\\. Everything should be built top-down, except the first time.\n\n16\\. Every program has (at least) two purposes: the one for which it was\nwritten, and another for which it wasn't.\n\n17\\. If a listener nods his head when you're explaining your program, wake him\nup.\n\n18\\. A program without a loop and a structured variable isn't worth writing.\n\n19\\. A language that doesn't affect the way you think about programming, is\nnot worth knowing.\n\n20\\. Wherever there is modularity there is the potential for misunderstanding:\nHiding information implies a need to check communication.\n\n21\\. Optimization hinders evolution.\n\n22\\. A good system can't have a weak command language.\n\n23\\. To understand a program you must become both the machine and the program.\n\n24\\. Perhaps if we wrote programs from childhood on, as adults we'd be able to\nread them.\n\n25\\. One can only display complex information in the mind. Like seeing,\nmovement or flow or alteration of view is more important than the static\npicture, no matter how lovely.\n\n26\\. There will always be things we wish to say in our programs that in all\nknown languages can only be said poorly.\n\n27\\. Once you understand how to write a program get someone else to write it.\n\n28\\. Around computers it is difficult to find the correct unit of time to\nmeasure progress. Some cathedrals took a century to complete. Can you imagine\nthe grandeur and scope of a program that would take as long?\n\n29\\. For systems, the analogue of a face-lift is to add to the control graph\nan edge that creates a cycle, not just an additional node.\n\n30\\. In programming, everything we do is a special case of something more\ngeneral -- and often we know it too quickly.\n\n31\\. Simplicity does not precede complexity, but follows it.\n\n32\\. Programmers are not to be measured by their ingenuity and their logic but\nby the completeness of their case analysis.\n\n33\\. The eleventh commandment was \"Thou Shalt Compute\" or \"Thou Shalt Not\nCompute\" - I forget which.\n\n34\\. The string is a stark data structure and everywhere it is passed there is\nmuch duplication of process. It is a perfect vehicle for hiding information.\n\n35\\. Everyone can be taught to sculpt: Michelangelo would have had to be\ntaught not to. So it is with great programmers.\n\n36\\. The use of a program to prove the 4-color theorem will not change\nmathematics - it merely demonstrates that the theorem, a challenge for a\ncentury, is probably not important to mathematics.\n\n37\\. The most important computer is the one that rages in our skulls and ever\nseeks that satisfactory external emulator. The standarization of real\ncomputers would be a disaster - and so it probably won't happen.\n\n38\\. Structured Programming supports the law of the excluded middle.\n\n39\\. Re graphics: A picture is worth 10K words - but only those to describe\nthe picture. Hardly any sets of 10K words can be adequately described with\npictures.\n\n40\\. There are two ways to write error-free programs; only the third one\nworks.\n\n41\\. Some programming languages manage to absorb change, but withstand\nprogress.\n\n42\\. You can measure a programmer's perspective by noting his attitude on the\ncontinuing vitality of FORTRAN.\n\n43\\. In software systems, it is often the early bird that makes the worm.\n\n44.Sometimes I think the only universal in the computing field is the fetch-\nexecute cycle.\n\n45\\. The goal of computation is the emulation of our synthetic abilities, not\nthe understanding of our analytic ones.\n\n46\\. Like punning, programming is a play on words.\n\n47\\. As Will Rogers would have said, \"There is no such thing as a free\nvariable.\"\n\n48\\. The best book on programming for the layman is \"Alice in Wonderland\"; but\nthat's because it's the best book on anything for the layman.\n\n49\\. Giving up on assembly language was the apple in our Garden of Eden:\nLanguages whose use squanders machine cycles are sinful. The LISP machine now\npermits LISP programmers to abandon bra and fig-leaf.\n\n50\\. When we understand knowledge-based systems, it will be as before --\nexcept our fingertips will have been singed.\n\n51\\. Bringing computers into the home won't change either one, but may\nrevitalize the corner saloon.\n\n52\\. Systems have sub-systems and sub-systems have sub- systems and so on ad\ninfinitum - which is why we're always starting over.\n\n53\\. So many good ideas are never heard from again once they embark in a\nvoyage on the semantic gulf.\n\n54\\. Beware of the Turing tar-pit in which everything is possible but nothing\nof interest is easy.\n\n55\\. A LISP programmer knows the value of everything, but the cost of nothing.\n\n56\\. Software is under a constant tension. Being symbolic it is arbitrarily\nperfectible; but also it is arbitrarily changeable.\n\n57\\. It is easier to change the specification to fit the program than vice\nversa.\n\n58\\. Fools ignore complexity. Pragmatists suffer it. Some can avoid it.\nGeniuses remove it.\n\n59\\. In English every word can be verbed. Would that it were so in our\nprogramming languages.\n\n60\\. In seeking the unattainable, simplicity only gets in the way.\n\n61\\. In programming, as in everything else, to be in error is to be reborn.\n\n62\\. In computing, invariants are ephemeral.\n\n63\\. When we write programs that \"learn\", it turns out that we do and they\ndon't.\n\n64\\. Often it is the means that justify the ends: Goals advance technique and\ntechnique survives even when goal structures crumble.\n\n65\\. Make no mistake about it: Computers process numbers - not symbols. We\nmeasure our understanding (and control) by the extent to which we can\narithmetize an activity.\n\n66\\. Making something variable is easy. Controlling duration of constancy is\nthe trick.\n\n67\\. Think of all the psychic energy expended in seeking a fundamental\ndistinction between \"algorithm\" and \"program\".\n\n68\\. If we believe in data structures, we must believe in independent (hence\nsimultaneous) processing. For why else would we collect items within a\nstructure? Why do we tolerate languages that give us the one without the\nother?\n\n69\\. In a 5 year period we get one superb programming language. Only we can't\ncontrol when the 5 year period will be.\n\n70\\. Over the centuries the Indians developed sign language for communicating\nphenomena of interest. Programmers from different tribes (FORTRAN, LISP,\nALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a\nblackboard on their ponies.\n\n71\\. Documentation is like term insurance: It satisfies because almost no one\nwho subscribes to it depends on its benefits.\n\n72\\. An adequate bootstrap is a contradiction in terms.\n\n73\\. It is not a language's weakness but its strengths that control the\ngradient of its change: Alas, a language never escapes its embryonic sac.\n\n74\\. Is it possible that software is not like anything else, that it is meant\nto be discarded: that the whole point is to see it as a soap bubble?\n\n75\\. Because of its vitality, the computing field is always in desperate need\nof new cliches: Banality soothes our nerves.\n\n76\\. It is the user who should parameterize procedures, not their creators.\n\n77\\. The cybernetic exchange between man, computer and algorithm is like a\ngame of musical chairs: The frantic search for balance always leaves one of\nthe three standing ill at ease.\n\n78\\. If your computer speaks English, it was probably made in Japan.\n\n79\\. A year spent in artificial intelligence is enough to make one believe in\nGod.\n\n80\\. Prolonged contact with the computer turns mathematicians into clerks and\nvice versa.\n\n81\\. In computing, turning the obvious into the useful is a living definition\nof the word \"frustration\".\n\n82\\. We are on the verge: Today our program proved Fermat's next-to-last\ntheorem.\n\n83\\. What is the difference between a Turing machine and the modern computer?\nIt's the same as that between Hillary's ascent of Everest and the\nestablishment of a Hilton hotel on its peak.\n\n84\\. Motto for a research laboratory: What we work on today, others will first\nthink of tomorrow.\n\n85\\. Though the Chinese should adore APL, it's FORTRAN they put their money\non.\n\n86\\. We kid ourselves if we think that the ratio of procedure to data in an\nactive data-base system can be made arbitrarily small or even kept small.\n\n87\\. We have the mini and the micro computer. In what semantic niche would the\npico computer fall?\n\n88\\. It is not the computer's fault that Maxwell's equations are not adequate\nto design the electric motor.\n\n89\\. One does not learn computing by using a hand calculator, but one can\nforget arithmetic.\n\n90\\. Computation has made the tree flower.\n\n91\\. The computer reminds one of Lon Chaney -- it is the machine of a thousand\nfaces.\n\n92\\. The computer is the ultimate polluter: its feces are indistinguish- able\nfrom the food it produces.\n\n93\\. When someone says \"I want a programming language in which I need only say\nwhat I wish done,\" give him a lollipop.\n\n94\\. Interfaces keep things tidy, but don't accelerate growth: Functions do.\n\n95\\. Don't have good ideas if you aren't willing to be responsible for them.\n\n96\\. Computers don't introduce order anywhere as much as they expose\nopportunities.\n\n97\\. When a professor insists computer science is X but not Y, have compassion\nfor his graduate students.\n\n98\\. In computing, the mean time to failure keeps getting shorter.\n\n99\\. In man-machine symbiosis, it is man who must adjust: The machines can't.\n\n100\\. We will never run out of things to program as long as there is a single\nprogram around.\n\n101\\. Dealing with failure is easy: Work hard to improve. Success is also easy\nto handle: You've solved the wrong problem. Work hard to improve.\n\n102\\. One can't proceed from the informal to the formal by formal means.\n\n103\\. Purely applicative languages are poorly applicable.\n\n104\\. The proof of a system's value is its existence.\n\n105\\. You can't communicate complexity, only an awareness of it.\n\n106\\. It's difficult to extract sense from strings, but they're the only\ncommunication coin we can count on.\n\n107\\. The debate rages on: is PL/I Bachtrian or Dromedary?\n\n108\\. Whenever two programmers meet to criticize their programs, both are\nsilent.\n\n109\\. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.\n\n110\\. Editing is a rewording activity.\n\n111\\. Why did the Roman Empire collapse? What is Latin for office automation?\n\n112\\. Computer Science is embarrassed by the computer.\n\n113\\. The only constructive theory connecting neuroscience and psychology will\narise from the study of software.\n\n114\\. Within a computer natural language is unnatural.\n\n115\\. Most people find the concept of programming obvious, but the doing\nimpossible.\n\n116\\. You think you know when you can learn, are more sure when you can write,\neven more when you can teach, but certain when you can program.\n\n117\\. It goes against the grain of modern education to teach children to\nprogram. What fun is there in making plans, acquiring discipline in organizing\nthoughts, devoting attention to detail and learning to be self-critical?\n\n118\\. If you can imagine a society in which the computer- robot is the only\nmenial, you can imagine anything.\n\n119\\. Programming is an unnatural act.\n\n120\\. Adapting old programs to fit new machines usually means adapting new\nmachines to behave like old ones.\n\n###### From ACM's SIGPLAN publication, (September, 1982), Article \"Epigrams in\nProgramming\", by Alan J. Perlis of Yale University.\n\n", "frontpage": true}
