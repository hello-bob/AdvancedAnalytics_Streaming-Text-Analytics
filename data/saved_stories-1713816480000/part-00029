{"aid": "40112675", "title": "A Deeper Look Inside PostgreSQL Visibility Check Mechanism", "url": "https://www.highgo.ca/2024/04/19/a-deeper-look-inside-postgresql-visibility-check-mechanism/", "domain": "highgo.ca", "votes": 1, "user": "todsacerdoti", "posted_at": "2024-04-22 09:26:44", "comments": 0, "source_title": "A Deeper Look Inside PostgreSQL Visibility Check Mechanism - Highgo Software Inc.", "source_text": "A Deeper Look Inside PostgreSQL Visibility Check Mechanism - Highgo Software\nInc.\n\n  * Home\n  * Products\n\n    * HighGo PostgreSQL Server\n  * Yum\n  * Blog\n  * News\n  * About Us\n  * Careers\n  * Contact Us\n\n# A Deeper Look Inside PostgreSQL Visibility Check Mechanism\n\nEnterprise PostgreSQL Solutions\n\nApril 19, 2024 | By Cary Huang Leave a Comment\n\n# A Deeper Look Inside PostgreSQL Visibility Check Mechanism\n\n### What is Visibility?\n\nSimply put, the visibility refers to whether a row of data (Heap Tuple by\ndefault) should be displayed to the user in certain states, backend processes,\nor transactions.\n\nFor example,\n\n  * A user changes a data record from \u2018A\u2019 to \u2018B\u2019 via UPDATE\n  * PostgreSQL handles this by INSERTing a new record call \u2018B\u2019 while marking record \u2018A\u2019 as \u2018invisible\u2019\n  * Both records exist in the system, but \u2018B\u2019 is visible, while \u2018A\u2019 is not.\n  * A deleted or invisible record is also referred as a \u2018dead\u2019 tuple\n  * One of the responsibilities of VACUUM process is to clear these \u2018dead\u2019 tuples to free up space.\n\nMVCC (Multi-Version Concurrency Control) is a method in which each write\noperation creates a \u201cnew version\u201d of the data while retaining the \u201cold\nversion\u201d. This allows concurrent read and write operations without blocking\neach other. PostgreSQL uses a variant of MVCC, also called Snapshot Isolation\nto isolate concurrent transactions.\n\nSo, it is possible that a single piece of data could have multiple \u201cversions\u201d\nof it, and it is PostgreSQL\u2019s responsibility to determine which \u2018version\u2019\nshall be presented to the user based on multiple factors. This act is also\nknown as the \u201cvisibility check\u201d or \u201cvisibility control\u201d\n\nIn this blog, we will dive into PostgreSQL\u2019s visibility check mechanism to\nunderstand how it works.\n\n### Visibility Indicators\n\nTo my knowledge today, PostgreSQL determines a data\u2019s visibility based on the\nfollowing indicators:\n\n  * Transaction ID\n  * xmin\n  * xmax\n  * cid\n  * transaction snapshot\n  * CLOG (Commit Log)\n  * hintbit\n\nwhat exactly are these? Let\u2019s find out.\n\n#### transaction ID\n\nThis should be self-explanatory. All transactions in PostgreSQL are associated\nwith a ID number called transaction ID. This is mainly used to check if a data\nin question is inserted or deleted in the current transaction. We will explore\nmore on this in the later part of the blog.\n\n#### xmin, xmax, cid and hintbit\n\nThese indicators are categorized together because they are all stored in each\nheap data tuple\u2019s header and each data tuple would have different values,\nresulting in different visibility check results. The image below illustrates\nwhere they are stored on the tuple header:\n\nxmin:\n\n  * this is the transaction ID that inserts this heap data tuple\n\nxmax:\n\n  * this is the transaction ID that removes this heap data tuple\n  * if a tuple header has a valid, committed xmax value, this tuple is normally said to be \u2018dead\u2019 or \u2018invisible\u2019\n\ncid:\n\n  * this is the command ID that this data tuple is inserted within a transaction\n  * mostly used to determine visibility within the current transaction\n  * if a transaction contains SELECTs + other DML queries (INSERT, UPDATE and DELETE), then cid can be used to determine if a data tuple is inserted or removed before or after a SELECT.\n\nhintbit:\n\n  * this is a flag field that stores the query results from CLOG so PostgreSQL does not have to look up CLOG all the time. CLOG stands for Commit Log and is explained below\n  * if hintbit has HEAP_XMIN_COMMITTED set, this means that the transaction ID that inserts this tuple (a.k.a xmin) is committed\n  * if PostgreSQL can get this information directly from hintbit, then it can save some time looking up from the CLOG, resulting in some performance gain.\n  * possible hintbit flag values are:\n\n#### CLOG (Commit Log)\n\nCLOG is a data structure stored in shared memory and persisted on\n$PGDATA/pg_xact directory. The purpose of CLOG is to record the commit status\nof transactions. Status can be one of:\n\n  * COMMITTED\n  * IN_PROGRESS\n  * ABORTED\n  * SUB_COMMITTED\n\nFor example:\n\nIf a tuple\u2019s xmin is 103, and CLOG says 103 is ABORTED (image below), this\nmeans 103 is not visible because the transaction that inserts this data tuple\nis ABORTED. Then, for the sake of performance, PostgreSQL will mark hintbit as\nHEAP_XMIN_INVALID, so it would not look up from the CLOG next time we visit\nthe same data tuple again.\n\n#### Transaction Snapshot\n\nA transaction snapshot is another data structure that stores active\ntransaction information at a certain point in time. It is mostly used to\nisolate the data tuples in concurrent transactions. A data tuple could be\ninserted and committed by another transaction but the transaction snapshot I\nhave could be from the past. Then in this case, the data tuple is still\ninvisible to me according to my snapshot in the past.\n\nA transaction snapshot can be represented by several transaction numbers:\n\n    \n    \n    [xmin, xmax, xip_list]\n\n  * xmin: minimum Transaction ID still active \u2013 anything less than this = transaction committed or rolled back.\n  * xmax: maximum Transaction ID that has been committed or rolled back + 1 \u2013 greater than or equal to this value = the transaction has not been committed or rolled back.\n  * xip_list: list of ongoing transaction numbers \u2013 should be greater than xmin and less than xmax\n\nPlease note that the definitions of xmin and xmax in transaction snapshot are\ndifferent from those stored in the tuple header above.\n\nTransaction snapshot is better explained with examples.\n\nSay we have 3 concurrent backends A, B and C starting transactions 747, 748\nand 749, each inserting a data record \u2018A\u2019, \u2018B\u2019 and \u2018C\u2019.\n\n    \n    \n    postgres=# BEGIN; Postgres*# INSERT INTO mytable VALUES('A'); Postgres*# SELECT txid_current(); txid_current -------------- 747 (1 row)\n    \n    \n    postgres=# BEGIN; postgres=# INSERT INTO mytable VALUES('B'); postgres=# SELECT txid_current(); txid_current -------------- 748 (1 row)\n    \n    \n    postgres=# BEGIN; Postgres*# INSERT INTO mytable VALUES('C'); Postgres*# SELECT txid_current(); txid_current -------------- 749 (1 row)\n\nThen, we commit transaction 749 and obtain a current transaction snapshot via\n\u201cpg_current_snapshot()\u201d\n\n    \n    \n    postgres=# BEGIN; Postgres*# INSERT INTO mytable VALUES('A'); Postgres*# SELECT txid_current(); txid_current -------------- 747 (1 row)\n    \n    \n    postgres=# BEGIN; postgres=# INSERT INTO mytable VALUES('B'); postgres=# SELECT txid_current(); txid_current -------------- 748 (1 row)\n    \n    \n    postgres=# BEGIN; Postgres*# INSERT INTO mytable VALUES('C'); Postgres*# SELECT txid_current(); txid_current -------------- 749 (1 row) Postgres*# COMMIT; postgres=# select pg_current_snapshot(); pg_current_snapshot --------------------- 747:750:747,748 (1 row)\n\nIn the perspective of backend C, the transaction snapshot shows:\n\n  * 747 is the minimum transaction ID still active\n  * 750 is the maximum transaction ID that has been committed or aborted + 1 (749 + 1)\n  * 747 and 748 are still on-going transactions.\n\nWhat does it mean though?\n\n  * C is able to see the data tuples inserted by transaction IDs less than 750 except except for 747 and 748 because they are still in progress (not committed or rollbacked)\n  * C is not able to see data tuples inserted in the future ( larger than 750)\n  * C is able to see the data tuple inserted by itself in transaction 749 because it has just committed it.\n\nwe can also view the transaction snapshots of A and B while in transaction\n\n    \n    \n    postgres=# BEGIN; Postgres*# INSERT INTO mytable VALUES('A'); Postgres*# SELECT txid_current(); txid_current -------------- 747 (1 row) Postgres*# select pg_current_snapshot(); pg_current_snapshot --------------------- 747:750:748 (1 row)\n    \n    \n    postgres=# BEGIN; postgres=# INSERT INTO mytable VALUES('B'); postgres=# SELECT txid_current(); txid_current -------------- 748 (1 row) postgres=*# select pg_current_snapshot(); pg_current_snapshot --------------------- 747:750:747 (1 row)\n    \n    \n    postgres=# BEGIN; Postgres*# INSERT INTO mytable VALUES('C'); Postgres*# SELECT txid_current(); txid_current -------------- 749 (1 row) Postgres*# COMMIT; postgres=# select pg_current_snapshot(); pg_current_snapshot --------------------- 747:750:747,748 (1 row)\n\nAs you can see that A\u2019s transaction snapshot indicates that B (748) is in\nprogress, so it cannot see the data tuples inserted by B(748) yet. 747 is the\ncurrent transaction it is in and is not marked in snapshot anywhere, so it can\nsee the data inserted by itself within the current transaction. B\u2019s\ntransaction snapshot indicates the exact opposite.\n\n### Determine Visibility\n\nThe visibility indicators mentioned above are just in pieces; this means that\nwe cannot determine the true visibility of a data tuple purely based one one\nor a few of them. They all have to be considered to compute the correct\nvisibility.\n\nLet\u2019s summarize where things are to determine visibility:\n\n  * xmin, xmax, cid and hintbit are stored in the tuple header\n  * snapshot, transaction id are provided by the transaction manager when starting a transaction\n  * CLOG is available in shared memory\n\nThe image below is a simplified illustration of visibility checking:\n\nThis only gives you a brief overview of the entire visibility checking\nprocess. This process can be found in src/backend/heap/heapam_visibility.c in\nthe function heapTupleSatisfiesMVCC(). Of course, the actual logic is more\ncomplex than the illustration above.\n\nI have studied the entire process of PostgreSQL\u2019s visibility checking logic\nand come up with a more elaborated flow diagram below: A visibility check can\ngo as deep as this diagram shows, but thanks to the use of hintbit, majority\nof the visibility check is done pretty quickly by simply checking the hintbit\nand the snapshot with the xmin and xmax values of a data tuple.\n\n### Summary\n\nIf you are a PostgreSQL developer working on distributed database, shared\nstorage cluster or sharding, I believe this blog could provide you with an\ninsight of how PostgreSQL handles visibility check. Data atomicity and\nvisibility is always an issue when we start to interact with multiple database\nnodes. How to ensure data is consistent across the cluster is a common\nchallenge. Knowing the fundamentals of transaction and visibility could help\nus toggle those problems.\n\nCary Huang\n\nCary is a Senior Software Developer in HighGo Software Canada with 8 years of\nindustrial experience developing innovative software solutions in C/C++ in the\nfield of smart grid & metering prior to joining HighGo. He holds a bachelor\ndegree in Electrical Engineering from University of British Columnbia (UBC) in\nVancouver in 2012 and has extensive hands-on experience in technologies such\nas: Advanced Networking, Network & Data security, Smart Metering Innovations,\ndeployment management with Docker, Software Engineering Lifecycle,\nscalability, authentication, cryptography, PostgreSQL & non-relational\ndatabase, web services, firewalls, embedded systems, RTOS, ARM, PKI, Cisco\nequipment, functional and Architecture Design.\n\nTag: visibility check\n\n0\n\n0\n\n##### Recent Posts\n\n  * A Deeper Look Inside PostgreSQL Visibility Check Mechanism\n  * How to run TLS regression test in PostgreSQL\n  * Procedure To Test Multiple Client Certificate Feature\n  * Understand PostgreSQL\u2019s Planner \u2013 Simple Scan Paths vs Plans\n  * Setting up a debugging environment in PostgreSQL to better understand OpenSSL APIs\n\n##### Recent Comments\n\n##### Archives\n\n  * April 2024\n  * March 2024\n  * February 2024\n  * January 2024\n  * December 2023\n  * November 2023\n  * October 2023\n  * September 2023\n  * August 2023\n  * July 2023\n  * June 2023\n  * May 2023\n  * April 2023\n  * March 2023\n  * February 2023\n  * January 2023\n  * December 2022\n  * November 2022\n  * October 2022\n  * September 2022\n  * August 2022\n  * July 2022\n  * June 2022\n  * May 2022\n  * April 2022\n  * March 2022\n  * February 2022\n  * January 2022\n  * December 2021\n  * November 2021\n  * October 2021\n  * September 2021\n  * August 2021\n  * July 2021\n  * June 2021\n  * May 2021\n  * April 2021\n  * March 2021\n  * February 2021\n  * January 2021\n  * December 2020\n  * November 2020\n  * October 2020\n  * September 2020\n  * August 2020\n  * July 2020\n  * June 2020\n  * May 2020\n  * April 2020\n  * March 2020\n  * February 2020\n  * January 2020\n  * November 2019\n  * October 2019\n  * September 2019\n  * August 2019\n  * July 2019\n  * June 2019\n\n##### Categories\n\n  * AES\n  * HA\n  * highavailability\n  * JIT\n  * KMS\n  * News\n  * Parallel\n  * performance\n  * pgpool\n  * postgresql\n  * Sharding\n  * SSL\n  * TDE\n  * Uncategorized\n  * Vacuum\n\n##### Tags\n\nattach compute database datatypes decryption encryption global unique index ha\nhighavailability HTTP load balancer load balancing logical replication neon\nnetworking nginx orphaned prepared transactions pgpool Pgpool-II pitr planner\npluggable storage api point in time recovery port control protocol postgres\npostgresconf.cn postgresql prepared transactions proxy recovery replication\nsecurity server sharding smgr sql ssl storage streaming replication table\naccess method TCP TLS UDP visibility check wal2mongo\n\nCanada Office\n\nRoom 510 - 9850 King George Blvd, Surrey, BC V3T 0P9\n\nEmail\n\ncontact@highgo.ca\n\nContact Number\n\n+1 (604) 781-6749\n\n\u00a9 2024, HighGo Software Inc.\n\n  * Home\n  * Products\n\n    * HighGo PostgreSQL Server\n  * Yum\n  * Blog\n  * News\n  * About Us\n  * Careers\n  * Contact Us\n\n", "frontpage": false}
