{"aid": "40113450", "title": "The Same User Interface Mistakes over and over (2015)", "url": "https://prog21.dadgum.com/214.html", "domain": "dadgum.com", "votes": 1, "user": "keepamovin", "posted_at": "2024-04-22 11:52:53", "comments": 0, "source_title": "The Same User Interface Mistakes Over and Over", "source_text": "The Same User Interface Mistakes Over and Over\n\nprogramming in the twenty-first century\n\nIt's not about technology for its own sake. It's about being able to implement\nyour ideas.\n\n# The Same User Interface Mistakes Over and Over\n\nIt has been 42 years since the not-very-wide release of the Xerox Alto and\nalmost 32 since the mainstream Macintosh. You might expect we've moved beyond\nthe era of egregious newbie mistakes when building graphical UIs, but clearly\nwe have not. Drop-down lists containing hundreds of elements are not rare\nsights. Neither are modal preference dialogs, meaningless alerts where the\ninformation is not actionable, checkboxes that allow mutually exclusive\noptions to be selected at the same time, and icons that don't clearly\nrepresent anything. I could go on, but we've all experienced this firsthand.\n\nWait, I need to call out one of the biggest offenses: applications stealing\nthe user's focus--jumping into the foreground--so that clicks intended for the\npreviously front-most app are now applied to the other, possibly with drastic\nresults.\n\nThat there are endless examples of bad UIs to cite and laugh at and ignore is\nnot news. The real question is why, after all this time, do developers still\nmake these mistakes? There are plenty of UI experts teaching simplicity and\nrailing against poor design. Human-computer interaction and UX are recognized\nfields. So what happened?\n\nWe've gotten used to it. Look at the preferences panel in most applications,\nand there are guaranteed to be settings that you can't preview, but instead\nhave to select, apply, close the window, and then can't be undone if you don't\nlike them. You have to manually re-establish the previous settings. This is so\ncommon that it wouldn't even be mentioned in a review.\n\n(At one time the concern was raised that the ubiquitous \"About...\" menu option\nwas mislabeled, because it didn't give information about what a program was or\nhow it worked, but instead displayed a version number and copyright\ninformation. It's a valid point, but it doesn't get a second thought now. We\naccept the GUI definition of \"About.\")\n\nThere's no standard resource. How do you know that certain uses of checkboxes\nor radio buttons are bad? From experience using apps, mostly, and some\ndesigners may never notice. If you're starting out building an interface,\nthere's no must-have, coffee-stained reference--or a web equivalent--that\nshould be sitting on your desk. Apple and others have their own guidelines,\nbut these are huge and full of platform-specific details; the fundamentals are\neasy to overlook.\n\nThere aren't always perfect alternatives. There's so much wrong with the\nfocus-stealing, jump-to-the-front application, but what's the solution?\nStandard practice is a notification system which flashes or otherwise vies for\nattention, then you choose when you want to interact with the beckoning\nprogram. What this notification system is depends on the platform. There isn't\na definitive approach for getting the user's attention. It's also not clear\nthat the model of background apps requesting the user's attention works. How\nmany iPhones have you seen with a red circle containing \"23\" on the home\nscreen, indicating that 23 apps need updating...and it's been there for\nmonths?\n\nImplementing non-trivial GUIs is still messy. Windows, OS X, and iOS are more\nor less the same when it comes to building interfaces. Use a tool to lay out a\ncontrol-filled window, setting properties and defaults. Write classes which\nare hooked to events fired by controls. There's more architecture here than\nthere should be, with half of the design in code, half in a tool, and trying\nto force-fit everything into an OOP model. It's also easy to build interfaces\nthat are too static. REBOL and Tk showed how much nicer this could be, but\nthey never became significant. It's better in HTML, where layout and code are\nblurred, but this doesn't help native apps.\n\n(If you liked this, then you might enjoy If You're Not Gonna Use It, Why Are\nYou Building It?)\n\npermalink December 30, 2015\n\n# previously\n\n  * Alternate Retrocomputing Histories\n  * What Can You Put in a Refrigerator?\n  * The Right Thing?\n  * Computer Science Courses that Don't Exist, But Should\n  * If You Haven't Done It Before, All Bets Are Off\n\n# archives\n\ntwitter / mail\n\nI'm James Hague, a recovering programmer who has been designing video games\nsince the 1980s. Programming Without Being Obsessed With Programming and\nOrganizational Skills Beat Algorithmic Wizardry are good starting points. For\nthe older stuff, try the 2012 Retrospective.\n\nWhere are the comments?\n\n", "frontpage": false}
