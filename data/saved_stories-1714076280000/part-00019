{"aid": "40157778", "title": "Making a LSP Server in Go", "url": "https://en.ewen.works/blog/making-an-lsp-server-in-go", "domain": "ewen.works", "votes": 1, "user": "ewen-lbh", "posted_at": "2024-04-25 14:06:40", "comments": 0, "source_title": "ewen.works", "source_text": "ewen.works\n\n2024-04-25\n\n# Making an LSP server in Go\n\nResources and documentation about implementing an LSP server in Go are\nsurprisingly sparse, so I decided to write my (first!) blog entry about it,\nafter having to go through the source code of some random dependent on\ngo.lsp.dev/protocol to figure out how to implement a simple LSP server.\n\n## The pieces\n\nWe\u2019ll be using the go.lsp.dev collection of modules to implement our LSP\nserver. These modules include:\n\n  * go.lsp.dev/protocol: A bunch of structs that represent the LSP protocol.\n  * go.lsp.dev/jsonrpc2: A JSON-RPC 2.0 implementation. The LSP protocol uses JSON-RPC 2.0 for communication.\n\n## The boilerplate\n\nYou\u2019ll most likely want to split up your code into at least two files:\n\n  * server.go: Logic (and honestly, mostly boilerplate) for starting the LSP server\n  * cmd/main.go: The entrypoint for launching your server with a binary. In the simplest of cases, you might not even need this. If you don\u2019t, put every file in the main package, and just call StartServer (see just below) from a main function in server.go.\n  * handlers.go: The actual LSP handlers, you\u2019ll define all the functions that you want to implement there! things like Definition to implement the \u201cGo to definition\u201d feature, etc.\n\n### server.go\n\nMostly boilerplate:\n\n    \n    \n    package yourlsp import ( \"context\" \"io\" \"os\" \"path/filepath\" \"go.lsp.dev/jsonrpc2\" \"go.lsp.dev/protocol\" \"go.uber.org/multierr\" \"go.uber.org/zap\" ) // StartServer starts the language server. // It reads from stdin and writes to stdout. func StartServer(logger *zap.Logger) { conn := jsonrpc2.NewConn(jsonrpc2.NewStream(&readWriteCloser{ reader: os.Stdin, writer: os.Stdout, })) handler, ctx, err := NewHandler( context.Background(), protocol.ServerDispatcher(conn, logger), logger, ) if err != nil { logger.Sugar().Fatalf(\"while initializing handler: %w\", err) } conn.Go(ctx, protocol.ServerHandler( handler, jsonrpc2.MethodNotFoundHandler, )) <-conn.Done() } type readWriteCloser struct { reader io.ReadCloser writer io.WriteCloser } func (r *readWriteCloser) Read(b []byte) (int, error) { n, err := r.reader.Read(b) return n, err } func (r *readWriteCloser) Write(b []byte) (int, error) { return r.writer.Write(b) } func (r *readWriteCloser) Close() error { return multierr.Append(r.reader.Close(), r.writer.Close()) }\n\n### cmd/main.go\n\n    \n    \n    package main import ( \"go.uber.org/zap\" \"yourlsp\" ) func main() { logger, _ := zap.NewDevelopmentConfig().Build() // Start the server yourlsp.StartServer(logger) }\n\n### handlers.go\n\nThat\u2019s were we get to the interesting stuff.\n\nYou first define your own Handler struct that just embeds the protocol.Server\nstruct, so that you can implement all the methods.\n\n    \n    \n    package yourlsp import ( \"context\" \"go.lsp.dev/protocol\" \"go.lsp.dev/uri\" \"go.uber.org/zap\" ) var log *zap.Logger type Handler struct { protocol.Server } func NewHandler(ctx context.Context, server protocol.Server, logger *zap.Logger) (Handler, context.Context, error) { log = logger // Do initialization logic here, including // stuff like setting state variables // by returning a new context with // context.WithValue(context, ...) // instead of just context return Handler{Server: server}, context, nil }\n\n## Implementing stuff\n\nActually implementing functionnality for your LSP consists in defining a\nmethod on your handler struct that has a particular name, as defined in\ntheprotocol.Server interface\n\n### Telling the clients what feature we support: the Initialize method\n\nAll LSP servers must implement the Initialize method, that returns information\non the LSP server, and most importantly, the features it supports.\n\nThe signature of the Initialize method is:\n\n    \n    \n    Initialize(ctx context.Context, params *InitializeParams) (result *InitializeResult, err error)\n\nAutocomplete and hover (features of Go\u2019s LSP server, how meta!) will help you\na lot when implementing this:\n\nYou\u2019ll notice that most of the capabilities receive an interface{}, that\u2019s not\nvery helpful.\n\nThis usually means that you can either pass true to say that you support the\nfeature fully, or a struct of options for more intricate support information.\n\nCheck with the spec to be sure.\n\n#### Example\n\nHere\u2019s an example method implementation that signals support for the Go to\nDefinition feature:\n\n    \n    \n    func (h Handler) Initialize(ctx context.Context, params *protocol.InitializeParams) (*protocol.InitializeResult, error) { return &protocol.InitializeResult{ Capabilities: protocol.ServerCapabilities{ DefinitionProvider: true, // <-- right there }, ServerInfo: &protocol.ServerInfo{ Name: \"yourls\", Version: \"0.1.0\", }, }, nil }\n\n### Implementing a feature: the Definition example\n\nAs with Initialize, hovering over the types of the parameters will help you\ngreatly.\n\n    \n    \n    // IMPORTANT: You _can't_ take a pointer to your handler struct as the receiver, // your handler will no longer implement protocol.Server if you do that. func (h Handler) Definition(ctx context.Context, params *protocol.DefinitionParams) ([]protocol.Location, error) { // ... do your processing ... return []protocol.Location{ { URI: uri.File(...), Range: protocol.Range{ Start: protocol.Position{ Line: 0, Character: 0, }, End: protocol.Position{ Line: 0, Character: 0, }, }, }, }, nil }\n\n## Using in IDEs & editors\n\n### Neovim\n\nYou can put the following in your init.lua:\n\n    \n    \n    vim.api.nvim_create_autocmd({'BufEnter', 'BufWinEnter'}, { pattern = { \"glob pattern of the files you want your LSP to be used on\" }, callback = function(event) vim.lsp.start { name = \"My language\", cmd = {\"mylsp\"}, } end })\n\n### Visual Studio Code\n\nVSCode requires writing an entire extension to use an LSP server...\n\nIf you want something quick \u2019n\u2019 dirty, you can use some generic LSP client\nextension (for example, llllvvuu\u2019s Generic LSP Client).\n\nBut to do a proper extension that you can distribute to your user\u2019s, you\u2019ll\nwant to follow the vscode docs on LSP extension development.\n\nThe guide assumes that you\u2019ll develop the LSP server in NodeJS too, but you\ncan easily rm -rf the hell out of the server/ directory from their template\nrepository.\n\nI\u2019m using the following architecture for ortfo\u2019s LSP server:\n\n    \n    \n    handler.go server.go cmd/ main.go vscode/ package.json # contains values from both client's package.json and the root package.json src/ # from client/ tsconfig.json ...\n\n(curious? see the repository at ortfo/languageserver)\n\n## Related works\n\n#### Hyprlang LSP\n\nHyprlang LSP WIP\n\n  * language\n  * programming\n\nortfo WIP\n\n  * automation\n  * web\n  * app\n  * program\n  * command-line\n  * site\n  * gui\n  * library\n\nwhoami?\n\nI'm interested in almost anything that is both creative and digital. Learn\nmore about me\n\n## Stats from stats.ewen.works\n\n0 views\n\newen.works/to/\n\nspotify\n\n    my music\ntwitter\n\n    random thoughts\ngithub\n\n    open-source code\nyoutube\n\n    visual+music\ndeezer\n\n    my music\nfiverr\n\n    i can work for you\nmail\n\n    contact\ninstagram\n\n    personal account\nlinkedin\n\n    my carreer\n\nProudly powered by ortfo, my portfolio database management system and templ\n\nSource code\n\n", "frontpage": false}
