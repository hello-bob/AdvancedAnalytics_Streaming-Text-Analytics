{"aid": "40261526", "title": "Unveiling secrets of the ESP32 part 2: reverse engineering RX", "url": "https://zeus.ugent.be/blog/23-24/esp32-reverse-engineering-continued/", "domain": "zeus.ugent.be", "votes": 6, "user": "timschmidt", "posted_at": "2024-05-05 00:54:14", "comments": 0, "source_title": "Unveiling secrets of the ESP32 part 2: reverse engineering RX", "source_text": "Zeus WPI | Unveiling secrets of the ESP32 part 2: reverse engineering RX\n\nAbout Contact Blog Events Projecten Sponsors Cammie Mirror\n\n# Unveiling secrets of the ESP32 part 2: reverse engineering RX\n\n## door Jasper Devreker\n\nGeschreven op 2023-12-07 Leestijd: 12 minuten\n\nThis is the second article in a series about reverse engineering the ESP32 Wi-\nFi networking stack, with the goal of building our own open-source MAC layer.\nIn the previous article in this series, we built static and dynamic analysis\ntools for reverse engineering. We also started reverse engineering the\ntransmit path of sending packets, and concluded with a rough roadmap and a\ncall for contributors.\n\nIn this part, we\u2019ll continue reverse engineering, starting with the \u2018receiving\npackets\u2019 functionality: last time, we succesfully transmitted packets. The\ngoal of this part is to have both transmitting and receiving working. To prove\nthat our setup is working, we\u2019ll try to connect to an access point and send\nsome UDP packets to a computer also connected to the network.\n\n# Receive functionality\n\nAs a short recap, the transmit functionality worked by:\n\n  1. Putting the packet you want to transmit in memory\n  2. Create a DMA (direct memory access) struct. This struct contains:\n\n     * the address of the packet you want to transmit\n     * the length and size of the packet (I haven\u2019t entirely figured out the difference, but one always seems to be 32 bigger than the other one)\n     * the address of the next packet (we set this to NULL to transmit a single packet)\n  3. Write some other memory peripherals to configure the settings for the packet you\u2019re about to transmit\n  4. Write the address of the DMA struct to a memory mapped IO address\n  5. The hardware then automatically reads the DMA struct, and transmits the packet\n  6. After this is done, interrupt 0 will fire, telling us how succesful the transmission was\n\nThe receive functionality seems to use the same DMA struct, but in a slightly\ndifferent way:\n\n  1. Set up a linked list of DMA structs, where the next field of the struct points to the next DMA struct in the linked list. The final DMA struct points to NULL. Every address field points to a buffer, and the length and size fields are set to the size of the buffer.\n  2. Write the address of the first DMA struct to a memory mapped IO address (WIFI_BASE_RX_DSCR). Now the setup is done, and we can receive packets.\n  3. When a packet is received by the hardware, it will put the packet into the address of the first available DMA struct. The length field will indicate the length of the packet; the size field will not be updated. The has_data field will be set to 1.\n  4. Interrupt 0 will fire to notify the processor that a packet was received. This interrupt will notify a non-interrupt task that a packet was received. We should avoid to do much processing in the interrupt, since we want to return as quickly as possible.\n  5. Outside of the interrupt, we can then look at the linked list of DMA structs to see which ones have their has_data bit set. The address buffers can then be passed up further in the Wi-Fi MAC stack. We want to avoid running out of DMA structs to receive packets into, so we have to extend the linked list. We could do it by just allocating a new DMA struct and space for a packet and putting it at the end of the DMA linked list, but this constant allocating and deallocating would be rather inefficient. Instead, we recycle existing DMA structs by resetting their fields and inserting them at the end of the linked list.\n\n# Practicalities\n\nNow we have a basic way to receive packets, but when we implemented this, no\npackets were received: this was likely because of the hardware MAC address\nfilters: if you are a Wi-Fi device, there are a lot of packets flying in the\nair that you\u2019re not interested in. For example, if you\u2019re a station (for\nexample, a phone) and are connected to an access point, you don\u2019t really care\nabout the packets other access points are sending to their stations. To avoid\nthe overhead in also having to process \u2018uninteresting\u2019 packets, most Wi-Fi\ndevices have a hardware filter where you can set the MAC addresses of packets\nyou want to receive. The hardware will then filter out the packets with\ndifferent MAC addresses, and will only forward packets with matching MAC\naddresses to the software.\n\nThe ESP32 also seems to have this implemented, but luckily for us, the ESP32\nalso implements a sort of monitor mode (also known as promiscuous mode), where\nevery packet that is receieved by the hardware is passed to the software. The\nESP32 SDK has a call esp_wifi_set_promiscuous(bool) where you can enable or\ndisable this feature. When we enabled this, we did start to receive packets.\nWe\u2019ll eventually reverse engineer and implement hardware MAC address filtering\nas well, but for now, we\u2019ll just filter in software.\n\n# Connecting to an access point\n\nNow that we have send and receive working, you\u2019d think that we\u2019d be able to\nconnect to an access point and start sending packets, right? Well, not\nentirely: since this is such a big project, we only implemented the bare\nminimum to proceed in every phase. This is the same approach Ladybird takes to\nbuild a novel browser:\n\n> If you tried to build a browser one spec at a time, or even one feature at a\n> time, you\u2019d most likely run out of steam and lose interest altogether. So\n> instead of that, we tend to focus on building \u201cvertical slices\u201d of\n> functionality. This means setting practical, cross-cutting goals, such as\n> \u201clet\u2019s get twitter.com/awesomekling to load\u201d, \u201clet\u2019s get login working on\n> discord.com\u201d, and other similar objectives.\n\nThis approach is very motivating, but sometimes bites you in the ass when you\nhave to figure out why something is not working.\n\n## Step 1: using Scapy\n\nBefore we start with the undertaking of connecting the ESP32 to an access\npoint, we\u2019ll first start by implementing connecting a regular USB Wi-Fi dongle\nto an access point by constructing and sending the packets ourselves to make\nsure we understand everything that\u2019s needed; and so we\u2019ll have a known-working\nreference implementation. We found this blog post about using Scapy, a Python\npacket manipulator library, for connecting to an open access point. We need 4\npackets to set up the connection:\n\n  1. Authentication, from client to AP\n  2. Authentication, from AP to client\n  3. Association request, from client to AP\n  4. Association response, from AP to client\n\nAfter that, if everything has gone well, we can send data frames from the\nclient to the access point and they\u2019ll get accepted. We extended the blog post\ncode a bit to also send data frames at the end of the connection setup, and\nverified that everything was working. For the data frames, we used UDP\npackets, because we can just construct the packet once, and then keep sending\nit; UDP is stateless, unlike TCP.\n\n## Step 2: using the ESP32\n\nWe implemented this on the ESP32, by copying the packets from Scapy and\nhardcoding the packet contents in the C source code. To make sure we could\ndiscern the ESP32 from the scapy implementation, we replace the MAC address of\nthe adapter we use for testing with an arbitrary MAC address\n(01:23:45:67:89:ab). When we then sent the packets, we saw that we received an\nACK frame in response to our authentication, but we didn\u2019t receive an\nauthentication answer back from the AP. Even stranger, the ACK was towards a\ndifferent MAC address: 00:23:45:67:89:ab.\n\nApparently, MAC addresses aren\u2019t just 6 arbitrary bytes with the first 3 bytes\nbeing vendor specific: the last bit of the first byte indicates if the packet\nis unicast or multicast. By using the 01:... MAC address, we had sent\nmulticast packets instead of unicast packets.\n\nAfter fixing this by using a different MAC address, we started to receive\nframes back from the access point. Because we didn\u2019t implement sending ACKs\nback, we received every frame from the access point 4 times: since the access\npoint didn\u2019t receive any ACKs back, it would assume the packet was not\nreceived correctly. At that point, that wasn\u2019t a problem: the AP would happily\nproceed with association request and response.\n\nHowever, when we started to send data packets, we\u2019d immediately started to\nreceive disassociation frames from the AP as a reply to our data packets. The\nonly difference between the (working) Scapy implementation and the current\nESP32 implementation, was not sending ACKs back; so I guess implementing that\nis necessary after all.\n\nSending ACK frames back in software is not as easy as it seems though: the ACK\nframe needs to be sent exactly one SIFS (Short Interframe Space) time period\nafter the last symbol of the received frame. For 802.11b, such a SIFS is only\n10 microseconds; the round-trip-time through the hardware and software is\nalready more than 10 us, so we can\u2019t implement this in software. The\nproprietary network stack does send ACK frames back, so this must be\nimplemented somehow. And indeed, sending ACKs is implemented in hardware: by\nwriting to a memory-mapped IO address, you can configure a MAC address for\nwhich the hardware will automatically send back an ACK.\n\nAfter also implementing this, we received our first packets on the computer\nthat had netcat listening for UDP packets \ud83c\udf89\n\nFirst succesfully received data packets sent by ESP32\n\nSince we now implement the interrupt ourselves, we can send and receive\nframes, without any proprietary code running (proprietary code is still used\nto initialize the hardware in the begin, but is not needed anymore after\nthat).\n\nThe current way of hardcoding the contents of packets was appropriate for the\nproof-of-concept showing that we can connect to an AP and send packets, but is\nnot useable for our eventual goal. We\u2019re searching for an open source\nimplementation that handles the higher level functionality of the 802.11 MAC\nlayer (constructing and parsing packets, knowing what packets to send when,\n...). For the higher layers, we can use the existing lwIP TCP/IP-stack on the\nESP32.\n\nAll code is available on the esp32-open-mac GitHub organisation.\n\n# Roadmap\n\n  * \u2611 Send packets\n  * \u2611 Receive packets\n  * \u2611 Send ACK (acknowledgment) packets back if we receive a packet that is destined for us\n  * \u2611 Implement hardware filtering based on MAC address so we don\u2019t receive as much packets\n  * \u2610 Find or build an open source 802.11 MAC implementation to construct the packets we want to send. The Linux kernel has mac80211, but including the full Linux kernel does not seem to be feasible. This is not ESP32-specific; we\u2019d ideally find an implemenation where you can pass your own TX and RX functions, and they do the rest.\n  * \u2610 Implement changing the wifi channel, rate, transmit power, ...\n  * \u2610 Implement the hardware initialization (now done by esp_phy_enable()). This will be a hard undertaking, since all calibration routines will need to be implemented, but also has a high payoff: we\u2019ll then have a completely blob-free firmware for the ESP32.\n  * \u2610 Write SVD documentation for all reverse engineered registers. An SVD file is an XML file that describes the hardware features of a microcontroller, this makes it possible to automatically generate an API from the hardware description. Espressif already has an SVD file containing the documented hardware registers; we can document the undocumented registers and (automatically) merge them in.\n\nThe two hardest (but most important) tasks are implementing hardware\ninitialization, and connecting our sending and receiving primitives to an open\nsource 802.11 MAC stack.\n\n## Bonus: Charlotte breaking everything\n\nCharlotte playing music completely broke the setup: the music setup at our\nhackerspace works via RTP (Realtime Transport Protocol). Under the hood, RTP\nsends UDP packets containing the audio data to a multicast address; so these\npackets were also transmitted over the Wi-Fi. Because this was a lot of\npackets per second, the receive buffer was always full, and very few other\npackets could be received/ACKed. This made it clear that hardware filtering\nwould need to be implemented sooner than later; reverse engineering turned out\nto be not as much work as expected.\n\nThe hardware filtering seems to have two \u2018slots\u2019, for every slot you can\nfilter on a destination MAC address and on a BSSID (not sure if you can do\nboth in each slot or you have to choose). By default, the hardware will not\nlet any packets through. The hardware will only send an ACK frame back if the\npacket was let through via one of the filters and was copied into an RX DMA\nbuffer: packets that were copied into an RX DMA buffer because of promiscuous\nmode will not result in an ACK frame getting sent.\n\n## Questions? Want to collaborate?\n\nThis is a sizeable project that could definitely use multiple contributors;\nI\u2019d really like to collaborate with other people to create a fully functional,\nopen-source Wi-Fi stack for the ESP32. If this sounds like something you\u2019d\nlike to work on, contact me via zeusblog@notdevreker.be, maybe we can have a\nweekly hacking session?\n\nAs far as I know, this is the first undertaking to build an open source 802.11\nMAC for an affordable microcontroller. If you want to financially support this\nproject, you can wire money via https://zeus.ugent.be/contact/#payment-info,\nplease put \u201cESP32\u201d in the transaction description, so our treasurer knows what\nthe money is for. Please do not donate if you\u2019re a student or if you\u2019re not\nfinancially independent. If you\u2019re a company and would like to donate hardware\n(for example, a faraday cage or measuring equipment that might be useful),\nplease contact me.\n\nThis project was funded through the NGI0 Core Fund, a fund established by\nNLnet with financial support from the European Commission\u2019s Next Generation\nInternet programme, under the aegis of DG Communications Networks, Content and\nTechnology under grant agreement No 101092990.\n\nFeel free to send me an email in case you have questions, you think something\nin this blog post could be worded better or you spotted a mistake.\n\nMade with by Zeus WPI\n\nView on GitHub | Privacy | Responsible Disclosure Policy\n\nPage last compiled on: 2024/05/04 08:09\n\n", "frontpage": true}
