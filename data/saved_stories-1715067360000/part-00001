{"aid": "40281351", "title": "The guide to kubectl I never had", "url": "https://glasskube.dev/guides/kubectl/", "domain": "glasskube.dev", "votes": 1, "user": "thunderbong", "posted_at": "2024-05-07 01:34:31", "comments": 0, "source_title": "The guide to kubectl I never had.", "source_text": "The guide to kubectl I never had. | Glasskube.dev\n\nSkip to main content\n\n\ud83c\udf89\ufe0f glasskube/glasskube Beta is launching on Producthunt \ud83e\udd73\ufe0f\n\n# The guide to kubectl I never had.\n\nWhat kind of engineer are you? \ud83e\udd14 Can somebody guess by just looking at you?\nMore than likely not.\n\nWould that somebody be able to tell by looking at your keyboard instead? Might\nbe a bit easier now. \u2328\ufe0f\n\nYou know you are dealing with a Kubernetes engineer when the \u201ck\u201c key on their\nkeyboard has seen better days. At the Glasskube office, you will find spare\n\u201ck\u201c keys all over the place, just in case \ud83d\ude04\n\nI\u2019m joking of course. I\u2019m not really sure about what a faded keyboard says\nabout its owner. What I do know for sure is how important kubectl is to\nanybody who wants to be a proficient Kubernetes administrator.\n\nkubectl is the CLI tool used to communicate to the Kubernetes API it can seem\nsimple at first but can quickly get complicated. So in this blog post, I aim\nto write the guide I wish I had when I started. Focusing first on command\nsyntax and useful commands, before moving on to the vibrant ecosystem of\nplugins and tools built to expand the functionalities of kubectl and\nKubernetes. Sharing tips and tricks along the way as well as a helpful\nkubecltl cheatsheet at the end. \ud83d\udccb\n\nLet\u2019s get to it. \u2638\ufe0f\n\n## Disclaimer \ud83d\uded1\n\n> This isn\u2019t an article about Kubernetes. K8s is an incredibly vast\n> technology, encompassing numerous concepts, such as various types of\n> Kubernetes objects and their interactions. For this discussion, I'll assume\n> you're familiar with these concepts. Instead, I'll focus specifically on\n> kubectl, its usage, and the tools built around it.\n\n## Just before we begin\n\nIf you are a fan of supporting Open Source projects working to make Kubernetes\npackage management better for everyone then please consider supporting\nGlasskube, by giving us a Star on GitHub \ud83d\ude4f\n\n## Installation\n\nTo install kubectl, you have a few different options depending on your\noperating system. Here's how to install it on some common platforms:\n\n### Linux (Ubuntu/Debian)\n\n    \n    \n    sudo apt-get update && sudo apt-get install -y kubectl\n\n### MacOS using Homebrew\n\n    \n    \n    brew install kubectl\n\n### Windows using Chocolatey\n\n    \n    \n    choco install kubernetes-cli\n\nAfter installation, you can verify if kubectl has been installed correctly by\nrunning:\n\n    \n    \n    kubectl version --client\n\n## kubectl commands:\n\nkubectl is a Command Line Interface (CLI) tool used to communicate with the\nKubernetes API. There are many commands, too many to remember.\n\nDon\u2019t worry though it\u2019s not as daunting as some might want you to think.\n\nWe will explore ways to quickly access command references, k8s-object-specific\ncommands, helpful aliases, and command completion. But first, how are command\nstrings built?\n\n## The syntax\n\nEnglish and Chinese are subject-verb-object (SVO) languages.\n\nHindi and Korean are subject-object-verb (SOV) languages.\n\nIf kubectl were a language, it would be a kubectl + verb + object/[name\noptional] + flag (kvof) language \ud83d\ude04\n\nAlso similar to languages, the best way to learn and absorb grammar is by\nusing it in context and not memorizing long verb and object lists.\n\n> i\ufe0f If you are stuck and want to quickly reference the existing Kubernetes\n> objects in any Kubernetes version run kubectl api-resources.\n\nCommands are built by choosing that action [verb] you want to apply to the\ndesired Kubernetes resource [object] usually followed by the name of the\nresource additionally you have a large array of filters [flags] that can be\napplied to the command which will determine the final scope and output.\n\nLet\u2019s look at a simple example of command building using the commonly used get\nverb to retrieve all resources in the glasskube-system namespace, and the\noutput is in yaml format:\n\n    \n    \n    kubectl get all --namespace glasskube-system -o yaml\n\n> i\ufe0f If you come across a Kubernetes resource that you haven\u2019t heard of before\n> or need a refresher use kubectl explain [resource-name] to get an in-\n> terminal description and usage instructions.\n\n## Working imperatively\n\nWhen working in Kubernetes environments your tasks are many, anything from\ndeploying new apps, troubleshooting faulty resources, inspecting usage, and\nmuch more. Later on, we will explore how useful declarative ways of working\nare more appropriate for defining and deploying workloads, but for everything\nelse we have our arsenal of useful imperative Kubernetes commands at the\nready.\n\nSimple commands to get us started are:\n\n    \n    \n    # Create a new deployment named \"nginx-deployment\" with the nginx image kubectl run nginx-deployment --image=nginx\n    \n    # Delete a pod named \"nginx-deployment\" in the default namespace kubectl delete pod nginx-deployment\n\nTo take imperative commands to the next step know that you can modify\nresources by using the TUI editor: By running kubectl edit -n [namespace]\n[resource-name] a text editor like the one below will open. Make you edits and\nclose the editor just like in vim by running ESC + :q!.\n\n    \n    \n    # Please edit the object below. Lines beginning with a '#' will be ignored, # and an empty file will abort the edit. If an error occurs while saving this file will be # reopened with the relevant failures. # apiVersion: v1 kind: Pod metadata: annotations: kubectl.kubernetes.io/default-container: manager creationTimestamp: \"2024-04-22T17:07:39Z\" generateName: glasskube-controller-manager-556ff6fccf- labels: control-plane: controller-manager pod-template-hash: 556ff6fccf name: glasskube-controller-manager-556ff6fccf-4qlxz namespace: glasskube-system ownerReferences: - apiVersion: apps/v1 blockOwnerDeletion: true controller: true kind: ReplicaSet name: glasskube-controller-manager-556ff6fccf uid: 430e90e9-32f3-45f6-92dc-4bae26ae1654 \"/var/folders/2q/wjmbwg1n5vn8v7vlw17nsz0h0000gn/T/kubectl-edit-1306753911.yaml\" 209L, 5898B\n\nMost commands are applicable to all sorts of Kubernetes objects. Insofar as it\nis useful further down we will touch on specific commands that are useful for\ncertain Kubernetes resources. Before that though, it\u2019s worth learning about\nsome useful flags that can be applied to many different objects.\n\n## Useful flags:\n\n\\--env:\n\nThe --env flag allows you to specify environment variables for the container\nbeing created.\n\n    \n    \n    kubectl run nginx-deployment --image=nginx --env=\"ENV_VARIABLE=value\"\n\n\\--template: This flag allows you to specify a Go template for the output\nformat of your kubectl command. It's handy when you want to customize the\noutput structure, filtering, or presentation.\n\n    \n    \n    kubectl get pods --template='{{range .items}}{{.metadata.name}}{{\"\\n\"}}{{end}}'\n\n\\--field-selector: With this flag, you can filter resources based on specific\nfields. For instance, you can filter pods based on their status or labels.\n\n    \n    \n    kubectl get pods --field-selector=status.phase=Running\n\n\\--field-selector type=[Normal/Warning]: This is a specific use of the\n--field-selector flag, where you filter events based on their type, either\nNormal or Warning.\n\n**kubectl events -n [resource-namespace] --for=[resource-kind]/[resource-\nname]: ** This command fetches events related to a specific resource in the\nspecified namespace. It continuously watches for new events related to the\ngiven resource.\n\n    \n    \n    kubectl events -n my-namespace --for=deployment/my-deployment\n\n## Old School vs. New School watching flags:\n\n-o wide vs. -w:\n\n-o wide: This is an \"old school\" flag that provides a wide output format, showing additional details about resources.\n\n-w: This is a \"new school\" flag that enables continuous watching for changes to resources, similar to the watch command.\n\n## Working with Pods\n\nPods are the smallest abstraction inside the Kubernetes ecosystem, they are\nthe logical units that house your containers. Pods consume resources and can\nbe executed into and produce logs. Here are some commands that will help you\nmanage pods.\n\n    \n    \n    # Show resource usage of a pod kubectl top pod -n [namespace] [pod-name]\n    \n    # Run a command inside a new pod in the cluster kubectl run -it ubuntu --image ubuntu --rm -- bash\n    \n    # Show resource labels as columns # e.g. kubectl get pods -n [namespace] -L vault-active -L vault-sealed kubectl get pods -n [namespace] -L vault-active -L vault-sealed\n    \n    # Execute a command inside a pod kubectl exec -it [pod-name] -n [namespace] --\n    \n    # Port forward to a pod kubectl port-forward [pod-name] [local-port]:[remote-port] -n [namespace]\n    \n    # Show container logs kubectl logs -n [namespace] [pod-name] kubectl logs -n [namespace] /deployment/[deployment-name] # Use -f flag for continuous streaming\n    \n    # Run a command inside an existing container kubectl exec -it -n [namespace] [pod-name] -- [command...]\n\n## Working with nodes\n\nNodes are the underlying instances that provide computational power and\nstorage on top of which your Kubernetes cluster runs.\n\n    \n    \n    # Show node resource utilization kubectl top node [node-name] # Node name is optional; without shows table of all nodes\n    \n    # Get node information kubectl get node\n\n## Working with Deployments, DaemonSets and StatefulSets\n\nDeployments, DaemonSets, and StatefulSets are higher-level abstractions in\nKubernetes that manage the deployment and scaling of application workloads.\n\n    \n    \n    # Restart a workload (e.g. deployment, stateful set, daemon set) kubectl rollout restart -n [namespace] [workload-kind]/[workload-name] # Triggers a re-creation of all pods for this workload, adhering to the workload configuration\n    \n    # Check the status of a deployment rollout kubectl rollout status deployment/[name]\n    \n    # View rollout history of a deployment kubectl rollout history deployment/[name] # View rollout history of a deployment\n    \n    # Scale a deployment to the specified number of replicas kubectl scale deployment/ --replicas=[number] # Scale a deployment to the specified number of replicas\n    \n    # Watch events related to a deployment kubectl events -n glasskube-system --for=deployment/glasskube-controller-manager\n    \n    #Update Deployment Image kubectl set image deployment/[deployment-name] [container-name]=new-image:tag\n    \n    # Delete DaemonSet kubectl delete daemonset [daemonset-name]\n\n## Working with jobs\n\nJobs manage the execution of pods to perform a particular task and ensure the\ntask is completed successfully before terminating.\n\n    \n    \n    # Run a CronJob manually kubectl create job [job-name] --image=image/name\n    \n    # Creates a new job from the job template specified in the cronjob kubectl create job -n [namespace] --from=cronjob/[cron-job-name] [job-name]\n\n## Working with secrets\n\nSecrets are used to store sensitive information like passwords, OAuth tokens,\nand SSH keys securely in Kubernetes.\n\n    \n    \n    # Create Secret kubectl create secret generic [secret-name] --from-literal=key1=value1 --from-file=ssh-privatekey=~/.ssh/id_rsa\n    \n    # Get a value from a secret kubectl get secrets -n [namespace] [secret-name] --template='{{ .data.[key-name] | base64decode }}'\n    \n    # Get a value from a secret using jsonpath kubectl get secrets [secret-name] -o jsonpath=\"{.data.key1}\" | base64 --decode\n\n> i\ufe0f JSONPath is a query language used to extract specific data from JSON\n> documents. In Kubernetes, JSONPath expressions are often used with the -o\n> jsonpath flag in kubectl commands to extract specific information from the\n> output of those commands.\n\n## Shell completions\n\nAs you have probably noticed, kubectl commands can get long in no time. A\nreally nifty shell completion script can be added to your bash or zshell file\nto enable easy tab completions. No more memorizing. To do so in all your shell\nsessions, add the following to your ~/.zshrc file:\n\n    \n    \n    source <(kubectl completion zsh)\n\nAnd restart the shell. Follow the instructions here if you are using bash:\n\n    \n    \n    # Install bash-completion package sudo apt-get install -y bash-completion # Store the output of the completion command in .bashrc echo \"source <(kubectl completion bash)\" >> ~/.bashrc # Activate the completion rules source ~/.bashrc\n\n## Working declaratively\n\nDeclarative management of Kubernetes resources involves specifying the desired\nstate of your resources using YAML manifest files and applying those manifests\nto the cluster.\n\n### Create YAML files\n\nAll Kubernetes objects are defined in YAML files, regardless if you write them\nyourself or not, YAML file definitions are how the Kubernetes API knows what\nthe state of the cluster should be:\n\n    \n    \n    apiVersion: apps/v1 kind: Deployment metadata: name: glasskube-deployment spec: replicas: 3 selector: matchLabels: app: glasskube env: prod template: metadata: labels: app: glasskube env: prod spec: containers: - name: glasskube-container image: your-glasskube-image:latest\n\nTo create this deployment from scratch use the kubectl create command:\n\n    \n    \n    kubectl create -f glasskube-deployment.yaml\n\n### Apply YAML Files (client-side apply)\n\nApplying YAML files is the standard method for managing Kubernetes resources.\nYou define the desired state of your resources in YAML format and apply those\nYAML files to the cluster.\n\n    \n    \n    kubectl apply -f manifest.yaml\n\n### Server-Side Apply (SSA)\n\nServer-Side Apply is a newer approach to applying configuration changes to\nKubernetes resources. With SSA, changes are applied directly on the server\nside, meaning that the Kubernetes API server takes responsibility for ensuring\nthat the desired state is achieved.\n\n    \n    \n    kubectl apply --server-side -f manifest.yaml\n\n## Plugins and tooling \ud83e\uddf0\n\nWhenever I see some back and forth around what Kubernetes is and isn\u2019t. What\nuse cases it\u2019s best suited for and how should it best be thought of, the same\nKelsey Hightower tweet pops into my head.\n\nThe sentiment is widely agreed upon, as evidenced by the extensive ecosystem\nof Kubernetes plugins and tools designed to assist in various stages of the\nKubernetes lifecycle.\n\n### Krew the Kubernetes plugin manager\n\nA great plugin manager to find new plugins is krew, install is here.\n\nCommand to install kubectl plugins via Krew:\n\n    \n    \n    kubectl krew install <PLUGIN_NAME>\n\nLet\u2019s explore some of the main plguing and tooling categories and highlight\nsome of the most useful projects out there. Since there are so many worth\nbringing attention to, I will add a section of Honorable mentions to each\nsection.\n\n### Content and Namespace switching \ud83d\udd00\n\nIn Kubernetes environments, you consistently operate within 2 hierarchical\ncontexts the clusters and the namespaces. Ensuring accurate command execution\nrequires specifying the appropriate context to obtain the desired output.\nSwitching cluster contexts or namespaces can involve lengthy commands to\nremember, which is where tools like Kubectl and Kubens come in.\n\n#### Kubectx and Kubens\n\nEasily see the available clusters and namespaces and swith between them\neffortlessly. Installation instructions here.\n\nHonorable mentions:\n\n  * kubectl-cf: A faster way to switch between kubeconfig files (not contexts).\n\n### Visibility \ud83d\udd2d\n\nKubernetes clusters are complex systems, with many moving parts that depend on\neach other so that your apps run. To have clear visibility into what is\nhappening at all times is crucial.\n\n#### k9s\n\nK9s is a handy and low-weight interactive Kubernetes dashboard that runs right\nin the terminal. As well as visualizing your k8s resources, you can also\neasily execute into pods, edit manifest, and manage your workloads all in one\nplace. It is probably one of my favorite tools for Kubernetes management\n\nInstall is here.\n\n#### kubectl tree\n\nA kubectl plugin to explore ownership relationships between Kubernetes objects\nthrough ownersReferences on the objects.\n\nInstall:\n\n    \n    \n    kubectl krew install tree kubectl tree --help\n\n#### kubecolor\n\nKubeColor is used to add colors to your kubectl output.\n\nInstallations instructions here.\n\n### Package management \ud83d\udce6\n\nCluster package management with conventional package management tools can be a\npain in the neck, and updating packages is a hassle. Configuration is clunky\nand applying your desired package stack declaratively has been still out of\nreach, until now.\n\n#### Glasskube:\n\nWith Glasskube all the pain points found in conventional package managers like\nhelm are solved to ensure you have time to manage your workloads and not have\nto worry about managing your k8s package stack.\n\n### Networking \ud83c\udf10\n\n#### Kubectl-Cilium:\n\nkubectl-Cilium is a plugin that interacts with Cilum which is an eBPF-based,\ncloud-native solution for providing, securing, and observing network\nconnectivity between workloads.\n\nInstall:\n\n    \n    \n    kubectl krew install cilium\n\n#### Cert-manager:\n\nCert-manager adds certificates and certificate issuers as resource types in\nKubernetes clusters, simplifying obtaining, renewing, and using those\ncertificates.\n\nInstallation instructions here.\n\nHonorable mentions:\n\nKsniff: A kubectl plugin that utilizes tcpdump and Wireshark to start a remote\ncapture on any pod in your Kubernetes cluster.\n\n### RBAC \ud83e\udef7\n\n#### Kubelogin\n\nKubelogin is a plugin for Kubernetes OpenID Connect (OIDC) authentication,\nalso known as kubectl oidc-login.\n\nInstallation instructions here.\n\n#### Kube-policy-advisor:\n\nKube-policy-advisor makes it easier to create K8s Pod Security Policies (PSPs)\nor OPA Policy from either a live K8s environment or from a single .yaml file\ncontaining a pod specification (Deployment, DaemonSet, Pod, etc). Install:\n\n    \n    \n    kubectl krew install advise-policy\n\nHonorable mentions:\n\n  * kubectl-who-can: Shows which subjects have RBAC permissions to VERB [TYPE | TYPE/NAME | NONRESOURCEURL] in Kubernetes.\n\n  * rakkess: Review Access - kubectl plugin to show an access matrix for server resources\n\n  * kubectl-rolesum: Summarize RBAC roles for the specified subject (ServiceAccount, User and Group).\n\n### Linting \ud83d\udccb\n\n#### Kubectl-neat:\n\nKubectl-neat removes clutter from Kubernetes manifests to make them more\nreadable. It primarily looks for two types of things to ignore: default values\ninserted by Kubernetes' object model and common mutating controllers. Install:\n\n    \n    \n    kubectl krew install neat\n\n#### KubeLinter:\n\nKubeLinter analyzes Kubernetes YAML files and Helm charts, and checks them\nagainst a variety of best practices, with a focus on production readiness and\nsecurity.\n\nInstallation instructions https://github.com/stackrox/kube-linter?tab=readme-\nov-file#installing-kubelinter.\n\n### Cluster maintenance and Security \ud83d\udee1\ufe0f\n\n#### KubePug\n\nKubePug downloads a generated data.json file containing API deprecation\ninformation for a specified release of Kubernetes, scans a running Kubernetes\ncluster to determine if any objects will be affected by deprecation and\ndisplays affected objects to the user. Example: You can check the status of a\nrunning cluster with the following command.\n\n    \n    \n    $ kubepug --k8s-version=v1.22 # Will verify the current context against v1.22 version [...] RESULTS: Deprecated APIs: PodSecurityPolicy found in policy/v1beta1 \u251c\u2500 Deprecated at: 1.21 \u251c\u2500 PodSecurityPolicy governs the ability to make requests that affect the Security Context that will be applied to a pod and container.Deprecated in 1.21. -> OBJECT: restrictive namespace: default\n    \n    Deleted APIs: APIs REMOVED FROM THE CURRENT VERSION AND SHOULD BE MIGRATED IMMEDIATELY!! Ingress found in extensions/v1beta1 \u251c\u2500 Deleted at: 1.22 \u251c\u2500 Replacement: networking.k8s.io/v1/Ingress \u251c\u2500 Ingress is a collection of rules that allow inbound connections to reach the endpoints defined by a backend. An Ingress can be configured to give servicesexternally-reachable urls, load balance traffic, terminate SSL, offer namebased virtual hosting etc.DEPRECATED - This group version of Ingress is deprecated by networking.k8s.io/v1beta1 Ingress. See the release notes for more information. -> OBJECT: bla namespace: blabla\n\nInstall:\n\n    \n    \n    kubectl krew install deprecations\n\n#### Kubescape:\n\nKubescape is an open-source Kubernetes security platform for your clusters,\nCI/CD pipelines, and IDE that separates out the security signal from the\nscanner noise.\n\nInstallation instructions here.\n\nHonorable mentions:\n\n  * kubectl-watch: Another watch tool with visualization view of delta change for kubernetes resources.\n\n### Troubleshooting \ud83e\uddd1\ud83d\udd27\n\n#### Inspektor-Gadget:\n\nInspektor-gadget is a collection of tools (or gadgets) to debug and inspect\nKubernetes resources and applications.\n\nInspektor Gadget tools are known as gadgets. You can deploy one, two, or many\ngadgets.\n\n#### K8s-gpt:\n\nk8sgpt is a tool for scanning your Kubernetes clusters, diagnosing, and\ntriaging issues in simple English.\n\nInstallation instructions here.\n\nHonorable mentions:\n\n  * kubectl node-shell : Starts a root shell directly in the node's host OS running.\n\n### Logging \ud83e\udeb5\n\n#### Stern:\n\nStern allows you to tail multiple pods on Kubernetes and multiple containers\nwithin the pod. Each result is color-coded for quicker debugging. Install:\n\n    \n    \n    kubectl krew install stern\n\n> i\ufe0f Some security implications of using kubectl plugins include possible\n> Vulnerabilities, Privilege Escalation, and inadvertent Data Leakage. Make\n> sure to only use actively maintained plugins and ideally have an active\n> community around them.\n\n## Aliases \ud83d\udcc7\n\nWith so many kubectl commands to remember, simplify your life by using\nkeyboard shortcuts or aliases.\n\nHere you will find a repo with contains a script to generate hundreds of\nconvenient shell aliases for kubectl. The thing is that many of the aliases\nare long and might become hard to recall. Don\u2019t worry though I found this very\npragmatic blog post by Benoit Couetil on how to deal with the many aliases\ngenerated by the above script.\n\n## Kubectl Cheatsheet\n\nNo guide is complete without a cheatsheet now is it?\n\n    \n    \n    # Basic Commands\n    \n    # List API Resources kubectl api-resources\n    \n    # List Resources kubectl get [name]\n    \n    # Explain Resources kubectl explain\n    \n    # Working with Pods # Create a new deployment named \"nginx-deployment\" with the nginx image kubectl run nginx-deployment --image=nginx\n    \n    # Show Resource Usage of a Pod kubectl top pod -n [namespace] [pod-name]\n    \n    # Run Command in Pod kubectl run -it [pod-name] --image [image-name] --rm -- [command]\n    \n    # Show Resource Labels kubectl get pods -n [namespace] -L [label1] -L [label2]\n    \n    # Execute Command in Pod kubectl exec -it [pod-name] -- [command]\n    \n    # Port Forwarding kubectl port-forward [pod-name] [local-port]:[remote-port]\n    \n    # Filtering Pods by Node Name kubectl get pods --field-selector spec.nodeName=[node-name]\n    \n    # Filtering Pods by Phase kubectl get pods --field-selector status.phase=Running\n    \n    # Delete a pod named \"my-pod\" in the default namespace kubectl delete pod my-pod\n    \n    # Working with Nodes\n    \n    # Watch Nodes (Old School) watch kubectl get nodes -o wide\n    \n    # Watch Nodes (New School) kubectl get nodes -w\n    \n    # Node Resource Utilization kubectl top node [node-name]\n    \n    # Get Node Resource kubectl describe node [node-name]\n    \n    # Working with Deployments, Daemonsets, and StatefulSets\n    \n    # Restart Workload kubectl rollout restart -n [namespace] [kind]/[name]\n    \n    # Rollout Status kubectl rollout status [kind]/[name]\n    \n    # Rollout History kubectl rollout history [kind]/[name]\n    \n    # Scale Deployment kubectl scale deployment/[name] --replicas=[replica-count]\n    \n    #Update Deployment Image kubectl set image deployment/[deployment-name] [container-name]=new-image:tag\n    \n    # Watch events related to a deployment kubectl events -n glasskube-system --for=deployment/glasskube-controller-manager\n    \n    # Delete DaemonSet kubectl delete daemonset [daemonset-name]\n    \n    # Working with Jobs\n    \n    # Run CronJob Manually kubectl create job -n [namespace] --from=cronjob/[cron-job-name] [job-name]\n    \n    # Working with Secrets\n    \n    # Get Value from Secret kubectl get secret -n [namespace] [secret-name] -o=jsonpath='{.data.[key]}' | base64 --decode\n    \n    # Create Secret kubectl create secret generic [secret-name] --from-literal=key1=value1 --from-file=ssh-privatekey=~/.ssh/id_rsa\n    \n    # Get a value from a secret kubectl get secrets -n [namespace] [secret-name] --template='{{ .data.[key-name] | base64decode }}'\n    \n    # Working with Containers\n    \n    # Show Container Logs kubectl logs -n [namespace] [pod-name] kubectl logs -n [namespace] deployment/[deployment-name]\n    \n    # Run Command in Container kubectl exec -it -n [namespace] [pod-name] -- [command]\n    \n    # Working Imperatively\n    \n    # Modify Resource kubectl edit -n [namespace] [resource-kind]/[resource-name]\n    \n    # Delete Resource kubectl delete [resource-kind]/[resource-name]\n    \n    # Create Resource kubectl create -f [resource-file]\n    \n    # Working Declaratively\n    \n    # Use Server-Side Apply (SSA) kubectl apply --server-side -f [resource-file]\n    \n    # Events and Logs\n    \n    # Show Events for Resource kubectl get events -n [namespace] --field-selector involvedObject.kind=[kind] --field-selector involvedObject.name=[name]\n    \n    # Filtering Events by Type kubectl get events --field-selector type=Warning\n    \n    # Filtering Events by Involved Object Name kubectl get events --field-selector involvedObject.name=[resource-name]\n    \n    # Show Resource Usage kubectl top\n\n## Additional resources:\n\n  * Curated list of plugins: https://github.com/ishantanu/awesome-kubectl-plugins\n  * List of aliases: https://github.com/ahmetb/kubectl-aliases\n  * Krew plugins repo: https://krew.sigs.k8s.io/plugins/\n\nIf you like this sort of content and would like to see more of it, please\nconsider supporting us by giving us a Star on GitHub \ud83d\ude4f\n\nTags:\n\n  * kubectl\n\nLast updated on May 6, 2024 by Philip Miglinci\n\nDocs\n\n  * Architecture\n  * Getting started\n\nComparisons\n\n  * Glasskube vs Helm\n  * Glasskube vs Timoni\n  * Glasskube vs OLM\n\nCommunity\n\n  * Discord\n  * Twitter / X\n  * LinkedIn\n  * GitHub\n\nMore\n\n  * Blog\n  * Contact / Book appointment\n\nCopyright \u00a9 2024 Glasskube, Inc. Built with Docusaurus.\n\n", "frontpage": false}
