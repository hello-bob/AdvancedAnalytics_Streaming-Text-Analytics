{"aid": "40113925", "title": "Internet of Desks: How I Connected My Standing Desk to the Internet", "url": "https://kn100.me/desksniffer/", "domain": "kn100.me", "votes": 11, "user": "kn100", "posted_at": "2024-04-22 12:58:39", "comments": 6, "source_title": "DeskOps: Commanding My Desk with HTTP - How I Brought Hysteresis Problems to the Desk Where I Solve Hysteresis Problems", "source_text": "DeskOps: Commanding My Desk with HTTP - How I Brought Hysteresis Problems to the Desk Where I Solve Hysteresis Problems | Kevin Norman\n\n## DeskOps: Commanding My Desk with HTTP - How I Brought Hysteresis Problems\nto the Desk Where I Solve Hysteresis Problems\n\n21 April, 2024\n\nBE CAREFUL! This post has been marked as potentially dangerous either to\nhealth or the devices discussed. You follow this post at your own risk.\n\nI have a standing desk, but I\u2019ve always wanted a way to automate it, so that I\ncould set up a schedule for \u201cstanding\u201d vs \u201csitting\". The controller box itself\ncontains absolutely no smarts, and has no obvious external control mechanism,\nso I wasn\u2019t really sure how I\u2019d achieve this. This post documents my\nexperience building a system that allows me to do this. It is not intended\nentirely as a build guide, but more an exploration of what hardware hacking is\nlike for somebody with very little previous experience. Hopefully you\u2019ll learn\nsomething from this and I\u2019ll save you some of the time I spent learning this\nstuff!\n\n# What this is\n\nI made a custom circuit board that kind of zombifies the original standing\ndesk controller. It is able to read the current height of the desk from the\noriginal controller, as well as pilot the desk up and down. It is controllable\nvia HTTP requests, as well as from buttons on the front of the controller.\n\n    \n    \n    GET http://esp32-abcde/desk {\"height\":720} GET http://esp32-abcde/desk?height=780 `OK`\n\n# Initial exploration\n\nThe standing desk I have is a VIVO DESK-V122EB frame with a 2.5m IKEA\ncountertop placed atop it. More importantly, the controller box my standing\ndesk has looks like this (Apologies for the terrible photo, I didn\u2019t take any\nphotos before doing what I did, so this one was cropped from a much larger\nphoto).\n\nAfter doing some Googling, nothing seemed particularly relevant to my specific\nstanding desk, and other solutions I found involved strapping motorized button\npressing robots to the controller, so I decided to open up the controller box\nand take a look to see if I could do something smarter.\n\nLooking at the circuit board, I realised it would be trivial to \u2018press\u2019 the up\nand down buttons from an external microcontroller. All I\u2019d need to do is use a\ntransistor to bridge the contacts of the switch. I really wanted something a\nbit smarter than that though. I wanted whatever I built to be able to know the\nheight of the desk. After studying the board for a bit and googling the random\npart numbers on the chips I could see on the board, I identified the AIP650 as\nthe chip responsible for driving the LCD. Fortunately, a data sheet was\navailable for this part, but unfortunately it was in Chinese, a language I do\nnot speak.\n\nAccording to the data sheet, translated with DeepL, it receives data in an i2c\n\u2018like\u2019 format, and then drives a 3 segment LCD just like the one on this board\nbased on what data it received. I was unable to determine from the data sheet\nwhat the data being sent to the controller actually \u201cmeant\u201d, but wasn\u2019t\nworried about that for the moment. I just wanted to capture the data.\n\nFor those not familiar with hardware, I2C is the scheme by which most circuits\nuse for inter-chip communication. In my desk controller, there is a\nmicrocontroller which writes data to a LCD driver chip, which in turn lights\nthe correct segments on a 3 digit segmented LCD. How would I capture the data\nthough? Easy, I thought! All I had do to was hook up to the same two pins the\ndata sheet reported as being the i2c pins along with the grounds of the\nstanding desk controller and my esp32, and I could then \u201csniff\u201d the data that\nwas being sent across the i2c bus, decode it, and then use that for something\nuseful.\n\nSo away I went! I soldered two wires directly to the pins on the chip that\nwere marked as the data pins (I am deeply sorry to anybody offended by my\nsoldering job!), and soldered a third wire to a ground point on the board. I\nthen connected those wires to an ESP32, and then went looking for somebody\nelses code to try to sniff the i2c data to see if this was even possible.\n\nI came across one such project online, which just about worked. It would\noutput what looked like plausible i2c data, but would constantly crash or\nstart outputting total nonsense. At this point, I hadn\u2019t really understood\nI2C, nor did I understand the code here at all, so the fact it worked even a\nlittle bit I took as a win.\n\nAt this point, I still hadn\u2019t really considered how the code worked at all, so\nI then took the plunge into the code and figured out its method of operation,\nso next I took a dive into the world of I2C.\n\n# A quick look into I2C\n\n> If you understand I2C even a little bit, you probably understand it better\n> than I, so you can skip this section.\n\nIn I2C communication, there are two pins involved. One is the clock pin,\nusually referred to SCL, and the data pin, referred to as SDA. The\nparticipants on an I2C bus are known as controller devices, and target devices\n(although are commonly referred to as master/slave in data sheets and the\nsuch!). Controller devices write to the I2C bus, and target devices listen for\nwrites that are targeting them. Target devices do respond on the I2C bus, but\nthis is to just acknlowledge they correctly received data. Remember that this\nis digital data - so the controller can only pull either of the pins high or\nlow, which literally means \u201cemitting voltage\u201d or \u201cconnected to ground\u201d. It\nemits a clock signal (continuous pulses on the SCL pin), along with varying\npulses on the SDA pin for signalling.\n\nLet\u2019s review one I2C communication session:\n\n  1. A controller wants to communicate with a target. IT first must assert control of the bus. To do this, it first pulls SCL high, and then pulls the SDA line high, then pulls it low. This transition of SDA from high to low while SCL has been held high implies a master is about to broadcast data, and targets know to listen for incoming data.\n\n  2. The controller needs to let all those target devices listening know which device it wants to talk to. It does this by sending 7 bits of data which correspond to a device address, along with 1 bit to indicate whether it would like to read or write to that specific device. It transmits these bits of data by pulling SDA either high or low to indicate a 1 or 0, along with a clock pulse (pulling the clock from low to high). This triggers the target device to read the value that is present on the SDA pin, thus transmitting a byte.\n\n> A note about addresses: They\u2019re not always 7 bits, and sometimes can be 10\n> bit. They\u2019re usually hardcoded into whatever target device is receiving them\n> - and for hobbyist grade Arduino attachments, you can even configure the\n> address through jumper pins or switches, allowing you to connect more than\n> one of the same device to an i2c bus.\n\n  3. Next, the target with the correct address must ACK this transmission, to signal to the controller that it is ready to receive data. The target does this by pulling the SDA pin low, which the controller interprets as an ACK. If no target ever does this, the controller should assume it wasn\u2019t heard for some reason.\n\n  4. Assuming the target ACKed the transmission, meaning it recognised the next data on the I2C bus is intended for it, the controller proceeds to transmit a data packet. IT transmits 8 bytes of data following the same scheme as the address transmission above, and again waits for an ACK condition the same way. If there is more than a single byte of data that needs to be transferred, it just transmits the next 8 bits after receiving the ACK. This cycle can happen an arbitrary number of times.\n\n  5. The controller is now done transmitting to that particular I2C device, so it needs to signal that. It sends a stop condition. This is similar to the start condition described above, except this time we pull SCL high, and then pull SDA high. The transition of SDA from low to high while SCL was held high indicates the transmission is over.\n\n# Digging deeper into the desk\n\nKnowing all of this now, I decided to refactor the code sample above into a\nform that was better understood by me, which ended up turning into this\nproject.\n\nA quick discussion on how this code works. Since we only really care when the\nstate changes on the pins we are sniffing (SDA and SCL) we can get away with\nusing interrupts. An interrupt causes the CPU to halt execution of whatever it\nwas doing, switch to some other context, do some other processing, and then\nreturn back to the main program loop. In our context, we want interrupts that\ntrigger on state changes for the I2C Pins. Realistically, there are only two\nevents we only really care about:\n\nHow we detect start and stop conditions: SDA changing from HIGH > LOW or from\nLOW > HIGH triggers the interrupt i2cTriggerOnChangeSDA(). If SCL was LOW,\nthis isn\u2019t a start or stop, so just return. If SCL was high, depending on the\ncurrent bus state (discussed later), along with whether SDA is high or low, we\nrecord a Start or Stop to a buffer. Concerning the bus state: we initially\nassume the bus is IDLE, and move to TX if there is a start condition detected.\nIf a stop condition is detected, we move to IDLE)\n\nHow we detect data being transmitted: SCL changing from Low > High indicates\nthat there is data for us to read. so, the transition triggers the interrupt\ni2cTriggerOnRaisingSCL(), which checks the bus state. If it was set to TX by\ni2cTriggerOnChangeSDA(), we read whatever data is present on SDA pin and write\nit into the buffer\n\nThis results in a stream of data, and very quickly a buffer overflow. To\nresolve this, we need some code that processes that buffer and does something\nuseful with it. We can only do this processing with the I2C bus is idle, so,\nin the main program loop, we wait for the IDLE bus condition to be reported by\nthe interrupts above. Once we have that, we can safely parse through the\nbuffer, and do something with the data. In the example code above, it just\nprints whatever it got to Serial. Once it\u2019s caught up with the last written\nposition of the buffer, it resets the variables that keep track of where the\nbuffer was last written to and read to, so that we can continue to use that\nsame memory over and over.\n\nThe code did as I asked and outputted streams of 1s and 0s along with start\nand stop conditions to the screen, but I had no idea what any of it meant, nor\nif the code even worked. What I could see is that there seemed to be bursts of\ndata, and if the data was to be believed, at least 5 I2C addresses receiving\ndata.\n\nI lamented this fact in a conversation with a colleague (if you\u2019re reading\nthis, you know who you are, THANKS!), and he suggested I pick up a Logic\nAnalyzer. I had no idea what a logic analyzer was, but for years I\u2019d looked on\nin envy as others used their logic analyzers for interesting hacking related\ntasks, and thought that stuff was way too complicated for me. I\u2019d never gotten\none because I was afraid of buying it, realizing I was way out of my depth,\nand it becoming \u201cthat thing I bought that I have no idea how to use\u201d.\n\nThis time however I bit the bullet and bought the cheapest logic analyzer I\ncould. I had no idea how to use the thing when it arrived, but I discovered\nthat Pulseview is a piece of software that can be used for logic analysis. I\nconnected the SDA and SCL pins of my desk up to my logic analyzer, connected\nit to my computer, fired up Pulseview, and clicked around a bit. Almost\nimmediately, I figured out how to \u201csample\u201d the data the logic analyzer was\ngetting, as well as that Pulseview includes a super handy I2C decoder built\nright in!\n\nSo, I sampled, and lo and behold, roughly what I\u2019d been observing with the\nesp32 sniffing code was visible here too! Short, sporadic bursts of data.\nAgain, sorry for the photos, you might want to right click and open them in a\nnew tab so you can arbitrarily zoom them!\n\nZooming in, even more success! Comparing what my code was outputting to what\nwas being seen on the logic analyzer, I could see the same addresses and the\nsame data packets. Incredible. It seemed that in my particular case, each\naddress received exactly one byte of data, and that the NACK/ACK bits didn\u2019t\nseem to make a lot of sense. I wonder if this is what the creators of the\nAIP650 meant when they said it was \u2018i2c-like\u2019.\n\nI still had no idea what any of this meant, so I flailed about for a bit.\nAfter a bit of thinking, I theorised that perhaps the AIP650 chip was not\n\u201cone\u201d i2c device, but instead was at least three, one per segment. That way,\nthe microcontroller that was asking it to display stuff could update each\nsegment as it needs to. It kind of made sense. A segment of the LCD consists\nof seven segments, along with a period that appears beside that segment.\nThat\u2019s 8 bits of information, so maybe each segment is linked to a specific\nbit in the byte.\n\nTo test that theory, I got the rightmost segment to display a zero, and\nsampled using the logic analyzer. I dumped the data out of Pulseview, and\nproceeded to make the segment display a 1, rinse and repeat all 9 digits. I\nwrote all the data I got into a spreadsheet (this took a while) in the hopes I\ncould spot a pattern.\n\nThis allowed me to confirm that a specific pattern of bits corresponded to the\nnumbers 0 through 9, and also allowed me to identify which i2c address\ncorresponded to which position on the display (the digit), as well as allowing\nme to identify that the most significant bit in the byte corresponded to the\nperiod portion of the digit. This is decent progress, I thought!\n\nWhat it didn\u2019t do however was tell me which bit corresponded to which\nindividual segment of a digit. Figuring that out was kind of like solving a\nSudoku. I sat there with a sheet of paper, drawing the digits as segments 0\nthrough 9, trying to find the commonalities.\n\nAs an example of what this particular puzzle took, let\u2019s work through\nidentifying two segments of a digit. We see that when the digit 1 is present\non the LCD, the binary 00000110 is present. That must mean that the 6th and\n7th bit correspond to the segments B and C, but we don\u2019t know which is which.\nTo determine which, we now have to find a digit which only had either B or C\nilluminated.\n\nThe digit 5 proves to be a good candidate here, since C is illuminated, but B\nis not. Looking at the data we collected, 5 seems to be represented by\n01101101. The 6th bit is 1, the seventh is 0, meaning that the 6th bit must\nthen be C, and B must therefore be represented by the 7th bit. Continue this\nprocess of deduction all the way and you\u2019ll eventually figure out which bit\nrepresents which segment. In my case, each bit in the array represented the\nfollowing segment:\n\n  * Position 0: DP\n  * Position 1: G\n  * Position 2: F\n  * Position 3: E\n  * Position 4: A\n  * Position 5: C\n  * Position 6: B\n  * Position 7: D\n\nNow that I knew what the binary data meant, I was finally ready to decode it.\nI wrote some code that would parse each I2C frame in the buffer into the\naddress portion to figure out which segment was being written to, and then\nparse the data portion into a character. I don\u2019t have the code I wrote back\nthen, but here\u2019s the most recent revision showing how we turn the data portion\ninto a digit, along with the code that parses through the buffer\n\nNext up came actually raising and lowering the desk. I\u2019d already done this\nsort of thing before, having previously tasked an ESP32 with pressing the\nbutton on my USB switching hub so this part was going to be relatively simple.\n\nAll you need to do really is take a transistor, connect the collector and\nemitter to your switch contacts, along with connecting the base to one of your\nESP32s GPIO pins (through a resistor to limit current, 10k will do!). Then, in\nyour ESP32 or Arduino code, all you need to do is configure your pin as an\noutput pin, ie: pinMode(yourPinInt, OUTPUT);, and then when you want to press\nthe button, you just bring the pin high by using digitalWrite(yourPinInt,\nHIGH);. To stop pressing the button, you bring the pin low\ndigitalWrite(yourPinInt, LOW);.\n\n# The electronics assembly\n\nOn my particular standing desk, the switch contacts consisted of an outer and\ninner ring. I determined that the outer ring was positive 5v, and was common\nacross the switches. The inner ring however was not common. Therefore, if I\nwanted my desk to go up or down, I needed to bridge ANY of the outer rings to\nthe center contact of the up and down switch. I firstly tested my design on a\nBreadboard:\n\nAfter validating this worked, I soldered together a protoboard. I firstly\nattached my ESP32. I then soldered two resistors to D33 and D32, and then\nconnected the center pin of both transistors (the base) to each resistor. I\nconnected the collectors of both transistors together (the leftmost leg, with\nthe flat side of the transistor facing you), and connected those legs to the\nouter ring of one of the switches. I then connected each Emitter leg to the\ncenter ring of the up and down rings.\n\nI also soldered D12 and D13 to the SDA and SCL pins on the AIP650 present on\nthe desk controller, along with a wire to VIN which would later supply 5\nvolts, along with a ground pin.\n\nI also attached wires to D15, D2, and D4, along with a second ground\nconnection\n\n  * which I will later attach to three switches, allowing me to have buttons on the outside of my new controller to control the desk manually, as I could before. I didn\u2019t bother connecting any of the other buttons of my desk to the ESP32 since I didn\u2019t care about the functionality they exposed (presets and the such).\n\nOnce all this was complete, and it continued to work, it was time to write\nsome code.\n\n# The code\n\nMy first revision of the code was a rats nest. I have no idea what I am doing\nin C++ (I\u2019m a Golang/Ruby baby!), but its method of operation was very simple.\nIt had two main variables responsible for control, the currentHeight, and\nrequestedHeight. If they were not equal, the code would press the button that\nwould cause currentHeight to move in the direction of requestedHeight, and\nrelease it once they were equal. Can you see the problem with this technique?\n\nIf not, no worries, I clearly didn\u2019t see it coming either, and I really should\nhave, given it\u2019s a very common problem in DevOps land. We regularly deal with\na concept called hysteresis, which is effectively a lag between an input and a\ndesired output. If you\u2019re more familiar with servers, maybe this example will\nhelp. Imagine you scale the number of replicas in a particular deployment\nbased on a really simple metric like CPU utilisation. You might have some sort\nof rule like \u201cIf the CPU utilisation average hits 80%, add a replica. If it is\nbelow 80%, remove a replica. Then, when your clever autoscaler recognises that\nthe average utilisation has exceeded 80%, it dutifully adds a replica. The\nutilisation then drops below 80%, and a replica gets removed, bringing the\nutilisation back up over 80%. This cycle repeats ad nauseum until you just use\nan autoscaler written by someone else.\n\nWell friends, I had hysteresis in the form of a 2.5m long oscillating\nvibrating desk. The code frantically tried its best to make currentHeight\nequal requestedHeight, but all it did was cause my desk to oscillate up and\ndown frantically until it eventually overheated and refused to do anything for\naround an hour after this event.\n\nAs hysterically funny as I found this, I really didn\u2019t want to break my desk,\nso I went back to the code and tried to fix this.\n\nThe fix I came up with was stupid, but it works. The \u2018proper\u2019 solution is\nprobably a PID controller, but the solution I came up with is far simpler to\nwrite and works perfectly, so I don\u2019t really care. I just implemented a form\nof crude PWM on the button pushes! Conceptually, instead of holding the button\nuntil we see the target height, we instead hold the button until we are near\nthe target height, at which point we start rapidly pressing and depressing the\nbutton, which has the effect of causing the desk to move more slowly. We keep\ndoing this until we reach the target height, and then we\u2019re done, without\novershooting or undershooting the target.\n\nSomething else I learned the hard way is that my desk controller really does\nnot appreciate having its button pressed and depressed at the clock speed of\nthe ESP32, and it gets really confused and sad. This was simple to resolve\nthough just by modifying the code to press and depress the button with a 50ms\ncycle time.\n\nThrough all this, I ended up with some code where I could program the ESP32\nwith a given height, and after I reflashed the ESP32, it would command the\ndesk to a particular height.\n\nI obviously wanted a way of setting this value arbitrarily, so I set up a\nsimple HTTP web server that would do this for me, hosted on the ESP32. It sits\nthere, waiting for requests, and if it receives a height change command, it\ndoes exactly as I described above and it worked beautifully.\n\n# 3D printing an enclosure\n\nCAD modelling is something I also have no professional experience with. I\u2019ve\nbeen teaching myself over the last few months, and decided this was the\nperfect opportunity to model something relatively complex. What I wanted was a\nplace to put the original controller board so the LCD was still visible, spots\nto put 3 real mechanical keyboard switches (yes, the kind you find in a\nkeyboard :P), and a spot to screw in the protoboard construction documented\nabove.\n\nI came up with this. Beauty is in the eye of the beholder, I guess! I threw\nthe job to my trust Sovol SV07 and waited a few hours. It turns out I designed\nsomething that is a nightmare to print, but the printer did an admirable job\neven with my ridiculous design. It\u2019s impressive what modern 3D printers are\ncapable of!\n\nI then assembled everything pretty much as described, just with the addition\nof 3 mechanical keyboard switches, and it all went together mostly as\ndesigned. The print quality is frankly terrible. This was down to a\nmisconfiguration of the printer, as well as the fact that this is a fairly\ndifficult to print model. I was also being impatient and printing it at\nludicrous speeds. 3D printing is a hobby that really benefits from patience,\nsomething I sometimes lack.\n\nI have not released the STL for this particular enclosure, because it is an\nabsolute nightmare to print, and has some design errors I haven\u2019t addressed.\nIf you really want it for some reason though, I will give it to you. Just ping\nme on Mastodon.\n\n# I\u2019m finished, right?\n\nGreat! Install and done right? I thought so too. I installed it, and revelled\nin telling anyone who would listen that now desk go up and down when I send\nHTTP request to it! Cool right? RIGHT?!. It worked great.\n\nUntil disaster struck. A few hours after I installed it, my desk started going\nup on its own. I was happily coding away, and it started going up totally on\nits own. No command. WTF?!\n\nI frantically unplugged it and started trying to think about why this\nhappened. I racked my brain, but I couldn\u2019t think of any reason. Through sheer\nluck it happened a second time while I was watching the serial output from the\nESP32. I had it logging out the state of the currentHeight and requestedHeight\nvariables if they changed, and the currentHeight randomly changed from 720 to\n1520! I had focussed all my thinking about reasons why requestedHeight might\nchange. I hadn\u2019t considered the actual height of the desk was being misread.\n\nIt turns out, writing your standing desk controller the same way you write\nreconciliation loops in Kubernetes-land is not a great approach. It also turns\nout, that just by installing your project in an enclosure, you can introduce a\nbrand new problem that was not present previously.\n\nEnough foreshadowing, the problem was pretty obvious in hindsight. Sniffing\nI2C is not a perfect art. Electromagnetic interference can cause you to\nincorrectly read a 0 as a 1, or a 1 as a 0. In my case, if this happens, in\nthe best case, we read an invalid I2C address, which just means we ignore that\nframe of data since we only care about a subset of i2c addresses (the ones\nthat correspond to each portion of the LCD). In the next best case, the actual\ndata portion gets corrupted somehow, and we get an arrangement of segments\nthat does not correspond to a valid digit. In this case, we again just ignore\nthat particular frame, and nothing bad happens. The most insidious cases\nthough are where a data frame gets corrupted, and we end up reading the wrong\ndigit.\n\nGiven my code works like a reconciliation loop, it notices that the current\nheight does not equal the previously requested height, and frantically tries\nto correct for that; but of course, it\u2019s reading invalid data, so desk go up\neven though I didn\u2019t ask it to. Oh noooo.\n\nI have made this situation extremely unlikely by adding a number of safety\nchecks:\n\n  * If a new currentHeight comes in that is substantially different to the previous reading, we assume that new reading was invalid. Usually, the next frame of data is read correctly, so this catches most cases.\n  * If a new currentHeight comes in that is out of bounds (ie, is a value the desk should never display), we just ignore it. This happens quite frequently, since one of the most common errors I\u2019ve seen is reading the first digit as a \u20181\u2019 instead of a \u20187\u2019 (a single bit different!).\n  * We only move if we have received a command to do so. CurrentHeight can change however it wants outside of a move command, we don\u2019t care, unless the user has issued a move request. Once the desk has reached its requested height, we make sure the desk has stopped moving, and then stop caring about currentHeight changes until the next request comes in.\n\nThis has resolved that specific problem! It\u2019s always good to remember to\nanticipate your hardware misbehaving and adding basic sanity checks to your\ncode.\n\n# The code today\n\nI reiterate from earlier, I do not really know C++/C or hardware, so this code\nis probably a litany of sins. Correct them in PRs if you like, I might even\nflash them to my desk, because those are words I can say without sounding\ninsane now! So, when reviewing this code, bear that in mind.\nhttps://github.com/kn100/desksniffer/\n\n# But why?\n\nRead this.\n\nLet me know what you thought! Hit me up on Mastodon at @kn100@fosstodon.org.\n\n  * personal\n  * hardware\n\nThis is the personal blog of Kevin Norman. Any opinions expressed here are not\nrepresentative of any organisation or employer I am or have been affiliated\nwith. Any information or guides provided here are for educational purposes\nonly. You are responsible for your own actions. Please don't electrocute\nyourself! Hit me up on Mastodon! @kn100@fosstodon.org\n\n", "frontpage": true}
