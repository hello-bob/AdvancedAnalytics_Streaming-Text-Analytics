{"aid": "40071508", "title": "SSH Tips and Tricks", "url": "https://www.trickster.dev/post/ssh-tips-and-tricks/", "domain": "trickster.dev", "votes": 2, "user": "keepamovin", "posted_at": "2024-04-18 00:06:08", "comments": 0, "source_title": "Trickster Dev", "source_text": "SSH tips and tricks \u2013 Trickster Dev\n\n# Trickster Dev\n\n# SSH tips and tricks\n\nSSH is well established protocol for securely accessing remote systems over\nthe network for administration and devops purposes. A widely deployed OpenSSH\nsoftware suite implements this protocol. But there is more to the SSH\ntechnology than reaching a remote shell over ssh(1) or copying files via\nscp(1)/sftp(1). We will go through some lesser known, somewhat advanced tricks\nand use cases that could be valuable in your daily work.\n\n## SSH escape sequences\n\nMost people don\u2019t know that ssh(1) provides somewhat secret control sequences\nthat can be used to manage in-progress connections. Make sure the last\nkeystroke you have typed is Enter, then type the tilde character and question\nmark (~?). You will be given the following message listing other sequences you\ncan do in a similar way:\n\n    \n    \n    Supported escape sequences: ~. - terminate connection (and any multiplexed sessions) ~B - send a BREAK to the remote system ~C - open a command line ~R - request rekey ~V/v - decrease/increase verbosity (LogLevel) ~^Z - suspend ssh ~# - list forwarded connections ~& - background ssh (when waiting for connections to terminate) ~? - this message ~~ - send the escape character by typing it twice (Note that escapes are only recognized immediately after newline.)\n\n~C gives you a secondary command prompt that can be used to manage port\nforwarding/tunneling (more on this later).\n\n## Single command through SSH\n\nSometimes you want to run just a single OS shell command via SSH connection\nand get the output. That can be done with a standard SSH client by launching\nit with -t and passing your command as last argument:\n\n    \n    \n    $ ssh -t root@167.172.24.25 \"date -R\" Sun, 14 Jan 2024 16:52:37 +0000 Connection to 167.172.24.25 closed.\n\n## 2FA on SSH login\n\nGenerally speaking, it is a recommended practice to use SSH keys for\nauthentication and to avoid relying on passwords. Passwordless SSH effectively\nprevents any successful brute force attack that could be done over the\nnetwork. However, if for some reason you still want to use SSH interface with\npassword you can make it more secure by adding Two Factor Authentication step.\nWe will go through the steps that can be taken to set it up on Debian 12\nsystem.\n\nMake sure your APT cache is up to date and install libpam-google-authenticator\npackage through APT:\n\n    \n    \n    # apt-get install libpam-google-authenticator\n\nNow we need to edit /etc/pam.d/sshd file to add the following line there:\n\n    \n    \n    auth required pam_google_authenticator.so\n\nAlso edit /etc/ssh/sshd_config to make sure there\u2019s following lines there\n(watch out for conflicting directives - you may need to change no to yes on\nsome lines):\n\n    \n    \n    UsePAM yes ChallengeResponseAuthentication yes KbdInteractiveAuthentication yes AuthenticationMethods keyboard-interactive\n\nRestart the sshd daemon to force it to read the updated config file:\n\n    \n    \n    # systemctl restart sshd.service\n\nIn your mobile device install Google Authenticator or a compatible app (e.g.\nFreeOTP.\n\nNow we\u2019re ready to run the google-authenticator tool, answer some questions\nand follow the instructions:\n\n    \n    \n    # google-authenticator Do you want authentication tokens to be time-based (y/n) y Warning: pasting the following URL into your browser exposes the OTP secret to Google: https://www.google.com/chart?chs=200x200&chld=M|0&cht=qr&chl=otpauth://totp/root@debian-s-1vcpu-512mb-10gb-ams3-01%3Fsecret%3D[REDACTED]%26issuer%3Ddebian-s-1vcpu-512mb-10gb-ams3-01 [REDACTED] Your new secret key is: [REDACTED] Enter code from app (-1 to skip): 371342 Code confirmed Your emergency scratch codes are: [REDACTED] Do you want me to update your \"/root/.google_authenticator\" file? (y/n) y Do you want to disallow multiple uses of the same authentication token? This restricts you to one login about every 30s, but it increases your chances to notice or even prevent man-in-the-middle attacks (y/n) y By default, a new token is generated every 30 seconds by the mobile app. In order to compensate for possible time-skew between the client and the server, we allow an extra token before and after the current time. This allows for a time skew of up to 30 seconds between authentication server and client. If you experience problems with poor time synchronization, you can increase the window from its default size of 3 permitted codes (one previous code, the current code, the next code) to 17 permitted codes (the 8 previous codes, the current code, and the 8 next codes). This will permit for a time skew of up to 4 minutes between client and server. Do you want to do so? (y/n) y If the computer that you are logging into isn't hardened against brute-force login attempts, you can enable rate-limiting for the authentication module. By default, this limits attackers to no more than 3 login attempts every 30s. Do you want to enable rate-limiting? (y/n) y\n\nWe were given the option to either scan the QR code rendered on the terminal\nin colored blocks or to have it displayed in the browser.\n\nScreenshot 1\n\nOnce we do all of this, we will be asked both one time key and the password\nwhen logging in via SSH:\n\n    \n    \n    $ ssh root@178.62.232.185 (root@178.62.232.185) Verification code: (root@178.62.232.185) Password:\n\n## SSH tunneling with -L\n\nSometimes you have some networked software running on remote system with\nlistener socket being bound to localhost or otherwise restricted network\ninterface.\n\nOne example is the situation in Jupyter notebook VPS on Digital Ocean. Once\nyou instantiate the VPS image you can run notebook.sh script in the home\ndirectory of ubuntu user to start the Jupyter lab webapp which will bind to\nlocalhost for security purposes. However, we are instructed to use ssh -L to\naccess it through SSH tunnel:\n\n    \n    \n    $ bash notebook.sh start JupyterLab started. See the logs under ~/notebook.log. Use 'notebook list' to view the URL. Remember that you need to create a tunnel to access the notebook from your localhost. On another terminal, use ssh root@<ip> -L 8888:localhost:8888 to create the tunnel. Then you can access the notebook from your local browser.\n\nRunning the provided command on client-side shell gives another SSH session\nwith the added benefit of Jupyter web app being available locally at port\n8888.\n\nScreenshot 2\n\nAs another example, a Linux server running LAMP stack may allow HTTP and SSH\naccess on public network, but make MySQL listen for incoming connections on\n127.0.0.1. That poses an inconvenience if we want to connect to the MySQL\nserver over the network. In cases like this, SSH tunneling - i.e. wrapping\nnon-SSH traffic in SSH connection can be quite useful.\n\n## SSH connection as local SOCKS proxy\n\nSSH tunneling enables us to access a single network daemon that otherwise\nwould not be reached. But what if we want to reach everything that can be\nreached from the server? In that case we can set up SSH connection as local\nSOCKS proxy with command like:\n\n    \n    \n    $ ssh -D 1080 root@64.23.163.194\n\nHere 1080 is the TCP port on local network interface we want to open as SOCKS\nproxy.\n\nBy using curl, we can verify that it works as intended:\n\n    \n    \n    $ curl -s -x socks5://localhost:1080 https://lumtest.com/myip.json | jq { \"ip\": \"64.23.163.194\", \"country\": \"US\", \"asn\": { \"asnum\": 14061, \"org_name\": \"DIGITALOCEAN-ASN\" }, \"geo\": { \"city\": \"Santa Clara\", \"region\": \"CA\", \"region_name\": \"California\", \"postal_code\": \"95054\", \"latitude\": 37.3931, \"longitude\": -121.962, \"tz\": \"America/Los_Angeles\", \"lum_city\": \"santaclara\", \"lum_region\": \"ca\" } }\n\nThis can also done via the \u201csecret\u201d SSH command line (~C) during an in-\nprogress SSH session:\n\n    \n    \n    ssh> -D 1080 Forwarding port.\n\n## SSH server behind NAT via Tor Onion Service\n\nTor is a well-known distributed system for anonymous communications that\nallows for a convenient secondary use case: NAT traversal via Onion Services.\nTypically this is done to expose a website or web app to be reachable via Tor\nBrowser, but since Tor works at TCP connection level nothing is stopping us\nfrom setting up Onion Service for some TCP-based application other than HTTP -\ni.e. we can also use it with SSH.\n\nFor example, on Debian 12 server we could do as follows.\n\nWe start by installing Tor:\n\n    \n    \n    # apt-get update # apt-get install -y tor\n\nLet us create a directory somewhere in file system to store the cryptographic\nkeys and metadata:\n\n    \n    \n    # mkdir /var/onionservice\n\nLimit the access to this directory so that only owner can fully access it:\n\n    \n    \n    # chmod 700 /var/onionservice/\n\nEdit your torrc file (on Debian it\u2019s available at /etc/tor/torrc) to add the\nfollowing directives:\n\n    \n    \n    HiddenServiceDir /var/onionservice HiddenServicePort 22 127.0.0.1:22\n\nRestart or launch the tor daemon (e.g systemctl restart tor). If all is good\nthe Onion Service directory will have some files, including the one named\nhostname:\n\n    \n    \n    # cat /var/onionservice/hostname iyqklkzlvieyehybr44yqyfqavcvhepdltumngxfje7x36ewx2li3hyd.onion\n\nNow we need to tunnel the SSH connection over Tor at client side. This can be\ndone via program named torsocks:\n\n    \n    \n    $ torsocks ssh root@iyqklkzlvieyehybr44yqyfqavcvhepdltumngxfje7x36ewx2li3hyd.onion\n\nThe caveat of this approach it that the extra latency Tor introduces can make\nthe shell work very laggy and slow. This can be particulary bad for touch\ntypers who rely on visual feedback to fix typos as they happen. A possible\nimprovement is making your Onion Service use only one hop into Tor network by\nadding the following directive into torrc:\n\n    \n    \n    HiddenServiceNonAnonymousMode 1 HiddenServiceSingleHopMode 1\n\nHowever it must be noted that this essentially removes the server hiding\naspect (which is fine if NAT traversal is all you need). This is also\nincompatible with SOCKS interface being open on Tor instance at your server.\n\nTorsocks is available via package managers on some Linux/Unix systems (e.g.\nDebian Linux, macOS).\n\n## Mounting directory subtree via sshfs\n\nSSHFS is a program that mounts a remote file system subtree to local one over\nSFTP connection. It is part of FUSE project that ships a framework for\ndeveloping custom file systems.\n\nThe following is assuming you are using Debian 12 on client side of the\nconnection.\n\nInstall sshfs via APT:\n\n    \n    \n    # apt-get update # apt-get install -y sshfs\n\nOn client side create the new directory to be used via sshfs:\n\n    \n    \n    $ mkdir /mnt/droplet\n\nTo mount a remote FS subtree via sshfs now we can run a command like:\n\n    \n    \n    $ sshfs root@209.97.131.201:/etc /mnt/droplet\n\nWhen we no longer need access to remove directory we can use umount(1) to\nunmount the directory we have created:\n\n    \n    \n    $ umount /mnt/droplet\n\nSSHFS is mostly supported on Linux. For other platforms there are some\nalternative solutions:\n\n  * macFUSE project ships it\u2019s own version of sshfs for macOS.\n  * sshfs-win is somewhat limit port of sshfs for Windows that relies on WinFsp - an equivalent of FUSE for Windows.\n\nYour mileage may vary.\n\n## Using SSH programmatically via Paramiko/Fabric\n\nParamiko is a Python module that implements SSH protocol. It provides a\nsomewhat low level API for automating SSH tasks. For example, connecting to\nremote SSH server and running a command can be done in few lines of code:\n\n    \n    \n    #!/usr/bin/python3 import sys import paramiko def main(): if len(sys.argv) != 5: print(\"{} <hostname> <username> <password> <command>\".format(sys.argv[0])) return hostname = sys.argv[1] username = sys.argv[2] password = sys.argv[3] command = sys.argv[4] client = paramiko.client.SSHClient() client.set_missing_host_key_policy(paramiko.AutoAddPolicy()) client.connect(hostname, username=username, password=password) _, stdout, _ = client.exec_command(command) output = stdout.read().decode(\"utf-8\") print(output) if __name__ == \"__main__\": main()\n\nFabric is Python module that wraps Paramiko to provide a more abstract, higher\nlevel API.\n\n# Trickster Dev\n\nCode level discussion of web scraping, gray hat automation, growth hacking and\nbounty hunting\n\nBy rl1987, 2024-02-04\n\nPowered by hugo and risotto.\n\n", "frontpage": false}
