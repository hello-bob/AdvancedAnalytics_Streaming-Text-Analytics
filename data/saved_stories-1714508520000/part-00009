{"aid": "40211205", "title": "Bytecode VMs in Surprising Places", "url": "https://dubroy.com/blog/bytecode-vms-in-surprising-places/", "domain": "dubroy.com", "votes": 59, "user": "todsacerdoti", "posted_at": "2024-04-30 14:20:08", "comments": 17, "source_title": "Bytecode VMs in surprising places", "source_text": "Bytecode VMs in surprising places\n\nPatrick Dubroy\n\n# Bytecode VMs in surprising places\n\nApril 30, 2024\n\nIn response to a question on Twitter^1, Richard Hipp wrote about why SQLite\nuses a bytecode VM for executing SQL statements.\n\nMost people probably associate bytecode VMs with general-purpose programming\nlanguages, like JavaScript or Python. But sometimes they appear in surprising\nplaces! Here are a few that I know about.\n\n## eBPF\n\nDid you know that inside the Linux kernel, there\u2019s an extension mechanism that\nincludes a bytecode interpreter and a JIT compiler?\n\nI had no idea. Well, it\u2019s called eBPF, and it\u2019s pretty interesting: a\nregister-based VM with ten general-purpose registers and over a hundred\ndifferent opcodes.\n\nThe \u201cBPF\u201d in eBPF stands for Berkeley packet filter, and the basic idea is\ndescribed in a 1993 USENIX paper:\n\n> Many versions of Unix provide facilities for user-level packet capture,\n> making possible the use of general purpose workstations for network\n> monitoring. Because network monitors run as user-level processes, packets\n> must be copied across the kernel/user-space protection boundary. This\n> copying can be minimized by deploying a kernel agent called a packet filter,\n> which discards unwanted packets as early as possible. The original Unix\n> packet filter was designed around a stack-based filter evaluator that\n> performs sub-optimally on current RISC CPUs. The BSD Packet Filter (BPF)\n> uses a new, register-based filter evaluator that is up to 20 times faster\n> than the original design.\n\nSo it was originally designed for a pretty restricted use case: a directed,\nacyclic control flow graph representing a filter function for network packets.\nAnd for a long time, the Linux implementation was equally simple: two general-\npurpose registers, a switch-style interpreter, and no backwards branches.\n\nA patch in 2011 added a JIT compiler for x86-64. In 2012, the first non-\nnetworking use case appeared. Then, in 2014, the BPF implementation was\nsubstantially extended on its way to becoming the universal in-kernel virtual\nmachine:\n\n> It expands the set of available registers from two to ten, adds a number of\n> instructions that closely match real hardware instructions, implements\n> 64-bit registers, makes it possible for BPF programs to call a (rigidly\n> controlled) set of kernel functions, and more. Internal BPF is more readily\n> compiled into fast machine code and makes it easier to hook BPF into other\n> subsystems.\n\n## DWARF expressions\n\nDWARF is a file format used by compilers like GCC and LLVM to include debug\ninformation in compiled binaries. Say you\u2019re trying to debug the following C++\ncode:\n\n    \n    \n    void add_two(int x) { int ans = x + 2; return ans + 2; // Oops! }\n\nIn a debugger, you might want to print the value of the ans variable. But\ndepending on the compiler and the code, this could be surprisingly difficult!\nIt could be in a register, on the stack, or it might have been optimized away\n(to name just a few possibilities).\n\nThe solution is allow the compiler to specify an expression that will compute\nthe value of the local variable. So the DWARF spec includes an expression\nlanguage:\n\n> 2.5 DWARF Expressions\n>\n> DWARF expressions describe how to compute a value or specify a location.\n> They are expressed in terms of DWARF operations that operate on a stack of\n> values.\n>\n> A DWARF expression is encoded as a stream of operations, each consisting of\n> an opcode followed by zero or more literal operands. The number of operands\n> is implied by the opcode.\n\nIt\u2019s up to the debugger to evaluate the expressions. GDB and LLDB both have a\nswitch-based interpreter for DWARF expressions.^2\n\n## GDB agent expressions\n\nBut it turns out that GDB has another bytecode interpreter!\n\n> Using GDB\u2019s trace and collect commands, the user can specify locations in\n> the program, and arbitrary expressions to evaluate when those locations are\n> reached.\n>\n> When GDB is debugging a remote target, the GDB agent code running on the\n> target computes the values of the expressions itself. To avoid having a full\n> symbolic expression evaluator on the agent, GDB translates expressions in\n> the source language into a simpler bytecode language, and then sends the\n> bytecode to the agent; the agent then executes the bytecode, and records the\n> values for GDB to retrieve later.\n>\n> The bytecode language is simple; there are forty-odd opcodes, the bulk of\n> which are the usual vocabulary of C operands (addition, subtraction, shifts,\n> and so on) and various sizes of literals and memory reference operations.\n> The bytecode interpreter operates strictly on machine-level values \u2014 various\n> sizes of integers and floating point numbers \u2014 and requires no information\n> about types or symbols; thus, the interpreter\u2019s internal data structures are\n> simple, and each bytecode requires only a few native machine instructions to\n> implement it. The interpreter is small, and strict limits on the memory and\n> time required to evaluate an expression are easy to determine, making it\n> suitable for use by the debugging agent in real-time applications.\n\n(From Debugging with GDB, Appendix F: The GDB Agent Expression Mechanism)\n\n## WinRAR\n\nWinRAR^3 is a file compression utility for Windows with a proprietary file\nformat. Tavis Ormandy, a vulnerability researcher at Google, discovered that\nthe RAR format includes a bytecode encoding for data transformation:\n\n> Believe it or not, RAR files can contain bytecode for a simple x86-like\n> virtual machine called the RarVM. This is designed to provide filters\n> (preprocessors) to perform some reversible transformation on input data to\n> increase redundancy, and thus improve compression.\n\nHis rarvmtools repo includes some details on the architecture:\n\n> Familiarity with x86 (and preferably intel assembly syntax) would be an\n> advantage.\n>\n> RarVM has 8 named registers, called r0 to r7. r7 is used as a stack pointer\n> for stack related operations (such as push, call, pop, etc). However, as on\n> x86, there are no restrictions on setting r7 to whatever you like, although\n> if you do something stack related it will be masked to fit within the\n> address space for the duration of that operation.\n\nSome others:\n\n  * The TrueType font specification includes a set of over 200 instructions used for glyph rendering and hinting.\n  * PostScript is not only a page description language, but a relatively powerful stack-based programming language. PostScript files are plain text, so a PostScript renderer doesn\u2019t necessarily use bytecode, but the spec also includes a binary encoding.\n\n\ud83d\udc49 Discuss on Hacker News.\n\n  1. https://twitter.com/gorilla0513/status/1784623660193677762 \u21a9\n\n  2. For LLDB, see lldb/source/Expression/DWARFExpression.cpp. For GDB, see gdb/dwarf2/expr.c. \u21a9\n\n  3. 90s kids will remember. \u21a9\n\nPssst! I'm working on a book called WebAssembly from the Ground Up. It takes\nyou from hand crafting bytecodes to writing a real compiler for a simple\nprogramming language. If you're interested in WebAssembly, you should\ndefinitely check it out.\n\n\u00a9 2006\u20132024 Patrick Dubroy \u00b7 Powered by Butterbrezn and Augustiner.\n\nSubscribe: RSS \u00b7 email\n\n", "frontpage": true}
