{"aid": "40198589", "title": "So, you want to write an unsafe crate", "url": "https://blog.dureuill.net/articles/nolife-0-4/", "domain": "dureuill.net", "votes": 2, "user": "todsacerdoti", "posted_at": "2024-04-29 14:12:19", "comments": 0, "source_title": "So, you want to write an unsafe crate", "source_text": "Naming is hard\n\nSo, you want to write an unsafe crate\n\n2024-04-29 9 minute read\n\nThese days saw the release of nolife 0.4, a crate that offers an intuitive fix\nfor borrow errors by letting you conveniently store a scope of execution\ncontaining multiple borrows inside of your struct without a lifetime. I want\nto seize this opportunity to write a bit about what goes into making a library\nthat juggles self-referential code like nolife does.\n\n## A taste of nolife\n\nnolife 0.4 allows you to turn the sad error E0597: borrowed value does not\nlive long enough:\n\n    \n    \n    use std::{fs::File, io::Read}; use zip::{read::ZipFile, ZipArchive}; pub fn zip_streamer(file_name: &str, member_name: &str) -> impl Read { let file = File::open(file_name).unwrap(); let mut archive = ZipArchive::new(file).unwrap(); let file : ZipFile<'_> = archive.by_name(member_name).unwrap(); file }\n\ninto the happily compiling:\n\n    \n    \n    use std::{fs::File, io::Read}; use zip::{read::ZipFile, ZipArchive}; pub fn zip_streamer(file_name: String, member_name: String) -> impl Read { let zip_scope = // freeze the scope in place, not closing it, and keeping the file borrowed nolife::BoxScope::new_dyn(nolife::scope!({ let file = File::open(file_name).unwrap(); let mut archive = ZipArchive::new(file).unwrap(); let mut file = archive.by_name(&member_name).unwrap(); freeze_forever!(&mut file) })); ZipStreamer { zip_scope } } struct ZipStreamer { // Store your scope without a lifetime zip_scope: nolife::BoxScope<ZipFamily>, } impl Read for ZipStreamer { fn read(&mut self, buf: &mut [u8]) -> std::io::Result<usize> { // access the file that was frozen inside of the scope and read from it self.zip_scope.enter(|zip_file| zip_file.read(buf)) } } // nolife boilerplate struct ZipFamily; impl<'a> nolife::Family<'a> for ZipFamily { type Family = ZipFile<'a>; } fn main() { let mut output = String::new(); zip_streamer( std::env::args().nth(1).unwrap(), std::env::args().nth(2).unwrap(), ) .read_to_string(&mut output) .unwrap(); println!(\"{}\", output); }\n\nThe 0.4 version brings breaking changes, most notably a new macro API that is\nmandatory for safety. Find all the changes in the changelog.\n\n## \ud83d\udc32 Thou shall face the dragons\n\nUnsafe Rust is very difficult to write correctly, so much so that I think the\nunsafe keyword could as well be replaced by the proverbial \"here be dragons\",\nyou know, for clarity.\n\nThe best way to tame these dragons is to talk to them: whenever you're using\nthe unsafe keyword in the \"oath taker\" position, you're making the promise\nthat your code verifies the preconditions stated in the documentation of items\nfor which the unsafe keyword is used in the \"oath recipient\" position. To not\nlose track of the contract, the preconditions have to be spelled out\nexplicitly at the \"oath recipient\" position and then verified explicitly at\nthe \"oath taker\" position.\n\n    \n    \n    // in <https://github.com/dureuill/nolife/blob/v0.4.0/src/raw_scope.rs> impl<T, F: ?Sized> RawScope<T, F> where T: for<'a> Family<'a>, F: Future<Output = Never>, { // \ud83d\udc47 Oath recipient position /// # Safety /// /// 1. `this` points to a properly aligned, fully initialized `RawScope<T, F>`. /// 2. `this` verifies the guarantees of `Pin` (one of its fields is pinned in this function) /// 3. No other exclusive reference to the frozen value. In particular, no concurrent calls to this function. pub(crate) unsafe fn enter<'borrow, Output, G>(this: NonNull<Self>, f: G) -> Output where G: for<'a> FnOnce(&'borrow mut <T as Family<'a>>::Family) -> Output, { todo!() } } // in <https://github.com/dureuill/nolife/blob/v0.4.0/src/box_scope.rs> impl<T, F: ?Sized> BoxScope<T, F> where T: for<'a> Family<'a>, F: Future<Output = Never>, { /// Enters the scope, making it possible to access the data frozen inside of the scope. /// /// # Panics /// /// - If the passed function panics. /// - If the underlying future panics. /// - If the underlying future awaits for a future other than the [`crate::FrozenFuture`]. pub fn enter<'borrow, Output, G>(&'borrow mut self, f: G) -> Output where G: for<'a> FnOnce(&'borrow mut <T as Family<'a>>::Family) -> Output, { // \ud83d\udc47 Oath taker position // SAFETY: // 1. `self.0` is valid as a post-condition of `new`. // 2. The object pointed to by `self.0` did not move and won't before deallocation. // 3. `BoxScope::enter` takes an exclusive reference and the reference passed to `f` cannot escape `f`. unsafe { RawScope::enter(self.0, f) } } }\n\nThe other best way to tame the dragons is to trial them with dedicated\ntooling. nolife has automated tests that run in CI that use miri to check for\nUndefined Behavior.\n\n## \ud83d\udeab\ud83d\udcdc Thou shall not compile\n\nOne trick I'm proud of for nolife is the \"counterexamples\" module. It uses the\ncode example features from rustdoc to make sure that some code examples that\nshouldn't compile, don't.\n\nHere's an example of non-compiling example:\n\n    \n    \n    //! # Attempting to save the frozen future in an async block //! //! ```compile_fail,E0767,E0267 //! use nolife::{scope, SingleFamily, TopScope}; //! fn forcing_inner_async() { //! fn some_scope(x: u32) -> impl TopScope<Family = SingleFamily<u32>> { //! scope!({ //! let fut = async { //! freeze!(&mut 0); //! }; //! // poll future //! // bang! //! panic!() //! }) //! } //! } //! ```\n\nWhen using the nightly toolchain, the specified error numbers are even\nverified, and the test fails if the compilation errors don't match.\n\n## \ud83d\udeab\ud83d\ude0b Thou shall refrain from gluttony\n\nThe API of nolife is intentionally small, it provides the minimal amount of\ncode to implement its main use cases. This is because having more API surface,\nand more implementation code creates more opportunities to introduce errors.\n\nIn time as the crate matures I'll be adding more convenience and support\nancillary use cases.\n\n## \ud83d\udeab\ud83d\udce6 Thou shall not use Box\n\nThis one is more specific to a crate that uses self-referential structures\nlike nolife.\n\nnolife's BoxScope type is an abstraction for a boxed scope, yet it doesn't use\nBox internally. This is because Box carries \"noalias\" semantics, which is\nincompatible with a self-referential structure such as BoxScope.\n\nI took the utmost care to check that any access to a variable through a\npointer would not get afoul of the borrow invalidation rules that proceed from\nthe aliasing rules.\n\nAll test cases in nolife currently pass miri with both the tree borrow and\nstacked borrow models.\n\n## \ud83c\udf08 Thou shall believe in thy friends \ud83d\udc96\n\nArmed with the commandments above, I released nolife 0.3 back in January,\ntogether with an article to announce it. Despite my best efforts at making\nnolife sound, I eventually woke up on a Saturday to find two soundness issues\nhad been filed to the issue tracker on GitHub. While #7 had a simple fix, it\nturned out that #8 basically required the new macro API (I'll let interested\nparties read the discussions in that issue).\n\n@steffahn, the contributor who opened these issues, has also been pivotal to\nresolve them.\n\n@steffahn is used to contributing to self-referential crates, with issues in\nouroboros, yoke and self_cell. More broadly, he has experience reporting\nsoundness issues to many projects in the Rust ecosystem, including Rust\nitself, qcell, or PyO3.\n\nWhen I asked him over email about his interest in self-referential crates,\nhere's what he replied:\n\n> As for my interest in self-referential crates, I love the premise of Rust's\n> safety guarantees that they are supposed to hold up even for the most\n> complex (safe!) Rust code imaginable, and I enjoy learning to understand how\n> it all fits together.\n>\n> Whenever something doesn't seem to fit my expectations, this means there's\n> either more nuance to learn in the details, or there's a soundness hole. One\n> of Rust's strengths in their safety story is that unsafe code can be used to\n> build new safe abstractions, the most general ones of which can even serve\n> de-facto as extensions to the language features, fundamentally extending\n> what's possible in safe Rust for everyone else. Self-referencing crates are\n> a prime example of this, with a lot of design space but also a lot lot lot\n> that can go wrong.\n\n@steffahn also stresses that ensuring that the crates building such safe\nabstractions are sound is a community effort. Other people are also reporting\nplenty of soundness issues, the resolution of which guarantees a rock solid\nfoundation to these libraries.\n\nIndeed, I remember people on the users.rust-lang.org forum patiently walking\nme through the leakpocalypse as I was discussing a naive prior idea for a...\nlifetime-erased reference \ud83d\ude04. That forum is a great place to actively seek a\nreview of your latest unsafe crimes, with many experienced Rustaceans kindly\ndwelling in the land \ud83e\udd80\n\nBack to @steffahn, he is now the first external contributor to nolife. I asked\nhim what he thought of nolife, here are his words:\n\n> I find it interesting because it's a take on self-referential types with an\n> API that approaches it from a direction I hadn't seen before. I'm curious\n> what kind of use-cases might emerge where this offers strong usability\n> improvements over the existing \u2013 let's say \"traditional\" \u2013 self-referencing\n> crates. It comes with high versatility by allowing execution of additional\n> code between calls to 'enter', which gives it almost a flavor of generator-\n> style framework, with a \"lending iterators\" twist; on the other hand, it's\n> harder to do certain things with it such as regaining ownership of the\n> original owned data (the owner in \"traditional\" self-referential crates) and\n> the use of a Future::poll call every time the scope is re-entered, even when\n> freeze_forever! is used, could have slight performance downsides, too, as\n> well as the need (on current Rust) for using trait objects in order to get a\n> nameable type out of it.\n\nI am very grateful to him for his dedication, it was a pleasure to work with\nhim on nolife, and I love open-source \u2764\ufe0f\n\n## Conclusion\n\nIf you want to write an unsafe crate, keep the above advice in mind. If you\nthink that's too much work, and your problem looks like the motivating example\nabove, then \ud83d\uded2 go grab nolife! It is sounder than ever, and has a brand new,\nconvenient API \u2728\n\nPublished 2024-04-29 in Programming and tagged Rust , lifetime , open source\nand nolife\n\nBack Home\n\nTheme:\n\n", "frontpage": false}
