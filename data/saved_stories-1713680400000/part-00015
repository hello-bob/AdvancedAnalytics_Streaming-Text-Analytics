{"aid": "40100586", "title": "Some features about JavaScript's AbortSignal I learned today", "url": "https://codedrivendevelopment.com/posts/everything-about-abort-signal-timeout", "domain": "codedrivendevelopment.com", "votes": 2, "user": "codedrivendev", "posted_at": "2024-04-20 20:08:37", "comments": 0, "source_title": "Everything about the AbortSignals (timeouts, combining signals, and how to use it with window.fetch)", "source_text": "Everything about the AbortSignals (timeouts, combining signals, and how to use it with window.fetch) | Code Driven Development\n\n## Everything about the AbortSignals (timeouts, combining signals, and how to\nuse it with window.fetch)\n\nPosted 2024-04-20\n\n#javascript\n\nIf you use plain old window.fetch() to make your HTTP requests, sometimes you\nwill want to timeout the request after a few seconds.\n\nFor the last few years I've made use of AbortController and manually trigger\nan AbortSignal.\n\nBut I learned today there are a few more advanced things you can do with these\nsignals.\n\nI'm going to cover:\n\n  * How to use AbortController (seen this in many projects - you are probably familiar)\n  * How to use automatic AbortSignal.timeout() (I wasn't aware of it until today)\n  * How to combine multiple aborts with AbortSignal.any() - something else I learned today\n\n#### Table of contents\n\n  * Easier way to automatically terminate a fetch request with AbortSignal.timeout()\n  * Combining multiple abort signals\n  * Handling when a signal is aborted\n  * Checking if a signal was already aborted with throwIfAborted()\n  * Getting why a signal was aborted with .reason\n\nThis is how you would typically use an AbortController (to get an AbortSignal)\nand pass it to fetch() options so you can terminate the request:\n\n    \n    \n    abort-controller-demo.js\n    \n    \u2705 copied\n    \n    const controller = new AbortController(); const timeout = 5000; // 5 seconds setTimeout(() => controller.abort(`custom timeout abort`), timeout); const response = window.fetch('/your-api', { signal: controller.signal, });\n\nThis will throw if the request takes more than 5 seconds if you await the\nfetch promise.\n\n    \n    \n    abort-controller-fetch-demo.js\n    \n    \u2705 copied\n    \n    const controller = new AbortController(); const timeout = 5000; // 5 seconds setTimeout(() => controller.abort(`custom timeout abort`), timeout); // this will throw here if it takes more than 5 seconds const response = await window.fetch('/your-api', { signal: controller.signal, });\n\nIf you catch it in a try/catch block, the error will be whatever you passed to\ncontroller.abort(...) - in my example it is a string.\n\nIf you do not provide a value for controller.abort() then a DOMExceptionError\nis thrown (with error.name === 'AbortError')\n\n## Easier way to automatically terminate a fetch request with\nAbortSignal.timeout()\n\nIf you don't need much in terms of flexibility, and want a simple timeout\nafter a time period (like my previous example) then there is a shortcut.\n\nI wasn't aware of this until today (and it sounds like on twitter there are\nquite a few people just learning about this).\n\nYou can use AbortSignal.timeout(500) to automatically create the abort signal\nwhich will abort after that duration (Without the boilerplate of using\nAbortController).\n\nExample of how it is used:\n\n    \n    \n    window.fetch(apiUrlWithCacheBusting(), { signal: AbortSignal.timeout(abortTimeout), })\n\nThis will throw a DOMExceptionError (with error.name === 'TimeoutError').\n\n## Combining multiple abort signals\n\nSometimes you might want multiple reasons for aborting a request. Luckily\nthere is a static method on AbortSignal to help you combine multiple signals.\n\nLet's say you have a system where you want to abort the fetch request if:\n\n  * 30 seconds has gone\n  * or the user clicked a button to cancel the download\n\nYou can do this easily with two separate abort signals and combine them with\nAbortSignal.any()\n\nHere is a demo:\n\n    \n    \n    demo.tsx\n    \n    \u2705 copied\n    \n    const [userCancelledController, setUserCancelledController] = useState<AbortController>() async function makeApiCall() { const controller = new AbortController setUserCancelledController(controller) // so we can call .abort() on it elsewhere const timeoutSignal = AbortSignal.timeout(5000); window.fetch(apiUrlWithCacheBusting(), { signal: AbortSignal.any( [ timeoutSignal, // after 5000 ms controller.signal // or if user clicks cancel button ] )}).catch(console.error) } return <> <button onClick={() => userCancelledController?.abort()}>Manual abort!</button> <button onClick={makeApiCall}> Fetch with automatic timeout abort </button> </>\n\n## Handling when a signal is aborted\n\nOk so now you can easily abort a fetch request... but we would often want to\ntell the user that their request was cancelled.\n\nLuckily you can do this with event handlers. You can use an event handler on\nthe AbortSignal to handle when it gets aborted.\n\n(Of course, if you manually use setTimeout(() => controller.abort()) then you\ncan handle that logic there too. This is for more advanced uses)\n\nHere is an example, so we can update state in react when a signal is aborted.\nThis is using .any but you could apply this to any signal.\n\n    \n    \n    on-abort-event.ts\n    \n    \u2705 copied\n    \n    const userCancelledController = new AbortController const timeoutSignal = AbortSignal.timeout(abortTimeout); // this is the relevant part: const signal = AbortSignal.any([timeoutSignal, userCancelledController.signal]) signal.addEventListener('abort', () => { console.log(\"Aborted\") }) window.fetch( '/your-api', {signal} ).catch(console.error)\n\nOne thing to be aware of is you can easily get into memory leaks if you are\napplying this pattern.\n\n## Checking if a signal was already aborted with throwIfAborted()\n\nI've never used this in production code, but one thing you might find useful\nis throwIfAborted().\n\nI think this is less useful for fetch() requests and maybe more useful for\njust generally working with AbortSignal\n\nYou can use it to throw an error if a signal is already aborted. (You could\nprobably have guessed that from the name of it). I'll show a demo:\n\n    \n    \n    throwIfAborted.tsx\n    \n    \u2705 copied\n    \n    async function waitForCondition(func, targetValue, { signal } = {}) { while (true) { signal?.throwIfAborted(); const result = await func(); if (result === targetValue) { return; } } }\n\n## Getting why a signal was aborted with .reason\n\nSo far all my examples have caught errors from the awaited fetch() response,\nwhich included the abort error in the catch block.\n\nBut if you have an AbortSignal which was aborted, you can find out what was\npassed to abort(...) with signal.reason.\n\n    \n    \n    abort-reason.ts\n    \n    \u2705 copied\n    \n    const controller = new AbortController(); const signal = controller.signal; if (signal.aborted) { if (signal.reason) { console.log(`Request aborted with reason: ${signal.reason}`); } else { console.log(\"Request aborted but no reason was given.\"); } } else { console.log(\"Request not aborted\"); }\n\n## See more\n\n  * sample code showing how to use it\n  * AbortSignal on MDN\n  * hat tip to Kent C Dodds and Guilherme\n\n## Subscribe to my Full Stack Typescript Developer newsletter\n\nIf you enjoyed my content and want more Full Stack Typescript content, then\nenter your email below.\n\nI send a few links every couple of weeks, that I personally found useful from\naround the web.\n\nFocusing on Javascript, Typescript, NextJS, and also engineering soft skills\nposts.\n\n#### Table of contents\n\n  * Easier way to automatically terminate a fetch request with AbortSignal.timeout()\n  * Combining multiple abort signals\n  * Handling when a signal is aborted\n  * Checking if a signal was already aborted with throwIfAborted()\n  * Getting why a signal was aborted with .reason\n\nWelcome to my site and blog - Code Driven Development.\n\nThis is where I dive topics relating to modern software engineering - with a\nfocus on Typescript, React, web accessibility and Agile practices\n\nI pick topics that I think are interesting, that I think others might find\ninteresting, or write up guides that I wish I had read before learning a\ntopic.\n\n##### Twitter / X\n\n@CodeDrivenDev\n\n##### Youtube\n\n@CodeDrivenDevelopment\n\n### Testing\n\n  * TDD for Frontend Engineers\n\n### General\n\n  * Useful sites for Javascript devs\n  * Why Sprint retrospectives are important\n\n### Engineering\n\n  * Guide to good Pull Requests\n  * Naming things is hard\n\n### Accessibility\n\n  * Introduction guide to accessibility\n  * Inclusive design\n\n### Frontend\n\n  * Frontend embedding by major payment providers\n  * Advanced Next.JS Features\n  * Useful FE tools\n\n\u00a9 2022-2023. Content is for informational purposes only. No guarantee of\naccuracy or completeness. Use at your own risk. CodeDrivenDevelopment.com is\nnot liable for any losses or damages. Legal information Nothing is AI written\n(except some images are generated). Sitemap\n\n", "frontpage": false}
