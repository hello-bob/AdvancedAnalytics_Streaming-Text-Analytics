{"aid": "40131155", "title": "I built a SaaS in 24 hours", "url": "https://matthew.science/posts/focusguardian/", "domain": "matthew.science", "votes": 2, "user": "sodality2", "posted_at": "2024-04-23 12:27:52", "comments": 0, "source_title": "Building FocusGuardian, my TribeHacks IX submission, in 24 hours", "source_text": "I built a SaaS in 24 hours\n\nMatt's Blog\n\n# I built a SaaS in 24 hours\n\ncreated on 2024-04-23\n\nThis weekend, I participated in TribeHacks IX at my university, William &\nMary.\n\nMy submission, FocusGuardian, is a service that allows you to define rules\nthat will block any service you choose. Are you a chronic late night scroller?\nBlock Instagram and TikTok after 10PM. Are you guilty of checking Hacker News\nconstantly during your classes or at work? Block it M-F, 9-5.\n\nSince it's DNS based, it can be blocked at any time, on all of your devices,\nand will truly act as a network block. The reason why I built this instead of\nusing existing solutions like Apple's Screen Time or Opal, or browser\nextensions, are as follows:\n\n  * I need something that works across all of my devices, as I am just as likely to consume on my laptop as I am my phone\n  * I need something that can't be easily bypassed. At this point, I have been trained to bypass Apple's Screen Time prompts by clicking \"ignore\" every day, it's almost muscle memory. So I want something that won't stop me from opening the app but rather break its functionality, so I'm more aware of the block.\n\nThe possibility of scheduling the blocks also serves to put myself in a\nroutine - if I know I will have an hour of social media at the end of the day,\nI won't constantly check it throughout the day. In my experience that's better\nthan just limiting it to one hour for the whole day, because I could quickly\nburn through it, and there's no schedule I'm forcing myself into.\n\n## Inspiration\n\nI thought to myself, what if I just program a DNS server to do this? That\nsounds like it'd work - just return a 0.0.0.0 response if it needs to be\nblocked. I could parse some rules to decide live whether a DNS request should\nbe permitted or blocked, then just pass it up to a recursive DNS resolver if\nit's allowed.\n\nI would need to make it DNS over HTTPS, though - I could NOT buy an IPV4\naddress for every user, so DNS over UDP and TLS were out of the question. DoH,\nhowever, allows you to set whatever path you want for the query, meaning you\ncould make the endpoint https://dns.focusguardian.org/USER_ID/dns-query, and\nit would be specific to one user's rules and schedules.\n\n## Selling Points\n\nMy idea distinguishes itself from existing solutions by addressing some\nlimitations and offering unique features:\n\n  * Cross-Device Compatibility: Unlike some existing solutions such as Apple's Screen Time or browser extensions, FocusGuardian operates seamlessly across all devices, including laptops, smartphones, and tablets. This ensures consistent distraction-blocking functionality regardless of the device being used.\n  * Enhanced Blocking Mechanism: Traditional solutions often rely on prompts or restrictions that users can easily bypass. In contrast, FocusGuardian employs a DNS-based blocking mechanism that effectively prevents access to specified services.\n  * Flexible Scheduling: By allowing users to schedule distraction-blocking rules based on specific times and days, FocusGuardian promotes the establishment of healthy digital habits. This flexibility enables users to tailor their usage restrictions to their individual routines and preferences, ultimately fostering more productive and balanced lifestyles.\n\nI'm not sure how differentiated I am in reality from the existing market (such\nas Opal), but hey, I spent my 24 hours coding, not doing market analysis. :)\n\n## Frontend\n\nSo, I got started! I whipped up a Vue/Vite/TailWind frontend in a few hours,\nwith tabs for information on how this can be beneficial to parents, students,\netc. I'm NOT a frontend developer (last year, my hackathon submission was\nhand-written HTML fragments being returned by a Rust backend and it looked...\nsubpar). But, in the past year, I've been building Vue frontends for side\nprojects, and I'd like to say I'm passable by now.\n\nI wanted a landing page to be done first, since that's what gets looked at for\nthe hackathon. For my own sake I spent the vast majority of my time on working\non the actual functionality but making it look pretty is really what gets you\npoints.\n\n## Backend\n\nNext - the backend. I started writing writing some sample code that parsed DNS\nover HTTPS requests in Rust. I was nose-deep in the RFC and implementing the\ntwo possible methods that could be used. At first, I simply proxied to Quad9's\nDoH endpoint, but that quickly proved too slow - it adds the entire latency of\nanother HTTPS request. I switched to a local resolver issued over UDP.\n\nI tried adding the DoH configuration to Firefox to test, and success! I could\nsee the requests being proxied and Firefox worked as expected.\n\n#### Apple cannot adhere to spec, ever.\n\nI used this site to generate a DoH profile for my phone. But alas, even when\nmy DNS resolver follows spec, Apple does not work. You need to add support for\nPOST/GET requests, where GET requests could have a dns parameter or a name and\ntype parameter - where dns is a base64-encoded DNS packet, or name is a domain\nand type is a DNS packet type. This involves manually constructing a DNS\npacket if they decided to send it as the latter case.\n\nMaybe I was just sleep deprived at the time but this implies Apple doesn't\nadhere to the DoH spec. That's okay, I handled that case and Apple was working\nperfectly!\n\nNow to write some of the actual rule/scheduling/user code.\n\n## User database\n\nI have used Pocketbase in the past - it's an absolutely magical self-hosted\nFOSS Firebase alternative. It handles user authentication, OAuth (sign in with\nall the services), tables with auth rules, etc. I was able to very quickly get\nstarted with it, by using two tables - manual vs scheduled rules - each one\nassociated with a user and list of services.\n\nI modified the Rust backend to grab from the database periodically, then parse\nthe list of schedules/services into a database. The backend then would first\ncheck on any DNS requests if the user has an active rule for that service. If\nso, it would modify the returned IP to be 0.0.0.0 (this is generally the\nagreed-upon way - NXDOMAIN responses could have the OS use a backup DNS server\nwhich would be bad).\n\n### Service list\n\nI didn't want to manually collect a long list of services and their associated\nlist of domains, but I had remembered that the AdGuard Home server I run does\nhave the option of blocking services, so they must have a list of these\nservices and domain names associated with each one. And indeed, they do!\nBuried in the source code is a list - so I had my code parse that and build a\nlist of services supported for my website. (I manually added Hacker News since\nit wasn't there and that's my worst procrastination tool)\n\n## Frontend pt 2\n\nNow, to write code that will allow me to add rules on the fly.\n\nAfter a lot of searching about Vue forms, I finally have a component to add\nrules! After integrating with PocketBase, it's as easy as:\n\n    \n    \n    await pb.collection(\"scheduled_rules\").create(bodyParams)\n\nI wrote some code to handle the case where the rule isn't scheduled but rather\nmanual, and we were off to the races.\n\n## Mobile App\n\nUpon making the desktop site, I realized: I was definitely not good at making\nresponsive Vue sites. The create rule component notably was extremely poor\nwhen viewed on mobile. I researched some solutions for creating mobile apps in\na cross-platform manner and found the Ionic Framework which served me very\nwell. I got a simple proof of concept working quickly, and it looked decent.\n\nAt this point, I had a working website, a demo mobile app written in Ionic,\nand instructions on how to add FocusGuardian for every common platform\n(Windows, Mac OS, Linux, Firefox, Chrome, iOS, iPad OS, etc). But, this wasn't\ncool enough. For those manual rules, is it really the best decision to have to\nopen your computer to visit the site to enable it? I wanted a hardware\nsolution that would allow me to enable/disable my rules without using a\nbrowser.\n\n## Hardware prototype\n\nI had so many old pieces of hardware laying around, from ESP32s and RPi Zeros.\nNone of those would be enough for a consumer-facing prototype, but I had one\nsecret weapon - a LilyGo T-QT.\n\nThis bad boy is incredibly small, yet has buttons and a screen! That's all you\nneed, really. Can we go back to the blackberry's now?\n\nSo, I got to coding - Surely I could learn LVGL in the 12 hours left.\n\nI began by simply modifying the sample program, a duck waddling gif, and added\n\"text\". That worked okay.\n\nNow, to mock rendering the rules. We will write code to actually parse from\nthe database, but below, I will fake it.\n\n    \n    \n    static char* rules[] = {\"instagram\", \"hn\"}; static bool* enabled[] = {false, true}; static int current_rule = 0; static int max_rule = 1; // In refresh_debug lv_obj_t *debug_label = lv_label_create(src); String text; text = \"Rules\\n\"; for (int i = 0; i < max_rule; i++) { if (i == current_rule) { text += \"> \"; } else { text += \" \"; } text += '['; if (enabled[i]) { text += \"X\"; } else { text += \" \"; // no monospace fonts, sorry! } text += \"] \"; text += rules[i]; text += \"\\n\"; } lv_label_set_text(debug_label, text.c_str()); lv_obj_align(debug_label, LV_ALIGN_TOP_LEFT, 0, 0); // If the toggle button is pressed if (enabled[current_rule]) { enabled[current_rule] = true; } else { enabled[current_rule] = false; } refresh_debug(); // If the scroll button is pressed current_rule = (current_rule + 1) % max_rule;\n\nThis was pretty good! I could simulate \"scrolling through\" the rules (updating\nwhere the > character was) with the right button, and use the left button to\ntoggle the currently selected rule. Now for actually integrating with the\ndatabase.\n\n### HTTPS on the ESP32\n\nGetting HTTPS working on the ESP32 was really the most difficult part of this\nproject. I ended up simply disabling TLS certificate validation. It's still\nencrypted, but anyone who can control the connection could MITM by presenting\nany TLS certificate. Unfortunate, and obviously not ideal, but this will be\njust fine for my one-day-long hackathon. I'm well aware of the security\nimplications, and will be iterating on this to find the best solution if I\nbring this to fruition.\n\n### Parsing\n\nJSON parsing was pretty easy - I mostly just used the ArduinoJson library. It\nbecame pretty easy to parse responses into the global rules array (once I\nswitched to using Strings!).\n\n### Demoing the hardware\n\nApproximately 10 minutes before the deadline, I filmed my demo for the\nproject, including the hardware.\n\n## Summary of my tech stack\n\n  * Rust-based DNS backend (handles processing DNS requests, keeping up-to-date with newly created rules, and generating Apple MobileConfigs)\n  * Vue-based frontend\n  * Ionic-based mobile app demo (still being worked on)\n  * Go-based user database (PocketBase + custom Go)\n  * C++-based software on the embedded hardware\n\nJuggling it all had me accidentally writing Rusty let x in JavaScript, C++'y\nconst * in Go, etc. I don't think this stack is too much; it fulfills my needs\nat exactly the right complexity, and none of it seems over- or under-\nengineered for my needs. But just having 24 hours of switching between all of\nthem to become proficient enough to get out a fully-working prototype hurt my\nhead a lot.\n\n## Reviews of my tech stack\n\n  * Rust: 10/10. I'm very experienced in Rust, so I'm biased and well over the learning curve for a simple project like this. Rust's performance-strong characteristics reassure me I didn't leave any performance on the table by not choosing another language.\n  * Vue: 9/10. Really good dev experience, plenty of libraries for most of the things I wanted to do.\n  * Ionic: 7.8/10. Pretty good, though I didn't get this working in time, I could easily freshen it up in a weekend.\n  * PocketBase/Go: 10/10. PocketBase makes it incredibly easy to turn a proof of concept web app into a SaaS while saving me from all of the pain of user authentication, OAuth, databases, etc.\n\n    * MailPace for transactional emails: 10/10, awesome and dead-simple to integrate with Pocketbase for all of the sign-up/reset emails (and I wrote the Rust library for it, so if I need to email from the backend, I can do so easily!).\n  * C++: 5/10. I have experience working with ESP32 as a platform but it was my first time learning LVGL. Definitely harder to pick up and start hacking with, but I also was down to a few hours. Maybe I disliked it more because I was closer to the deadline when I started working on it?\n\n## Results\n\nThe results of this hackathon were three-fold.\n\n  * I was very happy to find I could bang out a functional, ready-for-launch SaaS in 24 hours, that could expand into B2C hardware (irrespective of how good the idea is - truthfully I am unsure about demand, so this was more of a technical challenge)\n  * I was doubly happy to get the hardware working - I want to work on a proper first iteration, on a larger device, and get all of the kinks out.\n  * I won best hardware hack!\n\nAll in all, a very fun experience!\n\n# What's next for FocusGuardian\n\nI am launching FocusGuardian as a fully featured SaaS today, in a pilot\nprogram.\n\nUntil June/July, I won't add any code that checks for premium status - so if\nyou want to try out how premium feels, you may sign up and utilize those\nunlimited rules and ad-blocking without paying.\n\nBut if you want to help me recoup some of the costs of the server, domain,\nhardware, the Celsius's consumed while being built, etc, and feel like you get\nenough value from it, feel free to click upgrade on the pricing page.\n\nFree plan allows for two scheduled rules, and two manual rules. As well as\nunlimited DNS requests/devices/etc.\n\nPaid plan allows unlimited rules, ad blocking, requesting additional services\nfor blocking, and first access to a hardware client, should I turn that into a\nfull project (provided interest is there).\n\nI'm starting out the paid plan at $5/mo, $55/yr (with a discount to $2.50/mo,\n$27.50/yr - see pricing page).\n\n## Feedback\n\nIf you have feedback about absolutely anything, send me an email at admin @\nthe domain (either one). Do you think you'd be interested in paying for a\nproduct like this eventually? Or would you use the hardware solution? I would\ngreatly appreciate if you signed up today and started using it, and providing\nfeedback!\n\nSend me a letter!\n\nYou can visit FocusGuardian here!\n\n", "frontpage": false}
