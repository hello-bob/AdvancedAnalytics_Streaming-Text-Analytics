{"aid": "40080409", "title": "Ruff v0.4.0: a hand-written recursive descent parser for Python", "url": "https://astral.sh/blog/ruff-v0.4.0", "domain": "astral.sh", "votes": 1, "user": "todsacerdoti", "posted_at": "2024-04-18 20:31:19", "comments": 0, "source_title": "Ruff v0.4.0: a hand-written recursive descent parser for Python", "source_text": "Ruff v0.4.0: a hand-written recursive descent parser for Python\n\nGet Started\n\nG\n\nBack to blog\n\nApril 18, 2024\n\n##### Dhruv Manilawala\n\n@dhruvmanila\n\nRuff v0.4.0 is available now! Install it from PyPI, or your package manager of\nchoice:\n\n    \n    \n    pip install --upgrade ruff\n\nRuff is an extremely fast Python linter and formatter, written in Rust. Ruff\ncan be used to replace Black, Flake8 (plus dozens of plugins), isort,\npydocstyle, pyupgrade, and more, all while executing tens or hundreds of times\nfaster than any individual tool.\n\nThis release marks an important milestone in Ruff\u2019s development as we switch\nfrom a generated to a hand-written recursive descent parser.\n\nRuff's new parser is >2x faster, which translates to a 20-40% speedup for all\nlinting and formatting invocations.\n\nRepository| Linter (v0.3)| Linter (v0.4)| Formatter (v0.3)| Formatter (v0.4)  \n---|---|---|---|---  \nhome-assistant/core| 449.9| 364.1| 381.9| 307.8  \npytorch/pytorch| 328.7| 251.8| 351.1| 274.9  \npython/cpython| 134.6| 94.4| 180.2| 138.3  \nhuggingface/transformers| 198.5| 143.6| 239.0| 184.1  \n  \nTime in milliseconds to lint and format popular repositories. Lower is better.\n\nA hand-written parser also opens the door to future optimizations and\nimprovements, especially in error recovery.\n\nRead on for discussion of the major changes, or take a look at the changelog.\n\n## A hand-written parser #\n\nParsers form the foundational layer of any static analysis tool, transforming\nraw source code into Abstract Syntax Trees (ASTs), which serve as the basis\nfor analysis.\n\nRuff v0.4.0 introduces a hand-written recursive descent parser, replacing the\nexisting generated parser.\n\nThe difference between the two lies in how they are implemented:\n\n  * A generated parser is created using a tool called a parser generator (in our case, LALRPOP). Typically, a parser generator requires that the grammar is defined in a Domain Specific Language (DSL), which is then converted into executable code by the generator. In our case, rules were defined in a .lalrpop file, which LALRPOP converted into Rust code.\n\n  * On the other hand, a hand-written parser involves encoding the parsing rules directly in Rust code, using functions to define the parsing logic for individual nodes.\n\nOn initial release, Ruff used the Python parser from the RustPython project.\nAs Ruff evolved, we learned that a Python interpreter and linter have\ndifferent needs, and the ideal AST for those two use cases can look pretty\ndifferent. Ultimately, we pulled the parser into Ruff and maintained it\nseparately as we evolved our AST structure.\n\nEnter Victor Hugo Gomes, a contributor to the Ruff project who opened a pull\nrequest to introduce a hand-written recursive descent parser. It was an\nambitious proposal, but one that made a lot of sense for Ruff's future, given\nthat...\n\n  1. We were already maintaining the parser separately from RustPython.\n  2. We had a clear understanding of the AST structure we needed.\n  3. Victor had already demonstrated that the hand-written parser would significantly outperform the generated parser.\n  4. The generated parser, ironically, had become harder to maintain. Parser generators come with limitations around the grammars that they can support, and we'd already found ourselves fighting LALRPOP to support the latest Python syntax.\n  5. A hand-written parser would give us more control over error handling and recovery, which is especially important for building editor-friendly tools, which need to be resilient to syntax errors.\n\nFrom there, we worked closely with Victor to integrate the parser into Ruff\nand add support for the latest Python syntax. Once the parser was fully\ncompliant with Ruff's own test suite, we spent a few months testing and\nvalidating its accuracy and reliability across millions of lines of real-world\nPython code and fuzzer-generated inputs.\n\n### Advantages #\n\nIn line with our initial motivations, the introduction of a recursive descent\nparser brings several benefits over the generated parser.\n\n#### Control and Flexibility #\n\nA hand-written parser has complete control over the parsing process which\nallows for greater flexibility in handling edge cases. For example,\nparenthesized with items in Python introduce a syntactic ambiguity regarding\nwhich node the opening parenthesis \"belongs\" to:\n\n    \n    \n    # Parenthesis belongs to the `with` item with (item): ... # ^^^^^^ with item # Parenthesis belongs to the context expression which is part of the `with` item with (item) as var: ... # ^^^^^^ context expression # ^^^^^^^^^^^^^ with item\n\nEncoding this ambiguity in a generated parser can be challenging, while a\nhand-written parser gives you the flexibility you need to handle such cases.\n\n#### Performance #\n\nThe hand-written parser is significantly faster. Optimizing the parser\ngenerator was difficult, since we had minimal control over the generated code\nand few opportunities to take advantage of domain-specific knowledge around\nhot paths and cold paths, and other properties of the data. While we could\noptimize our hand-written lexer, the parser remained a black box.\n\nBenchmark| LALRPOP parser| Hand-written parser| Change  \n---|---|---|---  \n\u26a1| parser[large/dataset.py]| 63.6 ms| 26.6 ms| \u00d72.4  \n\u26a1| parser[numpy/ctypeslib.py]| 10.8 ms| 5 ms| \u00d72.2  \n\u26a1| parser[numpy/globals.py]| 964.6 \u03bcs| 424.9 \u03bcs| \u00d72.3  \n\u26a1| parser[pydantic/types.py]| 24.4 ms| 10.9 ms| \u00d72.2  \n\u26a1| parser[unicode/pypinyin.py]| 3.8 ms| 1.7 ms| \u00d72.2  \n  \nMicro-benchmark comparison between the two parsers.\n\nRuff's hand-written parser is >2x faster than the generated parser, which\ntranslates to a 20-40% speedup for all linting and formatting invocations.\n\n#### Error handling #\n\nWith a hand-written parser, we can now provide better error messages on\nencountering a syntax error, as seen in the following examples:\n\n    \n    \n    --- a/ruff/parser/old_error_messages +++ b/ruff/parser/new_error_messages | 1 | from x import - | ^ SyntaxError: Unexpected token Newline + | ^ SyntaxError: Expected one or more symbol names after import | 1 | async while test: ... - | ^ SyntaxError: Unexpected token 'while' + | ^ SyntaxError: Expected 'def', 'with' or 'for' to follow 'async', found 'while' | | 1 | a; if b: pass; b - | ^ SyntaxError: Unexpected token 'if' + | ^ SyntaxError: Compound statements are not allowed on the same line as simple statements | | 1 | with (item1, item2), item3,: ... - | ^ SyntaxError: Unexpected token ':' + | ^ SyntaxError: Trailing comma not allowed | | 1 | x = *a and b - | ^ SyntaxError: Unexpected token 'and' + | ^ SyntaxError: Boolean expression cannot be used here |\n\n#### Error resilience #\n\nFor many of our users, Ruff is a tool that lives in the editor, and in the\neditor, it's common to have syntax errors, even temporarily. Imagine, for\nexample, that you're in the midst of defining a new function. You've typed out\nthe def func (x):, but haven't filled in the function body. While your code is\nnot syntactically valid, you'd still like to see linting and formatting\ndiagnostics for the rest of the file.\n\nA hand-written parser enables us to support error recovery, and thereby build\nerror resilience into Ruff. That is, Ruff's parser can recover from syntax\nerrors in the source code and continue parsing despite the interruption.\n\nWhat does this look like in an editor? Imagine you've made multiple syntax\nerrors in your code, as shown below:\n\n    \n    \n    import os # unused-import (F401) def fibonacci(n): \"\"\"Compute the nth number in the Fibonacci sequence.\"\"\" x = 1 # unused-variable (F841) if n in (0, 1) # ^ SyntaxError: Expected ':', found newline return n else: return fibonacci(n - 1) + fibonacci(n - 2) if __name__ == \"__main__\": import sys 1 = int(sys.argv[1]) # ^ SyntaxError: Invalid assignment target print(fibonacci(n)) # undefined-name (F821)\n\nWith an error-resilient parser, Ruff can continue to analyze the code even\nafter encountering the above syntax errors, which then allows the linter to\nprovide and even fix diagnostics in a single run.\n\nWhile Ruff does not yet exhibit this error-resilient behavior, the hand-\nwritten parser lays the foundation for it, which we plan to implement in\nfuture releases.\n\n### What's next #\n\nLooking ahead, we aim to further improve Ruff's parsing capabilities with the\nfollowing objectives:\n\n  * Complete error recovery: Ensure that the parser recovers from all syntax errors, providing developers with an uninterrupted experience in the editor.\n  * Reporting all syntax errors: Display all syntax errors encountered during parsing, providing developers with a complete overview of the issues in their code.\n  * Continuous analysis: Allow the linter to proceed with analysis even in the presence of syntax errors.\n\nUltimately, our goal is to enable a first-class editor experience for Ruff by\nmaking it both faster and, critically, resilient to syntax errors.\n\n## Thank you! #\n\nFinally, we'd like to acknowledge the RustPython project for enabling us to\nleverage their Python parser. The RustPython parser was a significant enabler\nto Ruff's early development, and we're grateful for the opportunity to\ncollaborate and build on their work.\n\nWe'd also like to thank Victor Hugo Gomes, for initiating the transition to a\nhand-written parser and all the work that went into making it Ruff-compliant;\nand Addison Crump, for contributing the fuzzer that we leveraged to validate\nthe new parser.\n\nView the full changelog on GitHub.\n\nRead more about Astral \u2014 the company behind Ruff.\n\n## Supercharge your Python tooling\n\nGet Started\n\nBrowse Docs\n\n  * Ruffv0.4.0\n  * uvv0.1.33\n  * Docs\n  * Blog\n  * Company\n  * Hiring\n\n\u00a9 2024 Astral Software Inc.\n\n", "frontpage": false}
