{"aid": "40280530", "title": "What is so unique about Unison?", "url": "https://etorreborre.blog/what-is-so-unique-about-unison", "domain": "etorreborre.blog", "votes": 1, "user": "beefman", "posted_at": "2024-05-06 23:10:35", "comments": 0, "source_title": "What is so unique about Unison?", "source_text": "What is so unique about Unison?\n\n#\n\nGalaxy brain\n\n# Galaxy brain\n\n# What is so unique about Unison?\n\nEric Torreborre\n\n\u00b7May 4, 2024\u00b7\n\n14 min read\n\n## Table of contents\n\n  * First steps\n\n    * Search by type\n\n    * Add a function to the project\n\n    * Run and test my code\n\n    * Some feedback from my first steps\n\n  * My first library\n\n    * Documentation is first class\n\n    * Less attention to files = more focus\n\n    * Less attention to files = more normalization\n\n    * Todo\n\n    * Testing\n\n    * Publishing the library\n\n    * Some question marks\n\n      * Namespaces\n\n      * Privacy\n\n      * No typeclasses\n\n      * Large refactorings\n\n  * My first contributions\n\n  * Conclusion\n\nI have recently started exploring the Unison programming language. Some\nprogramming languages are good because they improve the current state of\naffairs. For example Gleam brings type-safety to the Erlang platform. Other\nlanguages are game-changers:\n\n  * When Scala was introduced, it brought an incredible amount of (statically-typed) functional programming features to the JVM. This changed the way we approached mutability, error management, concurrency, and structured our programs.\n\n  * Verse unifies functional-programming and logical programming, where notions of failure, multiple-valued variables, and transactions, are baked into the language. This changes the way we think about control flow.\n\n  * Unison is a frictionless language. It builds on the idea of \"immutable code\" to give us a huge productivity boost for writing cloud applications.\n\nIn this post, I am sharing my first steps with Unison. The parts where I was\ndelighted but also the parts where I was confused. I will only talk about my\nexperience of developing a small library for now. Part 2 will be about\ndeveloping a full cloud application for my own needs.\n\n# First steps\n\nI didn't need much to get started with Unison:\n\n  * An executable called the Unison Code Manager (ucm for short). It is available as a nix package, so it was very easy for me to install it with flox.\n\n  * VS Code with the Unison plugin.\n\nI then created a quickstart project with project.create quickstart using ucm.\nWith this project, I was all setup for coding. Here is a simple hello\nfunction:\n\nThe first unusual thing with unison is that files don't matter. A convenient\nsetup for your editor is a split screen as above with just one file on the\nleft, and ucm on the right. Where is my code then? It is in a database:\n\n    \n    \n    ll $HOME/.unison/v2 Permissions Size User Date Modified Name .rw-r--r--@ 0 etorreborre 14 Apr 12:48 unison.lockfile .rw-r--r--@ 13M etorreborre 14 Apr 12:55 unison.sqlite3\n\nThen, I went through the Unison language tour and learned how to:\n\n  * Search for functions: by name, but also by type!\n\n  * Create new functions and add them to my codebase.\n\n  * Test my code by either running it or writing tests.\n\nNot impressed? Let's have a closer look!\n\n### Search by type\n\nHaskell users know the benefits of a tool like Hoogle. With such a tool, you\ncan search functions by type. This is soooooo convenient! \"How do I serialize\nText to Bytes?\". Just type find : Text -> Bytes and ucm returns all the\nfunctions with that signature:\n\n    \n    \n    1. lib.base.Text.toUtf8 : Text -> Bytes 2. lib.base.IO.net.URI.Path.encode.segment : Text -> Bytes\n\nThis even works when there are type parameters (Hoogle is better though\nbecause it will also show you functions where the order of parameters is\nslightly different).\n\n### Add a function to the project\n\nOnce a function typechecks, you can add it to your project, or update it, if\nwas added before. This has profound implications:\n\n  * All the code added to your project always compiles. If an updated definition conflicts with the previous version, then all the conflicting code is brought up to be fixed.\n\n  * Adding a function to your project is also the equivalent of committing it. No more git add .; git commit -m \"add some code\". Later on, sharing the code with others is just a matter of running push.\n\n  * Codebase changes can be reversed by using the reflog, as you would do with git.\n\n  * The project knows about functions, not just text. This means that:\n\n    * You can easily rename a function.\n\n    * You can give several aliases to the same function. Internally, a function is identified by the hash of its contents.\n\n    * You can create patches that are selectively applied to part of the code, so that the result still typechecks (I haven't played too much with that though).\n\n### Run and test my code\n\nVeteran LISP programmers know the value of having a REPL at their fingertips.\nWith Unison, it is as simple as writing a \"watch expression\", with >:\n\nThat expression is automatically evaluated in ucm so you get immediate\nfeedback on your code. Writing a test is no different, except that you give it\na name, and use the test library functions:\n\n    \n    \n    test> hi.test = verify do ensureEqual (hi \"Eric\") \"Hi, Eric!\"\n\nThis test is just another term that can be added to the code base to grow the\ntest suite. If it passes of course! Two things to note:\n\n  * When you change code in your editor, all the tests are re-executed. If those tests don't depend on some changed code, their result is cached, they are not re-executed!\n\n  * This also means that you can break previously added tests, which are present in your editor anymore, when updating a function. In that case, you can call test in ucm to re-run all the tests.\n\n## Some feedback from my first steps\n\nI don't want to give the impression that everything is perfect. The language\ntour and first experience could be improved:\n\n  * In ucm, typing fn + \u2190 does not go to the beginning of the line as it does in my zsh terminal.\n\n  * Hovering over a term shows its definition. It would be great to also be able to:\n\n    * Show the doc.\n\n    * Show the code.\n\n    * Open the term in the editor to modify it.\n\n  * This would reduce the amount of back and forth switching between the editor and ucm.\n\n  * Selecting a term to edit it is a bit crude. The term to edit is added at the top of the current file and the rest of the file is commented out. In many cases, I want my existing code to stay in scope.\n\n  * Some crucial aspects of the platform are still being polished! While I was going on the language tour, the Unison team realized that the functions used to do property-based testing were not so great and revamped the whole thing. This means that some of the documentation or blog post you read about Unison might not always reflect the latest and greatest.\n\n  * Similarly, the concept of namespacing for terms (the name1.name2.term notation) is a bit in flux. There are still a number of issues regarding the interactions of ucm commands for navigating/updating the code: cd, up, ls, move,... and the qualifiers that need to be written or not in the edited code.\n\n  * The VS Code integration with ucm could be improved. Some specific windows would be nice to display:\n\n    * All the compilation errors (and being able to jump to one of them)\n\n    * All the tests (in the current file, in the whole project)\n\n    * All the watch expressions (in the current file, in the whole project)\n\n  * I think I had a few bugs with the editor:\n\n    * Sometimes ucm is happy with a function, yet the editor shows an error message.\n\n    * If you define a == function, with its documentation, add it, and try to edit the documentation again, then the editor shows an \"offset\" error for (Name.==.doc).\n\n  * Since we pay less attention to files, it's easy to delete terms that were not yet added, i.e. losing that code! In that case having an editor with a good local history is important.\n\n# My first library\n\nI want to use Unison to develop a cloud application but I think that it is\nimportant to get comfortable first with a new programming language and the\nfull lifecycle of: coding, testing, releasing. So I decided to implement a\nlibrary that did not exist yet: @etorreborre/multimap.\n\nThis library provides a data type, a MultiMap. This is simply a wrapper for a\nMap k vs where vs is a list of values. MultiMaps can be useful in a variety of\ncontexts. For example, in Unison we could have a MultiMap tracking all the\nexisting names for a given term hash.\n\nThat led me to appreciate a few more cool things about Unison.\n\n### Documentation is first class\n\nYes, in Unison, the documentation for a term is itself a term. It has a name,\na namespace, can be added and edited. It can also be executed! This means that\nyou can put both Markdown text in a block of documentation and some valid\nUnison code:\n\nThen, the docs command executes and displays the result on the right. And\neventually that documentation is published as some beautiful HTML:\n\nWhy is this important? This matters a lot because now we have a much greater\nincentive to write great docs:\n\n  * They always typecheck.\n\n  * They are refactored like the rest of the code when a name is updated.\n\n  * Links to other terms are always working.\n\n  * You can provide great examples inline.\n\n## Less attention to files = more focus\n\nWhen writing Unison code we don't jump from file to file. We keep editing code\nin the same window. This means that it's perfectly ok to clear everything and\njust focus on one or two functions at the time, with the corresponding tests.\nThis is strangely liberating.\n\n## Less attention to files = more normalization\n\nMany people came to the idea that a good syntax formatter was the best way to\nput formatting discussions to rest. For example, Go came up with a default\nformatter from the start, and in Haskell, a \"no-configuration\" formatter like\normolu, won the hearts of many teams.\n\nUnison goes one step further since no text is really stored, only an AST. This\nmeans that you don't really care if you prefix all your functions with their\nnamespace, or add a bunch of use clause at the beginning of the file.\nEventually the code will be stored and rendered in the same way. For example:\n\n    \n    \n    use MultiMap empty size isEmpty test> MultiMap.tests.ex1 = verify do size empty === 0 isEmpty empty === true\n\nis reformatted as:\n\n    \n    \n    MultiMap.tests.ex1 : [Result] MultiMap.tests.ex1 = test.verify do use MultiMap empty MultiMap.size empty === 0 MultiMap.isEmpty empty === true\n\n## Todo\n\nThis is a small but useful thing when you use types to design your code. For\nexample, you know that you will need a function with a given type but you\ndon't want to lose focus by implementing it right away. Just leave todo as its\nimplementation. This is always a valid term!\n\n## Testing\n\nTesting is great! Unison comes with an effect system, called abilities, where\na piece of code can interact with a handler to decide how the computation\nshould be executed. This possibly sound nebulous, but you probably have\nalready used something like this if you have:\n\n  * Thrown exceptions. Then, a handler knows what to do with the exception. \"Resumable exceptions\" are even better since the handler can provide a value to continue the computation.\n\n  * Used async in Rust. The handler is an executor that puts the current code on hold, then resumes it when a thread is available.\n\n  * Used a generator in Python with yield. In that case, the handler uses the yielded value then resumes the code, to get the next value.\n\nThe abilities used for testing in Unison are:\n\n  * Random to provide randomly generated values.\n\n  * Each to repeat a piece of code, possibly with a different value, taken from a list of values.\n\n  * Exception to abort the test in case of a failure.\n\nThis means that you have a very convenient way to mix enumeration testing,\nwhere data is tested exhaustively, and random testing, where you let\nrandomness explore the test data. You can read some examples on Paul\nChiusano's blog post on the subject.\n\n## Publishing the library\n\nPublishing a library is very easy:\n\n  * Provide a README, in the form of a documentation term called,... README.\n\n  * Use the License datatype to provide a license for your project (and mit as a LicenseType for example).\n\n  * push and press the Cut a new release button on the project page.\n\n## Some question marks\n\nThe MultiMap library is not so small. It contains more than 200 terms and 2000\nlines of code (counting the documentation. It's code, right \ud83d\ude0a?).\n\nWith this library I could get a taste of what it meant to work with larger\nprojects in Unison and ask myself a few questions.\n\n### Namespaces\n\nNamespaces are mostly irrelevant for a library like MultiMap since everything\nis at the same level. But where do you put tests? Possibly, we want to\nseparate the testing code from the \"production\" code. I opted for the\nMultiMap.tests namespace (Unison's base library does things a bit\ndifferently). This has the advantage of offering a clear separation, and if\nyou want to have a look at all the tests you can edit.namespace\nMultiMap.tests.\n\nThere is also a bit of \"convention over configuration\". The lib namespace in a\ngiven project is treated specially. It contains all the project dependencies,\nincluding Unison's base library. If you want to upgrade that library or add\nanother library as a dependency you need to pull it, inside the lib namespace:\n\n    \n    \n    pull @unison/json-core/releases/1.0.3 lib.jsonCore_1_0_3\n\nAs you can see, there are no real constraints for going from json-\ncore/releases/1.0.3 to lib.jsonCore_1_0_3. I think I would have preferred a\npull dependency @unison/json-core/releases/1.0.3 command doing the right thing\nfor me.\n\nI also made the mistake of pulling the full Unison base library directly into\nmy top-level namespace \ud83d\ude30. Then I really had to learn how to remove terms and\nnamespaces \ud83d\ude01.\n\n### Privacy\n\nClosely related to namespaces is privacy. There's no notion of public/private\nin Unison and no notion of modules. Only namespaces. In MultiMap there are\nonly 2 functions that are implementation functions. I decided to \"hide\" them\nin a private namespace.\n\nI think that having the ability to truly forbid some terms to be seen outside\nof their packages would help when scaling Unison programs to large programs.\n\n### No typeclasses\n\nI like to call typeclasses \"interfaces for data types\", and as such, I think\nthey play an important role for modularity. They also come with all sort of\nquestions:\n\n  * How do you pass typeclass instances where needed?\n\n  * How do create/resolve typeclass instances?\n\nUnison does not have typeclasses, and I can understand why. While they are\nincredibly convenient, they also make a programming language a lot more\ncomplex. OCaml, or Elm, for example, are two functional programming languages\nwith no support for typeclasses.\n\nAs a matter of convenience, Unison has universal equality and universal\nordering, which are both structural. What does that mean?\n\nThis means that when you define any data type, for example Person, equality\nand ordering are based on what is inside the data type:\n\n    \n    \n    type Person = { name: Text, age: Nat, }\n\nThe Universal.eq and the Universal.gt functions compare 2 Persons first based\non their name, then on their age. This even works with functions! Two\nfunctions are equal if the hash of their content is equal.\n\nStructural equality is not controversial, but structural ordering is more\nquestionable:\n\n  * We might want to define different orderings for the same data type.\n\n  * I'd rather avoid breaking code if I simply swap two fields in my data type.\n\nAs a result, some Unison APIs use a comparison function parameter to specify\nexactly how elements must be compared. But this is not the case for some data\ntypes like Map or Set.\n\n### Large refactorings\n\nWhile developing the MultiMap library, I inadvertently set myself up for a\nlarge refactoring. I initially started with MultiMap = Map k [v] and later,\nmuch later, realized that a more correct definition was MultiMap = Map k\n(List.Nonempty v).\n\nChanging the datatype, and trying to add the new definition, triggered the\ntypechecker, which was very unhappy with this change. ucm brought most of the\ndefinitions into scope and told me to fix them. This has been unfortunately a\nbit painful experience:\n\n  * Only some errors are displayed at the time. Fixing one issue triggers another issue in a different place and you don't really know when the whole process is going to stop.\n\n  * Some names were replaced with their hash.\n\n  * After fixing all issues in sight, I entered update but ucm told me that some code was still not compiling, commented out all the previous code, only to put another wall of text in front of me. Was it some new code, a bit of the old code that was still not compiling, some additional tests? Eventually, I had the impression of writing some fixes twice.\n\nThat made me wonder if more tooling was needed for large codebases, in order\nto support deep refactorings.\n\n# My first contributions\n\nDuring the development of the MultiMap library, I added a few functions that\nwere missing from the List and List.Nonempty data types. The whole process was\nreally simple:\n\n  * Create a branch in @unison/base: branche.create /mybranch.\n\n  * Add some new functions + doc + tests.\n\n  * push.\n\n  * Open a contribution in the corresponding project (much like a pull request in Github).\n\nAll of this, except the last step, is done in ucm and I can foresee a future\nwhere even the last step is supported in ucm so that you don't even have to\nleave your development environment to collaborate on projects.\n\n# Conclusion\n\nDespite some of the shortcomings mentioned above, I can't wait to develop my\nfirst cloud application. This is going to be an application for importing bank\ndata into my accounting software. My prediction is that most of the difficulty\nwill come from the core of the application:\n\n  * Dealing with authentication on both systems.\n\n  * Navigating both data models.\n\n  * Determining what is \"new\" data and what is already imported data.\n\nI hope that, on the contrary, thanks to Unison Cloud, the technical aspects\nwill be a breeze:\n\n  * Deploying the application.\n\n  * Monitoring it.\n\n  * Using secrets.\n\n  * Interacting with HTTP APIs.\n\n  * Maybe storing a bit of data.\n\nStay tuned for part 2, and don't hesitate to give Unison a go, it is really a\nrefreshing experience!\n\n## Subscribe to my newsletter\n\nRead articles from Galaxy brain directly inside your inbox. Subscribe to the\nnewsletter, and don't miss out.\n\nFunctional ProgrammingUnisonCloud\n\n### Written by\n\n# Eric Torreborre\n\nSoftware engineer at the intersection of functional programming, product\ndevelopment and open-source\n\nSoftware engineer at the intersection of functional programming, product\ndevelopment and open-source\n\nShare this\n\n### More articles\n\nEric Torreborre\n\n# We have no free will, and this is not a big deal\n\nI was introduced to the wonderful neuroscientist and primatologist, Robert\nSapolsky, more than 10 ye...\n\nEric Torreborre\n\n# Typed Tagless Final, for real!\n\nEvery so often, a software technique takes the center stage of attention and\nbecomes the source of c...\n\nEric Torreborre\n\n# The application toolbox\n\nWhat are the elements that make a huge difference in your productivity when\nyou are developing an ap...\n\n\u00a92024 Galaxy brain\n\nArchive\u00b7Privacy policy\u00b7Terms\n\n", "frontpage": false}
