{"aid": "40184515", "title": "Let's Embed a Go Program into the Linux Kernel", "url": "https://sigma-star.at/blog/2023/07/embedded-go-prog/", "domain": "sigma-star.at", "votes": 10, "user": "st_goliath", "posted_at": "2024-04-27 23:20:17", "comments": 0, "source_title": "Let's Embed a Go Program into the Linux Kernel", "source_text": "Let's Embed a Go Program into the Linux Kernel\n\nTrainings About Blog\n\nMenu\n\nlinux\n\n|\n\n21.07.2023\n\n# Let\u2019s Embed a Go Program into the Linux Kernel\n\nToday, we would like to present a lesser-known feature of the Linux kernel.\nInstead of launching a program from a file system, regardless of whether it\u2019s\nvirtual or not, it is also possible to embed a user-space program directly\ninto the kernel image itself and start it from there.\n\n## Introduction\n\nAt first glance, this might sound outlandish and of little use, but there are\ncases where the kernel needs to execute helper programs. Prominent examples\ninclude the module loader helper, /sbin/modprobe, or the Spanning Tree\nProtocol (STP) helper for Linux\u2019s 802.1d Ethernet bridge subsystem,\n/sbin/bridge-stp. On Linux, programs are typically launched from a file system\nusing the execve() system call. The kernel reads the initial parts of the\nspecified file and hands over execution to user space. Various helper\nfunctions exist on top of this system call, but they all have in common that\nthe program to be executed is started from a file. The same applies to the\nLinux user mode helper API, which allows executing a program from a driver.\nBoth scenarios require the program to be installed and loadable. In most\ncases, having the program installed is a trivial problem if you have control\nover all user space, as is the case with a typical Linux distribution.\n\nHowever, things become complicated if you are a Board Support Package (BSP)\nsupplier, either external or in-house, and don\u2019t always have easy access to\nthe workflow that determines what to install in the root file system. Ensuring\nthat a program is actually loadable from the current root file system is a\ndifferent story. A common problem arises in setups where the root file system\nis attached using network storage, such as NFS or iSCSI. If the network\nconnection is unavailable, all access to the root file system fails, and the\nkernel is unable to run helpers anymore. This is where the mechanism we\u2019d like\nto present in this blog post can help.\n\nLet\u2019s assume we have a device driver called embedded_prog that requires a user\nspace helper program, which must be executable at any time. First, we need the\nprogram we want to embed. Strictly speaking, any program will do, but we need\nto ensure that the program in question has no dependencies on the file system.\nLinking it statically provides benefits. Go programs are statically linked by\ndefault, and to illustrate that the following approach works with any kind of\nprogram, we have chosen to embed a Go program into the kernel. The driver\nitself is very simple. All it does is execute the helper program as soon as\nthe driver is loaded, and when the program writes something into the pipe, the\ncontents are directly logged into the kernel log buffer.\n\n## The Go Program\n\nTo keep things simple, the program itself will be straightforward. It will\nwrite \u2018Hello, world!\u2019 to standard output every five seconds.\n\n    \n    \n    1 2 3 4 5 6 7 8 9 10 11 12 13\n\n|\n\n    \n    \n    package main import ( \"fmt\" \"time\" ) func main() { for { fmt.Println(\"Hello, world!\") time.Sleep(5 * time.Second) } }  \n  \n---|---  \n  \nSince we want to be independent of the root file system, we need to ensure\nthat the program does not access files from the root file system. We can\nachieve this by using strace to trace its system calls.\n\n    \n    \n    $ strace -fe trace=file ./eprog_user execve(\"./eprog_user\", [\"./eprog_user\"], 0x7fff743fbd50 /* 61 vars */) = 0 openat(AT_FDCWD, \"/sys/kernel/mm/transparent_hugepage/hpage_pmd_size\", O_RDONLY) = 3 strace: Process 17908 attached strace: Process 17909 attached strace: Process 17910 attached strace: Process 17911 attached [pid 17905] --- SIGURG {si_signo=SIGURG, si_code=SI_TKILL, si_pid=17905, si_uid=1000} --- Hello, world! Hello, world! ^C strace: Process 17905 detached strace: Process 17908 detached strace: Process 17909 detached strace: Process 17910 detached strace: Process 17911 detached\n\nLooks good! Access to files in /proc or /sys is fine. These are virtual file\nsystems and can be assumed to be present and working at all times. They are\npart of the Linux ABI interface.\n\n## Linux\u2019s User Mode Helper API\n\nIf your device driver needs to execute a user space program, the User Mode\nHelper API is the way to go. The core function to use the API is\ncall_usermodehelper(), which has the following signature:\n\n    \n    \n    int call_usermodehelper(const char *path, char **argv, char **envp, int wait);\n\nSimilar to the execve() system call, call_usermodehelper() takes parameters\nsuch as the filename of the program to be executed, supplied arguments,\nenvironment, and a flag denoting whether the call should be asynchronous or\nnot. However, this is not what we want for running an embedded program within\nthe kernel image itself.\n\nSince Linux v4.18, a more advanced API called user mode driver is available to\nrun a user mode helper. The basic idea behind this API is that instead of\nspecifying a path to a file on the root file system, an arbitrary buffer can\nbe provided. The content of this buffer will be executed in user space just\nlike a regular program.\n\n    \n    \n    int umd_load_blob(struct umd_info *info, const void *data, size_t len); int fork_usermode_driver(struct umd_info *info);\n\nUsing umd_load_blob(), a program context is created from a buffer, and later\nit is executed by fork_usermode_driver(). In addition to running the program,\nthe User Mode Driver API also establishes a pipe between the program and the\nkernel, enabling inexpensive communication between them.\n\nBut how do we get our Go program into that buffer? We don\u2019t want a new user\nspace interface where the program has to be loaded into the kernel first. We\nwant it to be part of the kernel image.\n\n## GNU Assember to the Rescue!\n\nThe kernel build system, specifically the GNU assembler (gas), can assist us\nin embedding the Go program into the resulting kernel image during the build\nprocess. By using a gas file, eprog_user_blob.S, we can instruct the assembler\nto generate a C object file with two symbols: embedded_umh_start and\nembedded_umh_end. These symbols will contain the contents of a binary file\nspecified by the .incbin command, and this file can be arbitrary.\n\n    \n    \n    1 2 3 4 5 6\n\n|\n\n    \n    \n    .section .init.rodata, \"a\" .global embedded_umh_start embedded_umh_start: .incbin \"drivers/misc/embedded_prog/eprog_user\" .global embedded_umh_end embedded_umh_end:  \n  \n---|---  \n  \nIf we link the resulting object file, eprog_user_blob.o, with our Linux device\ndriver, we can utilize the symbols to locate the contents of the Go program\nwithin the kernel image. This makes loading and executing the program from a\nbuffer straightforward. In this case, the buffer passed to umd_load_blob() is\na memory location within the read-only section of the in-memory kernel image.\nThe linker has kindly prepared everything for us at compile time!\n\nThe code snippet provided below demonstrates the essential segments of the\ndevice driver, eprog_kern.c, responsible for loading and executing the Go\nprogram:\n\n    \n    \n    1 2 3 4 5 6\n\n|\n\n    \n    \n    struct umd_info eprog_ctx = { .driver_name = \"eprog_user\", }; umd_load_blob(&eprog_ctx, &embedded_umh_start, &embedded_umh_end - &embedded_umh_start); fork_usermode_driver(&eprog_ctx);  \n  \n---|---  \n  \nUsing the nm command, we can observe the symbols in the driver. If the driver\nis built as a loadable module, you can run nm on eprog.o. Otherwise, if it is\nbuilt directly into the kernel, you can run nm on vmlinux.\n\n    \n    \n    $ nm eprog.o | grep embedded_umh_ 00000000001bc4e4 R embedded_umh_end 0000000000000000 R embedded_umh_start\n    \n    \n    $ nm vmlinux | grep embedded_umh_ 0000000060688a00 d embedded_umh_end 00000000604cc51c d embedded_umh_start\n\n## Gluing it all Together\n\nSo far we have the following components:\n\n  * eprog_kern.c: The kernel driver that runs umd_load_blob() and fork_usermode_driver().\n  * eprog_user_blob.S, The assembly source file we use to embed the Go program into a C object.\n  * gohello/hello.go, Our Go program, located in a subdirectory of our driver.\n\nUsing the following Makefile, all components are build and connected together:\n\n    \n    \n    1 2 3 4 5 6 7\n\n|\n\n    \n    \n    $(obj)/eprog_user_blob.o: $(obj)/eprog_user $(obj)/eprog_user: $(srctree)/drivers/misc/embedded_prog/gohello/hello.go # TODO: Add support for cross builds go build -o $(obj)/eprog_user $(srctree)/drivers/misc/embedded_prog/gohello/hello.go obj-$(CONFIG_EMBEDDED_PROG) += eprog.o eprog-objs += eprog_kern.o eprog_user_blob.o  \n  \n---|---  \n  \nLinux\u2019s GNU make-based build system is rather flexible: it allows us to build\nour Go program even while building the kernel.\n\nThe following graphic outlines how all components are connected:\n\n## Demo\n\n    \n    \n    $ insmod eprog.ko $ ps fax PID TTY STAT TIME COMMAND 2 ? S 0:00 [kthreadd] [..] 25 ? Sl 0:00 \\_ eprog_user [..] 30 ? R 0:00 ps fax $ dmesg -w [ 53.300000] eprog: From userspace: Hello, world! [ 58.310000] eprog: From userspace: Hello, world! [...]\n\nWe observe a new process, eprog_user, right after loading the driver module.\nIt is not a kernel thread, the name is not in square brackets and it is not a\nchild of PID 1 but of kthreadd. Every five seconds the Go program will write\nHello, world! via standard output to the kernel driver which prints the string\nto the kernel log buffer. Once the module is unloaded, the process is killed.\n\n## Summary\n\nWe have seen that using a small assembly file and the User Mode Driver\nmechanism, it is possible to embed any kind of executable into the kernel\nimage and run it later from there. It works with any kind of program; we used\na Go binary because it is statically linked and has no dependencies on the\nroot file system. If you\u2019re using your own program and want to be completely\nindependent of the root file system, make sure that you know in detail which\nfiles it will process. While the number of valid use cases for the presented\nfeature is arguably small, it is still interesting to have and opens the door\nto new possibilities. The example driver is rather simple, but there are\nnumerous other ways to utilize this feature. Please keep in mind that adding\nprograms to the kernel image comes with a cost: the program as a whole will\nalways stay in memory.\n\nThe full example driver is available on git.kernel.org.\n\nPublish date\n\n21.07.2023\n\nCategory\n\nlinux\n\nAuthors\n\nRichard Weinberger\n\n## Get in touch\n\noffice@sigma-star.at (PGP Key)\n\n+43 5 9980 400 00\n\nsigma star gmbh Eduard-Bodem-Gasse 6, 1st floor 6020 Innsbruck | Austria\n\nPrivacy & Terms Careers\n\nHome Trainings About Blog\n\n", "frontpage": true}
