{"aid": "40138349", "title": "The only two log levels you need are INFO and ERROR", "url": "https://www.ntietz.com/blog/the-only-two-log-levels-you-need-are-info-and-error/", "domain": "ntietz.com", "votes": 2, "user": "ggoo", "posted_at": "2024-04-23 23:01:16", "comments": 0, "source_title": "The only two log levels you need are INFO and ERROR | nicole@web", "source_text": "The only two log levels you need are INFO and ERROR | nicole@web\n\n# technically a blog\n\nhome | blog / tags | newsletter | projects\n\n# The only two log levels you need are INFO and ERROR\n\nMonday, April 22, 2024\n\nLogging is a critical tool for maintaining any web application, and yet we're\ngetting it wrong.\n\nWith great logs, you can see what your application is doing. And without them?\nThings can be broken left and right without you ever finding out. Instead, you\nwonder why your customers don't come back, and shrug, and blame someone other\nthan engineering.\n\nUnfortunately, it's common for us to log in ways that are unhelpful. Log\nlevels are inconsistent, and logs are added to fix bugs then removed\nafterwards. But come on, you saw the title, this is about the log levels,\nmostly.\n\n# The typical log levels\n\nMost languages and logging libraries have a handful of log levels, at least\nfive. But they vary! Here are three examples:\n\n  * Rust's tracing has five log levels: ERROR, WARN, INFO, DEBUG, and TRACE.\n  * Python's logging also has five log levels: CRITICAL, ERROR, WARNING, INFO, and DEBUG.\n  * The infamous log4j has six log levels: FATAL, ERROR, WARN, INFO, DEBUG, and TRACE.\n\nThree examples and three wholly different sets of log levels. They all\nfunction in about the same way: you log certain information at different\nlevels, based on your ideas of \"severity\" and \"granularity\", and then as you\nget toward the fatal/error end of the log levels you see only the most\ncritical alerts, and toward the other end you see everything to help you debug\nyour application.\n\nThere's really no typical set of log levels, nor common cross-language\nguidance on what to log at which level. There can't be that advice, because\nthe levels vary so much!\n\n# What do we do with logs?\n\nWhen we add log statements, that's typically because we think that we will\nneed those logs sometime in the future. We think they'll help us debug\nsomething, or help us audit that it happened, or discover a critical error.\n\nThink about a time when you went to debug a deployed web application (not on\nyour local machine) and used the logs. Typically, we're doing a few things:\n\n  * Discovering errors to fix. We want to know when something has gone wrong, so we look for errors in the logs. Typically, you also want to get alerted if something needs to be fixed. And related, you don't want to be alerted if something happens that doesn't deserve attention. Alert fatigue is a serious problem.\n  * Debugging a problem. When something does go wrong, whether you were alerted from logs or not, you'll turn to them to understand what's up. The logs can tell you what's happening that's unexpected. They should include any stack traces, related errors, and conditions leading up to the problem.\n  * Understanding usage. Sometimes logs are good for understanding how things are used! You can see generally which portions of the application are accessed or left untouched. They're not a substitute for metrics or distributed tracing, though!\n  * Understanding how it works. Logs can also help you understand how a system works! If you have just the code, you'll see a lot of functions and request handlers and data and where do you start? With the logs, you can generally find an entry point where a request or session starts. From there, you can follow along with those logs through the life cycle of the session and follow the execution!\n\nThese can be split into two categories: logs that wake me up, and logs that\nhelp me fix things.\n\nFor logs that wake me up, I want to know a few things. What's the problem\nprecisely? When did it happen? And where can I find related logs?\n\nAnd then for logs that help me fix things, I really want to know everything.\nWell, when debugging, everything relevant, I don't need to go down a rabbit\nhole about CNCs right then. And you don't know what's going to be relevant\nuntil you know the answer to your question! You might have a guess, but it's a\nguess.\n\n# The levels you need\n\nIn practice, I tend to find that you only really want two log levels: ERROR\nand INFO. That's because we really do only care if something should alert us\nor not. For all the other uses of logs, we want to see all the context.\n\nLet's use WARNING as an example. Suppose you should have a WARNING log level,\nand some of those show up in your logs. What should you do when you see them?\nThere are three choices:\n\n  * If the information isn't useful at all, in any scenario, delete them entirely!\n  * If it helps you make sense of other logs, potentially related to an error, then these are just info logs for debugging! They should be INFO level to reflect that.\n  * And if it is an error you need to fix, well, it's not a warning now is it? Make that an ERROR log.\n\nAnd similar for things like DEBUG or TRACE. Usually you reach for those log\nlevels when you want to see extremely verbose information, but... That's not\npractical to enable in production environments, because the volume of logs you\nproduce would be way too high. And if you can't use it in production, you\nprobably shouldn't use it elsewhere! That's what your local debugger is for.\n\nThings like FATAL? Yep, that's also an ERROR log, because you do want to be\nalerted on it!\n\nIn every situation that I've run into in production, a single log line at a\ngiven level is never sufficient to debug something, only to know it happened.\nAnd even then, what actually happened? Shrug. Let's look at more log lines.\n\nAnd so if you separate things out into different log levels, you end up\nlooking at all of them together anyway, because to understand your warnings or\nerrors you need all the info logs to see what was going on! You need that\nbroader context to make sense of the overall situation. It's very slight\nsemantic information, similar to syntax highlighting, but there are better\nways to deliver that information.\n\n# Enhance your logs in other ways\n\nThere are better ways to increase the usability of your logs than with strict\nadherence to different log levels. Structured logging is the practice of\nemitting logs in a machine-readable format. They're often created from maps,\nand then output in the logs as JSON or output for humans to see in a more\nreadable format. Using structured logging, you can attach a lot more detail to\neach log in a way that's useful.\n\nHere are a few practices I like to use:\n\n  * Attach a request/trace id. This goes along with distributed tracing, and helps you filter effectively. Filtering down by log level won't give you context, but correlating by request id will give you all the logs for a given event!\n  * Include timestamps. All logs should include timestamps, but let's just make sure we have them and at a useful precision. Having these in a structured format makes it easier to use them for calculations.\n  * Add related ids. When an incoming request relates to a given user, document, or other data, adding that id into the logs is so helpful! Then when you're debugging, you can see either all the logs for a particular object, or you can see if a particular set of data is related to the issue you're working on. Without this, you are just guessing \"Maybe this is just a BigCo issue,\" and with it you know whether other customers see it too.\n  * Note information for auditing. If you log information for audit purposes, how will you find it? By including something in the logs that let you look for the needle in that haystack (and retain the needles when you toss out the haystack because paying the haystack storage company is akin to setting a pile of cash on fire\u2014not to torture the metaphor). This can be as simple as a boolean for if it's an audit log, or more complicated if you need that.\n  * Flags which were set. Your application probably has feature flags. Which ones were enabled for this request? Let's put them in the logs so we can tell.\n  * Where the log came from. Including the module or function name that a log came from can be really helpful for looking at surrounding context later. Too often, I've not had this, and had to grep for a specific string to find where that log was emitted. Hopefully only in one spot.\n\nYou do want to avoid adding too much information, because it can be an\noverwhelming amount! But if you add in this information tastefully, it's\nreally helpful.\n\nAnd don't add logs in to fix one issue, then remove them later, okay? I've\nseen that done, and what that says is you did not have enough logs in the\nfirst place to understand what was going on! You might not have known exactly\nwhat you need, but after you do, then make sure the logs you would have needed\nfor this issue are present. Ideally they're in a more general form, so that\nother related but different issues can also be debugged in the future.\n\nLook.\n\nI know, log levels are useful. I'm not actually terribly dogmatic about this,\nbecause there can be situations where you want to tune the amount of detail\n(especially helpful for libraries to limit their log levels, so you don't get\neverything from them on INFO).\n\nI just don't think it's useful, most of the time, for the kind of work I\ndo\u2014web applications, mostly\u2014to worry about anything beyond: wake me up, or\ndon't. If you do it differently, I'd love to hear about your experience.\n\nIf this post was enjoyable or useful for you, please share it! If you have\ncomments, questions, or feedback, you can email my personal email. To get new\nposts and support my work, subscribe to the newsletter. There is also an RSS\nfeed.\n\nWant to become a better programmer? Join the Recurse Center!\n\n", "frontpage": false}
