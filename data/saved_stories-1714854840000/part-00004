{"aid": "40256693", "title": "Swift's native Clocks are inefficient", "url": "https://wadetregaskis.com/swifts-native-clocks-are-very-inefficient/", "domain": "wadetregaskis.com", "votes": 2, "user": "ingve", "posted_at": "2024-05-04 11:09:39", "comments": 0, "source_title": "Swift\u2019s native Clocks are very inefficient", "source_text": "Swift\u2019s native Clocks are very inefficient \u2013 Wade Tregaskis\n\nSkip to content\n\n# Swift\u2019s native Clocks are very inefficient\n\nMay 3, 2024May 2, 2024 by\n\nContents [show]\n\n  * mach_absolute_time for the win\n  * Date / NSDate surprisingly not bad\n\nBy which I mean, things like ContinuousClock and SuspendingClock.\n\nIn absolute terms they don\u2019t have much overhead \u2013 think sub-microsecond for\nmost uses. Which makes them perfectly acceptable when they\u2019re used\nsporadically (e.g. only a few times per second).\n\nHowever, if you need to deal with time and timing more frequently, their\ninefficiency can become a serious bottleneck.\n\nI stumbled into this because of a fairly common and otherwise uninteresting\npattern \u2013 throttling UI updates on an I/O operation\u2019s progress. This might\nlook something like:\n\n    \n    \n    struct Example: View { let bytes: AsyncSequence<UInt8> @State var byteCount = 0 var body: some View { Text(\"Bytes so far: \\(byteCount.formatted(.byteCount(style: .binary)))\") .task { var localByteCount = 0 let clock = ContinuousClock() var lastUpdate = clock.now for try await byte in bytes { ... // Do something with the byte. localByteCount += 1 let now = clock.now let delta = now - lastUpdate if ( delta > .seconds(1) || ( (delta > .milliseconds(100) && 1_000_000 <= localByteCount))) { byteCount = localByteCount lastUpdate = now } } } } }\n\n\u261d\ufe0f This isn\u2019t a complete implementation, as it won\u2019t update the byte count if\nthe download stalls (since the lack of incoming bytes will mean no iteration\non the loop, and therefore no updates even if a full second has passes). But\nit\u2019s sufficient for demonstration purposes here.\n\n\ud83d\udd90\ufe0f Why didn\u2019t I just use throttle from swift-async-algorithms? I did, at\nfirst, and quickly discovered that its performance is horrible. While I do\nsuspect I can \u2018optimise\u2019 it to not be atrocious, I haven\u2019t pursued that as it\nwas easier to just write my own throttling system.\n\nThe above seems fairly straightforward, but if you run it and have any non-\ntrivial I/O rate \u2013 even just a few hundred kilobytes per second \u2013 you\u2019ll find\nthat it saturates an entire CPU core, not just wasting CPU time but limiting\nthe I/O rate severely.\n\nUsing a SuspendingClock makes no difference.\n\nIn a nutshell, the problem is that Swift\u2019s Clock protocol has significant\noverheads by design. If you look at a time profile of code like this, you\u2019ll\nsee things like:\n\nThat\u2019s a lot of time wasted in function calls and struct initialisation and\ntype conversion and protocol witnesses and all that guff. The only part that\u2019s\nactually retrieving the time is the swift_get_time call (which is just a\nwrapper over clock_gettime, which is just a wrapper over\nclock_gettime_nsec_np(CLOCK_UPTIME_RAW), which is just a wrapper over\nmach_absolute_time).\n\nI wrote some simple benchmarks of various alternative time-tracking methods,\nwith these results with Swift 5.10 (showing the median runtime of the\nbenchmark, which is a million iterations of checking the time):\n\nMethod| 10-core iMac Pro| M2 MacBook Air  \n---|---|---  \nContinuousClock| 429 ms| 258 ms  \nSuspendingClock| 430 ms| 247 ms  \nDate / NSDate| 30 ms| 19 ms  \nclock_gettime_nsec_np(CLOCK_MONOTONIC_RAW)| 32 ms| 10 ms  \nclock_gettime_nsec_np(CLOCK_UPTIME_RAW)| 27 ms| 10 ms  \ngettimeofday| 24 ms| 12 ms  \nmach_absolute_time| 15 ms| 6 ms  \n  \nAll these alternative methods are well over an order of magnitude faster than\nSwift\u2019s native clock APIs, showing just how dreadfully inefficient the Swift\nClock API is.\n\n### mach_absolute_time for the win\n\nUnsurprisingly, mach_absolute_time is the fastest. It is what all these other\nAPIs are actually based on; it is the lowest level of the time stack.\n\nThe downside to calling mach_absolute_time directly, though, is that it\u2019s on\nApple\u2019s \u201cnaughty\u201d list \u2013 apparently it\u2019s been abused for device\nfingerprinting, so Apple require you to beg for special permission if you want\nto use it (even though it\u2019s used by all these other APIs anyway, as the basis\nfor their implementations, and there\u2019s nothing you can get from\nmach_absolute_time that you can\u2019t get from them too \ud83e\udd28).\n\n### Date / NSDate surprisingly not bad\n\nI was quite surprised to see good ol\u2019 Date (a.k.a. NSDate) performing\ncompetitively with the traditional C-level APIs, at least on x86-64. Even on\narm64 it\u2019s not bad, at still a third to half the speed of the C APIs. This\nsurprised me because it has the overhead of at least one Objective-C message\nsend (for timeIntervalSinceNow), unless somehow the Swift compiler is\noptimising that into a static function call, or inlining it entirely...?\n\nI certainly wouldn\u2019t be afraid to use Date broadly, going down to lower APIs\nonly when truly necessary \u2013 which is pretty rarely, I\u2019d wager; we\u2019re talking a\nmere 19 to 30 nanoseconds to get the time elapsed since a reference date and\ncompare it to a threshold. If that\u2019s too slow, it might be an indication that\nthere\u2019s a bigger problem (like transferring data a single byte at a time, as\nin the example that started this post \u2013 but more on that in a future post).\n\n#### Moar posts\n\n  * SwiftUI main thread hang detector\n\n  * FTZ adaptor hates tripods, straps, and harnesses\n\n  * A brief introduction to type memory layout in Swift\n\nCategories Coding Tags Benchmarked, clock_gettime_nsec_np, ContinuousClock,\ngettimeofday, Inefficient by design, mach_absolute_time, Sad, SuspendingClock,\nSwift\n\n### Leave a Comment Cancel reply\n\nRSS (Posts)\n\nRSS (Comments)\n\nMastodon: @everything@wadetregaskis.com\n\nOther ways to follow this website\n\nCopyright & Licenses\n\n\u00a9 2024 Wade Tregaskis \u2022 Built with GeneratePress\n\n", "frontpage": false}
