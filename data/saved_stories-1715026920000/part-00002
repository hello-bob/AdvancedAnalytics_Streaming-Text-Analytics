{"aid": "40275028", "title": "C++ std:expected \u2013 Monadic Extensions", "url": "https://www.cppstories.com/2024/expected-cpp23-monadic/", "domain": "cppstories.com", "votes": 1, "user": "ibobev", "posted_at": "2024-05-06 14:21:35", "comments": 0, "source_title": "std::expected - Monadic Extensions", "source_text": "std::expected - Monadic Extensions - C++ Stories\n\nC++ Stories\n\nStay up-to-date with Modern C++\n\nLast Update: 06 May 2024\n\n# std::expected - Monadic Extensions\n\nTable of Contents\n\nstd::expected from C++23 not only serves as an error-handling mechanism but\nalso introduces functional programming paradigms into the language. In this\nblog post, we\u2019ll have a look at functional/monadic extensions of\nstd::expected, which allow us to chain operations elegantly, handling errors\nat the same time. The techniques are very similar to std::optional extensions\n- see How to Use Monadic Operations for `std::optional` in C++23 - C++\nStories.\n\nHere\u2019s a brief overview of these functional capabilities:\n\nUpdate: Thanks to prof. Boguslaw Cyganek for finding some errors in my initial\ntext!\n\n## and_then()\n\nThe and_then member function enables chaining operations that might produce a\nstd::expected object. It\u2019s invoked when the std::expected object holds a value\nand allows for seamless operation chaining without manual error checking after\neach step.\n\nSee below a simple example:\n\n    \n    \n    #include <iostream> #include <expected> std::expected<int, std::string> incrementIfPositive(int value) { if (value > 0) return value + 1; return std::unexpected(\"Value must be positive\"); } std::expected<int, std::string> getInput(int x) { if (x % 2 == 0) return x; return std::unexpected(\"Value not even!\"); } int main() { auto input = getInput(-2); auto result = input.and_then(incrementIfPositive); if (result) std::cout << *result << '\\n'; else std::cout << result.error() << '\\n'; }\n\nSee at @Compiler Explorer\n\nThe getInput function returns an expected object with the value of -2; since\nthis is not an error, it\u2019s passed to incrementIfPositive.\n\n> Please notice that incrementIfPositive takes the type of the contained value\n> of the starting object, but returns std::expected<T, Err> type.\n\nAnd here\u2019s the output:\n\n    \n    \n    Value must be positive\n\nAnd for the comparison, let\u2019s have a look at a more complicated example.\nHere\u2019s a version with regular \"if/else\" checking:\n\n    \n    \n    #include <iostream> #include <string> #include <charconv> #include <expected> std::expected<int, std::string> convertToInt(const std::string& input) { int value; auto [ptr, ec] = std::from_chars(input.data(), input.data() + input.size(), value); if (ec == std::errc()) return value; return std::unexpected(\"Conversion failed: invalid input\"); } std::expected<int, std::string> calculate(int number) { if (number > 0) return number * 2; return std::unexpected(\"Calculation failed: number must be positive\"); } int main() { std::string input; //std::cout << \"Enter a number: \"; //std::cin >> input; input = \"123\"; auto converted = convertToInt(input); if (!converted) { std::cout << converted.error() << '\\n'; return -1; } auto result = calculate(*converted); if (!result) { std::cout << result.error() << '\\n'; return -1; } std::cout << \"Result: \" << *result << '\\n'; }\n\nRun @Compiler Explorer\n\nHere\u2019s the version with and_then():\n\n    \n    \n    // Same convertToInt function as above... // Same calculate function as above... int main() { std::string input; //std::cout << \"Enter a number: \"; //std::cin >> input; input = \"123\"; auto result = convertToInt(input) .and_then(calculate) .and_then([](int num) { std::cout << \"Result: \" << num << '\\n'; return std::expected<int, std::string>(num); }); if (!result) std::cout << result.error() << '\\n'; }\n\nSee @Compiler Explorer\n\nNotice that the latter version omits one check for the input expected object.\nIn the example, I also mixed a regular function pointer with a lambda.\n\n## transform() - Transforming the Value\n\nThe transform function applies a given function to the contained value if the\nstd::expected object holds a value. It allows for transforming the value\nwithout altering the error state.\n\n    \n    \n    double doubleValue(int value) { return value * 2.; } auto tr = std::expected<int, Err>(10).transform(doubleValue); // ts now is std::expected<double, Err>\n\nRun at Compiler Explorer\n\n> Please notice that doubleValue takes the type of the contained value of the\n> starting object, and returns the same or other Value type. The returned\n> value is wrapped into expected type.\n\nAnd here\u2019s a better example, where we transform the parsed date:\n\n    \n    \n    #include <iostream> #include <string> #include <sstream> #include <expected> #include <chrono> #include <format> std::expected<std::chrono::year_month_day, std::string> parseDate(const std::string& dateStr) { std::istringstream iss(dateStr); std::chrono::year_month_day ymd; iss >> std::chrono::parse(\"%F\", ymd); if (!ymd.ok()) return std::unexpected(\"Parsing failed: invalid date format\"); return ymd; } std::string formatDate(const std::chrono::year_month_day& ymd) { return std::format(\"Back to string: {:%Y-%m-%d}\", ymd); } int main() { std::string input = \"2024-04-29\"; auto result = parseDate(input) .transform(formatDate); if (!result) { std::cout << \"Error: \" << result.error() << '\\n'; return -1; } std::cout << \"Formatted Date: \" << *result << '\\n'; }\n\nRun @Compiler Explorer\n\n## or_else() - Handling Errors\n\nor_else handles errors by applying a function to the contained error if the\nstd::expected object holds an error. It\u2019s useful for logging, error\ntransformation, or recovery strategies.\n\nFrom cppreference:\n\n> If this contains an unexpected value, invokes f with the argument error()\n> and returns its result; otherwise, returns a std::expected object that\n> contains a copy of the contained expected value (obtained from operator).\n    \n    \n    std::expected<int, std::string> handleError(const std::string& error) { std::cerr << \"Error encountered: \" << error << '\\n'; return std::unexpected(error); } auto handled = std::expected<int, std::string>(std::unexpected(\"Failure\")).or_else(handleError);\n\nor_else works great with and_then:\n\n    \n    \n    std::expected<int, std::string> handleError(const std::string& error) { std::cerr << \"Error encountered: \" << error << '\\n'; return std::unexpected(error); } int main() { auto input = getInput(-2); auto result = input.and_then(incrementIfPositive) .or_else(handleError); }\n\nRun at @Compiler Explorer\n\nThe output:\n\n    \n    \n    Error encountered: Value must be positive\n\nNotice that our error handler code can be invoked in two cases: when the input\nis in the error state or the returned value from incrementIfPositive is in the\nerror state.\n\n## transform_error()\n\nThis is similar to transform() but applies to the error part. It allows\ntransforming the error into another form without affecting the success path.\n\n    \n    \n    std::string transformError(const std::string& error) { return std::ustring(\"New Error: \") + error; } auto errorTransformed = std::expected<int, std::string>(std::unexpected(\"Original Error\")) .transform_error(transformError);\n\nRun @Compiler Explorer\n\n> Please notice that transformError takes the type of the contained error of\n> the starting object, and returns the same or other Error type. The returned\n> error is wrapped into expected type.\n\n## Using them all together:\n\nHere\u2019s a more complicated example that uses all of that functionality:\n\n    \n    \n    #include <iostream> #include <string> #include <sstream> #include <expected> #include <chrono> #include <format> bool isWeekend(const std::chrono::year_month_day& ymd) { auto wd = std::chrono::weekday(ymd); return wd == std::chrono::Sunday || wd == std::chrono::Saturday; } std::expected<std::chrono::year_month_day, std::string> parseDate(const std::string& dateStr) { std::istringstream iss(dateStr); std::chrono::year_month_day ymd; iss >> std::chrono::parse(\"%F\", ymd); if (!ymd.ok()) return std::unexpected(\"Parsing failed: invalid date format\"); return ymd; } std::string formatDate(const std::chrono::year_month_day& ymd) { return std::format(\"{:%Y-%m-%d}\", ymd); } int main() { std::string input = \"2024-04-28\"; // This is a Saturday auto result = parseDate(input) .and_then([](const std::chrono::year_month_day& ymd) -> std::expected<std::chrono::year_month_day, std::string> { if (isWeekend(ymd)) { return std::unexpected(\"Date falls on a weekend\"); } return ymd; }) .transform([](const std::chrono::year_month_day& ymd) -> std::string { return formatDate(ymd); }) .transform_error([](const std::string& error) -> std::string { return \"Error encountered: \" + error; }) .or_else([](const std::string& error) { std::cout << \"Handled Error: \" << error << '\\n'; return std::expected<std::string, std::string>(std::unexpected(error)); }); if (result) std::cout << \"Formatted Date: \" << *result << '\\n'; else std::cout << \"Final Error: \" << result.error() << '\\n'; }\n\nRun @Compiler Explorer\n\n  * Check Weekend and Pass Date: Using and_then, the date is checked if it\u2019s a weekend. If not, it passes the date forward.\n  * Format Date with transform: The transform function is applied only if the previous and_then succeeds. It converts the std::chrono::year_month_day to a formatted string.\n  * Customize Error Message with transform_error: If any error occurs (either parsing error or weekend error), the transform_error function modifies the error message to add additional context or change its format.\n  * Final Error Handling with or_else: Finally, or_else is used to handle or log any resulting error after transformations. This step ensures that any error, transformed or not, is addressed appropriately and could also include logic to recover or default if desired.\n\n## Summary\n\nIn this text, we explored some handy ways of working with the std::expected\ntype. Thanks to monadic extensions, you can wrap the logic into a chain of\ncallbacks/lambdas and avoid duplicate error checking.\n\nThis is a new style and requires some training, but it\u2019s a very interesting\nand promising option.\n\nAlso, have a look at my previous article on optional: How to Use Monadic\nOperations for std::optional in C++23 - C++ Stories.\n\nBut there\u2019s more! While the text showed a couple of examples, in the next blog\npost, we\u2019ll have a look at some existing code and see where std::expected is\nused in real projects.\n\n#### Back to you\n\n  * Have you tried monadic extensions for std::expected or std::optional?\n  * Do you prefer that new style or the regular \u201cif/else\u201d approach?\n\nShare your comments below.\n\nI've prepared a valuable bonus if you're interested in Modern C++! Learn all\nmajor features of recent C++ Standards! Check it out here:\n\nDownload a free copy of C++20/C++17 Ref Cards!\n\n#### Similar Articles:\n\n  * Understand internals of std::expected\n  * Using std::expected from C++23\n  * Parsing Numbers At Compile Time with C++17, C++23, and C++26\n  * Six Handy Operations for String Processing in C++20/23\n  * How to use std::span from C++20\n\nTags: cpp, cpp23, standard library, vocabulary types,\n\nTable of Contents\n\n#### See My Books:\n\n#### Recent Articles\n\nstd::expected - Monadic Extensions\n\nUnderstand internals of std::expected\n\nUsing std::expected from C++23\n\n\u00a9 2011-2022, Bartlomiej Filipek Disclaimer: Any opinions expressed herein are\nin no way representative of those of my employers. All data and information\nprovided on this site is for informational purposes only. I try to write\ncomplete and accurate articles, but the web-site will not be liable for any\nerrors, omissions, or delays in this information or any losses, injuries, or\ndamages arising from its display or use. This site contains ads or referral\nlinks, which provide me with a commission. Thank you for your understanding.\nBuilt on the Hugo Platform!\n\n", "frontpage": false}
