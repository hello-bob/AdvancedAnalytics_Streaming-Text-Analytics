{"aid": "40154145", "title": "Autotuner: How to Speed Up Your Rails App", "url": "https://railsatscale.com/2024-04-24-autotuner-how-to-speed-up-your-rails-app/", "domain": "railsatscale.com", "votes": 1, "user": "thunderbong", "posted_at": "2024-04-25 06:30:26", "comments": 0, "source_title": "Autotuner: How to Speed Up Your Rails App", "source_text": "Autotuner: How to Speed Up Your Rails App | Rails at Scale\n\nRails at Scale\n\n# Autotuner: How to Speed Up Your Rails App\n\n2024-04-24 \u2022 Peter Zhu\n\n> This article was adapted from my Rails World talk \u201cRails and the Ruby\n> Garbage Collector: How to Speed Up Your Rails App\u201d.\n\nRuby\u2019s garbage collector is designed to be adaptable, scaling from short Ruby\nscripts to running apps that serve millions of requests per second. While it\u2019s\ndesigned to be adaptable, it may not work optimally for every use case. For\nthis reason, Ruby\u2019s garbage collector supports many (19 at the time of\nwriting) parameters that can be used to tune it. However, the use of these\nparameters requires knowledge of how the garbage collector works on the\ninside. It also doesn\u2019t help that there are changes to the garbage collector\nin every major Ruby release, meaning that some of these parameters may become\ndeprecated and new ones may be added. This implies that you\u2019ll need to\nunderstand the changes and might have to retune the garbage collector to\nregain optimal performance. This complexity often deters Rails developers from\ntuning the garbage collector.\n\nThat\u2019s why we created the Autotuner gem, which analyzes the traffic of your\nRails app and gives you suggestions to personalize the garbage collector for\nyour app. Setting it up should be very straightforward by following the two\nsteps in the readme. In this article, we\u2019ll delve into the motivations behind\ncreating this gem, its workings, and our experimentation process with garbage\ncollector tuning at Shopify.\n\n# Motivations for creating Autotuner\n\nThere are many strategies to speed up a Rails app, such as getting faster\nservers, improving database queries, or moving more logic into background\njobs. However, your app might be spending more time in the garbage collector\nthan you think. In Jean Boussier\u2019s blog post about tuning Ruby\u2019s garbage\ncollector in Shopify\u2019s monolith, tuning the garbage collector decreased the\n99.9th percentile time in garbage collector by 87%, from over 1 second to 0.15\nseconds. Similarly, in Storefront Renderer, tuning the garbage collector\ndecreased the 99.9th percentile time in garbage collector by 59%, which\ntranslated to a 18% reduction in response times.\n\nThe garbage collector often disproportionately affects tail latency (e.g. 99th\nor 99.9th percentile) because it doesn\u2019t usually run very often (if it does,\nyou\u2019ve got another problem!). This is often caused by a major garbage\ncollection cycle (see my blog post if you\u2019re not familiar with the difference\nbetween minor and major garbage collection cycles). Surprisingly, most of the\nmajor garbage collection cycles run in a Rails app are actually unnecessary.\nHowever, due to various heuristics aimed at optimizing other workloads and\nreducing memory usage, Ruby\u2019s garbage collector ends up running garbage\ncollection cycles much more than necessary. If you know which garbage\ncollector parameters to tune, this is a low-hanging fruit that can\nsignificantly improve the response times of your Rails app.\n\nSuppose you\u2019ve figured out how to tune the garbage collector and have\noptimized it for your Rails app. The next time you upgrade to a new major\nrelease of Ruby, which might be less than a year later, you will need to\nunderstand what has changed in the garbage collector and might have to retune\nit to regain optimal performance. Sometimes, an outdated tuning configuration\nmight even slow down your Rails app!\n\n# How Autotuner works\n\nAutotuner functions as a Rack plugin, collecting data about the garbage\ncollector before and after each request, as well as the time taken to process\nthe request. After the request completes, it passes all of this data to a list\nof heuristics, each of which knows about a particular strategy to optimize GC\ntime.\n\nEach heuristic can select the necessary data and may store it to identify\ntrends. For example, let\u2019s take a closer look at the HeapSizeWarmup heuristic,\nwhich suggests sizes for the memory heaps after your app has warmed up and\nreached peak performance. During bootup, your app allocates many objects,\ncausing Ruby\u2019s garbage collector to grow the heap, which means that garbage\ncollection cycles will be ran frequently. This is bad for performance as\nRuby\u2019s garbage collector is stop-the-world, meaning that execution of Ruby\ncode is paused while the garbage collector runs. In a Rails app, this\ntranslates to longer response times during the warmup phase until the heap\nstabilizes. The following diagram illustrates this:\n\nThe HeapSizeWarmup heuristic records the time taken for each request and the\nsize of the heaps to determine when the request time has plateaued and peak\nperformance has been achieved. It then suggests values to configure the heaps\nin Ruby to this size so the heaps will no longer grow at bootup and instead be\nimmediately grown to that size.\n\n# Experimenting with garbage collector tuning\n\n## Collecting metrics\n\nWhen performing these experiments, it\u2019s critical to understand the\nbottlenecks, identify the metrics we want to improve, and know how to measure\nthe improvements. The callback Autotuner.metrics_reporter provided in\nAutotuner is a good starting point. This is a callback that will report\nmetrics after every request such as the time taken to process the request, the\ntime spent in the garbage collector, the number of major and minor garbage\ncollection cycles ran, and the size of the Ruby heap.\n\nUsing these metrics, we can determine whether tuning the garbage collector is\nworth it or not. There are a few common things to optimize:\n\n  * Bootup performance: If your app is slower at boot and spending more time in the garbage collector, then garbage collector tuning may help your app reach peak performance faster.\n  * Average response times: If your app is spending a high average proportion of the request time in the garbage collector, then tuning the garbage collector can reduce the frequency of garbage collection cycles and improve average response times.\n  * Extreme (99th, 99.9th percentile) response times: If your app is spending a higher proportion of the request time in the garbage collector in some of the longest requests, then tuning the garbage collector can reduce the impact of the garbage collector on these requests, and bring those extreme response times down.\n\n## How we experiment with garbage collector tuning at Shopify\n\nNot all suggestions from Autotuner will positively impact performance. Some of\nthem will be trade-offs. A common one will be trading better average garbage\ncollector and response times while making extremes like 99th or 99.9th\npercentile worse. A common example of how this can happen is that some tuning\ndecreases the frequency of garbage collection cycles. Running less garbage\ncollection cycles often means that the performance will be better on average,\nbut when a garbage collection cycle does run, it may do more work as there\nmight be more dead objects. Depending on your workloads and requirements, you\nmight not want to sacrifice extreme performance for better average\nperformance.\n\nWe\u2019ve found that response times can vary significantly due to factors like\nload, traffic patterns, and database and cache response times. Because of\nthis, it\u2019s difficult to accurately compare the impacts of the tuning over two\ndifferent time periods.\n\nGiven these reasons, we conduct tests on a small portion of production\ntraffic, dividing it into three groups:\n\n  1. Untuned: this group has no garbage collector tuning applied. This is a control group to compare the final tuning improvements.\n  2. Stable: this group has garbage collector tuning that yields a positive performance improvement.\n  3. Experimental: this group is where we apply the tuning suggestions from Autotuner one-by-one.\n\nFor a high-traffic app, we select around 1-5% of servers for each of the three\ngroups. For a low-traffic app, we select a higher proportion to reduce data\nvariance. Garbage collector tuning is a relatively safe experiment to run; it\nwill usually not cause incidents or significant degradation in performance, so\nit isn\u2019t too risky to run on a larger portion of traffic.\n\nWe follow this process for experimenting with garbage collector tuning:\n\n  1. Pick one tuning suggestion from Autotuner and apply it on the experimental group.\n  2. Compare the various performance metrics between the experimental group and stable group over a period of several days to a week.\n  3. If the tuning provides a positive performance improvement, apply this tuning suggestion to the stable group as well.\n  4. If the tuning does not provide a positive performance improvement, or gives a trade-off that you do not want, then discard the tuning configuration from the experimental group.\n  5. Repeat step 1 while there\u2019s a tuning suggestion that has not been tried yet.\n  6. Compare the performance between the stable and the untuned groups for total performance improvement.\n\nAfter this process, your Rails app should ideally be faster! You can now\nremove Autotuner and redo this experiment when you upgrade Ruby versions or if\nyour app changes significantly.\n\n# Conclusion\n\nRuby\u2019s garbage collector is designed to adapt to various workloads and balance\nmemory usage and performance. It often results in good performance, but not\nthe best performance. Garbage collector tuning allows us to optimize the\ngarbage collector for our specific workload and the metrics we care about.\nHowever, for many Rails developers, Ruby\u2019s garbage collector is a black box,\nmaking it difficult to find ways to tune it. The Autotuner gem is designed to\nassist you in finding ways to enhance the garbage collector performance of\nyour Rails apps. In this blog post, we\u2019ve explored the motivations for tuning\nthe garbage collector, how Autotuner works, and how to experiment with changes\nfrom Autotuner. For complete documentation on how to set up Autotuner, check\nthe readme.\n\nSubscribe\n\n  * Shopify Engineering\n\nThe Ruby and Rails Infrastructure team at Shopify exists to help ensure that\nRuby and Rails are 100-year tools that will continue to merit being our\ntoolchain of choice.\n\nThis work is licensed under a Creative Commons Attribution-NonCommercial-\nShareAlike 4.0 International License.\n\n", "frontpage": false}
