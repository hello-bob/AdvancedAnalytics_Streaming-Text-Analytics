{"aid": "40217418", "title": "Asking 3 Different AI models to rewrite the same Swift function", "url": "https://www.swiftjectivec.com/asking-ai-to-refactor-my-swift-code/", "domain": "swiftjectivec.com", "votes": 1, "user": "jordanmorgan10", "posted_at": "2024-04-30 22:50:41", "comments": 0, "source_title": "Asking AI to Refactor Swift Code", "source_text": "Asking AI to Refactor Swift Code | Swiftjective-C\n\n[SC]()\n\niOS. Apple. Indies. Plus Things.\n\nLink copied!\n\nShare it anywhere now.\n\n## Asking AI to Refactor Swift Code\n\n// Written by Jordan Morgan // Apr 29th, 2024 // Read it in about 5 minutes //\nRE: The Indie Dev Diaries\n\nThis post is brought to you by Emerge Tools, the best way to build on mobile.\n\nRecently I\u2019ve been adding quality-of-life platform fixes to Elite Hoops. Among\nthose? Home Screen Quick Actions.\n\nIt\u2019s been a minute since I\u2019ve created dynamic ones, so I forgot how much\nbookkeeping can be involved. I wanted a dynamic quick action for each recently\nviewed team in Elite Hoops. But, that also means that...\n\n  * I need to add it to UIApplication.shared.shortcutItems when one is opened.\n  * And update it when the name of a team could be changed.\n  * And remove it when it\u2019s been deleted.\n  * And write it in such a way to where when I add cloud syncing, it\u2019ll stay in lockstep with any changes from the server.\n\nSo, one of those hard easy things.\n\nlet concatenatedThoughts = \"\"\"\n\nIn fact, the last time I wrote Home Scren Quick Actions was for the chapter in\nmy book series. Which, as it were, I leaned upon heavily to implement these.\nI'm in the middle of releaseing an update for it now, do check it out if you\nhaven't yet. Five books, one price forever.\n\n\"\"\"\n\nTo that end, here is the function I initially wrote:\n\n    \n    \n    // This function is kind of hard to read - can you make it simpler? func updateQuickActionsForCourts() { if appSettings.quickActionCourtsToAdd.isEmpty && appSettings.quickActionCourtsToRemove.isEmpty { return } var quickActions: [UIApplicationShortcutItem] = UIApplication.shared.shortcutItems ?? [] // Any removals? var removalIndices: [Int] = [] appSettings.quickActionCourtsToRemove.forEach { courtIDToRemove in for (index, item) in quickActions.enumerated() { let courtID = item.userInfo?[\"courtID\"] as? Int64 ?? 0 if courtIDToRemove == courtID { removalIndices.append(index) } } } removalIndices.forEach { removalIndex in quickActions.remove(at: removalIndex) } // Any additions? appSettings.quickActionCourtsToAdd.forEach { court in if quickActions.filter({ item in let courtID = item.userInfo?[\"courtID\"] as? Int64 ?? 0 return courtID == court.id }).isEmpty { quickActions.append(court.quickAction()) } } UIApplication.shared.shortcutItems = quickActions.reversed() appSettings.quickActionCourtsToAdd.removeAll() appSettings.quickActionCourtsToRemove.removeAll() }\n\nIt\u2019s ugly, but it works. So, I began to wonder \u2014 how would AI tools suggest I\nchange it. Below are the results, all given the same prompt.\n\n### The Prompt\n\n    \n    \n    // This function is kind of hard to read - can you make it simpler? /* Then I included the function above right here */\n\n### chatGPT 4\n\nFirst off, the institutional choice. OpenAI\u2019s chatGPT using chatGPT 4:\n\n    \n    \n    /* Certainly! Here's a simplified and refactored version of your Swift function. I've added comments for clarity and improved the readability of the code by separating the removal and addition processes into separate functions: */ func updateQuickActionsForCourts() { guard !appSettings.quickActionCourtsToAdd.isEmpty || !appSettings.quickActionCourtsToRemove.isEmpty else { return } var quickActions = UIApplication.shared.shortcutItems ?? [] // Process removals quickActions = removeCourts(from: quickActions) // Process additions quickActions = addCourts(to: quickActions) // Update quick actions in reverse order and clear settings UIApplication.shared.shortcutItems = quickActions.reversed() clearCourtSettings() } /// Removes courts from the quick actions list based on app settings. private func removeCourts(from quickActions: [UIApplicationShortcutItem]) -> [UIApplicationShortcutItem] { let courtIDsToRemove = Set(appSettings.quickActionCourtsToRemove) return quickActions.filter { item in guard let courtID = item.userInfo?[\"courtID\"] as? Int64 else { return true } return !courtIDsToRemove.contains(courtID) } } /// Adds courts to the quick actions list based on app settings. private func addCourts(to quickActions: [UIApplicationShortcutItem]) -> [UIApplicationShortcutItem] { var updatedQuickActions = quickActions appSettings.quickActionCourtsToAdd.forEach { court in let exists = updatedQuickActions.contains { item in let courtID = item.userInfo?[\"courtID\"] as? Int64 ?? 0 return courtID == court.id } if !exists { updatedQuickActions.append(court.quickAction()) } } return updatedQuickActions } /// Clears the lists of courts to add or remove from app settings. private func clearCourtSettings() { appSettings.quickActionCourtsToAdd.removeAll() appSettings.quickActionCourtsToRemove.removeAll() } /* Explanation of Changes: Guard Statement: A guard statement at the start of the function checks whether any updates are needed, improving readability by reducing nesting. Separation of Concerns: I extracted the logic for removing and adding courts into separate functions, removeCourts and addCourts. This makes the main function more concise and each piece of functionality easier to maintain. Filter and Contains: The removal function uses filter and contains to efficiently remove items. This eliminates the need for finding indices and then removing by index, which can introduce errors or require additional adjustments in indexing after each removal. Function Encapsulation: Moving specific functionality into private helper functions clarifies the main function's flow and isolates each specific task. Reverse Logic Consolidation: The reversal of the quick actions list is kept at the point where the list is updated in the UIApplication, making the order manipulation more visible. This refactor should make your function easier to read, maintain, and modify in the future. */\n\nI\u2019ve found that chatGPT is more verbose in its response. Not only does it\nwrite code, but it tries to explain it to you. This code is nice if you\u2019re the\ntype of who believes each function should be a single thing, and not much\nmore. Of all the choices, when I go back and pretty up my code (because we\nalways go back, right?!) \u2014 this is probably the closet to how I tend to author\nit.\n\n### meta.ai\n\nThe new kid on the block, personifying the \u201cif it\u2019s free you are the product\u201d\napproach is Meta\u2019s newly minted meta.ai. Here\u2019s how it refactored my code:\n\n    \n    \n    // Here's a simplified version of the function: func updateQuickActionsForCourts() { guard !(appSettings.quickActionCourtsToAdd.isEmpty && appSettings.quickActionCourtsToRemove.isEmpty) else { return } var quickActions = UIApplication.shared.shortcutItems ?? [] // Remove quick actions quickActions.removeAll { item in appSettings.quickActionCourtsToRemove.contains(item.userInfo?[\"courtID\"] as? Int64 ?? 0) } // Add quick actions appSettings.quickActionCourtsToAdd.forEach { court in if !quickActions.contains(where: { item in item.userInfo?[\"courtID\"] as? Int64 == court.id }) { quickActions.append(court.quickAction()) } } UIApplication.shared.shortcutItems = quickActions.reversed() appSettings.quickActionCourtsToAdd.removeAll() appSettings.quickActionCourtsToRemove.removeAll() } /* This version uses more concise and expressive syntax, such as guard statements, removeAll and contains methods, and more. It should be easier to read and understand. Let me know if you have any questions! */\n\nWhat I like about this is how much simpler it is to read. Even though I most\nwrite code like chatGPT 4, I think I can read Meta\u2019s take on it easier.\n\n### Claude by Anthropic\n\nFinally, there\u2019s Claude. I consider it the last of the \u201cbig three\u201d, at least\nin my sphere of influence. I should note, this is not Anthropic\u2019s best model \u2014\nthat\u2019s Claude 3 Opus, but anyways here is what I got:\n\n    \n    \n    // Here's a simplified version of the updateQuickActionsForCourts function: func updateQuickActionsForCourts() { guard !appSettings.quickActionCourtsToAdd.isEmpty || !appSettings.quickActionCourtsToRemove.isEmpty else { return } var quickActions = UIApplication.shared.shortcutItems ?? [] // Remove unwanted quick actions quickActions = quickActions.filter { action in guard let courtID = action.userInfo?[\"courtID\"] as? Int64 else { return true } return !appSettings.quickActionCourtsToRemove.contains(courtID) } // Add new quick actions let existingCourtIDs = quickActions.compactMap { $0.userInfo?[\"courtID\"] as? Int64 } let newQuickActions = appSettings.quickActionCourtsToAdd .filter { !existingCourtIDs.contains($0.id) } .map { $0.quickAction() } quickActions.append(contentsOf: newQuickActions) UIApplication.shared.shortcutItems = quickActions appSettings.quickActionCourtsToAdd.removeAll() appSettings.quickActionCourtsToRemove.removeAll() } /* Here are the main changes: - The early return is moved to the beginning of the function to avoid unnecessary work if there are no actions to add or remove. - The removal of unwanted quick actions is done using the filter method, which creates a new array containing only the elements that satisfy the condition. - The addition of new quick actions is done by first creating an array of existing court IDs, then filtering the appSettings.quickActionCourtsToAdd array to remove any courts that already have a quick action, and finally mapping the remaining courts to their corresponding quick actions. - The append(contentsOf:) method is used to add the new quick actions to the existing array in a single operation. - The reversed() call has been removed since it is unnecessary. These changes make the code more concise and easier to read, while preserving the original functionality. */\n\nNot bad, like chatGPT 4, it tends to explain in detail what its changed are,\nand why it made them. And, like Meta, it\u2019s solution is still within one\nfunction, but greatly simplified.\n\n### Final Thoughts\n\nI offer no verdict in this post other than...it\u2019s interesting to see how large\nlanguage models reason about code. All three models quickly pointed out an\nearly guard statement, for example. And, each one tends to lean into language\nfeatures, such as Swift\u2019s functional aspects. As it should, I presume.\n\nSo where did I land?\n\nI just left my original, ugly function in and wrote this post \ud83d\ude07.\n\nUntil next time \u270c\ufe0f.\n\n\u00b7\u00b7\u00b7\n\nSpot an issue, anything to add?\n\nReach Out.\n\nIntroducing Elite Soccer Club \u2192\n\n", "frontpage": false}
