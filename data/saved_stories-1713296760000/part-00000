{"aid": "40051763", "title": "Effect 3.0: Production-Grade TypeScript", "url": "https://effect.website/blog/effect-3.0", "domain": "effect.website", "votes": 14, "user": "MichaelArnaldi", "posted_at": "2024-04-16 13:43:49", "comments": 0, "source_title": "Effect 3.0 \u2013 Effect Blog", "source_text": "Effect 3.0 \u2013 Effect Blog\n\nDocsBlog\n\nGitHubDiscord\n\nAuthor\n\nMichael Arnaldi\n\nChief Executive Officer\n\nBlog\n\n## Effect 3.0\n\nApr 16th, 2024\n\n## #Announcement\n\nEffect is finally stable!\n\nI am pleased to announce that after 5 years of work and 3+ years of production\nusage we are ready to release Effect 3.0, the first stable release of the core\nof the Effect Ecosystem.\n\nStarting with 3.0 the main package effect will follow semantic versioning:\n\n  1. major releases will include breaking changes\n  2. minor releases will include new features and new modules\n  3. patch releases will include bug-fixes\n\nWe do not expect new major releases in the near future, we will release a new\nmajor when a significant number of API improvements have been made and after a\nsubstantial period of feedback.\n\n## #Quickstart\n\nEffect is a TypeScript library that works in every runtime & project, to start\nusing it you can:\n\n    \n    \n    bash\n    \n    npm install effect\n    \n    \n    bash\n    \n    npm install effect\n\nAnd follow the quickstart guide in our documentation.\n\nIf you prefer instead to have a look at a fully working & effect-native app\nwe've prepared a demo cli app that you can directly open in Gitpod or locally\n(if you prefer), you'll need to provide an OpenAI API Key in order to\nintegrate with the OpenAI API. The demo app allows you to train a model via\nembeddings from a set of files and then allows you to prompt the trained model\nwith questions.\n\nThe same app was used in the Advanced Workshop held in Vienna by Maxwell\nBrown, you can start to follow the workshop from the material knowing that\nrecordings will be made public soon, together with the Beginner/Intermediate\nWorkshop held by Ethan Niser.\n\nIf you want to have a glimpse at the conference, we just published the opening\nkeynote of the day by Johannes Schickling who tells us how he likes to write\nProduction-Grade Software in TypeScript with Effect:\n\n## #The Problem\n\nTypeScript is quickly becoming the de-facto standard for writing business\napplications. Thanks to the evolution of JavaScript runtimes it is now very\ncommon to write 90% (or more) of your application code in TypeScript across\nboth front-end and back-end.\n\nGitHub\n\n@github\n\n\u00b7Follow\n\nReplying to @github\n\nIn 2023, TypeScript overtook Java for the first time as the third most popular\nlanguage across OSS projects on GitHub with 37% growth of its user base.\nJavaScript, meanwhile, continues to top the charts. Read more in our Octoverse\nreport \ud83d\udc49 github.blog/2023-11-08-the...\n\n6:32 PM \u00b7 Mar 5, 2024\n\n262\n\nReply\n\nRead 13 replies\n\nBut the JavaScript (and TypeScript) we all know and love wasn't made for this,\nit started as a scripting language to automate a few simple UI tasks.\n\nWhen developing in TypeScript to write production-grade software we feel a\nlack of features, namely:\n\n### #Error Management\n\nPainful. Even when using TS we often have to deal with unknown error types\nthat make our handling logic a guessing game.\n\n### #Dependency Injection\n\nTotally missing. Which makes our code hard to test and testing becomes reliant\non the monkey-patching of modules.\n\n### #Data Modelling\n\nChallenging and mostly unsafe. TypeScript types don't exist at runtime, and if\nwe don't properly check the edges of our program (where data comes in and goes\nout) we rely on a lie. All seems good and safe but ready to explode at any\npoint in time.\n\n### #Interruption\n\nAdded to the language as an afterthought. Passing AbortSignal around manually\nmakes our code a nightmere.\n\n### #Tracing & Metrics\n\nNon-existent. When using libraries such as opentelemetry we have to compromise\non code expressivity, and we end up wrapping everything with noisy try-catch\nstatements that only hurt the readability of our code.\n\n### #Logging\n\nUsually implemented as a few custom calls to console.log and doesn't consider\ndifferent severity levels. Even when it does with console.info (and similar),\nthere is no global switch to set the current log level of a program.\n\n### #State of JS Survey\n\nWhen asked about the Pain Points of JavaScript, in the latest State of JS\nsurvey people say:\n\nAnd when asked about What they feel missing they say:\n\nIn short, TS doesn't have a strong standard library that addresses the\nproblems of Production Grade Software. We end up with thousands of small npm\npackages that fill the holes in a way that doesn't quite compose, making our\ncode horrendous (albeit working).\n\n## #The Solution\n\nThat's where Effect comes in! Made from day 1 with production grade software\nin mind, Effect is the missing piece in the TypeScript puzzle. It is meant to\nbe the standard library that we all love and use to build our code. In other\nwords, If TypeScript was created to be JavaScript that scales, Effect was\ncreated to be TypeScript that scales.\n\nIn Effect everything that was mentioned so far is supported natively, without\nbeing an afterthought.\n\nLet's see some code, before and after Effect, by analyzing a single HTTP call.\n\n### #Plain TS code\n\n    \n    \n    ts\n    \n    interface Todo {\n    \n    readonly id: number\n    \n    readonly userId: number\n    \n    readonly title: string\n    \n    readonly completed: boolean\n    \n    }\n    \n    const getTodo = async (id: number): Promise<Todo> => {\n    \n    const response = await fetch(`/todos/${id}`)\n    \n    const todo = await response.json()\n    \n    return todo\n    \n    }\n    \n    \n    ts\n    \n    interface Todo {\n    \n    readonly id: number\n    \n    readonly userId: number\n    \n    readonly title: string\n    \n    readonly completed: boolean\n    \n    }\n    \n    const getTodo = async (id: number): Promise<Todo> => {\n    \n    const response = await fetch(`/todos/${id}`)\n    \n    const todo = await response.json()\n    \n    return todo\n    \n    }\n\nEven going beyond the fault of assuming the todo returned by the API\nnecessarily matches the Todo interface, the code above is kind of unsafe for\nother less obvious reasons as well. For example, by calling it we have no idea\nfor what reasons it may fail.\n\nIf we were to add such a requirement our code would become:\n\n    \n    \n    ts\n    \n    async function getTodo(\n    \n    id: number\n    \n    ): Promise<\n    \n    | { ok: true; todo: Todo }\n    \n    | { ok: false; error: \"InvalidJson\" | \"RequestFailed\" }\n    \n    > {\n    \n    try {\n    \n    const response = await fetch(`/todos/${id}`)\n    \n    if (!response.ok) throw new Error(\"Not OK!\")\n    \n    try {\n    \n    const todo = await response.json()\n    \n    return { ok: true, todo }\n    \n    } catch (jsonError) {\n    \n    return { ok: false, error: \"InvalidJson\" }\n    \n    }\n    \n    } catch (error) {\n    \n    return { ok: false, error: \"RequestFailed\" }\n    \n    }\n    \n    }\n    \n    \n    ts\n    \n    async function getTodo(\n    \n    id: number\n    \n    ): Promise<\n    \n    | { ok: true; todo: Todo }\n    \n    | { ok: false; error: \"InvalidJson\" | \"RequestFailed\" }\n    \n    > {\n    \n    try {\n    \n    const response = await fetch(`/todos/${id}`)\n    \n    if (!response.ok) throw new Error(\"Not OK!\")\n    \n    try {\n    \n    const todo = await response.json()\n    \n    return { ok: true, todo }\n    \n    } catch (jsonError) {\n    \n    return { ok: false, error: \"InvalidJson\" }\n    \n    }\n    \n    } catch (error) {\n    \n    return { ok: false, error: \"RequestFailed\" }\n    \n    }\n    \n    }\n\nLets say that it is good enough, this still does not represent the rest of the\nactual requirements that you see in the wild, so now without going step-by-\nstep, a realistic feature set would also include:\n\n  * the api call is retried using an exponential backoff policy, that avoids hurting an already faulty backend\n  * the code should be instrumented for telemetry - such that a connected telemetry backend (such as Tempo / Jaeger / Honeycomb / Datadog / etc) can show exactly what fails, when it fails, why it fails and exactly how long every step takes.\n  * the code should be compatible with interruption (aka graceful shutdown). When the response is no longer needed, we'd like our request to be interrupted.\n\nWe'd end up with:\n\n    \n    \n    ts\n    \n    const tracer = Otel.trace.getTracer(\"todos\")\n    \n    function getTodo(\n    \n    id: number\n    \n    {\n    \n    retries = 3,\n    \n    retryBaseDelay = 1000,\n    \n    signal,\n    \n    }: {\n    \n    retries?: number\n    \n    retryBaseDelay?: number\n    \n    signal?: AbortSignal\n    \n    },\n    \n    ): Promise<\n    \n    | { ok: true; todo: Todo }\n    \n    | {\n    \n    ok: false\n    \n    error: \"InvalidJson\" | \"RequestFailed\" | \"Timeout\"\n    \n    }\n    \n    > {\n    \n    return tracer.startActiveSpan(\n    \n    \"getTodo\",\n    \n    { attributes: { id } },\n    \n    async (span) => {\n    \n    try {\n    \n    const result = await execute(0)\n    \n    if (result.ok) {\n    \n    span.setStatus({ code: Otel.SpanStatusCode.OK })\n    \n    } else {\n    \n    span.setStatus({\n    \n    code: Otel.SpanStatusCode.ERROR,\n    \n    message: result.error,\n    \n    })\n    \n    }\n    \n    return result\n    \n    } finally {\n    \n    span.end()\n    \n    }\n    \n    },\n    \n    )\n    \n    async function execute(attempt: number): Promise<\n    \n    | { ok: true; todo: Todo }\n    \n    | {\n    \n    ok: false\n    \n    error: \"InvalidJson\" | \"RequestFailed\" | \"Timeout\"\n    \n    }\n    \n    > {\n    \n    try {\n    \n    const controller = new AbortController()\n    \n    setTimeout(() => controller.abort(), 1000)\n    \n    signal?.addEventListener(\"abort\", () =>\n    \n    controller.abort(),\n    \n    )\n    \n    const response = await fetch(`/todos/${id}`, {\n    \n    signal: controller.signal,\n    \n    })\n    \n    if (!response.ok) throw new Error(\"Not OK!\")\n    \n    try {\n    \n    const todo = await response.json()\n    \n    return { ok: true, todo }\n    \n    } catch (jsonError) {\n    \n    if (attempt < retries) {\n    \n    throw jsonError // jump to retry\n    \n    }\n    \n    return { ok: false, error: \"InvalidJson\" }\n    \n    }\n    \n    } catch (error) {\n    \n    if ((error as Error).name === \"AbortError\") {\n    \n    return { ok: false, error: \"Timeout\" }\n    \n    } else if (attempt < retries) {\n    \n    const delayMs = retryBaseDelay * 2 ** attempt\n    \n    return new Promise((resolve) =>\n    \n    setTimeout(\n    \n    () => resolve(execute(attempt + 1)),\n    \n    delayMs,\n    \n    ),\n    \n    )\n    \n    }\n    \n    return { ok: false, error: \"RequestFailed\" }\n    \n    }\n    \n    }\n    \n    }\n    \n    \n    ts\n    \n    const tracer = Otel.trace.getTracer(\"todos\")\n    \n    function getTodo(\n    \n    id: number\n    \n    {\n    \n    retries = 3,\n    \n    retryBaseDelay = 1000,\n    \n    signal,\n    \n    }: {\n    \n    retries?: number\n    \n    retryBaseDelay?: number\n    \n    signal?: AbortSignal\n    \n    },\n    \n    ): Promise<\n    \n    | { ok: true; todo: Todo }\n    \n    | {\n    \n    ok: false\n    \n    error: \"InvalidJson\" | \"RequestFailed\" | \"Timeout\"\n    \n    }\n    \n    > {\n    \n    return tracer.startActiveSpan(\n    \n    \"getTodo\",\n    \n    { attributes: { id } },\n    \n    async (span) => {\n    \n    try {\n    \n    const result = await execute(0)\n    \n    if (result.ok) {\n    \n    span.setStatus({ code: Otel.SpanStatusCode.OK })\n    \n    } else {\n    \n    span.setStatus({\n    \n    code: Otel.SpanStatusCode.ERROR,\n    \n    message: result.error,\n    \n    })\n    \n    }\n    \n    return result\n    \n    } finally {\n    \n    span.end()\n    \n    }\n    \n    },\n    \n    )\n    \n    async function execute(attempt: number): Promise<\n    \n    | { ok: true; todo: Todo }\n    \n    | {\n    \n    ok: false\n    \n    error: \"InvalidJson\" | \"RequestFailed\" | \"Timeout\"\n    \n    }\n    \n    > {\n    \n    try {\n    \n    const controller = new AbortController()\n    \n    setTimeout(() => controller.abort(), 1000)\n    \n    signal?.addEventListener(\"abort\", () =>\n    \n    controller.abort(),\n    \n    )\n    \n    const response = await fetch(`/todos/${id}`, {\n    \n    signal: controller.signal,\n    \n    })\n    \n    if (!response.ok) throw new Error(\"Not OK!\")\n    \n    try {\n    \n    const todo = await response.json()\n    \n    return { ok: true, todo }\n    \n    } catch (jsonError) {\n    \n    if (attempt < retries) {\n    \n    throw jsonError // jump to retry\n    \n    }\n    \n    return { ok: false, error: \"InvalidJson\" }\n    \n    }\n    \n    } catch (error) {\n    \n    if ((error as Error).name === \"AbortError\") {\n    \n    return { ok: false, error: \"Timeout\" }\n    \n    } else if (attempt < retries) {\n    \n    const delayMs = retryBaseDelay * 2 ** attempt\n    \n    return new Promise((resolve) =>\n    \n    setTimeout(\n    \n    () => resolve(execute(attempt + 1)),\n    \n    delayMs,\n    \n    ),\n    \n    )\n    \n    }\n    \n    return { ok: false, error: \"RequestFailed\" }\n    \n    }\n    \n    }\n    \n    }\n\nBy this time I challenge every human being to look at the code and tell me if\nit even works according to spec, let alone being confident in making any\nchange to it. Also we still haven't solved the issue with data validation, for\nthat we might want to add a dependency to Zod (or similar) and add a\nvalidation step (with subsequent typed error).\n\n### #Effect code\n\nBy using Effect the above mess becomes just 25 lines of highly declarative\ncode (imports & formatting included):\n\n    \n    \n    ts\n    \n    import { HttpClient } from \"@effect/platform\"\n    \n    import type { Cause } from \"effect\"\n    \n    import { Effect, Schedule } from \"effect\"\n    \n    export const getTodo: (\n    \n    id: number\n    \n    ) => Effect.Effect<\n    \n    unknown,\n    \n    | HttpClient.error.HttpClientError\n    \n    | Cause.TimeoutException\n    \n    > = (\n    \n    id: number\n    \n    ) =>\n    \n    HttpClient.request.get(`/todos/${id}`).pipe(\n    \n    HttpClient.client.fetchOk,\n    \n    HttpClient.response.json,\n    \n    Effect.timeout(\"1 seconds\"),\n    \n    Effect.retry(\n    \n    Schedule.exponential(1000).pipe(\n    \n    Schedule.compose(Schedule.recurs(3))\n    \n    )\n    \n    ),\n    \n    Effect.withSpan(\"getTodo\", { attributes: { id } })\n    \n    )\n    \n    \n    ts\n    \n    import { HttpClient } from \"@effect/platform\"\n    \n    import type { Cause } from \"effect\"\n    \n    import { Effect, Schedule } from \"effect\"\n    \n    export const getTodo: (\n    \n    id: number\n    \n    ) => Effect.Effect<\n    \n    unknown,\n    \n    | HttpClient.error.HttpClientError\n    \n    | Cause.TimeoutException\n    \n    > = (\n    \n    id: number\n    \n    ) =>\n    \n    HttpClient.request.get(`/todos/${id}`).pipe(\n    \n    HttpClient.client.fetchOk,\n    \n    HttpClient.response.json,\n    \n    Effect.timeout(\"1 seconds\"),\n    \n    Effect.retry(\n    \n    Schedule.exponential(1000).pipe(\n    \n    Schedule.compose(Schedule.recurs(3))\n    \n    )\n    \n    ),\n    \n    Effect.withSpan(\"getTodo\", { attributes: { id } })\n    \n    )\n\nIf we unpack each piece in its own code block and allow for type inference it\nbecomes even simpler to read and understand:\n\n    \n    \n    ts\n    \n    import { HttpClient } from \"@effect/platform\"\n    \n    import { Effect, Schedule } from \"effect\"\n    \n    const retryPolicy = Schedule.exponential(1000).pipe(\n    \n    Schedule.compose(Schedule.recurs(3))\n    \n    )\n    \n    const httpCall = (id: number) =>\n    \n    HttpClient.request.get(`/todos/${id}`).pipe(\n    \n    HttpClient.client.fetchOk,\n    \n    HttpClient.response.json\n    \n    )\n    \n    export const getTodo = (id: number) =>\n    \n    httpCall(id).pipe(\n    \n    Effect.timeout(\"1 seconds\"),\n    \n    Effect.retry(retryPolicy),\n    \n    Effect.withSpan(\"getTodo\", { attributes: { id } })\n    \n    )\n    \n    \n    ts\n    \n    import { HttpClient } from \"@effect/platform\"\n    \n    import { Effect, Schedule } from \"effect\"\n    \n    const retryPolicy = Schedule.exponential(1000).pipe(\n    \n    Schedule.compose(Schedule.recurs(3))\n    \n    )\n    \n    const httpCall = (id: number) =>\n    \n    HttpClient.request.get(`/todos/${id}`).pipe(\n    \n    HttpClient.client.fetchOk,\n    \n    HttpClient.response.json\n    \n    )\n    \n    export const getTodo = (id: number) =>\n    \n    httpCall(id).pipe(\n    \n    Effect.timeout(\"1 seconds\"),\n    \n    Effect.retry(retryPolicy),\n    \n    Effect.withSpan(\"getTodo\", { attributes: { id } })\n    \n    )\n\nIn this example we can truly see the power of composition, each block of\nEffect cares about a specific thing (such as schedule definitions, http\nclient, etc) and it does so in such a way that the single pieces compose\ntogether.\n\nThe last problem we wanted to solve with our code is checking the types at the\nedge, accounting for that our full example code becomes:\n\n    \n    \n    ts\n    \n    import { HttpClient } from \"@effect/platform\"\n    \n    import { Schema } from \"@effect/schema\"\n    \n    import { Effect, Schedule } from \"effect\"\n    \n    const retryPolicy = Schedule.exponential(1000).pipe(\n    \n    Schedule.compose(Schedule.recurs(3))\n    \n    )\n    \n    const httpCall = (id: number) =>\n    \n    HttpClient.request.get(`/todos/${id}`).pipe(\n    \n    HttpClient.client.fetchOk,\n    \n    HttpClient.response.json\n    \n    )\n    \n    class Todo extends Schema.Class<Todo>(\"Todo\")({\n    \n    id: Schema.Number,\n    \n    userId: Schema.Number,\n    \n    title: Schema.String,\n    \n    completed: Schema.Boolean\n    \n    }) {}\n    \n    export const getTodo = (id: number) =>\n    \n    httpCall(id).pipe(\n    \n    Effect.timeout(\"1 seconds\"),\n    \n    Effect.retry(retryPolicy),\n    \n    Effect.flatMap(Schema.decodeUnknown(Todo)),\n    \n    Effect.withSpan(\"getTodo\", { attributes: { id } })\n    \n    )\n    \n    \n    ts\n    \n    import { HttpClient } from \"@effect/platform\"\n    \n    import { Schema } from \"@effect/schema\"\n    \n    import { Effect, Schedule } from \"effect\"\n    \n    const retryPolicy = Schedule.exponential(1000).pipe(\n    \n    Schedule.compose(Schedule.recurs(3))\n    \n    )\n    \n    const httpCall = (id: number) =>\n    \n    HttpClient.request.get(`/todos/${id}`).pipe(\n    \n    HttpClient.client.fetchOk,\n    \n    HttpClient.response.json\n    \n    )\n    \n    class Todo extends Schema.Class<Todo>(\"Todo\")({\n    \n    id: Schema.Number,\n    \n    userId: Schema.Number,\n    \n    title: Schema.String,\n    \n    completed: Schema.Boolean\n    \n    }) {}\n    \n    export const getTodo = (id: number) =>\n    \n    httpCall(id).pipe(\n    \n    Effect.timeout(\"1 seconds\"),\n    \n    Effect.retry(retryPolicy),\n    \n    Effect.flatMap(Schema.decodeUnknown(Todo)),\n    \n    Effect.withSpan(\"getTodo\", { attributes: { id } })\n    \n    )\n\n## #The Future\n\nWhile the core effect library is now stable, the rest of the ecosystem such as\n@effect/platform and @effect/schema aren't yet. It will be our first priority\nto make the ecosystem libraries stable, together with adding tons of\ndocumentation and examples.\n\nFollowing that, we plan to keep iterating and develop higher and higher levels\nof abstraction to solve challenging issues in the development of Production-\nGrade TypeScript.\n\nOur next goal for the near future is to build up Effect Cluster, the first\nJavaScript solution that enables:\n\n  * Clustering of Distributed Instances\n  * Addressing of Processes by Name\n  * Actors and Entities\n  * Scheduling of Cluster Singletons\n  * Execution of Durable Business Workflows\n\nWhile many current solutions for business workflows prescribe a specific way\nof doing things and pretend that all problems fit in that solution, Effect\nCluster will provide a holistic framework that will enable users to write\nworkflows that work for the problem they have, for example they will support:\n\n  * Explicit event sourcing / actor model, a la Akka/Pekko in the JVM, ideal for real-time / multiplayer-like code where you model your system as a set of entities with their behaviors.\n  * Implicit event sourcing / retried program, a la Temporal, ideal for short-lived transactions that spawn across different systems, for example a registration procedure that has to write to a database and send a confirmation email or a payment that has to be reconciled with the payment provider.\n  * Explicit state machines, ideal for high-frequency scenarios that are state-first and require introspection, for example a trading system that has to constantly reassess the risk of a particular position and take decisions based on the assessment.\n\n## #The Company\n\nA year ago with the objective of making Effect as easy to use and as feature\ncomplete as possible we:\n\n  * Incorporated Effectful Technologies Inc.\n  * Raised a Seed Round of 2.275.000$ led by Amplify Partners with participation from Early Adopters.\n  * Hired an amazing Founding Team.\n\nAs a VC-backed company that deals with Free Open Source Software, especially\nin recent times, we are aware of our responsibility of being absolutely clear\nabout what is OSS and what isn't.\n\nSo to make it very clear, everything that is released under MIT license will\nremain MIT licensed and we don't require CLAs. The Effect organization is\nfully managed by the Community.\n\nTo make money Effectful Technologies will house and build its own Effect-\npowered products and services that you can choose to use as you see fit.\n\nAuthor\n\nMichael Arnaldi\n\nChief Executive Officer\n\n## On this page\n\nMIT Licensed Copyright \u00a9 2024 Effectful Technologies Inc.\n\nGitHubDiscordTwitter\n\n### Docs\n\n  * Getting Started\n  * Guides\n  * API\n\n### Company\n\n  * Effectful\n\n### Legal\n\n  * Terms & Conditions\n  * Privacy Policy\n  * Contact Us\n\n", "frontpage": false}
