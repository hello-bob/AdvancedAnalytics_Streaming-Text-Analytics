{"aid": "40113040", "title": "Where everything went wrong: error handling in Rust. (2021)", "url": "https://msirringhaus.github.io/Where-everything-went-wrong/", "domain": "msirringhaus.github.io", "votes": 2, "user": "fanf2", "posted_at": "2024-04-22 10:42:04", "comments": 0, "source_title": "Where everything went wrong...", "source_text": "Where everything went wrong... \u2013 traitshifter \u2013 Who are you today?\n\n# traitshifter\n\nWho are you today?\n\n# Where everything went wrong...\n\n\u00b7 February 9, 2020\n\nRust Error Minidump\n\nToday you are frustrated.\n\nThis is so annoying. You\u2019ve written a Rust crate and now that you want to test\nit for the very first time, it doesn\u2019t work!\n\nCome on, Rust! How dare you? You promised that once one gets past the\ncompiler, it. Just. Works! And now this!\n\nOk, ok. You calm yourself down. Lets start from the beginning. You want to\ncreate so called minidumps. This is a file that contains information about a\ncrashed program (like stacks of all threads, CPU registers, system info,\netc.). The minidump consists of various sections, such as the minidump header\n(including time of day, versions and basically a table of contents), a thread\nsection (including all threads of the process and their stacks), memory\nmappings and libraries, etc. [Just to give some context, as all of this is\nactually not really important.]\n\nFor this, you created a crate. One section gets written after the other, while\ninformation about the targeted process is retrieved from the system. You even\ncreated a nice, simple API. You hand in a process ID and an open file, where\nthe minidump should be written to. like this:\n\n    \n    \n    MinidumpWriter::new(pid, blamed_thread) .dump(&mut dump_file) .expect(\"Dumping failed!\")\n\nYou can also hand in user specified memory regions that should be included in\nthe dump, like so:\n\n    \n    \n    let app_memory = AppMemory { ptr: some_address, length: memory_size, }; MinidumpWriter::new(pid, pid) .set_app_memory(vec![app_memory]) .dump(&mut tmpfile) .expect(\"Dumping failed\");\n\n# A wild error appears\n\nBut when you run your nice library code in an application, you get 'Dumping\nfailed: \"Failed in ptrace::read: Sys(EIO)\"'.\n\nHow useless is that?!\n\nOkay, maybe you could enhance your library error handling, a little. And by\nenhance, you mean \u201cimplement one in the first place\u201d.\n\n## State of the dart\n\nYour current approach is to define\n\n    \n    \n    type Error = Box<dyn error::Error + std::marker::Send + std::marker::Sync>; pub type Result<T> = result::Result<T, Error>;\n\nand using Result<T> in all of your functions as the return value and handing\nall of them to the parent function using ?. Thus the original error pierces\nthrough your callstack like a dart through....jelly (Yes, you are good with\nwords and you know it.).\n\n    \n    \n    pub fn init(&mut self) -> Result<()> { self.read_auxv()?; self.enumerate_threads()?; self.enumerate_mappings()?; Ok(()) }\n\nIn Rust parlance, this is also called bubbling up errors.\n\nUsually, you just bubble up errors from libraries you use, but for the rare\nerrors you have to define yourself, you currently just do\n\n    \n    \n    Err(\"Found no auxv entry\".into())\n\nWell, now you know there is an error, at least. And that it has something to\ndo with your usage of ptrace. But you have no idea where that happens. You use\nthat functionality in various places. Is it during the init-phase? During one\nof the sections? And if so, which one? What are you trying to read? And from\nwhere? Or in short: What is going on?!\n\n## Shoes off, get some tea: Research time!\n\nWell, Rust has been around for quite some time now and they always boast about\nhow error handling is a first class citizen and all that. So error handling\nshould be a done deal, right? With a canonical way of dealing with errors,\nofficially documented and all that should be right there, correct?\n\nOh boy, were you wrong.\n\nTurns out, this is a very active field of...mh...experimentation, lets say.\nThere has been a survey recently, listing and quickly describing most the\ndifferent libraries and ways for error handling that emerged, fallen out of\nfavor, got forked, died anyways, got superseded, fallen out of favor again,\netc. And the opinions seem to change frequently, if you should use error-chain\nor failure or fehler or snafu or thiserror or anyhow or eyre or...\n\nYou opened a can of hornets there, or whatever that saying is.\n\nThen you find this gem and don\u2019t know if you should laugh or cry. Almost six\nyears after Rust hit 1.0 an error handling project group is formed. Six.\nYears. (heavy breathing)\n\nWell, okay. At least they are sorting it out now. Problem is, you need....SIX\nYEARS? Are you serious?...ahem, sorry...Problem is, you need helpful error\nmessages now.\n\nAfter reading a few decent blogs on the topic (like this or that), there seems\nto emerge a consensus, at least for libraries: Return something that derives\nfrom std::error::Error. Either implement them by hand, or use a crate that\ndoes it for you, using macro magic. like thiserror. Which method you use\ndepends on your level of laziness plus your patience regarding compile times.\n\n## Examples vs. Reality\n\nAnother post highlighted error wrapping, a particularly intriguing idea to\nyou.\n\nUnfortunately, all the articles have the understandable, but rather annoying\ntendency to use very simple example code for illustration purposes.\nUnrealistically simple, you might even say. They have callstacks of depth 1,\nreturn only three kinds of error in total in their API, and their errors are\nobvious and easily describable (e.g. \u201cInput file XY not found in your\n\u2018counting words\u2019 program\u201d).\n\nYou have a more complicated callstack, with tons of different errors and code\nreuse in different places. For example, the function you think is to blame for\nthe above error is copy_from_process(), which calls ptrace::read(), which\nprobably returns something like Failed in ptrace::read: Sys(EIO). This\nfunction is used in multiple places in your code, e.g.:\n\n    \n    \n    \u251c\u2500 init() \u2502 \u251c\u2500 read_auxv() \u2502 \u2502 \u251c\u2500 open(format!(\"/proc/{}/auxv\", self.pid)) \u2502 \u2502 \u2514\u2500 some_parsing() \u2502 \u251c\u2500 ... \u2502 \u251c\u2500 enumerate_mappings() \u2502 \u2502 \u251c\u2500 open(format!(\"/proc/{}/maps\", self.pid)) \u2502 \u2502 \u2514\u2500 some_parsing() \u2502 \u2502 \u2502 \u2514\u2500 some_more_checks() \u2502 \u2514\u2500 copy_from_process() \u2502 \u2514\u2500 dump() \u2502 \u251c\u2500 sections::header::write() \u2502 \u251c\u2500 sections::thread_list_stream::write() \u2502 \u2514\u2500 copy_from_process() \u2502 \u251c\u2500 sections::mappings::write() \u2502 \u2514\u2500 elf_identifier_for_mapping() \u2502 \u2514\u2500 copy_from_process() \u2502 \u251c\u2500 sections::app_memory::write() \u2502 \u2514\u2500 copy_from_process() \u2502 \u2514\u2500 ...\n\nSame goes for opening files, which happens in multiple places (two examples of\nwhich are shown in init()), so getting FileNotFound without context is going\nto be equally fun, and so on.\n\n# Wrapping up (your errors)\n\nWrapping errors still sounds like a nice idea, but one layer alone is not\ngoing to wrap it cut it. Going with copy_from_process() as an example, you see\na few possibilities:\n\n  1. Wrapping the ptrace error into an CopyFromProcessError, but that gives you nothing (except maybe some context, if you add some)\n  2. With InitErrors and DumpingErrors that wrap the ptrace errors, you will still not know which section failed and why, but know if it was during init() or not.\n\nYou might add context to option 2 as well (see below on how), but each section\nhas a variety of reasons why it could fail. Some unique to the section, some\nshared among a few, some among all of them.\n\nComplex problems sometimes require complex solutions, maybe?\n\n## Inc Err() ption\n\nUsing thiserror and the fabulous #[from] macro, you quickly define a plethora\nof errors and wrappers, starting from the deepest, darkest places in your\ncallstack, wrapping your way up:\n\n    \n    \n    #[derive(Debug, Error)] pub enum PtraceDumperError { #[error(\"nix::ptrace() error\")] PtraceError(#[from] nix::Error), ... } #[derive(Debug, Error)] pub enum SectionAppMemoryError { #[error(\"Failed to copy memory from process\")] CopyFromProcessError(#[from] PtraceDumperError), ... } #[derive(Debug, Error)] pub enum DumpError { #[error(\"Error during init phase\")] InitError(#[from] InitError), #[error(transparent)] PtraceDumperError(#[from] PtraceDumperError), #[error(\"Failed when writing section AppMemory\")] SectionAppMemoryError(#[from] SectionAppMemoryError), ...\n\nThe fun part is: You have to touch very little of your existing code, thanks\nto the automatic conversion from one error to the other, conveniently provided\nby #[from]:\n\n    \n    \n    - pub fn init(&mut self) -> Result<()> { + pub fn init(&mut self) -> Result<(), InitError> { self.read_auxv()?; self.enumerate_threads()?; self.enumerate_mappings()?; Ok(()) }\n\nor\n\n    \n    \n    - pub fn get_stack_info(&self, int_stack_pointer: usize) -> Result<(usize, usize)> { + pub fn get_stack_info(&self, int_stack_pointer: usize) -> Result<(usize, usize), DumperError> { // snip let mapping = self .find_mapping(stack_pointer) - .ok_or(\"No mapping for stack pointer found\")?; + .ok_or(DumperError::NoStackPointerMapping)?; let offset = stack_pointer - mapping.start_address; let distance_to_end = mapping.size - offset; // snip\n\nIf you run your test binary again, you now get\n\n    \n    \n    Failed when writing section AppMemory\n\nwhich is....(Throws a stack of papers from the desk)...short. Too short, and\nnot that much more helpful, actually. Well, you know which section is failing.\nThats good. But where are all the nice error messages you specified in your\nerrors?\n\nHm, you do only use println!(\"{}\", error);. Maybe {:?} is better?\n\n    \n    \n    SectionAppMemoryError(CopyFromProcessError(PtraceError(Sys(EIO))))\n\nAha! Now you are getting somewhere! Tiny, tiny, painfully tiny steps, but you\nare getting somewhere! No error texts, but at least a chain!\n\nNormal printing doesn\u2019t seem to recursively go through all the wrapped errors,\nbut stop at the top most. For this, you need to either go through all the\nerrors yourself by hand, or use a crate that does this for you. There are a\nnumber of them that provide this, but anyhow will do (its by the same author\nas thiserror, so interoperability shouldn\u2019t be an issue).\n\n    \n    \n    println!(\"{:#}\", anyhow::Error::new(error));\n\naaaaand:\n\n    \n    \n    Failed when writing section AppMemory: Failed to copy memory from process: nix::ptrace() error: EIO: I/O error\n\nCollects papers from the floor. Throws them into the air in jubilation\n\n## Out of context?\n\nWith that sweet, sweet error chain and the resulting error message, you now\nknow where everything goes wrong. Not really why, though. You lack context.\nLuckily, you are not out of context (Note to yourself: You need a drum set for\nacoustically emphasizing your puns).\n\nYou have plenty of context to add, and adding it is rather easy. Instead of\nusing #[from], you use #[source], which will not implement an automatic\nconversion function anymore, but keep the error chain intact:\n\n    \n    \n    #[derive(Debug, Error)] pub enum PtraceDumperError { #[error(\"Copy from process {0} failed (source: 0x{1:x}, offset: {2}, length: {3})\")] PtraceError(Pid, usize, usize, usize, #[source] nix::Error),\n\nThis can be done on all layers of your error chain. For this example, we only\ndo it at the last link. No matter where you do it, you have to map your error\nnow (eyre could do this a bit more ergonomically, but you want to keep your\ndependency list small):\n\n    \n    \n    let word = ptrace::read(pid, (src + idx) as *mut c_void) .map_err(|e| PtraceError(child, src, idx, num_of_bytes, e))?;\n\nleading to\n\n    \n    \n    Failed when writing section AppMemory: Failed to copy memory from process: Copy from process 12111 failed (source: 0x0, offset: 0, length: 4096): EIO: I/O error\n\nYou handed in a nullptr. Why would you do that? Why?\n\nTo get an easy example error case for this article, thats why!\n\n## Human or machine?\n\nWell, your error messages, including lots of context, is now a well of\ninformation for humans. Its perfect for logging (for example to put into a\nJSON-file accompanying your minidump). Is it any good to use programmatically\nby application developers, though?\n\nYou think it could be. You envision scenarios like \u201cCan\u2019t find file XY,\nbecause of not yet mounted filesystem\u201d or the like. These can easily be\nmatched for in the application code by using the last link in your error-\nchain, which anyhow provides with the root_cause() function. Or you could\nmatch only the top most error and redoing the minidump-section on your own, if\nthe library code fails in it.\n\nOnly time will tell.\n\n## Comments\n\nYou can use your Mastodon account to reply to this post.\n\nReply\n\n", "frontpage": false}
