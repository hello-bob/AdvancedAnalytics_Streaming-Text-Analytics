{"aid": "40234254", "title": "Dissecting LockBit v3 Ransomware", "url": "https://blog.calif.io/p/dissecting-lockbit-v3-ransomware", "domain": "calif.io", "votes": 5, "user": "favadi", "posted_at": "2024-05-02 09:24:28", "comments": 0, "source_title": "Dissecting LockBit v3 ransomware", "source_text": "Dissecting LockBit v3 ransomware\n\n# Calif\n\nShare this post\n\n#### Dissecting LockBit v3 ransomware\n\nblog.calif.io\n\n#### Discover more from Calif\n\nContinue reading\n\nSign in\n\n# Dissecting LockBit v3 ransomware\n\nNh\u00e2n Hu\u1ef3nh\n\n,\n\nHoang Nguyen\n\n, and\n\nThai Duong\n\nMay 02, 2024\n\n1\n\nShare this post\n\n#### Dissecting LockBit v3 ransomware\n\nblog.calif.io\n\nShare\n\n#\n\nIntroduction\n\nIn our last article, we recommended analyzing ransomware binaries as part of\nan effective ransomware response strategy:\n\n> \u201cAnalyzing binaries is hard. Analyzing obfuscated ransomware is even harder.\n>\n> [...] However, it is worth investing in analyzing and understanding\n> ransomware. Crypto breaking bugs may be rare, but they are not impossible to\n> find. In addition, ransomware authors may not fully understand how to use\n> crypto correctly. The only way to determine if it is possible to recover the\n> data, if any, is the long and detailed ransomware analysis by an expert\n> team.\n>\n> [...] In addition, a successful analysis can help reassure you that there\n> are no potential bugs in the encryption and decryption process. It also\n> helps the technical team understand and potentially improve the recovery\n> process. This is an investment that should be considered early on in an\n> incident.\u201d\n\nIn this article, we show some examples of crucial intelligence you can gain\nfrom a meticulous and accurate ransomware analysis. The target of this\nanalysis is a variant of the LockBit v3 ransomware that we encountered in a\nrecent engagement. This variant is also known as LockBit Black due to some\ncode similarity with the BlackMatter family. These samples are built from the\nleaked LockBit v3 builder available on GitHub.\n\nCalif discovered two issues in this version of the ransomware:\n\n  * a crypto bug that may allow for the decryption of a portion of the data without the private key, i.e., without paying the ransom.\n\n  * a design flaw that may cause data corruption and permanent data loss.\n\nWe decided to publish this analysis for the following reasons:\n\n  * The crypto bug is already known to the malware author. We have observed newer variants where we can no longer take advantage of this bug.\n\n  * We want to share our analysis and research to help other affected organizations prepare and respond to the same ransomware family, especially regarding the data corruption flaw.\n\n  * The LockBit v3 family contains interesting anti-analysis techniques and clever use of standard cryptographic algorithms that are not well documented. These technical details would be valuable for malware researchers and threat hunters.\n\nWe also publish an open-source decryptor for this variant. You can download\nthe tool from GitHub.\n\nCalif would like to extend a special thank you to Chuong Dong \u2013 a malware\nexpert who has previous experience with this ransomware family. During the\ninitial analysis, we requested Chuong\u2019s assistance to swiftly comprehend the\nfile encryption scheme. His help proved highly valuable as we managed to\nquickly reimplement the decryptor.\n\nNote that the screenshots and code snippets within this article assume that\nthe encryptor is loaded at address 0xFA0000 instead of the default ImageBase\nof 0x400000. The decryptor is loaded at the ImageBase of 0x400000. In\naddition, the ransomware has many anti-debugging and obfuscation mechanisms.\nTo bypass these protections and reproduce this analysis, please refer to\nAppendix A: Reverse engineering detail.\n\n#\n\nTable of contents\n\nIntroduction\n\nEncryption and decryption logic\n\n  * Encrypted file structure\n\n  * Footer structure\n\n  * Modified Salsa20\n\n  * RSA with no padding\n\n  * File encryption\n\n  * File decryption\n\nFlaws\n\n  * Keystream reuse vulnerability\n\n  * Data corruption\n\nConclusion\n\nAppendix A: Reverse engineering detail\n\nAppendix B: Open-source decryption tool\n\nAppendix C: Binary Information and Indicators of Compromise (IOCs)\n\nAppendix D: IDC script to rename functions\n\nAppendix E: Chunk counts and skip bytes\n\n#\n\nEncryption and decryption logic\n\nThe sample encrypts files using a combination of symmetric and asymmetric\ncryptography, as follows:\n\n  * Generate a 64-byte random key for each targeted file. We will refer to it as the file_encryption_key. We identify the encryption algorithm as a variant of Salsa20. Normally, Salsa20 uses a 32-byte key, but this variant uses 64-byte. Please refer to the Modified Salsa20 section for more details. Unless specified otherwise, all references to Salsa20 in this document refer to this modified version.\n\n  * Generate another 64-byte random Salsa20 key to encrypt the file_encryption_key. We will refer to this second key as the key_encryption_key. As an optimization to reduce the number of slow RSA encryption operations, the sample reuses this key for 1,000 files before generating a new one. This key reuse leads to a vulnerability described in the Keystream reuse vulnerability section.\n\n  * Encrypt the key_encryption_keys using RSA with no padding, using a 1024-bit public key embedded within. We describe this algorithm in the RSA with no padding section. Note that since 2015 NIST has recommended against using 1024-bit RSA keys.\n\n##\n\nEncrypted file structure\n\nThe sample processes targeted files the same way during encryption and\ndecryption. It divides each file into chunks of 0x20000 bytes. The sample does\nnot pad the file if the file size or the size of the last chunk is less than\n0x20000 bytes.\n\nConsecutive chunks form a group. There are three group types: before, skip,\nand after group. There is exactly one \u201cbefore group\u201d at the beginning of the\nfile. The skip group and the after group follow the before group and repeat\nalternatively throughout the rest of the file.\n\nThe sample encrypts chunks of the before group and after groups using Salsa20.\nIt leaves chunks in the skip group unencrypted. It determines the number of\nchunks in each group based on the file size. Please refer to Appendix E for\nmore details.\n\nAn encrypted file ends with a footer containing information about the file\nsuch as the file\u2019s original name, number of chunks in each group, etc,\nincluding the file_encryption_key to decrypt the file data. The sample\nencrypts this footer, and appends it to the file after the encryption\nfinishes. For a detailed description of the footer structure, refer to the\nnext section.\n\nThe overall structure of an encrypted file can be visualized as follows:\n\n##\n\nFooter structure\n\nWe reconstruct the overall structure of the footer in the C snippet below:\n\n    \n    \n    struct file_encryption_info { char filename[file_encryption_info.filename_size]; // apLib compressed uint16_t filename_size; LARGE_INTEGER skipped_bytes; int before_chunk_count; int after_chunk_count; uint8_t file_encryption_key[0x40]; }; struct key_encryption_info { uint16_t file_encryption_info_length; // necessary because filename is dynamically sized int checksum; union { struct { uint8_t key_encryption_key[0x40]; uint8_t checksum[0x40]; } decrypted; uint8_t encrypted_key_encryption_key[0x80]; // RSA encrypted } key_blob; }; struct footer { struct file_encryption_info file_encryption_info; // Salsa20 encrypted struct key_encryption_info key_encryption_info; };\n\nThe file_encryption_info contains a randomly generated key to decrypt the file\ncontent. The file_encryption_info is encrypted using Salsa20. The key to\ndecrypt the file_encryption_info is stored in the encrypted_key_encryption_key\nfield of the key_encryption_info structure. This field, in turn, is encrypted\nusing the RSA public key embedded in the ransomware.\n\nThe decryptor contains an embedded private key, and works as follows:\n\n  1. Read the key_encryption_info structure at offset 0x86 bytes from the end of the file.\n\n  2. Hash the encrypted_key_encryption_key field and verify it against the checksum field as seen here.\n\n  3. Decrypt the encrypted_key_encryption_key using the embedded private RSA key then validate the key_encryption_key with the decrypted.checksum field.\n\n  4. Calculate the start of the file_encryption_info structure using the file_encryption_info_length field.\n\n  5. Use the key_encryption_key to decrypt the file_encryption_info structure using the modified Salsa20 algorithm. This structure contains the Salsa20 file_encryption_key that can be used to decrypt the chunks in the before group and after group.\n\n##\n\nModified Salsa20\n\nThe sample encrypts the file_encryption_info structure and the chunks using\nSalsa20 at address 0x00FA20AC.\n\nSalsa20 has a 64-byte state that is used to generate a key stream to encrypt\nthe plaintext one 64-byte block at a time. In the vanilla Salsa20 standard,\nthe initial 64-byte state consists of a 32-byte key, an 8-byte block counter,\nan 8-byte nonce, and a 16-byte constant that spell \u201cexpand 32-byte k\u201d in\nASCII.\n\nHowever, in this variant, the entire initial state is filled with random\nvalues. The aforementioned file_encryption_key and key_encryption_key are the\ninitial states of the file encryption and key encryption processes\nrespectively.\n\nThis finding shows that LockBit v3 is indeed a successor of BlackMatter, which\nin turn came from the Darkside ransomware family. Chuong\u2019s analysis of\nDarkside shows that it also fills the Salsa20\u2019s initial state, which Chuong\ncalled the matrix, with random values.\n\n##\n\nRSA with no padding\n\nThis sample encrypts key_encryption_info.key_encryption_key and\nkey_encryption_info.checksum, using a custom implementation of the RSA\nalgorithm at address 0x00FA17B4.\n\nRecall that an RSA public key consists of two components:\n\n  * The modulus N.\n\n  * The public exponent e.\n\nTo encrypt a message m using RSA with no padding, you compute m^e (mod N).\nThis encryption mode, which is known as textbook RSA, has many potential\nfootguns. For example, it\u2019s possible to recover small messages. Therefore, m\nis usually padded with PKCS v1.5 or OAEP padding schemes.\n\nHowever, the sample uses no padding. We can\u2019t find any obvious issues, because\nthe sample only encrypts messages that have the same size as the modulus. In\nparticular, it uses a 1024-bit key to encrypt\nkey_encryption_info.key_encryption_key and key_encryption_info.checksum, which\nin total are also 1024 bits long.\n\n##\n\nFile encryption\n\nBefore encrypting any files, the sample parses its embedded configuration at\naddress 0x00FC600C. This data are encrypted by the function at 0x00FA6F48 and\ncontain information such as configuration flags, file hashes to avoid, ransom\nnote, and the RSA public key used to encrypt the randomly generated\nkey_encryption_info.key_encryption_key.\n\nAfter decrypting its configurations, the sample parses its command line\narguments and enumerates target paths to encrypt files. The sample operates\nslightly differently depending on the command line argument. However, the file\nencryption logic is similar across different execution flows. The sample\ncreates one thread for traversing and queueing files to be encrypted and\nmultiple threads to actually encrypt the files. The threads communicate\nasynchronously with each other using an IO completion port.\n\nAt a high-level, the encryption threads work as follows:\n\n  * The file traversal and queueing logic starts at 0x00FAF308.\n\n  * It drops a ransom note in the current directory.\n\n  * For each file in the current target directory, it verifies the filename against the lists of hashes to avoid. If the current filename doesn\u2019t belong to any of the lists, it renames the current file and adds a unique extension. In our variant, the extension is .IzYqBW5pa.\n\n  * It increases various counters, including a counter for the number of files using the current key_encryption_key. This key is randomly generated and reused once every 1,000 files. Once this counter reaches 1,000, the sample resets it back to 0 and generates a new key_encryption_key. This design introduces a bug that allows for the decryption without paying the ransom. This bug is described in detail in the Key stream reuse vulnerability section.\n\n  * It fills out and sets up the key_encryption_info structure for the current file. The logic to set the before_chunk_count, skipped_bytes, and after_chunk_count is at address 0x00FAE8AC. These values are determined based on the current file size. Refer to Appendix E for the exact values of each field based on the current file size.\n\n  * The file encryption thread logic starts at address 0x00FADE78. This function simply determines if it needs to encrypt the current chunk depending on the file_encryption_info structure. It uses a randomly generated key stored at file_encryption_info.file_encryption_key to encrypt each chunk using Salsa20. Finally, when the entire file is processed, it writes the footer structure to the end of the file.\n\n##\n\nFile decryption\n\nThe decryptor binary LB3Decryptor.exe is not obfuscated and can be quickly\nanalyzed statically.\n\nSimilar to the encryptor, the decryptor parses its command line arguments and\nenumerates paths to decrypt files. The sample also creates multiple threads\nfor decrypting and one for traversing and queueing files. These threads\ncommunicate asynchronously with each other using an IO completion port.\n\nAt a high-level, the decryption threads work as follows:\n\n  * The file traversal and queueing logic starts at 0x00403CEC. For each file, it decrypts the key_encryption_info (see Footer structure) at address 0x00403960. Then, it obtains the file_encryption_key and the chunk counts before queueing the file.\n\n  * The file decryption thread logic starts at 0x004030DC. It decrypts the chunks selected by the grouping algorithm using the file_encryption_key. Finally, when the entire file is processed, it removes the encrypted footer structure at the end of the file.\n\n#\n\nFlaws\n\n##\n\nKeystream reuse vulnerability\n\nThis version of the LockBit v3 ransomware has a keystream reuse vulnerability.\n\nInstead of directly encrypting the file_encryption_info structure with RSA,\nthe sample aims to reduce the number of slow RSA operations by adding another\nlayer of Salsa20 encryption. This is where it makes a mistake that may allow\nthe recovery of a portion of the data.\n\nThe sample generates a random Salsa20 key_encryption_key to encrypt the\nfile_encryption_info structure once every 1,000 files as seen below:\n\nTherefore, the Salsa20 algorithm would generate the same key stream for 1,000\nfiles from the same key. Within these 1,000 files, if there is a file with a\nsufficiently long compressed filename, we can recover enough of the keystream\nto decrypt the file_encryption_info structure of other files with a much\nshorter compressed filename. This file_encryption_info structure contains the\nfile_encryption_key to decrypt the file content. In other words, if we happen\nto have a file with a sufficiently long compressed filename, chances are we\ncan recover the content of other files with shorter compressed filenames\nwithout the private key from the threat actor, i.e., without paying the\nransom.\n\nFor example, we created two short text files for our test case:\n\n  * a.txt, whose compressed filename is: 61 e0 2e e0 74 e0 78 db 09 02 00 00\n\n  * aABCDEFGHIJKLMNOPQRSTUVWXYZ[]^_`abcdefghijklmnopqrstuvwxyz{}~123456789.txt, whose compressed filename is shown below:\n\nThe content of the encrypted file with the longer file name is shown here:\n\nBecause we know the current filename, we can compute the plaintext compressed\nfilename. XOR-ing the encrypted compressed filename with the plaintext\ncompressed filename gives us the following keystream:\n\nThe content of the encrypted a.txt is shown below with similar color-coded\nfields:\n\nXOR-ing the entire file_encryption_info block, starting at offset 0x0e to\noffset 0x6c with the keystream above would give us the following bytes:\n\nThe recovered file_encryption_info fields are:\n\n  * Compressed filename: 61 e0 2e e0 74 e0 78 db 09 02 00 00 (compressed a.txt)\n\n  * filename_size: 0c 00 (0x0c)\n\n  * skipped_bytes: 00 00 52 00 00 00 00 00 (0x520000 in little-endian)\n\n  * before_chunk_count: 03 00 00 00 (0x03 in little-endian)\n\n  * after_chunk_count: 03 00 00 00 (0x03 in little-endian)\n\n  * file_encryption_key:\n\nThe recovered file_encryption_info structure allows us to decrypt the entire\nfile following the decryption scheme described above.\n\n##\n\nData corruption\n\nThis version of the LockBit v3 ransomware has a design flaw that can cause\npermanent data loss. LockBit v3 has a mutex checking mechanism to ensure only\none instance of itself is running on the infected system:\n\nHowever, this feature can be configured at build time and is disabled in our\nsample. The flag at byte_FC5129 is part of the sample\u2019s encrypted settings\nconfigured by the TA and set by the builder. When this feature is disabled,\nmultiple instances of the ransomware can run on the infected system at one\ntime.\n\nThe sample needs to process each file with exclusive access to the encryption\nlogic. To do that, it attempts to terminate other processes that prevent\nexclusive access to the file. The sample uses the restart manager family of\nAPIs (RmStartSession(), RmRegisterResource(), RmGetList()) to get a list of\nprocesses with open handles to the file being encrypted. It then terminates\nall of those processes.\n\nThis design can cause permanent data corruption because of the following\nreasons:\n\n  * With multiple instances of the same ransomware running on the same system, one instance can attempt to terminate the other instance that is encrypting the same file. In this case, the randomly generated file_encryption_key from the 1st instance can not be recovered. The file is permanently corrupted. We can detect the corruption by observing files with multiple extra extensions, signaling that the files were encrypted multiple times. Each instance of the ransomware can have multiple encryption threads running parallel, each of which encrypts one file at a time. Since the number of concurrent threads is quite low, the number of files being affected in this case can potentially be low.\n\n  * The sample may attempt to terminate another process that is currently writing and modifying the current file. This may cause data corruption depending on how the affected process is designed. We can not easily detect this case. However, the number of files being affected can be very high depending on the services running on the infected system and their utilization. Calif has observed files that are properly decrypted but are corrupted and not recognized by their associated applications.\n\n#\n\nConclusion\n\nAnalyzing the ransomware could provide critical intelligence when evaluating\nresponse strategies to ransomware attacks. In this case, Calif observed flaws\nin the ransomware design that allowed affected organizations to reconsider the\ntrue value of the ransom demand. We hope our analysis helps demystify the\ninner workings of one ransomware variant. We also hope to encourage more\nsharing of technical analysis, curated intelligence, and valuable lessons\nacross organizations. Security demands collaboration as no organizations\noperate in a vacuum. The more secure our peers, the safer we are against cyber\ncriminals.\n\n#\n\nAppendix A: Reverse engineering detail\n\n##\n\nAnti-debugging\n\nTypically, malware does not want to be analyzed. With a debugger, we can\neasily control the malware\u2019s execution, dump data, or force the malware to\nexecute a specific code path. Therefore, malware usually contains multiple\nanti-debugging checks. We found multiple said checks in this sample.\n\nThe first check occurs at 0x00FA63C5 (offset 0x57C5 into the file) as seen\nbelow:\n\nAfter manually resolving some Windows Application Programming Interfaces\n(APIs), the sample calls the RtlCreateHeap() function to create a new heap.\nThe result is a HANDLE to a window HEAP structure provided by the operating\nsystem for the current process. This HEAP structure is undocumented by\nMicrosoft. To better understand this structure, refer to other online\nresources regarding the Windows HEAP. Significant to anti-debugging\nmechanisms, the HEAP structure contains two flags: Flag and ForceFlag. These\nvalues change depending on whether the current process is running under a\ndebugger.\n\nIn the screenshot above, the sample checks the Flag field, which is at offset\n0x40 byte into the undocumented HEAP structure. The value of this Flag field\nis 0x40041062 as shown in the screenshot below:\n\nThe sample gets the most significant 4 bits of the flag by rotating the Flag\nfield 28 (0x1c) bits to the right, and tests the result against 0x04. This\neffectively tests the most significant byte of the Flag field against\n0x40000000 (HEAP_VALIDATE_PARAMETER_ENABLED) which is set if the current\nprocess is running under a debugger.\n\nIf the sample detects a debugger, it modifies the HANDLE to the current\nprocess\u2019s heap using the rol operation. This causes the process to crash if it\never tries to allocate any memory using the modified heap HANDLE in the\nfuture.\n\nA similar check of the heap\u2019s ForceFlag field is shown below:\n\nIn the screenshot above, the sample finds the heap using the current process\u2019s\nProcess Environment Block (PEB). Then, it tests the ForceFlag field, which is\nat offset 0x44, against 0x40000000 to detect a debugger.\n\nThese checks are scattered around the sample\u2019s logic near any heap operation.\nThe easiest way to bypass these anti-debugging checks is to modify the process\nheap structures directly and reset both the Flag and ForceFlag fields\u2019 most\nsignificant byte to 0x00.\n\nThis sample also contains the following additional anti-debugging features:\n\n  * Checking beyond the bound of the allocated heap memory against magic constants like 0xABABABAB. These magic constants come from a Windows feature that adds additional guardrails to heap memory to quickly detect memory corruption bugs. This feature is only enabled if the current process is running under a debugger. This check can also be bypassed by modifying the Flag and ForceFlag fields of the heap.\n\n  * Calling NtProtectVirtualMemory() and RtlEncryptMemory() to encrypt the DbgUiRemoteBreakin() function. This causes the current process to crash if there is any attempt to attach a debugger afterwards. This does not have any effect if we start executing the sample using the debugger.\n\n  * Calling NtSetInformationThread() with ThreadHideFromDebugger (0x11) for the current thread. This call only happens a few times at the beginning of the execution flow. A quick way to bypass this is patching the function to simply return NT_SUCCESS (0x00).\n\n##\n\nObfuscation\n\n###\n\nManual API resolution\n\nTo avoid leaking capabilities and being tracked using the import hash, this\nsample manually resolves Windows APIs using the PEB.\n\nThe PEB contains all the properties of its associated process, including a\nlist of loaded DLLs. The sample can walk this list of DLLs and their export\ntables to manually find addresses of the necessary Windows APIs. To further\navoid leaking strings, the sample manually resolves Windows APIs using a\nhashing algorithm shown below:\n\nThe sample applies the hashing algorithm above on the DLLs and their export\nnames to find a match instead of comparing strings normally. However, in\naddition to the \u201cAddition-Rotate Right 13\u201d operation, the sample also XORs the\nresult with the 0x10035FFF constant. This results in a set of API hashes that\nare different from other malware families using a similar technique.\n\n###\n\nTrampoline code\n\nThe sample doesn\u2019t use the resolved APIs directly. Instead, for each API, it\nallocates a small memory chunk and builds a small piece of trampoline code\nwhich calculates and jumps to the target API.\n\nFor example, instead of executing a standard indirect call to NtOpenProcess()\nas an import, the sample calls to a pointer at address 0x00fc5474, which\npoints to a function at address 0x00330bc8 on the heap. This function is shown\nbelow:\n\nAfter the rol operation, eax becomes 0x7743FC50, which is the address of\nntdll!NtOpenProcess(). This makes static analysis significantly more tedious.\nWe would have a hard time tracking all the calls to the trampoline code.\n\nBecause we can bypass the anti-debugging checks, we can use a debugger to help\nus automate the renaming of the trampoline calls. The logic to resolve APIs\nand setup the trampoline code is at 0x00FA5dA0. Using the IDA Free debugger,\nwe can set a breakpoint at 0x00FA5DDB, which is the instruction right after\nthe call to manually resolve Windows APIs. Then, we can edit the breakpoint to\nexecute the following one-liner:\n\n    \n    \n    fprintf(fopen(\"out.txt\", \"a+\"), \"%s\\n\", sprintf(\"%a -- %s\", GetRegValue(\"edi\"), get_name(GetRegValue(\"eax\")) ) )\n\nThis small snippet tells the IDA Free debugger to log the following items to\nthe file \u201cout.txt\u201d in the current working directory:\n\n  * The current value of the edi register. This is the address of the trampoline code. In our example, this would be 0x00FA5dA0.\n\n  * The name of the value in the eax register. The eax register holds the address of the resolved API. In our example, eax would be 0x7743FC50. Within the current process context, this is the address of ntdll!NtOpenProcess().\n\nOnce the breakpoint is ready, we can let the sample execute through all the\nAPI resolution logic. At the end, we should see the out.txt file that looks\nsimilar to this:\n\nAfter the sample finishes resolving all the APIs, we can dump the current\nprocess including all of its allocated memory for further analysis. Then, we\ncan write a small IDA script to parse out.txt and rename all the trampoline\ncalls to the appropriate APIs. This will help speed up our static analysis\nsignificantly. An example of such a script is available in Appendix D.\n\n#\n\nAppendix B: Open-source decryption tool\n\nThe leaked LockBit v3 builder generated the encryptor and decryptor for\nWindows. Although the decryptor can run on Linux using Wine, Calif decided to\nre-implement the decryption logic in C for the following reasons:\n\n  * We want to run the decryptor natively on VMWARE ESXi.\n\n  * We want to confirm our understanding of the encryption scheme.\n\n  * We want to avoid executing the malware author\u2019s decryptor which may contain other data corruption bugs.\n\n  * Other affected organizations may also find our decryptor useful.\n\nThis section describes how we build a decryption tool for Linux. The tool is\nopen-source and can be downloaded from GitHub.\n\n##\n\nExtracting the decryption function\n\nCalif identified the two crypto functions to be Salsa20 (0x00FA20AC) and RSA\nwith no padding (0x00FA17B4). Initially, instead of fully reverse-engineering\nthese functions, we take the code directly from the binary and run it as\nshellcode inside a C wrapper. Calif\u2019s decisions were based on the following\nreasons:\n\n  * It would take us too long to fully analyze and confirm the algorithms.\n\n  * The sample uses a custom implementation of the two algorithms. Therefore, re-implementation or using a standard library may introduce discrepancies and bugs.\n\nWe extract the following items directly from the ransomware into shellcode\nthat we can call using our wrapper:\n\n  * The Salsa20 encryption function and related functions\n\n  * The Raw RSA function and related functions\n\n  * The checksum calculation algorithm\n\n  * The APLib compression function and related functions\n\nWhen preparing these functions, we also fix any absolute address references so\nwe can call them correctly in our wrapper without causing a crash.\n\n##\n\nImplementation\n\nThe sample is compiled for a 32-bit Windows environment. To get the shellcode\nto run correctly, we also need to compile our code for this environment. By\ndefault, GCC would default to the cdecl calling convention, but Windows uses\nstdcall. We fix that by adding the attribute (__attribute__((stdcall)).\n\nThe data section of an executable is marked as non-executable, therefore we\ncan not execute the shellcode directly from there. Instead, we allocate new\nmemory pages with executable permission and copy the shellcode over.\n\n#\n\nAppendix C: Binary Information and Indicators of Compromise (IOCs)\n\nThe following IOCs come from our specific build of this variant of LockBit v3.\nHere are the components that may be different across different builds:\n\n  * The unique ID for this build: IzYqBW5pa.\n\n  * File hashes other than the hash of the icon and desktop background.\n\n##\n\nBinary information\n\n  * Filename: LB3.exe\n\n    * File type: Windows Portable Executable (PE) x86\n\n    * File size: 156,160\n\n    * SHA256 hash: f34dd8449b9b03fedde335f8be51bdc7f96cda29a2dde176c3db667ba0713c6f\n\n  * Filename: LB3Decryptor.exe\n\n    * File type: Windows Portable Executable (PE) x86\n\n    * File size: 33,280\n\n    * SHA256 hash: 8f0a2d5b47441fbcf1882aa41cae22fd0db057ccc38abad87ccc28813df3a83c\n\n##\n\nIndicators of Compromise\n\n###\n\nHost-based indicators (HBIs)\n\n  * Volatile:\n\n    * When configured, the sample creates the following mutex: Global\\a91a66d6abc26041b701bf8da3de4d0f where a91a66d6abc26041b701bf8da3de4d0f is calculated from the embedded RSA private key\n\n  * Files\n\n    * Filename: C:\\ProgramData\\IzYqBW5pa.ico where IzYqBW5pa is the unique ID for this specific variant.\n\n    * File type: ICO\n\n    * File size: 15,086\n\n    * SHA256 hash: 95e059ef72686460884b9aea5c292c22917f75d56fe737d43be440f82034f438\n\n  * Filename: C:\\ProgramData\\IzYqBW5pa.bmp.\n\n    * File type: BMP\n\n    * File size: 86,708\n\n    * SHA256 hash: ef66e202c7a1f2a9bc27ae2f5abe3fd6e9e6f1bdd9d178ab510d1c02a1db9e4f\n\n  * Filename: IzYqBW5pa.README.txt.\n\n    * File type: TXT\n\n    * File size: 6,197\n\n    * SHA256 hash: af23f7d2cf9a263802a25246e2d45eaf4a4f8370e1b6115e79b9e1e13bf20bfe\n\n  * Registry:\n\n    * Path: HKEY_CLASSES_ROOT\\\\.IzYqBW5pa\\DefaultIcon\n\n    * Value: C:\\ProgramData\\IzYqBW5pa.ico\n\n###\n\nNetwork-based indicators (NBIs):\n\n  * When configured, the sample communicates with the configured C2 server using HTTP Protocol POST method. This specific variant is not configured with a C2 server.\n\n  * When communicating with the C2 server, the sample uses the following User-Agent string: Chrome/91.0.4472.77.\n\n  * Communication with the C2 server is encrypted using the AES algorithm. This specific variant is not configured to communicate with the C2 server. Therefore, it also does not contain the AES key.\n\n#\n\nAppendix D: IDC script to rename functions\n\n    \n    \n    #include <idc.idc> static process(line) { // example line: .data:00FC5410 -- ntdll_RtlCreateHeap auto idx = strstr(line, \" -- \"); // saddr: .data:00FC5410 auto saddr = substr(line, 0, idx); // name: ntdll_RtlCreateHeap auto name = substr(line, idx + 1, -1); // old saddr: .data:00FC5410 // new saddr: 00FC5410 as a string // addr : 0x00FC5410 auto _idx = strstr(saddr, \":\"); saddr = substr(saddr, _idx + 1, -1); auto addr = xtol(saddr); // old name: ntdll_RtlCreateHeap // new name: RtlCreateHeap _idx = strstr(name, \"_\"); name = substr(name, _idx + 1, -1); auto len = strlen(name); // NULL terminate the last byte name[len-1] = '\\0'; Message(\"Addr: 0x%x, name: %s\\n\", addr, name); set_name(addr, name, SN_NOCHECK|SN_FORCE); } static load_file() { auto fd = fopen(\"out.txt\", \"r\"); auto line = readstr(fd); while (value_is_string(line)) { process(line); line = readstr(fd); } fclose(fd); return 0; } static main() { load_file(); }\n\n#\n\nAppendix E: Chunk counts and skip bytes\n\n##\n\nGrouping algorithm\n\nEach chunk of the file belongs to one of the three groups (before group, skip\ngroup, after group). But for the sake of simplicity, let\u2019s only consider the\nstate of each chunk: encrypted (before group or after group), or unencrypted\n(skip group).\n\nTo determine if a chunk needs encrypting or decrypting, we can use the\nfollowing algorithm:\n\n    \n    \n    chunk_state = '' # first 'before_chunk_count' chunks belong to before group and are encrypted crypt_chunk_count = before_chunk_count skip_chunk_count = (skipped_bytes / 0x20000) -1 skip_count = skip_chunk_count for chunk in chunks: if (crypt_chunk_count): chunk_state = \"en(de)crypt\" crypt_chunk_count = crypt_chunk_count - 1 else: chunk_state = \"skip\" # belongs to a skip group skip_count = skip_count - 1 if (skip_count == 0): crypt_chunk_count = after_chunk_count\n\nThe decrypted file_encryption_info contains the value for before_chunk_count,\nafter_chunk_count and skipped_bytes. To see how and where they are generated,\nrefer to the File encryption section. The sample determines the chunk count\nbased on the file size as described in the following table:\n\n### Subscribe to Calif\n\nLaunched a year ago\n\n2 Likes\n\n1\n\nShare this post\n\n#### Dissecting LockBit v3 ransomware\n\nblog.calif.io\n\nShare\n\nComments\n\nCraftCMS RCE\n\nCraft is a flexible, user-friendly CMS for creating custom digital experiences\non the web\u2014and beyond. You have a ton of options when it comes to...\n\nSep 14, 2023 \u2022\n\nThanh\n\n11\n\nShare this post\n\n#### CraftCMS RCE\n\nblog.calif.io\n\nReproducing CVE-2023-38646: Metabase Pre-auth RCE\n\nBy Duc Nguyen and Jang Nguyen\n\nJul 27, 2023\n\n9\n\nShare this post\n\n#### Reproducing CVE-2023-38646: Metabase Pre-auth RCE\n\nblog.calif.io\n\n1\n\nPrivilege escalation in AWS Elastic Kubernetes Service\n\nThe team recently encountered an interesting scenario where we were trying to\nescalate privileges from a compromised pod in AWS Elastic Kubernetes...\n\nApr 2, 2023 \u2022\n\nAn Trinh\n\nand\n\nDuc Nguyen\n\n6\n\nShare this post\n\n#### Privilege escalation in AWS Elastic Kubernetes Service\n\nblog.calif.io\n\nReady for more?\n\n\u00a9 2024 Calif Global Inc.\n\nPrivacy \u2219 Terms \u2219 Collection notice\n\nStart WritingGet the app\n\nSubstack is the home for great culture\n\nShare\n\n## Create your profile\n\n## Only paid subscribers can comment on this post\n\nAlready a paid subscriber? Sign in\n\n#### Check your email\n\nFor your security, we need to re-authenticate you.\n\nClick the link we sent to , or click here to sign in.\n\n", "frontpage": true}
