{"aid": "40135832", "title": "Show HN: Storing Private Keys in the Browser Securely", "url": "https://github.com/JWally/BrowserPrivateKeyDemo", "domain": "github.com/jwally", "votes": 2, "user": "jwally", "posted_at": "2024-04-23 19:02:33", "comments": 0, "source_title": "GitHub - JWally/BrowserPrivateKeyDemo: Protect SessionTokens with Private Keys - In The Browser", "source_text": "GitHub - JWally/BrowserPrivateKeyDemo: Protect SessionTokens with Private Keys\n- In The Browser\n\nSkip to content\n\n## Navigation Menu\n\nSign in\n\n# Search code, repositories, users, issues, pull requests...\n\nSearch syntax tips\n\nSign in\n\nSign up\n\nYou signed in with another tab or window. Reload to refresh your session. You\nsigned out in another tab or window. Reload to refresh your session. You\nswitched accounts on another tab or window. Reload to refresh your session.\nDismiss alert\n\nJWally / BrowserPrivateKeyDemo Public\n\n  * Notifications\n  * Fork 0\n  * Star 3\n\nProtect SessionTokens with Private Keys - In The Browser\n\n3 stars 0 forks Branches Tags Activity\n\nStar\n\nNotifications\n\n# JWally/BrowserPrivateKeyDemo\n\nThis commit does not belong to any branch on this repository, and may belong\nto a fork outside of the repository.\n\n1 Branch\n\n0 Tags\n\n## Folders and files\n\nName| Name| Last commit message| Last commit date  \n---|---|---|---  \n  \n## Latest commit\n\nJWallyUpdate README.mdApr 23, 20247c2ecb1 \u00b7 Apr 23, 2024Apr 23, 2024\n\n## History\n\n2 Commits  \n  \n### README.md\n\n|\n\n### README.md\n\n| Update README.md| Apr 23, 2024  \n  \n## Repository files navigation\n\n# Secure Private Key Creation and Storage in the Browser\n\n## What Is This?\n\nThe following code snippet shows how to store a private key that can be USED\nin your browser, but CANNOT be extracted or stolen.\n\n## Why Should I Care?\n\nYou (or FireBase, SupaBase, Cognito, etc) can use this approach to make\nsession-token-theft EXTREMELY difficult.\n\n## Prove It!\n\nIn your browser, open the dev console (CTRL+SHFT+I), then copy and paste the\nfollowing code snippet in:\n\n    \n    \n    /** * Name of the IndexedDB database. * @type {string} */ const dbName = \"CryptoKeys\"; /** * Name of the object store within the IndexedDB. * @type {string} */ const storeName = \"keys\"; /** * Identifier for the key pair stored in the database. * @type {string} */ const keyPairName = \"ecdsaKeyPair\"; /** * Opens or creates an IndexedDB database and ensures it contains the required object store. * @returns {Promise<IDBDatabase>} A promise that resolves with the database object on success. */ function openDatabase() { return new Promise((resolve, reject) => { // Attempt to open the database const request = indexedDB.open(dbName, 1); // Create the store if this is the first time the database is being opened (i.e., on upgrade) request.onupgradeneeded = function(event) { const db = event.target.result; if (!db.objectStoreNames.contains(storeName)) { db.createObjectStore(storeName); } }; // Resolve the promise with the database instance on successful opening request.onsuccess = () => resolve(request.result); // Reject the promise with the error on failure request.onerror = () => reject(request.error); }); } /** * Retrieves an existing ECDSA key pair from the database or generates a new one if not found. * @param {IDBDatabase} db - The database instance. * @returns {Promise<CryptoKeyPair>} A promise that resolves with the key pair. */ async function getKeyPair(db) { return new Promise(async (resolve, reject) => { const transaction = db.transaction([storeName], \"readwrite\"); const store = transaction.objectStore(storeName); const request = store.get(keyPairName); request.onsuccess = async (event) => { if (request.result) { // Resolve with the found key pair resolve(request.result); } else { // Generate a new key pair if not found try { const keyPair = await crypto.subtle.generateKey( { name: \"ECDSA\", namedCurve: \"P-256\" }, true, // set to true to make keys extractable for demonstration [\"sign\", \"verify\"] ); // Save the new key pair in the database const putTransaction = db.transaction([storeName], \"readwrite\"); const putStore = putTransaction.objectStore(storeName); const putRequest = putStore.put(keyPair, keyPairName); putRequest.onsuccess = () => resolve(keyPair); putRequest.onerror = () => reject(putRequest.error); } catch (error) { reject(error); } } }; request.onerror = () => reject(request.error); }); } /** * Signs a message using a given ECDSA private key. * @param {CryptoKey} privateKey - The private key to sign the message with. * @param {string} message - The message to sign. * @returns {Promise<ArrayBuffer>} The signature as an ArrayBuffer. */ async function signMessage(privateKey, message) { const encoder = new TextEncoder(); const data = encoder.encode(message); return crypto.subtle.sign( { name: \"ECDSA\", hash: { name: \"SHA-256\" } }, privateKey, data ); } /** * Verifies a signature against the given message using an ECDSA public key. * @param {CryptoKey} publicKey - The public key to verify the signature with. * @param {ArrayBuffer} signature - The signature to verify. * @param {string} message - The message that was signed. * @returns {Promise<boolean>} A boolean indicating whether the signature is valid. */ async function verifySignature(publicKey, signature, message) { const encoder = new TextEncoder(); const data = encoder.encode(message); return crypto.subtle.verify( { name: \"ECDSA\", hash: { name: \"SHA-256\" } }, publicKey, signature, data ); } /** * Converts an ArrayBuffer into a base64 encoded string. * @param {ArrayBuffer} buffer - The ArrayBuffer to convert. * @returns {string} The base64 encoded string. */ function bufferToBase64(buffer) { return btoa(String.fromCharCode(...new Uint8Array(buffer))); } /** * Converts a CryptoKey into a PEM-formatted string. * @param {CryptoKey} key - The CryptoKey to convert. * @returns {Promise<string>} The PEM-formatted string of the key. */ async function exportPublicKey(key) { // Export the public key in the SPKI (Subject Public Key Info) format const exported = await crypto.subtle.exportKey('spki', key); // Convert the exported ArrayBuffer to a Base64 string const base64 = window.btoa(String.fromCharCode(...new Uint8Array(exported))); // Format the Base64 string as PEM return base64; } /** * Main function that orchestrates the creation or retrieval of a key pair, * signs a message, exports the public key, and verifies the signature, logging the results to the console. */ async function main() { const db = await openDatabase(); const keyPair = await getKeyPair(db); const message = \"base_64_of_jwt\"; const signatureBuffer = await signMessage(keyPair.privateKey, message); const signatureBase64 = bufferToBase64(signatureBuffer); // Export and log the public key in PEM format const publicKeyPEM = await exportPublicKey(keyPair.publicKey); const instructions = ` ------------------------------------------ ------------------------------------------ Below are: 1. Your public-key (which should be the same after reloading the browser) 2. A message being signed with your _PRIVATE_KEY_ 3. The Message's Signature with your _PRIVATE_KEY_ 4. The Signature's verification with your _public_key_ Try Extracting or viewing your private key data!!! If I did this right...YOU CAN'T! ------------------------------------------ ------------------------------------------ `; console.log(instructions); console.log(`Message: ${message}`); console.log(`Public Key: ${publicKeyPEM}`); console.log(`Signature: ${signatureBase64}`); const isValid = await verifySignature(keyPair.publicKey, signatureBuffer, message); console.log(`Verification: ${isValid ? \"Successful\" : \"Failed\"}`); } // Run the main function and log errors to the console main().catch(console.error);\n\n## How Does This Help With Session-Token Theft?\n\n  1. When the user is authenticating, have them sign their public-key with their private-key and send it to you.\n  2. Put the user's public-key inside of a JWT\n  3. For extra protection, put the user's IP-Address in the JWT as well\n\nEvery time the user makes a request to something protected, in addition to\nsending the JWT, the user should send the following headers:\n\n    \n    \n    x-base64-jwt: {a base 64 encoded, stringifed version of the JWT being sent} x-base64-jwt-signature: {the ECDSA Signature of the x-base64-jwt}\n\nBecause the JWT contains the server-verified public key; I can verify the\ncurrent signature (x-base64-jwt-signature) with it. If it fails, I proceed\nexactly as if someone tampered a JWT in any other framework.\n\nIf I want to be extra secure, I can refuse request whose IP Address is\ndifferent than what's in the JWT.\n\n## About\n\nProtect SessionTokens with Private Keys - In The Browser\n\n### Resources\n\nReadme\n\nActivity\n\n### Stars\n\n3 stars\n\n### Watchers\n\n1 watching\n\n### Forks\n\n0 forks\n\nReport repository\n\n## Releases\n\nNo releases published\n\n## Packages 0\n\nNo packages published\n\n## Footer\n\n\u00a9 2024 GitHub, Inc.\n\nYou can\u2019t perform that action at this time.\n\n", "frontpage": false}
