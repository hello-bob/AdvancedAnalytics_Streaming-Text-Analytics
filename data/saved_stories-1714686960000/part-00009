{"aid": "40237491", "title": "Secure Randomness in Go 1.22", "url": "https://go.dev/blog/chacha8rand", "domain": "go.dev", "votes": 1, "user": "spacey", "posted_at": "2024-05-02 15:40:21", "comments": 0, "source_title": "Secure Randomness in Go 1.22 - The Go Programming Language", "source_text": "Secure Randomness in Go 1.22 - The Go Programming Language\n\n# The Go Blog\n\n# Secure Randomness in Go 1.22\n\nRuss Cox and Filippo Valsorda 2 May 2024\n\nComputers aren\u2019t random. On the contrary, hardware designers work very hard to\nmake sure computers run every program the same way every time. So when a\nprogram does need random numbers, that requires extra effort. Traditonally,\ncomputer scientists and programming languages have distinguished between two\ndifferent kinds of random numbers: statistical and cryptographic randomness.\nIn Go, those are provided by math/rand and crypto/rand, respectively. This\npost is about how Go 1.22 brings the two closer together, by using a\ncryptographic random number source in math/rand (as well as math/rand/v2, as\nmentioned in our previous post). The result is better randomness and far less\ndamage when developers accidentally use math/rand instead of crypto/rand.\n\nBefore we can explain what Go 1.22 did, let\u2019s take a closer look at\nstatistical randomness compared to cryptographic randomness.\n\n## Statistical Randomness\n\nRandom numbers that pass basic statistical tests are usually appropriate for\nuse cases like simulations, sampling, numerical analysis, non-cryptographic\nrandomized algorithms, random testing, shuffling inputs, and random\nexponential backoff. Very basic, easy to compute mathematical formulas turn\nout to work well enough for these use cases. Because the methods are so\nsimple, however, an observer who knows what algorithm is being used can\ntypically predict the rest of the sequence after seeing enough values.\n\nEssentially all programming environments provide a mechanism for generating\nstatistical random numbers that traces back through C to Research Unix Third\nEdition (V3), which added a pair of functions: srand and rand. The manual page\nincluded a note that read:\n\n> WARNING The author of this routine has been writing random-number generators\n> for many years and has never been known to write one that worked.\n\nThis note was partly a joke but also an acknowledgement that such generators\nare inherently not random.\n\nThe source code of the generator makes clear how trivial it is. Translated\nfrom PDP-11 assembly to modern C, it was:\n\n    \n    \n    uint16 ranx; void srand(uint16 seed) { ranx = seed; } int16 rand(void) { ranx = 13077*ranx + 6925; return ranx & ~0x8000; }\n\nCalling srand seeds the generator with a single integer seed, and rand returns\nthe next number from the generator. The AND in the return statement clears the\nsign bit to make sure the result is positive.\n\nThis function is an instance of the general class of linear congruential\ngenerators (LCGs), which Knuth analyzes in The Art of Computer Programming,\nVolume 2, section 3.2.1. The main benefit of LCGs is that constants can be\nchosen such that they emit every possible output value once before repeating,\nas the Unix implementation did for 15-bit outputs. A serious problem with\nLCGs, however, is that the high bits of the state do not affect the low bits\nat all, so every truncation of the sequence to k bits necessarily repeats with\na smaller period. The low bit must toggle: 0, 1, 0, 1, 0, 1. The low two bits\nmust count up or down: 0, 1, 2, 3, 0, 1, 2, 3, or else 0, 3, 2, 1, 0, 3, 2, 1.\nThere are four possible three-bit sequences; the original Unix implementation\nrepeats 0, 5, 6, 3, 4, 1, 2, 7. (These problems can be avoided by reducing the\nvalue modulo a prime, but that would have been quite expensive at the time.\nSee S. K. Park and K. W. Miller\u2019s 1988 CACM paper \u201cRandom number generators:\ngood ones are hard to find\u201d for a short analysis and the first chapter of\nKnuth Volume 2 for a longer one.)\n\nEven with these known problems, the srand and rand functions were included in\nthe first C standard, and equivalent functionality was included in essentially\nevery language since then. LCGs were once the dominant implementation\nstrategy, although they\u2019ve fallen off in popularity due to some important\ndrawbacks. One significant remaining use is java.util.Random, which powers\njava.lang.Math.random.\n\nAnother thing you can see from the implementation above is that the internal\nstate is completely exposed by the result of rand. An observer who knows the\nalgorithm and sees a single result can easily compute all future results. If\nyou are running a server that calculates some random values that become public\nand some random values that must stay secret, using this kind of generator\nwould be disastrous: the secrets wouldn\u2019t be secret.\n\nMore modern random generators aren\u2019t as terrible as the original Unix one, but\nthey\u2019re still not completely unpredictable. To make that point, next we will\nlook at the original math/rand generator from Go 1 and the PCG generator we\nadded in math/rand/v2.\n\n## The Go 1 Generator\n\nThe generator used in Go 1\u2019s math/rand is an instance of what is called a\nlinear-feedback shift register. The algorithm is based on an idea by George\nMarsaglia, tweaked by Don Mitchell and Jim Reeds, and further customized by\nKen Thompson for Plan 9 and then Go. It has no official name, so this post\ncalls it the Go 1 generator.\n\nThe Go 1 generator\u2019s internal state is a slice vec of 607 uint64s. In that\nslice, there are two distinguished elements: vec[606], the last element, is\ncalled the \u201ctap\u201d, and vec[334] is called the \u201cfeed\u201d. To generate the next\nrandom number, the generator adds the tap and the feed to produce a value x,\nstores x back into the feed, shifts the entire slice one position to the right\n(the tap moves to vec[0] and vec[i] moves to vec[i+1]), and returns x. The\ngenerator is called \u201clinear feedback\u201d because the tap is added to the feed;\nthe entire state is a \u201cshift register\u201d because each step shifts the slice\nentries.\n\nOf course, actually moving every slice entry forward would be prohibitively\nexpensive, so instead the implementation leaves the slice data in place and\nmoves the tap and feed positions backward on each step. The code looks like:\n\n    \n    \n    func (r *rngSource) Uint64() uint64 { r.tap-- if r.tap < 0 { r.tap += len(r.vec) } r.feed-- if r.feed < 0 { r.feed += len(r.vec) } x := r.vec[r.feed] + r.vec[r.tap] r.vec[r.feed] = x return uint64(x) }\n\nGenerating the next number is quite cheap: two subtractions, two conditional\nadds, two loads, one add, one store.\n\nUnfortunately, because the generator directly returns one slice element from\nits its internal state vector, reading 607 values from the generator\ncompletely exposes all its state. With those values, you can predict all the\nfuture values, by filling in your own vec and then running the algorithm. You\ncan also recover all the previous values, by running the algorithm backward\n(subtracting the tap from the feed and shifting the slice to the left).\n\nAs a complete demonstration, here is an insecure program generating\npseudorandom authentication tokens along with code that predicts the next\ntoken given a sequence of earlier tokens. As you can see, the Go 1 generator\nprovides no security at all (nor was it meant to). The quality of the\ngenerated numbers also depends on the initial setting of vec.\n\n## The PCG Generator\n\nFor math/rand/v2, we wanted to provide a more modern statistical random\ngenerator and settled on Melissa O\u2019Neill\u2019s PCG algorithm, published in 2014 in\nher paper \u201cPCG: A Family of Simple Fast Space-Efficient Statistically Good\nAlgorithms for Random Number Generation\u201d. The exhaustive analysis in the paper\ncan make it hard to notice at first glance how utterly trivial the generators\nare: PCG is a post-processed 128-bit LCG.\n\nIf the state p.x were a uint128 (hypothetically), the code to compute the next\nvalue would be:\n\n    \n    \n    const ( pcgM = 0x2360ed051fc65da44385df649fccf645 pcgA = 0x5851f42d4c957f2d14057b7ef767814f ) type PCG struct { x uint128 } func (p *PCG) Uint64() uint64 { p.x = p.x * pcgM + pcgA return scramble(p.x) }\n\nThe entire state is a single 128-bit number, and the update is a 128-bit\nmultiply and add. In the return statement, the scramble function reduces the\n128-bit state down to a 64-bit state. The orginal PCG used (again using a\nhypothetical uint128 type):\n\n    \n    \n    func scramble(x uint128) uint64 { return bits.RotateLeft(uint64(x>>64) ^ uint64(x), -int(x>>122)) }\n\nThis code XORs the two halves of the 128-bit state together and then rotates\nthe result according to the top six bits of the state. This version is called\nPCG-XSL-RR, for \u201cxor shift low, right rotate\u201d.\n\nBased on a suggestion from O\u2019Neill during proposal discussion, Go\u2019s PCG uses a\nnew scramble function based on multiplication, which mixes the bits more\naggressively:\n\n    \n    \n    func scramble(x uint128) uint64 { hi, lo := uint64(x>>64), uint64(x) hi ^= hi >> 32 hi *= 0xda942042e4dd58b5 hi ^= hi >> 48 hi *= lo | 1 }\n\nO\u2019Neill calls PCG with this scrambler PCG-DXSM, for \u201cdouble xorshift\nmultiply.\u201d Numpy uses this form of PCG as well.\n\nAlthough PCG uses more computation to generate each value, it uses\nsignificantly less state: two uint64s instead of 607. It is also much less\nsensitive to the initial values of that state, and it passes many statistical\ntests that other generators do not. In many ways it is an ideal statistical\ngenerator.\n\nEven so, PCG is not unpredictable. While the scrambling of bits to prepare the\nresult does not expose the state directly like in the LCG and Go 1 generators,\nPCG-XSL-RR can still be be reversed, and it would not be surprising if PCG-\nDXSM could too. For secrets, we need something different.\n\n## Cryptographic Randomness\n\nCryptographic random numbers need to be utterly unpredictable in practice,\neven to an observer who knows how they are generated and has observed any\nnumber of previously generated values. The safety of cryptographic protocols,\nsecret keys, modern commerce, online privacy, and more all critically depend\non access to cryptographic randomness.\n\nProviding cryptographic randomness is ultimately the job of the operating\nsystem, which can gather true randomness from physical devices\u2014timings of the\nmouse, keyboard, disks, and network, and more recently electrical noise\nmeasured directly by the CPU itself. Once the operating system has gathered a\nmeaningful amount of randomness\u2014say, at least 256 bits\u2014it can use\ncryptographic hashing or encryption algorithms to stretch that seed into an\narbitrarily long sequence of random numbers. (In practice the operating system\nis also constantly gathering and adding new randomness to the sequence too.)\n\nThe exact operating system interfaces have evolved over time. A decade ago,\nmost systems provided a device file named /dev/random or something similar.\nToday, in recognition of how fundamental randomness has become, operating\nsystems provide a direct system call instead. (This also allows programs to\nread randomness even when cut off from the file system.) In Go, the\ncrypto/rand package abstracts away those details, providing the same interface\non every operating system: rand.Read.\n\nIt would not be practical for math/rand to ask the operating system for\nrandomness each time it needs a uint64. But we can use cryptographic\ntechniques to define an in-process random generator that improves on LCGs, the\nGo 1 generator, and even PCG.\n\n## The ChaCha8Rand Generator\n\nOur new generator, which we unimaginatively named ChaCha8Rand for\nspecification purposes and implemented as math/rand/v2\u2019s rand.ChaCha8, is a\nlightly modified version of Daniel J. Bernstein\u2019s ChaCha stream cipher. ChaCha\nis widely used in a 20-round form called ChaCha20, including in TLS and SSH.\nJean-Philippe Aumasson\u2019s paper \u201cToo Much Crypto\u201d argues persuasively that the\n8-round form ChaCha8 is secure too (and it\u2019s roughly 2.5X faster). We used\nChaCha8 as the core of ChaCha8Rand.\n\nMost stream ciphers, including ChaCha8, work by defining a function that is\ngiven a key and a block number and produces a fixed-size block of apparently\nrandom data. The cryptographic standard these aim for (and usually meet) is\nfor this output to be indistinguishable from actual random data in the absence\nof some kind of exponentially costly brute force search. A message is\nencrypted or decrypted by XOR\u2019ing successive blocks of input data with\nsuccessive randomly generated blocks. To use ChaCha8 as a rand.Source, we use\nthe generated blocks directly instead of XOR\u2019ing them with input data (this is\nequivalent to encrypting or decrypting all zeros).\n\nWe changed a few details to make ChaCha8Rand more suitable for generating\nrandom numbers. Briefly:\n\n  * ChaCha8Rand takes a 32-byte seed, used as the ChaCha8 key.\n  * ChaCha8 generates 64-byte blocks, with calculations treating a block as 16 uint32s. A common implementation is to compute four blocks at a time using SIMD instructions on 16 vector registers of four uint32s each. This produces four interleaved blocks that must be unshuffled for XOR\u2019ing with the input data. ChaCha8Rand defines that the interleaved blocks are the random data stream, removing the cost of the unshuffle. (For security purposes, this can be viewed as standard ChaCha8 followed by a reshuffle.)\n  * ChaCha8 finishes a block by adding certain values to each uint32 in the block. Half the values are key material and the other half are known constants. ChaCha8Rand defines that the known constants are not re-added, removing half of the final adds. (For security purposes, this can be viewed as standard ChaCha8 followed by subtracting the known constants.)\n  * Every 16th generated block, ChaCha8Rand takes the final 32 bytes of the block for itself, making them the key for the next 16 blocks. This provides a kind of forward secrecy: if a system is compromised by an attack that recovers the entire memory state of the generator, only values generated since the last rekeying can be recovered. The past is inaccessible. ChaCha8Rand as defined so far must generate 4 blocks at a time, but we chose to do this key rotation every 16 blocks to leave open the possibility of faster implementations using 256-bit or 512-bit vectors, which could generate 8 or 16 blocks at a time.\n\nWe wrote and published a C2SP specification for ChaCha8Rand, along with test\ncases. This will enable other implementations to share repeatability with the\nGo implementation for a given seed.\n\nThe Go runtime now maintains a per-core ChaCha8Rand state (300 bytes), seeded\nwith operating system-supplied cryptographic randomness, so that random\nnumbers can be generated quickly without any lock contention. Dedicating 300\nbytes per core may sound expensive, but on a 16-core system, it is about the\nsame as storing a single shared Go 1 generator state (4,872 bytes). The speed\nis worth the memory. This per-core ChaCha8Rand generator is now used in three\ndifferent places in the Go standard library:\n\n  1. The math/rand/v2 package functions, such as rand.Float64 and rand.N, always use ChaCha8Rand.\n\n  2. The math/rand package functions, such as rand.Float64 and rand.Intn, use ChaCha8Rand when rand.Seed has not been called. Applying ChaCha8Rand in math/rand improves the security of programs even before they update to math/rand/v2, provided they are not calling rand.Seed. (If rand.Seed is called, the implementation is required to fall back to the Go 1 generator for compatibility.)\n\n  3. The runtime chooses the hash seed for each new map using ChaCha8Rand instead of a less secure wyrand-based generator it previously used. Random seeds are needed because if an attacker knows the specific hash function used by a map implementation, they can prepare input that drives the map into quadratic behavior (see Crosby and Wallach\u2019s \u201cDenial of Service via Algorithmic Complexity Attacks\u201d). Using a per-map seed, instead of one global seed for all maps, also avoids other degenerate behaviors. It is not strictly clear that maps need a cryptographically random seed, but it\u2019s also not clear that they don\u2019t. It seemed prudent and was trivial to switch.\n\nCode that needs its own ChaCha8Rand instances can create its own rand.ChaCha8\ndirectly.\n\n## Fixing Security Mistakes\n\nGo aims to help developers write code that is secure by default. When we\nobserve a common mistake with security consequences, we look for ways to\nreduce the risk of that mistake or eliminate it entirely. In this case,\nmath/rand\u2019s global generator was far too predictable, leading to serious\nproblems in a variety of contexts.\n\nFor example, when Go 1.20 deprecated math/rand\u2019s Read, we heard from\ndevelopers who discovered (thanks to tooling pointing out use of deprecated\nfunctionality) they had been using it in places where crypto/rand\u2019s Read was\ndefinitely needed, like generating key material. Using Go 1.20, that mistake\nis a serious security problem that merits a detailed investigation to\nunderstand the damage. Where were the keys used? How were the keys exposed?\nWere other random outputs exposed that might allow an attacker to derive the\nkeys? And so on. Using Go 1.22, that mistake is just a mistake. It\u2019s still\nbetter to use crypto/rand, because the operating system kernel can do a better\njob keeping the random values secret from various kinds of prying eyes, the\nkernel is continually adding new entropy to its generator, and the kernel has\nhad more scrutiny. But accidentally using math/rand is no longer a security\ncatastrophe.\n\nThere are also a variety of use cases that don\u2019t seem like \u201ccrypto\u201d but\nnonetheless need unpredictable randomness. These cases are made more robust by\nusing ChaCha8Rand instead of the Go 1 generator.\n\nFor example, consider generating a random UUID. Since UUIDs are not secret,\nusing math/rand might seem fine. But if math/rand has been seeded with the\ncurrent time, then running it at the same instant on different computers will\nproduce the same value, making them not \u201cuniversally unique\u201d. This is\nespecially likely on systems where the current time is only available with\nmillisecond precision. Even with auto-seeding using OS-provided entropy, as\nintroduced in Go 1.20, the Go 1 generator\u2019s seed is only a 63-bit integer, so\na program that generates a UUID at startup can only generate 263 possible\nUUIDs and is likely to see collisions after 231 or so UUIDs. Using Go 1.22,\nthe new ChaCha8Rand generator is seeded from 256 bits of entropy and can\ngenerate 2256 possible first UUIDs. It does not need to worry about\ncollisions.\n\nAs another example, consider load balancing in a front-end server that\nrandomly assigns incoming requests to back-end servers. If an attacker can\nobserve the assignments and knows the predictable algorithm generating them,\nthen the attacker could send a stream of mostly cheap requests but arrange for\nall the expensive requests to land on a single back-end server. This is an\nunlikely but plausible problem using the Go 1 generator. Using Go 1.22, it\u2019s\nnot a problem at all.\n\nIn all these examples, Go 1.22 has eliminated or greatly reduced security\nproblems.\n\n## Performance\n\nThe security benefits of ChaCha8Rand do have a small cost, but ChaCha8Rand is\nstill in the same ballpark as both the Go 1 generator and PCG. The following\ngraphs compare the performance of the three generators, across a variety of\nhardware, running two operations: the primitive operation \u201cUint64,\u201d which\nreturns the next uint64 in the random stream, and the higher-level operation\n\u201cN(1000),\u201d which returns a random value in the range [0, 1000).\n\nThe \u201crunning 32-bit code\u201d graphs show modern 64-bit x86 chips executing code\nbuilt with GOARCH=386, meaning they are running in 32-bit mode. In that case,\nthe fact that PCG requires 128-bit multiplications makes it slower than\nChaCha8Rand, which only uses 32-bit SIMD arithmetic. Actual 32-bit systems\nmatter less every year, but it is still interesting that ChaCha8Rand is faster\nthan PCG on those systems.\n\nOn some systems, \u201cGo 1: Uint64\u201d is faster than \u201cPCG: Uint64\u201d, but \u201cGo 1:\nN(1000)\u201d is slower than \u201cPCG: N(1000)\u201d. This happens because \u201cGo 1: N(1000)\u201d\nis using math/rand\u2019s algorithm for reducing a random int64 down to a value in\nthe range [0, 1000), and that algorithm does two 64-bit integer divide\noperations. In contrast, \u201cPCG: N(1000)\u201d and \u201cChaCha8: N(1000)\u201d use the faster\nmath/rand/v2 algorithm, which almost always avoids the divisions. Removing the\n64-bit divisions dominates the algorithm change for 32-bit execution and on\nthe Ampere.\n\nOverall, ChaCha8Rand is slower than the Go 1 generator, but it is never more\nthan twice as slow, and on typical servers the difference is never more than\n3ns. Very few programs will be bottlenecked by this difference, and many\nprograms will enjoy the improved security.\n\n## Conclusion\n\nGo 1.22 makes your programs more secure without any code changes. We did this\nby identifying the common mistake of accidentally using math/rand instead of\ncrypto/rand and then strengthening math/rand. This is one small step in Go\u2019s\nongoing journey to keep programs safe by default.\n\nThese kinds of mistakes are not unique to Go. For example, the npm keypair\npackage tries to generate an RSA key pair using Web Crypto APIs, but if\nthey\u2019re not available, it falls back to JavaScript\u2019s Math.random. This is\nhardly an isolated case, and the security of our systems cannot depend on\ndevelopers not making mistakes. Instead, we hope that eventually all\nprogramming languages will move to cryptographically strong pseudorandom\ngenerators even for \u201cmathematical\u201d randomness, eliminating this kind of\nmistake, or at least greatly reducing its blast radius. Go 1.22\u2019s ChaCha8Rand\nimplementation proves that this approach is competitive with other generators.\n\nPrevious article: Evolving the Go Standard Library with math/rand/v2 Blog\nIndex\n\nWhy Go Use Cases Case Studies\n\nGet Started Playground Tour Stack Overflow Help\n\nPackages Standard Library About Go Packages\n\nAbout Download Blog Issue Tracker Release Notes Brand Guidelines Code of\nConduct\n\nConnect Twitter GitHub Slack r/golang Meetup Golang Weekly\n\nOpens in new window.\n\n  * Copyright\n  * Terms of Service\n  * Privacy Policy\n  * Report an Issue\n\ngo.dev uses cookies from Google to deliver and enhance the quality of its\nservices and to analyze traffic. Learn more.\n\n", "frontpage": false}
