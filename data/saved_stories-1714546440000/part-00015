{"aid": "40217870", "title": "Content CSS Transitions in Hugo", "url": "https://dawidwrobel.com/journal/content-css-transformations-in-hugo/", "domain": "dawidwrobel.com", "votes": 2, "user": "cromka", "posted_at": "2024-04-30 23:48:44", "comments": 0, "source_title": "Applying CSS transitions to Hugo blog posts", "source_text": "Applying CSS transitions to Hugo blog posts | Homepage of Dawid Wr\u00f3bel\n\n# Applying CSS transitions to Hugo blog posts\n\nUsing a simple JavaScript hack and a bit of CSS styling\n\nApril 29, 2024 \u00b7 5 min\n\nI wanted to include some on-scroll content transitions to blog posts on my\nHugo-based website, which I was just finished porting over from the initial\nWordpress + LayTheme design. Turns out it\u2019s fairly easy using JavaScript\u2019s\nIntersectionObserver API and some Hugo magic.\n\n# CSS transitions#\n\nConsider this (slightly modified) \u201cMultiple animated properties example\u201d from\nMozilla Developer Docs, showing how CSS transitions work:\n\nA div element:\n\n    \n    \n    <div class=\"box\">Sample</div>\n\nstyled with this CSS:\n\n    \n    \n    .box { color: white; border-style: solid; border-width: 1px; display: block; width: 100px; height: 100px; background-color: #0000ff; transition: width 2s, height 2s, background-color 2s, rotate 2s, color 2s; } .box:hover, .box:active { color: black; background-color: #ffcccc; width: 200px; height: 200px; rotate: 180deg; }\n\nwill result in a box that transforms as soon as you hover over it or depress\nit (for use on smartphones):\n\nSimple?\n\nSimple. Two classes, one for the \u201cdefault\u201d state and another one to define the\ntransition to be applied.\n\nYou could now use Markdown Attributes to apply those CSS classes to any of\nyour Markdown content in Hugo and be done.\n\n# IntersectionObserver API#\n\nHowever, the particular transition I am after is an ease-in transform, which\nlooks like this:\n\nIn case you got distracted: the photo slides in slightly from the bottom when\nscrolling. To make that happen we need to kick the transition off as soon as\nthe photo starts showing on the screen \u2014 or, technically speaking, showing in\nviewport. To get that working, I can leverage IntersectionObserver API, as\nexplained on Stack Overflow:\n\n    \n    \n    const inViewport = (entries, observer) => { entries.forEach(entry => { entry.target.classList.toggle(\"is-inViewport\", entry.isIntersecting); }); }; const Obs = new IntersectionObserver(inViewport); const obsOptions = {}; //See: https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API#Intersection_observer_options // Attach observer to every [data-inviewport] element: document.querySelectorAll('[data-inviewport]').forEach(el => { Obs.observe(el, obsOptions); });\n\nThe code is pretty self-explanatory (reading from the bottom up):\n\n  * For each element matching [data-inviewport] selector, have it observed by the Obs (which is an object of IntersectionObserver class).\n  * Whenever an observed element intersects with browser\u2019s viewport, Obs invokes inViewport callback function.\n  * inViewport, in turn, toggles the is-inViewport class on observed element.\n\nSince the elements intersect both when they appear in the viewport and\ndisappear from it, the is-inViewport class effectively tells us whether or not\nany portion of an observed element is visible on the screen or not. Neat.\n\nYou could now define some classes for different transformations, e.g.\n\n    \n    \n    [data-inviewport=\"scale-in\"] { transition: 2s; transform: scale(0.1); } [data-inviewport=\"scale-in\"].is-inViewport { transform: scale(1); }\n\nand add a data-inviewport=\"scale-in\" attribute to every HTML element you\nwanted to apply the scale-in effect to. Unfortunately, in Hugo, this typically\nmeans you\u2019d have to modify the theme itself, e.g. its shortcodes for\n<<figure>> or <<highlight>>, and ideally you want to avoid that.\n\nThe alternative is to use a different selector in querySelectorAll, one that\nwould capture elements by their other classes previously applied or by their\ntype. For example: querySelectorAll('.highlight, .post-content img') would get\nis-inViewport class toggled on:\n\n  * any element that already has a .highlight class assigned, i.e. is a code block;\n  * and on any <img> element that is a descendant of any element with .post-content class, such that only images added as posts content have that transition applied \u2014 otherwise the selector would capture all of the images on the website, including your logo, etc.\n\nCSS styling to accompany that could look like this:\n\n    \n    \n    .highlight, .post-content img { transition: 2s; transform: scale(0.1); } .highlight.is-inViewport, img.is-inViewport { transform: scale(1); }\n\nNotice that the second selector does not use .post-content class restriction,\ngiven that .is-inViewport already limits it to the elements of our interest.\n\nTo finish this off, you\u2019d save the CSS above into assets/css/extended folder\n(under any file name, Hugo will include it automatically) plus the JavaScript\npiece above to e.g. static/js/viewportobserve.js. For the latter, you also\nneed a corresponding <script> tag added to the HTML\u2019s body to have the script\nactually loaded together with your website:\n\n    \n    \n    <script src=\"{{ \"js/assets/js/viewportobserve.js\" | absURL }}\"></script>\n\nThis is typically added to layouts/partials/extend_footer.html or a similar\npartial file \u2014 there\u2019s no rule, as it\u2019s merely a convention adopted by Hugo\ntheme authors.\n\n# Templating perfection#\n\nThe last step of improvement is to avoid having to modify the .js file\nwhenever you want to change the element selector. Preferably, we\u2019d want it as\na parameter in hugo.toml (or hugo.yml) config file:\n\n    \n    \n    [params] observeViewportSelectors = \".highlight, .post-content img'\"\n\nFor that we need to convert the JavaScript code to incorporate Hugo templates\nand its Go functions:\n\n    \n    \n    const inViewport = (entries, observer) => { entries.forEach(entry => { entry.target.classList.toggle(\"is-inViewport\", entry.isIntersecting); }); }; const Obs = new IntersectionObserver(inViewport); const obsOptions = {}; {{ if .Site.Params.observeViewportSelectors }} const selector = \"{{ .Site.Params.observeViewportSelectors }}\"; // Attach observer to every element requested: document.querySelectorAll(selector).forEach(el => { Obs.observe(el, obsOptions); }); {{ end }}\n\nLastly, we change the script inclusion directive to have Hugo pre-process the\nnow templated .js file using ExecuteAsTemplate function:\n\n    \n    \n    {{- $viewportobserve := resources.Get \"js/viewportobserve.js\" | resources.ExecuteAsTemplate \"viewportobserve_processed.js\" . | resources.Minify }} <script crossorigin=\"anonymous\" src=\"{{ $viewportobserve.RelPermalink }}\"></script>\n\nA notable difference here is that the script file now needs to be placed\ninside assets/js/, since it no longer is just a static file, but instead a\nresource we retrieve using resources.Get for further processing.\n\nDone. Now you can observe any elements getting in/out of the viewport and\napply any changes to them using CSS styles.\n\n  * Hugo\n  * Css\n  * Javascript\n  * Css Transitions\n  * Css Transformations\n  * Hugo Theme\n\n# Discussions around the web\n\nLooking up discussions on social networks...\n\nPowered by discu.eu\n\n# No comments yet\n\n", "frontpage": false}
