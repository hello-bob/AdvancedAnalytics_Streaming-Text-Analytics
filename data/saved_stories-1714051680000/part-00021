{"aid": "40154141", "title": "A walk through the SA-IS Suffix Array Construction Algorithm", "url": "https://zork.net/~st/jottings/sais.html", "domain": "zork.net", "votes": 1, "user": "pncnmnp", "posted_at": "2024-04-25 06:29:54", "comments": 0, "source_title": "Screwtape's Notepad", "source_text": "A walk through the SA-IS algorithm - Screwtape's Notepad\n\n# Screwtape's Notepad\n\n# A walk through the SA-IS Suffix Array Construction Algorithm\u00b6\n\nSome time ago, while looking for solutions to some string-searching problem I\nwas having, I stumbled across the Suffix Array data-structure. It seemed\npromising, so I looked up the algorithm Wikipedia recommended (the \u201cSA-IS\u201d\nalgorithm from the paper \u201cLinear Suffix Array Construction by Almost Pure\nInduced-Sorting\u201d by G. Nong, S. Zhang and W. H. Chan). I downloaded the paper\nfrom the authors\u2019 site and I read through it.\n\nUnfortunately, the paper was aimed at an audience of Computer Science\nresearchers well-versed in the literature of the field, rather than an\nindustry programmer with some spare-time and curiosity, so it made almost no\nsense to me. I decided I would research this research, figure out how the SA-\nIS algorithm worked, and write up the most accessible explanation I could\nmuster.\n\nBefore we begin, though, some caveats:\n\n  * I will explain the ideas behind the SA-IS algorithm, but I won\u2019t go into detail about why they work. For fully-worked proofs, see the original paper.\n  * At any point where I have to choose between an efficiently-implemented example and a simple-to-explain example, I\u2019ll pick simplicity. You can probably come up with practical optimisations yourself.\n  * Although SA-IS can be generally applied to strings with an alphabet of any size, the code shown here is specialised to strings of 8-bit bytes, because in practice that\u2019s what most people will want to do.\n  * The SA-IS algorithm itself is simple enough, but requires storage for intermediate values. To keep things simple I\u2019ll ignore storage costs, but G. Nong\u2019s follow-up paper, \u201cPractical Linear-Time O(1)-Workspace Suffix Sorting for Constant Alphabets\u201d discusses how to build a suffix-array in linear-time and constant (working) space (obviously you need O(n) space to store the resulting sorted array). It\u2019s basically the same as the SA-IS algorithm but it\u2019s smarter about storing intermediate values.\n  * All the code examples are written to work with Python 3, and specifically tested against Python 3.4.\n\n## Table of contents\u00b6\n\n  * A walk through the SA-IS Suffix Array Construction Algorithm\n\n    * Table of contents\n    * What\u2019s a suffix array?\n  * Concepts in SA-IS\n\n    * S-type and L-type suffixes\n    * LMS characters\n    * LMS substrings\n    * Bucket sorting\n  * The SA-IS Algorithm\n\n    * The first guess\n    * Induced sorting: L-type suffixes\n    * Induced sorting: S-type suffixes\n    * Summarise the guessed suffix array\n    * Make a suffix array of the summary\n    * Build the real suffix array\n    * Putting it all together\n\n## What\u2019s a suffix array?\u00b6\n\nA suffix array is an index over a string that helps you find all the times\nsome smaller string occurs inside it, if at all. A suffix array for a string\nwith N characters will generally be an array of N integers, where each item of\nthe array stores an offset into the string, representing the suffix of the\nstring starting at that offset and continuing (as suffixes do) to the end.\n\nThe important thing about a suffix-array is that it represents a sorted\nsequence of suffixes, so you can find some particular suffix\u2014or all the\nsuffixes beginning with some particular string\u2014by using an ordinary binary\nsearch.\n\nHere\u2019s a simple Python function that generates a suffix array:\n\n    \n    \n    >>> def naivelyMakeSuffixArray(source): ... \"\"\" ... A naive, slow suffix-array construction algorithm. ... \"\"\" ... ... # Construct a list of suffixes of the source string. ... suffixes = [] ... for offset in range(len(source) + 1): ... suffixes.append(source[offset:]) ... ... # Sort the suffixes ... suffixes.sort() ... ... # Calculate the start offset of each suffix, storing them in ... # sorted order into the suffix array. ... suffixArray = [] ... for suffix in suffixes: ... offset = len(source) - len(suffix) ... suffixArray.append(offset) ... ... return suffixArray\n\nIf we feed a string like cabbage into this algorithm, we get the correct\nsuffix array in return:\n\n    \n    \n    >>> naivelyMakeSuffixArray(b'cabbage') [7, 1, 4, 3, 2, 0, 6, 5]\n\nThe string contains two instances of the character a, at indexes 1 and 4, and\ntherefore two suffixes starting with a. Sure enough, the indexes 1 and 4 are\ngrouped together in the suffix array. Index 1 comes first, because that suffix\nbegins with ab, which is alphabetically before index 4\u2019s ag.\n\nNote that although the indexes of the characters run 0 to 6, for a total of\nseven characters, the suffix array has eight offsets. The suffix beginning\njust after the last character and continuing to the end of the string is the\nempty suffix, containing no characters. Because it\u2019s the shortest possible\nsuffix, it always winds up sorted to the beginning of the suffix array. Most\npeople who want to use suffix arrays don\u2019t care about the empty suffix, but it\nturns out to be important for the SA-IS algorithm.\n\nThe naive algorithm above just re-uses a standard O(n log n) sorting\nalgorithm, plus it adds the overhead of building a list of suffixes and\nbuilding a new array of offsets at the end. SA-IS manages to do the whole\nthing in O(n) time, faster than just the standard sorting on its own, a\nmassive improvement. To achieve this speed, SA-IS takes advantage of certain\nfeatures of suffix arrays that are not necessarily true of any old array of\nstrings.\n\n# Concepts in SA-IS\u00b6\n\nBefore we get into the details of the SA-IS algorithm, we need to cover the\nconcepts that SA-IS is built on.\n\n## S-type and L-type suffixes\u00b6\n\nWhen sorting an array of suffixes of some string, SA-IS divides them into two\ngroups: \u201cS-type\u201d suffixes and \u201cL-type\u201d suffixes. S-type suffixes are smaller\n(in the sorting sense) than the suffix to their right (and so must appear\ncloser to the start of the finished suffix array) and L-type suffixes are\nlarger than the suffix to their right (and so appear closer to the end).\n\nLet\u2019s take the string cabbage again. The suffix starting at offset 1 is\nabbage; the suffix starting to the right of it is bbage, and abbage comes\nbefore bbage alphabetically, so abbage is an S-type suffix. Meanwhile, the\nsuffix starting at offset 5 is ge; the suffix starting to the right is e, and\nge comes after e, so ge is an L-type suffix.\n\nWe can figure out whether the suffix starting at some particular place is\nS-type or L-type by comparing the character at that place with the character\nto the right, but what if both characters are the same? For example, the\nsuffix at offset 2 is bbage, and the suffix to the right is bage. You could\njust use a normal string comparison, but imagine if one suffix was \u201ca million\nbs followed by age\u201d and the other suffix was \u201ca million and one bs followed by\nage\u201c\u2014that comparison would get expensive quickly! However, because both are\nsuffixes of the same string, it turns out that when a character is the same as\nthe character to its right, then its type is the same as the other character\ntoo. bage turns out to be L-type, and so bbage is also L-type.\n\nTherefore, if we know whether the suffix at some offset is L-type or S-type,\nwe can easily calculate the type of every suffix to the left of that offset by\nstarting at that point and walking left, comparing characters and storing\ntypes. But what about the right-most suffix? It doesn\u2019t have a right-hand\nsuffix to compare to, so we can\u2019t figure out whether it\u2019s larger or smaller!\nWell, in SA-IS the right-most suffix is always the empty suffix, and it\u2019s\ndefined to always be S-type.\n\nNow we have a complete set of rules for determining the type of each suffix of\na string:\n\n  1. The empty suffix at the end of the string is S-type by definition, and therefore the penultimate suffix (containing just the last character) is always L-type (since it\u2019s alphabetically after the empty suffix).\n  2. If the character at offset X is alphabetically larger than the character at offset X+1, the suffix starting at offset X is L-type.\n  3. If the character at offset X is the same as the character at offset X+1, and the suffix starting at offset X+1 is L-type, then the suffix starting at offset X is also L-type.\n  4. Otherwise, the suffix starting at offset X is S-type.\n\nIf we define some values to represent \u201cS-type\u201d and \u201cL-type\u201d:\n\n    \n    \n    >>> S_TYPE = ord(\"S\") >>> L_TYPE = ord(\"L\")\n\n...we can make a function that takes a string and maps out whether each\ncharacter of the source string as S-type or L-type, following the above rules.\n\n    \n    \n    >>> def buildTypeMap(data): ... \"\"\" ... Builds a map marking each suffix of the data as S_TYPE or L_TYPE. ... \"\"\" ... # The map should contain one more entry than there are characters ... # in the string, because we also need to store the type of the ... # empty suffix between the last character and the end of the ... # string. ... res = bytearray(len(data) + 1) ... ... # The empty suffix after the last character is S_TYPE ... res[-1] = S_TYPE ... ... # If this is an empty string... ... if not len(data): ... # ...there are no more characters, so we're done. ... return res ... ... # The suffix containing only the last character must necessarily ... # be larger than the empty suffix. ... res[-2] = L_TYPE ... ... # Step through the rest of the string from right to left. ... for i in range(len(data)-2, -1, -1): ... if data[i] > data[i+1]: ... res[i] = L_TYPE ... elif data[i] == data[i+1] and res[i+1] == L_TYPE: ... res[i] = L_TYPE ... else: ... res[i] = S_TYPE ... ... return res\n\nThe buildTypeMap() function stores its map as a bytearray, so if we want to\nprint out a type-map we\u2019ll need to decode it into text first:\n\n    \n    \n    >>> def showTypeMap(data): ... print(data.decode('ascii')) ... print(buildTypeMap(data).decode('ascii'))\n\nIf we look at the type map of cabbage, we can see the S-type and L-type\nsuffixes are just as we expected:\n\n    \n    \n    >>> showTypeMap(b'cabbage') cabbage LSLLSLLS\n\nNote again that the type-map is longer than the input text, because it\u2019s\nstoring an entry for the empty suffix.\n\n## LMS characters\u00b6\n\nLet\u2019s say that some particular character in our input string is an \u201cS\ncharacter\u201d if an S-type suffix starts at that location (and likewise for an \u201cL\ncharacter\u201d). A \u201cleft-most S character\u201d (or \u201cLMS character\u201d for short), is just\nan S character that has an L character to its immediate left. The first\ncharacter in the string can never be an LMS character (because there\u2019s no\ncharacter to the immediate left, let alone an L character), but apart from\nthat the definition is straightforward. Therefore, we can very easily write a\nfunction to implement this test:\n\n    \n    \n    >>> def isLMSChar(offset, typemap): ... \"\"\" ... Returns true if the character at offset is a left-most S-type. ... \"\"\" ... if offset == 0: ... return False ... if typemap[offset] == S_TYPE and typemap[offset - 1] == L_TYPE: ... return True ... ... return False\n\n...and we can also extend our showTypeMap() function to point out which\ncharacters in the string are LMS characters:\n\n    \n    \n    >>> def showTypeMap(data): ... typemap = buildTypeMap(data) ... ... print(data.decode('ascii')) ... print(typemap.decode('ascii')) ... ... print(\"\".join( ... \"^\" if isLMSChar(i, typemap) else \" \" ... for i in range(len(typemap)) ... ))\n\nNow we can see where the LMS characters are in cabbage:\n\n    \n    \n    >>> showTypeMap(b'cabbage') cabbage LSLLSLLS ^ ^ ^\n\nNote that as a side-effect of our definition, the empty suffix is regarded as\nan LMS character, even though it\u2019s not a character as such.\n\nIf we try a word that has consecutive S characters, we can see that only the\nleft-most S character is marked as an LMS character:\n\n    \n    \n    >>> showTypeMap(b'caabage') caabage LSSLSLLS ^ ^ ^\n\n## LMS substrings\u00b6\n\nLooking at the examples above, you can see that LMS characters are somewhat\nsparse throughout the input string. An \u201cLMS substring\u201d is a portion of the\ninput string starting at one LMS character and continuing up to (but not\nincluding) the next LMS character. In the string cabbage examined above, there\nare two LMS substrings: abb and age. The SA-IS algorithm does its magic by\nsorting LMS substrings, but we can\u2019t use an ordinary string comparison\nfunction because we don\u2019t necessarily know how long each LMS string is. We\u2019d\nneed to walk along the string to find the beginning of the next LMS character,\nand if we\u2019re walking the string anyway, we might as well do the comparison at\nthe same time.\n\nThe rules for comparing LMS substrings are straightforward: they must have the\nsame length and the same characters in the same order. Here\u2019s a function that,\ngiven an input string, its typemap and two offsets into that string,\ndetermines whether the LMS substrings starting at those offsets are equal:\n\n    \n    \n    >>> def lmsSubstringsAreEqual(string, typemap, offsetA, offsetB): ... \"\"\" ... Return True if LMS substrings at offsetA and offsetB are equal. ... \"\"\" ... # No other substring is equal to the empty suffix. ... if offsetA == len(string) or offsetB == len(string): ... return False ... ... i = 0 ... while True: ... aIsLMS = isLMSChar(i + offsetA, typemap) ... bIsLMS = isLMSChar(i + offsetB, typemap) ... ... # If we've found the start of the next LMS substrings... ... if (i > 0 and aIsLMS and bIsLMS): ... # ...then we made it all the way through our original LMS ... # substrings without finding a difference, so we can go ... # home now. ... return True ... ... if aIsLMS != bIsLMS: ... # We found the end of one LMS substring before we reached ... # the end of the other. ... return False ... ... if string[i + offsetA] != string[i + offsetB]: ... # We found a character difference, we're done. ... return False ... ... i += 1\n\nThis function doesn\u2019t explicitly test for reaching the end of the string, but\nremember that the empty suffix at the end of the string is always regarded as\nan LMS character\u2014if i + offsetA reaches the end of the string, then aIsLMS\nmust be true, and the code will always take one of the first two if statements\nin the body of the while loop.\n\nLet\u2019s take a string with some repeated content:\n\n    \n    \n    >>> showTypeMap(b'rikki-tikki-tikka') rikki-tikki-tikka LSLLLSLSLLLSLSLLLS ^ ^ ^ ^ ^ ^\n\nYou can see the LMS substrings at offset 1 and offset 7 both have the same\ncontent (ikki) and the same types (SLLL). Therefore, those two LMS substrings\nshould be equal:\n\n    \n    \n    >>> s = b'rikki-tikki-tikka' >>> tm = buildTypeMap(s) >>> lmsSubstringsAreEqual(s, tm, 1, 7) True\n\nOn the other hand, the LMS substring at offset 13 has the same length and the\nsame types, but different content (ikka), so it should be reported as unequal:\n\n    \n    \n    >>> lmsSubstringsAreEqual(s, tm, 1, 13) False\n\n## Bucket sorting\u00b6\n\nBucket sorting is a common operation even outside the world of suffix arrays,\nbut since it\u2019s important to SA-IS here\u2019s a brief description. Since we\u2019re\nmaking a sorted suffix array, we know that all the suffixes beginning with the\nsame character will wind up grouped together. The string cabbage has two as,\ntwo bs, one c, and no ds, so we can already predict that the first two indexes\nin the suffix array will point at suffixes beginning with a, the bs will take\nthe next two slots, then one for c and none for d.\n\nGiven a string (and the size of its alphabet), the following function will\nfigure out how many suffixes of the string begin with each character of the\nalphabet; colloquially, how many suffixes are in the \u201cbucket\u201d for each\ncharacter:\n\n    \n    \n    >>> def findBucketSizes(string, alphabetSize=256): ... res = [0] * alphabetSize ... ... for char in string: ... res[char] += 1 ... ... return res\n\nWe could find the bucket sizes for cabbage using the traditional ASCII\nencoding for each letter, but ASCII is a 128-character alphabet, and that\nwould make for an awkwardly-long list. Instead, let\u2019s make up our own encoding\nwhere a = 0, b = 1, c = 2, etc.:\n\n    \n    \n    >>> encoded_cabbage = [2, 0, 1, 1, 0, 6, 4]\n\nBecause g is the alphabetically largest letter in our string, we only need 7\ncharacters in our alphabet to spell it. And so, our bucket sizes are:\n\n    \n    \n    >>> findBucketSizes(encoded_cabbage, 7) [2, 2, 1, 0, 1, 0, 1]\n\nAs predicted, the a bucket has two suffixes, b has two, c has one, d has none,\nand so on.\n\nNow that we know how big each bucket is, it\u2019s simple to derive an array where\neach character\u2019s index points at the beginning of the corresponding bucket in\nthe suffix array:\n\n    \n    \n    >>> def findBucketHeads(bucketSizes): ... offset = 1 ... res = [] ... for size in bucketSizes: ... res.append(offset) ... offset += size ... ... return res >>> cabbage_buckets = findBucketSizes(encoded_cabbage, 7) >>> findBucketHeads(cabbage_buckets) [1, 3, 5, 6, 6, 7, 7]\n\nThe empty suffix always winds up at the beginning of the suffix array in index\n0, so the a bucket begins at index 1. There\u2019s two as so the b bucket begins at\n3, and so on. Note that the buckets for d and e both begin at index 6, but\nthere\u2019s no d suffixes so that won\u2019t cause a problem.\n\nWe can easily find the indexes of the end of each bucket in a similar fashion:\n\n    \n    \n    >>> def findBucketTails(bucketSizes): ... offset = 1 ... res = [] ... for size in bucketSizes: ... offset += size ... res.append(offset - 1) ... ... return res >>> findBucketTails(cabbage_buckets) [2, 4, 5, 5, 6, 6, 7]\n\nAnd now, having covered all the background material, let\u2019s talk about the\nalgorithm itself.\n\n# The SA-IS Algorithm\u00b6\n\nThe SA-IS algorithm\u2019s name comes from the fact that it produces a Suffix Array\nby Induced Sorting. What is \u201cInduced Sorting\u201d? Well, the tricky part of\nbuilding a suffix array turns out to be the LMS suffixes. If you imagine a\nsimple string like \u201cAAAAA\u201d, it\u2019s very easy to create a sorted suffix list\nbecause all the suffixes are L-type, so you can just list them out. LMS\nsuffixes are the knots in the string that make the problem hard, so if you\nhave them properly sorted it\u2019s easy to slot all the L-type and other S-type\nsuffixes into place.\n\nAt a very high level, the SA-IS algorithm looks like this (don\u2019t worry about\nthe functions we haven\u2019t defined yet, we\u2019ll get to them in the following\nsections):\n\n    \n    \n    >>> def makeSuffixArrayByInducedSorting(string, alphabetSize): ... \"\"\" ... Compute the suffix array of 'string' with the SA-IS algorithm. ... \"\"\" ... ... # Classify each character of the string as S_TYPE or L_TYPE ... typemap = buildTypeMap(string) ... ... # We'll be slotting suffixes into buckets according to what ... # character they start with, so let's precompute that info now. ... bucketSizes = findBucketSizes(string, alphabetSize) ... ... # Use a simple bucket-sort to insert all the LMS suffixes into ... # approximately the right place the suffix array. ... guessedSuffixArray = guessLMSSort(string, bucketSizes, typemap) ... ... # Slot all the other suffixes into guessedSuffixArray, by using ... # induced sorting. This may move the LMS suffixes around. ... induceSortL(string, guessedSuffixArray, bucketSizes, typemap) ... induceSortS(string, guessedSuffixArray, bucketSizes, typemap) ... ... # Create a new string that summarises the relative order of LMS ... # suffixes in the guessed suffix array. ... summaryString, summaryAlphabetSize, summarySuffixOffsets = \\ ... summariseSuffixArray(string, guessedSuffixArray, typemap) ... ... # Make a sorted suffix array of the summary string. ... summarySuffixArray = makeSummarySuffixArray( ... summaryString, ... summaryAlphabetSize, ... ) ... ... # Using the suffix array of the summary string, determine exactly ... # where the LMS suffixes should go in our final array. ... result = accurateLMSSort(string, bucketSizes, typemap, ... summarySuffixArray, summarySuffixOffsets) ... ... # ...and once again, slot all the other suffixes into place with ... # induced sorting. ... induceSortL(string, result, bucketSizes, typemap) ... induceSortS(string, result, bucketSizes, typemap) ... ... return result\n\nAs an aid to illustrating the algorithm in action, we\u2019ll use the following\nfunction to show the state of a suffix array in progress. We\u2019ll store -1 in\nsuffix array elements that are uninitialised, and since we\u2019ll be demonstrating\nthis algorithm on short strings, we can get away with assuming each offset\nwill be one or two digits long (the same length as \u201c-1\u201d) and render\nintermediate states of a suffix array like this:\n\n    \n    \n    >>> def showSuffixArray(arr, pos=None): ... print(\" \".join(\"%02d\" % each for each in arr)) ... ... if pos is not None: ... print(\" \".join( ... \"^^\" if each == pos else \" \" ... for each in range(len(arr)) ... ))\n\nThis shows all the offsets in a suffix array:\n\n    \n    \n    >>> showSuffixArray([2, -1, 4]) 02 -1 04\n\n...and it also allows an individual cell in the array to be highlighted, to\nshow the progress of whatever part of the algorithm we\u2019re looking at:\n\n    \n    \n    >>> showSuffixArray([2, -1, 4], 2) 02 -1 04 ^^\n\n## The first guess\u00b6\n\nWe don\u2019t yet know exactly where our LMS suffixes should go in our sufffix\narray, so we start by putting them in approximately the right place with a\nbucket sort. All else being equal, a longer suffix (one occurring earlier in\nthe string) sorts after a shorter suffix (one occurring later), so we\u2019ll go\nthrough the string from left-to-right and stack each LMS suffix we find at the\ntail-end of its bucket.\n\n    \n    \n    >>> def guessLMSSort(string, bucketSizes, typemap): ... \"\"\" ... Make a suffix array with LMS-substrings approximately right. ... \"\"\" ... # Create a suffix array with room for a pointer to every suffix of ... # the string, including the empty suffix at the end. ... guessedSuffixArray = [-1] * (len(string) + 1) ... ... bucketTails = findBucketTails(bucketSizes) ... ... # Bucket-sort all the LMS suffixes into their appropriate bucket. ... for i in range(len(string)): ... if not isLMSChar(i, typemap): ... # Not the start of an LMS suffix ... continue ... ... # Which bucket does this suffix go into? ... bucketIndex = string[i] ... # Add the start position at the tail of the bucket... ... guessedSuffixArray[bucketTails[bucketIndex]] = i ... # ...and move the tail pointer down. ... bucketTails[bucketIndex] -= 1 ... ... # Show the current state of the array ... showSuffixArray(guessedSuffixArray) ... ... # The empty suffix is defined to be an LMS-substring, and we know ... # it goes at the front. ... guessedSuffixArray[0] = len(string) ... ... showSuffixArray(guessedSuffixArray) ... ... return guessedSuffixArray\n\nSo now we can guess the positions of the LMS substrings in our string, leaving\nall the other positions set to -1:\n\n    \n    \n    >>> cabbage_buckets = findBucketSizes(b'cabbage') >>> cabbage_types = buildTypeMap(b'cabbage') >>> cabbage_guess = guessLMSSort(b'cabbage', cabbage_buckets, cabbage_types) -1 -1 01 -1 -1 -1 -1 -1 -1 04 01 -1 -1 -1 -1 -1 07 04 01 -1 -1 -1 -1 -1\n\nBecause guessLMSSort() calls showSuffixArray() at various points of the\nprocess, we can trace its operation:\n\n  * the first LMS suffix it finds is abbage at index 1 in the string, so it puts that at the end of the a bucket\n  * the next LMS suffix it finds is age at index 4, so it puts that immediately before abbage\n  * we hit the end of the source string, so we add the empty suffix at position 0 in the suffix array\n\nTo fill in the rest of the positions, we\u2019re going to use \u201cinduced sorting\u201d;\nthat is, determining where to put the other suffixes based on what\u2019s already\nin the array.\n\n## Induced sorting: L-type suffixes\u00b6\n\nNow that we have the LMS suffixes in our suffix array, we can extrapolate\nwhere all the other suffixes go. We start by scanning through our temporary\nsuffix array and for each listed suffix, we check the suffix to the left of it\nin the original string - if that\u2019s L-type, we\u2019ll bucket-sort that one too.\n\n    \n    \n    >>> def induceSortL(string, guessedSuffixArray, bucketSizes, typemap): ... \"\"\" ... Slot L-type suffixes into place. ... \"\"\" ... bucketHeads = findBucketHeads(bucketSizes) ... ... # For each cell in the suffix array.... ... for i in range(len(guessedSuffixArray)): ... if guessedSuffixArray[i] == -1: ... # No offset is recorded here. ... continue ... ... # We're interested in the suffix that begins to the left of ... # the suffix this entry points at. ... j = guessedSuffixArray[i] - 1 ... if j < 0: ... # This entry in the suffix array is the suffix that begins ... # at the start of the string, offset 0. Therefore there is ... # no suffix to the left of it, and j is out of bounds of ... # the typemap. ... continue ... if typemap[j] != L_TYPE: ... # We're only interested in L-type suffixes right now. ... continue ... ... # Which bucket does this suffix go into? ... bucketIndex = string[j] ... # Add the start position at the head of the bucket... ... guessedSuffixArray[bucketHeads[bucketIndex]] = j ... # ...and move the head pointer up. ... bucketHeads[bucketIndex] += 1 ... ... showSuffixArray(guessedSuffixArray, i)\n\nIf we feed this function our guess from before, we can watch it propagate\nL-type suffixes into the array:\n\n    \n    \n    >>> induceSortL(b'cabbage', cabbage_guess, cabbage_buckets, cabbage_types) 07 04 01 -1 -1 -1 06 -1 ^^ 07 04 01 03 -1 -1 06 -1 ^^ 07 04 01 03 -1 00 06 -1 ^^ 07 04 01 03 02 00 06 -1 ^^ 07 04 01 03 02 00 06 05 ^^\n\nTracing through the output above, we can see what it\u2019s done:\n\n  * we start at the first cell in the suffix array, which represents the empty suffix at the end of the string\n  * the character before the empty suffix is e at offset 6, so we slot 6 into the e bucket\n  * the next cell has the suffix age at offset 4, and the suffix to the left of it is the L-type suffix bage at offset 3, so we slot 3 into the b bucket\n  * next is abbage at offset 1, offset 0 has the L-type suffix cabbage, so we slot 0 into the c bucket\n  * we find bage at offset 3, which we stored two steps ago - but the suffix at offset 2 (bbage) is still L-type, so we slot it into the b bucket\n  * we find bbage at offset 2, but the suffix to its left is not L-type so we move on\n  * we find cabbage at offset 0, but there\u2019s nothing to its left, so we move on\n  * we find e at offset 6, and the suffix at offset 5 (ge) is L-type, so we slot it into the g bucket\n  * we find ge at offest 5, but the suffix to its left is not L-type, so we\u2019re done\n\nIf we compare the above output to the result of the naive algorithm...\n\n    \n    \n    >>> showSuffixArray(naivelyMakeSuffixArray(b'cabbage')) 07 01 04 03 02 00 06 05\n\n...we can see that we already have something fairly close to the correct\nanswer. That\u2019s partially because of the power of induced sorting, but also\nbecause cabbage is a pretty easy string to begin with: it only has two S-type\nsuffixes, and they\u2019re both LMS suffixes. Let\u2019s investigate a more complex\nstring:\n\n    \n    \n    >>> baa = b'baabaabac' >>> showTypeMap(baa) baabaabac LSSLSSLSLS ^ ^ ^ ^\n\nThis string has six S-type suffixes, only four of which are LMS-suffixes. If\nwe duplicate what we did with cabbage on this new string...\n\n    \n    \n    >>> baa_buckets = findBucketSizes(baa) >>> baa_types = buildTypeMap(baa) >>> baa_guess = guessLMSSort(baa, baa_buckets, baa_types) -1 -1 -1 -1 -1 01 -1 -1 -1 -1 -1 -1 -1 -1 04 01 -1 -1 -1 -1 -1 -1 -1 07 04 01 -1 -1 -1 -1 09 -1 -1 07 04 01 -1 -1 -1 -1 >>> induceSortL(baa, baa_guess, baa_buckets, baa_types) 09 -1 -1 07 04 01 -1 -1 -1 08 ^^ 09 -1 -1 07 04 01 06 -1 -1 08 ^^ 09 -1 -1 07 04 01 06 03 -1 08 ^^ 09 -1 -1 07 04 01 06 03 00 08 ^^\n\nHere, we can see that at this point, there\u2019s still some uninitialised cells in\nthe suffix array. That\u2019s not suprising, we haven\u2019t touched the S-type suffixes\nyet.\n\n## Induced sorting: S-type suffixes\u00b6\n\nHaving scanned through the suffix array from left-to-right slotting in L-type\nsuffixes, we now scan from right-to-left slotting in S-type suffixes. This is\nbasically a mirror-image of the previous function:\n\n    \n    \n    >>> def induceSortS(string, guessedSuffixArray, bucketSizes, typemap): ... \"\"\" ... Slot S-type suffixes into place. ... \"\"\" ... bucketTails = findBucketTails(bucketSizes) ... ... for i in range(len(guessedSuffixArray)-1, -1, -1): ... j = guessedSuffixArray[i] - 1 ... if j < 0: ... # This entry in the suffix array is the suffix that begins ... # at the start of the string, offset 0. Therefore there is ... # no suffix to the left of it, and j is out of bounds of ... # the typemap. ... continue ... if typemap[j] != S_TYPE: ... # We're only interested in S-type suffixes right now. ... continue ... ... # Which bucket does this suffix go into? ... bucketIndex = string[j] ... # Add the start position at the tail of the bucket... ... guessedSuffixArray[bucketTails[bucketIndex]] = j ... # ...and move the tail pointer down. ... bucketTails[bucketIndex] -= 1 ... ... showSuffixArray(guessedSuffixArray, i)\n\nWhen we apply this next step to our old friend cabbage:\n\n    \n    \n    >>> induceSortS(b'cabbage', cabbage_guess, cabbage_buckets, cabbage_types) 07 04 04 03 02 00 06 05 ^^ 07 01 04 03 02 00 06 05 ^^\n\ncabbage only has two S-type suffixes, so we only get two rows of output. As\nthe function sweeps through the suffix array, it winds up swapping the order\nof the LMS suffixes from \u201c04 01\u201d to \u201c01 04\u201d, and this is enough to transform\nour guessed suffix array into the correct suffix array. That\u2019s just a happy\ncoincidence, though. If we process our other example:\n\n    \n    \n    >>> induceSortS(baa, baa_guess, baa_buckets, baa_types) 09 -1 -1 07 04 07 06 03 00 08 ^^ 09 -1 -1 07 02 07 06 03 00 08 ^^ 09 -1 -1 05 02 07 06 03 00 08 ^^ 09 -1 01 05 02 07 06 03 00 08 ^^ 09 04 01 05 02 07 06 03 00 08 ^^\n\n...it\u2019s shuffled around the LMS suffixes, but compare the result to the output\nof the naive algorithm:\n\n    \n    \n    >>> showSuffixArray(naivelyMakeSuffixArray(baa)) 09 01 04 02 05 07 00 03 06 08\n\nThere\u2019s still a few cells that need to be swapped around.\n\n## Summarise the guessed suffix array\u00b6\n\nWe started with a string of characters in some alphabet, we made an\napproximate suffix array for that string, and now we will summarise that\napproximate suffix array with a new string, in a new alphabet, that represents\njust the most important bits of information: where the LMS suffixes ended up,\nafter induceSortL() and induceSortS() did their thing.\n\nThe summarising works like this: Each LMS suffix of the original string gets a\nname, based on the order in which those suffixes appear in the guessed suffix\narray. Or rather, the LMS substring at the beginning of each LMS suffix gets a\nname: if two LMS suffixes begin with the same LMS substring, they get the same\nname. These names are combined in the same order as the corresponding suffixes\nin the original string to form the summary string.\n\nSA-IS is a recursive algorithm, where constructing the suffix-array for a\nstring involves generating a summary string and constructing the suffix array\nfor that. However, in a practical implementation the first input is likely to\nbe a file in the alphabet of \"bytes\", having at most 256 different characters,\nwhile the summaries will be in alphabets having as many characters as there\nare LMS suffixes in the original file\u2014thousands, millions or more.\n\nTherefore, when implementing SA-IS yourself, you may need a separate\nimplementation for byte-inputs and for large-integer inputs; or make your\nimplementation generic over the input type, if your language supports that.\n\nPython 3 only has one integer type which is arbitrary precision, so the\nimplementation described here doesn't need to worry about different integer\nsizes.\n\nHere\u2019s the corresponding implementation:\n\n    \n    \n    >>> def summariseSuffixArray(string, guessedSuffixArray, typemap): ... \"\"\" ... Construct a 'summary string' of the positions of LMS-substrings. ... \"\"\" ... # We will use this array to store the names of LMS substrings in ... # the positions they appear in the original string. ... lmsNames = [-1] * (len(string) + 1) ... ... # Keep track of what names we've allocated. ... currentName = 0 ... ... # Where in the original string was the last LMS suffix we checked? ... lastLMSSuffixOffset = None ... ... # We know that the first LMS-substring we'll see will always be ... # the one representing the empty suffix, and it will always be at ... # position 0 of suffixOffset. ... lmsNames[guessedSuffixArray[0]] = currentName ... lastLMSSuffixOffset = guessedSuffixArray[0] ... ... showSuffixArray(lmsNames) ... ... # For each suffix in the suffix array... ... for i in range(1, len(guessedSuffixArray)): ... # ...where does this suffix appear in the original string? ... suffixOffset = guessedSuffixArray[i] ... ... # We only care about LMS suffixes. ... if not isLMSChar(suffixOffset, typemap): ... continue ... ... # If this LMS suffix starts with a different LMS substring ... # from the last suffix we looked at.... ... if not lmsSubstringsAreEqual(string, typemap, ... lastLMSSuffixOffset, suffixOffset): ... # ...then it gets a new name ... currentName += 1 ... ... # Record the last LMS suffix we looked at. ... lastLMSSuffixOffset = suffixOffset ... ... # Store the name of this LMS suffix in lmsNames, in the same ... # place this suffix occurs in the original string. ... lmsNames[suffixOffset] = currentName ... showSuffixArray(lmsNames) ... ... # Now lmsNames contains all the characters of the suffix string in ... # the correct order, but it also contains a lot of unused indexes ... # we don't care about and which we want to remove. We also take ... # this opportunity to build summarySuffixOffsets, which tells ... # us which LMS-suffix each item in the summary string represents. ... # This will be important later. ... summarySuffixOffsets = [] ... summaryString = [] ... for index, name in enumerate(lmsNames): ... if name == -1: ... continue ... summarySuffixOffsets.append(index) ... summaryString.append(name) ... ... # The alphabetically smallest character in the summary string ... # is numbered zero, so the total number of characters in our ... # alphabet is one larger than the largest numbered character. ... summaryAlphabetSize = currentName + 1 ... ... return summaryString, summaryAlphabetSize, summarySuffixOffsets\n\nThat\u2019s a lot of code, and it\u2019s a little bit intricate, but let\u2019s look at some\nexamples.\n\n    \n    \n    >>> ( ... cabbage_summary, ... cabbage_summary_alpha_size, ... cabbage_summary_suffix_offsets, ... ) = summariseSuffixArray(b'cabbage', cabbage_guess, cabbage_types) -1 -1 -1 -1 -1 -1 -1 00 -1 01 -1 -1 -1 -1 -1 00 -1 01 -1 -1 02 -1 -1 00\n\nAs we saw above, the guessed suffix array of cabbage looks like this:\n\n    \n    \n    >>> showSuffixArray(cabbage_guess) 07 01 04 03 02 00 06 05\n\nOf those suffixes, we know the first three are the LMS suffixes; in order, the\nempty suffix, abbage and age. Because all three LMS suffixes begin with\ndifferent LMS substrings, they get three distinct names (0, 1 and 2). Those\nnames are stored in lmsNames at the positions where the corresponding suffix\noccurs in the original string: at offsets 7, 1 and 4 respectively.\n\nAfter lmsNames is calculated, we throw away the unused indices of lmsNames to\nproduce the summary string:\n\n    \n    \n    >>> cabbage_summary [1, 2, 0]\n\nBut that\u2019s not the only output from our function. We also know that the\nsummary string is written in an alphabet with three distinct characters:\n\n    \n    \n    >>> cabbage_summary_alpha_size 3\n\n...and we have a list that stores the suffix offset associated with each item\nin the summary string.\n\n    \n    \n    >>> cabbage_summary_suffix_offsets [1, 4, 7]\n\nBut as noted previously, cabbage is a pretty simple string. Let\u2019s try our more\ncomplex example, baabaabac:\n\n    \n    \n    >>> ( ... baa_summary, ... baa_summary_alpha_size, ... baa_summary_suffix_offsets, ... ) = summariseSuffixArray(baa, baa_guess, baa_types) -1 -1 -1 -1 -1 -1 -1 -1 -1 00 -1 -1 -1 -1 01 -1 -1 -1 -1 00 -1 01 -1 -1 01 -1 -1 -1 -1 00 -1 01 -1 -1 01 -1 -1 02 -1 00\n\nFor this string, two of the LMS suffixes start with the same LMS substring:\naabaabac and aabac both start with aab and the types of those characters are\nSSL in both cases. Consequently, both suffixes get the same name (1) and our\nsummary string contains two identical characters:\n\n    \n    \n    >>> baa_summary [1, 1, 2, 0]\n\nAlthough this summary string contains four characters, it still only contains\nthree distinct characters, so the alphabet size is still 3:\n\n    \n    \n    >>> baa_summary_alpha_size 3\n\nAnd we get the suffix offset map for the summary string again:\n\n    \n    \n    >>> baa_summary_suffix_offsets [1, 4, 7, 9]\n\n## Make a suffix array of the summary\u00b6\n\nWe started with one string and wanted to build a suffix array, and in the\nprocess we\u2019ve build a second string and now we have to make a suffix array of\nthat one too? Isn\u2019t that circular reasoning?\n\nWell, almost: it\u2019s recursive reasoning.\n\nIf we\u2019re going to do recursion, there needs to be a base case that\u2019s not\nrecursive. If we look at our cabbage example above, we got a pretty simple\nsummary string:\n\n    \n    \n    >>> cabbage_summary [1, 2, 0]\n\nYes, that particular example happens to be small enough that you could build\nthe suffix array in your head, but there\u2019s another interesting feature: we\u2019ve\nsaid it\u2019s a string in an alphabet of three characters, and every character in\nthe alphabet appears exactly once, somewhere in that string. Which means we\ncan create a suffix array with our trusty old bucket sort.\n\nIf we look at our baabaabac example on the other hand, the outlook isn\u2019t\nnearly as rosy:\n\n    \n    \n    >>> baa_summary [1, 1, 2, 0]\n\nThis string is still in an alphabet of three characters, but it\u2019s more than\nthree characters long, which means at least one character must be repeated and\nwe can\u2019t be sure a bucket sort will do the right thing - so in that situation\nwe\u2019ll have to recurse.\n\nIt\u2019s worth pointing out that while you could in theory have a three-character\nstring in an alphabet of three characters that included repetition (say, [1,\n1, 0]), our summariseSuffixArray() function will never generate such a thing,\nsince it always uses consecutive characters in the alphabet, and it always\nsets the alphabet size to the number of distinct characters it\u2019s used.\n\n    \n    \n    >>> def makeSummarySuffixArray(summaryString, summaryAlphabetSize): ... \"\"\" ... Construct a sorted suffix array of the summary string. ... \"\"\" ... if summaryAlphabetSize == len(summaryString): ... # Every character of this summary string appears once and only ... # once, so we can make the suffix array with a bucket sort. ... summarySuffixArray = [-1] * (len(summaryString) + 1) ... ... # Always include the empty suffix at the beginning. ... summarySuffixArray[0] = len(summaryString) ... ... for x in range(len(summaryString)): ... y = summaryString[x] ... summarySuffixArray[y+1] = x ... ... else: ... # This summary string is a little more complex, so we'll have ... # to use recursion. ... summarySuffixArray = makeSuffixArrayByInducedSorting( ... summaryString, ... summaryAlphabetSize, ... ) ... ... return summarySuffixArray\n\nWe can\u2019t test this function on the baabaabac summary yet because we haven\u2019t\nfinished the recursive implementation, but we can test it on the cabbage\nsummary:\n\n    \n    \n    >>> cabbage_summary_suffix_array = makeSummarySuffixArray( ... cabbage_summary, cabbage_summary_alpha_size, ... ) >>> showSuffixArray(cabbage_summary_suffix_array) 03 02 00 01\n\n...and compare that with our naive implementation:\n\n    \n    \n    >>> showSuffixArray(naivelyMakeSuffixArray(cabbage_summary)) 03 02 00 01\n\n## Build the real suffix array\u00b6\n\nAt last we begin building the real, final suffix array, based on the suffix\narray of the summary string. As before, we start by placing the LMS suffixes\ninto the suffix array, and then we can fill in all the others by induced\nsorting. Unlike before, we don\u2019t just bucket-sort them into place in whatever\norder we find them, we insert them in an order determined by the summary\nstring\u2019s suffix array.\n\nRemember, when we built the summary string (where each character was a\ngenerated name for an LMS substring), we also built a corresponding\nsummarySuffixOffsets array that maps characters from the summary string back\nto LMS substrings (and hence, LMS suffixes) from the original string, so\nthat\u2019s what we\u2019re going to use.\n\nThe process goes something like this: Each entry in the suffix array of the\nsummary string points at a position in summary. We look at the same position\nin summarySuffixOffsets to find the offset of the corresponding LMS suffix of\nour original string. Then we put that LMS suffix into the correct bucket,\ntrusting in the summary suffix array to put them in the correct order within\nthe bucket.\n\n    \n    \n    >>> def accurateLMSSort(string, bucketSizes, typemap, ... summarySuffixArray, summarySuffixOffsets): ... \"\"\" ... Make a suffix array with LMS suffixes exactly right. ... \"\"\" ... # A suffix for every character, plus the empty suffix. ... suffixOffsets = [-1] * (len(string) + 1) ... ... # As before, we'll be adding suffixes to the ends of their ... # respective buckets, so to keep them in the right order we'll ... # have to iterate through summarySuffixArray in reverse order. ... bucketTails = findBucketTails(bucketSizes) ... for i in range(len(summarySuffixArray)-1, 1, -1): ... stringIndex = summarySuffixOffsets[summarySuffixArray[i]] ... ... # Which bucket does this suffix go into? ... bucketIndex = string[stringIndex] ... # Add the suffix at the tail of the bucket... ... suffixOffsets[bucketTails[bucketIndex]] = stringIndex ... # ...and move the tail pointer down. ... bucketTails[bucketIndex] -= 1 ... ... showSuffixArray(suffixOffsets) ... ... # Always include the empty suffix at the beginning. ... suffixOffsets[0] = len(string) ... ... showSuffixArray(suffixOffsets) ... ... return suffixOffsets\n\nNote: to make sure our LMS suffixes survive the induced sorting later, we need\nto insert them at the end of their buckets, so we need to walk backward\nthrough summarySuffixArray as we insert the suffixes backwards, to maintain\ntheir relative order.\n\nAlso, we don\u2019t process every entry in summarySuffixArray: the first entry\ncorresponds to the empty suffix of the summary string, which does not\ncorrespond to any suffix of the original string. The second entry corresponds\nto the empty suffix of the original string, which we can\u2019t bucket-sort into\nplace because it\u2019s empty. We already know it winds up at the beginning,\nthough, so it\u2019s not a problem.\n\nLet\u2019s walk through the algorithm as it applies to our old friend cabbage. As a\nreminder, here\u2019s the inputs to accurateLMSSort():\n\n    \n    \n    >>> showSuffixArray(cabbage_summary_suffix_array) 03 02 00 01 >>> showSuffixArray(cabbage_summary) 01 02 00 >>> showSuffixArray(cabbage_summary_suffix_offsets) 01 04 07\n\nAnd now, we can walk through the algorithm.\n\n  * The first entry we find in the summary\u2019s suffix array (the last entry, since we\u2019re walking backwards) is 01. If we look at offset 1 of summarySuffixOffsets, we see this corresponds to the LMS suffix at position 4 of the original string (age) so we can slot in that suffix at the end of the a bucket.\n  * The next entry in the summary\u2019s suffix array is 00, offset 0 of summarySuffixOffsets corresponds to the LMS suffix at position 1 of the original string (abbage), so we slot that suffix into the a bucket just before age.\n  * The second-last entry is skipped because it points at the empty suffix of the original string and we can\u2019t bucket-sort that into place.\n  * The last entry is skipped because it represents the empty suffix at the end of the summary string, it doesn\u2019t have a corresponding LMS suffix in the original string.\n  * Finally, we know that the empty suffix (at position 7) will wind up at the beginning of our final suffix array.\n\nWhen we run our function, we can see the same steps occurring:\n\n    \n    \n    >>> cabbage_real = accurateLMSSort(b'cabbage', cabbage_buckets, ... cabbage_types, cabbage_summary_suffix_array, ... cabbage_summary_suffix_offsets) -1 -1 04 -1 -1 -1 -1 -1 -1 01 04 -1 -1 -1 -1 -1 07 01 04 -1 -1 -1 -1 -1\n\n04 is slotted in at the at the end of the a bucket, then 01 immediately before\nthat, then finally the empty suffix gets its special place at the beginning.\n\n## Putting it all together\u00b6\n\nAfter putting the LMS suffixes into their correct places, all the other\nsuffixes fall into place with a second round of induced sorting, just as\nbefore. We\u2019ve now described all the functions that\nmakeSuffixArrayByInducedSorting() calls, so we can invoke it to efficiently\nbuild a suffix array of any string we like... along with a detailed log of its\ninner calculations (omitted here for brevity):\n\n    \n    \n    >>> showSuffixArray(makeSuffixArrayByInducedSorting(b'cabbage', 256)) -1 -1 01 -1 -1 -1 -1 -1 ... 07 01 04 03 02 00 06 05 >>> showSuffixArray(makeSuffixArrayByInducedSorting(baa, 256)) -1 -1 -1 -1 -1 01 -1 -1 -1 -1 ... 09 01 04 02 05 07 00 03 06 08\n\nBut since most people who want to build a sorted suffix array will have a\nstring of bytes, rather than strings of an arbitrary-sized alphabet, let\u2019s\nmake a wrapper function with a sensible default:\n\n    \n    \n    >>> def makeSuffixArray(bytestring): ... return makeSuffixArrayByInducedSorting(bytestring, 256)\n\nAnd now we\u2019re done.\n\n    \n    \n    >>> naivelyMakeSuffixArray(b'cabbage') == makeSuffixArray(b'cabbage') True >>> naivelyMakeSuffixArray(baa) == makeSuffixArray(baa) True\n\n", "frontpage": false}
