{"aid": "40251641", "title": "OpenAPI v4.0 (a.k.a. \"Project Moonwalk\")", "url": "https://bump.sh/blog/openapi-v4-moonwalk", "domain": "bump.sh", "votes": 1, "user": "nick238", "posted_at": "2024-05-03 19:52:35", "comments": 0, "source_title": "OpenAPI v4.0 (A.K.A \"Project Moonwalk\") \u00b7 Bump.sh", "source_text": "OpenAPI v4.0 (A.K.A \"Project Moonwalk\") \u00b7 Bump.sh\n\nBlog OpenAPI v4.0 (A.K.A \"Project Moonwalk\")\n\n# OpenAPI v4.0 (A.K.A \"Project Moonwalk\")\n\nWhat is coming next for OpenAPI, as v4.0 of the OpenAPI Specification gets\ncloser to being released? What major changes are coming, how easy will it be\nto upgrade, and how do tooling companies feel about it?\n\n## Recent History of OpenAPI\n\nOpenAPI has been around for a long time, but only hit the mainstream when\nOpenAPI v3.0 was released in 2017. It made it a whole lot easier to describe\nthe majority of REST/RESTish APIs, and brought in major investment from\ntooling developers big and small who jumped at the chance to add value to the\ncommunity.\n\nOpenAPI v3.1 came out in early 2021, and focused on fixing issues that\nappeared with this influx of new users in v3.0. A large part of the focus was\nsolving the subtle but problematic differences between JSON Schema and the\nOpenAPI Schema Object. These two specifications looked similar enough that\nmany users (and even tooling) treated them as interchangeable, but OpenAPI\nSchema Objects were a subset and a superset of JSON Schema, which caused\nconfusion for years. OpenAPI v3.1 aligned Schema Objects to be a valid\n\u201cdialect\u201d of JSON Schema 2020-12, which not only solved this long standing\nissue, but brought lots of useful new keywords like if/then/else to replace\nawkward nested allOf > oneOf usage. Other useful functionality like support\nfor Webhooks expanded the type of APIs that could be described.\n\nSo what is OpenAPI v4.0 about?\n\n## Introducing OpenAPI Project Moonwalk\n\nWith OpenAPI v3.1 released and chugging along happily, the OpenAPI TSC spent\nabout a year keeping an eye on feedback, patching the specification with fixes\nand clarifications, then started collating ideas for the next version. Would\nit be 3.2? Would it be 4.0? Both?\n\nIt wasn\u2019t entirely clear for a while which would be the next step, but in late\n2022 the OpenAPI Technical Steering Committee set up a Special Interest Group\nto start hashing out what the community needed out of a new major OpenAPI\nversion, and that resulted in Project Moonwalk, a repository where ideas could\ninitially be hashed out and potentially abandoned without confusing everyone\nwith OpenAPI v4.0 being \u201ccancelled\u201d and forcing them to skip a version like\nPHP\u2019s missing version 6... \ud83e\udd23\n\nThe primary goal of Project Moonwalk is to make the next version of OpenAPI\nmore approachable, and less complex for both humans and computers to write and\nunderstand.\n\n### Reduce nested structures to improve readability and editability\n\nLet\u2019s be honest, OpenAPI v3 can sometimes feel like a confusing pile of YAML.\nIt\u2019s grown to add excellent functionality which is a large part of how it\nachieved dominance against earlier API Description Formats, but it\u2019s got\npretty complex to write by hand. This complexity has lead to a plethora of\nopen-source and paid tooling aiming to assist the editing experience, from\nDSL\u2019s to write OpenAPI in easier language, to visual editors to avoid ever\nneeding to look at the YAML.\n\nMore recently LLMs like Copilot are helping remind users, myself included, how\nto write out all the right response, mime type, content, status code, schema,\nkeywords... when core contributors of OpenAPI need to melt the ice caps with\nAI just to remember what keyword comes next, it might be time for a\nsimplification.\n\nHere\u2019s the new structure (as it stands).\n\nDiagrams like this can fail to convey much meaning to folks like myself, so\nlets create an example before (OAS3) and after (OAS4) by taking a snippet from\nthe Train Travel API (source on GitHub).\n\n    \n    \n    /bookings/{bookingId}: parameters: - name: bookingId in: path required: true description: The ID of the booking to retrieve. schema: type: string format: uuid example: 1725ff48-ab45-4bb5-9d02-88745177dedb get: summary: Get a booking description: Returns the details of a specific booking. operationId: get-booking responses: '200': description: The booking details headers: RateLimit: $ref: '#/components/headers/RateLimit' content: application/json: schema: $ref: '#/components/schemas/Booking' application/xml: schema: $ref: '#/components/schemas/Booking'\n\nNow let\u2019s try that in OpenAPI 4.0 Project Moonwalk:\n\n    \n    \n    /bookings/{bookingId}: parameterSchema: bookingId: description: The ID of the booking to retrieve. type: string format: uuid examples: [1725ff48-ab45-4bb5-9d02-88745177dedb] requests: getBooking: method: get summary: Get a booking description: Returns the details of a specific booking. responses: Ok: status: '200' contentType: application/json contentSchema: $ref: '#/components/schemas/Booking'\n\nThe nesting has been reduced by making status and contentType a new property\nin the response instead of another key and another level of nesting. I can\nremember keywords like status and contentType a lot easier than I can remember\nthe order of that many keys and objects. Similarly the API requests definition\nhave received the new method property avoiding yet another level of parent\nnesting.\n\nAnother nice benefit is the OAS \u201cParameters Object\u201d being replaced with\nparameterSchema. This is a simple JSON Schema object, which is a lot easier\nfor tooling developers to work with than stitch together object maps of \u201cname\u201d\nand \u201cin\u201d, where parameters are unique based on their location in the URL...\nThis can be confusing for users too, when you get messages about \u201cParameter\nfoo is not unique\u201d because you had a foo defined in the Path\u2019s Parameters\nObject, but a foo also defined in the query string in the Operations\nParameters Object. This is just one place, with one list of parameters that\ncan all be reasoned about together.\n\nA handy bonus is seeing Operation ID moved from in object to being a key.\nOperation ID is super handy for lots of tooling, from documentation to SDK\ngeneration, but it is rarely used. This means everyone will be defining it!\n\n### Support APIs that have different responses based on query parameters,\nheaders and request bodies.\n\nFor starters, there is an explicit goal of allowing more types of API than\nonly REST/REST-inspired APIs. This will now support all sorts of RPC API,\nwhich often uses fewer URLs, and sends a \u201cmethod\u201d, \u201caction\u201d, or \u201ccommand\u201d as a\nparameter in the request body or query string.\n\nThis would not have been possible in OpenAPI v3.x as a URL is expected to have\none purpose only, and the shape of the response is expected to be the same\nregardless of what is sent.\n\nHere\u2019s an example of an API that sends service.{serviceName} as a request\nheader to decide what to do. This is a bit of a contrived example, but the\ngoal is to show the flexibility of the new approach, where requests and\nresponses can be defined to work in all sorts of ways, other than REST(ish)\nbest practice. There\u2019s nothing wrong with RPC, and the more APIs that can be\ndescribed by OpenAPI the better.\n\n    \n    \n    openapi: 4.0.0 info: title: RPC API version: 1.0.0 paths: \"/service\": requests: createFoo: method: post parameterSchema: type: object properties: header: ## We can either use this specially named property or create a first class headerSchema property on the Request Object type: object properties: path: const: service.createFoo ## path Header field used to convey the RPC method contentType: application/json contentSchema: $ref: \"#/components/schemas/foo\" responses: ok: status: 201 contentType: application/json contentSchema: $ref: \"#/components/schemas/foo\" getFoo: method: get parameterSchema: type: object properties: header: type: object properties: path: const: service.getFoo ## path Header field used to convey the RPC method responses: ok: status: 200 contentType: application/json contentSchema: $ref: \"#/components/schemas/foo\" deleteFoo: method: post parameterSchema: type: object properties: header: type: object properties: path: const: service.deleteFoo responses: ok: status: 200 contentType: application/json contentSchema: $ref: \"#/components/schemas/foo\"\n\nHere the parameterSchema is playing a role in deciding which method is being\ncalled, because the path property could be anything, but by defining const\n(constant value) it\u2019s like writing a switch statement, where the case is the\nvalue of the const. Basically, if the path value matches this const value, a\nrequest will match this \u201coperation signature\u201d for this specific request. This\ncan be used for data validation, documentation, SDK generation, and everything\nelse, it\u2019s just a bit of a different way to think about things. A more JSON\nSchema way.\n\n### Support a broader range of URL design patterns\n\nAs well as being able to work with more types of API than REST(ish), there are\nplenty of times REST API designers have had their hands tied by limitations on\nthe sorts of URLs and parameter structures allowed in OpenAPI.\n\nFor example, in OAS3.x all path parameters have to be required, there is no\nway to have optional path parameters, or multi-segment path parameters.\n\nNeither of these sorts of URLs would be allowed in OAS3.1:\n\n  1. /files/{mypath}/{filename} - The mypath parameter would need to have slashes escaped and be considered one parameter.\n  2. /reports/{reportName}/{nonDefaultFormat} - The nonDefaultFormat would need to be provided every time, or two different operations would need to be defined with and without it, which can lead to a lot of duplication.\n\nAll of these things are common enough that the RFC 6570: URI Templates popped\nup back in 2012, and whilst OpenAPI paths look a bit like URI Templates they\nare only a subset of what it can do.\n\nProject Moonwalk once again says \u201chey there\u2019s a standard for that, let\u2019s use\nit!\u201d and defers all path logic to the URI Template RFC. Using this RFC brings\nloads of powerful syntax, and adds support for loads of existing tooling which\ncan make use of it.\n\n    \n    \n    paths: \"/files/{/filepath*}\": # filepath can contain as many URI segments as needed \"/reports/{reportName}{/nonDefaultFormat}\": # this last one is now optional\n\nYou can do all sorts of advanced stuff, like define custom server names for\nparticular operations should you have some need to do that, or work with all\nsorts of complex arrays or objects in the query string without having to\ndecypher the arcane (and rarely supported) style/explode parameter\ncombinations in OAS3.x.\n\n    \n    \n    {/list} /red,green,blue {/list*} /red/green/blue {/list*,path:4} /red/green/blue/%2Ffoo {/keys} /semi,%3B,dot,.,comma,%2C {/keys*} /semi=%3B/dot=./comma=%2C\n\nLearn more about URI Templates.\n\n### When will OpenAPI v4.0 Be Released?\n\nIt\u2019s still being worked on, but the OpenAPI Initiative have set the target\nrelease date for \u201csometime in 2024\u201d.\n\nThere is always a delay between a specification being released and tooling\nvendors adding support for it, but unlike the v2.0 to v3.0 transition, the\nv3.0 to v3.1 was much quicker, and much easier. Whenever a specification like\nthis ditches a unique snowflake of a concept and replaces it with an existing\nbattle tested standard, the tooling migration gets a lot easier, as tooling\nvendors can wrap a few thousand lines of their code in an if statement, and\nthe else is an existing library that has a whole bunch of tests.\n\nThere is already a lot of tooling out there helping with migrations, and the\nword on the grapevine from some of the modern tooling companies is that\nthey\u2019re already experimenting with OAS4 to make sure they\u2019re ready when it\ndrops.\n\n### Ongoing Discussions\n\nThere are still lots of ongoing discussions occurring, and things are likely\nto change somewhat before the final release, but now is a good time to be\nhaving a look around. Take a look at some of the examples, then a look at the\nongoing discussions.\n\nReplacing $ref with \u201cimports\u201d\n\nThe $ref keyword is incredibly powerful, and can be used to \u201cinclude\u201d bits of\nOpenAPI and JSON Schema via a filepath, or a URL. This not only helps avoid\nrepetition in a single OpenAPI document, but can be used to share components\nbetween multiple APIs, and can enable schema reuse across an entire\norganization (or even be published publicly and shared to others).\n\nSadly $ref has a history of not quite doing what people expect, not quite\nlining up with JSON Schema, and trying to keep up with changing expectations\nas those communities all continue to evolve. The reliance on the filesystem\nstructure makes it hard to share documents with $ref, and lots of tools either\ndon\u2019t understand them, only support some of the functionality, or implement\nthings incorrectly...\n\nThe latests versions of JSON Schema have standardized some really useful $ref\nresolutions that work outside of the filesystem, with an approach of \u201cassuming\nyou\u2019ve got all these files from a repo, zip, floppy disk, whatever, they\u2019ll\nall declare their $id and you can $ref on that. This has been great for the\nJSON Schema community, but the OpenAPI community has struggled to see any\ntake-up on this at all.\n\nA new approach is being considered, conceptually referred to for now as\n\u201cMoonwalk imports\u201d.\n\nOpenAPI users can define a document like this, which for example purposes is\npurely using components.\n\n    \n    \n    openapi: 4.0.0 self: https://example.com/fooComponents components: pathItems: Foos: {...} schemas: Foos: {...}\n\nThen in another document they can define all the paths, and import than\ncomponents document, referencing them with the namespace value to\ndifferentiate them from components defined in the local document.\n\n    \n    \n    openapi: 4.0.0 self: https://example.com/fooPaths components: pathItems: Bars: {...} imports: - namespace: foo href: fooComponents paths: /foos: foo:Foos /bars: self:Bars\n\nThis is an interesting approach, which relies on RFC 3987: Internationalized\nResource Identifiers (IRIs), keeping with the theme of replacing OpenAPI-\nspecific things with existing standards.\n\nBetter Tags\n\nI am keeping a close eye on a discussion to improve Tags, because they\u2019ve\nalways felt a bit overloaded and confused with different tools having wildly\ndifferent expectations for what they\u2019re for and how they should be formatted.\n\nBetter tags \u00b7 OAI sig-moonwalk \u00b7 Discussion #67\n\nRemoving Discriminator\n\nThen there\u2019s the discussion about removing discriminator entirely, because its\nbeen so poorly defined it\u2019s been confusing people for years. It adds nothing\non top of oneOf and does not exist in JSON Schema, so it\u2019s hard to add support\nwithout custom writing an extension for specifically just that. Ditch it.\n\nReplace or remove discriminator \u00b7 OAI sig-moonwalk \u00b7 Discussion #57\n\nImproving Links\n\nLinks, can we upgrade the OAS 3 concept of Links from a rarely used or\nsupported \u201cNext Step hints\u201d idea into something a bit more useful? Being able\nto link backwards as well as forwards. Being able to link to other servers\nusing a full URL not just jump around the current API. It\u2019s a lot more HATEOAS\nthis way.\n\nProposal for links in OpenAPI v4\n\nIf you\u2019re interested in Moonwalk, give it a shot. You can try out the concepts\non your own OpenAPI documents to see how it looks. You\u2019ll have to do that\nmanually for now as tooling is waiting for the plan to settle, but Bump.sh\nwill be keeping an eye on things and adding experimental support as soon as\nthe time feels right. Until then keep getting feedback to the OAI so they can\nmake this as good as possible.\n\nWritten by\n\nPhil Sturgeon\n\nPublished on\n\nApr 24, 2024\n\nShare this\n\nLinkedIn Twitter Facebook\n\nWant to try Bump.sh?\n\nAccess 14 day free trial\n\n## Continue Reading\n\nTech\n\n## Documenting PHP APIs with OpenAPI\n\nThe Bump.sh team has been busy adding brilliant features to the hosted service\nand their command-line tools, and whilst they\u2019ve been doing that I\u2019ve been\ntyping up infinite guides helping people learn how to get OpenAPI out of (or\ninto!) their various programming languages and web frameworks.\n\nKeep reading\n\nTech\n\n## Train Travel API: A Modern OpenAPI PetStore Replacement\n\nEveryone working with OpenAPI (formerly Swagger) will have come across the\nPetStore at some point. It's a sample OpenAPI description for an imaginary Pet\nStore with an API, but the OpenAPI is old, and the API it describes is pretty\nfar from best practices. We thought it was time for a refresh, so we're\nbringing you the Train Travel API, a new sample OpenAPI you can use for your\ntooling and testing.\n\nKeep reading\n\n## Preview your documentation using a Swagger, OpenAPI or AsyncAPI file.\n\n  * URL preview\n  * Bump CLI\n\nTry it with an OpenAPI or an AsyncAPI example.\n\nnpm install -g bump-cli\n\nbump preview path/to/your/file.json\n\nMore infos about our CLI in our documentation.\n\n### Product\n\n  * API Documentation\n  * Change management\n  * Hubs\n  * API Diff\n\n### Specifications\n\n  * OpenAPI (Swagger)\n  * AsyncAPI\n  * GraphQL\n  * gRPC\n  * SOAP\n\n### Compare\n\n  * APIMatic\n  * RapiDoc\n  * Redoc\n  * Stoplight\n  * Swagger UI\n\n### Information\n\n  * About\n  * Pricing\n  * Students\n  * Careers Hiring\n\n### Resources\n\n  * Customers\n  * Blog\n  * Help center\n  * CLI\n  * Status\n  * Contact\n\n  * \u00a9 2024, Bump.sh.\n  * Privacy policy\n  * Legal mentions\n  * Terms of use\n  * Cookie policy\n  * Data Processing Agreement\n\nWe use essential cookies and optional ones for your experience and marketing.\nRead our Cookie Policy.\n\n", "frontpage": false}
