{"aid": "40154202", "title": "Building a Micro HTMX SSR Framework", "url": "https://blog.platformatic.dev/building-a-micro-htmx-ssr-framework", "domain": "platformatic.dev", "votes": 1, "user": "thunderbong", "posted_at": "2024-04-25 06:37:51", "comments": 0, "source_title": "Building a Micro HTMX SSR Framework", "source_text": "Building a Micro HTMX SSR Framework\n\n# Building a Micro HTMX SSR Framework\n\nMatteo Collina\n\n\u00b7Mar 21, 2024\u00b7\n\n25 min read\n\n## Table of contents\n\n  * Starting a new Vite project\n\n  * Turning it into a Fastify application\n\n  * Configuring the client\n\n  * Configuring the server\n\n  * Configuring build scripts\n\n  * Ensuring route client imports\n\n  * Leveraging Vite's SSR manifest\n\n  * Adding JSX support via @kitajs/html\n\n  * Adding support for HTML fragments\n\n  * Reviewing our setup\n\n  * Rewriting the Movie Quotes App\n\n  * Rewriting the boilerplate\n\n  * Loading .env files\n\n  * Generating a Platformatic DB client\n\n  * Rewriting the layout component\n\n  * Rewriting the like action component\n\n  * Rewriting the movie quotes listing\n\n  * Wrapping up\n\nIn the Movie Quotes App Tutorial tutorial from Platformatic's documentation\nsuite, we walked through building a multi-tier application with the service\nlayer built on Fastify backed by Platformatic DB and the frontend built on\nAstro.\n\nIn this tutorial we'll explore an alternative stack for running the Movie\nQuotes App frontend, with nothing but Fastify, Vite and HTMX.\n\nEven though the JavaScript web server ecosystem has recently gained some\nnoteworthy additions to choose from, such as Nitro, Hono and ElysiaJS, Fastify\nremains our recommendation to companies who want a fast, safe and mature web\nserver for Node.js.\n\nWith over half a million weekly downloads on npm, Fastify is trusted by\nthousands of companies due to its performance-oriented design, rich API and\nsimplicity all around.\n\nVite has quickly become the industry standard for bundling modern\napplications, with frameworks like Nuxt, SvelteKit and SolidStart all based on\nit. Vite uses native ESM to quickly deliver files in development mode, but\nstill produces a bundle for production. Check out the motivation page in\nVite's documentation to learn more.\n\nHTMX has recently gained popularity due to its small footprint and radically\nsimple approach of using HTML attributes to automatically enable several\nfunctionalities that would otherwise require writing JavaScript code. That is\nnot to say HTMX applications don't require any JavaScript, which is not the\ncase necessarily.\n\nHTMX has a series of events that you can subscribe to via JavaScript when\nneeded, but it provides a nice set of conventions where in most scenarios\nJavaScript isn't needed at all. For instance, you can cause the contents of a\n<div> to be automatically replaced with new markup rendered from a URL with\njust a few attributes:\n\n    \n    \n    <ul class=\"list\"> </ul> <button hx-post=\"/render-list\" hx-swap=\"outerHTML\" hx-target=\"previous .list\"> Load list </button>\n\nCheck out the HTMX documentation to learn more.\n\nInstead of relying on a full blown framework like Astro, by simply using\nFastify, Vite and JSX via @kitajs/html, we can build a mini Server-Side\nRendering framework that will render markup on the server from JSX page\nmodules, but still be able to load any client-oriented assets loaded from\nthese same page modules, such as CSS files. Which should be enough to rewrite\nthe Movie Quotes App in JSX and HTMX.\n\nBut we'll get there step-by-step, first by taking a crash course in Vite, then\nlearning how to integrate it into Fastify applications and finally moving on\nto the rewrite.\n\n## Starting a new Vite project\n\nThe best way to start a new Vite project is to use create-vite CLI, which can\nbe easily called via npm or any other package manager. It has scaffolding\ntemplates for most frameworks, but we'll just use the vanilla preset:\n\n    \n    \n    npm create vite micro-htmx-framework-tutorial --template vanilla\n\nAfter running this command micro-htmx-framework-tutorial should contain:\n\n    \n    \n    \u251c\u2500\u2500 .gitignore \u251c\u2500\u2500 counter.js \u251c\u2500\u2500 index.html \u251c\u2500\u2500 main.js \u251c\u2500\u2500 style.css \u251c\u2500\u2500 javascript.svg \u251c\u2500\u2500 public/ \u2502 \u2514\u2500\u2500 vite.svg \u2514\u2500\u2500 package.json\n\nOne thing it doesn't have is a Vite configuration file, because it doesn't\nneed one.\n\nBy default, Vite infers the application entry point from the index.html file,\nso when we run vite build in that directory, it's able to create a bundle.\nVite will look for <script> tags with type set to module, and resolve all\ndependencies from there:\n\n    \n    \n    <!doctype html> <html lang=\"en\"> <head> <meta charset=\"UTF-8\" /> <link rel=\"icon\" type=\"image/svg+xml\" href=\"/vite.svg\" /> <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" /> <title>Vite App</title> </head> <body> <div id=\"app\"></div> <script type=\"module\" src=\"/main.js\"></script> </body> </html>\n\nVite also packs a development server so running vite will launch it and serve\nthat very index.html page. To start it, just run npm run dev.\n\nIn development mode, Vite will add a script to the page:\n\n    \n    \n    <script type=\"module\" src=\"/@vite/client\"></script>\n\nThis is responsible for enabling Vite's hot module replacement functionality.\n\nWhen running vite build for this project, we'll see:\n\n    \n    \n    vite v5.1.1 building for production... \u2713 7 modules transformed. dist/index.html 0.45 kB \u2502 gzip: 0.29 kB dist/assets/index-BfibREyH.css 1.21 kB \u2502 gzip: 0.62 kB dist/assets/index-BLvcXRAk.js 2.59 kB \u2502 gzip: 1.40 kB \u2713 built in 155ms\n\nAnd if we look at the production index.html, we'll see /main.js has become one\nof the bundled scripts as expected:\n\n    \n    \n    <script type=\"module\" crossorigin src=\"/assets/index-BLvcXRAk.js\"></script>\n\nWhat we've just covered truly is the basis of how Vite works.\n\nThere's a whole lot more you can do with it, its plugin API and its already\nwell established plugin ecosystem, but understanding these key aspects are\njust about enough to let the reader say they know Vite.\n\n## Turning it into a Fastify application\n\nVite's development server is convenient but it's there just for just that:\nconvenience. You should not ever serve a live application from it, the\nassumption being once built your project's production bundle is served\nstatically from a server.\n\nHowever, that also implies your application is a Single-Page Application\n(SPA), that is, every piece of it is rendered through that main index.html\nfile.\n\nIn this case all the routing is handled client-side via the History API or if\nusing a framework, a library like Vue Router or React Router.\n\nIf we're a building a server-first, Multi-Page Application (MPA) as\npopularized again by Astro and more recently HTMX, we need to ensure we're\nable to serve that index.html file dynamically so it can include live server-\nside rendered pages.\n\n## Configuring the client\n\nThat's where @fastify/vite comes into play.\n\nThis plugin lets you run Vite's development from within your Fastify\napplication in development mode, while also seamlessly serving your Vite\napplication's bundle in production mode.\n\nNot only that, it lets you expose your Vite client application to Fastify as a\nmodule, and it provides a series of configuration hooks that allow you to\nautomate, among other things, how Fastify registers routes based on your Vite\nclient application code.\n\nIn order to adapt the scaffolded Vite application into a Fastify application,\nwe'll first follow @fastify/vite's convention of keeping client source files\nin a client/ folder. And add a vite.config.js file with a different root so\nthat Vite knows about it too:\n\n    \n    \n    import { dirname, join } from 'node:path' import { fileURLToPath } from 'node:url' import { defineConfig } from 'vite' export default defineConfig({ root: join(dirname(fileURLToPath(import.meta.url)), 'client'), })\n\nAll off these changes can be seen in this commit.\n\nThe client code is almost ready for @fastify/vite, there's two steps missing:\none is moving the markup out of main.js and turning it into views/index.js,\nand the other is creating an index.js file under client/, which @fastify/vite\nautomatically loads. You can use this module to expose anything necessary to\nthe server, in this case the most obvious need is exposing the routes we have.\nWe'll define routes by exporting a path constant from modules under views/.\n\nSo in client/index.js, we can use Vite's import.meta.glob() to automatically\nimport and make them available to Fastify, as shown below. Note that\n@fastify/vite expects your Vite client module (client/index.js) to contain a\nroutes array as an export, with objects containing a path property. That's why\nObject.values() is alo used:\n\n    \n    \n    export const routes = Object.values( import.meta.glob('/views/**/*.js', { eager: true }) )\n\n@fastify/vite automatically traverses routes and register routes based on the\nmetadata of each object in it, but we can also control how it does that by\nalso providing a createRoute() hook to @fastify/vite. We'll see that how that\nlooks next.\n\n## Configuring the server\n\nFirst we need to install Fastify related dependencies:\n\n    \n    \n    npm install \\ fastify \\ @fastify/vite \\ @fastify/formbody \\ @fastify/one-line-logger\n\nNow we can write server.js as follows:\n\n    \n    \n    import Fastify from 'fastify' import FastifyVite from '@fastify/vite' import FastifyFormBody from '@fastify/formbody' const server = Fastify({ logger: { transport: { target: '@fastify/one-line-logger' } } }) await server.register(FastifyFormBody) await server.register(FastifyVite, { root: import.meta.url, createRoute ({ handler, errorHandler, route }, fastify, config) { fastify.route({ url: route.path, method: route.method ?? 'GET', async handler (req, reply) { reply.type('text/html') reply.html({ element: await route.default({ fastify, req, reply }), }) }, errorHandler, ...route }) } }) await server.vite.ready() await server.listen({ port: 3000 })\n\nQuite a bit of boilerplate here, and a lot going on under the hood. As can be\nseen in this commit, the markup from client/main.js moved to\nclient/views/index.js and is now returned as a string from the default\nfunction export:\n\n    \n    \n    import javascriptLogo from '/javascript.svg' import viteLogo from '/vite.svg' export const path = '/' export default () => ` <div> <a href=\"https://vitejs.dev\" target=\"_blank\"> <img src=\"${viteLogo}\" class=\"logo\" alt=\"Vite logo\" /> </a> <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript\" target=\"_blank\"> <img src=\"${javascriptLogo}\" class=\"logo vanilla\" alt=\"JavaScript logo\" /> </a> <h1>Hello Vite!</h1> <div class=\"card\"> <button id=\"counter\" type=\"button\"></button> </div> <p class=\"read-the-docs\"> Click on the Vite logo to learn more </p> </div> `\n\nAlso note that client/index.html now includes the <!-- element -->\nplaceholder.\n\nIn a nutshell, @fastify/vite automatically turns your Vite application's\nindex.html file into a templating function, exposed as reply.html().\n\nTo run the server in development mode:\n\n    \n    \n    node server.js --dev\n\n> The --dev flag is recognized by @fastify/vite by default, but you can\n> customize this behavior by providing your own dev (boolean) flag in the\n> plugin options.\n\n## Configuring build scripts\n\nTo run it in production mode, just remove the --dev flag, but that also\nrequires you to run vite build beforehand so there's a production bundle\n@fastify/vite can load.\n\nThe catch here is that you need vite build both the client and server bundles.\n\n  * The client bundle is what is made available to the client via index.html.\n\n  * The server bundle is what gets exposed to Fastify on the server, namely client/index.js, which exports the routes array and anything else that might be needed on the server, accessible via @fastify/vite's hooks as seen before.\n\nHere's how you need to set up your build scripts in package.json:\n\n    \n    \n    { \"scripts\": { \"build\": \"npm run build:client && npm run build:server\", \"build:client\": \"vite build --outDir dist/client --ssrManifest\", \"build:server\": \"vite build --outDir dist/server --ssr /index.js\", } }\n\nNotice that for the client build, we also tell Vite to produce a SSR manifest\nfile. This is a JSON file mapping all client modules and their imported\nmodules to bundle asset URLs. It's loaded automatically by @fastify/vite and\nmade available in runtime in production mode. It'll be useful when we get to\nsetup asset preloading.\n\n## Ensuring route client imports\n\nThere's a couple of problems though: in this iteration, index.html still has\nmain.js linked, which means even though it can render other route modules,\nit'll still be loading the same client JavaScript file for every one of them.\n\n> There's also a minor problem with the viteLogo image import, which Vite's\n> development server automatically serves from the public/ directory, but\n> would need a separate @fastify/static plugin instance which is not provided\n> out of the box. For simplicity, we'll just move vite.svg out of the public/\n> directory.\n\nIn order to ensure each rendered route also has its accompanying modules\nloaded on the client, we could try and make sure each route module is also\nloaded on the client. The problem with this approach is that we might have\nserver-side imports on these modules, and even if we don't, we'll be\nneedlessly loading the functions used for SSR on the client.\n\nWe can use a library like mlly to dynamically infer the imported files from\neach route module and ensure the client loads only the files that make sense,\nsuch as CSS and SVG files and client-only JavaScript files. The first step is\nto ensure the full module path for each route module in our routes export:\n\n    \n    \n    const routeHash = import.meta.glob('/views/**/*.js', { eager: true }) for (const [path, route] of Object.entries(routeHash)) { routeHash[path] = { ...route } routeHash[path].modulePath = path } export const routes = Object.values(routeHash)\n\nNext we'll patch index.html to include an inlined clientImports array:\n\n    \n    \n    <script> window[Symbol.for('clientImports')] = JSON.parse('<!-- clientImports -->') </script>\n\nAnd use @fastify/vite's prepareClient() hook to populate them for each route:\n\n    \n    \n    async function prepareClient (clientModule, scope, config) { if (!clientModule) { return null } const { routes } = clientModule for (const route of routes) { route.clientImports = await findClientImports(route.modulePath) } return Object.assign({}, clientModule, { routes }) } async function findClientImports (path, imports = []) { const source = await readFile(join(root, path), 'utf8') const specifiers = findStaticImports(source) .filter(({ specifier }) => { return specifier.endsWith('.css') || specifier.endsWith('.svg') || specifier.endsWith('.client.js') }) .map(({ specifier }) => specifier) for (const specifier of specifiers) { const resolved = resolve(dirname(path), specifier) imports.push(resolved) if (specifier.endsWith('.client.js')) { imports.push(...await findClientImports(resolved)) } } return imports }\n\nNote that we also allow for files ending with .client.js to be loaded on the\nclient. This is so we can safely import it in our route module that will run\non the server, and have it seamlessly loaded on the client. For that to work\nproperly, we need to include a Vite plugin in our vite.config.js file to\nremove these modules altogether when loaded during SSR:\n\n    \n    \n    export default defineConfig({ root: join(dirname(fileURLToPath(import.meta.url)), 'client'), plugins: [ ensureClientOnlyScripts() ] }) function ensureClientOnlyScripts () { let config return { name: 'vite-plugin-fastify-vite-htmx', configResolved (resolvedConfig) { // Store the resolved config config = resolvedConfig }, load (id, options) { if (options?.ssr && id.endsWith('.client.js')) { return { code: '', map: null, } } }, } }\n\nThen for views/index.js, we can also have views/index.client.js:\n\n    \n    \n    import '/style.css' import { setupCounter } from '/counter.js' setupCounter(document.querySelector('#counter'))\n\nNext we need to patch up createRoute() to include clientImports, and to ignore\nmodules that don't have the path export, like index.client.js:\n\n    \n    \n    function createRoute ({ handler, errorHandler, route }, fastify, config) { if (!route.path) { return } fastify.route({ url: route.path, method: route.method ?? 'GET', async handler (req, reply) { reply.type('text/html') reply.html({ element: await route.default(req, reply), clientImports: JSON.stringify(route.clientImports), }) }, errorHandler, ...route }) }\n\nFinally, we patch main.js to become a kind of lazy module loading hub. Thanks\nto import.meta.glob() we're able to ensure modules are linked in the build,\nbut still lazy-loaded in runtime. We can then traverse the list of client\nimports (serialized and parsed from the inlined JSON string) that should run\nfor the route and load them on-demand:\n\n    \n    \n    const allClientImports = { ...import.meta.glob('/**/*.svg'), ...import.meta.glob('/**/*.css'), ...import.meta.glob('/**/*.client.js') } const clientImports = window[Symbol.for('clientImports')] Promise.all(clientImports.map((clientImport) => { return allClientImports[clientImport]() }))\n\n## Leveraging Vite's SSR manifest\n\nEven though this will work, it's not ideal. At least not in all cases. This is\nthe correct approach if lazy loading is optimal for your routes. For CSS files\nthough, lazy loading is rarely optimal because it can cause sudden layout and\nstyling changes.\n\nThanks to the SSR manifest produced by vite build, and made available as\nconfig.ssrManifest in @fastify/vite, we can compute <link> and <script> tags\nfor imported assets at boot time.\n\nBut first let's take a moment to further refine our findClientImports()\nfunction to properly look for .css, .svg and .client.js files, and group them\ninto separate arrays:\n\n    \n    \n    async function findClientImports(path, { js = [], css = [], svg = [] } = {}) { const source = await readFile(join(root, path), 'utf8') const specifiers = findStaticImports(source) .filter(({ specifier }) => { return specifier.match(/\\.((svg)|(css)|(m?js)|(tsx?)|(jsx?))$/) }) .map(({ specifier }) => specifier) for (const specifier of specifiers) { const resolved = resolve(dirname(path), specifier) if (specifier.match(/\\.svg$/)) { svg.push(resolved.slice(1)) } if (specifier.match(/\\.client\\.((m?js)|(tsx?)|(jsx?))$/)) { js.push(resolved.slice(1)) } if (specifier.match(/\\.css$/)) { css.push(resolved.slice(1)) } if (specifier.match(/\\.((m?js)|(tsx?)|(jsx?))$/)) { const submoduleImports = await findClientImports(resolved) js.push(...submoduleImports.js) css.push(...submoduleImports.css) svg.push(...submoduleImports.svg) } } return { js, css, svg } }\n\nNow we can also rewrite prepareClient() to compute our preloading <head>\nelements either based on the actual module path, which works in development\nmode, or the corresponding production bundle file in production:\n\n    \n    \n    async function prepareClient(clientModule, scope, config) { if (!clientModule) { return null } const { routes } = clientModule for (const route of routes) { // Pregenerate prefetching <head> elements const { css, svg, js } = await findClientImports(route.modulePath) route[kPrefetch] = '' for (const stylesheet of css) { if (config.dev) { route[kPrefetch] += ` <link rel=\"stylesheet\" href=\"/${stylesheet}\">\\n` } else if (config.ssrManifest[stylesheet]) { const [asset] = config.ssrManifest[stylesheet].filter((s) => s.endsWith('.css'), ) route[kPrefetch] += ` <link rel=\"stylesheet\" href=\"${asset}\" crossorigin>\\n` } } for (const image of svg) { // Omitted for brevity } for (const script of js) { // Omitted for brevity } } return Object.assign({}, clientModule, { routes }) }\n\nThe next step is to attach our <link> and <script> elements to our index.html\nfile. For that we'll use a renderHead() function, which will use, by default,\nthe head JSX or function exported by the route and main client modules, in\nthat order.\n\n    \n    \n    async function renderHead(client, route, ctx) { let rendered = '' if (route[kPrefetch]) { rendered += route[kPrefetch] } if (route.head === 'function') { rendered += await route.head(ctx) } else if (route.head) { rendered += route.head } rendered += '\\n' if (client.head === 'function') { rendered += await client.head(ctx) } else if (client.head) { rendered += client.head } return rendered }\n\nAnd then make sure it makes into reply.html():\n\n    \n    \n    function createRoute ({ handler, errorHandler, route, client }, fastify, config) { if (!route.path) { return } fastify.route({ url: route.path, method: route.method ?? 'GET', async handler (req, reply) { reply.type('text/html') if (route.fragment) { reply.send(await route.default(req, reply)) } else { reply.html({ head: await renderHead(client, route, { app: fastify, req, reply }), element: await route.default(req, reply), }) } return reply }, errorHandler, ...route }) }\n\nFinally, we update main.jsx to do just produce lazy imports for all our .jsx\nfiles, so even though we're never loading theses files on the client, we can\nsure all of its dependencies will make it to the client bundle and become\navailable in the SSR manifest:\n\n    \n    \n    void { ...import.meta.glob('/**/*.jsx') }\n\nYou can see all of these changes in this commit.\n\n## Adding JSX support via @kitajs/html\n\nNow it's time to add JSX support to our app, so we can stop using raw\nJavaScript strings for server-side rendering our markup.\n\nFor this we'll use @kitajs/html, a tiny and fast library for generating markup\nfrom JSX. In this iteration, we'll also make the application HTMX-ready.\n\n    \n    \n    import inject from '@rollup/plugin-inject' export default defineConfig({ root: join(dirname(fileURLToPath(import.meta.url)), 'client'), esbuild: { jsxFactory: 'Html.createElement', jsxFragment: 'Html.Fragment', }, plugins: [ inject({ htmx: 'htmx.org', Html: '@kitajs/html' }), ensureClientOnlyScripts() ], })\n\nAnd then we can rewrite client/views/index.js as follows:\n\n    \n    \n    import './index.client.js' import javascriptLogo from '/javascript.svg' import viteLogo from '/vite.svg' export const path = '/' export default () => <> <div> <a href=\"https://vitejs.dev\" target=\"_blank\"> <img src={viteLogo} class=\"logo\" alt=\"Vite logo\" /> </a> <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript\" target=\"_blank\"> <img src={javascriptLogo} class=\"logo vanilla\" alt=\"JavaScript logo\" /> </a> <h1>Hello Vite!</h1> <div class=\"card\"> <button id=\"counter\" type=\"button\"></button> </div> <p class=\"read-the-docs\"> Click on the Vite logo to learn more </p> </div> </>\n\nYou can see all of these changes in this commit.\n\n## Adding support for HTML fragments\n\nAt this stage, in client/counter.js, we can still see the code responsible for\nrendering the button's text:\n\n    \n    \n    export function setupCounter(element) { let counter = 0 const setCounter = (count) => { counter = count element.innerHTML = `count is ${counter}` } element.addEventListener('click', () => setCounter(counter + 1)) setCounter(0) }\n\nIn order to demonstrate one of HTMX's abilities, we'll change rendering of\nthat button's text to the server. Every time the user clicks, it'll fetch a\nnew fragment from the server.\n\nLet's begin by creating client/views/increment.jsx:\n\n    \n    \n    export const fragment = true export const path = '/counter' export const method = 'POST' export default (req) => { return req.body.innerHTML.replace(/count is (\\d+)/, (_, count) => { return `count is ${Number(count) + 1}` }) }\n\nNotice that we export fragment set to true, so we can modify our createRoute()\nhook to take that into account and skip wrapping the fragment in the\napplication's HTML shell (index.html). We also assume the presence of\ninnerHTML as a form parameter, we'll make sure it's sent along with every\nclick to the button.\n\nBelow is the update createRoute() definition:\n\n    \n    \n    fastify.route({ url: route.path, method: route.method ?? 'GET', async handler (req, reply) { reply.type('text/html') if (route.fragment) { reply.send(await route.default(req, reply)) } else { reply.html({ element: await route.default(req, reply), clientImports: JSON.stringify(route.clientImports), }) } }, errorHandler, ...route })\n\nIn client/views/index.client.js, we can now remove the old code based on\ncounter.js since the updating will be server-rendered now. In fact, we can\nremove the file altogether and just move the CSS import to index.jsx.\n\nTo update the button's text with HTMX, first we need to add some properties to\nit:\n\n    \n    \n    <button id=\"counter\" type=\"button\" hx-include-inner hx-swap=\"innerHTML\" hx-post=\"/counter\">count is 1</button>\n\nNote that we're using the element itself to set the initial state.\n\nThe first attribute (hx-include-inner) registers a HTMX extension to include\nthe element's innerHTML in the request's form data.\n\nThe second (hx-swap) tells HTMX to swap the element's innerHTML with the\nresponse from the server. And the last (hx--post) tells HTMX to perform a POST\nrequest to /counter every time the button is clicked.\n\nNow we just need to update main.js to import htmx.org and pick up on hx-\ninclude-inner, which uses the configRequest HTMX event:\n\n    \n    \n    import 'htmx.org' document.addEventListener('htmx:configRequest', ({ detail }) => { if (detail.elt.hasAttribute('hx-include-inner')) { detail.parameters['innerHTML'] = detail.elt.innerHTML } })\n\nYou can see all of these changes in this commit.\n\n## Reviewing our setup\n\nIt's time to take a step back and look what we've built.\n\n    \n    \n    \u251c\u2500\u2500 server.js \u251c\u2500\u2500 vite.config.js \u2514\u2500\u2500 client/ \u251c\u2500\u2500 views/ \u2502 \u251c\u2500\u2500 index.jsx \u2502 \u2514\u2500\u2500 increment.jsx \u251c\u2500\u2500 index.html \u251c\u2500\u2500 index.js \u2514\u2500\u2500 main.js\n\nWe now have a Fastify server, running Vite as a middleware in development\nmode.\n\nThe setup has two key features:\n\n  * We can automatically register routes by placing them in the views/ folder with each module exporting a path constant, and also optionally method and fragment \u2014 to indicate routes that deliver standalone HTML fragments.\n\n  * We can import JavaScript files with the .client.js suffix and CSS modules from server route modules and still be sure they will be loaded on the client after rendering.\n\nAll the setup requires is Fastify and Vite, resulting in an absolute minimal,\nlow-level setup with minimum dependencies. For comparison, below are the\nnode_modules sizes of this example application and a starter Next.js app built\nwith create-next-app:\n\nmicro-htmx-framework-tutorial| 102mb  \n---|---  \nnext-app-starter| 200mb  \n  \nAll of these features have been packed as @fastify/htmx, which is now the\nofficial JSX and HTMX renderer for @fastify/vite and is available on npm.\n\nWe'll be using it to rewrite the Movie Quotes App.\n\n## Rewriting the Movie Quotes App\n\nFor this part we're using a fork of the Movie Quotes App tutorial source code.\nThis app actually contains two services, one for the API, and another for\nserving the frontend.\n\n    \n    \n    \u2514\u2500\u2500 apps/ \u251c\u2500\u2500 movie-quotes-api \u2514\u2500\u2500 movie-quotes-frontend\n\nThe API is served from movie-quotes-api, a Fastify application running via the\nPlatformatic DB CLI. The frontend is an Astro SPA which makes requests to the\nAPI retrieving data only. The frontend is served in this example via Astro's\nown development server, but its bundle could be served from a variety of\nservers.\n\nIt's a simple app with four routes:\n\n  * the index page, pages/index.astro.\n\n  * the add movie quote page, pages/add.astro.\n\n  * the edit quote page, pages/edit/[id.astro].\n\n  * and the delete quote page, pages/delete/[id.astro].\n\nAll movie quote associated actions have their own components as well. And then\nthere are some vanilla JavaScript libraries responsible for a few bits of\nfunctionality, such as talking to the Platformatic DB GraphQL API and\nconfirming actions before running them.\n\nBelow is the full source code structure for the original movie-quotes-frontend\nservice.\n\n    \n    \n    . \u2514\u2500\u2500 movie-quotes-frontend-htmx/ \u251c\u2500\u2500 components/ \u2502 \u251c\u2500\u2500 QuoteActionDelete.astro \u2502 \u251c\u2500\u2500 QuoteActionEdit.astro \u2502 \u251c\u2500\u2500 QuoteActionLike.astro \u2502 \u2514\u2500\u2500 QuoteForm.astro \u251c\u2500\u2500 layouts/ \u2502 \u2514\u2500\u2500 Layout.astro \u251c\u2500\u2500 lib/ \u2502 \u251c\u2500\u2500 quotes-api.js \u2502 \u2514\u2500\u2500 request-utils.js \u251c\u2500\u2500 pages/ \u2502 \u251c\u2500\u2500 delete/ \u2502 \u2502 \u2514\u2500\u2500 [id].astro \u2502 \u251c\u2500\u2500 edit/ \u2502 \u2502 \u2514\u2500\u2500 [id].astro \u2502 \u251c\u2500\u2500 add.astro \u2502 \u2514\u2500\u2500 index.astro \u2514\u2500\u2500 scripts/ \u2514\u2500\u2500 quote-actions.js\n\n## Rewriting the boilerplate\n\nWe'll start by creating a exact copy of movie-quotes-frontend for the HTMX\nversion, making the directory structure now look like the following:\n\n    \n    \n    \u2514\u2500\u2500 apps/ \u251c\u2500\u2500 movie-quotes-api \u251c\u2500\u2500 movie-quotes-frontend \u2514\u2500\u2500 movie-quotes-frontend-htmx\n\nNext, in movie-quotes-frontend-htmx we'll add server.js to replace the Astro\nserver:\n\n    \n    \n    import Fastify from 'fastify' import FastifyVite from '@fastify/vite' import FastifyFormBody from '@fastify/formbody' const server = Fastify({ logger: { transport: { target: '@fastify/one-line-logger' } } }) await server.register(FastifyFormBody) await server.register(FastifyVite, { root: import.meta.url, renderer: '@fastify/htmx', }) await server.vite.ready() await server.listen({ port: 3000 })\n\nAnd a vite.config.js file to import @fastify/htmx's accompanying Vite plugin\nand set up CSS modules to use the camel case convention for class names:\n\n    \n    \n    import { join, dirname } from 'path' import { fileURLToPath } from 'url' import inject from '@rollup/plugin-inject' import viteFastifyHtmx from '@fastify/htmx/plugin' export default { root: join(dirname(fileURLToPath(import.meta.url)), 'client'), plugins: [ viteFastifyHtmx() ], css: { modules: { localsConvention: 'camelCase' } } }\n\n> @fastify/htmx is a brand new renderer for @fastify/vite built reusing most\n> of the code in this tutorial. You can read the release notes here.\n\n## Loading .env files\n\nAstro handles .env files automatically, and so does Vite. In fact, Astro's\nsupport for .env files comes from Vite's own built-in support. But we also\nneed to make .env files available to Fastify. In this example we'll use\nfluent-env, a convenient wrapper around env-schema and fluent-json-schema.\n\nAll we need to do is add the following import at the top of server.js:\n\n    \n    \n    import `fluent-env/auto`\n\nAnd change the PUBLIC_GRAPHQL_API_ENDPOINT variable to\nVITE_GRAPHQL_API_ENDPOINT to match Vite's default standard. Only environment\nvariables prefixed with VITE_ are allowed to make it into the bundle.\n\nIn the end, this is not going to be required at all as since we're not ever\nrunning code that relies on the single environment variable of this\napplication on the client, but it's still good to know.\n\n## Generating a Platformatic DB client\n\nPlatformatic CLI has had for some time the ability to automatically generate a\nfunctioning GraphQL or REST API client for your Platformatic DB service.\n\nNext we'll replace lib/quotes-api.js with an automatically generated GraphQL\nclient via Platformatic CLI. First cd to apps/movie-quotes-api and start the\nservice:\n\n    \n    \n    npm run start\n\nThen in our movie-quotes-frontend-htmx rewrite, first cd to src/lib and run:\n\n    \n    \n    npm i @platformatic/client --save npx platformatic client http://127.0.0.1:3042/graphql --name quotes\n\nYou should see an output like the following:\n\n    \n    \n    [12:35:29] INFO: Client generated successfully into src/lib/quotes\n\nEven though the generated client code is written in CommonJS, we can still\nimport it from our ESM server.js file because it's explicitly tagged as\nCommonJS via the .cjs extension. Here's our updated server.js registering the\nplugin:\n\n    \n    \n    import 'fluent-env/auto' import FastifyFormBody from '@fastify/formbody' import FastifyVite from '@fastify/vite' import Fastify from 'fastify' import quotesGraphQLClient from './src/lib/quotes/quotes.cjs' const server = Fastify({ logger: { transport: { target: '@fastify/one-line-logger', }, }, }) await server.register(FastifyFormBody) await server.register(quotesGraphQLClient, { url: process.env.VITE_GRAPHQL_API_ENDPOINT, }) await server.register(FastifyVite, { root: import.meta.url, renderer: '@fastify/htmx', }) await server.vite.ready() await server.listen({ port: 3000 })\n\n## Rewriting the layout component\n\nThe main difference is that the main HTML shell needs to live in an index.html\nfile, which just the body rendered by the main layout component. Here's how\nthe original layouts/Layout.astro component reads:\n\n    \n    \n    --- export interface Props { title: string; page?: string; } const { title, page } = Astro.props; const navActiveClasses = \"font-bold bg-yellow-400 no-underline\"; --- <!DOCTYPE html> <html lang=\"en\"> <head> <meta charset=\"UTF-8\" /> <meta name=\"viewport\" content=\"width=device-width\" /> <title>{title}</title> </head> <body class=\"py-8\"> <header class=\"prose mx-auto mb-6\"> <h1>\ud83c\udfac Movie Quotes</h1> </header> <nav class=\"prose mx-auto mb-6 border-y border-gray-200 flex\"> <a href=\"/?sort=createdAt\" class={`p-3 ${page === \"listing-createdAt\" && navActiveClasses}`}>Latest quotes</a> <a href=\"/?sort=likes\" class={`p-3 ${page === \"listing-likes\" && navActiveClasses}`}>Top quotes</a> <a href=\"/add\" class={`p-3 ${page === \"add\" && navActiveClasses}`}>Add a quote</a> </nav> <section class=\"prose mx-auto\"> <slot /> </section> </body> </html>\n\nAnd here's how layouts/defaults.jsx reads:\n\n    \n    \n    const navActiveClasses = 'font-bold bg-yellow-400 no-underline' export default ({ req, children }) => { return ( <> <header class=\"prose mx-auto mb-6\"> <h1>\ud83c\udfac Movie Quotes</h1> </header> <nav class=\"prose mx-auto mb-6 border-y border-gray-200 flex\"> <a href=\"/?sort=createdAt\" class={`p-3 ${req.page === 'listing-createdAt' && navActiveClasses}`} > Latest quotes </a> <a href=\"/?sort=likes\" class={`p-3 ${req.page === 'listing-likes' && navActiveClasses}`} > Top quotes </a> <a href=\"/add\" class={`p-3 ${req.page === 'add' && navActiveClasses}`}> Add a quote </a> </nav> <section class=\"prose mx-auto\">{children}</section> </> ) }\n\nAccompanied by this new index.html file:\n\n    \n    \n    <!DOCTYPE html> <html> <head> <meta charset=\"utf-8\" /> <link href=\"/index.css\" rel=\"stylesheet\"> <!-- head --> </head> <body class=\"py-8\"> <!-- element --> </body> <!-- hydration --> <script type=\"module\" src=\"/:client.js\"></script> </html>\n\nYou'll see going from Astro to @kitajs/html-flavored JSX is rather\nstraightforward.\n\n## Rewriting the like action component\n\nIn the original Astro version, the heart SVG that serves to perform a like\naction on a movie quote is controlled by client-side code, triggering client-\nside requests to the GraphQL API. That means importing @urql/core on the\nclient bundle, a 20kb+ library.\n\n    \n    \n    export async function likeQuote (likeQuote) { likeQuote.classList.add('liked') likeQuote.classList.remove('cursor-pointer') const id = Number(likeQuote.dataset.quoteId) const { data } = await quotesApi.mutation(gql` mutation($id: ID!) { likeQuote(id: $id) } `, { id }) if (data?.likeQuote) { likeQuote.querySelector('.likes-count').innerText = data.likeQuote } }\n\nWe'll avoid that by going with HTMX. First we'll add an endpoint to return the\nnumber of likes for a movie quote, in plain-text:\n\n    \n    \n    server.post('/api/like-movie-quote/:id', async (req, reply) => { const id = Number(req.params.id) const liked = await req.quotes.graphql({ query: ` mutation($id: ID!) { likeQuote(id: $id) } `, variables: { id }, }) reply.type('text/plain') reply.send(liked.toString()) })\n\nNote that we're already using Platformatic's autogenerated GraphQL client in\nthis snippet. Very simple POST endpoint, runs a mutation and returns the\nupdated value. Now we can use it in our new QuoteActionLike.tsx component to\ndo the update:\n\n    \n    \n    import Html from '@kitajs/html' import styles from './QuoteActionLike.module.css' import './QuoteActionLike.client.js' export interface Props extends Html.PropsWithChildren { id: number likes: number } export default ({ id, likes }: Props) => { return ( <> <span data-like-quote hx-post={`/api/like-movie-quote/${id}`} hx-target=\"find span[data-like-count]\" class={`${styles.likeQuote} cursor-pointer mr-5 flex items-center`} > <svg role=\"img\" aria-label=\"Like\" class={`${styles.likeIcon} w-6 h-6 mr-2 text-red-600`} xmlns=\"http://www.w3.org/2000/svg\" fill=\"none\" viewBox=\"0 0 24 24\" stroke-width=\"1.5\" stroke=\"currentColor\" > <path stroke-linecap=\"round\" stroke-linejoin=\"round\" d=\"M21 8.25c0-2.485-2.099-4.5-4.688-4.5-1.935 0-3.597 1.126-4.312 2.733-.715-1.607-2.377-2.733-4.313-2.733C5.1 3.75 3 5.765 3 8.25c0 7.22 9 12 9 12s9-4.78 9-12z\" /> </svg> <span data-like-count class={`${styles.likesCount} w-8`}> {likes} </span> </span> </> ) }\n\nLike Vue, Astro allows you to inline <style> tags in a single file component,\nwhich makes for an ergonomic development experience. In this example, we use\nCSS modules as a compromise, which are still elegant and clean nonetheless and\nsupported by @fastify/htmx. Note how we also import\n./QuoteActionLike.client.js, which is responsible for changing the classes in\nthe heart SVG element:\n\n    \n    \n    import styles from './QuoteActionLike.module.css' document.body.addEventListener( 'htmx:afterRequest', ({ detail }) => { if (detail.elt.hasAttribute('data-like-quote')) { detail.elt.classList.add(styles.liked) detail.elt.classList.remove('cursor-pointer') } } )\n\n## Rewriting the movie quotes listing\n\nRemember the ability to register HTML fragments routes we added before?\n@fastify/htmx packs the same functionality, allowing us to have a\nQuoteListing.tsx component and a fragment route at the same time:\n\n    \n    \n    import QuoteActionDelete from '/components/QuoteActionDelete.tsx' import QuoteActionEdit from '/components/QuoteActionEdit.tsx' import QuoteActionLike from '/components/QuoteActionLike.tsx' export const path = '/html/quotes' export const fragment = true export default async ({ req }) => { const allowedSortFields = ['createdAt', 'likes'] const searchParamSort = req.query.sort const sort = allowedSortFields.includes(searchParamSort) ? searchParamSort : 'createdAt' const quotes = await req.quotes.graphql({ query: ` query { quotes(orderBy: {field: ${sort}, direction: DESC}) { id quote saidBy likes createdAt movie { id name } } } `, }) req.page = `listing-${sort}` return ( <main> {quotes.length > 0 ? ( quotes.map((quote) => ( <div class=\"border-b mb-6 quote\"> <blockquote class=\"text-2xl mb-0\"> <p class=\"mb-4\">{quote.quote}</p> </blockquote> <p class=\"text-xl mt-0 mb-8 text-gray-400\"> \u2014 {quote.saidBy}, {quote.movie?.name} </p> <div class=\"flex flex-col mb-6 text-gray-400\"> <span class=\"flex items-center\"> <QuoteActionLike id={quote.id} likes={quote.likes} /> <QuoteActionEdit id={quote.id} /> <QuoteActionDelete id={quote.id} /> </span> <span class=\"mt-4 text-gray-400 italic\"> Added {new Date(quote.createdAt).toUTCString()} </span> </div> </div> )) ) : ( <p>No movie quotes have been added.</p> )} </main> ) }\n\nAnd used by views/index.jsx as follows:\n\n    \n    \n    import QuoteListing from '/fragments/QuoteListing.tsx' export const path = '/' export const head = ( <> <title>All quotes</title> </> ) export default ({ req }) => { return <QuoteListing req={req} /> }\n\nThe interesting bit here is that even though we're just using it as JSX\ncomponent, this very same component is used to register a /html/quotes which\ncould be reused to reload it in place. I leave that as a fun exercise to the\nreader!\n\n## Wrapping up\n\nMake sure to see full source code here.\n\nIn this blog, we delved into how you can use Fastify, Vite and @fastify/vite\nto produce a small, low-overhead application setup that has the absolute\nminimal set of dependencies and moving parts. Ideally, this will have\ndemystified a few layers of complexity implementing common features of full\nstack frameworks.\n\nIn terms of raw SSR performance, both implementations behave similarly, with\nautocannon giving an average of 15k requests per second. However the Fastify\nimplementation contains a fraction of the dependencies from the Astro\nframework, making the overall development setup much smaller.\n\nhtmxplatformaticfastifyNode.jsvite\n\n### Written by\n\n# Matteo Collina\n\n### Published on\n\n# Platformatic Blog\n\nShare this\n\n### More articles\n\nMatteo Collina\n\n# HTTP Fundamentals: Understanding Undici and its Working Mechanism\n\nNavigating through Node.js http/https can be a daunting task that often calls\nfor updates. This is p...\n\nMatteo Collina\n\n# A Deep Dive into Meraki 1.0\n\nImagine this: your development team kicks off a new project which includes\ninnovative new features. ...\n\nMatteo Collina\n\n# Introducing the Platformatic Control Module\n\nWhen dealing with microservices, simplicity, precision, and efficiency are\ncritical. As part of our ...\n\n\u00a92024 Platformatic Blog\n\nArchive\u00b7Privacy policy\u00b7Terms\n\nWrite on Hashnode\n\nPowered by Hashnode - Home for tech writers and readers\n\n", "frontpage": false}
