{"aid": "40166948", "title": "K2 Compiler Performance Benchmarks and How to Measure Them on Your Projects", "url": "https://blog.jetbrains.com/kotlin/2024/04/k2-compiler-performance-benchmarks-and-how-to-measure-them-on-your-projects/", "domain": "jetbrains.com", "votes": 1, "user": "pcw888", "posted_at": "2024-04-26 08:10:53", "comments": 0, "source_title": "K2 Compiler Performance Benchmarks and How to Measure Them on Your Projects | The Kotlin Blog", "source_text": "K2 Compiler Performance Benchmarks and How to Measure Them on Your Projects | The Kotlin Blog\n\nBlog\n\nSkip to content\n\n  * Blogs by Topic\n  * Search\n\nBurger menu icon\n\n## Kotlin\n\nA concise multiplatform language developed by JetBrains\n\nFollow\n\n  * Follow:\n  * Twitter Twitter\n  * RSS RSS\n\nVisit the Kotlin Site\n\nEcosystem\n\n# K2 Compiler Performance Benchmarks and How to Measure Them on Your Projects\n\nSarah Haggarty\n\nApril 25, 2024\n\nWith the Kotlin 2.0.0 release drawing ever closer, the K2 compiler is now\navailable for you to try! In this blog post, we explore the performance of the\nK2 compiler in various projects and give you the tools to collect your own\nperformance statistics.\n\nThe road to the Stable version of the K2 compiler has been a long one. Since\nwe made the decision to rewrite the compiler from scratch, we\u2019ve added a new\ntype inference algorithm, new JVM and JS IR (Intermediate Representation)\nbackends, and finally, a new frontend.\n\nThe fundamental change in the frontend is the use of one unified data\nstructure that contains more semantic information. This change makes\ncompilation more efficient and helps IntelliJ IDEA analyze your Kotlin code.\n\nThe driving force behind this initiative was the desire to speed up the\ndevelopment of new language features, unify all platforms that Kotlin\nsupports, and improve performance for Kotlin developers.\n\n> To receive the full benefits of the K2 compiler in IntelliJ IDEA, enable K2\n> Kotlin mode. The K2 Kotlin mode is in Alpha, so not all IDE features are\n> supported yet.\n\n# Key performance improvements\n\n  * The K2 compiler brings up to 94% compilation speed gains. For example, in the Anki-Android project, clean build times were reduced from 57.7 seconds in Kotlin 1.9.23 to 29.7 seconds in Kotlin 2.0.0.\n\n  * The initialization phase is up to 488% faster with the K2 compiler. For example, in the Anki-Android project, the initialization phase for incremental builds was cut from 0.126 seconds in Kotlin 1.9.23 to just 0.022 seconds in Kotlin 2.0.0.\n\n  * The Kotlin K2 compiler is up to 376% quicker in the analysis phase compared to the previous compiler. For example, in the Anki-Android project, analysis times for incremental builds were slashed from 0.581 seconds in Kotlin 1.9.23 to only 0.122 seconds in Kotlin 2.0.0.\n\n# Set up\n\nThe Kotlin project that we used to run performance tests is available on\nGitHub. If you\u2019d like to use it to collect your own statistics from your\nKotlin projects, see Collect your own measurements.\n\n## Projects\n\nWe ran our performance tests on the following open-source projects:\n\n  * Anki-Android\n  * Exposed\n\n## Tools\n\nTo collect performance measurements, we used the Gradle Profiler.\n\nWe also used Kotlin build reports to collect detailed measurements about the\ndifferent compilation phases.\n\n# Test scenarios\n\nWe created three scenarios to cover the most common compilation activities in\na Kotlin project:\n\n  1. Clean build: We built the whole project from scratch without using any pre-set configuration or build cache. This scenario happens when you compile a project for the first time or after you\u2019ve made a project configuration change.\n  2. Incremental build with no ABI (application binary interface) changes: We made changes in one file, but the changes were such that no further subprojects need to be recompiled.\n  3. Incremental build with ABI changes: We made changes in one file, but these changes meant that a module needed to be recompiled because the external interface of the module was modified.\n\nWe compared performance data collected from Kotlin 1.9.23 and Kotlin 2.0.0 and\nused Gradle 8.5 throughout.\n\nThe Gradle configuration cache, project isolation, and build cache were\ndisabled for all scenarios. Before the performance measurements were\ncollected, we completed 10 warm-up rounds. We performed 10 measurement rounds\nin total.\n\n# Types of measurements collected\n\nIn addition to the total Kotlin compilation time and Gradle build time, our\ntests used build reports to collect data on the time spent by the compiler in\neach of its compilation phases:\n\nPhase| Description  \n---|---  \nInitialization| The compiler initializes and reads all available symbols from\nthe compilation classpath.  \nAnalysis| The compiler reads the source code, character by character, and\nbreaks it down into meaningful tokens. These are analyzed to determine the\nstructure of the code, after which the compiler performs semantic checks.  \nIR translation| The compiler converts the semantic information into the\ninternal representation.  \nIR lowering| The compiler transforms the internal representation into a\nsimpler form and finally de-sugars all special language constructs.  \nIR generation| The compiler translates the optimized internal representation\ninto the final bytecode.  \n  \n# Results\n\nWhen comparing the results across our different scenarios and projects, we saw\nthat Gradle build speeds were consistently higher by at least 9%. The most\nsignificant improvement was seen in the Anki-Android project, where the\nrecorded build speed gains were around 20%, regardless of the compiler\nscenario.\n\nGraph with Gradle build time for clean build scenario \u2013 Anki-Android| Graphs\nwith Gradle build time for incremental build scenarios \u2013 Anki-Android  \n---|---  \n  \n## Clean builds\n\nThe benefits of the new K2 compiler architecture were most clearly seen in the\nclean build scenario, with both projects compiling significantly faster in\nKotlin 2.0.0.\n\nThe Exposed project demonstrated an 80% increase in compiler speeds, with\ncompilation times falling from 5.8 seconds in Kotlin 1.9.23 to 3.22 seconds in\nKotlin 2.0.0. Similarly, the Anki-Android project showed a 94% increase in\ncompiler performance, as compilation times were cut to 30 seconds in Kotlin\n2.0.0 compared to 58 seconds in Kotlin 1.9.23.\n\nGraph with Kotlin compilation time for clean build scenario \u2013 Exposed| Graph\nwith Kotlin compilation time for clean build scenario \u2013 Anki-Android  \n---|---  \n  \nDelving deeper into the performance of the different compilation phases, we\nfound that the biggest improvement came in the analysis phase, with the\nExposed and Anki-Android projects reporting speed gains of 156% and 194%,\nrespectively. This is a direct result of the new unified data structure that\nwe implemented in the K2 frontend. Since the new compiler only has to manage\none data structure instead of two and has additional semantic information\navailable to it, it\u2019s unsurprising that we saw such an improvement here.\n\nGraph with compilation breakdown for clean build scenario \u2013 Exposed  \n---  \nBlue = analysis phase  \nGraph with compilation breakdown for clean build scenario \u2013 Anki-Android  \n---  \nBlue = analysis phase  \n  \n## Incremental builds\n\nFor the incremental build scenarios, we also saw improved compiler\nperformance. Especially in the case of the Anki-Android project, where\ncompilation speeds increased by as much as 275% for both incremental build\nscenarios.\n\nGraph with Kotlin compilation time for incremental build scenarios \u2013 Anki-\nAndroid  \n---  \n  \nHowever, the results for the Exposed project weren\u2019t as impressive. We saw a\ngain of just 35% for incremental builds with ABI changes and 7% for\nincremental builds without ABI changes, so there\u2019s still room for improvement\nin this area.\n\nWhile investigating the performance of the different compilation phases, we\nobserved that the biggest performance gains were in the initialization and\nanalysis phases, with each becoming around 400% faster in the Anki-Android\nproject.\n\nGraph with compilation breakdown for incremental build for ABI scenario \u2013\nAnki-Android  \n---  \nGraph with compilation breakdown for incremental build for non-ABI scenario \u2013\nAnki-Android  \n---  \n  \nAgain, the Exposed project demonstrated a smaller improvement in the\ninitialization and analysis phases, with a relatively modest 12%\u201355%\nperformance boost. In fact, in the case of incremental builds with ABI changes\nin the IR lowering and IR generation phases, there was actually a performance\ndegradation. However, the time taken in these phases is so little to begin\nwith that we believe the impact to be imperceptible. For example, the IR\nlowering phase takes 0.01 seconds in Kotlin 1.9.23, rising to 0.014 seconds in\nKotlin 2.0.0.\n\n# Collect your own measurements\n\nAs we edge closer to the release of Kotlin 2.0.0, the spotlight is firmly on\nthe K2 compiler, and it\u2019s your turn to put it to the test. This section guides\nyou through collecting your own Kotlin project performance statistics.\n\nTo facilitate an easy and quick benchmarking process for your own Kotlin\nprojects, we\u2019ve prepared a performance management tool especially for you.\nThis is a Kotlin-based project that allows you to gather performance\nmeasurements for any Kotlin project, local or remote. By default, this project\nruns benchmark tests for Kotlin versions 1.9.23 and 2.0.0-RC1. However, you\nhave the option to customize your own test scenarios as required. For\nvisualization purposes, you can analyze the raw data generated by these\nscenarios, or use the provided Kotlin notebook for a more convenient visual\nrepresentation.\n\n### Step 1: Open the project in IntelliJ IDEA\n\n  1. Clone the k2-performance-metrics repository.\n  2. Download and install the latest version of IntelliJ IDEA.\n  3. On the IntelliJ IDEA welcome screen, click Open or select File | Open in the menu bar.\n  4. Navigate to the k2-performance-metrics folder and click Open.\n\n### Step 2: Set up your project\n\n  1. Verify environment variables:=\n\n    1. Confirm that the JAVA_HOME variable is set, as it will be used to compile your project.\n    2. Ensure that ANDROID_HOME is set if your project involves Android development.\n  2. In the gradle.properties file, add the project that you want to collect measurements for in one of the following ways:\n\n     * Add the local path in project.path.\n     * Add the GitHub URL in project.git.url and the commit that you want the tests to run from in project.git.commit.sha.\n\n  3. For the incremental build scenarios, add the path to the file where you\u2019re making changes:\n\n    1. scenario.abi.changes for the incremental build with ABI changes scenario.\n    2. scenario.non.abi.changes for the incremental build without ABI changes scenario.\n\n### Step 3: Collect measurements\n\n  1. In IntelliJ IDEA, open the Gradle tool window by selecting View | Tool Windows | Gradle.\n  2. In Tasks | benchmarks, select and run the runBenchmarks task.\n\nAlternatively, you can run the following command in the terminal from the\nk2-performance-measurement root directory:\n\nPlain text\n\nCopy to clipboard\n\nOpen code in new window\n\nEnlighterJS 3 Syntax Highlighter\n\n./gradlew runBenchmarks -t\n\n./gradlew runBenchmarks -t\n\n    \n    \n    ./gradlew runBenchmarks -t\n\nBy default, the build reports are available in the reports/{kotlin-\nversion}/{scenario-name} folders.\n\n> If you want to create your own custom test scenarios, you can do so by\n> extending the task class in your build.gradle.kts file. For more\n> information, see the Create custom build scenarios section in the\n> k2-performance-metrics repository\u2019s README.md.\n\n### Step 4: Analyze your results with Kotlin Notebook\n\n> You need IntelliJ IDEA Ultimate to use Kotlin notebooks.\n\n  1. In IntelliJ IDEA, go to Settings/Preferences | Plugins and select the Marketplace tab.\n  2. In the search bar, search for \u201cKotlin Notebook\u201d and select Install.\n  3. Open benchmarkResult.ipynb and click the Run All button in the gutter to run all cells.\n\n## Conclusion\n\nIn summary, the new K2 compiler architecture can significantly reduce\ncompilation times in your projects. This is particularly true for clean builds\nand the analysis phase of compilation, though Gradle build times are also\nshortened by the new compiler. Nevertheless, the degree of improvement that\nyou\u2019ll see will depend on your specific project. Some projects may enjoy a\nconsiderable increase in performance, while others may only experience modest\ngains.\n\nThroughout our time working on the new K2 compiler, we\u2019ve been constantly\ntesting its performance on our internal projects. Additionally, EAP champions\nand early adopters have been testing it on their own projects, providing\ninvaluable feedback on its performance and usability.\n\nNow, we\u2019re asking you to try the K2 compiler and provide your feedback. We\nencourage you to join the #k2-early-adopters channel in our public Slack (get\nyour invite here) for support and discussions. If you\u2019re facing specific\nproblems or bugs, please don\u2019t hesitate to create an issue in the Kotlin\nYouTrack project. Your feedback is invaluable in refining K2 and ensuring it\nmeets the high standards and needs of our community.\n\n## What else to read and watch\n\n  * K2 Compiler Migration Guide\n  * K2 Kotlin Mode (Alpha) in IntelliJ IDEA\n  * What Everyone Must Know About The New Kotlin K2 Compiler\n  * The K2 Compiler Is Going Stable in Kotlin 2.0\n\n  * Share\n  * Facebook\n  * Twitter\n  * Linkedin\n\nPrev post A Step-by-Step Guide to Performing Data Analysis With Kotlin\nDataFrame\n\n#### Subscribe to Kotlin Blog updates\n\nThanks, we've got you!\n\n  1. Projects\n  2. Tools\n  3. Clean builds\n  4. Incremental builds\n\n    1. Step 1: Open the project in IntelliJ IDEA\n    2. Step 2: Set up your project\n    3. Step 3: Collect measurements\n    4. Step 4: Analyze your results with Kotlin Notebook\n  5. Conclusion\n  6. What else to read and watch\n\n## Discover more\n\n#### A Step-by-Step Guide to Performing Data Analysis With Kotlin DataFrame\n\nLearn how to easily manipulate and visualize your data using the Kotlin\nDataFrame and Kandy libraries.\n\nGarth Gilmour April 24, 2024\n\n0\n\n#### Data Analytics With Kotlin Notebooks, DataFrame, and Kandy\n\nInteractively exploring and visualizing data allows users to uncover hidden\npatterns, trends, and relationships that may not be immediately apparent\nthrough static analysis. This instant feedback allows users to quickly\nvalidate their assumptions, identify outliers or anomalies, and adjust their\nanalyses.\n\nAnton Arhipov March 27, 2024\n\n2\n\n#### Kandy: the new Kotlin plotting library by JetBrains\n\nWe are excited to introduce Kandy, a new Kotlin plotting library by JetBrains.\nIt provides a new, powerful DSL for creating charts of various kinds. The\nfirst public preview version is ready for you to try, and we welcome any\nfeedback and comments you may have. Kandy Documentation How does it ...\n\nPavel Gorgulov December 14, 2023\n\n8\n\n#### Kotlin for WebAssembly Goes Alpha\n\nKotlin/Wasm is in Alpha! Continue reading to explore the capabilities of this\ntechnology.\n\nSebastian Aigner December 7, 2023\n\n3\n\n  * Privacy & Security\n  * Terms of Use\n  * Legal\n  * Genuine tools\n\n  * Twitter\n  * Facebook\n  * Linkedin\n  * Instagram\n  * Youtube\n  * RSS\n  * Tiktok\n\nMerchandise store iconMerchandise store\n\nCopyright \u00a9 2000 JetBrains s.r.o.\n\n", "frontpage": false}
