{"aid": "40155423", "title": "What's Lazy Evaluation in Python?", "url": "https://realpython.com/python-lazy-evaluation/", "domain": "realpython.com", "votes": 1, "user": "kryster", "posted_at": "2024-04-25 09:48:31", "comments": 0, "source_title": "What's Lazy Evaluation in Python? \u2013 Real Python", "source_text": "What's Lazy Evaluation in Python? \u2013 Real Python\n\nBrowse Topics Guided Learning Paths Basics Intermediate Advanced\n\napi best-practices career community databases data-science data-structures\ndata-viz devops django docker editors flask front-end gamedev gui machine-\nlearning numpy projects python testing tools web-dev web-scraping\n\nTable of Contents\n\n  * In Short: Python Lazy Evaluation Generates Objects Only When Needed\n  * What Are Examples of Lazy Evaluation in Python?\n\n    * Other Built-In Data Types\n    * Iterators in itertools\n    * Generator Expressions and Generator Functions\n    * Short-Circuit Evaluation\n    * Functional Programming Tools\n    * File Reading Operations\n  * How Can a Data Structure Have Infinite Elements?\n  * What Are the Advantages of Lazy Evaluation in Python?\n  * What Are the Disadvantages of Lazy Evaluation in Python?\n  * Conclusion\n\nShare Share Email\n\n# What's Lazy Evaluation in Python?\n\nby Stephen Gruppetta Apr 24, 2024 0 Comments intermediate python\n\nShare Share Email\n\nTable of Contents\n\n  * In Short: Python Lazy Evaluation Generates Objects Only When Needed\n  * What Are Examples of Lazy Evaluation in Python?\n\n    * Other Built-In Data Types\n    * Iterators in itertools\n    * Generator Expressions and Generator Functions\n    * Short-Circuit Evaluation\n    * Functional Programming Tools\n    * File Reading Operations\n  * How Can a Data Structure Have Infinite Elements?\n  * What Are the Advantages of Lazy Evaluation in Python?\n  * What Are the Disadvantages of Lazy Evaluation in Python?\n  * Conclusion\n\nRemove ads\n\nBeing lazy is not always a bad thing. Every line of code you write has at\nleast one expression that Python needs to evaluate. Python lazy evaluation is\nwhen Python takes the lazy option and delays working out the value returned by\nan expression until that value is needed.\n\nAn expression in Python is a unit of code that evaluates to a value. Examples\nof expressions include object names, function calls, expressions with\narithmetic operators, literals that create built-in object types such as\nlists, and more. However, not all statements are expressions. For example, if\nstatements and for loop statements don\u2019t return a value.\n\nPython needs to evaluate every expression it encounters to use its value. In\nthis tutorial, you\u2019ll learn about the different ways Python evaluates these\nexpressions. You\u2019ll understand why some expressions are evaluated immediately,\nwhile others are evaluated later in the program\u2019s execution. So, what\u2019s lazy\nevaluation in Python?\n\nGet Your Code: Click here to download the free sample code that shows you how\nto use lazy evaluation in Python.\n\nTake the Quiz: Test your knowledge with our interactive \u201cWhat's Lazy\nEvaluation in Python?\u201d quiz. You\u2019ll receive a score upon completion to help\nyou track your learning progress:\n\nInteractive Quiz\n\n## What's Lazy Evaluation in Python?\n\nIn this quiz, you'll test your understanding of the differences between lazy\nand eager evaluation in Python. By working through this quiz, you'll revisit\nhow Python optimizes memory use and computational overhead by deciding when to\ncompute values.\n\n## In Short: Python Lazy Evaluation Generates Objects Only When Needed\n\nAn expression evaluates to a value. However, you can separate the type of\nevaluation of expressions into two types:\n\n  1. Eager evaluation\n  2. Lazy evaluation\n\nEager evaluation refers to those cases when Python evaluates an expression as\nsoon as it encounters it. Here are some examples of expressions that are\nevaluated eagerly:\n\nPython\n\n    \n    \n    1>>> 5 + 10 215 3 4>>> import random 5>>> random.randint(1, 10) 64 7 8>>> [2, 4, 6, 8, 10] 9[2, 4, 6, 8, 10] 10>>> numbers = [2, 4, 6, 8, 10] 11>>> numbers 12[2, 4, 6, 8, 10]\n\nInteractive environments, such as the standard Python REPL used in this\nexample, display the value of an expression when the line only contains the\nexpression. This code section shows a few examples of statements and\nexpressions:\n\n  * Lines 1 and 2: The first example includes the addition operator +, which Python evaluates as soon as it encounters it. The REPL shows the value 15.\n  * Lines 4 to 6: The second example includes two lines:\n\n    * The import statement includes the keyword import followed by the name of a module. The module name random is evaluated eagerly.\n    * The function call random.randint() is evaluated eagerly, and its value is returned immediately. All standard functions are evaluated eagerly. You\u2019ll learn about generator functions later, which behave differently.\n  * Lines 8 to 12: The final example has three lines of code:\n\n    * The literal to create a list is an expression that\u2019s evaluated eagerly. This expression contains several integer literals, which are themselves expressions evaluated immediately.\n    * The assignment statement assigns the object created by the list literal to the name numbers. This statement is not an expression and doesn\u2019t return a value. However, it includes the list literal on the right-hand side, which is an expression that\u2019s evaluated eagerly.\n    * The final line contains the name numbers, which is eagerly evaluated to return the list object.\n\nThe list you create in the final example is created in full when you define\nit. Python needs to allocate memory for the list and all its elements. This\nmemory won\u2019t be freed as long as this list exists in your program. The memory\nallocation in this example is small and won\u2019t impact the program. However,\nlarger objects require more memory, which can cause performance issues.\n\nLazy evaluation refers to cases when Python doesn\u2019t work out the values of an\nexpression immediately. Instead, the values are returned at the point when\nthey\u2019re required in the program. Lazy evaluation can also be referred to as\ncall-by-need.\n\nThis delay of when the program evaluates an expression delays the use of\nresources to create the value, which can improve the performance of a program\nby spreading the time-consuming process across a longer time period. It also\nprevents values that will not be used in the program from being generated.\nThis can occur when the program terminates or moves to another part of its\nexecution before all the generated values are used.\n\nWhen large datasets are created using lazily-evaluated expressions, the\nprogram doesn\u2019t need to use memory to store the data structure\u2019s contents. The\nvalues are only generated when they\u2019re needed.\n\nAn example of lazy evaluation occurs within the for loop when you iterate\nusing range():\n\nPython\n\n    \n    \n    for index in range(1, 1_000_001): print(f\"This is iteration {index}\")\n\nThe built-in range() is the constructor for Python\u2019s range object. The range\nobject does not store all of the one million integers it represents. Instead,\nthe for loop creates a range_iterator from the range object, which generates\nthe next number in the sequence when it\u2019s needed. Therefore, the program never\nneeds to have all the values stored in memory at the same time.\n\nLazy evaluation also allows you to create infinite data structures, such as a\nlive stream of audio or video data that continuously updates with new\ninformation, since the program doesn\u2019t need to store all the values in memory\nat the same time. Infinite data structures are not possible with eager\nevaluation since they can\u2019t be stored in memory.\n\nThere are disadvantages to deferred evaluation. Any errors raised by an\nexpression are also deferred to a later point in the program. This delay can\nmake debugging harder.\n\nThe lazy evaluation of the integers represented by range() in a for loop is\none example of lazy evaluation. You\u2019ll learn about more examples in the\nfollowing section of this tutorial.\n\nRemove ads\n\n## What Are Examples of Lazy Evaluation in Python?\n\nIn the previous section, you learned about using range() in a for loop, which\nleads to lazy evaluation of the integers represented by the range object.\nThere are other expressions in Python that lead to lazy evaluation. In this\nsection, you\u2019ll explore the main ones.\n\n### Other Built-In Data Types\n\nThe Python built-ins zip() and enumerate() create two powerful built-in data\ntypes. You\u2019ll explore how these data types are linked to lazy evaluation with\nthe following example. Say you need to create a weekly schedule, or rota, that\nshows which team members will bring coffee in the morning.\n\nHowever, the coffee shop is always busy on Monday mornings, and no one wants\nto be responsible for Mondays. So, you decide to randomize the rota every\nweek. You start with a list containing the team members\u2019 names:\n\nPython\n\n    \n    \n    >>> names = [\"Sarah\", \"Matt\", \"Jim\", \"Denise\", \"Kate\"] >>> import random >>> random.shuffle(names) >>> names ['Sarah', 'Jim', 'Denise', 'Matt', 'Kate']\n\nYou also shuffle the names using random.shuffle(), which changes the list in\nplace. It\u2019s time to create a numbered list to pin to the notice board every\nweek:\n\nPython\n\n    \n    \n    >>> for index, name in enumerate(names, start=1): ... print(f\"{index}. {name}\") ... 1. Sarah 2. Jim 3. Denise 4. Matt 5. Kate\n\nYou use enumerate() to iterate through the list of names and also access an\nindex as you iterate. By default, enumerate() starts counting from zero.\nHowever, you use the start argument to ensure the first number is one.\n\nBut what does enumerate() do behind the scenes? To explore this, you can call\nenumerate() and assign the object it returns to a variable name:\n\nPython\n\n    \n    \n    >>> numbered_names = enumerate(names, start=1) >>> numbered_names <enumerate object at 0x11b26ae80>\n\nThe object created is an enumerate object, which is an iterator. Iterators are\none of the key tools that allow Python to be lazy since their values are\ncreated on demand. The call to enumerate() pairs each item in names with an\ninteger.\n\nHowever, it doesn\u2019t create those pairs immediately. The pairs are not stored\nin memory. Instead, they\u2019re generated when you need them. One way to evaluate\na value from an iterator is to call the built-in function next():\n\nPython\n\n    \n    \n    >>> next(numbered_names) (1, 'Sarah') >>> next(numbered_names) (2, 'Jim')\n\nThe numbered_names object doesn\u2019t contain all the pairs within it. When it\nneeds to create the next pair of values, it fetches the next name from the\noriginal list names and pairs it up with the next integer. You can confirm\nthis by changing the third name in the list names before fetching the next\nvalue in numbered_names:\n\nPython\n\n    \n    \n    >>> names[2] = \"The Coffee Robot\" >>> next(numbered_names) (3, 'The Coffee Robot')\n\nEven though you created the enumerate object numbered_names before you changed\nthe contents of the list, you fetch the third item in names after you made the\nchange. This behavior is possible because Python evaluates the enumerate\nobject lazily.\n\nLook back at the numbered list you created earlier with the for loop, which\nshows Sarah is due to buy coffee first. Sarah is a Python programmer, so she\nenquired whether the 1 next to her name means she should buy coffee on Tuesday\nsince Monday ought to be 0.\n\nYou decide not to get angry. Instead, you update your code to use zip() to\npair names with weekdays instead of numbers. Note that you recreate and\nshuffle the list again since you have made changes to it:\n\nPython\n\n    \n    \n    >>> names = [\"Sarah\", \"Matt\", \"Jim\", \"Denise\", \"Kate\"] >>> weekdays = [\"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\"] >>> random.shuffle(names) >>> names ['Denise', 'Jim', 'Sarah', 'Matt', 'Kate'] >>> for day, name in zip(weekdays, names): ... print(f\"{day}: {name}\") ... Monday: Denise Tuesday: Jim Wednesday: Sarah Thursday: Matt Friday: Kate\n\nWhen you call zip(), you create a zip object, which is another iterator. The\nprogram doesn\u2019t create copies of the data in weekdays and names to create the\npairs. Instead, it creates the pairs on demand. This is another example of\nlazy evaluation. You can explore the zip object directly as you did with the\nenumerate object:\n\nPython\n\n    \n    \n    >>> day_name_pairs = zip(weekdays, names) >>> next(day_name_pairs) ('Monday', 'Denise') >>> next(day_name_pairs) ('Tuesday', 'Jim') >>> # Modify the third item in 'names' >>> names[2] = \"The Coffee Robot\" >>> next(day_name_pairs) ('Wednesday', 'The Coffee Robot')\n\nThe program didn\u2019t need to create and store copies of the data when you call\nenumerate() and zip() because of lazy evaluation. Another consequence of this\ntype of evaluation is that the data is not fixed when you create the enumerate\nor zip objects. Instead, the program uses the data present in the original\ndata structures when a value is needed from the enumerate or zip objects.\n\nRemove ads\n\n### Iterators in itertools\n\nIterators are lazy data structures since their values are evaluated when\nthey\u2019re needed and not immediately when you define the iterator. There are\nmany more iterators in Python besides enumerate and zip. Every iterable is\neither an iterator itself or can be converted into an iterator using iter().\n\nHowever, in this section, you\u2019ll explore Python\u2019s itertools module, which has\nseveral of these data structures. You\u2019ll learn about two of these tools now,\nand then you can try some of the others after you finish this tutorial.\n\nIn the previous section, you worked with a list of team members. Now, you join\nforces with another team to participate in a quiz, and you want to print out\nthe list of names of the entire quiz team:\n\nPython\n\n    \n    \n    >>> import itertools >>> first_team = [\"Sarah\", \"Matt\", \"Jim\", \"Denise\", \"Kate\"] >>> second_team = [\"Mark\", \"Zara\", \"Mo\", \"Jennifer\", \"Owen\"] >>> for name in itertools.chain(first_team, second_team): ... print(name) ... Sarah Matt Jim Denise Kate Mark Zara Mo Jennifer Owen\n\nThe iterable you use in the for loop is the object created by\nitertools.chain(), which chains the two lists together into a single iterable.\nHowever, itertools.chain() doesn\u2019t create a new list but an iterator, which is\nevaluated lazily. Therefore, the program doesn\u2019t create copies of the strings\nwith the names, but it fetches the strings when they\u2019re needed from the lists\nfirst_name and second_name.\n\nHere\u2019s another way to observe the relationship between the iterator and the\noriginal data structures:\n\nPython\n\n    \n    \n    >>> first_team = [\"Sarah\", \"Matt\", \"Jim\", \"Denise\", \"Kate\"] >>> second_team = [\"Mark\", \"Zara\", \"Mo\", \"Jennifer\", \"Owen\"] >>> import sys >>> sys.getrefcount(first_team) 2 >>> quiz_team = itertools.chain(first_team, second_team) >>> sys.getrefcount(first_team) 3\n\nThe function sys.getrefcount() counts the number of times an object is\nreferenced in the program. Note that sys.getrefcount() always shows one more\nreference to the object that comes from the call to sys.getrefcount() itself.\nTherefore, when there\u2019s only one reference to an object in the rest of the\nprogram, sys.getrefcount() shows two references.\n\nWhen you create the chain object, you create another reference to the two\nlists since quiz_team needs a reference to where the original data is stored.\nTherefore, sys.getrefcount() shows an extra reference to first_team. But this\nreference disappears when you exhaust the iterator:\n\nPython\n\n    \n    \n    >>> for name in quiz_team: ... print(name) ... Sarah Matt Jim Denise Kate Mark Zara Mo Jennifer Owen >>> sys.getrefcount(first_team) 2\n\nLazy evaluation of data structures such as itertools.chain rely on this\nreference between the iterator, such as itertools.chain, and the structure\ncontaining the data, such as first_team.\n\nAnother tool in itertools that highlights the difference between eager and\nlazy evaluation is itertools.islice(), which is the lazy evaluation version of\nPython\u2019s slice. Create a list of numbers and a standard slice of that list:\n\nPython\n\n    \n    \n    >>> numbers = [2, 4, 6, 8, 10] >>> standard_slice = numbers[1:4] >>> standard_slice [4, 6, 8]\n\nNow, you can create an iterator version of the slice using itertools.islice():\n\nPython\n\n    \n    \n    >>> iterator_slice = itertools.islice(numbers, 1, 4) >>> iterator_slice <itertools.islice object at 0x117c93650>\n\nThe arguments in itertools.islice() include the iterable you want to slice and\nthe integers to determine the start and stop indices of the slice, just like\nin a standard slice. You can also include an extra argument representing the\nstep size. The final output doesn\u2019t show the values in the slice since these\nhaven\u2019t been generated yet. They\u2019ll be created when needed.\n\nFinally, change one of the values in the list and loop through the standard\nslice and the iterator slice to compare the outputs:\n\nPython\n\n    \n    \n    >>> numbers[2] = 999 >>> numbers [2, 4, 999, 8, 10] >>> for number in standard_slice: ... print(number) ... 4 6 8 >>> for number in iterator_slice: ... print(number) ... 4 999 8\n\nYou modify the third element in the list numbers. This change doesn\u2019t affect\nthe standard slice, which still contains the original numbers. When you create\na standard slice, Python evaluates that slice eagerly and creates a new list\ncontaining the subset of data from the original sequence.\n\nHowever, the iterator slice is evaluated lazily. Therefore, as you change the\nthird value in the list before you loop through the iterator slice, the value\nin iterator_slice is also affected.\n\nYou\u2019ll visit the itertools module again later in this tutorial to explore a\nfew more of its iterators.\n\nRemove ads\n\n### Generator Expressions and Generator Functions\n\nExpressions that create built-in data structures, such as lists, tuples, or\ndictionaries, are evaluated eagerly. They generate and store all of the items\nin these data structures immediately. An example of this kind of expression is\na list comprehension:\n\nPython\n\n    \n    \n    >>> import random >>> coin_toss = [ ... \"Heads\" if random.random() > 0.5 else \"Tails\" ... for _ in range(10) ... ] >>> coin_toss ['Heads', 'Heads', 'Tails', 'Tails', 'Heads', 'Tails', 'Tails', 'Heads', 'Heads', 'Heads']\n\nThe expression on the right-hand side of the assignment operator (=) creates a\nlist comprehension. This expression is evaluated eagerly, and the ten heads or\ntails values are created and stored in the new list.\n\nThe list comprehension includes a conditional expression that returns either\nthe string \"Heads\" or \"Tails\" depending on the value of the condition between\nthe if and else keywords. The random.random() function creates a random float\nbetween 0 and 1. Therefore, there\u2019s a 50 percent chance for the value created\nto be \"Heads\" or \"Tails\".\n\nYou can replace the square brackets with parentheses on the right-hand side of\nthe assignment operator:\n\nPython\n\n    \n    \n    >>> coin_toss = ( ... \"Heads\" if random.random() > 0.5 else \"Tails\" ... for _ in range(10) ... ) >>> coin_toss <generator object <genexpr> at 0x117a43440>\n\nThe expression in parentheses is a generator expression. Even though it looks\nsimilar to the list comprehension, this expression is not evaluated eagerly.\nIt creates a generator object. A generator object is a type of iterator that\ngenerates values when they\u2019re needed.\n\nThe generator object coin_toss doesn\u2019t store any of the string values.\nInstead, it will generate each value when it\u2019s needed. You can generate and\nfetch the next value using the built-in next():\n\nPython\n\n    \n    \n    >>> next(coin_toss) Tails >>> next(coin_toss) Heads\n\nThe expression that generates \"Heads\" or \"Tails\" is only evaluated when you\ncall next(). This generator will generate ten values since you use range(10)\nin the generator\u2019s for clause. As you called next() twice, there are eight\nvalues left to generate:\n\nPython\n\n    \n    \n    >>> for toss_result in coin_toss: ... print(toss_result) ... Heads Heads Heads Tails Tails Heads Tails Heads\n\nThe for loop iterates eight times, once for each of the remaining items in the\ngenerator. A generator expression is the lazy evaluation alternative to\ncreating a list or a tuple. It\u2019s intended to be used once, unlike its eager\ncounterparts like lists and tuples.\n\nYou can also create a generator object using a generator function. A generator\nfunction is a function definition that has a yield statement instead of a\nreturn statement. You can define a generator function to create a generator\nobject similar to the one you used in the coin toss example above:\n\nPython\n\n    \n    \n    >>> def generate_coin_toss(number): ... for _ in range(number): ... yield \"Heads\" if random.random() > 0.5 else \"Tails\" ... >>> coin_toss = generate_coin_toss(10) >>> next(coin_toss) 'Heads' >>> next(coin_toss) 'Tails' >>> for toss_result in coin_toss: ... print(toss_result) ... Tails Heads Tails Heads Tails Tails Heads Tails\n\nYou create a new generator object each time you call the generator function.\nUnlike standard functions with return, which are evaluated in full, a\ngenerator is evaluated lazily. Therefore, when the first value is needed, the\ncode in the generator function executes code up to the first yield statement.\nIt yields this value and pauses, waiting for the next time a value is needed.\n\nThis process keeps running until there are no more yield statements and the\ngenerator function terminates, raising a StopIteration exception. The\niteration protocol in the for loop catches this StopIteration error, which is\nused to signal the end of the for loop.\n\nLazy iteration in Python also allows you to create multiple versions of the\ndata structure that are independent of each other:\n\nPython\n\n    \n    \n    >>> first_coin_tosses = generate_coin_toss(10) >>> second_coin_tosses = generate_coin_toss(10) >>> next(first_coin_tosses) 'Tails' >>> next(first_coin_tosses) 'Tails' >>> next(first_coin_tosses) 'Heads' >>> second_as_list = list(second_coin_tosses) >>> second_as_list ['Heads', 'Heads', 'Heads', 'Heads', 'Heads', 'Tails', 'Tails', 'Tails', 'Tails', 'Heads'] >>> next(second_coin_tosses) Traceback (most recent call last): ... File \"<input>\", line 1, in <module> StopIteration >>> next(first_coin_tosses) 'Tails'\n\nThe two generators, first_coin_tosses and second_coin_tosses, are separate\ngenerators created from the same generator function. You evaluate the first\nthree values of first_coin_tosses. This leaves seven values in the first\ngenerator.\n\nNext, you convert the second generator into a list. This evaluates all its\nvalues to store them in the second_as_list. There are ten values since the\nvalues you got from the first generator have no effect on the second one.\n\nYou confirm there are no more values left in the second generator when you\ncall next() and get a StopIteration error. However, the first generator,\nfirst_coin_tosses, still has values to evaluate since it\u2019s independent of the\nsecond generator.\n\nGenerators, and iterators in general, are central tools when dealing with lazy\nevaluation in Python. This is because they only yield values when they\u2019re\nneeded and don\u2019t store all their values in memory.\n\nRemove ads\n\n### Short-Circuit Evaluation\n\nThe examples of lazy evaluation you\u2019ve seen so far focused on expressions that\ncreate data structures. However, these are not the only types of expressions\nthat can be evaluated lazily. Consider the and and or operators. A common\nmisconception is that these operators return True or False. In general, they\ndon\u2019t.\n\nYou can start to explore and with a few examples:\n\nPython\n\n    \n    \n    >>> True and True True >>> True and False False >>> 1 and 0 0 >>> 0 and 1 0 >>> 1 and 2 2 >>> 42 and \"hello\" 'hello'\n\nThe first two examples have Boolean operands and return a Boolean. The result\nis True only when both operands are True. However, the third example doesn\u2019t\nreturn a Boolean. Instead, it returns 0, which is the second operand in 1 and\n0. And 0 and 1 also returns 0, but this time, it\u2019s the first operand. The\ninteger 0 is falsy, which means that bool(0) returns False.\n\nSimilarly, the integer 1 is truthy, which means that bool(1) returns True. All\nnon-zero integers are truthy. When Python needs a Boolean value, such as in an\nif statement or with operators such as and and or, it converts the object to a\nBoolean to determine whether to treat it as true or false.\n\nWhen you use the and operator, the program evaluates the first operand and\nchecks whether it\u2019s truthy or falsy. If the first operand is falsy, there\u2019s no\nneed to evaluate the second operand since both need to be truthy for the\noverall result to be truthy. This is what occurs in the expression 0 and 1\nwhere the and operator returns the first value, which is falsy. Therefore, the\nwhole expression is falsy.\n\nPython doesn\u2019t evaluate the second operand when the first one is falsy. This\nis called short-circuit evaluation and it\u2019s an example of lazy evaluation.\nPython only evaluates the second operand if it needs it.\n\nIf the first operand is truthy, Python evaluates and returns the second\noperand, whatever its value. If the first operand is truthy, the truthiness of\nthe second operand determines the overall truthiness of the and expression.\n\nThe final two examples include operands that are truthy. The second operand is\nreturned in both cases to make the whole expression truthy. You can confirm\nthat Python doesn\u2019t evaluate the second operand if the first is falsy with the\nfollowing examples:\n\nPython\n\n    \n    \n    >>> 0 and print(\"Do you see this text?\") 0 >>> 1 and print(\"Do you see this text?\") Do you see this text?\n\nIn the first example, the first operand is 0, and the print() function is\nnever called. In the second example, the first operand is truthy. Therefore,\nPython evaluates the second operand, calling the print() function. Note that\nthe result of the and expression is the value returned by print(), which is\nNone.\n\nAnother striking demonstration of short-circuiting is when you use an invalid\nexpression as the second operand in an and expression:\n\nPython\n\n    \n    \n    >>> 0 and int(\"python\") 0 >>> 1 and int(\"python\") Traceback (most recent call last): ... File \"<input>\", line 1, in <module> ValueError: invalid literal for int() with base 10: 'python'\n\nThe call int(\"python\") raises a ValueError since the string \"python\" can\u2019t be\nconverted into an integer. However, in this first example, the and expression\nreturns 0 without raising the error. The second operand was never evaluated!\n\nThe or operator works similarly. However, only one operand needs to be truthy\nfor the entire expression to evaluate as truthy. Therefore, if the first\noperand is truthy, it\u2019s returned, and the second operand isn\u2019t evaluated:\n\nPython\n\n    \n    \n    >>> 1 or 2 1 >>> 1 or 0 1 >>> 1 or int(\"python\") 1\n\nIn all these examples, the first operand is returned since it\u2019s truthy. The\nsecond operand is ignored and is never evaluated. You confirm this with the\nfinal example, which doesn\u2019t raise a ValueError. This is short-circuit\nevaluation in the or expression. Python is lazy and doesn\u2019t evaluate\nexpressions that have no effect on the final outcome.\n\nHowever, if the first operand is falsy, the result of the or expression is\ndetermined by the second operand:\n\nPython\n\n    \n    \n    >>> 0 or 1 1 >>> 0 or int(\"python\") Traceback (most recent call last): ... File \"<input>\", line 1, in <module> ValueError: invalid literal for int() with base 10: 'python'\n\nThe built-in any() and all() functions are also evaluated lazily using short-\ncircuit evaluation. The any() function returns True if any of the elements in\nan iterable is truthy:\n\nPython\n\n    \n    \n    >>> any([0, False, \"\"]) False >>> any([0, False, \"hello\"]) True\n\nThe list you use in the first call to any() contains the integer 0, the\nBoolean False, and an empty string. All three objects are falsy and any()\nreturns False. In the second example, the final element is a non-empty string,\nwhich is truthy. The function returns True.\n\nThe function stops evaluating elements of the iterable when it finds the first\ntruthy value. You can confirm this using a trick similar to the one you used\nwith the and and or operators with help from a generator function, which you\nlearned about in the previous section:\n\nPython\n\n    \n    \n    >>> def lazy_values(): ... yield 0 ... yield \"hello\" ... yield int(\"python\") ... yield 1 ... >>> any(lazy_values()) True\n\nYou define the generator function lazy_values() with four yield statements.\nThe third statement is invalid since \"python\" can\u2019t be converted into an\ninteger. You create a generator when you call this function in the call to\nany().\n\nThe program doesn\u2019t raise any errors, and any() returns True. The evaluation\nof the generator stopped when any() encountered the string \"hello\", which is\nthe first truthy value in the generator. The function any() performs lazy\nevaluation.\n\nHowever, if the invalid expression doesn\u2019t have any truthy values ahead of it,\nit\u2019s evaluated and raises an error:\n\nPython\n\n    \n    \n    >>> def lazy_values(): ... yield 0 ... yield \"\" ... yield int(\"python\") ... yield 1 ... >>> any(lazy_values()) Traceback (most recent call last): ... File \"<input>\", line 1, in <module> File \"<input>\", line 4, in lazy_values ValueError: invalid literal for int() with base 10: 'python'\n\nThe first two values are falsy. Therefore, any() evaluates the third value,\nwhich raises the ValueError.\n\nThe function all() behaves similarly. However, all() requires all the elements\nof the iterable to be truthy. Therefore, all() short-circuits when it\nencounters the first falsy value. You update the generator function\nlazy_values() to verify this behavior:\n\nPython\n\n    \n    \n    >>> def lazy_values(): ... yield 1 ... yield \"\" ... yield int(\"python\") ... yield 1 ... >>> all(lazy_values()) False\n\nThis code doesn\u2019t raise an error since all() returns False when it evaluates\nthe empty string, which is the second element in the generator.\n\nShort-circuiting, like other forms of lazy evaluation, prevents unnecessary\nevaluation of expressions when these expressions are not required at run time.\n\nRemove ads\n\n### Functional Programming Tools\n\nFunctional programming is a programming paradigm in which functions only have\naccess to data input as arguments and do not alter the state of objects,\nreturning new objects instead. A program written in this style consists of a\nseries of these functions, often with the output from a function used as an\ninput for another function.\n\nSince data is often passed from one function to another, it\u2019s convenient to\nuse lazy evaluation of data structures to avoid storing and moving large\ndatasets repeatedly.\n\nThree of the principle tools in functional programming are Python\u2019s built-in\nmap() and filter() functions and reduce(), which is part of the functools\nmodule. Technically, the first two are not functions but constructors of the\nmap and filter classes. However, you use them in the same way you use\nfunctions, especially in the functional programming paradigm.\n\nYou can explore map() and filter() with the following example. Create a list\nof strings containing names. First, you want to convert all names to\nuppercase:\n\nPython\n\n    \n    \n    >>> original_names = [\"Sarah\", \"Matt\", \"Jim\", \"Denise\", \"Kate\"] >>> names = map(str.upper, original_names) >>> names <map object at 0x117ad31f0>\n\nThe map() function applies the function str.upper() against each item in the\niterable. Each name in the list is passed to str.upper(), and the value\nreturned is used.\n\nHowever, map() doesn\u2019t create a new list. Instead, it creates a map object,\nwhich is an iterator. It\u2019s not surprising that iterators appear often in a\ntutorial about lazy evaluation since they\u2019re one of the main tools for the\nlazy evaluation of values!\n\nYou can evaluate each value, one at a time, using next():\n\nPython\n\n    \n    \n    >>> next(names) 'SARAH' >>> next(names) 'MATT'\n\nYou can also convert the map object into a list. This evaluates the values so\nthey can be stored in the list:\n\nPython\n\n    \n    \n    >>> list(names) ['JIM', 'DENISE', 'KATE']\n\nThere are only three names in this list. You already evaluated and used the\nfirst two names when you called next() twice. Since values are evaluated when\nthey\u2019re needed and not stored in the data structure, you can only use them\nonce.\n\nNow, you only want to keep names that contain at least one letter a. You can\nuse filter() for this task. First, you\u2019ll need to recreate the map object\nrepresenting the uppercase letters since you already exhausted this generator\nin the REPL session:\n\nPython\n\n    \n    \n    >>> names = map(str.upper, original_names) >>> names = filter(lambda x: \"A\" in x, names) >>> names <filter object at 0x117ad0610>\n\nEach item in the second argument in filter(), which is the map object names,\nis passed to the lambda function you include as the first argument. Only the\nvalues for which the lambda function returns True are kept. The rest are\ndiscarded.\n\nYou reuse the variable called names at each stage. If you prefer, you can use\ndifferent variable identifiers, but if you don\u2019t need to keep the intermediate\nresults, it\u2019s best to use the same variable. The object that filter() returns\nis another iterator, a filter object. Therefore, its values haven\u2019t been\nevaluated yet.\n\nYou can cast the filter object to a list as you did in the previous example.\nBut in this case, try looping using a for loop instead:\n\nPython\n\n    \n    \n    >>> for name in names: ... print(name) ... SARAH MATT KATE\n\nThe first function call to map() converts the names to uppercase. The second\ncall, this time to filter(), only keeps the names that include the letter a.\nYou use uppercase A in the code since you\u2019ve already converted all the names\nto uppercase.\n\nFinally, you only keep names that are four letters long. The code below shows\nall the map() and filter() operations since you need to recreate these\niterators each time:\n\nPython\n\n    \n    \n    >>> names = map(str.upper, original_names) >>> names = filter(lambda x: \"A\" in x, names) >>> names = filter(lambda x: len(x) == 4, names) >>> list(names) ['MATT', 'KATE']\n\nYou can reorder the operations to make the overall evaluation lazier. The\nfirst operation converts all names to uppercase, but since you discard some of\nthese names later, it would be best to avoid converting these names. You can\nfilter the names first and convert them to uppercase in the final step. You\nadd \"Andy\" to the list of names to ensure that your code works whether the\nrequired letter is uppercase or lowercase:\n\nPython\n\n    \n    \n    >>> original_names = [\"Sarah\", \"Matt\", \"Jim\", \"Denise\", \"Kate\", \"Andy\"] >>> names = filter(lambda x: (\"a\" in x) or (\"A\" in x), original_names) >>> names = filter(lambda x: len(x) == 4, names) >>> names = map(str.upper, names) >>> list(names) ['MATT', 'KATE', 'ANDY']\n\nThe first call to filter() now checks if either uppercase or lowercase a is in\nthe name. Since it\u2019s more likely that the letter a is not the first letter in\nthe name, you set the first operand to (\"a\" in x) in the or expression to take\nadvantage of short-circuiting with the or operator.\n\nThe lazy evaluation obtained from using map and filter iterators means that\ntemporary data structures containing all the data are not needed in each\nfunction call. This won\u2019t have a significant impact in this case since the\nlist only contains six names, but it can affect performance with large sets of\ndata.\n\nRemove ads\n\n### File Reading Operations\n\nThe final example of expressions that are evaluated lazily will focus on\nreading data from a comma-separated values file, usually referred to as a CSV\nfile. CSV files are a basic spreadsheet file format. They are text files with\nthe .csv file extension that have commas separating values to denote values\nthat belong to different cells in the spreadsheet. Each line ends with the\nnewline character \"\\n\" to show where each row ends.\n\nYou can use any CSV file you wish for this section, or you can copy the data\nbelow and save it as a new text file with the .csv extension. Name the CSV\nfile superhero_pets.csv and place it in your project folder:\n\nCSV superhero_pets.csv\n\n    \n    \n    Pet Name,Species,Superpower,Favorite Snack,Hero Owner Whiskertron,Cat,Teleportation,Tuna,Catwoman Flashpaw,Dog,Super Speed,Peanut Butter,The Flash Mystique,Squirrel,Illusion,Nuts,Doctor Strange Quackstorm,Duck,Weather Control,Bread crumbs,Storm Bark Knight,Dog,Darkness Manipulation,Bacon,Batman\n\nYou\u2019ll explore two ways of reading data from this CSV file. In the first\nversion, you\u2019ll open the file and use the .readlines() method for file\nobjects:\n\nPython\n\n    \n    \n    >>> import pprint >>> with open(\"superhero_pets.csv\", encoding=\"utf-8\") as file: ... data = file.readlines() ... >>> pprint.pprint(data) ['Pet Name,Species,Superpower,Favorite Snack,Hero Owner\\n', 'Whiskertron,Cat,Teleportation,Tuna,Catwoman\\n', 'Flashpaw,Dog,Super Speed,Peanut Butter,The Flash\\n', 'Mystique,Squirrel,Illusion,Nuts,Doctor Strange\\n', 'Quackstorm,Duck,Weather Control,Bread crumbs,Storm\\n', 'Bark Knight,Dog,Darkness Manipulation,Bacon,Batman\\n'] >>> print(type(data)) <class 'list'>\n\nYou import pprint to enable pretty printing of large data structures. Once you\nopen the CSV file using the with context manager, specifying the file\u2019s\nencoding, you call the .readlines() method for the open file. This method\nreturns a list that contains all the data in the spreadsheet. Each item in the\nlist is a string containing all the elements in a row.\n\nThis evaluation is eager since .readlines() extracts all the contents of the\nspreadsheet and stores them in a list. This spreadsheet doesn\u2019t contain a lot\nof data. However, this route could lead to significant pressure on memory\nresources if you\u2019re reading large amounts of data.\n\nInstead, you can use Python\u2019s csv module, which is part of the standard\nlibrary. To simplify this code in the REPL, you can open the file without\nusing a with context manager. However, you should remember to close the file\nwhen you do so. In general, you should use with to open files whenever\npossible:\n\nPython\n\n    \n    \n    >>> import csv >>> file = open(\"superhero_pets.csv\", encoding=\"utf-8\", newline=\"\") >>> data = csv.reader(file) >>> data <_csv.reader object at 0x117a830d0>\n\nYou add the named argument newline=\"\" when opening the file to use with the\ncsv module to ensure that any newlines within fields are dealt with correctly.\nThe object returned by csv.reader() is not a list but an iterator. You\u2019ve\nencountered iterators enough times already in this article to know what to\nexpect.\n\nThe contents of the spreadsheet aren\u2019t stored in a data structure in the\nPython program. Instead, Python will lazily fetch each line when it\u2019s needed,\ngetting the data directly from the file, which is still open:\n\nPython\n\n    \n    \n    >>> next(data) ['Pet Name', 'Species', 'Superpower', 'Favorite Snack', 'Hero Owner'] >>> next(data) ['Whiskertron', 'Cat', 'Teleportation', 'Tuna', 'Catwoman'] >>> next(data) ['Flashpaw', 'Dog', 'Super Speed', 'Peanut Butter', 'The Flash']\n\nThe first call to next() triggers the evaluation of the first item of the data\niterator. This is the first row of the spreadsheet, which is the header row.\nYou call next() another two times to fetch the first two rows of data.\n\nYou can use a for loop to iterate through the rest of the iterator, and\nevaluate the remaining items:\n\nPython\n\n    \n    \n    >>> for row in data: ... print(row) ... ['Mystique', 'Squirrel', 'Illusion', 'Nuts', 'Doctor Strange'] ['Quackstorm', 'Duck', 'Weather Control', 'Bread crumbs', 'Storm'] ['Bark Knight', 'Dog', 'Darkness Manipulation', 'Bacon', 'Batman'] >>> file.close()\n\nYou evaluated the header and the first two rows in earlier code. Therefore,\nthe for loop only has the final three rows to iterate through. And it\u2019s good\npractice to close the file since you\u2019re not using a with statement.\n\nThe reader() function in the csv module enables you to evaluate the\nspreadsheet rows lazily by fetching each row only when it\u2019s needed. However,\ncalling .readlines() on an open file evaluates the rows eagerly by fetching\nthem all immediately.\n\n## How Can a Data Structure Have Infinite Elements?\n\nLazy evaluation of expressions also enables data structures with infinite\nelements. Infinite data structures can\u2019t be achieved through eager evaluation\nsince it\u2019s not possible to generate and store infinite elements in memory!\nHowever, when elements are generated on demand, as in lazy evaluation, it\u2019s\npossible to have an object that represents an infinite number of elements.\n\nThe itertools module has several tools that can be used to create infinite\niterables. One of these is itertools.count(), which yields sequential numbers\nindefinitely. You can set the starting value and the step size when you create\na count iterator:\n\nPython\n\n    \n    \n    >>> import itertools >>> quarters = itertools.count(start=0, step=0.25) >>> for _ in range(8): ... print(next(quarters)) ... 0 0.25 0.5 0.75 1.0 1.25 1.5 1.75\n\nThe iterator quarters will yield values 0.25 larger than the previous one and\nwill keep yielding values forever. However, none of these values is generated\nwhen you define quarters. Each value is generated when it\u2019s needed, such as by\ncalling next() or as part of an iteration process, such as a for loop.\n\nAnother tool you can use to create infinite iterators is itertools.cycle().\nYou can explore this tool with the list of team member names you used earlier\nin this tutorial to create a rota for who\u2019s in charge of getting coffee in the\nmorning. You decide you don\u2019t want to regenerate the rota every week, so you\ncreate an infinite iterator that cycles through the names:\n\nPython\n\n    \n    \n    >>> names = [\"Sarah\", \"Matt\", \"Jim\", \"Denise\", \"Kate\"] >>> rota = itertools.cycle(names) >>> rota <itertools.cycle object at 0x1156be340>\n\nThe object returned by itertools.cycle() is an iterator. Therefore, it doesn\u2019t\ncreate all its elements when it\u2019s first created. Instead, it generates values\nwhen they\u2019re needed:\n\nPython\n\n    \n    \n    >>> next(rota) 'Sarah' >>> next(rota) 'Matt' >>> next(rota) 'Jim' >>> next(rota) 'Denise' >>> next(rota) 'Kate' >>> next(rota) 'Sarah' >>> next(rota) 'Matt'\n\nThe cycle iterator rota starts yielding each name from the original list\nnames. When all names have been yielded once, the iterator starts yielding\nnames from the beginning of the list again. This iterator will never run out\nof values to yield since it will restart from the beginning of the list each\ntime it reaches the last name.\n\nThis is an object with an infinite number of elements. However, only five\nstrings are stored in memory since there are only five names in the original\nlist.\n\nThe iterator rota is iterable, like all iterators. Therefore, you can use it\nas part of a for loop statement. However, this now creates an infinite loop\nsince the for loop never receives a StopIteration exception to trigger the end\nof the loop.\n\nYou can also achieve infinite data structures using generator functions. You\ncan recreate the rota iterator by first defining the generator function\ngenerate_rota():\n\nPython\n\n    \n    \n    >>> def generate_rota(iterable): ... index = 0 ... length = len(iterable) ... while True: ... yield iterable[index] ... if index == length - 1: ... index = 0 ... else: ... index += 1 ... >>> rota = generate_rota(names) >>> for _ in range(12): ... print(next(rota)) ... Sarah Matt Jim Denise Kate Sarah Matt Jim Denise Kate Sarah Matt\n\nIn the generator function generate_rota(), you manually manage the index to\nfetch items from the iterable, increasing the value after each item is yielded\nand resetting it to zero when you reach the end of the iterable. The generator\nfunction includes a while True statement, which makes this an infinite data\nstructure.\n\nIn this example, the generator function replicates behavior you can achieve\nwith itertools.cycle(). However, you can create any generator with custom\nrequirements using this technique.\n\nRemove ads\n\n## What Are the Advantages of Lazy Evaluation in Python?\n\nYou can revisit an earlier example to explore one of the main advantages of\nlazy evaluation. You created a list and a generator object with several\noutcomes from a coin toss earlier in this tutorial. In this version, you\u2019ll\ncreate one million coin tosses in each one:\n\nPython\n\n    \n    \n    >>> import random >>> coin_toss_list = [ ... \"Heads\" if random.random() > 0.5 else \"Tails\" ... for _ in range(1_000_000) ... ] >>> coin_toss_gen = ( ... \"Heads\" if random.random() > 0.5 else \"Tails\" ... for _ in range(1_000_000) ... ) >>> import sys >>> sys.getsizeof(coin_toss_list) 8448728 >>> sys.getsizeof(coin_toss_gen) 200\n\nYou create a list and a generator object. Both objects represent one million\nstrings with either \"Heads\" or \"Tails\". However, the list takes up over eight\nmillion bytes of memory, whereas the generator uses only 200 bytes. You may\nget a slightly different number of bytes depending on the Python version\nyou\u2019re using.\n\nThe list contains all of the one million strings, whereas the generator\ndoesn\u2019t since it will generate these values when they\u2019re needed. When you have\nlarge amounts of data, using eager evaluation to define data structures may\nput pressure on memory resources in your program and affect performance.\n\nThis example also shows another advantage of using lazy evaluation when you\ncreate a data structure. You could use the conditional expression that returns\n\"Heads\" or \"Tails\" at random directly in the code whenever you need it.\nHowever, creating a generator might be a better option.\n\nSince you included the logic of how to create the values you need in the\ngenerator expression, you can use a more declarative style of coding in the\nrest of your code. You state what you want to achieve without focusing on how\nto achieve it. This can make your code more readable.\n\nAnother advantage of lazy evaluation is the performance gains you could\nachieve by avoiding the evaluation of expressions that you don\u2019t need. These\nbenefits become noticeable in programs that evaluate large numbers of\nexpressions.\n\nYou can demonstrate this performance benefit using the timeit module in\nPython\u2019s standard library. You can explore this with the short-circuit\nevaluation when you use the and operator. The following two expressions are\nsimilar and return the same truthiness:\n\nPython\n\n    \n    \n    >>> import random >>> random.randint(0, 1) and random.randint(0, 10) 1 >>> random.randint(0, 10) and random.randint(0, 1) 8\n\nThese expressions return a truthy value if both calls to random.randint()\nreturn non-zero values. They will return 0 if at least one function returns 0.\nHowever, it\u2019s more likely for random.randint(0, 1) to return 0 compared with\nrandom.randint(0, 10).\n\nTherefore, if you need to evaluate this expression repeatedly in your code,\nthe first version is more efficient due to short-circuit evaluation. You can\ntime how long it takes to evaluate these expressions many times:\n\nPython\n\n    \n    \n    >>> import timeit >>> timeit.repeat( ... \"random.randint(0, 1) and random.randint(0, 10)\", ... number=1_000_000, ... globals=globals(), ... ) [0.39701350000177626, 0.37251866700171377, 0.3730850419997296, 0.3731833749989164, 0.3740811660027248] >>> timeit.repeat( ... \"random.randint(0, 10) and random.randint(0, 1)\", ... number=1_000_000, ... globals=globals(), ... ) [0.504747375001898, 0.4694556670001475, 0.4706860409969522, 0.4841222920003929, 0.47349566599950776]\n\nThe output shows the time it takes for one million evaluations of each\nexpression. There are five separate timings for each expression. The first\nversion is the one that has random.randint(0, 1) as its first operand, and it\nruns quicker than the second one, which has the operands switched around.\n\nThe evaluation of the and expression short-circuits when the first\nrandom.randint() call returns 0. Since random.randint(0, 1) has a 50 percent\nchance of returning 0, roughly half the evaluations of the and expression will\nonly call the first random.randint().\n\nWhen random.randint(0, 10) is the first operand, the expression\u2019s evaluation\nwill only short-circuit once out of every eleven times it runs since there are\neleven possible values returned by random.randint(0, 10).\n\nThe advantages of reducing memory consumption and improving performace can be\nsignificant in some projects where demands on resources matter. However, there\nare some disadvantages to lazy evaluation. You\u2019ll explore these in the next\nsection.\n\n## What Are the Disadvantages of Lazy Evaluation in Python?\n\nLazy evaluation reduces memory requirements and unnecessary operations by\ndelaying the evaluation. However, this delay can also make debugging harder.\nIf there\u2019s an error in an expression that\u2019s evaluated lazily, the exception is\nnot raised right away. Instead, you\u2019ll only encounter the error at a later\nstage of the code\u2019s execution when the expression is evaluated.\n\nTo demonstrate this, you can return to the list of team members you used\nearlier in this tutorial. On this occasion, you want to keep track of the\npoints they gained during a team-building exercise:\n\nPython\n\n    \n    \n    >>> players = [ ... {\"Name\": \"Sarah\", \"Games\": 4, \"Points\": 23}, ... {\"Name\": \"Matt\", \"Games\": 7, \"Points\": 42}, ... {\"Name\": \"Jim\", \"Games\": 1, \"Points\": 7}, ... {\"Name\": \"Denise\", \"Games\": 0, \"Points\": 0}, ... {\"Name\": \"Kate\", \"Games\": 5, \"Points\": 33}, ... ]\n\nYou create a list of players, and each item in the list is a dictionary. Each\ndictionary contains three key-value pairs to store the player\u2019s name, the\nnumber of games they play, and the total number of points they scored.\n\nYou\u2019re interested in the average number of points per game for each player, so\nyou create a generator with this value for each player:\n\nPython\n\n    \n    \n    >>> average_points_per_game = ( ... item[\"Points\"] / item[\"Games\"] ... for item in players ... ) >>> average_points_per_game <generator object <genexpr> at 0x11566a880>\n\nThe generator expression is evaluated lazily. Therefore, the required values\nare not evaluated right away. Now, you can start calling next() to fetch the\naverage number of points per game for each player:\n\nPython\n\n    \n    \n    >>> next(average_points_per_game) 5.75 >>> next(average_points_per_game) 6.0 >>> next(average_points_per_game) 7.0 >>> next(average_points_per_game) Traceback (most recent call last): ... File \"<input>\", line 1, in <module> File \"<input>\", line 1, in <genexpr> ZeroDivisionError: division by zero\n\nYour code evaluates and returns the values for the first three players.\nHowever, it raises a ZeroDivisionError when it tries to evaluate the fourth\nvalue. Denise didn\u2019t enjoy the team-building event and didn\u2019t participate in\nany of the games. Therefore, she played zero games and scored zero points. The\ndivision operation in your generator expression raises an exception in this\ncase.\n\nEager evaluation would raise this error at the point you create the object.\nYou can replace the parentheses with square brackets to create a list\ncomprehension instead of a generator:\n\nPython\n\n    \n    \n    >>> average_points_per_game = [ ... item[\"Points\"] / item[\"Games\"] ... for item in players ... ] Traceback (most recent call last): ... File \"<input>\", line 1, in <module> File \"<input>\", line 1, in <listcomp> ZeroDivisionError: division by zero\n\nThe error is raised immediately in this scenario. Delayed errors can make them\nharder to identify and fix, leading to increased difficulty with debugging\ncode. A popular third-party Python library, TensorFlow, shifted from lazy\nevaluation to eager evaluation as the default option to facilitate debugging.\nUsers can then turn on lazy evaluation using a decorator once they complete\nthe debugging process.\n\nRemove ads\n\n## Conclusion\n\nIn this tutorial, you learned what lazy evaluation in Python is and how it\u2019s\ndifferent from eager evaluation. Some expressions aren\u2019t evaluated when the\nprogram first encounters them. Instead, they\u2019re evaluated when the values are\nneeded in the program.\n\nThis type of evaluation is referred to as lazy evaluation and can lead to more\nreadable code that\u2019s also more memory-efficient and performant. In contrast,\neager evaluation is when an expression is evaluated in full immediately.\n\nThe ideal evaluation mode depends on several factors. For small data sets,\nthere are no noticeable benefits to using lazy evaluation for memory\nefficiency and performance. However, the advantages of lazy evaluation become\nmore important for large amounts of data. Lazy evaluation can also make errors\nand bugs harder to spot and fix.\n\nLazy evaluation is also not ideal when you\u2019re generating data structures such\nas iterators and need to use the values repeatedly in your program. This is\nbecause you\u2019ll need to generate the values again each time you need them.\n\nIn Python, lazy evaluation often occurs behind the scenes. However, you\u2019ll\nalso need to decide when to use expressions that are evaluated eagerly or\nlazily, like when you need to create a list or generator object. Now, you\u2019re\nequipped with the knowledge to understand how to deal with both types of\nevaluation.\n\nGet Your Code: Click here to download the free sample code that shows you how\nto use lazy evaluation in Python.\n\nTake the Quiz: Test your knowledge with our interactive \u201cWhat's Lazy\nEvaluation in Python?\u201d quiz. You\u2019ll receive a score upon completion to help\nyou track your learning progress:\n\nInteractive Quiz\n\n## What's Lazy Evaluation in Python?\n\nIn this quiz, you'll test your understanding of the differences between lazy\nand eager evaluation in Python. By working through this quiz, you'll revisit\nhow Python optimizes memory use and computational overhead by deciding when to\ncompute values.\n\n\ud83d\udc0d Python Tricks \ud83d\udc8c\n\nGet a short & sweet Python Trick delivered to your inbox every couple of days.\nNo spam ever. Unsubscribe any time. Curated by the Real Python team.\n\nAbout Stephen Gruppetta\n\nStephen worked as a research physicist in the past, developing imaging systems\nto detect eye disease. He now teaches coding in Python to kids and adults. And\nhe's almost finished writing his first Python coding book for beginners\n\n\u00bb More about Stephen\n\nEach tutorial at Real Python is created by a team of developers so that it\nmeets our high quality standards. The team members who worked on this tutorial\nare:\n\nAldren\n\nBrenda\n\nBartosz\n\nGeir Arne\n\nMaster Real-World Python Skills With Unlimited Access to Real Python\n\nJoin us and get access to thousands of tutorials, hands-on video courses, and\na community of expert Pythonistas:\n\nLevel Up Your Python Skills \u00bb\n\nMaster Real-World Python Skills With Unlimited Access to Real Python\n\nJoin us and get access to thousands of tutorials, hands-on video courses, and\na community of expert Pythonistas:\n\nLevel Up Your Python Skills \u00bb\n\nWhat Do You Think?\n\nRate this article:\n\nLinkedIn Twitter Facebook Email\n\nWhat\u2019s your #1 takeaway or favorite thing you learned? How are you going to\nput your newfound skills to use? Leave a comment below and let us know.\n\nCommenting Tips: The most useful comments are those written with the goal of\nlearning from or helping out other students. Get tips for asking good\nquestions and get answers to common questions in our support portal.\n\nLooking for a real-time conversation? Visit the Real Python Community Chat or\njoin the next \u201cOffice Hours\u201d Live Q&A Session. Happy Pythoning!\n\nKeep Learning\n\nRelated Tutorial Categories: intermediate python\n\n## Keep reading Real Python by creating a free account or signing in:\n\nContinue \u00bb\n\nAlready have an account? Sign-In\n\nAlmost there! Complete this form and click the button below to gain instant\naccess:\n\nWhat's Lazy Evaluation in Python? (Sample Code)\n\nRemove ads\n\n\u00a9 2012\u20132024 Real Python \u22c5 Newsletter \u22c5 Podcast \u22c5 YouTube \u22c5 Twitter \u22c5 Facebook\n\u22c5 Instagram \u22c5 Python Tutorials \u22c5 Search \u22c5 Privacy Policy \u22c5 Energy Policy \u22c5\nAdvertise \u22c5 Contact Happy Pythoning!\n\n", "frontpage": false}
