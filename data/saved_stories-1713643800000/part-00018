{"aid": "40096994", "title": "Lean Scala", "url": "https://odersky.github.io/blog/2024-04-11-post.html", "domain": "odersky.github.io", "votes": 2, "user": "Taikonerd", "posted_at": "2024-04-20 12:48:56", "comments": 0, "source_title": "Lean Scala", "source_text": "Lean Scala | Language and Code\n\nLanguage and Code\n\n# Lean Scala\n\nApr 11, 2024\n\nProgram code is for communicating between humans, not just for instructing\ncomputers. So we strive for code to be lean. Lean code is simple and\nunderstandable. It is as concise as possible without losing clarity. It avoids\nlingo, over-abstraction, and obscure features. It does not mislead, that is,\nit expresses the meaning of a program clearly and without fault. All these\nproperties are desirable for code just as they are desirable for technical\nprose.\n\nIn principle, one can write lean code in any programming language, but some\nlanguages make it easier than others. Some languages are limited in their\nexpressiveness and therefore require either repetitive boilerplate or awkward\nconstructions. More expressive languages might have the opposite problem:\nthere are too many ways to express the same concepts, which makes it difficult\nto understand code written in an unfamiliar way.\n\nScala, and in particular Scala 3, is a very good notation for writing lean\ncode. It has a smallish, quiet syntax. It has a concise and expressive type\nsystem with good type inference that gives type safety and documentation\nwithout a lot of boilerplate. Its types and its immutable-first orientation\npromote software that is reliable and correct by design, and provide an\nexpressive toolkit for clean modularization. Scala\u2019s system of implicit\nparameters avoids repetitive parameter passing and gives the right foundations\nfor modeling context in all forms, including type classes, configurations, or\ncapabilities. In my courses in EPFL\u2019s Scala specialization on Coursera I\npresent many examples of lean Scala code.\n\nBut Scala also has its set of challenges when it comes to writing lean code.\nThe language is both very flexible and very expressive. Its flexibility allows\ncode bases to be written in many different styles. Its expressiveness can\nencourage over-abstraction. This means that trying to find your way in an\nunfamiliar Scala codebase is sometimes difficult. Some of the stylistic\nvariations are unavoidable if a language is used in many different application\ndomains. Some of them are for historical reasons, since old software tends to\nlook different from new. But there is also the real problem of variations that\narise because people prefer different styles. Which is of course perfectly\nfine as far as the individual is concerned. But it can be a problem for teams,\nand overall the community would be better off if there were more common\ndefaults.\n\nI believe we can and should do something to address these challenges. For a\nstart, we can identify a recommended style to write lean Scala code. I tried\nto come up with a list of properties of such a style and arrived at the\nfollowing.\n\n  * It should follow the Principle of Least Power: Given a choice of solutions, pick the least powerful solution capable of solving your problem. This also extends to language constructs. For instance, implicit conversions or macros are very powerful constructs. One should use them only if simpler alternatives are not sufficient.\n  * It should be immutable first, without being dogmatic about it. That is, we generally prefer immutable data and pure functions, but also allow effects if they are well contained and described. In the near future we will probably have new type constructs that can help here.\n  * It should focus on Scala 3 constructs and syntax. To ease migration, Scala 3 still supports many of Scala 2\u2019s idioms. We are in the process of deprecating those bit by bit, but the process is slow and painful. Lean Scala should jump ahead and drop all Scala 2 legacy constructs.\n  * It should promote the core language over embedded DSLs (domain specific languages). Scala has a rich ecosystem of libraries and frameworks that essentially implement DSLs: fluid syntax in ScalaTest, hardware design in Chisel, query languages, and many others. These have their place, but they also contribute to language fragmentation. So we need to distinguish Lean Scala from \u201cScala as a host language for DSLs\u201d.\n  * It should focus on direct style. Monadic effect systems shine in some areas but they are also a kind of DSL, which creates specialized eco-systems and dialects.\n\nNo doubt that list needs to be discussed and refined. Once we have identified\nour goals for lean code, the next question is how to promote it. Here are some\nof the things we can do:\n\n  * Write technical documentation such as blog posts discussing what lean Scala style is, and how to get there.\n  * Work on tooling support. For instance, develop tool tips or linting rules that promote lean Scala. Where possible this should be supported by automatic rewriting from legacy code. Rewriting is particularly helpful for code that is generated by LLMs. The training set bias means that such code is more likely to use old Scala 2 patterns. Once automatic rewrites are established and more Lean Scala code exists, we can assume that LLMs will generate it by themselves when prompted. But initially they will have to be augmented by our own tooling.\n  * Encourage efforts to assemble and promote library stacks that are powerful and easy to use and that support lean coding styles.\n\nClearly, Lean Scala is just one way to write code in the language. There are\nsituations and whole application areas where you want to deviate from the\nstyle and develop your own set of principles and techniques. But Lean Scala is\na useful default, for instance for teams that don\u2019t have special requirements,\npeople new to the language, or for educators that want to teach simple and\nmodern Scala. For that reason, I hope that defining and promoting it will be\nuseful.\n\n\u2190 Previous\n\n## Language and Code\n\n  * Martin Odersky\n\nMy blogs\n\n", "frontpage": false}
