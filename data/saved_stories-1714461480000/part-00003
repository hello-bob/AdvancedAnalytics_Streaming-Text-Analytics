{"aid": "40204256", "title": "PowerShell: The object-oriented shell you didn't know you needed", "url": "https://chriswarrick.com/blog/2024/04/29/powershell-the-object-oriented-shell-you-didnt-know-you-needed/", "domain": "chriswarrick.com", "votes": 8, "user": "todsacerdoti", "posted_at": "2024-04-29 21:19:19", "comments": 2, "source_title": "PowerShell: the object-oriented shell you didn\u2019t know you needed", "source_text": "PowerShell: the object-oriented shell you didn\u2019t know you needed | Chris Warrick\n\nSkip to main content\n\n# PowerShell: the object-oriented shell you didn\u2019t know you needed\n\n29 April 2024 at 18:45\n\n  * Programming\n  * .NET\n  * CSharp\n  * PowerShell\n  * programming\n  * Windows\n  * zsh\n\nPowerShell is an interactive shell and scripting language from Microsoft. It\u2019s\nobject-oriented \u2014 and that\u2019s not just a buzzword, that\u2019s a big difference to\nhow the standard Unix shells work. And it is actually usable as an interactive\nshell.\n\n## Getting Started\n\nPowerShell is so nice, Microsoft made it twice.\n\nSpecifically, there concurrently exist two products named PowerShell:\n\n  * Windows PowerShell (5.1) is a built-in component of Windows. It is proprietary, Windows-only, and is based on the equally proprietary and equally Windows-only .NET Framework 4.x. It has a blue icon.\n  * PowerShell (7.x), formerly known as PowerShell Core, is a stand-alone application. It is MIT-licensed (developed on GitHub), available for Windows, Linux, and macOS, and is based on the equally MIT-licensed and equally multi-platform .NET (formerly .NET Core). It has a black icon.\n\nWindows PowerShell development stopped when PowerShell (Core) came out. There\nare some niceties and commands missing in it, but it is still a fine option\nfor trying it out or for when one can\u2019t install PowerShell on a Windows system\nbut need to solve something with code.\n\nAll examples in this post should work in either version of PowerShell on any\nOS (unless explicitly noted otherwise).\n\nInstall the modern PowerShell: Windows, Linux, macOS.\n\n## Objects? In my shell?\n\nLet\u2019s try getting a directory listing. This is Microsoft land, so let\u2019s try\nthe DOS command for a directory listing \u2014 that would be dir:\n\n    \n    \n    PS C:\\tmp\\hello> dir Directory: C:\\tmp\\hello Mode LastWriteTime Length Name ---- ------------- ------ ---- d---- 2024-04-29 18:00 world -a--- 2024-04-29 18:00 23 example.py -a--- 2024-04-29 18:00 7 foobar.txt -a--- 2024-04-29 18:00 14 helloworld.txt -a--- 2024-04-29 18:00 0 newfile.txt -a--- 2024-04-29 18:00 5 test.txt\n\nThis looks like a typical (if slightly verbose) file listing.\n\nNow, let\u2019s try to do something useful with this. Let\u2019s get the total size of\nall .txt files.\n\nIn a Unix shell, one option is du -bc *.txt. The arguments: -b (--bytes) gives\nthe real byte size, and -c (--summarize) produces a total. The result is this:\n\n    \n    \n    7 foobar.txt 14 helloworld.txt 0 newfile.txt 5 test.txt 26 total\n\nBut how to get just the number? This requires text manipulation (getting the first word of the last line). Something like du -bc *.txt | tail -n 1 | cut -f 1 will do. There\u2019s also wc --total=only --bytes *.txt \u2014 but this is specific to GNU wc, so it won\u2019t cut it on *BSD or macOS. Another option would be to parse the output of ls -l \u2014 but that might not always be easy, and the output may contain something unexpected added by the specific ls version or the user\u2019s specific shell configuration.\n\nLet\u2019s try something in PowerShell. If we do $x = dir, we\u2019ll have the output of\nthe dir command in $x. Let\u2019s try to analyse it further, is the first character\na newline?\n\n    \n    \n    PS C:\\tmp\\hello> $x = dir PS C:\\tmp\\hello> $x[0] Directory: C:\\tmp\\hello Mode LastWriteTime Length Name ---- ------------- ------ ---- d---- 2024-04-29 18:00 world\n\nThat\u2019s interesting, we didn\u2019t get the first character or the first line, we\ngot the first file. And if we try $x[1]?\n\n    \n    \n    PS C:\\tmp\\hello> $x[1] Directory: C:\\tmp\\hello Mode LastWriteTime Length Name ---- ------------- ------ ---- -a--- 2024-04-29 18:00 23 example.py\n\nWhat if we try getting the Length property out of that?\n\n    \n    \n    PS C:\\tmp\\hello> $x[1].Length 23\n\nIt turns out that dir returns an array of objects, and PowerShell knows how to\nformat this array (and a single item from the array) into a nice table. What\ncan we do with it? This:\n\n    \n    \n    PS C:\\tmp\\hello> Get-ChildItem -Filter '*.txt' | ForEach-Object { $_.Length } | Measure-Object -Sum Count : 4 Average : Sum : 26 Maximum : Minimum : StandardDeviation : Property : PS C:\\tmp\\hello> (Get-ChildItem -Filter '*.txt' | ForEach-Object { $_.Length } | Measure-Object -Sum).Sum 26 PS C:\\tmp\\hello> (Get-ChildItem -Filter '*.txt' | Measure-Object -Sum -Property Length).Sum 26 PS C:\\tmp\\hello> (Get-ChildItem -Recurse -Filter '*.txt' | Measure-Object -Sum -Property Length).Sum 30 PS C:\\tmp\\hello> $measured = (Get-ChildItem -Recurse -Filter '*.txt' | Measure-Object -Sum -Property Length) PS C:\\tmp\\hello> $measured.Sum / $measured.Count 6\n\nWe can iterate over all file objects, get their length (using ForEach-Object\nand a lambda), and then use Measure-Object to compute the sum (Measure-Object\nreturns an object, we need to get its Sum property). We can replace the\nForEach-Object call with the -Property argument in Measure-Object. And if we\nwant to look into subdirectories, we can easily add -Recurse to Get-ChildItem.\nWe get actual integers we can do math on.\n\nYou might have noticed I used Get-ChildItem instead of dir in the previous\nexample. Get-ChildItem is the full name of the command (cmdlet). dir is one of\nits aliases, alongside gci and ls (Windows-only to avoid shadowing /bin/ls).\nMany common commands have aliases defined for easier typing and ease of use \u2014\nCopy-Item can be written as cp (for compatibility with Unix), copy (for\ncompatibility with MS-DOS), and ci. In our examples, we could also use measure\nfor Measure-Object and foreach or % for ForEach-Object. Those aliases are a\nnice thing to have for interactive use, but for scripts, it\u2019s best to use the\nfull names for readability, and to avoid depending on the environment for\nthose aliases.\n\n## More filesystem operations\n\n### Files per folder\n\nThere\u2019s a photo collection in a Photos folder, grouped into folders. The\nobjective is to see how many .jpg files are in each folder. Here\u2019s the\nPowerShell solution:\n\n    \n    \n    PS C:\\tmp> Get-ChildItem Photos/*/*.jpg | Group-Object { $_.Directory.Name } | Sort-Object -Property Count -Descending Count Name Group ----- ---- ----- 10 foo bar {C:\\tmp\\Photos\\foo bar\\img001.jpg, C:\\tmp\\Photos\\foo bar\\img002.jpg, C:\\tmp\\Photos\\foo bar\\img003.jpg...} 2 example {C:\\tmp\\Photos\\example\\img101.jpg, C:\\tmp\\Photos\\example\\img201.jpg}\n\nIn Unix land, StackOverflow has a lot of solutions. The top solution is du -a | cut -d/ -f2 | sort | uniq -c | sort -nr \u2014 a lot of tools mashed together, starting with a tool to check disk usage, and a lot of string manipulation. The second solution uses find, read, and shell globbing. The PowerShell solution is quite simple and obvious to anyone who has ever touched SQL.\n\nThe above example works for one level of nesting. For more levels, given\nPhotos\\one\\two\\three.jpg, use Get-ChildItem -Filter '*.jpg' -Recurse Photos,\nand:\n\n  * Group by $_.Directory.Name (same as before) to get two\n  * Group by Split-Path -Parent ([System.IO.Path]::GetRelativePath(\"$PWD/Photos\", $_.FullName)) to get one/two\n  * Group by ([System.IO.Path]::GetRelativePath(\"$PWD/Photos\", $_.FullName)).Split([System.IO.Path]::DirectorySeparatorChar)[0] to get one\n\n(All of the above examples work for a single folder as well. The latter two\nexamples don\u2019t work on Windows PowerShell.)\n\n### Duplicate finder\n\nLet\u2019s build a simple tool to detect byte-for-byte duplicated files. Get-\nFileHash is a shell built-in. We can use Group-Object again, and Where-Object\nto filter only matching objects. Computing the hash of every file is quite\ninefficient, so we\u2019ll group by the file length first, and then ensure the\nhashes match. This gives us a nice pipeline of 6 commands:\n\n    \n    \n    # Fully spelled out Get-ChildItem -Recurse -File | Group-Object { $_.Length } | Where-Object { $_.Count -gt 1 } | ForEach-Object { $_.Group } | Group-Object { (Get-FileHash -Algorithm MD5 $_).Hash } | Where-Object { $_.Count -gt 1 } # Using aliases gci -Recurse -File | group { $_.Length } | where { $_.Count -gt 1 } | foreach { $_.Group } | group { (Get-FileHash -Algorithm MD5 $_).Hash } | where { $_.Count -gt 1 } # Using less readable aliases gci -Recurse -File | group { $_.Length } | ? { $_.Count -gt 1 } | % { $_.Group } | group { (Get-FileHash -Algorithm MD5 $_).Hash } | ? { $_.Count -gt 1 }\n\n## Serious Scripting: Software Bill of Materials\n\nSoftware Bills of Materials (SBOMs) and supply chain security are all the rage\nthese days. The boss wants to have something like that, i.e. a CSV file with a\nlist of packages and versions, and only the direct production dependencies.\nSure, there exist standards like SPDX, but the boss does not like those pesky\n\u201cstandards\u201d. The backend is written in C#, and the frontend is written in\nNode.js. Since we care only about the production dependencies, we can look at\nthe .csproj and package.json files. For Node packages, we\u2019ll also try to fetch\nthe license name from the npm API (the API is a bit more complicated for\nNuGet, so we\u2019ll keep it as a TODO in this example).\n\n    \n    \n    $ErrorActionPreference = \"Stop\" # stop execution on any error Set-StrictMode -Version 3.0 function Get-CsprojPackages([string]$Path) { return Select-Xml -Path $Path -XPath '//PackageReference' | ForEach-Object { [PSCustomObject]@{ Name = $_.Node.GetAttribute(\"Include\") Version = $_.Node.GetAttribute(\"Version\") Source = 'nuget' License = 'TODO' } } } function Get-NodePackages([string]$Path) { $nameToVersion = (Get-Content -Raw $Path | ConvertFrom-Json).dependencies return $nameToVersion.psobject.Properties | ForEach-Object { [PSCustomObject]@{ Name = $_.Name Version = $_.Value Source = 'node' License = (Get-NodeLicense -Name $_.Name) } } } function Get-NodeLicense([string]$Name) { try { return (Invoke-RestMethod -TimeoutSec 3 \"https://registry.npmjs.org/$Name\").license } catch { return \"???\" } } $csprojData = @(Get-ChildItem -Recurse -Filter '*.csproj' | ForEach-Object { Get-CsprojPackages $_.FullName }) $nodeData = @(Get-ChildItem -Recurse -Filter 'package.json' | Where-Object { $_.FullName -notlike '*node_modules*' } | ForEach-Object { Get-NodePackages $_.FullName }) $allData = $csProjData + $nodeData $allData | ConvertTo-Csv -NoTypeInformation | Tee-Object sbom.csv\n\nJust like every well-written shell script starts with set -euo pipefail, every\nPowerShell script should start with $ErrorActionPreference = \"Stop\" so that\nexecution is stopped as soon as something goes wrong. Note that this does not\naffect native commands, you still need to check $LASTEXITCODE. Another useful\nearly command is Set-StrictMode -Version 3.0 to catch undefined variables.\n\nFor .csproj files, which are XML, we look for PackageReference elements using\nXPath, and then build a PSCustomObject out of a hashmap \u2014 extracting the\nappropriate attributes from the PackageReference nodes.\n\nFor package.json, we read the file, parse the JSON, and extract the properties\nof the dependencies object (it\u2019s a map of package names to versions). To get\nthe license, we use Invoke-RestMethod, which takes care of parsing JSON for\nus.\n\nIn the main body of the script, we look for the appropriate files (skipping\nthings under node_modules) and call our parser functions. After retrieving all\ndata, we concatenate the two arrays, convert to CSV, and use Tee-Object to\noutput to a file and to standard output. We get this:\n\n    \n    \n    \"Name\",\"Version\",\"Source\",\"License\" \"AWSSDK.S3\",\"3.7.307.24\",\"nuget\",\"TODO\" \"Microsoft.AspNetCore.SpaProxy\",\"7.0.17\",\"nuget\",\"TODO\" \"@testing-library/jest-dom\",\"^5.17.0\",\"node\",\"MIT\" \"@testing-library/react\",\"^13.4.0\",\"node\",\"MIT\" \"@testing-library/user-event\",\"^13.5.0\",\"node\",\"MIT\" \"@types/jest\",\"^27.5.2\",\"node\",\"MIT\" \"@types/node\",\"^16.18.96\",\"node\",\"MIT\" \"@types/react\",\"^18.3.1\",\"node\",\"MIT\" \"@types/react-dom\",\"^18.3.0\",\"node\",\"MIT\" \"react\",\"^18.3.1\",\"node\",\"MIT\" \"react-dom\",\"^18.3.1\",\"node\",\"MIT\" \"react-scripts\",\"5.0.1\",\"node\",\"MIT\" \"typescript\",\"^4.9.5\",\"node\",\"Apache-2.0\" \"web-vitals\",\"^2.1.4\",\"node\",\"Apache-2.0\"\n\nCould it be done in a different language? Certainly, but PowerShell is really\neasy to integrate with CI, e.g. GitHub Actions or Azure Pipelines. On Linux,\nyou might be tempted to use Python \u2014 and you could get something done equally\nsimply, as long as you don\u2019t mind using the ugly urllib.request library, or\nalternatively ensuring requests is installed (and then you get into the hell\nthat is Python package management).\n\n## Using .NET classes\n\nPowerShell is built on top of .NET. This isn\u2019t just the implementation\ntechnology \u2014 PowerShell gives access to everything the .NET standard library\noffers. For example, the alternate ways to group photos in multiple\nsubdirectories we\u2019ve explored above involve a call to a static method of the\n.NET System.IO.Path class.\n\nOther .NET types are also available. Need a HashSet? Here goes:\n\n    \n    \n    PS> $set = New-Object System.Collections.Generic.HashSet[string] PS> $set.Add(\"hello\") True PS> $set.Add(\"hello\") False PS> $set.Add(\"world\") | Out-Null PS> $set.Count 2 PS> $set -contains \"hello\" True PS> $set -contains \"world\" False\n\nIt is also possible to load any .NET DLL into PowerShell (as long as it\u2019s\ncompatible with the .NET version PowerShell is built against) and use it as\nusual from C# (although possibly with slightly ugly syntax).\n\n## Sick Windows Tricks\n\nMicrosoft supposedly killed off Internet Explorer last year. Attempting to\nlaunch iexplore.exe will bring up Microsoft Edge. But you see, Internet\nExplorer is a crucial part of Windows, and has been so for over two decades.\nSoftware vendors have built software that depends on IE being there and being\nable to show web content. Some of them are using web views, but some of them\nprefer something else: COM.\n\nCOM, or Component Object Model, is Microsoft\u2019s thing for interoperability\nbetween different applications and/or components. COM is basically a way for\nclasses offered by different vendors and potentially written in different\nlanguages to talk to one another. Under the hood, COM is C++ vtables plus\nstandard reference counting and class loading/discovery mechanisms. The .NET\nFramework, and its successor .NET, have always included COM interoperability.\nThe modern WinRT platform is COM on steroids.\n\nComing back to Internet Explorer, it exposes some COM classes. They were not\nremoved with iexplore.exe. This means you can bring up a regular Internet\nExplorer window in just two lines of PowerShell:\n\n    \n    \n    $ie = New-Object -ComObject InternetExplorer.Application $ie.Visible = $true\n\nWhy would you do that? The InternetExplorer.Application object lets you\ncontrol the browser, e.g. you can use $ie.Navigate(\"https://example.com/\") to\ngo to a page. Why would you want to launch IE in 2024? I don\u2019t know, I guess\nyou can use it to laugh in the faces of the Microsoft developers who removed\nthe user-accessible shortcuts? But there definitely exist some legacy\napplications that expect a COM-controllable IE.\n\nWe have already explored the possibility of using classes from .NET. .NET\ncomes with a GUI framework named Windows Forms, which can be loaded from\nPowerShell and used to build a GUI. There is no form designer, so it requires\nmanually defining and positioning controls, but it actually works.\n\nPowerShell can also do various Windows management tasks. It can manage boot\nsettings, BitLocker, Hyper-V, networking, storage... For example, to get the\npercentage of disk space remaining:\n\n    \n    \n    $c = Get-Volume C \"$(($c.SizeRemaining / $c.Size) * 100)%\"\n\n## Getting out of PowerShell land\n\nAs a shell, PowerShell can obviously launch subprocesses. Unlike something\nlike Python, running a subprocess is as simple as running anything else. If\nyou need to git pull, you just type that. Or you can make PowerShell interact\nwith non-PowerShell commands, reading output and passing arguments:\n\n    \n    \n    $changes = (git status --porcelain --null) if ($LASTEXITCODE -eq 128) { throw \"Not a git repository\" } elseif ($LASTEXITCODE -ne 0) { throw \"Getting changes from git failed\" } if ($null -eq $changes) { Write-Host \"No changes found\" } else { $untrackedFiles = @( $changes.Split(\"`0\") | Where-Object { $_.StartsWith('?? ') } | ForEach-Object { $_.Remove(0, 3) } ) # Alternate spelling for regex fans: $untrackedFilesForRegexFans = @( $changes.Split(\"`0\") | Where-Object { $_ -match '^\\?\\? ' } | ForEach-Object { $_ -replace '^\\?\\? ','' } ) if ($untrackedFiles) { Write-Host \"Opening $($untrackedFiles.Length) untracked files in VS Code\" code $untrackedFiles } else { Write-Host \"No untracked files\" } }\n\nI chose to compute untracked files with the help of standard .NET string\nmanipulation methods, but there\u2019s also a regex option. On a related note,\nthere are three content check operators: -match uses regex, -like uses\nwildcards, and -contains checks collection membership.\n\n## Profile script\n\nI use a fairly small profile script that adds some behaviours I\u2019m used to from\nUnix, and to make Tab completion show a menu. Here are the most basic bits:\n\n    \n    \n    Set-PSReadLineOption -HistorySearchCursorMovesToEnd Set-PSReadLineKeyHandler -Key UpArrow -Function HistorySearchBackward Set-PSReadLineKeyHandler -Key DownArrow -Function HistorySearchForward Set-PSReadlineKeyHandler -Key ctrl+d -Function DeleteCharOrExit Set-PSReadlineKeyHandler -Key Tab -Function MenuComplete Set-PSReadLineOption -AddToHistoryHandler { param($command) # Commands starting with space are not remembered. return -not ($command -like ' *') }\n\nApart from that, I use a few aliases and a pretty prompt with the help of oh-\nmy-posh.\n\n## The unusual and sometimes confusing parts\n\nPowerShell can be verbose. Some of its syntax is a little quirky, compared to\nother languages, e.g. the equality and logic operators (for example, -eq, -le,\n-and). The aliases usually help with remembering commands, but they can\u2019t\nalways be depended on \u2014 ls is defined as an alias only on Windows, and Windows\nPowerShell aliases wget and curl to Invoke-WebRequest, even though all three\nhave completely different command line arguments and outputs (this was removed\nin PowerShell).\n\nMoreover, the Unix/DOS aliases do not change the argument handling. rm -rf foo\nis invalid. rm -r foo is, since argument names can be abbreviated as long as\nthe abbreviation is unambiguous. rm -r -f foo is not valid, because -f can be\nan abbreviation of -Filter or -Force (so rm -r -fo foo) will do. rm foo bar\ndoes not work, an array is needed: rm foo,bar.\n\nC:\\Windows\\regedit.exe launches the Registry editor. \"C:\\Program Files\\Mozilla\nFirefox\\firefox.exe\" is a string. Launching something with spaces in its name\nrequires the call operator: & \"C:\\Program Files\\Mozilla Firefox\\firefox.exe\".\nPowerShell\u2019s tab completion will add the & if necessary.\n\nThere are two function call syntaxes. Calling a function/cmdlet uses the\nshell-style syntax with argument names: Some-Function -Arg1 value1 -Arg2\nvalue2, and argument names can be abbreviated, and can sometimes be omitted.\nCalling a method requires a more traditional syntax: $obj.SomeMethod(value1,\nvalue2). Names are case-insensitive in either case.\n\nThe escape character is the backtick. The backslash is the path separator in\nWindows, so making it an escape character would make everything painful on\nWindows. At least it makes it easy to write regex.\n\n## The ugliest part\n\nThe ugliest and the least intuitive part of PowerShell is the handling of\nsingle-element arrays. PowerShell really wants to unpack them to a scalar. The\ncommand (Get-ChildItem).Length will produce the number of files in the current\ndirectory \u2014 unless there is exactly one file, in which case it will produce\nthe single file\u2019s size in bytes. And if there are zero items, instead of an\nempty array, PowerShell produces $null. Sometimes, things will work out in the\nend (since many cmdlets are happy to get either as inputs), but sometimes,\nPowerShell must be asked to stop this madness and return an array: @(Get-\nChildItem).Length.\n\nThe previous example with git status leverages its --null argument to get\nzero-delimited data, so we expect either $null or a single string according to\nthe rules. If we didn\u2019t want to use --null, we would need to use @(git status\n--porcelain) to always get an array (but we would also need to remove quotes\nthat git adds to paths that contain spaces).\n\n## Conclusion\n\nPowerShell is a fine interactive shell and scripting language. While it does\nhave some warts, it is more powerful than your usual Unix shell, and its\nstrongly-typed, object-oriented code beats stringly-typed sh spaghetti any\nday.\n\n#### No Comments Yet\n\nthis site uses cookies. by using this site, you agree to our cookie and\nprivacy policy.\n\npowered by Nikola, nginx and Hetzner Cloud copyright \u00a9 2009\u20132024 Chris Warrick\nCC BY-NC-SA, unless stated otherwise\n\n", "frontpage": true}
