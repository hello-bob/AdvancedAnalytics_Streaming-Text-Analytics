{"aid": "40136286", "title": "Asyncio Handle Control-C (Sigint) \u2013 Super Fast Python", "url": "https://superfastpython.com/asyncio-control-c-sigint/", "domain": "superfastpython.com", "votes": 1, "user": "rbanffy", "posted_at": "2024-04-23 19:39:58", "comments": 0, "source_title": "Asyncio Handle Control-C (SIGINT)", "source_text": "Asyncio Handle Control-C (SIGINT) - Super Fast Python\n\n  * Skip to main content\n  * Skip to primary sidebar\n  * Skip to footer\n\n## Additional menu\n\nSuper Fast Python\n\nmaking you awesome at concurrency\n\n# Asyncio Handle Control-C (SIGINT)\n\nApril 17, 2024 by Jason Brownlee in Python Asyncio\n\nThe \u201cSignal Interrupt\u201d or SIGINT signal is raised in a program when the user\npresses Ctrl-C.\n\nThis has the effect of interrupting and often terminating a Python program.\n\nThe SIGINT signal can be used to terminate asyncio programs as well, and we\ncan use a custom signal handler function to perform cleanup activities before\nthe asyncio program is closed.\n\nIn this tutorial, you will discover how asyncio programs can handle Control-C\nor SIGINT signals.\n\nLet\u2019s get started.\n\nTable of Contents\n\nToggle\n\n## What is Control-C (SIGINT)\n\nControl-C, or \u201cSignal Interrupt\u201d (SIGINT for short) in Unix-based systems, is\na commonly used method to interrupt or terminate the execution of a program.\n\nWhen we press Control-C in a terminal or send a SIGINT signal to a running\nprocess, it triggers an interrupt request, signaling to the program that it\nshould stop its current execution.\n\n> The SIGINT signal is sent to a process by its controlling terminal when a\n> user wishes to interrupt the process. This is typically initiated by\n> pressing Ctrl+C ...\n>\n> \u2014 Signal (IPC)\n\nIn Python, when a program is running, it generally executes in a single\nthread. If a user sends a Control-C signal, the Python interpreter catches\nthis signal and raises a KeyboardInterrupt exception.\n\nThis exception is designed to gracefully handle the interruption and allows\nthe program to perform necessary cleanup actions before exiting.\n\nIn regular Python, we can handle this exception by using try and except blocks\nto catch the KeyboardInterrupt exception, enabling us to execute specific code\nwhen the program receives a SIGINT signal.\n\nThis approach allows the program to handle the interruption gracefully, such\nas closing open files, releasing resources, or performing any cleanup required\nbefore terminating the program.\n\nHow can we handle a Control-C or SIGINT in asyncio programs?\n\nRun loops using all CPUs, download your FREE book to learn how.\n\n## What Happens in Asyncio When Control-C (SIGINT) is Received\n\nPressing Control-C while an asyncio program will send the SIGINT signal to the\nprocess.\n\nBy default, the SIGINT process will terminate the asyncio program, and this\ncapability was introduced in Python version 3.11.\n\nIt does this by calling the cancel() method on the main task.\n\nThis raises a CancelledError in the main task if it is suspended.\n\nWhen the main task exits, all other running tasks are canceled. This is a\nnormal behavior of the main task.\n\n> When signal.SIGINT is raised by Ctrl-C, the custom signal handler cancels\n> the main task by calling asyncio.Task.cancel() which raises\n> asyncio.CancelledError inside the main task. This causes the Python stack to\n> unwind, try/except and try/finally blocks can be used for resource cleanup.\n>\n> \u2014 Asyncio Runners, Asyncio API Documentation\n\nYou can learn more about the special properties of the main task or \u201cmain\ncoroutine\u201d in the tutorial:\n\n  * What is the Main Coroutine\n\nIf the main task is not suspended and does not suspend after the SIGINT was\nsent to the process, then the main task will not be canceled and instead will\nrun until completion, after which a KeyboardInterrupt will be raised.\n\n> After the main task is cancelled, asyncio.Runner.run() raises\n> KeyboardInterrupt.\n>\n> \u2014 Asyncio Runners, Asyncio API Documentation\n\nRaising a KeyboardInterrupt exception in the main thread is the default\nbehavior for a regular Python program, and provides a fallback if the asyncio\nprogram does not respond to the SIGINT.\n\n> When signal.SIGINT is raised by Ctrl-C, KeyboardInterrupt exception is\n> raised in the main thread by default.\n>\n> \u2014 Asyncio Runners, Asyncio API Documentation\n\nNow that we know the default behavior of SIGINT in asyncio programs, let\u2019s\nlook at adding a custom handler.\n\nDownload Now: Free Asyncio PDF Cheat Sheet\n\n## How to Handle Control-C (SIGINT)\n\nWe can add a custom handler for SIGINT in our asyncio programs.\n\nThis capability was introduced in Python 3.11 and is only supported on Unix-\nbased platforms (e.g. Linux and macOS, not Windows).\n\nThis can be achieved by defining a regular Python function to call when a\nSIGINT is received by the asyncio program, registering our function as a\nhandler at the beginning of our asyncio program.\n\nThe handler function does not take any arguments by default.\n\nFor example:\n\n123| # custom signal handlerdef signal_handler():# ...  \n---|---  \n  \nWe can then register it to handle SIGINT signals by first getting access to\nthe asyncio event loop and then calling the add_signal_handler() method and\nspecifying the signal type to handle and the function to call.\n\nFor example:\n\n12345| ...# get the event looploop = asyncio.get_running_loop()# add a custom\nsignal handlerloop.add_signal_handler(signal.SIGINT, signal_handler)  \n---|---  \n  \nWe could then perform some custom actions in our handler, such as logging or\nreporting the request to shut down, close resources, like socket servers, and\ncancel running tasks.\n\nFor example, we might cancel all running tasks as follows:\n\n12345| # custom signal handlerdef signal_handler():# cancel all tasksfor task\nin asyncio.all_tasks():task.cancel()  \n---|---  \n  \nBecause the handler is a regular Python function, we cannot directly await\ncoroutines or tasks.\n\nNow that we know how to handle SIGINT in our asyncio programs, let\u2019s look at\nsome worked examples.\n\nFree Python Asyncio Course\n\nDownload your FREE Asyncio PDF cheat sheet and get BONUS access to my free\n7-day crash course on the Asyncio API.\n\nDiscover how to use the Python asyncio module including how to define, create,\nand run new coroutines and how to use non-blocking I/O.\n\nLearn more\n\n## Example of Control-C (SIGINT) in Asyncio\n\nWe can explore the default behavior of raising a SIGINT signal in an asyncio\nprogram.\n\nIn this case, we will define a task that reports a message and sleeps for a\nlong duration. The main coroutine will run this task in the background, then\nraise a SIGINT signal and wait for it to take effect. We will use try-except\nblocks to handle exceptions in order to see what exceptions are raised in each\ntask, if at all.\n\nFirstly, we can define the background task that sleeps for an extended\nduration.\n\n12345678910111213| # coroutine to perform some workasync def work():try:#\nreport a messageprint('Work is starting...')# suspend a whileawait\nasyncio.sleep(10)# report a messageprint('Work is done')except\nasyncio.CancelledError as e:print('work() cancelled')except Exception as\ne:print(f'work() got: {e}')  \n---|---  \n  \nNext, we can define the main() coroutine.\n\nFirstly we can create and schedule our work() coroutine as a background task,\nthen suspend a moment to allow it to run.\n\n12345| ...# create and schedule the eventtask = asyncio.create_task(work())#\nwait a momentawait asyncio.sleep(2)  \n---|---  \n  \nNext, we can raise a signal in the process, then sleep a moment to allow the\nmain coroutine/task to respond to it.\n\nWe can raise a signal within our program via the signal.raise_signal() and\npass it the details of the signal to raise, such as signal.SIGINT.\n\n1234567| ...# report progressprint('Sending SIGINT')# raise a sigint in the\ncurrent processsignal.raise_signal(signal.SIGINT)# wait a momentawait\nasyncio.sleep(2)  \n---|---  \n  \nTying this together, the complete main() coroutine is listed below.\n\n12345678910111213141516171819| # main coroutineasync def main():try:# create\nand schedule the eventtask = asyncio.create_task(work())# wait a momentawait\nasyncio.sleep(2)# report progressprint('Sending SIGINT')# raise a sigint in\nthe current processsignal.raise_signal(signal.SIGINT)# wait a momentawait\nasyncio.sleep(2)# report a final messageprint('Main is done')except\nasyncio.CancelledError as e:print('main() cancelled')except Exception as\ne:print(f'main() got: {e}')  \n---|---  \n  \nWe can then start the event loop and run the main() coroutine.\n\n123| ...# start the event loopasyncio.run(main())  \n---|---  \n  \nTying this together, the complete example is listed below.\n\n1234567891011121314151617181920212223242526272829303132333435363738394041| #\nSuperFastPython.com# example of default SIGINT handlingimport signalimport\nasyncio# coroutine to perform some workasync def work():try:# report a\nmessageprint('Work is starting...')# suspend a whileawait asyncio.sleep(10)#\nreport a messageprint('Work is done')except asyncio.CancelledError as\ne:print('work() cancelled')except Exception as e:print(f'work() got: {e}')#\nmain coroutineasync def main():try:# create and schedule the eventtask =\nasyncio.create_task(work())# wait a momentawait asyncio.sleep(2)# report\nprogressprint('Sending SIGINT')# raise a sigint in the current\nprocesssignal.raise_signal(signal.SIGINT)# wait a momentawait\nasyncio.sleep(2)# report a final messageprint('Main is done')except\nasyncio.CancelledError as e:print('main() cancelled')except Exception as\ne:print(f'main() got: {e}')# start the event loopasyncio.run(main())  \n---|---  \n  \nRunning the example first creates the main() coroutine and starts the asyncio\nevent loop to run it.\n\nThe main() coroutine runs and creates the work() coroutine and runs it as a\nbackground task. It then suspends a moment to allow the task to begin.\n\nThe work() coroutine runs and reports a message, it then sleeps for an\nextended period.\n\nThe main() coroutine results and raises a SIGINT in the current process that\nis running the asyncio event loop. It then suspends for a moment to allow the\nSIGINT to take effect.\n\nThe SIGNAL is handled by the asyncio event loop and the main() coroutine is\ncanceled. A message is reported confirming that the main() coroutine was\ncanceled.\n\nOnce the main() coroutine is canceled, the asyncio event loop then cancels all\nother running tasks, such as our work() task. This is the default behavior of\nthe asyncio event loop when the main task exits. The work() task reports a\nmessage confirming it was canceled.\n\nA KeyboardInterrupt exception is not raised because the asyncio program\nhandled the SIGINT and the main thread did not need to handle it.\n\nThis highlights the default behavior when a SIGINT is raised in an asyncio\nprogram.\n\n1234| Work is starting...Sending SIGINTmain() cancelledwork() cancelled  \n---|---  \n  \nNext, let\u2019s explore an example of a custom SIGINT handler in an asyncio\nprogram.\n\nOverwhelmed by the python concurrency APIs? Find relief, download my FREE\nPython Concurrency Mind Maps\n\n## Example of Control-C (SIGINT) Customer Handler in Asyncio\n\nWe can explore an example of a custom SIGINT handler in our asyncio program.\n\nIn this case, we can update the above example to define a custom SIGINT\nhandler function, and to register it at the beginning of our program.\n\nIn this case, we will handle the SIGINT by doing nothing, allowing the asyncio\nprogram to run until completion.\n\nOur custom signal handler function is listed below.\n\n1234| # custom signal handlerdef signal_handler():# report\nprogressprint('Custom SIGINT handler running...')  \n---|---  \n  \nWe can then register this function to be called and handle the SIGINT at the\nbeginning of our program,\n\n12345| ...# get the event looploop = asyncio.get_running_loop()# add a custom\nsignal handlerloop.add_signal_handler(signal.SIGINT, signal_handler)  \n---|---  \n  \nTying this together, the complete example is listed below.\n\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950|\n# SuperFastPython.com# example of custom SIGINT handlingimport signalimport\nasyncio# custom signal handlerdef signal_handler():# report\nprogressprint('Custom SIGINT handler running...')# coroutine to perform some\nworkasync def work():try:# report a messageprint('Work is starting...')#\nsuspend a whileawait asyncio.sleep(10)# report a messageprint('Work is\ndone')except asyncio.CancelledError as e:print('work() cancelled')except\nException as e:print(f'work() got: {e}')# main coroutineasync def main():# get\nthe event looploop = asyncio.get_running_loop()# add a custom signal\nhandlerloop.add_signal_handler(signal.SIGINT, signal_handler)try:# create and\nschedule the eventtask = asyncio.create_task(work())# wait a momentawait\nasyncio.sleep(2)# report progressprint('Sending SIGINT')# raise a sigint in\nthe current processsignal.raise_signal(signal.SIGINT)# wait a momentawait\nasyncio.sleep(2)# report a final messageprint('Main is done')except\nasyncio.CancelledError as e:print('main() cancelled')except Exception as\ne:print(f'main() got: {e}')# start the event loopasyncio.run(main())  \n---|---  \n  \nRunning the example first creates the main() coroutine and starts the asyncio\nevent loop to run it.\n\nThe main() coroutine runs and registers our signal_handler() function to\nhandle any SIGINT signals that are raised.\n\nThe main() coroutine then creates the work() coroutine and runs it as a\nbackground task. It then suspends for a moment to allow the task to begin.\n\nThe work() coroutine runs and reports a message, it then sleeps for an\nextended period.\n\nThe main() coroutine results and raises a SIGINT in the current process that\nis running the asyncio event loop. It then suspends for a moment to allow the\nSIGINT to take effect.\n\nThe SIGNAL is handled by our custom signal_handler() function and reports a\nmessage.\n\nThe asyncio program is not terminated.\n\nThe main() coroutine resumes after its sleep, reports a final message, then\nterminates.\n\nWhen the main() coroutine terminates, the work() coroutine is canceled, the\nnormal behavior when the main task exits.\n\nThis highlights how we can use a custom handler function to handle SIGINT\nsignals in our asyncio programs.\n\n12345| Work is starting...Sending SIGINTCustom SIGINT handler running...Main\nis donework() cancelled  \n---|---  \n  \nNext, let\u2019s look at an example of the main() coroutine being too busy to\nhandle a SIGINT signal.\n\nLoving The Tutorials?\n\nWhy not take the next step? Get the book.\n\nLearn more\n\n## Example of Control-C (SIGINT) Never Handled\n\nWe can explore an example where the main() coroutine is busy and never\nresponds to a raised SIGINT.\n\nThis will prevent the asyncio program from handling the signal, which will\nthen be handled by the main thread and raise a KeyboardInterrupt.\n\nIn this case, we can update the first example above so that the main()\ncoroutine runs a loop that blocks the asyncio event loop.\n\nFor example, we can achieve this with calls to the time.sleep() function, not\nthe asyncio.sleep() function.\n\n1234| ...# perform blocking taskfor i in range(5):time.sleep(1)  \n---|---  \n  \nThe updated main() coroutine with this change is listed below.\n\n1234567891011121314151617181920| # main coroutineasync def main():try:# create\nand schedule the eventtask = asyncio.create_task(work())# wait a momentawait\nasyncio.sleep(2)# report progressprint('Sending SIGINT')# raise a sigint in\nthe current processsignal.raise_signal(signal.SIGINT)# perform blocking\ntaskfor i in range(5):time.sleep(1)# report a final messageprint('Main is\ndone')except asyncio.CancelledError as e:print('main() cancelled')except\nException as e:print(f'main() got: {e}')  \n---|---  \n  \nThis does not suspend the main coroutine and allows other coroutines to run.\nInstead, it blocks the asyncio event loop and prevents any other coroutines\nfrom running.\n\nAs such, the main coroutine does not suspend after the SIGINT is raised and\nnever handles it.\n\nTying this together, the complete example is listed below.\n\n12345678910111213141516171819202122232425262728293031323334353637383940414243|\n# SuperFastPython.com# example of default SIGINT handlingimport signalimport\nasyncioimport time# coroutine to perform some workasync def work():try:#\nreport a messageprint('Work is starting...')# suspend a whileawait\nasyncio.sleep(10)# report a messageprint('Work is done')except\nasyncio.CancelledError as e:print('work() cancelled')except Exception as\ne:print(f'work() got: {e}')# main coroutineasync def main():try:# create and\nschedule the eventtask = asyncio.create_task(work())# wait a momentawait\nasyncio.sleep(2)# report progressprint('Sending SIGINT')# raise a sigint in\nthe current processsignal.raise_signal(signal.SIGINT)# perform blocking\ntaskfor i in range(5):time.sleep(1)# report a final messageprint('Main is\ndone')except asyncio.CancelledError as e:print('main() cancelled')except\nException as e:print(f'main() got: {e}')# start the event\nloopasyncio.run(main())  \n---|---  \n  \nRunning the example first creates the main() coroutine and starts the asyncio\nevent loop to run it.\n\nThe main() coroutine runs and registers our signal_handler() function to\nhandle any SIGINT signals that are raised.\n\nThe main() coroutine then creates the work() coroutine and runs it as a\nbackground task. It then suspends for a moment to allow the task to begin.\n\nThe work() coroutine runs and reports a message, it then sleeps for an\nextended period.\n\nThe main() coroutine results and raises a SIGINT in the current process that\nis running the asyncio event loop.\n\nIt then does not suspend and allows the event loop to handle the signal.\nInstead, it loops and executes a blocking call, then reports a final message\nand terminates.\n\nWhen the main() coroutine terminates, the work() coroutine is canceled, the\nnormal behavior when the main task exits.\n\nFinally, the main thread of the program handles the SIGINT, and a\nKeyboardInterrupt is raised and not handled. This terminates the program.\n\nThis highlights that the main coroutine in an asyncio program can be too busy\nto respond to a SIGINT, which is then handled by the main thread after the\nasyncio program terminates.\n\n1234567891011| Work is starting...Sending SIGINTMain is donework()\ncancelledTraceback (most recent call\nlast):asyncio.exceptions.CancelledErrorDuring handling of the above exception,\nanother exception occurred:KeyboardInterrupt  \n---|---  \n  \n## Takeaways\n\nYou now know how asyncio programs can handle Control-C or SIGINT signals.\n\nDid I make a mistake? See a typo? I\u2019m a simple humble human. Correct me,\nplease!\n\nDo you have any additional tips? I\u2019d love to hear about them!\n\nDo you have any questions? Ask your questions in the comments below and I will\ndo my best to answer.\n\nPhoto by Bing Hui Yau on Unsplash\n\n### Share this:\n\n  * Tweet\n\n### Related Tutorials:\n\n#### About Jason Brownlee\n\nHi, my name is Jason Brownlee, Ph.D. and I\u2019m the guy behind this website. I am\nobsessed with Python Concurrency.\n\nI help python developers learn concurrency, super fast. Learn more.\n\n### Parallel Loops in Python\n\nDiscover how to run your loops in parallel, download your free book now:\n\nYour free book \"Parallel Loops in Python\" includes complete and working code\ntemplates that you can modify and use right now in your own projects.\n\nDownload Your FREE Book\n\n## Reader Interactions\n\n### Do you have any questions?Cancel reply\n\n## Primary Sidebar\n\nAbout Jason Brownlee Hi, my name is Jason Brownlee, Ph.D. and welcome to\nSuperFastPython! My mission is to make Python developers awesome at\nconcurrency. Learn more.\n\n### Join 10,000+ developers:\n\n### Search:\n\n### Asyncio Cheat Sheet:\n\n### Do you want to Learn Asyncio Fast?\n\nDownload your Free PDF Cheat Sheet. Get bonus access to a 7-day crash course.\n\nGet your PDF cheat sheet\n\n### Python Asyncio Guide:\n\nPython Asyncio Guide\n\n### Best Asyncio Resources:\n\n### Asyncio Resources:\n\n  1. Asyncio Tutorials\n  2. Asyncio Guide\n  3. Asyncio Learning Path\n  4. Asyncio Cheat Sheet\n  5. Asyncio Jump-Start Book\n  6. Asyncio Mastery Book\n  7. Asyncio Interview Questions Book\n\n### Python Asyncio Mastery:\n\n### Loving the Tutorials?\n\n#### Get The Book:\n\nLearn More\n\n### Python Concurrency Bookshelf:\n\n### Don't Dabble!\n\n#### Learn All Of Python Concurrency\n\n### No more idle CPUs\n\nLearn more\n\n## Footer\n\n## Learn Asyncio Fast (without the frustration)\n\nWhat if you could develop Python programs that were asynchronous from the\nstart?\n\nThe asyncio module provides easy-to-use coroutine-based concurrency for\nasynchronous programming.\n\nIntroducing: \"Python Asyncio Jump-Start\".\n\nA new book designed to teach you the asyncio module step-by-step, super fast!\n\nCopyright \u00a9 2024 Super Fast Python LinkedIn | Twitter | Facebook | RSS\n\nSuper Fast Python Pty. Ltd. PO Box 206, Vermont, Victoria, 3133, Australia\nABN: 65 654 877 433, ACN: 654 877 433 Email: Jason@SuperFastPython.com\n\n", "frontpage": false}
