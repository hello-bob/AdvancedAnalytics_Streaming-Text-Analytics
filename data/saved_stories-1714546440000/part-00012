{"aid": "40217839", "title": "Open Source Infrastructure Deployment Tool for Early Stage Startups", "url": "https://github.com/bparanj/hivegrid.dev", "domain": "github.com/bparanj", "votes": 1, "user": "bcparanj", "posted_at": "2024-04-30 23:44:23", "comments": 0, "source_title": "GitHub - bparanj/hivegrid.dev: HiveGrid is a infrastructure deployment tool. Install, configure and provision a EC2 instance to deploy Rails 7 apps.", "source_text": "GitHub - bparanj/hivegrid.dev: HiveGrid is a infrastructure deployment tool.\nInstall, configure and provision a EC2 instance to deploy Rails 7 apps.\n\nSkip to content\n\n## Navigation Menu\n\nSign in\n\n# Search code, repositories, users, issues, pull requests...\n\nSearch syntax tips\n\nSign in\n\nSign up\n\nYou signed in with another tab or window. Reload to refresh your session. You\nsigned out in another tab or window. Reload to refresh your session. You\nswitched accounts on another tab or window. Reload to refresh your session.\nDismiss alert\n\nbparanj / hivegrid.dev Public\n\n  * Notifications\n  * Fork 0\n  * Star 8\n\nHiveGrid is a infrastructure deployment tool. Install, configure and provision\na EC2 instance to deploy Rails 7 apps.\n\nwww.hivegrid.dev/\n\n### License\n\nMIT license\n\n8 stars 0 forks Branches Tags Activity\n\nStar\n\nNotifications\n\n# bparanj/hivegrid.dev\n\nThis commit does not belong to any branch on this repository, and may belong\nto a fork outside of the repository.\n\n1 Branch\n\n0 Tags\n\n## Folders and files\n\nName| Name| Last commit message| Last commit date  \n---|---|---|---  \n  \n## Latest commit\n\nbparanjRevise readmeApr 30, 2024d900692 \u00b7 Apr 30, 2024Apr 30, 2024\n\n## History\n\n95 Commits  \n  \n### ansible\n\n|\n\n### ansible\n\n| 1\\. Upgrade Ruby to version 3.3.1| Apr 30, 2024  \n  \n### javascript\n\n|\n\n### javascript\n\n| First version| Apr 8, 2024  \n  \n### packer\n\n|\n\n### packer\n\n| 1\\. Upgrade Ruby to version 3.3.1| Apr 30, 2024  \n  \n### terraform\n\n|\n\n### terraform\n\n| 1\\. Upgrade Ruby to version 3.3.1| Apr 30, 2024  \n  \n### tests\n\n|\n\n### tests\n\n| First version| Apr 8, 2024  \n  \n### troubleshooting\n\n|\n\n### troubleshooting\n\n| Revise docs| Apr 30, 2024  \n  \n### .gitignore\n\n|\n\n### .gitignore\n\n| First version| Apr 8, 2024  \n  \n### DIFFERENTIATION.md\n\n|\n\n### DIFFERENTIATION.md\n\n| Who is it for| Apr 27, 2024  \n  \n### LICENSE\n\n|\n\n### LICENSE\n\n| Initial commit| Apr 7, 2024  \n  \n### PLAYBOOKS.md\n\n|\n\n### PLAYBOOKS.md\n\n| Revise docs| Apr 30, 2024  \n  \n### PROVISION.md\n\n|\n\n### PROVISION.md\n\n| First version| Apr 8, 2024  \n  \n### README.md\n\n|\n\n### README.md\n\n| Revise readme| Apr 30, 2024  \n  \n### VERSIONS.md\n\n|\n\n### VERSIONS.md\n\n| Revise docs| Apr 30, 2024  \n  \n### sweat.md\n\n|\n\n### sweat.md\n\n| Revise docs| Apr 11, 2024  \n  \n### tasks.md\n\n|\n\n### tasks.md\n\n| Revise docs| Apr 10, 2024  \n  \n## Repository files navigation\n\n# HiveGrid\n\nHiveGrid is a toolchain that simplifies the deployment of Rails 7 applications\non AWS by automating the provisioning and configuration of EC2 instances.\n\nRead about the background to learn why this project exists or the entertaining\nbackground story.\n\n## Purpose\n\nAutomate the software delivery process by using a toolchain that leverages\nPacker, Terraform, Ansible and cloud provider SDKs. The toolchain simplifies\ninfrastructure management tasks by using a declarative language, pre-built\ntemplates for common use cases and glue code to integrate with cloud\nproviders.\n\nIt targets developers at companies with limited or no DevOps resources. It\nreduces the time spent on manual infrastructure tasks from days to minutes.\nDevelopers can focus more on application development rather than\ninfrastructure complexities. It is designed for those comfortable with the\ncommand-line interface, offering customizable templates for each phase of\nsoftware delivery to streamline processes and enhance efficiency in the\nsoftware delivery workflow.\n\n## Who is it for?\n\nHiveGrid is tailored for early-stage startups that are still searching for\nproduct/market fit. Scalability is not the immediate concern and modular\nsolution allows startups to iterate quickly based on market feedback.\n\nWith this lightweight toochain, you can rapidly build, deploy and experiment\nwith features without the burden of complex architectures. You can validate\nideas, make data-driven decisions and adapt your product as you learn more\nabout your target market.\n\nBy leveraging the modular approach, you can start small, gradually evolve and\nprioritize features that resonate with users. Whether you're a small team or a\nsolo founder, HiveGrid is designed to keep your development process lean,\nagile and focused on rapid experimentation and learning about your target\nmarket.\n\n## Modular Toolchain\n\nHiveGrid differs from the competition by offering a modular design that\nprioritizes simplicity and flexibility. A set of reusable building blocks can\nbe choosen and you can use only what you need for your specific use case. This\navoids bloat and keeps your system lean.\n\nIt does not impose opinionated choices or predefined architectures. You have\nthe freedom to select the components that fits your requirements. You can\navoid over-engineering and unnecessary complexity, especially in the early\nstages of your startup.\n\nYou don't need to start with a complex architecture. Complex systems have\nsteep learning curves and can be overwhelming. With the modular design, you\ncan start with a simple architecture that meets your immediate needs and\ngradually evolve your architecture organically as your business grows.\nBeginning with a simpler architecture makes it easier to learn and adapt over\ntime.\n\nThe building blocks are designed to be flexible and adaptable, allowing you to\nbuild a new system from scratch. The modular components can be combined and\ncustomized to create a solution tailored to your needs.\n\n    \n    \n    graph TD subgraph StackA[Ruby Stack A] A[deploy_user] --> B[install_ruby] B --> C[postgreSQL] C --> D[install_caddy] style StackA fill:#1f3864,stroke:#333,stroke-width:2px,color:#fff style C fill:#00758F,stroke:#333,stroke-width:2px,color:#fff end\n    \n    \n    graph TD subgraph StackB[Ruby Stack B] A[deploy_user] --> B[install_ruby] B --> C[MySQL] C --> D[install_caddy] style StackB fill:#1f3864,stroke:#333,stroke-width:2px,color:#fff style C fill:#00758F,stroke:#333,stroke-width:2px,color:#fff end\n\nChoose simplicity, flexibility and modularity and stay focused on what matters\nmost \u2014 building a successful product.\n\n## Internal Applications\n\nMany companies build web applications for internal use, where scalability is\nnot a concern. In such cases, an EC2 t2.medium instance is sufficient. With\nHiveGrid, everything can be contained within a single server instance, making\nit an ideal solution for this scenario.\n\nWhen building internal web applications, there is typically no need for\nadvanced features like load balancers, zero-downtime deployments, staging\nenvironments or other complex setups. HiveGrid provides a simpler approach,\nallowing companies to focus on developing their application without the\noverhead of unnecessary infrastructure complexities.\n\nBy leveraging HiveGrid, companies can quickly deploy and manage their internal\nweb applications on a single EC2 instance, simplifying the development and\ndeployment process while keeping costs down.\n\n## Project Scope\n\nTask| Description| Tools  \n---|---|---  \nInstall| Install the software binaries and all dependencies| Ansible, Packer  \nConfigure| Configure the software at runtime. TLS certs, firewall settings\netc| Ansible  \nProvision| Provision the infrastructure. Includes servers, network\nconfiguration, IAM permissions| Terraform  \n  \nThese tools have clear separation of responsibilities, making it easier to\nextend and customize the functionality according to our needs.\n\n## Workflow\n\nWe've knitted together Ansible, Packer, and Terraform to whip up servers on\nAWS like it's nobody's business. Ansible cuts through the configuration chaos,\nletting us cherry-pick cloud services, slap on software, and select our web\nframework with a declarative flair. Packer is our Swiss Army knife, slicing\nacross cloud platforms to provision servers without breaking a sweat. And\nTerraform? It\u2019s the smart cookie that keeps our code lean and mean, thanks to\nits idempotent magic. Meshing these tools together, we've streamlined our AWS\nserver setup, keeping our workflow slick, adaptable, and blazing fast.\n\n    \n    \n    graph LR A[Base Image] --> B[Packer] B --> C[Custom Image] C --> D[Terraform] D --> E[EC2 Instance] F[Code Repository] --> G[Capistrano] G --> E B -- Ansible Provisioner --> B style B fill:#1f77b4,stroke:#333,stroke-width:2px,color:#fff style D fill:#2ca02c,stroke:#333,stroke-width:2px,color:#fff style G fill:#ff7f0e,stroke:#333,stroke-width:2px,color:#fff\n\nTo learn more, read Toolchain\n\n### Advantages of the Toolchain\n\n  * Ensures consistent, reliable and reproducible environments\n  * Automates processes, saving time and reducing human errors\n  * Enables easy scalability, configuration, and cross-environment deployment\n  * Facilitates version control, collaboration and rollbacks\n\n## Anti-Features\n\nDoes not require:\n\n  * Docker\n  * Load balancer\n  * Cloudflare\n  * Traefik\n\n## Packer Image\n\n    \n    \n    graph LR A[Base Image] --> B(Packer) B --> C(Ansible) C --> D[Custom Image] style B fill:#1F77B4,stroke:#333,stroke-width:2px,color:#fff style C fill:#EE0000,stroke:#333,stroke-width:2px,color:#fff\n\n  * Base Image: This is your starting point. It is a generic operating system image (e.g., Ubuntu, CentOS).\n  * Packer: This is the tool that automates the process of image creation. You define the desired configuration of your custom image in a Packer template.\n  * Ansible: Packer uses Ansible as a provisioner to configure and customize the base image.\n  * Custom Image: This is the final product produced by Packer. It includes all the modifications you specified, such as:\n\n    * Installed software packages\n    * System configurations\n\n## Rails Stack\n\nThe custom AMI created by Packer provides:\n\nName| Version  \n---|---  \nRuby| 3.3.1  \nRubyGem| 2.3.6  \nCaddy| 2.7.6  \nPostgreSQL| psql (PostgreSQL) 16.2 (Ubuntu 16.2-1.pgdg22.04+1)  \nRedis| Redis server v=7.2.4 sha=00000000:0 malloc=jemalloc-5.3.0 bits=64\nbuild=4a33ab3ec422ece7  \nGit| git version 2.34.1  \nGoss| 0.4.6  \n  \nSee versions for more details.\n\n### Customized Image\n\nIf the image created by Packer does not meet your requirements, you can:\n\n  1. Customize the Packer template:\n\n     * Open the file packer/aws-ubuntu.pkr.hcl\n     * Modify the base image and other configurations as needed\n  2. Modify the master playbook:\n\n     * Open the file ansible/playbooks/master_playbook.yml\n     * Change the included playbooks to suit your needs\n\n       * For example, you can create a new playbook for MySQL and replace the Postgres playbook\n  3. Customize versions in existing playbooks:\n\n     * Go to the ansible/playbooks folder\n     * Modify the versions for Ruby, Postgresql, Redis, etc. in the corresponding playbooks\n\nBy following these steps, you can tailor the Packer-generated image to your\nspecific requirements.\n\n## Terraform Provisioning\n\nThe custom image created in the previous step is the input to Terraform and\nthe output is a running EC2 instance:\n\n    \n    \n    graph LR A[Custom Image] --> B(Terraform) B --> C[EC2 Instance] style B fill:#1F77B4,stroke:#333,stroke-width:2px,color:#fff\n\n  1. The custom image, which was created using Packer and Ansible, serves as an input to Terraform.\n  2. Terraform, as an infrastructure as code (IaC) tool, uses the custom image to define and provision the desired infrastructure.\n  3. Terraform creates an EC2 instance based on the specifications defined in the Terraform configuration files.\n  4. The EC2 instance is launched using the custom image, ensuring that it includes all the necessary software, configurations, and customizations.\n\nThis diagram illustrates the workflow where the custom image, created through\nthe Packer and Ansible, is consumed by Terraform to provision an EC2 instance.\nTerraform allows you to define the desired state of your infrastructure using\ndeclarative configuration files, and it automatically provisions and manages\nthe EC2 instance based on that configuration.\n\nBy using a custom image for the EC2 instance, we ensure that the instance is\npre-configured with the required software and settings, reducing manual setup\nand configuration after the instance is launched.\n\nThe Terraform template defines the following configuration:\n\n  * Instance Type: t2.medium\n  * Region: us-west-2\n\nSee main.tf for more details. You can change it in terraform/variables.tf.\n\n## Getting Started\n\n### Prerequisites\n\nAn AWS account\n\n  * An IAM user with appropriate policies for EC2, S3, and AWS Secrets Manager\n  * Packer and Terraform installed and configured\n\nSSH Access:\n\nThe PEM file used for SSH access to your EC2 instance, is stored in AWS\nSecrets Manager. This means you can retrieve the PEM file even if you lose the\noriginal downloaded copy. You will be charged for storing the PEM file in\nSecrets Manager. To avoid the cost, you can delete the PEM file from the AWS\nconsole after downloading it.\n\nDatabase Backups: AWS S3 is used for storing database backups.\n\n### Clone the Project\n\n    \n    \n    git clone git@github.com:bparanj/hivegrid.dev.git\n\n### Provision the Server\n\nFrom the root of the project, run the Terraform template:\n\n    \n    \n    terraform apply terraform/main.tf\n\n### Download PEM File\n\nYou must have nodejs installed on your laptop. To install dependencies, go to\njavascript folder directory and run:\n\n    \n    \n    npm install\n\nSet the following environment variables to proper values:\n\n    \n    \n    AWS_ACCESS_KEY_ID AWS_SECRET_ACCESS_KEY ROR_SECRET_KEY\n\nYou will see the value for ROR_SECRET_KEY from the output of the terraform\napply command.\n\nTo download the PEM file, run:\n\n    \n    \n    node keyDownload.js\n\n## Ansible Playbooks\n\nPacker uses Ansible as the provisioner. The Ansible playbooks are included in\nthe master playbook. Packer runs the master playbook to create a custom AMI\nfrom a base Ubuntu 22.04 image. The playbooks:\n\n  * Install required packages on Ubuntu 22.04\n  * Install and configure Fail2ban\n  * Setup deploy user\n  * Harden SSH Configuration\n  * Install and Configure Caddy Server\n  * Install Ruby 3.3.1\n  * Install PostgreSQL 16\n  * Install and Setup Redis\n  * Set server timezone to UTC\n\nSee playbooks for more details.\n\n## Deploying Rails App\n\nYou can use Capistrano to deploy your Rails 7.1 app to the provisioned server.\nWe will be using dotenv gem to manage environment variables on the production\nserver.\n\n    \n    \n    graph LR A[Code] --> B(Capistrano) B -- Deploy --> C[EC2 Instance] style B fill:#1C1B39,stroke:#333,stroke-width:2px,color:#fff style C stroke:#333,stroke-width:2px class C server\n\nThe EC2 instance, provisioned using Terraform with a custom image, serves as\nthe target environment for the deployed application. Capistrano is used\nminimally, mainly because the DSL has a learning curve. If a task can be done\nin Ansible, it is preferred over Capistrano.\n\n## Testing\n\nThe image is tested using Goss. The tests folder contains the tests. Test\nresults are exposed as a JSON endpoint. It can be accessed only within the EC2\ninstance. SSH into your EC2 instance and run:\n\n    \n    \n    curl http://localhost:8080/healthz | jq .\n\n### Goss Test Setup\n\nFor adding tests:\n\n  * Review the Packer and Terraform template\n  * Manually run goss autoadd on the server\n  * Copy the generated file on the server to tests/goss.yaml file in the project\n\n## Image Catalog and Provisioning Template\n\nEach stack has its own image and provisioning template, illustrating the\nseparation between the different stacks.\n\n    \n    \n    graph LR %% Define style for Rails Stack style RailsStack fill:#cc0000,stroke:#333,stroke-width:2px subgraph RailsStack RailsImage[Rails Stack Image] --> RailsTemplate[Rails Provisioning Template] end %% Define style for Django Stack style DjangoStack fill:#092E20,stroke:#333,stroke-width:2px subgraph DjangoStack DjangoImage[Django Stack Image] --> DjangoTemplate[Django Provisioning Template] end\n\n## Lifecyle Hooks\n\n    \n    \n    timeline title Software Delivery Lifecycle Base Image : Ubuntu Custom Hook : Your Code : Boto3 : Playbook Custom Image : AMI Custom Hook : Your Code : Boto3 : Playbook Provision Instance : EC2 Instance Custom Hook : Your Code : Boto3 : Playbook Capistrano Deploy : Your App\n\nYou can customize the process in any of the following phases:\n\n  1. Base Image\n  2. Your Custom Hook\n  3. Custom Image - Packer Build\n  4. Your Custom Hook\n  5. Provision Instance - Terraform Provision\n  6. Your Custom Hook\n  7. Capistrano Deploy\n\nYour custom hooks can be cloud-init script, ansible playbook, code written\nusing Ruby, Python, Java or any other SDK for AWS.\n\n## Getting Started Guide\n\n### Create a AWS Account\n\nMore videos to walk you through each step is coming soon.\n\n## Process at a High Level\n\n    \n    \n    graph TD A[Create IAM dev user] --> B{Default Image Fits Needs?} B -->|Yes| C[Use Default Image] B -->|No| D[Create Image] C --> E[Provision a Server] D --> E E --> F[Setup DNS Records] F --> G[Run SSL playbook] G --> H[Run Puma playbook] H --> I[Change DB Password] I --> J[Capistrano Deploy]\n\nCreate Image step is optional. It is only required if the default image does\nnot fit your needs.\n\n## Request Flow\n\n    \n    \n    graph LR A[Browser] --> B[Caddy] B --> C[Puma] C --> D[PostgreSQL]\n\n## Alternatives\n\n  * Zero\n\n## License\n\nHiveGrid is released under the MIT License.\n\n## Where to Get Help\n\nJoin the discussions to get help.\n\n## Contributing\n\nJoin the discussions to start contributing to this project. Ways to\ncontribute:\n\n  * Ansible playbooks for other SQL and NoSQL database servers\n  * Support other Linux flavors like RHEL, Debian etc.\n  * Packer and Terraform template for other cloud providers like:\n\n#| Provider  \n---|---  \n1| Microsoft Azure  \n2| Google Cloud  \n3| Digital Ocean  \n4| Linode  \n  \n  * Add support for other full stack MVC frameworks like:\n\n#| Framework| Language  \n---|---|---  \n1| Django| Python  \n2| Laravel| PHP  \n3| ASP.NET Core MVC| C#  \n4| Spring Boot| Java  \n5| Phoenix| Elixir  \n6| Play Framework| Java/Scala  \n  \n## Endorsements\n\n> Your endorsement with name can go here.\n\nTake it for a spin and if you like it, send me your endorsement.\n\n## About\n\nHiveGrid is a infrastructure deployment tool. Install, configure and provision\na EC2 instance to deploy Rails 7 apps.\n\nwww.hivegrid.dev/\n\n### Topics\n\nansible packer terraform aws-s3 aws-ec2 aws-secrets-manager\n\n### Resources\n\nReadme\n\n### License\n\nMIT license\n\nActivity\n\n### Stars\n\n8 stars\n\n### Watchers\n\n1 watching\n\n### Forks\n\n0 forks\n\nReport repository\n\n## Releases\n\nNo releases published\n\n## Packages 0\n\nNo packages published\n\n## Languages\n\n  * HCL 71.5%\n  * JavaScript 15.2%\n  * Python 10.0%\n  * Jinja 3.3%\n\n## Footer\n\n\u00a9 2024 GitHub, Inc.\n\nYou can\u2019t perform that action at this time.\n\n", "frontpage": false}
