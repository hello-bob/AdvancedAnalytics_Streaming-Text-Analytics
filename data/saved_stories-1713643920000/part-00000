{"aid": "40097100", "title": "CS SYD \u2013 Getting your Haskell executable statically linked with Nix", "url": "https://cs-syd.eu/posts/2024-04-20_static-linking-haskell-nix", "domain": "cs-syd.eu", "votes": 1, "user": "Norfair", "posted_at": "2024-04-20 13:09:16", "comments": 0, "source_title": "CS SYD - Getting your Haskell executable statically linked with Nix", "source_text": "CS SYD - Getting your Haskell executable statically linked with Nix\n\n# Getting your Haskell executable statically linked with Nix\n\nERT 12 min\n\nDate 2024-04-20\n\nstatic linking\n\nnix\n\nhaskell\n\nI have been making my products statically linked over the past few days. This\npost why and how to statically link your Haskell executables and collects a\nmapping from obscure error to unexpected fixes.\n\nThis work would not have been possible without the many-year-long effort of\npeople like nh2. This issue on GitHub is a good summary of what went into\nmaking this possible.\n\n## Why statically link?\n\nThe issue has a section called \"Why is static linking desirable?\" In short:\n\n  * Statically linked executables are easier to deploy because you don't need to worry about linked libraries being deployed.\n\n  * Statically linked executables start faster because they don't need to look through the file system for the libraries they link against.\n\n## Why is this so complicated?\n\n### Libc\n\nIf you don't know what this means, you have probably been (dynamically)\nlinking your executables against glibc. Statically linking against glibc is\ndiscouraged, so we will have to statically link against musl instead. This\nincludes building ghc against musl and involves using pkgs.pkgsMusl.\n\n### Template Haskell\n\nIn order to statically link an executable that uses Template Haskell at\ncompile-time, the GHC RTS has to be built in the same way as the code you are\ncompiling. This means that we need to tell ghc to produce relocatedStaticLibs\nin order to use Template Haskell.\n\n### Non-Haskell dependencies\n\nNix is excellent for providing non-Haskell dependencies, but the nixpkgs\ninfrastructure has a dontDisableStatic flag that is false by default.\n(Confusing, right?! Couldn't they just have called it enableStatic = false?!)\nSo for a bunch of non-Haskell dependencies, we'll have to override them with\n.overrideAttrs (old: { dontDisableStatic = true; }).\n\n## Getting started with your own project\n\nThis blog post assumes you use the nixpkgs infrastructure for defining the nix\nbuild of your Haskell package and you can build it with some nix build\ninvocation. You will see that it is dynamically linked against a few\nlibraries:\n\n    \n    \n    $ ldd ./result/bin/foo-bar linux-vdso.so.1 (0x00007fff0e5d8000) libm.so.6 => /nix/store/qn3ggz5sf3hkjs2c797xf7nan3amdxmp-glibc-2.38-27/lib/libm.so.6 (0x00007fc9be0ec000) libgmp.so.10 => /nix/store/s3s7gv33p88kzbgki2bprg2a1nc7jnf8-gmp-with-cxx-6.3.0/lib/libgmp.so.10 (0x00007fc9be049000) libc.so.6 => /nix/store/qn3ggz5sf3hkjs2c797xf7nan3amdxmp-glibc-2.38-27/lib/libc.so.6 (0x00007fc9bde61000) librt.so.1 => /nix/store/qn3ggz5sf3hkjs2c797xf7nan3amdxmp-glibc-2.38-27/lib/librt.so.1 (0x00007fc9bde5c000) libdl.so.2 => /nix/store/qn3ggz5sf3hkjs2c797xf7nan3amdxmp-glibc-2.38-27/lib/libdl.so.2 (0x00007fc9bde57000) libffi.so.8 => /nix/store/9kd4bc8fpclpvf1vdwlbila71svyb6w1-libffi-3.4.4/lib/libffi.so.8 (0x00007fc9bde44000) /nix/store/qn3ggz5sf3hkjs2c797xf7nan3amdxmp-glibc-2.38-27/lib/ld-linux-x86-64.so.2 => /nix/store/qn3ggz5sf3hkjs2c797xf7nan3amdxmp-glibc-2.38-27/lib64/ld-linux-x86-64.so.2 (0x00007fc9be1ce000)\n\nWhat we will be aiming for, is to see output like this:\n\n    \n    \n    $ ldd ./result/bin/foo-bar not a dynamic executable\n\n### Fail with a static check\n\nYou can add a check to your build to test whether your binaries are now\nstatically linked. This part is optional, but helps you future-proof your\nbuild against accidentally doing your own work.\n\n    \n    \n    overrideCabal fooBar (old: { postInstall = (old.postInstall or \"\") + '' for b in $out/bin/* do if ldd \"$b\" then echo \"ldd succeeded on $b, which may mean that it is not statically linked\" exit 1 fi done ''; })\n\n### Linking against musl\n\nThe first step will be to use pkgs.pkgsMusl instead of just pkgs. This is\n\"version\" of nixpkgs that uses musl instead of glibc.\n\nSo your package would be pkgs.pkgsMusl.haskellPackages.foo-bar instead of\npkgs.haskellPackages.foo-bar. If we build it, we'll see that it is indeed\n(dynamically) linked against musl instead of glibc:\n\n    \n    \n    $ ldd ./result/bin/foo-bar [...] libc.so => /nix/store/rhpfpswa12l0hdipy9r26j844lp9pp8g-musl-1.2.3/lib/libc.so (0x00007f879edd6000) [...]\n\n### Statically linking\n\nThe nixpkgs infrastructure lets you use pkgs.haskell.lib.overrideCabal on your\npackages to change build settings. We will want to override configure flags,\nwhich looks like this:\n\n    \n    \n    overrideCabal fooBar (old: { configureFlags = (old.configureFlags or [ ]) ++ [ \"new configure flags go here\" ]; })\n\nThe first important flag to add is \"--ghc-option=-optl=-static\", which tells\nCabal to tell ghc to tell the linker to link statically.\n\n    \n    \n    overrideCabal fooBar (old: { configureFlags = (old.configureFlags or [ ]) ++ [ \"--ghc-option=-optl=-static\" ]; })\n\nBut if you do only that, you'll start seeing obscure errors:\n\n    \n    \n    foo-bar-cli> /nix/store/cjcp2ssfn2ng849nqvbyb378d0xrkl01-binutils-2.40/bin/ld: /nix/store/zpk49i784kgwfp8d86rv300aqnd1klyh-gcc-12.3.0/lib/gcc/x86_64-unknown-linux-musl/12.3.0/crtbeginT.o: relocation R_X86_64_32 against hidden symbol `__TMC_END__' can not be used when making a shared object foo-bar-cli> /nix/store/cjcp2ssfn2ng849nqvbyb378d0xrkl01-binutils-2.40/bin/ld: failed to set dynamic section sizes: bad value foo-bar-cli> collect2: error: ld returned 1 exit status foo-bar-cli> `cc' failed in phase `Linker'. (Exit code: 1)\n\nYou may have to scroll to the right to read all of that. This is the important\npiece:\n\n    \n    \n    relocation R_X86_64_32 against hidden symbol `__TMC_END__' can not be used when making a shared object\n\nWe're still trying to make a shared executable (and library), so we'll also\nhave to add these to our override to fix that error:\n\n    \n    \n    overrideCabal fooBar (old: { enableSharedExecutables = false; enableSharedLibraries = false; })\n\n### Enable static linking for dependencies\n\nNext we get more comprehensible errors:\n\n    \n    \n    foo-bar-cli> [6 of 6] Linking dist/build/foo-bar-cli-test/foo-bar-cli-test foo-bar-cli> /nix/store/cjcp2ssfn2ng849nqvbyb378d0xrkl01-binutils-2.40/bin/ld: cannot find -lgmp: No such file or directory foo-bar-cli> /nix/store/cjcp2ssfn2ng849nqvbyb378d0xrkl01-binutils-2.40/bin/ld: cannot find -lffi: No such file or directory foo-bar-cli> collect2: error: ld returned 1 exit status foo-bar-cli> ghc: `cc' failed in phase `Linker'. (Exit code: 1)\n\nAgain, scroll to the right to find:\n\n    \n    \n    ld: cannot find -lgmp: No such file or directory ld: cannot find -lffi: No such file or directory\n\nThe linker cannot find gmp.a or ffi.a because building those is turned off by\ndefault in nixpkgs. TODO is this true?\n\nWe can override those in a nixpkgs override, but that will cause a lot of\nrecompilation:\n\n    \n    \n    gmp6 = prev.gmp6.override { withStatic = true; }; libffi = prev.libffi.overrideAttrs (old: { dontDisableStatic = true; })\n\nSo instead we make them available via some more configure flags:\n\n    \n    \n    overrideCabal fooBar (old: { configureFlags = (old.configureFlags or [ ]) ++ [ \"--ghc-option=-optl=-static\" \"--extra-lib-dirs=${final.gmp6.override { withStatic = true; }}/lib\" \"--extra-lib-dirs=${final.libffi.overrideAttrs (old: { dontDisableStatic = true; })}/lib\" ]; })\n\nIndeed, if we have a look at the paths that are passed in now, we see that\nthere are .a files in there:\n\n    \n    \n    $ tree /nix/store/iqr454kg405rvhlfqji5liqjpdnaw3d8-libffi-3.4.4/lib 44ms /nix/store/iqr454kg405rvhlfqji5liqjpdnaw3d8-libffi-3.4.4/lib \u251c\u2500\u2500 libffi.a \u251c\u2500\u2500 libffi.la \u251c\u2500\u2500 libffi.so -> libffi.so.8.1.2 \u251c\u2500\u2500 libffi.so.8 -> libffi.so.8.1.2 \u2514\u2500\u2500 libffi.so.8.1.2\n\nIf we have another look at the executable, we'll see that it's statically\nlinked:\n\n    \n    \n    ldd ./result/bin/foo-bar not a dynamic executable\n\nYay! Except, that was the happiest path out there. Your real projects will\nprobably be rather more complicated than my little foo-bar example executable.\n\nThe rest of this post describes errors that you might run into, and how you\ncan go about fixing them. If you run into any errors that aren't listed here,\nfeel free to send them to me and I'll add them.\n\n## Common errors\n\n### Zlib\n\nIf you see\n\n    \n    \n    ld: cannot find -lz: No such file or directory\n\nYou may need to pass in the .static version of zlib:\n\n    \n    \n    overrideCabal fooBar (old: { configureFlags = (old.configureFlags or [ ]) ++ [ \"--ghc-option=-optl=-static\" \"--extra-lib-dirs=${final.zlib.static}/lib\" ]; })\n\n### Terminfo\n\nIf you see\n\n    \n    \n    ld: cannot find -ltinfo: No such file or directory\n\nYou may need to pass in the enableStatic = true version of ncurses:\n\n    \n    \n    overrideCabal fooBar (old: { configureFlags = (old.configureFlags or [ ]) ++ [ \"--ghc-option=-optl=-static\" \"--extra-lib-dirs=${final.ncurses.override { enableStatic = true; }}/lib\" ]; })\n\n### Sqlite\n\nIf you see\n\n    \n    \n    ld: cannot find -lsqlite3: No such file or directory\n\nYou may think you need to pass in the dontDisableStatic = true version of\nsqlite using --extra-lib-dirs. However, you'll just see the same error if you\ndo that. What you need to do instead is to override sqlite globally:\n\n    \n    \n    sqlite = prev.sqlite.overrideAttrs (old: { dontDisableStatic = true; })\n\n### Text ICU\n\nIf you see this error:\n\n    \n    \n    ld: cannot find -licuuc: No such file or directory ld: cannot find -licui18n: No such file or directory ld: cannot find -licuuc: No such file or directory ld: cannot find -licudata: No such file or directory\n\nYou'll need a version of icu with static linking enabled:\n\n    \n    \n    let # Until https://github.com/NixOS/nixpkgs/pull/304772 icuWithStatic = final.icu.overrideAttrs (old: { dontDisableStatic = true; configureFlags = (old.configureFlags or \"\") ++ [ \"--enable-static\" ]; outputs = old.outputs ++ [ \"static\" ]; postInstall = '' mkdir -p $static/lib mv -v lib/*.a $static/lib '' + (old.postInstall or \"\"); }); in\n\n... and mention it to cabal:\n\n    \n    \n    overrideCabal fooBar (old: { configureFlags = (old.configureFlags or [ ]) ++ [ \"--ghc-option=-optl=-static\" \"--extra-lib-dirs=${icuWithStatic.static}/lib\" \"--ghc-option=-optl=-licui18n\" \"--ghc-option=-optl=-licuio\" \"--ghc-option=-optl=-licuuc\" \"--ghc-option=-optl=-licudata\" \"--ghc-option=-optl=-ldl\" \"--ghc-option=-optl=-lm\" \"--ghc-option=-optl=-lstdc++\" ]; })\n\nThank you 4e6 for figuring this out years ago!\n\n### Webp\n\nIf you see this error:\n\n    \n    \n    ld: cannot find -lwebp: No such file or directory\n\nYou may need the dontDisableStatic = true version of libwebp.\n\nIf you see this error:\n\n    \n    \n    ld: (.text+0xcf6): undefined reference to `SharpYuvGetConversionMatrix' ld: (.text+0xd41): undefined reference to `SharpYuvConvert'\n\nYou'll also need -lsharpyuv:\n\n    \n    \n    overrideCabal fooBar (old: { configureFlags = (old.configureFlags or [ ]) ++ [ \"--ghc-option=-optl=-static\" \"--extra-lib-dirs=${final.libwebp.overrideAttrs (old: { dontDisableStatic = true; })}/lib\" \"--ghc-option=-optl=-lsharpyuv\" ]; })\n\n### Template Haskell\n\nIf you see this error again, double-check if you are using Template Haskell.\n(Remember, this is the same as the first error we encountered.)\n\n    \n    \n    relocation R_X86_64_32 against hidden symbol `__TMC_END__' can not be used when making a shared object ld: failed to set dynamic section sizes: bad value\n\nIf so, you need to override ghc in the haskellPackages part of your overlay:\n\n    \n    \n    let fixGHC = pkg: pkg.override { enableRelocatedStaticLibs = true; enableShared = false; }; in { ghc = fixGHC super.ghc; buildHaskellPackages = old.buildHaskellPackages.override (oldBuildHaskellPackages: { ghc = fixGHC oldBuildHaskellPackages.ghc; }); }\n\n### Webdriver tests\n\nBuilding big projects like Firefox or Chromium can prove difficult. For this\nreason, I've not figured out how to run webdriver tests in a pkgsMusl context.\nYou may be able to pass in a regular (non-pkgsMusl) version of the browsers\ninstead.\n\n## Conclusion\n\nThere is a very good likelihood that it is entirely possible to statically\nlink your Haskell executable these days. The work that nh2 et al. have done on\nFully static Haskell executables has made this all possible.\n\nLooking for a lead engineer?\n\nHire me\n\nNext 2023; year in review\n\n\u00a9 2024 CS SYD. Tom Sydney Kerckhove | Technical Leader | Speaker | Coach.\n\ncontact\n\n", "frontpage": false}
