{"aid": "40048744", "title": "Five tips on Postgres logical decoding", "url": "https://blog.peerdb.io/five-tips-on-postgres-logical-decoding", "domain": "peerdb.io", "votes": 1, "user": "saisrirampur", "posted_at": "2024-04-16 05:50:02", "comments": 0, "source_title": "Five tips on Postgres logical decoding", "source_text": "Five tips on Postgres logical decoding\n\n# Five tips on Postgres logical decoding\n\nSai Srirampur\n\n\u00b7Dec 13, 2023\n\nLogical decoding is a mechanism that enables users to stream changes on\nPostgres as a sequence of logical operations like INSERTs, UPDATEs, and\nDELETEs. This is useful for applications that need to keep an external data\nstore synchronized with Postgres. For example, replicating data in Postgres to\nData Warehouses for analytics.\n\nIn this blog, I'll walk through 5 interesting logical decoding concepts worth\nknowing about:\n\n  1. Slot Growth - Under the covers, a logical replication slot captures changes in the Postgres Write-Ahead Log (WAL) and streams them in a human-readable format to the client. A common issue posed by logical decoding is unexpected replication slot growth. This could risk filling up storage and causing server crashes. Slot growth mostly happens when the consumer application (a.k.a. client) that reads changes from a replication slot lags or halts. You could monitor slot activity and its growth to detect if the client is lagging or is halted:\n\n    1. Monitoring the state of the slot: The query below indicates if the slot is active or not. If the active column is predominantly showing true, it means that the consumer app is constantly consuming the changes. Else, it means that the app is halted.\n        \n                SELECT slot_name,active FROM pg_replication_slots ;\n\n    2. Monitoring the size of the slot - If the size of the slot is constantly growing, it could indicate that the consumer app is not catching up with the rate of ingestion on Postgres. Below\n        \n                SELECT slot_name, pg_size_pretty(pg_wal_lsn_diff(pg_current_wal_lsn(), confirmed_flush_lsn)) AS replication_lag_bytes FROM pg_replication_slots;\n\nThere could be other reasons incl. long-running transactions, the client\nforgetting to flush the slot periodically, etc. causing replication slot\ngrowth. More on the causes, preventive measures and mitigation steps for\nreplication slot growth in the next blog!\n\n  2. Large transactions can lead to Slot growth and this can be avoided - By default, a large in-progress transaction cannot be consumed until the transaction finishes. This could potentially increase the size of the slot. To resolve this concern, starting from Postgres 14, the START_REPLICATION command enables clients to consume large in-flight transactions (see proto_version). However, it is the responsibility of the client to reliably handle changes from the in-flight transaction.\n\n  3. PUBLICATION to filter logical decoding changes: When reading changes from a logical replication slot, you can use a PUBLICATION as a filter, allowing you to selectively capture the changes you're interested in. This feature acts as a sieve, enabling filtering based on specific tables, schemas, types of changes (like INSERT, UPDATE, or DELETE), and even column values (introduced in Postgres 15). Crucially, this filtering occurs server-side, reducing the volume of data transmitted over the network.\n    \n        /*Create a publication that publishes all changes in two tables*/ CREATE PUBLICATION mypublication FOR TABLE users, departments; /*Create a publication that publishes all changes from active departments*/ CREATE PUBLICATION active_departments FOR TABLE departments WHERE (active IS TRUE); /*Create a publication that only publishes INSERT operations in one table:*/ CREATE PUBLICATION insert_only FOR TABLE mydata WITH (publish = 'insert');\n\n  4. logical_decoding_work_mem - In Postgres 13, a new setting called logical_decoding_work_mem was introduced, controlling how much memory a logical replication connection (wal sender process) can use to decode changes. By default, it's set at 64MB, but if your workload involves large transactions or high concurrency, this might not be sufficient. When that happens, the decoding process might overflow to disk, slowing down logical decoding. Increasing logical_decoding_work_mem, especially if you have available memory, can significantly boost decoding performance. Keep an eye on pg_stat_activity to see if your wal_sender process is struggling with IO wait events, and consider tuning logical_decoding_work_mem. This blog captures a more detailed summary of how this setting works.\n\n  5. Logical decoding via standbys in Postgres 16 - Before Postgres 16, creating logical replication slots on standbys (read-replicas) wasn't possible. However, Postgres 16 brings a significant change\u2014you can now create replication slots on standby! This allows clients to consume changes from the replica rather than the primary server, offering several benefits:\n\n    1. Eases the load on the primary server.\n\n    2. Eliminates the risk of replicating slot growth impacting the primary.\n\n    3. Making logical decoding resilient to failovers.\n\n## Closing statements..\n\nAt PeerDB, we enable you to easily replicate data from Postgres to Data\nWarehouses, Queues and Storage. Behind the scenes, we rely on Postgres'\nlogical decoding to make this happen. To ensure that we provide a fast and\nsimple experience to users, we've been delving into the intricacies of logical\ndecoding and trying to keep up with its evolution. This blog captures a few of\nour learnings. Hope you enjoyed reading the blog!\n\nIf you want to give PeerDB a try, these links should prove useful: :)\n\n  1. Quickstart\n\n  2. PeerDB's Github repo\n\n  3. Join PeerDB's Slack community\n\n  4. PeerDB docs\n\n## Subscribe to our newsletter\n\nRead articles from PeerDB Blog directly inside your inbox. Subscribe to the\nnewsletter, and don't miss out.\n\nPostgreSQLchange data capturedataengineeringOpen Sourcereplication\n\n### Written by\n\n# Sai Srirampur\n\n### Published on\n\n# PeerDB Blog\n\nAt PeerDB, we are building a fast, simple and the most cost effective way to\nstream data from Postgres to Data Warehouses, Queues and Storage engines.\n\nAt PeerDB, we are building a fast, simple and the most cost effective way to\nstream data from Postgres to Data Warehouses, Queues and Storage engines.\n\nShare this\n\n### More articles\n\nSai Srirampur\n\n# PeerDB raises $3.6 million seed funding to revolutionize data movement for\nPostgreSQL\n\nPeerDB offers a fast and cost-effective way to move data from PostgreSQL to\ndata warehouses, such as...\n\nKunal Gupta\n\n# PeerDB is GDPR Compliant\n\nWe are excited to share a significant achievement at PeerDB: we have achieved\nfull compliance with t...\n\nSai Srirampur\n\n# Exploring versions of the Postgres logical replication protocol\n\nIntroduction Logical Replication is one of the many ways a Postgres database\ncan replicate data to o...\n\n\u00a92024 PeerDB Blog\n\nArchive\u00b7Privacy policy\u00b7Terms\n\nWrite on Hashnode\n\nPowered by Hashnode - Home for tech writers and readers\n\n", "frontpage": false}
