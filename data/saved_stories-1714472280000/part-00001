{"aid": "40207199", "title": "Reverse Engineering BeReal API", "url": "http://rahulvaidun.com/blog/reverse-engineering/2024/03/17/reverse-engineering-bereal.html", "domain": "rahulvaidun.com", "votes": 1, "user": "rvaidun", "posted_at": "2024-04-30 04:17:12", "comments": 0, "source_title": "Reverse engineering BeReal", "source_text": "Reverse engineering BeReal | Rahul\u2019s Blog\n\nRahul's Blog\n\n# Reverse engineering BeReal\n\nMar 17, 2024\n\nReverse engineering has always intrigued me, offering the opportunity to\nunlock the potential of apps with private APIs that companies prefer to keep\nhidden. In this article, I\u2019ll share my journey of reverse engineering the\npopular social media app BeReal.\n\n# What is BeReal\n\nBeReal is a social media app that has recently gained popularity. Where the\nwhole idea is at a random time every day, all users in a region will get a\nnotification when it is time to \u201cBe Real.\u201d When you receive the notification,\nyou post a photo of whatever you are doing at the moment. The catch is that\nyou can only see your friends\u2019 posts after posting your BeReal for the day and\nwill only see blurred images before. I wanted to reverse-engineer the app to\nsee if viewing your friends\u2019 posts from a web browser instead of the app is\npossible.\n\n# Network Requests\n\nThe first thing I like to do when reverse engineering a new application is\ninspect the network requests and see what you can find. The requests show what\ndata an app requests from servers, which is crucial in reverse engineering.\nFinding network requests is easy for web applications as all modern browsers\nallow you to see network requests a site is making. Google provides a guide\nfor how to inspect networking activity on Chrome.\n\nUnfortunately, BeReal does not have a web client; the official clients are\nonly available on iOS and Android, so inspecting network requests will be\ntricky. We will have to use a man-in-the-middle proxy. This type of proxy sits\nbetween your device and router and will listen to requests your clients make\nand responses the server gives back. Mitmproxy provides a comprehensive guide\non how it works and installation instructions over at the mitmproxy docs\n\nIn early versions of the BeReal app, just a mitmproxy would be enough to start\ninspecting requests; however, newer versions of the app use SSL pinning to\nstop MITM attacks. SSL pinning is when the app hard-codes the SSL certificate\nof a server into the client application so even if mitmproxy\u2019s certificate is\ntrusted systemwide the app will still drop the requests. To disable SSL\npinning on iOS you will need a jailbroken iPhone and Frida. I am using ssl-\nkill-switch3, a jailbreak tweak to disable SSL pinning system-wide.\n\nAfter the proxy is set up and SSL pinning disabled we can finally start\ninspecting network requests the BeReal app is making. I started up the BeReal\napp and found the following requests pop up on the proxy.\n\n# Login and Authentication\n\nTo start using the API we need to figure out how authentication works to\nauthorize our requests to the BeReal endpoints. BeReal\u2019s authentication only\nuses phone numbers with 2FA via SMS to log in users. Unfortunately in the\nlatest version of the BeReal build BeReal is using non-standard SSL pinning\ntechniques pre-login which I was unable to disable. I attempted to disable SSL\npinning with SSL-kill-switch3 and Frida but both did not work and the client\nwould not send the login requests to the server and hang with an infinite\nloading indicator. However, at the time of writing, SSLkillswitch still works\nto inspect network requests after the login flow to inspect other endpoints\nBeReal uses.\n\nUsing mitmproxy on older builds of BeReal and other Github repositories that\nreverse engineer BeReal I was able to piece together how BeReal authentication\nworks and implemented authentication in my repository befake. The paragraphs\nin this section explain how BeFake is doing authentication as I am unable to\nget past the SSL pinning in the official app. If anyone reading this knows how\nto get past SSL pinning before login please contact me I would greatly\nappreciate it. The code for the login section can be found in pages/Login.vue\non the befake repository.\n\nThe first step in the login flow is the client initiates a request to a\nverifyClient endpoint. The client makes a POST request to\nhttps://www.googleapis.com/identitytoolkit/v3/relyingparty/verifyClient?key=AIzaSyDwjfEeparokD7sXPVQli9NsTuhT6fJ6iA\nwith the following body.\n\n    \n    \n    { \"appToken\":\"54F80A258C35A916B38A3AD83CA5DDD48A44BFE2461F90831E0F97EBA4BB2EC7\" }\n\nappToken seems to be a static value as every time the client makes this\nrequest the same app token is sent. The server responds with a receipt.\n\nThe client uses this receipt as a unique token to send to the endpoint that\nsends the verification SMS. The client makes another POST request to\nhttps://www.googleapis.com/identitytoolkit/v3/relyingparty/sendVerificationCode?key=AIzaSyDwjfEeparokD7sXPVQli9NsTuhT6fJ6iA\nwith a JSON body in the format of\n\n    \n    \n    { \"iosReceipt\": \"Receipt from the verify client endpoint\", \"phoneNumber\": \"Your phone number with country code.\" }\n\nAfter sending this request the BeReal servers will send an SMS message with\nthe verification code to the phone number provided. The sendVerificationCode\nendpoint responds to the client with a unique ID, sessionInfo. To verify the\nSMS token the client makes another post request to\nhttps://www.googleapis.com/identitytoolkit/v3/relyingparty/verifyCustomToken?key=AIzaSyDwjfEeparokD7sXPVQli9NsTuhT6fJ6iA\nwith a JSON body in the format of\n\n    \n    \n    { \"sessionInfo\": \"id from the sendVerificationCode endpoint\", \"code\": \"SMS code sent to the phone number\", \"operation\": \"SIGN_UP_OR_IN\" }\n\nFrom my testing, the operation is always hardcoded to SIGN_UP_OR_IN. This\nendpoint sends back a refreshToken. The refreshToken is not enough to\nauthenticate with the API we will need full JWT tokens (Read more on JWT\ntokens) The client makes yet another request with the refreshToken to get JWT\ntokens. The client makes a POST request to\nhttps://securetoken.googleapis.com/v1/token?key=AIzaSyDwjfEeparokD7sXPVQli9NsTuhT6fJ6iA\nwith the following JSON body.\n\n    \n    \n    { \"grant_type\": \"refresh_token\", \"refresh_token\": \"Refresh token received from the verifyCustomToken endpoint\", }\n\ngrant_type is hard coded to refresh_token. If all goes well this server will\nsend back the following data refresh_token, id_token, and a user_id The server\nmakes one final POST request to\nhttps://auth.bereal.team/token?grant_type=firebase with the following JSON\nbody.\n\n    \n    \n    { \"grant_type\": \"firebase\", \"client_id\": \"android\", \"client_secret\": \"F5A71DA-32C7-425C-A3E3-375B4DACA406\", \"token\": \"id token received from the previous request\" }\n\nBeFake hardcodes the grant_type, client_id, and client_secret to the values\nshown above. The token is grabbed from the previous request to the /token\nGoogle API endpoint. I am unsure how the official client generates\nclient_secret and client_id This server responds with an access_token,\nrefresh_token and expires_in. The expires_in is just the number of seconds\nuntil this set of tokens expires. When the token does expire the previous two\nrequests\n(https://securetoken.googleapis.com/v1/token?key=AIzaSyDwjfEeparokD7sXPVQli9NsTuhT6fJ6iA\nand https://auth.bereal.team/token?grant_type=firebase) need to be run again\nto get a new set of tokens. We can use access_token as the JWT token to\nauthenticate with the BeReal API.\n\n# Endpoints\n\nNow that we\u2019ve got past the login flow, I can use mitmproxy and show the\nrequests from the official client. After inspecting the requests the client is\nmaking I found one that looks like it has something to do with my friends\u2019\nposts, https://mobile.bereal.com/api/feeds/friends-v1.\n\nHowever, for some reason, the server is giving my client a 301 Moved\nPermanently error and there is no content in the response.\n\nI need to inspect this further so I copy as cURL. In Mitmproxy you can copy\nthe current network request with the :export.clip curl @focus command. cURL is\nnot very useful and I\u2019d like to make a Python script that just makes a call to\nthis endpoint so I paste my clipboard into curlconverter to quickly get a\nPython script. (Note: I have changed the authorization, bereal-device-id, and\nbereal-user-id)\n\nI modify the script a little bit so I\u2019m able to see the response.\n\n    \n    \n    import requests headers = { 'bereal-device-language': 'en', 'bereal-app-version': '1.21.5', 'bereal-signature': 'MToxNzEwNTUxODU1OpHVPe0+bt7AyVyvN5FDHmZOc8DLfkm9mXuQ+ZD/lcVl', 'authorization': 'Bearer access_token', 'accept': '*/*', 'bereal-platform': 'iOS', 'bereal-os-version': '15.7.5', 'accept-language': 'en-US;q=1.0', 'if-none-match': 'W/\"1147-2501891797\"', 'bereal-device-id': 'ABCDEFGHIJKLMNOPQRSTUVWXYYZ', 'bereal-app-language': 'en-US', 'bereal-user-id': 'USER_ID12', 'user-agent': 'BeReal/1.21.5 (AlexisBarreyat.BeReal; build:14549; iOS 15.7.5)', 'bereal-app-version-code': '14549', 'bereal-timezone': 'America/Los_Angeles', } response = requests.get('https://mobile.bereal.com/api/feeds/friends-v1', headers=headers) print(response.status_code) print(response.text)\n\nWhen testing, I see similar behavior as the official client and receive a 304.\nI started messing around with the headers and found if you don\u2019t include the\nif-none-match header, the server will respond with 200 and sends back all of\nyour friends\u2019 posts for the day. I am assuming the if-none-match is a way for\nthe client to tell the server it has already downloaded some photos so only\nsend the response if there are more posts the client has not yet downloaded. I\nalso noted the fields bereal-signature, authorization, bereal-device-id, and\nbereal-timezone are required, and failure to provide proper value in any of\nthese fields results in a 401.\n\nLet\u2019s start with the most obvious field authorization, the same token we got\nfrom the login step. The client includes this header so the server can\nauthenticate/identify which user is making the request. bereal-device-id seems\nto just be a UUID generated randomly that uniquely represents my device. It is\nunclear why bereal-timezone is being sent. The signature seems to be a set of\nrandom letters. I had no idea what bereal-signature could have been so I used\na little Chat GPT magic and figured out it was a Base 64 encoded string. I\ndecoded the string and found the following.\n\n    \n    \n    \u279c ~ echo MToxNzEwNTUxODU1OpHVPe0+bt7AyVyvN5FDHmZOc8DLfkm9mXuQ+ZD/lcVl | base64 --decode 1:1710551855:\ufffd\ufffd=\ufffd>n\ufffd\ufffd\ufffd\\\ufffd7\ufffdCfNs\ufffd\ufffd~I\ufffd\ufffd{\ufffd\ufffd\ufffd\ufffd\ufffde% \u279c ~\n\nIt looks like the signatures are in the format of\n1:{random_numbers}:{random_bits}. I tested out a couple more signatures and\nfound the same pattern after decoding. Each time the client makes a request\nusing the API a unique bereal-signature is generated so I could get as many\nsignatures as I needed. I was also pretty quickly able to realize the\nrandom_numbers was the current time as a UNIX timestamp. I needed to further\ndecode the random_bits so I used hexdump.\n\n    \n    \n    \u279c ~ echo MToxNzEwNTUxODU1OpHVPe0+bt7AyVyvN5FDHmZOc8DLfkm9mXuQ+ZD/lcVl | base64 --decode | hexdump -C 00000000 31 3a 31 37 31 30 35 35 31 38 35 35 3a 91 d5 3d |1:1710551855:..=| 00000010 ed 3e 6e de c0 c9 5c af 37 91 43 1e 66 4e 73 c0 |.>n...\\.7.C.fNs.| 00000020 cb 7e 49 bd 99 7b 90 f9 90 ff 95 c5 65 |.~I..{......e| 0000002d \u279c ~\n\nIn the hexdump, I noticed the amount of bits in the random_bits was 256 bits\nwhich led me to suspect some type of SHA256 hash (Read more on hashing\nalgorithms). Given the required headers I guessed the hash was most likely\nsome combination of the current UNIX timestamp, bereal-device-id, bereal-\ntimezone and some secret key to make the hashes difficult to brute force. The\npseudocode to generate a hash would be:\n\n    \n    \n    def generate_hash(timezone, device_id , current_time, secret_key): message = timezone + device_id + current_time return SHA256HMAC(message, secret_key)\n\nNetwork requests would not be enough to inspect the functions in the app.\n\n# Frida\n\nAfter a little bit of searching, I came across a tool called Frida that would\nhelp me inspect low-level functions. Frida is also available to download as a\npackage on jailbroken iOS devices for powerful dynamic analysis on iOS apps.\nThis was my first time using Frida so I had no idea where to start. After\nreading the docs for a few hours I came across the example usages for frida-\ntrace and one usage particularly caught my eye.\n\n    \n    \n    # Launch SnapChat on your iPhone and trace crypto API calls $ frida-trace \\ -U \\ -f com.toyopagroup.picaboo \\ -I \"libcommonCrypto*\"\n\nI wanted to trace the crypto API calls for the BeReal app. To find the package\nname for BeReal I used the following command\n\n    \n    \n    \u279c ~ frida-ps -Ua PID Name Identifier ---- ---------------- --------------------------------------- 308 AltStore com.5WVHLY9ZK7.com.rileytestut.AltStore 596 AppStore com.apple.AppStore 9351 BeReal AlexisBarreyat.BeReal 282 Maps com.apple.Maps 396 MobileSMS com.apple.MobileSMS 305 MobileSafari com.apple.mobilesafari 242 Search com.apple.Spotlight 8995 Settings com.apple.Preferences 597 Snapchat com.toyopagroup.picaboo 306 TikTok com.zhiliaoapp.musically 309 TrollStore com.opa334.TrollStore 307 Twitter com.atebits.Tweetie2 \u279c ~\n\nI ran the same trace command with the BeReal app and saw the following happen.\n\nLet\u2019s understand what\u2019s happening here. First frida-trace auto generates a\nbunch of handlers for all the functions in the libcommonCrypto library in the\n__handlers__ directory. Opening the directory shows the following With these\nhooks, we can know when the functions get called and other important\ninformation such as the state of the app and the parameters passed into the\nfunction. Frida-trace only generates the handlers if the handlers directory is\nnot found in the working directory. On subsequent runs, we can instantly see\nthe calls being made. In the video it took too long for Frida to generate all\nthe handlers and the app crashed so I ran the command again and was finally\nable to see all calls made in the crypto library. There are 1000s of calls to\nthe crypto library happening but after analyzing the function calls for a few\nhours I find 3 calls that look particularly interesting.\n\n    \n    \n    1700 ms CCHmacInit(ctx=0x16deb2ae0, algorithm=0x2, key=0x2816b1fa0, keyLength=0x20) 1700 ms CCHmacUpdate(ctx=0x16deb2ae0, data=0x282d6efa0, dataLength=0x58) 1700 ms CCHmacFinal(ctx=0x16deb2ae0, macOut=0x2816b2b60)\n\nThese calls happen whenever the client makes a request to the friends-v1\nendpoint and happen to be the only ones with arguments passed to the\nfunctions. I need to find out more about the functions and after a Google\nsearch, I find the header file for the CCHmac functions. The variable ctx\nseems to just be a memory pointer that represents an HMAC context or object\nthat is being worked on. Notice how all 3 functions have the same ctx value.\nFor those of you familiar with C programming this is similar to when you\ncreate ADT (read more on ADT) and have functions specific to the ADT. The\nalgorithm parameter is just an enum used to represent what algorithm is being\nused to hash. A value of 2 indicates an HMAC with a SHA256 digest. The key\nargument is the memory location of the secret key being used to hash and\nobviously, keyLength is just the length of the key. The data parameter is a\npointer to the data that should be hashed and dataLength is the length of the\ndata. The length is being passed so the function how many bytes to read from\nthe pointers. macOut is a pointer to where the 256-bit hash should be stored.\nJust knowing the memory locations is not very helpful to us as we need to be\nable to see the actual values at those memory addresses. Frida allows us to do\nthis by modifying the handlers. I update the onEnter functions CCHmacInit.js\nand CCHmacUpdate.js files in the __handlers__ folder to the following\n\n    \n    \n    // __handlers__/libcommonCrypto.dylib/CCHmacInit.js onEnter(log, args, state) { log(`CCHmacInit(ctx=${args[0]}, algorithm=${args[1]}, key=${args[2]}, keyLength=${args[3]})`); const dataArrayBuffer = Memory.readByteArray(args[2], args[3].toInt32()); const uint8Array = new Uint8Array(dataArrayBuffer); let utf8String = ''; for (let i = 0; i < uint8Array.length; i++) { utf8String += String.fromCharCode(uint8Array[i]); } log(`data: ${utf8String}`); } // __handlers__/libcommonCrypto.dylib/CCHmacUpdate.js onEnter(log, args, state) { log(`CCHmacUpdate(ctx=${args[0]}, data=${args[1]}, dataLength=${args[2]})`); const keyArrayBuffer = Memory.readByteArray(args[1], args[2].toInt32()); const uint8Array = new Uint8Array(keyArrayBuffer); let utf8String = ''; for (let i = 0; i < uint8Array.length; i++) { utf8String += String.fromCharCode(uint8Array[i]); } log(`key: ${utf8String}`); }\n\nAfter modifying the frida-trace command to only trace the CCHmac calls in the\nBeReal app with frida-trace -U -f AlexisBarreyat.BeReal -i \"CCHmac*\" I see the\nfollowing.\n\n    \n    \n    4139 ms CCHmacInit(ctx=0x16e51eae0, algorithm=0x2, key=0x2834051a0, keyLength=0x20) 4139 ms key: $ecretKey123456 4139 ms CCHmacUpdate(ctx=0x16e51eae0, data=0x280fcd420, dataLength=0x58) 4139 ms data: QUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVlaQW1lcmljYS9Mb3NfQW5nZWxlczE3MTA2MzE1NDk= 4139 ms CCHmacFinal(ctx=0x16e51eae0, macOut=0x283407960)\n\nI have changed the output to protect my device ID and BeReal\u2019s secret key. I\nrecognize the data to be a Base64 encoded string and after decoding I see the\nfollowing\n\n    \n    \n    \u279c ~ echo QUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVlaQW1lcmljYS9Mb3NfQW5nZWxlczE3MTA2MzE1NDk= | base64 --decode ABCDEFGHIJKLMNOPQRSTUVWXYYZAmerica/Los_Angeles1710631549% \u279c ~\n\nThe base64encoding is just the device_id, timezone, and current unix timestamp\nconcatenated. It also makes sense why the bereal-timestamp header needs to be\nsent now, so the server can verify the signature is correct. There is probably\nsome logic in the BeReal servers that generates a hash with the UNIX timestamp\nprovided in the signature, device_id, and timezone and verifies that the\nclient has provided the same hash. We finally know both the message and key\nbeing used for the SHA256 HMAC! For example, let\u2019s say a client passes these\nheaders\n\n    \n    \n    { \"bereal-signature\": \"MToxNzA3NDgwMjI4OhBj2ijVK5qyabYJuKF4QThGuIJmIzabd/dIYQYtzLZQ\", \"bereal-timezone\": \"Europe/Paris\", \"bereal-device-id\": \"937v3jb942b0h6u9\" }\n\nAfter decoding the signature with hexdump we get\n\n    \n    \n    \u279c ~ echo MToxNzA3NDgwMjI4OhBj2ijVK5qyabYJuKF4QThGuIJmIzabd/dIYQYtzLZQ | base64 --decode | hexdump -C 00000000 31 3a 31 37 30 37 34 38 30 32 32 38 3a 10 63 da |1:1707480228:.c.| 00000010 28 d5 2b 9a b2 69 b6 09 b8 a1 78 41 38 46 b8 82 |(.+..i....xA8F..| 00000020 66 23 36 9b 77 f7 48 61 06 2d cc b6 50 |f#6.w.Ha.-..P| 0000002d \u279c ~\n\nWe are trying to find a SHA256 hash that starts with 1063da. Since we know\nboth the message and secret key we can generate a SHA 256 HMAC with the\nfollowing command\n\n    \n    \n    # First find the base64 encoding and then get the HMAC \u279c ~ echo -n \"937v3jb942b0h6u9Europe/Paris1707480228\" | base64 OTM3djNqYjk0MmIwaDZ1OUV1cm9wZS9QYXJpczE3MDc0ODAyMjg= \u279c ~ echo -n \"OTM3djNqYjk0MmIwaDZ1OUV1cm9wZS9QYXJpczE3MDc0ODAyMjg=\" | openssl dgst -sha256 -hmac \"\\$ecretKey123456\" SHA2-256(stdin)= 1063da28d52b9ab269b609b8a178413846b8826623369b77f74861062dccb650 \u279c ~\n\nNotice how the hash is identical to the hash in the signature. With all this\ninformation I wrote a simple Python script that allows me to generate\nsignatures quickly.\n\n    \n    \n    import base64 import hashlib import hmac key = \"$ecretKey123456\" device_id = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\" timezone = \"America/Los_Angeles\" unixts = \"1707480228\" data = device_id + timezone + unixts data_bytes = data.encode(\"utf-8\") base64_bytes = base64.b64encode(data_bytes) base64_string = base64_bytes.decode(\"utf-8\") signature = hmac.new( bytes(key, 'utf-8'), msg=bytes(base64_string, 'utf-8'), digestmod=hashlib.sha256 ) s2 = b\"1:\" + unixts.encode(\"utf-8\") + b\":\" + signature.digest() s3 = base64.b64encode(s2) print(\"bereal-timezone:\", timezone) print(\"bereal-device-id:\", device_id) print(\"bereal-signature:\", s3.decode(\"utf-8\"))\n\nWe can use the values provided by this script as headers to the friends-v1\nendpoint without receiving 401s. This allows us to generate fake devices for\nBeReal\u2019s API. We can also generate new unique signatures on the fly without\nhaving to rely on the client to get a new signature.\n\n# What\u2019s Next\n\nI don\u2019t plan on developing this project further as I was able to complete my\ngoal of bringing BeReal to the web and learning more about reverse\nengineering.\n\n## Rahul's Blog\n\n  * Rahul's Blog\n  * rahul.vaidun@gmail.com\n\n  * rvaidun\n\nHi, I'm Rahul. I'm a software engineer and this is my blog. I write about\nreverse engineering, software, technology, and other things that interest me.\n\n", "frontpage": false}
