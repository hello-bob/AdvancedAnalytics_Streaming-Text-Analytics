{"aid": "40179015", "title": "Planes in 3D Space", "url": "https://alexharri.com/blog/planes", "domain": "alexharri.com", "votes": 8, "user": "alexharri", "posted_at": "2024-04-27 11:00:57", "comments": 0, "source_title": "Planes in 3D space", "source_text": "Planes in 3D space\n\nAlex Harri\n\nHomeBlog\n\n# Planes in 3D space\n\nApril 27, 2024\n\nA plane in 3D space can be thought of as a flat surface that stretches\ninfinitely far, splitting space into two halves.\n\nPlanes have loads of uses in applications that deal with 3D geometry. I've\nmostly been working with them in the context of an architectural modeler,\nwhere geometry is defined in terms of planes and their intersections.\n\nLearning about planes felt abstract and non-intuitive to me. \u201cSure, that's a\nplane equation, but what do I do with it? What does a plane look like?\u201d It\ntook some time for me to build an intuition for how to reason about and work\nwith them.\n\nIn writing this, I want to provide you with an introduction that focuses on\nbuilding a practical, intuitive understanding of planes. I hope to achieve\nthis through the use of visual (and interactive!) explanations which will\naccompany us as we work through progressively more complex problems.\n\nWith that out of the way, let's get to it!\n\n## Describing planes\n\nThere are many ways to describe planes, such as through\n\n  1. a point in 3D space and a normal,\n  2. three points in 3D space, forming a triangle, or\n  3. a normal and a distance from an origin.\n\nThroughout this post, the term normal will refer to a normalized direction\nvector (unit vector) whose magnitude (length) is equal to 1, typically denoted\nby where .\n\nStarting with the point-and-normal case, here's an example of a plane\ndescribed by a point in 3D space and a normal :\n\nLoading 3D scene\n\nThe normal describes the plane's orientation, where the surface of the plane\nis perpendicular to , while the point describes a point on the plane.\n\nWe described this plane in terms of a single point , but keep in mind that\nthis plane\u2014let's call it \u2014contains infinitely many points.\n\nLoading 3D scene\n\nIf were described by one of those other points contained by , we would be\ndescribing the exact same plane. This is a result of the infinite nature of\nplanes.\n\nThis way of describing planes\u2014in terms of a point and a normal\u2014is the point-\nnormal form of planes.\n\nWe can also describe a plane using three points in 3D space , , forming a\ntriangle:\n\nLoading 3D scene\n\nThe triangle forms an implicit plane, but for us to be able to do anything\nuseful with the plane we'll need to calculate its normal . Once we've\ncalculated the plane's normal, we can use that normal along with one of the\ntriangle's three points to describe the plane in point-normal form.\n\nLoading 3D scene\n\nAs mentioned earlier, the normal describing a plane is a unit vector ()\nperpendicular to the plane.\n\nWe can use and as two edge vectors that are parallel to the plane's surface.\n\nLoading 3D scene\n\nBy virtue of being parallel to the plane's surface, the vectors and are\nperpendicular to the plane's normal. This is where the cross product becomes\nuseful to us.\n\nThe cross product takes in two vectors and and returns a vector that is\nperpendicular to both of them.\n\nFor example, given the vectors and , their cross product is the vector , which\nwe'll label :\n\nLoading 3D scene\n\nThis explanation is simple on purpose. We'll get into more detail about the\ncross product later on.\n\nBecause the edge vectors of the triangle, and , are both parallel to the\ntriangle's surface, their cross product will be perpendicular to the\ntriangle's surface. Let's name the cross product of our two edge vectors :\n\nLoading 3D scene\n\nhas been scaled down for illustrative purposes\n\npoints in the right direction, but it's not a normal. For to be a normal, its\nmagnitude needs to equal 1. We can normalize by dividing it by its magnitude,\nthe result of which we'll assign to :\n\nThis gives us a normal where :\n\nLoading 3D scene\n\nHaving found the triangle's normal we can use it and any of the points , , to\ndescribe the plane containing the three points in point-normal form.\n\nLoading 3D scene\n\nIt doesn't matter which of , , we use as the point in the point-normal form;\nwe always get the same plane.\n\n### Constant-normal form\n\nThere's one more way to describe a plane that we'll look at, which is through\na normal and a distance .\n\nLoading 3D scene\n\nThis is the constant-normal form of planes. It makes lots of calculations\nusing planes much simpler.\n\nIn the constant-normal form, the distance denotes how close the plane gets to\nthe origin. Thought of another way: multiplying the normal by yields the point\non the plane that's closest to the origin.\n\nThis is a simplification. More formally, given a point on a plane whose normal\nis , we can describe all points on the plane in two forms: the point-normal\nform , and the constant-normal form where . See further reading.\n\nIn getting a feel for the difference between the point-normal and constant-\nnormal forms, take this example which describes the same plane in both forms:\n\nLoading 3D scene\n\nThe green arrow represents from the constant-normal form, while the blue point\nand arrow represent the point and normal from the point-normal form.\n\nTranslating from the point-normal to the constant-normal form is very easy:\nthe distance is the dot product of and .\n\nIf you're not familiar with the dot product, don't worry. We'll cover it later\non.\n\nThe notation for and might seem to indicate that they're of different types,\nbut they're both vectors. I'm differentiating between points in space (e.g.\nand ) and direction vectors (e.g. and ) by using the arrow notation only for\ndirection vectors.\n\nThe normal stays the same across both forms.\n\n## Distance from plane\n\nGiven an arbitrary point and a plane in constant-normal form, we may want to\nask how far away the point is from the plane. In other words, what is the\nminimum distance needs to travel to lie on the plane?\n\nLoading 3D scene\n\nWe can frame this differently if we construct a plane containing that is\nparallel to , which we can do in point-normal form using as the point and 's\nnormal as the normal:\n\nLoading 3D scene\n\nWith two parallel planes, we can frame the problem as finding the distance\nbetween the two planes. This becomes trivial using their constant-normal form\nsince it allows us to take the difference between their distance components\nand .\n\nSo let's find 's distance using the equation we learned about:\n\nLoading 3D scene\n\nWith two distances and from the planes and the solution simply becomes:\n\nLoading 3D scene\n\nSo, to simplify, given a plane having a normal and distance , we can calculate\na point 's distance from like so:\n\nThe distance may be positive or negative depending on which side of the plane\nthe point is on.\n\n### Projecting a point onto a plane\n\nA case where calculating a point's distance from a plane becomes useful is,\nfor example, if you want to project a point onto a plane.\n\nGiven a point which we want to project onto plane whose normal is and distance\nis , we can do that fairly easily. First, let's define as the point's distance\nfrom the plane:\n\nMultiplying the plane's normal by gives us a vector which when added to\nprojects it onto the plane. Let's call the projected point :\n\nLoading 3D scene\n\nThe projection occurs along the plane's normal, which is sometimes useful.\nHowever, it is much more useful to be able to project a point onto a plane\nalong an arbitrary direction instead. Doing that boils down finding the point\nof intersection of a line and a plane.\n\n## Line-plane intersection\n\nWe can describe lines in 3D space using a point and normal . The normal\ndescribes the line's orientation, while the point describes a point which the\nline passes through.\n\nLoading 3D scene\n\nIn this chapter, the line will be composed of the point and normal , while the\nplane\u2014given in constant-normal form\u2014has a normal and a distance .\n\nLoading 3D scene\n\nOur goal will be to find a distance that needs to travel along such that it\nlies on the plane.\n\nWe can figure out the distance that we'd need to travel if and were parallel,\nwhich is what we did when projecting along the plane's normal.\n\nLet's try projecting along using as a scalar like so:\n\nWe'll visualize as a red point:\n\nLoading 3D scene\n\nAs and become parallel, gets us closer and closer to the correct solution.\nHowever, as the angle between and increases, becomes increasingly too small.\n\nHere, the dot product comes in handy. For two vectors and , the dot product is\ndefined as\n\nwhere is the angle between and .\n\nConsider the dot product of and . Since both normals are unit vectors whose\nmagnitudes are 1\n\nwe can remove their magnitudes from the equation,\n\nmaking the dot product of and the cosine of the angle between them.\n\nFor two vectors, the cosine of their angles approaches 1 as the vectors become\nincreasingly parallel, and approaches 0 as they become perpendicular.\n\nSince becomes increasingly too small as and become more perpendicular, we can\nuse as a denominator for . We'll assign this scaled-up version of to :\n\nWith as our scaled-up distance, we find the point of intersection via:\n\nLoading 3D scene\n\nWe can now get rid of , which was defined as , giving us the full equation for\n:\n\nPutting this into code, we get:\n\n    \n    \n    Vector3 LinePlaneIntersection(Line line, Plane plane) {\n    \n    float denom = Vector3.Dot(line.normal, plane.normal);\n    \n    float dist = Vector3.Dot(plane.normal, line.point);\n    \n    float D = (plane.distance - dist) / denom;\n    \n    return line.point + line.normal * D;\n    \n    }\n\nHowever, our code is not completely yet. In the case where the line is\nparallel to the plane's surface, the line and plane do not intersect.\n\nLoading 3D scene\n\nThat happens when and are perpendicular, in which case their dot product is\nzero. So if , the line and plane do not intersect. This gives us an easy test\nwe can add to our code to yield a result of \"no intersection\".\n\nHowever, for many applications we'll want to treat being almost parallel as\nactually being parallel. To do that, we can check whether the dot product is\nsmaller than some very small number\u2014customarily called epsilon\n\n    \n    \n    float denom = Vector3.Dot(line.normal, plane.normal);\n    \n    if (Mathf.Abs(denom) < EPSILON) {\n    \n    return null; // Line is parallel to plane's surface\n    \n    }\n\nSee if you can figure out why Mathf.Abs is used here. We'll cover it later, so\nyou'll see if you're right.\n\nWe'll take a look at how to select the value of epsilon in a later chapter on\ntwo plane intersections.\n\nWith this, our line-plane intersection implementation becomes:\n\n    \n    \n    Vector3 LinePlaneIntersection(Line line, Plane plane) {\n    \n    float denom = Vector3.Dot(line.normal, plane.normal);\n    \n    if (Mathf.Abs(denom) < EPSILON) {\n    \n    return null; // Line is parallel to plane's surface\n    \n    }\n    \n    float dist = Vector3.Dot(plane.normal, line.point);\n    \n    float D = (plane.distance - dist) / denom;\n    \n    return line.point + line.normal * D;\n    \n    }\n\n### Rays and lines\n\nWe've been talking about line-plane intersections, but I've been lying a bit\nby visualizing ray-plane intersections instead for visual clarity.\n\nLoading 3D scene\n\nA ray and a line are very similar; they're both represented through a normal\nand a point .\n\nThe difference is that a ray (colored red) extends in the direction of away\nfrom , while a line (colored green) extends in the other direction as well:\n\nLoading 3D scene\n\nWhat this means for intersections is that a ray will not intersect planes when\ntraveling backward along its normal:\n\nLoading 3D scene\n\nOur implementation for ray-plane intersections will differ from our existing\nline-plane intersection implementation only in that it should yield a result\nof \"no intersection\" when the ray's normal is pointing \"away\" from the plane's\nnormal at an obtuse angle.\n\nSince represents how far to travel along the normal to reach the point of\nintersection, we could yield \"no intersection\" when becomes negative:\n\n    \n    \n    if (D < 0) {\n    \n    return null;\n    \n    }\n\nBut then we'd have to calculate first. That's not necessary since becomes\nnegative as a consequence of the dot product being a negative number when and\nare at an obtuse angle between 90\u00b0 and 180\u00b0.\n\nIf this feels non-obvious, it helps to remember that the dot product encodes\nthe cosine of the angle between its two component vectors, which is why the\ndot product becomes negative for obtuse angles.\n\nKnowing that, we can change our initial \"parallel normals\" test from this:\n\n    \n    \n    Vector3 LinePlaneIntersection(Line line, Plane plane) {\n    \n    float denom = Vector3.Dot(line.normal, plane.normal);\n    \n    if (Mathf.Abs(denom) < EPSILON) {\n    \n    return null; // Line is parallel to plane's surface\n    \n    }\n    \n    // ...\n    \n    }\n\nTo this:\n\n    \n    \n    Vector3 RayPlaneIntersection(Line line, Plane plane) {\n    \n    float denom = Vector3.Dot(line.normal, plane.normal);\n    \n    if (denom < EPSILON) {\n    \n    // Ray is parallel to plane's surface or pointing away from it\n    \n    return null;\n    \n    }\n    \n    // ...\n    \n    }\n\nThe check covers both the \"line parallel to plane\" case and the case where the\ntwo normal vectors are at an obtuse angle.\n\nNote: is the symbol for epsilon.\n\n## Plane-plane intersection\n\nThe intersection of two planes forms an infinite line.\n\nLoading 3D scene\n\nAs a quick refresher: lines in 3D space are represented using a point and\nnormal where normal describes the line's orientation, while the point\ndescribes a point which the line passes through.\n\nLoading 3D scene\n\nLet's take two planes and whose normals are and .\n\nFinding the direction vector of and 's intersection is deceptively simple.\nSince the line intersection of two planes lies on the surface of both planes,\nthe line must be perpendicular to both plane normals, which means that the\ndirection of the intersection is the cross product of the two plane normals.\nWe'll assign it to .\n\nThe magnitude of the cross product is equal to the area of the parallelogram\nformed by the two component vectors. This means that we can't expect the cross\nproduct to be a unit vector, so we'll normalize and assign the normalized\ndirection vector to .\n\nThis gives us the intersection's normal . Let's zoom in and see this close up.\n\nLoading 3D scene\n\nBut this is only half of the puzzle! We'll also need to find a point in space\nto represent the line of intersection (i.e. a point which the line passes\nthrough). We'll take a look at how to do just that, right after we discuss the\nno-intersection case.\n\n### Handling parallel planes\n\nTwo planes whose normals are parallel will never intersect, which is a case\nthat we'll have to handle.\n\nLoading 3D scene\n\nThe cross product of two parallel normals is . So if , the planes do not\nintersect.\n\nAs previously mentioned, for many applications we'll want to treat planes that\nare almost parallel as being parallel. This means that our plane-plane\nintersection procedure should yield a result of \"no intersection\" when the\nmagnitude of is less than some very small number called epsilon.\n\n    \n    \n    Line PlanePlaneIntersection(Plane P1, Plane P2) {\n    \n    Vector3 direction = Vector3.cross(P1.normal, P2.normal);\n    \n    if (direction.magnitude < EPSILON) {\n    \n    return null; // Roughly parallel planes\n    \n    }\n    \n    // ...\n    \n    }\n\nBut what should the value of epsilon be?\n\nGiven two normals and where the angle between and is , we can find a\nreasonable epsilon by charting for different values of :\n\nBoth of the axes are logarithmic.\n\nThe relationship is linear: as the angle between the planes halves, so does\nthe magnitude of the cross product of their normals. yields a magnitude of ,\nand yields half of that.\n\nSo to determine the epsilon, we can ask: how low does the angle in degrees\nneed to become for us to consider two planes parallel? Given an angle , we can\nfind the epsilon via:\n\nIf that angle is 1/256\u00b0, then we get:\n\nWith this you can determine the appropriate epsilon based on how small the\nangle between the planes needs to be for you to consider them parallel. That\nwill depend on your use case.\n\n### Finding a point of intersection\n\nHaving computed the normal and handled parallel planes, we can move on to\nfinding a point along the line of intersection.\n\nSince the line describing a plane-plane intersection is infinite, there are\ninfinitely many points we could choose as .\n\nLoading 3D scene\n\nWe can narrow the problem down by taking the plane parallel to the two plane\nnormals , and observing that it intersects the line at a single point.\n\nLoading 3D scene\n\nSince the point lies on the plane parallel to the two plane normals, we can\nfind it by exclusively traveling along those normals.\n\nThe simplest case is the one where and are perpendicular. In that case, the\nsolution is just . Here's what that looks like visually:\n\nLoading 3D scene\n\nWhen dragging the slider, notice how the tip of the parallelogram gets further\naway from the point of intersection as the planes become more parallel.\n\nWe can also observe that as we get further away from the point of\nintersection, the longer of the two vectors (colored red) pushes us further\naway from the point of intersection than the shorter (blue) vector does. This\nis easier to observe if we draw a line from the origin to the point of\nintersection:\n\nLoading 3D scene\n\nLet's define and as the scaling factors that we apply to and (the result of\nwhich are the red and blue vectors). Right now we're using the distance\ncomponents and of the planes as the scaling factors:\n\nTo solve this asymmetric pushing effect, we need to travel less in the\ndirection of the longer vector as the planes become more parallel. We need\nsome sort of \"pulling factor\" that adjusts the vectors such that their tip\nstays on the line as the planes become parallel.\n\nHere our friend the dot product comes in handy yet again. When the planes are\nperpendicular the dot product of and equals 0, but as the planes become\nincreasingly parallel, it approaches 1. We can use this to gradually increase\nour yet-to-be-defined pulling factor.\n\nLet's give the dot product the name to make this a bit less noisy:\n\nThe perfect pulling factors happen to be the distance components and used as\ncounterweights against each other!\n\nConsider why this might be. When and are perpendicular, their dot product\nequals 0, which results in\n\nwhich we know yields the correct solution.\n\nIn the case where and are parallel, their dot product equals 1, which results\nin:\n\nBecause the absolute values of and are equal, it means that the magnitude of\nthe two vectors\u2014defined as and \u2014is equal:\n\nThis means that the magnitude of our vectors will become more equal as the\nplanes become parallel, which is what we want!\n\nLet's see this in action:\n\nLoading 3D scene\n\nThe vectors stay on the line, but they become increasingly too short as and\nbecome parallel.\n\nYet again, we can use the dot product. Since we want the length of the vectors\nto increase as the planes become parallel, we can divide our scalars and by\nwhere is the dot product of and and is the absolute value of .\n\nThe result of this looks like so:\n\nLoading 3D scene\n\nUsing as the denominator certainly increases the size of the parallelogram,\nbut by too much.\n\nHowever, notice what happens when we visualize the quadrants of the\nparallelogram:\n\nLoading 3D scene\n\nAs the planes become more parallel, the point of intersection approaches the\ncenter of the parallelogram.\n\nIn understanding why that is, consider the effect that our denominator has on\nthe area of the parallelogram. When , both of the vectors forming the\nparallelogram double in length, which has the effect of quadrupling the area\nof the parallelogram.\n\nThis means that when we scale the component vectors of the parallelogram by\n\nit has the effect of scaling the area of the parallelogram by:\n\nTo instead scale the area of the parallelogram by , we need to square in the\ndenominator:\n\nSquaring allows us to remove because the square of a negative number is\npositive.\n\nWith this, our scalars and become\n\nwhich scales the parallelogram such that its tip lies at the point of\nintersection:\n\nLoading 3D scene\n\nPutting all of this into code, we get:\n\n    \n    \n    float dot = Vector3.Dot(P1.normal, P2.normal);\n    \n    float denom = 1 - dot * dot;\n    \n    float k1 = (P1.distance - P2.distance * dot) / denom;\n    \n    float k2 = (P2.distance - P1.distance * dot) / denom;\n    \n    Vector3 point = P1.normal * k1 + P2.normal * k2;\n\nBased on code from Real-Time Collision Detection by Christer Ericson\n\nWhich through some mathematical magic can be optimized down to:\n\n    \n    \n    Vector3 direction = Vector3.cross(P1.normal, P2.normal);\n    \n    float denom = Vector3.Dot(direction, direction);\n    \n    Vector3 a = P1.distance * P2.normal;\n    \n    Vector3 b = P2.distance * P1.normal;\n    \n    Vector3 point = Vector3.Cross(a - b, direction) / denom;\n\nHow this optimization works can be found in chapter 5.4.4 of Real-Time\nCollision Detection by Christer Ericson.\n\nThis completes our plane-plane intersection implementation:\n\n    \n    \n    Line PlanePlaneIntersection(Plane P1, Plane P2) {\n    \n    Vector3 direction = Vector3.cross(P1.normal, P2.normal);\n    \n    if (direction.magnitude < EPSILON) {\n    \n    return null; // Roughly parallel planes\n    \n    }\n    \n    float denom = Vector3.Dot(direction, direction);\n    \n    Vector3 a = P1.distance * P2.normal;\n    \n    Vector3 b = P2.distance * P1.normal;\n    \n    Vector3 point = Vector3.Cross(a - b, direction) / denom;\n    \n    Vector3 normal = direction.normalized;\n    \n    return new Line(point, normal);\n    \n    }\n\nBy the way, an interesting property of only traveling along the plane normals\nis that it yields the point on the line of intersection that is closest to the\norigin. Cool stuff!\n\n## Three plane intersection\n\nGiven three planes , , , there are five possible configurations in which they\nintersect or don't intersect:\n\n  1. All three planes are parallel, with none of them intersecting each other.\n  2. Two of the planes are parallel, and the third plane intersects the other two.\n  3. All three planes intersect along a single line.\n  4. The three planes intersect each other in pairs, forming three parallel lines of intersection.\n  5. All three planes intersect each other at a single point.\n\nLoading 3D scene\n\nWhen finding the point of intersection, we'll first need to determine whether\nall three planes intersect at a single point\u2014which for configurations 1\nthrough 4, they don't.\n\nGiven , , as the plane normals for , , , we can determine whether the planes\nintersect at a single point with the formula:\n\nWhen I first saw this, I found it hard to believe this would work for all\ncases. Still, it does! Let's take a deep dive to better understand what's\nhappening.\n\n### Two or more planes are parallel\n\nWe'll start with the configurations where two or more planes are parallel:\n\nLoading 3D scene\n\nIf and are parallel then is a vector whose magnitude is zero.\n\nAnd since the dot product is a multiple of the magnitudes of its component\nvectors:\n\nthe final result is zero whenever and are parallel.\n\nThis takes care of the \"all-planes-parallel\" configuration, and the\nconfiguration where and are parallel\n\nLoading 3D scene\n\nWith that, let's consider the case where is parallel to either or but and are\nnot parallel to each other.\n\nLet's take the specific case where is parallel to but is parallel to neither.\n\nLoading 3D scene\n\nHere the cross product is a vector (colored red) that's perpendicular to both\nand .\n\nLoading 3D scene\n\nSince is parallel to , that means that is also perpendicular to . As we've\nlearned, the dot product of two perpendicular vectors is zero, meaning that:\n\nThis also holds in the case where is parallel to instead of .\n\n### Parallel lines of intersection\n\nWe've demonstrated that two of the three normals being parallel results in .\nBut what about the configurations where the three planes intersect along\nparallel lines? Those configurations have no parallel normals.\n\nLoading 3D scene\n\nAs we learned when looking at plane-plane intersections, the cross product of\ntwo plane normals gives us the direction vector of the planes' line of\nintersection.\n\nLoading 3D scene\n\nWhen all of the lines of intersection are parallel, all of the plane normals\ndefining those lines are perpendicular to them.\n\nYet again, because the dot product of perpendicular vectors is 0 we can\nconclude that for these configurations as well.\n\nWe can now begin our implementation. As usual, we'll use an epsilon to handle\nthe \"roughly parallel\" case:\n\n    \n    \n    Vector3 ThreePlaneIntersection(Plane P1, Plane P2, Plane P3) {\n    \n    Vector3 cross = Vector3.Cross(P2.normal, P3.normal);\n    \n    float dot = Vector3.Dot(P1.normal, cross);\n    \n    if (Mathf.Abs(dot) < EPSILON) {\n    \n    return null; // Planes do not intersect at a single point\n    \n    }\n    \n    // ...\n    \n    }\n\n## Computing the point intersection\n\nWe want to find the point at which our three planes , , intersect:\n\nLoading 3D scene\n\nSome of what we learned about two-plane intersections will come into play\nhere. Let's start by taking the line of intersection for and and varying the\nposition of . You'll notice that the point of intersection is the point at\nwhich intersects the line.\n\nLoading 3D scene\n\nWhen 's distance from the origin is 0, the vector pointing from the origin to\nthe point of intersection is parallel to (and perpendicular to 's normal).\n\nLoading 3D scene\n\nThis vector\u2014let's call it \u2014will play a large role in computing the point of\nintersection.\n\nWe can find through the cross product of two other vectors , . The first of\nthose, , is just 's normal.\n\nThe latter vector can be found via the equation\n\nwhere and are the distances in the constant-normal form of planes and .\n\nWith and defined, we assign their cross product to :\n\nLet's see what it looks like:\n\nLoading 3D scene\n\nHmm, not quite long enough. certainly points in the right direction, but to\nmake 's tip lie on the line of intersection, we need to compute some scaling\nfactor for .\n\nAs it turns out, we've already computed this scaling factor:\n\nThe product of \u2014let's call that \u2014can be thought to represent how parallel 's\nnormal is to the line intersection of and .\n\napproaches as 's normal becomes parallel to the line of intersection , and\napproaches 0 as they become perpendicular.\n\nWe want the 's magnitude to increase as decreases, so we'll make the scaling\nfactor for .\n\nLoading 3D scene\n\nFully expanded, the equation for becomes:\n\nBam! The problem is now reduced to traveling along the direction of the line\nintersection until we intersect with .\n\nLoading 3D scene\n\nWe could use our knowledge of line-plane intersections to solve this, but\nthere is a more efficient approach I want to demonstrate.\n\nIt involves finding a scaling factor for the direction vector that scales it\nsuch that it's tip ends at . Let's call this direction vector .\n\nThere's one observation we can make that simplifies that. Since is\nperpendicular to 's normal, the distance from 's tip to along the direction\nvector is the same as the distance from the origin to along that same\ndirection.\n\nLoading 3D scene\n\nWith that, consider the vector where and are the normal and distance of .\n\nLoading 3D scene\n\nIf were parallel to , then would be the scaling factor we need, but let's see\nwhat happens with :\n\nLoading 3D scene\n\nAs and become less parallel, becomes increasingly too short.\n\nOne thing to note as well is that even when and are completely parallel, is\nstill too short, which is due to not being a unit vector. If we normalize\nprior to multiplying with that problem goes away.\n\nLoading 3D scene\n\nBut we're getting ahead of ourselves\u2014we won't need to normalize . Let's take a\nfresh look at how is defined:\n\nHaving defined as , we can simplify this to\n\nEarlier I mentioned that we could think of as a measure of how parallel 's\nnormal is to (the line intersection of and ). That's correct, but it's not the\nwhole truth!\n\nSince the dot product is a multiple of the magnitudes of its component\nvectors, also encodes the magnitude of . Hence, scaling by does two things:\n\n  1. it normalizes , and\n  2. it increases the length of as it becomes less parallel with .\n\nSo is both the scaling factor we need for , as well as :\n\nLoading 3D scene\n\nWe've got our solution! Let's do a quick overview.\n\nWe define as:\n\nWe'll redefine to include :\n\nOur denominator, , remains defined as :\n\nWith this, we find our point of intersection by adding and together and\nscaling them by :\n\nWhich fully expanded becomes:\n\nPutting this into code, we get:\n\n    \n    \n    Vector3 ThreePlaneIntersection(Plane P1, Plane P2, Plane P3) {\n    \n    Vector3 dir = Vector3.Cross(P2.normal, P3.normal);\n    \n    float denom = Vector3.Dot(u);\n    \n    if (Mathf.Abs(denom) < EPSILON) {\n    \n    return null; // Planes do not intersect at a single point\n    \n    }\n    \n    Vector3 a = P2.normal * P3.distance;\n    \n    Vector3 b = P3.normal * P2.distance;\n    \n    Vector3 V = Vector3.Cross(P1.normal, a - b);\n    \n    Vector3 U = dir * P1.distance;\n    \n    return (V + U) / denom;\n    \n    }\n\n## Parting words\n\nThanks for reading!\n\nA whole lot of hours went into writing and building the visualizations for\nthis post, so I hope it achieved its goal of helping you build an intuitive\nmental model of planes.\n\nMassive thanks goes to Gunnlaugur \u00de\u00f3r Briem and Eir\u00edkur Fannar Torfason for\nproviding invaluable feedback on this post. I worked with them at GRID;\nthey're fantastic people to work with and be around.\n\n\u2014 Alex Harri\n\nPS: If you're interested in taking a look at how the visualizations in this\npost were built, this website is open source on GitHub.\n\n## Further reading\n\nI highly recommend checking out Real-Time Collision Detection by Christer\nEricson. If you're building applications using 3D geometry, it will prove to\nbe an incredibly useful resource. This post would not exist were it not for\nthis book\u2014especially the two chapters on the intersections of planes.\n\nI recently analyzed the edit performance in Arkio and noticed that a method\nfor solving three-plane intersections took around half of the total compute\ntime when recalculating geometry. By implementing the more efficient method\nfor three-plane intersections described in the book, we made the method ~500%\nfaster, increasing Arkio's edit performance by over 1.6x. Crazy stuff!\n\nI started writing this post to understand how the three-plane intersection\nmethod worked. However, I felt that readers would need a better foundation and\nunderstanding of planes for this post to be of any value. In building that\nfoundation, this post ended up quite a bit longer than I intended.\n\nAnyway, it's a great book. Check it out!\n\nAlex Harri\n\n\u00a9 2024 Alex Harri J\u00f3nsson\n\nLinks\n\nGitHub\n\nLinkedIn\n\nRSS\n\nMedium\n\nPages\n\nHome\n\nBlog\n\nSnippets\n\n", "frontpage": true}
