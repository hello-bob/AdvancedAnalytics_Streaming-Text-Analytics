{"aid": "40293380", "title": "What Happens on Gitlab When You do Git push?", "url": "https://nanmu.me/en/posts/2022/what-happens-on-gitlab-when-you-do-git-push/", "domain": "nanmu.me", "votes": 1, "user": "fagnerbrack", "posted_at": "2024-05-08 01:18:03", "comments": 0, "source_title": "What Happens on GitLab When You do git push?", "source_text": "What Happens on GitLab When You do git push? \u00b7 nanmu42\n\n# What Happens on GitLab When You do git push?\n\n\ud83d\udcc5 Sep 23, 2022 \ud83d\udcddMar 29, 2024 \u2615 12 min read\n\n\ud83c\udff7\ufe0f\n\n* #git\n* #GitLab\n\nEver curious about how Git and GitLab work behind the scenes? Now\u2019s the time\nto pick up your beloved IDE and embark on a journey to explore the inner\nworkings of these tools with me!\n\n# The Basics\ud83d\udd17\n\nBefore we set off on our journey, let\u2019s stock up on some background knowledge\nin less than five minutes. Ready, set, go!\n\n## Inside a Git Repository\ud83d\udd17\n\nProjects using Git have a .git folder at their root (hidden), which holds all\nthe information saved by Git. Here are the parts we\u2019ll be focusing on this\ntime:\n\n    \n    \n    .git \u251c\u2500\u2500 HEAD # Current branch (ref) the workspace is on \u251c\u2500\u2500 objects # git objects, from which git can reconstruct the entire commit history and files at any point in time \u2502 \u251c\u2500\u2500 20 # Sparse objects, organized into folders based on the first byte of their hash to avoid too many files in a single directory \u2502 \u2502 \u2514\u2500\u2500 7151a78fb5e2d99f1185db7ebbd7d883ebde6c \u2502 \u251c\u2500\u2500 43 # Another set of sparse objects \u2502 \u2502 \u2514\u2500\u2500 49b682aeaf8dc281c7a7c8d8460f443835c0c2 \u2502 \u2514\u2500\u2500 pack # Compressed objects \u2514\u2500\u2500 refs # Branches, with file contents being the hash of a commit \u251c\u2500\u2500 heads \u2502 \u251c\u2500\u2500 feat \u2502 \u2502 \u2514\u2500\u2500 hello-world # A feature branch \u2502 \u2514\u2500\u2500 main # Main branch \u251c\u2500\u2500 remotes \u2502 \u2514\u2500\u2500 origin \u2502 \u2514\u2500\u2500 HEAD # Local record of the remote branch \u2514\u2500\u2500 tags # Tags, with file contents being the hash of a commit\n\nThe red parts are provided by refs, the rest by objects. Commit objects\n(yellow) point to tree objects (blue) that represent file structures, which in\nturn point to individual file objects (grey) Image/Pro Git on git-scm.com\n\nOn the server side, Git only stores information within the .git folder\n(referred to as a bare repository), git clone pulls this information from the\nremote and reconstructs the repository at the HEAD state on your local\nmachine, while git push sends your local refs along with their related commit,\ntree, and file objects to the remote.\n\nGit compresses objects for network transmission, resulting in a packfile.\n\n## Git Transfer Protocol\ud83d\udd17\n\nLet\u2019s go through what happens during a git push, step by step:\n\n  1. The user runs git push on the client side.\n  2. The client\u2019s Git git-send-pack service, with the repository identifier, calls the server\u2019s git-receive-pack service.\n  3. The server returns the current commit hash for each ref in the repository, each as a 40-character hex-coded text, looking something like this:\n\n    \n    \n    001f# service=git-receive-pack 000000c229859bcc73cdab4db2b70ed681077a5885f80134 refs/heads/main\\x00report-status report-status-v2 delete-refs side-band-64k quiet atomic ofs-delta push-options object-format=sha1 agent=git/2.37.1.gl1 0000\n\nHere, we see that the server\u2019s main branch is at\n229859bcc73cdab4db2b70ed681077a5885f80134 (ignoring the protocol content).\n\n  4. The client identifies commits it has that the server does not, informing the server about the refs to be updated:\n\n    \n    \n    009f0000000000000000000000000000000000000000 8fa91ae7af0341e6524d1bc2ea067c99dff65f1c refs/heads/feat/hello-world\n\nIn this example, we\u2019re pushing a new branch feat/hello-world, currently\npointing to 8fa91ae7af0341e6524d1bc2ea067c99dff65f1c. Since it\u2019s a new branch,\nits previous point is represented as 0000000000000000000000000000000000000000.\n\n  5. The client packs the relevant commits along with their tree and file objects into a compressed packfile and sends it to the server. A packfile is binary:\n\n    \n    \n    report-status side-band-64k agent=git/2.20.10000PACK\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x03\\x98\\x0cx\\x9c\\x8d\\x8bI \\xc30\\x0c\\x00\\xef~\\x85\\xee\\x85\"[^$(\\xa5_\\x91m\\x85\\xe6\\xe0\\xa4\\x04\\xe7\\xff]^\\xd0\\xcb0\\x87\\x99y\\x98A\\x11\\xa5\\xd8\\xab,\\xbdSA]Z\\x15\\xcb(\\x94|4\\xdf\\x88\\x02&\\x94\\xa0\\xec^z\\xd86!\\x08'\\xa9\\xad\\x15j]\\xeb\\xe7\\x0c\\xb5\\xa0\\xf5\\xcc\\x1eK\\xd1\\xc4\\x9c\\x16FO\\xd1\\xe99\\x9f\\xfb\\x01\\x9bn\\xe3\\x8c\\x01n\\xeb\\xe3\\xa7\\xd7aw\\xf09\\x07\\xf4\\\\\\x88\\xe1\\x82\\x8c\\xe8\\xda>\\xc6:\\xa7\\xfd\\xdb\\xbb\\xf3\\xd5u\\x1a|\\xe1\\xde\\xac\\xe29o\\xa9\\x04x\\x9c340031Q\\x08rut\\xf1u\\xd5\\xcbMap\\xf6\\xdc\\xd6\\xb4n}\\xef\\xa1\\xc6\\xe3\\xcbO\\xdcp\\xe3w\\xb10=p\\xc8\\x10\\xa2(%\\xb1$U\\xaf\\xa4\\xa2\\x84\\xa1T\\xe5\\x8eO\\xe9\\xcf\\xd3\\x0c\\\\R\\x7f\\xcf\\xed\\xdb\\xb9]n\\xd1\\xea3\\xa2\\x00\\xd3\\x86\\x1db\\xbb\\x02x\\x9c\\x01+\\x00\\xd4\\xff2022\\xe5\\xb9\\xb4 09\\xe6\\x9c\\x88 01\\xe6\\x97\\xa5 \\xe6\\x98\\x9f\\xe6\\x9c\\x9f\\xe5\\x9b\\x9b 15:52:13 CST \\xa4d\\x11\\xa1\\xe8\\x86\\xdeQ\\x90\\xb1\\xe0Z\\xfd\\x7f\\x91\\x90\\xc3\\xd6\\x17\\xe8\\x02&K\\xd0\n\n  6. The server unpacks the packfile, updates the ref, and returns the result of the process:\n\n    \n    \n    003a\\x01000eunpack ok 0023ok refs/heads/feat/hello-world\n\nThe Git transfer protocol can be carried over by SSH or HTTP(S).\n\nPretty straightforward, right?\n\n## Components of GitLab\ud83d\udd17\n\nGitLab is a popular code hosting service that supports collaborative\ndevelopment, issue tracking, CI/CD, and more.\n\nGitLab\u2019s services aren\u2019t monolithic. Let\u2019s use version 15 as an example;\ncomponents related to git push include:\n\n  * GitLab: Developed in Ruby, it consists of two parts: the web/API services (hereafter referred to as Rails) and the job queue/background jobs (referred to as Sidekiq).\n  * Gitaly: Developed in Go, it\u2019s the Git storage backend for GitLab, responsible for storing and accessing Git repositories, exposing various Git operations as GRPC calls. Initially, Rails operated Git repositories directly through Git command lines on NFS, but this became inefficient with scale, leading to the development of Gitaly.\n  * Workhorse: Developed in Go, acting as a reverse proxy for Rails, handling \u201cslow\u201d HTTP requests like Git push/pull, file uploads/downloads. It offloads processing from Rails to handle resource-intensive operations more efficiently.\n  * GitLab Shell: Developed in Go, it manages Git SSH connections, serving as a bridge between the user\u2019s Git client and Gitaly.\n  * GitLab Runner: Also developed in Go, responsible for running CI/CD jobs.\n  * Data is stored in Postgres, with Redis used for caching. Rails and Sidekiq directly interact with the database and cache, while other components communicate through APIs implemented in Rails.\n\nA simplified view of GitLab components Diagram/GitLab architecture overview on\ndocs.gitlab.com\n\n# The Journey of git push\ud83d\udd17\n\nNow that you\u2019re equipped with the basics, let\u2019s dive into the adventure!\n\n## Do You Prefer SSH?\ud83d\udd17\n\nIf your remote URL looks like git@gitlab.example.com:user/repo.git, you\u2019re\ncommunicating with GitLab over SSH. When executing a git push, essentially,\nyour Git client\u2019s upload-pack service is executing a command like:\n\n    \n    \n    1\n\n|\n\n    \n    \n    ssh -x git@gitlab.example.com \"git-receive-pack 'user/repo.git'\"  \n  \n---|---  \n  \nThere are interesting questions to ponder here:\n\n  * Everyone\u2019s username is git. How does the server distinguish who is who?\n  * SSH? Can I run arbitrary commands on the server?\n\nThese questions are addressed by GitLab Shell\u2019s gitlab-sshd, a customized SSH\ndaemon speaking the same protocol as sshd. During the SSH handshake, the\nclient provides its public key, and gitlab-sshd verifies it against the public\nkeys registered in GitLab through an internal API call, thus authenticating\nthe user.\n\nMoreover, gitlab-sshd restricts the commands clients can execute, using the\nattempted command to decide which method to run. Any non-matching commands are\nrejected.\n\nSadly, it seems we can\u2019t run bash or rm -rf / on GitLab\u2019s servers via SSH. \u2511(\n\u0304\u0414 \u0304)\u250d\n\nIn the past, GitLab indeed used sshd to handle Git requests. To solve the\naforementioned problems, their authorized_keys file looked something like\nthis:\n\n    \n    \n    # Managed by gitlab-rails command=\"/bin/gitlab-shell key-1\",no-port-forwarding,no-X11-forwarding,no-agent-forwarding,no-pty ssh- rsa AAAAB3NzaC1yc2EAAAABJQAAAIEAiPWx6WM4lhHNedGfBpPJNPpZ7yKu+dnn1SJejgt1016k6YjzGGphH2TUxwKzxcKDKKezwkpfnxPkSMkuEspGRt/aZZ9wa++Oi7 Qkr8prgHc4soW6NUlfDzpvZK2H5E7eQaSeP3SAwGmQKUFHCddNaP0L+hM7zhFNzjFvpaMgJw0= command=\"/bin/gitlab-shell key-2\",no-port-forwarding,no-X11-forwarding,no-agent-forwarding,no-pty ssh- rsa AAAAB3NzaC1yc2EAAAABJQAAAIEAiPWx6WM4lhHNedGfBpPJNPpZ7yKu+dnn1SJejgt1026k6YjzGGphH2TUxwKzxcKDKKezwkpfnxPkSMkuEspGRt/aZZ9wa++Oi7 Qkr8prgHc4soW6NUlfDzpvZK2H5E7eQaSeP3SAwGmQKUFHCddNaP0L+hM7zhFNzjFvpaMgJw0=\n\nYes, all users\u2019 public keys were in this file, potentially reaching sizes of\nhundreds of MBs!\n\nThe command parameter overrides any command the SSH client attempts to run,\ninstead launching gitlab-shell with the public key ID as the parameter.\ngitlab-shell then executes the intended operation based on the\nSSH_ORIGINAL_COMMAND environment variable.\n\nWith the transition to gitlab-sshd, which relies on a Rails API backed by\nPostgres indexing, the performance disparity between users based on their\nregistration order is no longer an issue.\n\nTwo experienced developers are having fun when waiting for git push to be\nfinished Image/xkcd-excuse.com\n\nAfter authenticating the user, gitlab-sshd checks the user\u2019s write access to\nthe target repository and retrieves information about the repository\u2019s Gitaly\ninstance, user ID, and repository details.\n\nFinally, gitlab-sshd calls the corresponding Gitaly instance\u2019s SSHReceivePack\nmethod, acting as a relay and translator between the Git client (SSH) and\nGitaly (GRPC).\n\nFrom a broader perspective, a git push over SSH follows this flow:\n\n  1. The user executes git push.\n  2. The Git client establishes an SSH connection to gitlab-shell.\n  3. gitlab-shell queries the Rails internal API for public key verification(GET /api/v4/internal/authorized_keys) and write permission(POST /api/v4/internal/allowed).\n  4. The API responds with the Gitaly address, authentication token, repository object, and hook callback information.\n  5. gitlab-shell relays this information to Gitaly\u2019s SSHReceivePack method.\n  6. Gitaly executes git-receive-pack in the appropriate working directory, setting environment variables(GITALY_HOOKS_PAYLOAD) for Git hooks.\n  7. The server-side Git attempts to update refs and execute Git hooks.\n  8. Completion.\n\nThe details about Gitaly and Git hooks will be covered next.\n\n## Do You Prefer HTTP(S)?\ud83d\udd17\n\nThe remote URL for HTTP(S) looks like\nhttps://gitlab.example.com/user/repo.git. Unlike SSH, HTTP requests are\nstateless and always follow a request-response pattern. When you perform a git\npush, the Git client interacts with two endpoints in sequence:\n\n  * GET https://gitlab.example.com/user/repo.git/info/refs?service=git-receive-pack: The server returns the current commit hashes of all branches in the repository body.\n  * POST https://gitlab.example.com/user/repo.git/git-receive-pack: The client submits the branches to be updated along with their old commit hashes and new commit hashes in the body, including the required packfile. The server returns the result of the operation in the body, along with the familiar prompt to \u201ccreate a merge request\u201d:\n\n    \n    \n    003a\\x01000eunpack ok 0023ok refs/heads/feat/hello-world 00000085\\x02 To create a merge request for feat/hello-world, visit: https://gitlab.example.com/user/repo/-/merge_requests/new?merge_request%5Bs0029\\x02ource_branch%5D=feat%2Fhello-world 0000\n\nBoth requests are intercepted by Workhorse, which does two things each time:\n\n  1. Forwards the request as-is to Rails, which returns the authentication result, user ID, and information about the repository\u2019s corresponding Gitaly instance (interesting, right? The info/refs and git-receive-pack endpoints of Rails are actually used for authentication, which I guess has some historical reasons behind it).\n  2. Based on the information returned by Rails, Workhorse establishes a connection with Gitaly, acting as a relay between the client and Gitaly.\n\nIn summary, a git push via HTTP(S) goes like this:\n\n  1. The user executes git push.\n  2. The Git client calls GET https://gitlab.example.com/user/repo.git/info/refs?service=git-receive-pack, including the corresponding authorization header.\n  3. Workhorse intercepts the request, forwards it to Rails as-is, and obtains the authentication result, user ID, and information about the repository\u2019s corresponding Gitaly instance.\n  4. Based on Rails\u2019 response, Workhorse calls Gitaly\u2019s GRPC service InfoRefsReceivePack, acting as a relay between the client and Gitaly.\n  5. Gitaly runs git-receive-pack in the appropriate working directory and returns ref information.\n  6. The Git client calls POST https://gitlab.example.com/user/repo.git/git-receive-pack.\n  7. Workhorse intercepts the request, forwards it to Rails as-is, and obtains the authentication result, user ID, and information about the repository\u2019s corresponding Gitaly instance.\n  8. Based on Rails\u2019 response, Workhorse calls Gitaly\u2019s GRPC service PostReceivePack, acting as a relay between the client and Gitaly.\n  9. Gitaly runs git-receive-pack in the appropriate working directory, setting environment variables like GITALY_HOOKS_PAYLOAD, which includes GL_ID, GL_REPOSITORY, etc.\n  10. The server-side Git attempts to update refs and execute Git hooks.\n  11. Completion.\n\n## Gitaly and Git Hooks\ud83d\udd17\n\nAfter traversing through the connection layer and authorization checks, we\u2019re\nnow closer to GitLab\u2019s heart\u2014Gitaly.\n\nGitaly, named with a bit of humor blending \u201cGit\u201d with the desolately populated\nRussian village \u201cAly\u201d, aims for minimal disk IO operations, much like Aly\u2019s\nminimal population. This playful naming underscores the developers\u2019 goal of\nefficiency and minimalism.\n\nGitaly is responsible for managing Git repositories in GitLab, executing Git\nbinary operations through fork/exec, and using cgroups to ensure these\nprocesses don\u2019t consume excessive CPU and memory resources. Repositories are\nstored locally(e.g. /var/opt/gitlab/git-\ndata/repositories/@hashed/b1/7e/b17ef6d19c7a5b1ee83b907c595526dcb1eb06db8227d650d5dda0a9f4ce8cd9.git),\nand Gitaly handles the intricate operations of managing these repositories.\n\nWhen you perform a git push, Gitaly\u2019s SSHReceivePack (for SSH) and\nPostReceivePack (for HTTPS) methods come into play. These methods ultimately\nrely on Git\u2019s git-receive-pack, which means the core updates to refs and\nobjects are managed by the Git binary itself. Git\u2019s git-receive-pack offers\nhooks that allow Gitaly to integrate into this process, interacting with Rails\nfor certain operations.\n\nWhen Gitaly starts git-receive-pack, it passes a Base64-encoded JSON via the\nGITALY_HOOKS_PAYLOAD environment variable, containing repository information,\nthe Gitaly Unix Socket address and connection token, user information, and\nwhich hooks to execute (for git push, it\u2019s always the following ones). It also\nsets Git\u2019s core.hooksPath parameter to a temporary directory prepared by\nGitaly at runtime, where all hook files are symlinked to gitaly-hooks.\n\nAfter being started by git-receive-pack, gitaly-hooks reads\nGITALY_HOOKS_PAYLOAD from the environment variable, reconnects to Gitaly\nthrough Unix Socket and GRPC, informing Gitaly of the currently executed hook\nand the parameters provided by Git to the hook.\n\n### pre-receive hook\ud83d\udd17\n\nThis hook is triggered once Git receives a git push request, before any\nupdates are made. It receives change information via stdin in the format of\n<old commit ref hash> <new commit ref hash> <ref name>, one per line.\n\nUpon receiving this information, Gitaly makes two calls to Rails:\n\n  * POST /api/v4/internal/allowed: This API endpoint was already invoked during the connection layer\u2019s authorization step. This time, it includes change information, allowing Rails to make more granular decisions like enforcing branch protection rules.\n  * POST /api/v4/internal/pre_receive: This notifies Rails that the repository is about to be updated, incrementing a reference counter for the repository to prevent disruptive changes during the push process.\n\nIf the POST /api/v4/internal/allowed returns an error, Gitaly will relay this\nerror back to gitaly-hooks, which will write the error message to standard\nerror and exit with a non-zero exit code. The error message will be collected\nby git-receive-pack and written to its standard error. The non-zero exit code\nfrom gitaly-hooks will cause git-receive-pack to stop processing the current\ngit push and exit with a non-zero exit code as well, returning control to\nGitaly. Gitaly then collects the standard error output from git-receive-pack\nand responds to Workhorse/Gitlab-Shell with a GRPC response.\n\nObservant you might wonder how unprocessed objects, which have already been\nuploaded to the server when hooks are running, are handled if the process is\nhalted at this point?\n\nActually, objects associated with an incomplete git push are first written to\na quarantine environment, stored in a subfolder under objects, such as\nincoming-8G4u9v. This way, if the hooks determine there\u2019s a problem with the\npush, the related resources can be easily cleaned up.\n\n### update hook\ud83d\udd17\n\nThis hook is invoked just before Git updates a ref. It doesn\u2019t currently\ninteract with Rails but is essential for maintaining repository integrity\nduring updates.\n\nGitLab also supports custom Git hooks, which can be triggered at this stage,\nallowing administrators to integrate additional checks or operations during\nthe push process.\n\n### post-receive hook\ud83d\udd17\n\nAfter all refs have been successfully updated, the post-receive hook is\ntriggered, sending the same change information as the pre-receive hook to\nGitaly.\n\nGitaly then informs Rails through the POST /api/v4/internal/post_receive\nendpoint. Rails performs several actions in response:\n\n  * Suggests creating a Merge Request for the updated branch.\n  * Decrements the repository\u2019s reference counter.\n  * Refreshes repository cache.\n  * Triggers CI pipelines.\n  * Sends notification emails if applicable.\n\nSome of these actions are asynchronous, managed by Sidekiq to ensure efficient\nprocessing without blocking the post-receive hook\u2019s execution.\n\n# Conclusion\ud83d\udd17\n\nYou\u2019ve now journeyed through the entire process of git push from the client-\nside to the server-side, uncovering the intricate details of GitLab\u2019s handling\nof Git operations.\n\nHere\u2019s our end-of-journey treasure!\n\n# References\ud83d\udd17\n\n  * Pro Git - Chapter 10: Git Internals\n  * How Gitaly fits into GitLab\n  * Gitaly - Git Hooks\n  * Git Hooks\n  * Rails internal APIs\n\nShare on\n\nWRITTEN BY\n\nnanmu42\n\nTo build beautiful things beautifully.\n\n#\n\nSee Also\n\n  * The Art of Error Handling in Go\n  * Learning Golang as Your Second Programming Language: Learning Paths, Best Practices, and Engineering\n  * Yaesu FT-70DR Handheld Transceiver Crash Course\n  * How to Program Your Robot Car into a Goalkeeper?\n  * A Practical Guide to Reclaim Disk Space from MongoDB\n\nCopyright \u00a92024 LI Zhennan\n\n###### What's on this Page\n\n", "frontpage": false}
