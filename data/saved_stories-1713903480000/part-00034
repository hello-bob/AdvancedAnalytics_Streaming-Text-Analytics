{"aid": "40132122", "title": "Solving the Expression Problem with Clojure (2010)", "url": "https://web.archive.org/web/20110821210021/http://www.ibm.com/developerworks/java/library/j-clojure-protocols/", "domain": "archive.org", "votes": 2, "user": "simonpure", "posted_at": "2024-04-23 14:03:52", "comments": 0, "source_title": "Solving the Expression Problem with Clojure 1.2", "source_text": "Solving the Expression Problem with Clojure 1.2\n\nThe Wayback Machine -\nhttp://www.ibm.com/developerworks/java/library/j-clojure-protocols/\n\nSkip to main content\n\n  * Sign in (or register)\n  * English\n  * [userid]\n\n  * Close [x]\n\nIf you don't have an IBM ID and password, register here.\n\n  * Forgot your IBM ID?\n\n  * Forgot your password?\n  * Change your password\n\nThe first time you sign into developerWorks, a profile is created for you.\nThis profile includes the first name, last name, and display name you\nidentified when you registered with developerWorks. Select information in your\ndeveloperWorks profile is displayed to the public, but you may edit the\ninformation at any time. Your first name, last name (unless you choose to hide\nthem), and display name will accompany the content that you post.\n\nAll information submitted is secure.\n\nThe first time you sign in to developerWorks, a profile is created for you, so\nyou need to choose a display name. Your display name accompanies the content\nyou post on developerworks.\n\nPlease choose a display name between 3-31 characters. Your display name must\nbe unique in the developerWorks community and should not be your email address\nfor privacy reasons.\n\nAll information submitted is secure.\n\n## My developerWorks:\n\n  * My profile\n  * My home\n  * My groups\n\n## My notifications:\n\n  * {[num_notify] new notifications}([num_notify] new notification)\n  * {[num_invite] network requests}([num_invite] network request)\n\n  * Sign out\n\n## Select a language:\n\n  * English\n  * \u4e2d\u6587\n  * \u65e5\u672c\u8a9e\n  * \ud55c\uad6d\uc5b4\n\n  * \u0420\u0443\u0441\u0441\u043a\u0438\u0439\n  * Portugu\u00eas (Brasil)\n  * Espa\u00f1ol\n  * Vi\u1ec7t\n\n  * Close [x]\n\n  * Technical topics\n  * Evaluation software\n  * Community\n  * Events\n\n## IBM products:\n\n  * AIX and UNIX\n  * IBM i\n  * Information Management\n  * Lotus\n  * Rational\n  * Tivoli\n  * WebSphere\n\n## Technologies:\n\n  * Java technology\n  * Linux\n  * Open source\n  * SOA and web services\n  * XML\n\n## Solutions:\n\n  * Cloud computing\n  * Industries\n  * Integrated Service Management\n\n  * Technical library\n  * Feeds and syndication\n  * Newsletters\n\n  * More about Technical topics\n\n  * Close [x]\n\n## Find software by:\n\n  * IBM product\n  * Evaluation method (Download, online trial, product beta, cloud)\n  * Industry\n\n  * More about Evaluation software\n\n  * Close [x]\n\n  * My home\n  * Profiles\n  * Groups\n  * Blogs\n  * Bookmarks\n\n  * Forums\n  * Wikis\n  * Files\n  * Activities\n  * Podcasts\n\n  * IBM Champion program\n\n  * More about Community\n\n  * Close [x]\n\n  * Briefings\n  * Webcasts\n  * Find events (briefings, webcasts, conferences...)\n\n  * More about Events\n\n  * Close [x]\n\n  * developerWorks\n  * Java technology\n  * Technical library\n\n# Solving the Expression Problem with Clojure 1.2\n\nExtend preexisting types to new methods, and preexisting methods to new types\n\nStuart Sierra (stuart.sierra@thinkrelevance.com), Developer, Relevance, Inc.\n\nStuart Sierra is an actor/writer/coder who lives in New York City. He is a\nmember of the Clojure/core team at Relevance, Inc. Stuart is the co-author of\nPractical Clojure (Apress, 2010). He received an M.S. in Computer Science from\nColumbia University and a B.F.A. in Theatre from New York University.\n\nSummary: Clojure expert Stuart Sierra introduces you to new features in\nClojure 1.2 that solve the Expression Problem, a classic programming dilemma.\nProtocols let you extend preexisting types to new methods, and datatypes let\nyou extend preexisting methods to new types \u2014 all without changing the\nexisting code. You'll also see how JavaTM interfaces and classes can interact\nwith Clojure protocols and datatypes.\n\nTag this!\n\nUpdate My dW interests (Log in | What's this?) Skip to help for Update My dW interests\n\nDate: 14 Dec 2010 Level: Intermediate PDF: A4 and Letter (91KB | 17 pages)Get Adobe\u00ae Reader\u00ae Also available in: Chinese Portuguese\n\nActivity: 31817 views Comments: 0 (View | Add comment - Sign in)\n\nRate this article\n\nProtocols are a new feature introduced in version 1.2 of Clojure, a dynamic\nprogramming language for the JVM. Protocols represent an approach to object-\noriented programming that's more flexible than Java class hierarchies, without\nsacrificing the excellent performance of JVM method dispatch. Protocols \u2014 and\na related feature, datatypes \u2014 provide a solution to what is known as the\nExpression Problem. Solving the Expression Problem makes it possible to extend\npreexisting types to new methods and extend preexisting methods to new types,\nall without recompiling existing code.\n\n## Clojure basics\n\nThis article assumes you're familiar with the basics of writing and running\nClojure (and Java) programs. For an introduction to Clojure, see the\ndeveloperWorks article \"The Clojure programming language,\" and explore the\nResources.\n\nThis article describes the Expression Problem, shows some examples of it, and\nthen demonstrates how Clojure's protocols and datatypes can solve it, which\nsimplifies certain programming challenges. You'll also see how you can\nintegrate Clojure's protocol and datatype features with existing Java classes\nand interfaces.\n\nMany types, one interface\n\nOne of Clojure's core features is its generic data-manipulation API. A small\nset of functions can be used on all of Clojure's built-in types. For example,\nthe conj function (short for conjoin) adds an element to any collection, as\nshown in the following REPL session:\n\n    \n    \n    user> (conj [1 2 3] 4) [1 2 3 4] user> (conj (list 1 2 3) 4) (4 1 2 3) user> (conj {:a 1, :b 2} [:c 3]) {:c 3, :a 1, :b 2} user> (conj #{1 2 3} 4) #{1 2 3 4}  \n  \n---  \n  \nEach data structure behaves slightly differently in response to the conj\nfunction (lists grow at the front, vectors grow at the end, and so on), but\nthey all support the same API. This is a textbook example of polymorphism \u2014\nmany types accessed through one uniform interface.\n\nPolymorphism is a powerful feature and one of the foundations of modern\nprogramming languages. The Java language supports a particular kind of\npolymorphism called subtype polymorphism, which means that an instance of a\ntype (class) can be accessed as if it were an instance of another type.\n\nIn practical terms, this means that you can work with objects through a\ngeneric interface such as java.util.List without knowing or caring if an\nobject is an ArrayList, LinkedList, Stack, Vector, or something else. The\njava.util.List interface defines a contract that any class claiming to\nimplement java.util.List must fulfill.\n\nBack to top\n\nThe Expression Problem\n\nPhilip Wadler of Bell Labs coined the term Expression Problem in an\nunpublished paper that he circulated by email in 1998 (see Resources). As he\nput it, \"The Expression Problem is a new name for an old problem. The goal is\nto define a datatype by cases, where one can add new cases to the datatype and\nnew functions over the datatype, without recompiling existing code, and while\nretaining static type safety (e.g., no casts).\"\n\nTo illustrate the Expression Problem, Wadler's paper uses the idea of a table\nthat has types as rows and functions as columns. Object-oriented languages\nmake it easy to add new rows \u2014 that is, new types extending a known interface\n\u2014 as shown in Figure 1:\n\nFigure 1. Object-oriented languages: Easy to add new rows (types)\n\nIn Figure 1, each column represents a method in the java.util.List interface.\nFor simplicity, it includes only four methods: List.add, List.get, List.clear,\nand List.size. Each of the first four rows represents a class that implements\njava.util.List : ArrayList, LinkedList, Stack, and Vector. The cells where\nthese rows and columns intersect represent existing implementations (provided\nby the standard Java Class Library) of these methods for each of the classes.\nA fifth row added at the bottom represents a new class you might write that\nimplements java.util.List. For each cell in that row, you would write your own\nimplementation of the corresponding method in java.util.List, specific to your\nnew class.\n\nIn contrast to object-oriented languages, functional languages typically make\nit easy to add new columns \u2014 that is, new functions that operate on existing\ntypes. For Clojure, this might look like Figure 2:\n\nFigure 2. Functional languages: Easy to add new columns (functions)\n\nFigure 2 is another table, similar to Figure 1. Here, the columns represent\nfunctions in Clojure's standard collection API: conj, nth, empty, and count.\nSimilarly, the rows represent Clojure's built-in collection types: list,\nvector, map, and set. The cells where these rows and columns intersect\nrepresent existing implementations of these functions provided by Clojure. You\ncan add a new column to the table by defining a new function. Assuming your\nnew function is written in terms of Clojure's built-in functions, it will\nautomatically be able to support all the same types.\n\nWadler's paper was talking about statically typed languages such as the Java\nlanguage. Clojure is dynamically typed \u2014 the specific types of objects do not\nneed to be declared, or known, at compile time. But that doesn't mean Clojure\ngets a free pass on the Expression Problem. In fact, it changes almost\nnothing. Being dynamically typed doesn't mean that Clojure doesn't have types.\nIt just doesn't require you to declare all of them in advance. The same\nproblem of extending old functions to new types, and new functions to old\ntypes \u2014 extending Wadler's table in both directions \u2014 remains.\n\nA concrete example\n\nThe Expression Problem isn't just about abstract types such as lists and sets.\nIf you've spent a significant amount of time working with object-oriented\nlanguages, you've probably run into examples of the Expression Problem. This\nsection provides a concrete, albeit simplified, real-world case.\n\nSuppose you work in the IT department at WidgetCo, a mail-order office-supply\ncompany. WidgetCo has written its own billing and inventory-management\nsoftware in the Java language.\n\nWidgetCo's products are all described by a simple interface:\n\n    \n    \n    package com.widgetco; public interface Widget { public String getName(); public double getPrice(); }  \n  \n---  \n  \nFor each unique type of widget manufactured by WidgetCo, the IT department's\nprogrammers write a class that implements the Widget interface.\n\nAn order from one of WidgetCo's customers is implemented as a list of Widget\nobjects, with one extra method to compute the order's total cost:\n\n    \n    \n    package com.widgetco; public class Order extends ArrayList<Widget> { public double getTotalCost() { /*...*/ } }  \n  \n---  \n  \nEverything works fine at WidgetCo until the company is bought out by\nAmagalmated Thingamabobs Incorporated. Amalgamated has its own custom billing\nsystem, also written in the Java language. Its inventory is centered around an\nabstract class, Product, from which specific product classes are derived:\n\n    \n    \n    package com.amalgamated; public abstract class Product { public String getProductID() { /*...*/ } }  \n  \n---  \n  \nAt Amalgamated, products do not have fixed prices. Instead, the company\nnegotiates with each customer to deliver a certain quantity of items at a\ngiven price. This agreement is represented by the Contract class:\n\n    \n    \n    package com.amalgamated; public class Contract { public Product getProduct() { /*...*/ } public int getQuantity() { /*...*/ } public double totalPrice() { /*...*/ } public String getCustomer() { /*...*/ } }  \n  \n---  \n  \nAfter the merger, your new bosses at Amagalmated assign you the task of\nwriting a new application to generate invoices and shipping manifests for the\nmerged company. But there's a catch: the new system must work with the\nexisting Java code used for inventory management at both WidgetCo and\nAmalgamated Thingamabobs \u2014 the com.widgetco.Widget, com.widgetco.Order,\ncom.amalgamated.Product, and com.amalgamated.Contract classes. Too many other\napplications depend on that code to risk changing it.\n\nYou have just met the Expression Problem.\n\nBack to top\n\nPotential \"solutions\"\n\nObject-oriented languages offer a number of possible approaches to solving the\nExpression Problem, but each one has its drawbacks. You've probably\nencountered examples of each of these techniques.\n\nInheritance from a common superclass\n\nThe traditional object-oriented solution to problems of this sort is to\nleverage subtype polymorphism \u2014 that is, inheritance. If two classes need to\nsupport the same interface, they should both extend the same superclass. In my\nexample, both com.widgetco.Order and com.amalgamated.Contract need to produce\ninvoices and manifests. Ideally, both classes would implement some interface\nwith the necessary methods:\n\n    \n    \n    public interface Fulfillment { public Invoice invoice(); public Manifest manifest(); }  \n  \n---  \n  \nTo do this, you'd need to modify the source code for Order and Contract to\nimplement the new interface. But that was the catch in this example: you can't\nmodify the source code to those classes. You can't even recompile them.\n\nMultiple inheritance\n\nAnother approach to the Expression Problem is multiple inheritance, in which\none subclass can extend many superclasses. You want a generic representation\nof a purchase that can be either a com.widgetco.Order or a\ncom.amalgamated.Contract. The following pseudocode shows what this might look\nlike if the Java language had multiple inheritance:\n\n    \n    \n    public class GenericOrder extends com.widgetco.Order, com.amalgamated.Contract implements Fulfillment { public Invoice invoice() { /*...*/ } public Manifest manifest() { /*...*/ } }  \n  \n---  \n  \nBut the Java language doesn't support multiple inheritance of concrete\nclasses, for a good reason: it leads to complex and sometimes unpredictable\nclass hierarchies. The Java language does support multiple inheritance of\ninterfaces, so if Order and Contract were both interfaces, you could make this\ntechnique work. But regrettably, the original authors of Order and Contract\nweren't farsighted enough to base their design on interfaces. Even if they\nwere, this wouldn't be a real solution to the Expression Problem, because you\ncan't add the Fulfillment interface to the existing Order and Contract\nclasses. Instead, you have created the new GenericOrder class, which has the\nsame problems as wrappers, described next.\n\nWrappers\n\nAnother popular solution is to write wrappers around classes whose behavior\nyou want to modify. The wrapper class is constructed with a reference to the\noriginal class, and it forwards methods to that class. The Java wrapper for\nthe Order class might look like this:\n\n    \n    \n    public class OrderFulfillment implements Fulfillment { private com.widgetco.Order order; /* constructor takes an instance of Order */ public OrderFulfillment(com.widgetco.Order order) { this.order = order; } /* methods of Order are forwarded to the wrapped instance */ public double getTotalCost() { return order.getTotalCost(); } /* the Fulfillment interface is implemented in the wrapper */ public Invoice invoice() { /*...*/ } public Manifest manifest() { /*...*/ } }  \n  \n---  \n  \nOrderFulfillment is a wrapper around Order. The wrapper class implements the\nFulfillment interface I described earlier. It also copies and forwards methods\ndefined by Order. Because Order extends ArrayList<Widget>, a correct\nimplementation of the wrapper class would also need to copy and forward all\nthe methods of java.util.ArrayList.\n\nOnce you create another wrapper for com.amalgamated.Contract that also\nimplements Fulfillment, you've satisfied the requirements of your task \u2014 but\nat the cost of increasing complexity. Wrapper classes are tedious to write.\n(java.util.ArrayList has more than 30 methods.) Worse, they break certain\nbehaviors you expect of your classes. An OrderFulfillment, although it\nimplements the same methods as Order, is not really an Order. You can't access\nit through a pointer declared as an Order, nor can you pass it to another\nmethod expecting an Order as an argument. By adding a wrapper class, you have\nbroken subtype polymorphism.\n\nEven worse, wrapper classes break identity. An Order wrapped in an\nOrderFulfillment is no longer the same object. You can't compare an\nOrderFulfillment to an Order with the Java == operator and expect it to return\ntrue. If you try to override the Object.equals method in OrderFulfillment such\nthat it is \"equal\" to its Order, you've broken the contract of Object.equals,\nwhich specifies that equality must be symmetric. Because Order knows nothing\nabout OrderFulfillment, its equals method will always return false when passed\nan OrderFulfillment. If you define OrderFulfillment.equals such that it can\nreturn true when passed an Order, you've broken the symmetry of equals,\ncausing a cascade of failures in other classes, such as the built-in Java\ncollection classes, that depend on that behavior. The moral of the story is:\ndon't mess with identity.\n\nOpen classes\n\nThe Ruby and JavaScript languages have helped to popularize the idea of open\nclasses in object-oriented programming. An open class isn't limited to the set\nof methods that were implemented when it was defined. Anyone can \"reopen\" the\nclass at any time to add new methods, or even replace existing methods.\n\nOpen classes permit a high degree of flexibility and reuse. Generic classes\ncan be extended with functionality specific to different places where they are\nused. Groups of methods implementing a particular aspect of behavior can be\ngathered together in a mix-in that is added to any class that needs that\nbehavior. If this article's example were written in Ruby or JavaScript, you\ncould simply reopen the Order and Contract classes to add the methods you\nneed.\n\nThe downside of open classes, aside from their nonexistence in most\nprogramming languages (including the Java language), is the lack of certainty\nbrought about by their very flexibility. If you define an invoice method on a\nclass, you have no way of knowing that some other user of that class won't\ndefine a different, incompatible method also named invoice. This is the\nproblem of name clashes, and it's difficult to avoid in languages with both\nopen classes and no namespacing mechanism for methods. There's a reason this\ntechnique is known as \"monkey patching.\" It's simple and easy to understand,\nbut it's almost guaranteed to cause problems later.\n\nConditionals and overloading\n\nOne of the most common solutions to the Expression Problem is plain old if-\nthen-else logic. Using conditional statements and type checks, you enumerate\nevery possible case and deal with each appropriately. For the invoice example,\nin the Java language, you could implement this in a static method:\n\n    \n    \n    public class FulfillmentGenerator { public static Invoice invoice(Object source) { if (source instanceof com.widgetco.Order) { /* ... */ } else if (source instanceof com.amalgamated.Contract) { /* ... */ } else { throw IllegalArgumentException(\"Invalid source.\"); } } }  \n  \n---  \n  \nLike the wrapper class, this technique fulfills your requirements, but it\ncomes with its own disadvantages. The chain of if-else blocks gets messier,\nand slower, the more types you must handle. And this implementation is closed:\nAfter you compile the FulfillmentGenerator class, you can't extend the invoice\nmethod to new types without editing the source code and recompiling. The\nconditional solution to the Expression Problem is really no solution at all,\njust a hack that will lead to more maintenance work in the future.\n\nIn this case, you could avoid the conditional logic by overloading the invoice\nmethod for different types:\n\n    \n    \n    public class FulfillmentGenerator { public static Invoice invoice(com.widgetco.Order order) { /* ... */ } public static Invoice invoice(com.amalgamated.Contract contract) { /* ... */ } }  \n  \n---  \n  \nThis accomplishes the same thing and is more efficient than the conditional\nversion, but it's just as closed: You can't add new implementations of invoice\nfor different types without modifying the source of FulfillmentGenerator. It\nalso becomes unpredictable in the face of inheritance hierarchies. Suppose you\nwanted to add an implementation of invoice for a subclass of Order or\nContract. Only a Java language expert could tell you which version of the\nmethod would actually be invoked, and it might not be the one you want.\n\nReal solutions to the Expression Problem in the Java language do exist (see\nResources), but they are much more complex than you would want to tackle to\nsolve a simple business problem. In general, all of the nonsolutions I've\npresented here fail because they conflate types with other things:\ninheritance, identity, or namespaces. Clojure treats each issue separately.\n\nBack to top\n\nProtocols\n\nClojure 1.2 introduced protocols. While not a new idea \u2014 computer scientists\nwere researching similar ideas in the 1970s \u2014 Clojure's implementation is\nflexible enough to solve the Expression Problem while preserving the\nperformance of its host platform, the JVM.\n\nConceptually, a protocol is like a Java interface. It defines a set of method\nnames and their argument signatures, but no implementations. The invoice\nexample might look like Listing 1:\n\nListing 1. The Fulfillment protocol\n\n    \n    \n    (ns com.amalgamated) (defprotocol Fulfillment (invoice [this] \"Returns an invoice\") (manifest [this] \"Returns a shipping manifest\"))  \n  \n---  \n  \nEach protocol method takes at least one argument, commonly called this. Like\nJava methods, protocol methods are invoked \"on\" an object, and that object's\ntype determines which implementation of the method is used. Unlike the Java\nlanguage, Clojure requires this to be declared as an explicit argument to the\nfunction.\n\nProtocols differ from interfaces in that their methods exist, as ordinary\nfunctions, the moment they are defined. The Listing 1 example defines Clojure\nfunctions named invoice and manifest, both living in the com.amalgamated\nnamespace. Of course, those functions don't have any implementations yet, so\ncalling them will just throw an exception.\n\nProtocols allow you to provide implementations for their methods on a case-by-\ncase basis. You extend the protocol to new types, using a function named\nextend. The extend function takes a datatype, a protocol, and a map of method\nimplementations. I'll explain datatypes in the next section, but for now, just\nassume that datatypes are ordinary Java classes. You can extend the\nFulfillment protocol to work on the old Order class, as shown in Listing 2:\n\nListing 2. Extending the Fulfillment protocol to work on the Order class\n\n    \n    \n    (extend com.widgetco.Order Fulfillment {:invoice (fn [this] ... return an invoice based on an Order ... ) :manifest (fn [this] ... return a manifest based on an Order ... )})  \n  \n---  \n  \nNotice that the map you pass to the extend function maps from keywords to\nanonymous functions. The keywords are names of the methods in the protocol;\nthe functions are implementations of those methods. By calling extend, you are\ntelling the Fulfillment protocol, \"Here is the code to implement these methods\non the com.widgetco.Order type.\"\n\nYou can do the same thing for the Contract class, as shown in Listing 3:\n\nListing 3. Extending the Fulfillment protocol to work on the Contract class\n\n    \n    \n    (extend com.amalgamated.Contract Fulfillment {:invoice (fn [this] ... return an invoice based on a Contract ... ) :manifest (fn [this] ... return a manifest based on a Contract ... )})  \n  \n---  \n  \nAnd with that, you have polymorphic invoice and manifest functions that can be\ncalled on either an Order or a Contract and that will do the right thing.\nYou've satisfied the difficult part of the Expression Problem: you've added\nthe new invoice and manifest functions to the preexisting Order and Contract\ntypes, without modifying or recompiling any existing code.\n\nUnlike in the open-classes approach, you have not changed the Order and\nContract classes. Nor have you prevented other code from defining its own\ninvoice and manifest methods with different implementations. Your invoice and\nmanifest methods are namespaced within com.amalgamated; methods defined in\nother namespaces will never clash.\n\nClojure, being a Lisp, uses macros to simplify some complex or repetitive\nsyntax. Using the built-in extend-protocol macro, you could write all your\nmethod implementations in one block, as shown in Listing 4:\n\nListing 4. Using the extend-protocol macro\n\n    \n    \n    (extend-protocol Fulfillment com.widgetco.Order (invoice [this] ... return an invoice based on an Order ... ) (manifest [this] ... return a manifest based on an Order ... ) com.amalgamated.Contract (invoice [this] ... return an invoice based on a Contract ... ) (manifest [this] ... return a manifest based on a Contract ... ))  \n  \n---  \n  \nThis macro code expands out to the same two calls to extend shown in Listing 2\nand Listing 3.\n\nBack to top\n\nDatatypes\n\nProtocols are a powerful tool: they effectively give you the ability to insert\nnew methods into existing classes, without name clashes and without modifying\nthe original code. But they only solve half of the Expression Problem, the\n\"new columns\" of Wadler's table. How do you add \"new rows\" to the table in\nClojure?\n\nThe answer is datatypes. In the object-oriented landscape, datatypes fill the\nsame role as classes: they encapsulate state (fields) and behavior (methods).\nHowever, mainstream object-oriented languages such as the Java language tend\nto conflate the different roles that classes can fill in object-oriented\ndesign. Clojure's datatypes are split into two distinct roles.\n\nStructured data: defrecord\n\nOne use for classes is as containers for structured data. This is where almost\nevery object-oriented programming textbook starts: you have a Person class\nwith fields like Name and Age. Whether the fields are accessed directly or\nthrough getter/setter methods is immaterial; the class itself fills the role\nof a struct in C. Its purpose is to hold a set of logically related values.\nJavaBeans are examples of classes used to hold structured data.\n\nThe problem with using classes for structured data is that each class has its\nown distinct interface for accessing that data, typically through\ngetter/setter methods. Clojure favors uniform interfaces, so it encourages\nstoring structured data in maps. Clojure's map implementations \u2014 HashMap,\nArrayMap, and StructMap \u2014 all support the generic data-manipulation interface\nI discussed at the beginning of this article. But maps lack some of the\nfeatures expected of structured data: they have no real \"type\" (without added\nmetadata) and, unlike classes, they can't be extended with new behavior.\n\nThe defrecord macro, introduced along with protocols in Clojure 1.2, can be\nused to create containers for structured data that combine the features of\nmaps and classes.\n\nReturning to this article's running example, suppose the management of\nAmalgamated Thingamabobs Incorporated decides it's time to unify the\npurchasing processes of its customers. From this point forward, new product\norders will be represented by a PurchaseOrder object, and the old Order and\nContract classes will be phased out.\n\nA PurchaseOrder will have \"date,\" \"customer,\" and \"products\" properties. It\nmust also provide implementations of invoice and manifest. As a Clojure\ndefrecord, it looks like Listing 5:\n\nListing 5. The PurchaseOrder datatype\n\n    \n    \n    (ns com.amalgamated) (defrecord PurchaseOrder [date customer products] Fulfillment (invoice [this] ... return an invoice based on a PurchaseOrder ... ) (manifest [this] ... return a manifest based on a PurchaseOrder ... ))  \n  \n---  \n  \nThe vector following the name PurchaseOrder defines the datatype's fields.\nAfter the fields, defrecord allows you to write in-line definitions for\nprotocol methods. Listing 5 implements only one protocol, Fulfillment, but it\ncould be followed by any number of other protocols and their implementations.\n\nUnder the hood, defrecord creates a Java class with date, customer, and\nproducts fields. To create a new instance of PurchaseOrder, you call its\nconstructor in the usual way, supplying values for the fields, as shown in\nListing 6:\n\nListing 6. Creating a new PurchaseOrder instance\n\n    \n    \n    (def po (PurchaseOrder. (System/currentTimeMillis) \"Stuart Sierra\" [\"product1\" \"product2\"]))  \n  \n---  \n  \nOnce the instance is constructed, you can call the invoice and manifest\nfunctions on your PurchaseOrder object, which uses the implementations\nprovided in the defrecord. But you can also treat the PurchaseOrder object\nlike a Clojure map: defrecord automatically adds the methods necessary to\nimplement Clojure's map interface. You can retrieve fields by name (as\nkeywords), update those fields, and even add new fields not in the original\ndefinition \u2014 all using Clojure's standard map functions, as in the following\nREPL session:\n\n    \n    \n    com.amalgamated> (:date po) 1288281709721 com.amalgamated> (assoc po :rush \"Extra Speedy\") #:com.amalgamated.PurchaseOrder{:date 1288281709721, :customer \"Stuart Sierra\", :products [\"product1\" \"product2\"], :rush \"Extra Speedy\"} com.amalgamated> (type po) com.amalgamated.PurchaseOrder  \n  \n---  \n  \nNotice that when a record type is printed, it looks like a map with an extra\ntype tag in front. That type can be retrieved with Clojure's type function.\nThe fact that maps and record types obey the same interface is especially\nconvenient during development: you can start with ordinary maps and switch to\nrecord types when you need the extra features, without breaking your code.\n\nPure behavior: deftype\n\nNot all classes represent structured data in the application domain. The other\nkind of class typically represents objects specific to an implementation, such\nas collections (for example, ArrayList, HashMap, SortedSet) or values (for\nexample, String, Date, BigDecimal). These classes implement their own generic\ninterfaces, so it doesn't make sense for them to behave like Clojure maps. To\nfill that role, Clojure offers a variant of datatype for things that aren't\nrecords. The deftype macro has the same syntax as defrecord, but it creates a\nbare-bones Java class, without any map-like features. Any behavior of the\nclass must be implemented as protocol methods. You would typically use deftype\nto implement new kinds of collections, or to define completely new\nabstractions around protocols that you specify.\n\nOne feature that is deliberately left out of datatypes is the ability to\nimplement methods that are not defined in any protocol. A datatype must be\ncompletely specified by its fields and the protocols it implements; that\nguarantees that functions invoked on a datatype will always be polymorphic.\nAny datatype can be substituted by another datatype as long as they implement\nthe same protocols.\n\nBack to top\n\nInteracting with Java code\n\nOver the past several months, you have managed to sneak some Clojure into the\nproduction systems of Amalgamated Thingamabobs Incorporated. Because it was\ncompiled into JAR files, the other programming teams never even noticed. But\nthen another team of Java-only developers needs to build another invoice\ngenerator that is compatible with your Clojure code. You start to talk to them\nabout Clojure, Lisp, and the Expression Problem, and their eyes glaze over.\n\nFinally, you say, \"No problem, just make your Java classes implement this\ninterface,\" and you show them this:\n\n    \n    \n    package com.amalgamated; public interface Fulfillment { public Object invoice(); public Object manifest(); }  \n  \n---  \n  \nClojure has already compiled the protocol you defined earlier into JVM\nbytecode representing this interface. In fact, every Clojure protocol is also\na Java interface with the same name and methods. If you're careful with naming\n(that is, don't use any characters in your method names that aren't valid in\nthe Java language) then other Java developers can implement the interface\nwithout ever knowing that it was generated from Clojure.\n\nThe same is true of datatypes, although their generated classes look a bit\nless like what a Java developer would expect. The PurchaseOrder datatype\ndefined in Listing 5 generates bytecode for a class like this:\n\n    \n    \n    public class PurchaseOrder implements Fulfillment, java.io.Serializable, java.util.Map, java.lang.Iterable, clojure.lang.IPersistentMap { public final Object date; public final Object customer; public final Object products; public PurchaseOrder(Object date, Object customer, Object products) { this.date = date; this.customer = customer; this.products = products; } }  \n  \n---  \n  \nThe datatype's fields are declared public final in keeping with Clojure's\npolicy of immutable data. They can only be initialized through the\nconstructor. You can see that this class implements the Fulfillment interface.\nThe other interfaces are the foundations of Clojure's data-manipulation APIs \u2014\nthey would be absent in a datatype created with deftype instead of defrecord.\nNotice that datatypes can implement methods of any Java interface, not only\nthose generated by Clojure protocols.\n\nClojure has other forms of Java interop that produce code that's more like\nidiomatic Java \u2014 but less like idiomatic Clojure \u2014 when that's the only\noption.\n\nBack to top\n\nConclusion\n\nThe Expression Problem is a real, practical problem in object-oriented\nprogramming, and most common solutions to it are inadequate. Clojure protocols\nand datatypes provide a simple, elegant solution. Protocols allow you to\ndefine polymorphic functions over preexisting types. Datatypes let you create\nnew types that support preexisting functions. Together they let you extend\nyour code in both directions, as shown in Figure 3:\n\nFigure 3. Clojure: Easy to add new columns (protocols) and rows (datatypes)\n\nFigure 3 shows the final version of the table, adapted from Figure 1 and\nFigure 2. The columns represent any functions or methods that already exist.\nRows represent classes (Java) and datatypes (Clojure) that already exist. The\nintersection of those rows and columns represents all preexisting\nimplementations, which you don't want or need to change. You can add a new\nClojure datatype as a new row at the bottom of the table, and a new Clojure\nprotocol as a new column at the right side of the table. Furthermore, your new\nprotocol can be extended to your new datatype, filling in the new bottom-right\ncell.\n\nSolutions to the Expression Problem beyond those I have described here are\navailable. Clojure itself has always had multimethods, which provide an even\nmore flexible variety of polymorphism (albeit one that performs less well).\nMultimethods are similar to generic functions in other languages such as\nCommon Lisp. Clojure's protocols also bear a resemblance to Haskell's type\nclasses.\n\nEvery programmer will encounter the Expression Problem sooner or later, so\nevery programming language has some sort of answer to it. As an interesting\nexperiment, pick any programming language \u2014 one you know well or one you are\njust learning \u2014 and think about how you would use it to solve a problem like\nthe example presented in this article. Can you do it without modifying any\nexisting code? Can you do it without breaking identity? Can you be sure you're\nsafe from name clashes? And, most important, can you do it without creating an\neven bigger problem in the future?\n\nResources\n\nLearn\n\n  * Clojure: Visit the Clojure website and check out the Protocols and Datatypes pages.\n\n  * Stuart Halloway on Clojure: Listen to this podcast with a Clojure committer to learn more about Clojure and why it's rising rapidly in popularity.\n\n  * The Expression Problem: Read Philip Wadler's paper.\n\n  * Clojure's Solutions to the Expression Problem: View video and slides from a presentation by Chris Houser at Strange Loop 2010.\n\n  * Clojure Protocols: Take a look at slides presented by Stuart Halloway at the International Software Development Conference 2010.\n\n  * \"The Clojure programming language\" (Michael Galpin, developerWorks, September 2009): Get started with Clojure, learn some of its syntax, and take advantage of the Clojure plug-in for Eclipse.\n\n  * Practical Clojure (Luke VanderHart and Stuart Sierra, Apress, 2010): Check out this book's chapter on datatypes and protocols.\n\n  * Type polymorphism and Polymorphism in object-oriented programming: Read Wikipedia's articles about polymorphism, including subtype polymorphism.\n\n  * The Expression Problem Revisited: Take a look at a paper, slides, and example code that show real solutions to the Expression Problem in the Java language, by Mads Torgersen, University of Aarhus, Denmark.\n\n  * Browse the technology bookstore for books on these and other technical topics.\n\n  * developerWorks Java technology zone: Find hundreds of articles about every aspect of Java programming.\n\nGet products and technologies\n\n  * Clojure: Download Clojure 1.2.\n\nDiscuss\n\n  * Get involved in the My developerWorks community. Connect with other developerWorks users while exploring the developer-driven blogs, forums, groups, and wikis.\n\nAbout the author\n\nStuart Sierra is an actor/writer/coder who lives in New York City. He is a\nmember of the Clojure/core team at Relevance, Inc. Stuart is the co-author of\nPractical Clojure (Apress, 2010). He received an M.S. in Computer Science from\nColumbia University and a B.F.A. in Theatre from New York University.\n\nClose [x]\n\nReport abuse help\n\n# Report abuse\n\nThank you. This entry has been flagged for moderator attention.\n\nClose [x]\n\nReport abuse help\n\n# Report abuse\n\nReport abuse submission failed. Please try again later.\n\nClose [x]\n\n# developerWorks: Sign in\n\nIf you don't have an IBM ID and password, register here.\n\nThe first time you sign into developerWorks, a profile is created for you.\nThis profile includes the first name, last name, and display name you\nidentified when you registered with developerWorks. Select information in your\ndeveloperWorks profile is displayed to the public, but you may edit the\ninformation at any time. Your first name, last name (unless you choose to hide\nthem), and display name will accompany the content that you post.\n\nAll information submitted is secure.\n\nClose [x]\n\n# Choose your display name\n\nThe first time you sign in to developerWorks, a profile is created for you, so\nyou need to choose a display name. Your display name accompanies the content\nyou post on developerWorks.\n\nPlease choose a display name between 3-31 characters. Your display name must\nbe unique in the developerWorks community and should not be your email address\nfor privacy reasons.\n\nAll information submitted is secure.\n\nRate this article\n\nError: Submission failed. Please try again.\n\nComments\n\nSign in or register to leave a comment.\n\nNote: HTML elements are not supported within comments.\n\nThere is a problem in retrieving the comments. Please refresh the page later.  \n---  \n  \nBack to top\n\nClose [x]\n\nHelp: Update or add to My dW interests\n\n# What's this?\n\nThis little timesaver lets you update your My developerWorks profile with just\none click! The general subject of this content (AIX and UNIX, Information\nManagement, Lotus, Rational, Tivoli, WebSphere, Java, Linux, Open source, SOA\nand Web services, Web development, or XML) will be added to the interests\nsection of your profile, if it's not there already. You only need to be logged\nin to My developerWorks.\n\nAnd what's the point of adding your interests to your profile? That's how you\nfind other users with the same interests as yours, and see what they're\nreading and contributing to the community. Your interests also help us\nrecommend relevant developerWorks content to you.\n\nView your My developerWorks profile\n\nReturn from help\n\nClose [x]\n\nHelp: Remove from My dW interests\n\n# What's this?\n\nRemoving this interest does not alter your profile, but rather removes this\npiece of content from a list of all content for which you've indicated\ninterest. In a future enhancement to My developerWorks, you'll be able to see\na record of that content.\n\nView your My developerWorks profile\n\nReturn from help\n\nstatic.content.url=http://www.ibm.com/developerworks/js/artrating/\n\nSITE_ID=1\n\nZone=Java technology\n\nArticleID=600180\n\nArticleTitle=Solving the Expression Problem with Clojure 1.2\n\npublish-date=12142010\n\nauthor1-email=stuart.sierra@thinkrelevance.com\n\nauthor1-email-cc=jaloi@us.ibm.com\n\nurl=http://www.ibm.com/developerworks/java/library/j-clojure-protocols/\n\n## Table of contents\n\n  * Many types, one interface\n  * The Expression Problem\n  * Potential \"solutions\"\n  * Protocols\n  * Datatypes\n  * Interacting with Java code\n  * Conclusion\n  * Resources\n  * About the author\n  * Comments\n\n## Local resources\n\n  * IBM Innovation Center - Austin, TX\n  * IBM Innovation Center - Chicago, IL\n  * IBM Innovation Center - Dallas, TX\n  * IBM Innovation Center - San Mateo, CA\n  * IBM Innovation Center - Waltham, MA\n  * Technical Briefings in North America\n\n## Tags\n\nUse the search field to find all types of content in My developerWorks with\nthat tag.\n\nUse the slider bar to see more or fewer tags.\n\nFor articles in technology zones (such as Java technology, Linux, Open source,\nXML), Popular tags shows the top tags for all technology zones. For articles\nin product zones (such as Info Mgmt, Rational, WebSphere), Popular tags shows\nthe top tags for just that product zone.\n\nFor articles in technology zones (such as Java technology, Linux, Open source,\nXML), My tags shows your tags for all technology zones. For articles in\nproduct zones (such as Info Mgmt, Rational, WebSphere), My tags shows your\ntags for just that product zone.\n\nUse the search field to find all types of content in My developerWorks with\nthat tag. Popular tags shows the top tags for this particular content zone\n(for example, Java technology, Linux, WebSphere). My tags shows your tags for\nthis particular content zone (for example, Java technology, Linux, WebSphere).\n\nPopular article tags | My article tagsSkip to tags list\n\nPopular article tags | My article tags\n\nSkip to tags list\n\n## Dig deeper into Java on developerWorks\n\n  * Overview\n  * New to Java programming\n  * Downloads and products\n  * Open source projects\n  * Standards\n  * Technical library (articles, tutorials, and more)\n  * Forums\n  * Events\n  * Newsletter\n\n## Seeking nominations\n\nNominate IBM Champions: experts who help you build a smarter planet with IBM\n\n## Special offers\n\nTrial software offers\n\n  * Print this page\n\n  * Share this page\n  * Follow developerWorks\n\n## Share this page:\n\n  * Facebook\n  * LinkedIn\n  * Twitter\n\n  * Delicious\n  * Digg\n  * StumbleUpon\n\n  * Email this page\n\n  * Close [x]\n\n## Follow developerWorks:\n\n  * Facebook\n  * Twitter\n\n  * Close [x]\n\n## Technical topics\n\n  * AIX and UNIX\n  * IBM i\n  * Information Management\n  * Lotus\n  * Rational\n  * Tivoli\n  * WebSphere\n\n  * Cloud computing\n  * Industries\n  * Integrated Service Management\n\n  * Java technology\n  * Linux\n  * Open source\n  * SOA and web services\n  * XML\n\n## More...\n\n## Evaluation software\n\n  * By IBM product\n  * By evaluation method\n  * By industry\n\n## Events\n\n  * Briefings\n  * Webcasts\n  * Find events\n\n## Community\n\n  * Forums\n  * Groups\n  * Blogs\n  * Wikis\n  * Terms of use\n  * Report abuse\n\n  * IBM Champion program\n\n## More...\n\n## About developerWorks\n\n  * Site help and feedback\n  * Contacts\n  * Article submissions\n\n## Related resources\n\n  * Students and faculty\n  * Business Partners\n\n## IBM\n\n  * Solutions\n  * Software\n  * Software services\n  * Support\n  * Product information\n  * Redbooks\n  * Privacy\n  * Accessibility\n\n", "frontpage": false}
