{"aid": "40283690", "title": "Htmx and Servant: Seamless and powerful handling of HTTP errors in Htmx", "url": "https://silky.github.io/posts/htmx-haskell-interview.html", "domain": "silky.github.io", "votes": 1, "user": "thunderbong", "posted_at": "2024-05-07 09:15:58", "comments": 0, "source_title": "Noon van der Silk - HTMX and Servant: Seamless and powerful handling of HTTP errors in HTMX", "source_text": "Noon van der Silk - HTMX and Servant: Seamless and powerful handling of HTTP\nerrors in HTMX\n\n# Noon van der Silk\n\nAbout Archive Between Books Talks Links Atom Feed\n\n## HTMX and Servant: Seamless and powerful handling of HTTP errors in HTMX\n\nPosted on May 6, 2024 by Noon van der Silk\n\nAs part of the interview process for a company I was recently rejected by, I\nwrote a blog post about HTMX and Haskell (and, JavaScript, but that was just a\nrequirement :D).\n\nI think the post is interesting in any case, so here it is :) The Haskell\ncomponent is in the Bonus content. If you want to skip straight to the code,\nyou can just go direct to the repo: htmx-servant-js-example.\n\n# Seamless and powerful handling of HTTP errors in HTMX\n\nHTMX is a popular front-end JavaScript library that can be used to create\nsimple dynamic UIs. But how robust is it? Is it ready for production use? And\nwhat are its features, anyway? Let\u2019s explore it together by building an image\nconversion app.\n\n## Problem\n\nYou are building a dynamic UI and calling endpoints that will either fail or\nreturn some content to render. You want to handle both these cases with the\nsimplest code possible.\n\nA typical workflow somewhere in your code is to query the endpoint, check the\nstatus of what happened, and act accordingly:\n\n    \n    \n    fetch(url) .then( (result) => { if (result.ok) { // Everything is good! } else { // Something else ... } })\n\nIt\u2019s a bit of a hassle to write this logic all over the place. Can HTMX help\nus out here? How does it look for something non-trivial, and what are the\ncaveats we should be aware of?\n\n## Solution\n\nLet\u2019s take the example of uploading an image and converting it from a PNG to a\nJPG.\n\nNaturally, HTMX can do the happy-path, when there are no errors, easily. We\ndefine the form, with the HTMX attributes to define how the DOM changes based\non the result:\n\n    \n    \n    <!-- index.html --> <script src=\"https://unpkg.com/htmx.org@1.9.11\"></script> ... <body> <form hx-encoding=\"multipart/form-data\" hx-post=\"/upload\" hx-target=\"#result\" hx-swap=\"innerHTML\" > <input type=\"file\" name=\"image\" accept=\"image/png\" /> <button>Upload</button> </form> <div id=\"result\"></div> </bod>\n\nOn the server, at the /upload route, we return an HTML element:\n\n    \n    \n    // server.js endpoint definition app.post(\"/upload\", async function(req, resp) { // image conversion steps; new image in `newPath`. // ... // send the resulting path back as an \"img\" tag resp.send(`<img src=\"${newPath}\" />`); });\n\nHere\u2019s what it looks like:\n\nIt\u2019s interesting to note:\n\n  * It looks pretty smooth!\n  * We tell HTMX which element to update (via a CSS selector) with hx-target,\n  * We tell it how with hx-swap (it\u2019s important that we use innerHTML so the main target element persists if we upload a different image),\n\nThese are some questions I\u2019m asking myself at this point:\n\n  * What would happen if we didn\u2019t return a HTML element from the response?\n  * What would happen if we didn\u2019t return HTTP status 200?\n\nWe can actually already answer the first question, given what we know about\ninnerHTML: whatever text is returned from our /upload route is directly set as\nthe innerHTML, so we best make sure it\u2019s valid HTML :)\n\nFor our second question, let\u2019s just try it!\n\n    \n    \n    // update server.js to just through an error: app.post(\"/upload\", async function(req, resp) { return resp.status(500).send(`Sorry, no thanks.`); }\n\nThen:\n\nWe can see that nothing gets rendered, and we see the errors in the console.\n\nWith what we\u2019ve seen so far, we would be justified in assuming that the text\nSorry, no thanks might have come through to the <div id=\"result\"> element, but\nin fact if the response is a HTTP error code HTMX doesn\u2019t perform subsequent\nsteps (typically a good idea when something has gone wrong!)\n\nLuckily, there is an extension: response-targets that we can use to get the\nbehaviour we are after. Phew! We can make the following modifications to our\nindex.html page:\n\n    \n    \n    <!-- index.html --> <script src=\"https://unpkg.com/htmx.org@1.9.11\"></script> <script src=\"https://unpkg.com/htmx.org@1.9.11/dist/ext/response-targets.js\"></script> ... <body hx-ext=\"response-targets\"> <form hx-encoding=\"multipart/form-data\" hx-post=\"/upload\" hx-target=\"#result\" hx-target-error=\"#result\" hx-swap=\"innerHTML\" > <input type=\"file\" name=\"image\" accept=\"image/png\" /> <button> Upload </button> </form> <div id=\"result\"></div> </body>\n\nWhat did we do?\n\n  * We added a dependency on dist/ext/response-targets.js\n  * We added `hx-ext=\u201cresponse-targets\u201d to the parent of the elements we want to use it on (read more about hx-ext; I forgot this initially and was wondering why it didn\u2019t work!)\n  * We used the catch-all hx-target-error to send all errors to the id=\"result\" element, just for simplicity (you can target specific error codes if you wish).\n\nHere\u2019s how it looks now:\n\nSuccess! We see the error rendered in the page! And in the case that we don\u2019t\nhit an error, we will still render the image directly as well. That\u2019s exactly\nwhat we wanted! :)\n\n## Discussion\n\nIt\u2019s pretty nice to use HTMX to handle HTTP errors from your API: use\nresponse-targets to pick up specific errors, or all of them, and render the\ncontents directly in the page!\n\nA small detail that I came across along the way is the difference between\nouterHTML and innerHTML and what you might consider repeated behaviour while\npreserving the most \u201cmeaningful\u201d structure for your HTMX documents.\n\nThe scenario is this: Imagine you want to repeatedly convert images; then you\nneed to make sure that the HTML element of hx-target persists; with innerHTML\nit always will, but with outerHTML it will be replaced. The advantage of\nouterHTML is it\u2019s a bit more \u201cmeaningful\u201d to replace an <img> tag with another\n<img> tag; and likewise. But, ultimately, it\u2019s up to you to pick the style you\nprefer.\n\n## Bonus content: The server is now in Haskell\n\nHTMX is, after all, a front-end technology, so we can continue to use it if we\nhave our server in a different language.\n\nIt turns out Haskell will let us express one interesting requirement of using\nHTMX: our routes should return HTML, not, say, JSON, or plain text.\n\nIn the Servant ecosystem, you would having something like the following^1 to\ndefine the /upload endpoint:\n\n    \n    \n    -- Main.hs data Routes mode = Routes { upload :: mode :- \"upload\" :> MultipartForm Mem (MultipartData Mem) :> Post '[HTML] Html , ... }\n\nAnd then something like this \ud83d\udc47 (with a few details left out) to do what the\nJavaScript server.js was doing before: read exactly one image from the form,\nthrow an error if not, and otherwise take the image, convert it to a JPG, and\nreturn the new path as an <img ... /> tag:\n\n    \n    \n    -- Main.hs uploadAndConvert :: MultipartData Mem -> Handler Html uploadAndConvert form = do newPath <- case (files form) of [] -> oops \"No files uploaded!\" f : [] -> liftIO $ do let jpg = ... newPath = ... BIO.writeFile newPath jpg pure newPath ... pure $ [shamlet| <img src=#{newPath} /> |] where oops m = throwError $ err500 { errBody = m }\n\nIt is a requirement of the type system to make sure that this particular\nendpoint returns HTML! It\u2019s then a small exercise to ensure that any error\ncontent comes through with the appropriate HTML wrapping :) Happy Haskelling!\n\n  1. Note we\u2019ve left off important import statements, but you can find these in the full code snippet.\u21a9\ufe0e\n\nHakyll was involved here (source). \u0646\n\n", "frontpage": false}
