{"aid": "40291490", "title": "Jolie, the service-oriented programming language", "url": "https://www.jolie-lang.org/index.html", "domain": "jolie-lang.org", "votes": 20, "user": "todsacerdoti", "posted_at": "2024-05-07 21:07:33", "comments": 4, "source_title": "Jolie, the service-oriented programming language", "source_text": "Jolie Programming Language - Official Website\n\n  * Home\n  * Download\n  * News (from )\n  * Docs\n  * Vision\n  * About\n  * FAQ\n\n# Jolie\n\n## The service-oriented programming language\n\nDownload Docs Vision\n\n    \n    \n    type HelloRequest { name:string } interface HelloInterface { requestResponse: hello( HelloRequest )( string ) } service HelloService { execution: concurrent inputPort HelloService { location: \"socket://localhost:9000\" protocol: http { format = \"json\" } interfaces: HelloInterface } main { hello( request )( response ) { response = \"Hello \" + request.name } } }\n\nNext\n\n## Thinking in services\n\nJolie crystallises the programming concepts of service-oriented computing as\nlinguistic constructs. The basic building blocks of software are not objects\nor functions, but rather services that can be relocated and replicated as\nneeded. A composition of services is a service.\n\nNext\n\n## Get Started Now\n\nFollow this tutorial to start your first Jolie project.\n\nNext\n\n## Tailored for microservices and APIs\n\nJolie is a contract-first programming language, which puts API design at the\nforefront. It supports both synchronous and asynchronous communication. Data\nmodels are defined by types that support refinement (in red on the right), and\nDTO (Data Transfer Objects) transformations are transparently managed by the\ninterpreter.\n\n    \n    \n    type GetProfileRequestType { id:int } type GetProfileResponseType { name:string surname:string email:string( regex(\".*@.*\\\\..*\") ) accounts[0,*] { nickname:string service_url:string enabled:bool } ranking:int( ranges( [1,5] ) ) } type SendMessageRequestType { id:int message:string( length( [0,250] ) ) } interface ProfileInterface { requestResponse: // Synchronous RPC getProfile( GetProfileRequestType )( GetProfileResponseType ) oneWay: // Asynchronous sendMessage( SendMessageRequestType ) }\n\nNext\n\n## Built for the networked age\n\nJolie code is always contained in services, which you can always move from\nbeing local to remote and vice versa, without altering the logic of your\nprograms. A monolithical application can scale to being distributed by design:\nif you decide to distribute a part of it, just take it and execute it in\nanother machine.\n\n#### Program your microservice system\n\n#### Deploy it in a single machine\n\n#### Deploy it in two different machines\n\n#### Deploy it in four different machines\n\nNext\n\n## Protocol agnostic\n\nJolie is protocol agnostic: your services can exchange data by using different\nprotocols. Bridging two networks using different protocols is a matter of a\nfew lines of code. If you need a protocol that Jolie does not support yet,\nthere is an API for developing new ones in Java.\n\n    \n    \n    type HelloRequest { name:string } interface HelloInterface { requestResponse: hello( HelloRequest )( string ) } service HelloService { execution { concurrent } inputPort HelloServiceHTTP { location: \"socket://localost:9000\" protocol: http { format = \"json\" } interfaces: HelloInterface } inputPort HelloServiceSOAP { location: \"socket://localost:9001\" protocol: soap { wsdl = \"myWsdl.wsdl\" wsdl.port = \"MyServiceSOAPPort\" } interfaces: HelloInterface } inputPort HelloServiceSODEP { location: \"socket://localost:9002\" protocol: sodep interfaces: HelloInterface } main { // This can now be reached through HTTP/JSON, SOAP, or SODEP (binary) hello( request )( response ) { response = \"Hello \" + request.name } } }\n\nNext\n\n## Structured workflows\n\nJolie comes with native primitives for structuring workflows, for example in\nsequences (one after the other) or parallels (go at the same time). This makes\nthe code follow naturally from the requirements, avoiding error-prone\nbookkeeping variables for checking what happened so far in a computation. For\nexample, the following code says that the operations publish and edit become\navailable at the same time (|), but only after (;) operation login is invoked:\n\n    \n    \n    login( credentials )() { checkCredentials }; { publish( x ) | edit( y ) }\n\n## Dynamic error handling for parallel code\n\nProgramming reliable parallel code is challenging because faults may cause\nside-effects in parallel activities. Jolie comes with a solid semantics for\nparallel fault handling. Programmers can update the behaviour of fault\nhandlers at runtime, following the execution of activities thanks to the\ninstall primitive.\n\n    \n    \n    include \"console.iol\" include \"time.iol\" main { scope( grandFather ) { install( this => println@Console( \"recovering grandFather\" )() ); scope( father ) { install( this => println@Console( \"recovering father\" )() ); scope ( son ) { install( this => println@Console( \"recovering son\" )() ); sleep@Time( 500 )(); println@Console( \"Son's code block\" )() } } } | throw( a_fault ) }\n\nNext\n\n## Everything you build can be used to build again\n\nJolie offers many ways for building complex software from simple services.\nEven the deployment architecture of a system can be programmed with native\nprimitives, generalising common practices. Whatever you build, is again a\nservice that you can expose; so, it can be reused to build again! Here are\nsome examples of composition:\n\nOrchestration: an orchestrator is a service that offers functionalities\nobtained by coordinating other services with a workflow.\n\nAggregation: a generalisation of proxies and load balancers, which you can use\nto compose and expose the APIs of separate services\n\nRedirection: a generalisation of virtual servers, which hides the actual\nlocations of services to clients by assigning logical names to services.\n\nEmbedding: a generalisation of application servers, which runs other services\nas inner components. It enables fast local communications and can even run\ncode written in different languages than Jolie, such as Java and Javascript\n(with more coming)!\n\nNext\n\n## Revolutionise the way you develop web applications\n\nJolie allows for directly programming a web server that is just a service as\neverything else in Jolie. You don't need other extra frameworks for\ninstantiating a web server.\n\nIt is possible to directly aggregate other service APIs into a Jolie web\nserver, thus web GUIs are completely independent from the microservice system\nthey interact with. We natively support JSON, XML, AJAX, ND-JSON and other\ntechnologies.\n\nNext\n\n## Solid foundations\n\nJolie comes with formal specifications of its semantics. It is used in\nComputer Science research and teaching at several universities around the\nworld.\n\nNext\n\n## Join us!\n\nJolie is an open source project, with a growing community of contributors and\nusers that you are welcome to join. Check out our project news.\n\n## Stakeholders and Supporters\n\nCopyright (C) 2014-2020 The Jolie Team. This work is licensed under a Creative\nCommons Attribution 4.0 International License, except for the code samples,\nwhich are instead licensed under the GNU GPL License (v2). This website is\nmade with Jolie and is powered by Leonardo.Please contact our webmaster for\nquestions or comments concerning this website.\n\n", "frontpage": true}
