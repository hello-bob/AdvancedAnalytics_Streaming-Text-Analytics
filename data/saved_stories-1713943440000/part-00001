{"aid": "40139378", "title": "The Guide To Git I never had", "url": "https://glasskube.dev/guides/git/", "domain": "glasskube.dev", "votes": 3, "user": "endingwithali", "posted_at": "2024-04-24 01:23:30", "comments": 0, "source_title": "The guide to Git I never had. | Glasskube.dev", "source_text": "The guide to Git I never had. | Glasskube.dev\n\nSkip to main content\n\n\ud83c\udf89\ufe0f glasskube/glasskube Beta is launching on Producthunt \ud83e\udd73\ufe0f\n\n# The guide to Git I never had.\n\n\ud83e\ude7a Doctors have stethoscopes. \ud83d\udd27 Mechanics have spanners. \ud83d\udc68\ud83d\udcbb We developers, have\nGit.\n\nHave you noticed that Git is so integral to working with code that people\nhardly ever include it in their tech stack or on their CV at all? The\nassumption is you know it already, or at least enough to get by, but do you?\n\nGit is a Version Control System (VCS). The ubiquitous technology that enables\nus to store, change, and collaborate on code with others.\n\n> \ud83d\udea8 As a disclaimer, I would like to point out that Git is a massive topic.\n> Git books have been written, and blog posts that could be mistaken for\n> academic papers too. That's not what I\u2019m going for here. I'm no Git expert.\n> My aim here is to write the Git fundamentals post I wish I had when learning\n> Git.\n\nAs developers, our daily routine revolves around reading, writing, and\nreviewing code. Git is arguably one of the most important tools we use.\nMastering the features and functionalities Git offers is one of the best\ninvestments you can make in yourself as a developer.\n\nSo let\u2019s get started\n\n> If you feel I missed or should go into more detail on a specific command,\n> let me know in the comments below. And I will update this post accordingly.\n> \ud83d\ude4f\n\n## While we are on the topic\n\nIf you are looking to put your Git skills to work and would like to contribute\nto Glasskube, we officially launched in February and we aim to be the no-\nbrainer, default solution for Kubernetes package management. With your\nsupport, we can make it happen. The best way to show your support is by\nstarring us on GitHub \u2b50\n\nStar\n\n## Let\u2019s lay down the foundations\n\nDoes Git ever make you feel like Peter Griffin? If you don\u2019t learn Git the\nright way you run the risk of constantly scratching your head, getting stuck\non the same issues, or rueing the day you see another merge conflict appear in\nyour terminal. Let's ensure that doesn\u2019t happen by defining some foundational\nGit concepts.\n\n### Branches\n\nIn a Git repository, you'll find a main line of development, typically named\n\"main\" or \"master\" (deprecated) from which several branches diverge. These\nbranches represent simultaneous streams of work, enabling developers to tackle\nmultiple features or fixes concurrently within the same project.\n\n### Commits\n\nGit commits serve as bundles of updated code, capturing a snapshot of the\nproject's code at a specific point in time. Each commit records changes made\nsince the last commit was recorded, all together building a comprehensive\nhistory of the project's development journey.\n\nWhen referencing commits you will generally use its uniquely identified\ncryptographic hash.\n\nExample:\n\n    \n    \n    git show abc123def456789\n\nThis shows detailed information about the commit with that hash.\n\n### Tags\n\nGit tags serve as landmarks within the Git history, typically marking\nsignificant milestones in a project's development, such as releases, versions,\nor standout commits. These tags are invaluable for marking specific points in\ntime, often representing the starting points or major achievements in a\nproject's journey.\n\n### HEAD\n\nThe most recent commit on the currently checked-out branch is indicated by the\nHEAD, serving as a pointer to any reference within the repository. When you're\non a specific branch, HEAD points to the latest commit on that branch.\nSometimes, instead of pointing to the tip of a branch, HEAD can directly point\nto a specific commit (detached HEAD state).\n\n### Stages\n\nUnderstanding Git stages is crucial for navigating your Git workflow. They\nrepresent the logical transitions where changes to your files occur before\nthey are committed to the repository. Let's delve into the concept of Git\nstages:\n\n#### Working directory \ud83d\udc77\n\nThe working directory is where you edit, modify, and create files for your\nproject. Representing the current state of your files on your local machine.\n\n#### Staging area \ud83d\ude89\n\nThe staging area is like a holding area or a pre-commit zone where you prepare\nyour changes before committing them to the repository.\n\n> Useful command here: git add Also git rm can be used to unstage changes\n\n#### Local repository \ud83d\uddc4\ufe0f\n\nThe local repository is where Git permanently stores the committed changes. It\nallows you to review your project's history, revert to previous states, and\ncollaborate with others on the same codebase.\n\n> You can commit changes that are ready in the staging area with: git commit\n\n#### Remote repository \ud83d\udeeb\n\nThe remote repository is a centralized location, typically hosted on a server\n(like GitHub, GitLab, or Bitbucket), where you can share and collaborate with\nothers on your project.\n\n> You can use commands like git push and git pull to push/pull your committed\n> changes from your local repository to the remote repository.\n\n## Getting Started with Git\n\nWell, you have to start somewhere, and in Git that is your workspace. You can\nfork or clone an existing repository and have a copy of that workspace, or if\nyou are starting completely fresh in a new local folder on your machine you\nhave to turn it into a git repository with git init. The next step, crucially\nnot to be overlooked is setting up your credentials.\n\n### Credentials set up\n\nWhen running pushing and pulling to a remote repository you don\u2019t want to have\nto type your username and password every time, avoid that by simply executing\nthe following command:\n\n    \n    \n    git config --global credential.helper store\n\nThe first time you interact with the remote repository, Git will prompt you to\ninput your username and password. And after that, you won\u2019t be prompted again\n\n> It's important to note that the credentials are stored in a plaintext format\n> within a .git-credentials file.\n\nTo check the configured credentials, you can use the following command:\n\n    \n    \n    git config --global credential.helper\n\n### Working with branches\n\nWhen working locally it\u2019s crucial to know which branch you are currently on.\nThese commands are helpful:\n\n    \n    \n    # Will show the changes in the local repository git branch\n    \n    # Or create a branch directly with git branch feature-branch-name\n\nTo transition between branches use:\n\n    \n    \n    git switch\n\nAdditionally to transitioning between them, you can also use:\n\n    \n    \n    git checkout # A shortcut to switch to a branch that is yet to be created with the -b flag git checkout -b feature-branch-name\n\nTo check the repository's state, use:\n\n    \n    \n    git status\n\nA great way to always have a clear view of your current branch is to see it\nright in the terminal. Many terminal add-ons can help with this. Here is one.\n\n### Working with commits\n\nWhen working with commits, utilize git commit -m to record changes, git amend\nto modify the most recent commit, and try your best to adhere to commit\nmessage conventions.\n\n    \n    \n    # Make sure to add a message to each commit git commit -m \"meaningful message\"\n\nIf you have changes to your last commit, you don\u2019t have to create another\ncommit altogether, you can use the -\u2014amend flag to amend the most recent\ncommit with your staged changes\n\n    \n    \n    # make your changes git add . git commit --amend # This will open your default text editor to modify the commit message if needed. git push origin your_branch --force\n\n> \u26a0\ufe0f Exercise caution when utilizing --force, as it has the potential to\n> overwrite the history of the target branch. Its application on the\n> main/master branch should be generally avoided.\n\n> As a rule of thumb it's better to commit more often than not, to avoid\n> losing progress or accidentally resetting the unstaged changes. One can\n> rewrite the history afterward by squashing multiple commits or doing an\n> interactive rebase.\n\nUse git log to show a chronological list of commits, starting from the most\nrecent commit and working backward in time\n\n## Manipulating History\n\nManipulating History involves some powerful commands. Rebase rewrites commit\nhistory, Squashing combines multiple commits into one, and Cherry-picking\nselects specific commits.\n\n### Rebasing and merging\n\nIt makes sense to compare rebasing to merging since their aim is the same but\nthey achieve it in different ways. The crucial difference is that rebasing\nrewrites the project's history. A desired choice for projects that value clear\nand easily understandable project history. On the other hand, merging\nmaintains both branch histories by generating a new merge commit.\n\nDuring a rebase, the commit history of the feature branch is restructured as\nit's moved onto the HEAD of the main branch\n\nThe workflow here is pretty straightforward.\n\nEnsure you're on the branch you want to rebase and fetch the latest changes\nfrom the remote repository:\n\n    \n    \n    git checkout your_branch git fetch\n\nNow choose the branch you want to rebase onto and run this command:\n\n    \n    \n    git rebase upstream_branch\n\nAfter rebasing, you might need to force-push your changes if the branch has\nalready been pushed to a remote repository:\n\n    \n    \n    git push origin your_branch --force\n\n> \u26a0\ufe0f Exercise caution when utilizing --force, as it has the potential to\n> overwrite the history of the target branch. Its application on the\n> main/master branch should be generally avoided.\n\n### Squashing\n\nGit squashing is used to condense multiple commits into a single, cohesive\ncommit.\n\nThe concept is easy to understand and especially useful if the method of\nunifying code that is used is rebasing, since the history will be altered,\nit\u2019s important to be mindful of the effects on the project history. There have\nbeen times I have struggled to perform a squash, especially using interactive\nrebase, luckily we have some tools to help us. This is my preferred method of\nsquashing which involves moving the HEAD pointer back X number of commits\nwhile keeping the staged changes.\n\n    \n    \n    # Change to the number after HEAD~ depending on the commits you want to squash git reset --soft HEAD~X git commit -m \"Your squashed commit message\" git push origin your_branch --force\n\n> \u26a0\ufe0f Exercise caution when utilizing --force, as it has the potential to\n> overwrite the history of the target branch. Its application on the\n> main/master branch should be generally avoided.\n\n### Cherry-picking\n\nCherry-picking is useful for selectively incorporating changes from one branch\nto another, especially when merging entire branches is not desirable or\nfeasible. However, it's important to use cherry-picking judiciously, as it can\nlead to duplicate commits and divergent histories if misapplied\n\nTo perform this first you have to identify the commit hash of the commit you\nwould like to pick, you can do this with git log. Once you have the commit\nhash identified you can run:\n\n    \n    \n    git checkout target_branch git cherry-pick <commit-hash> # Do this multiple times if multiple commits are wanted git push origin target_branch\n\n## Advanced Git Commands\n\n### Signing commits\n\nSigning commits is a way to verify the authenticity and integrity of your\ncommits in Git. It allows you to cryptographically sign your commits using\nyour GPG (GNU Privacy Guard) key, assuring Git that you are indeed the author\nof the commit. You can do so by creating a GPG key and configuring Git to use\nthe key when committing. Here are the steps:\n\n    \n    \n    # Generate a GPG key gpg --gen-key\n    \n    # Configure Git to Use Your GPG Key git config --global user.signingkey <your-gpg-key-id>\n    \n    # Add the public key to your GitHub account\n    \n    # Signing your commits with the -S flag git commit -S -m \"Your commit message\"\n    \n    # View signed commits git log --show-signature\n\n### Git reflog\n\nA topic that we haven\u2019t explored is Git references, they are pointers to\nvarious objects within the repository, primarily commits, but also tags and\nbranches. They serve as named points in the Git history, allowing users to\nnavigate through the repository's timeline and access specific snapshots of\nthe project. Knowing how to navigate git references can be very useful and\nthey can use git reflog to do just that. Here are some of the benefits:\n\n  * Recovering lost commits or branches\n  * Debugging and troubleshooting\n  * Undoing mistakes\n\n### Interactive rebase\n\nInteractive rebase is a powerful Git feature that allows you to rewrite commit\nhistory interactively. It enables you to modify, reorder, combine, or delete\ncommits before applying them to a branch.\n\nIn order to use it you have to become familiar with the possible actions such\nare:\n\n  * Pick (\u201cp\u201c)\n  * Reword (\u201cr\u201c)\n  * Edit (\u201ce\u201c)\n  * Squash (\u201cs\u201c)\n  * Drop (\u201cd\u201c)\n\nHere is a useful video to learn how to perform an interactive rebase in the\nterminal, I have also linked a useful tool at the bottom of the blog post.\n\n## Collaborating with Git\n\n### Origin vs Upstream\n\nThe origin is the default remote repository associated with your local Git\nrepository when you clone it. If you've forked a repository, then that fork\nbecomes your \"origin\" repository by default.\n\nUpstream on the other hand refers to the original repository from which your\nrepository was forked.\n\nTo keep your forked repository up-to-date with the latest changes from the\noriginal project, you git fetch changes from the \"upstream\" repository and\nmerge or rebase them into your local repository.\n\n    \n    \n    # By pulling the pulled changes will be merged into your working branch git pull <remote_name> <branch_name> # If you don't want to merge the changes use git fetch <remote_name>\n\nTo see the remote repositories associated with you local Git repo, run:\n\n    \n    \n    git remote -v\n\n### Conflicts\n\nDon\u2019t panic, when trying to merge or rebase a branch and conflicts are\ndetected it only means that there are conflicting changes between different\nversions of the same file or files in your repository and they can be easily\nresolved (most times).\n\nThey are typically indicated within the affected files, where Git inserts\nconflict markers <<<<<<<, ======= and >>>>>>> to highlight the conflicting\nsections. Decide which changes to keep, modify, or remove, ensuring that the\nresulting code makes sense and retains the intended functionality.\n\nAfter manually resolving conflicts in the conflicted files, remove the\nconflict markers <<<<<<<, =======, and >>>>>>> and adjust the code as\nnecessary.\n\nSave the changes in the conflicted files once you're satisfied with the\nresolution.\n\n> If you have issues resolving conflicts, this video does a good job at\n> explaining it.\n\n## Popular Git workflows\n\nVarious Git workflows exist, however, it's important to note that there's no\nuniversally \"best\" Git workflow. Instead, each approach has its own set of\npros and cons. Let's explore these different workflows to understand their\nstrengths and weaknesses.\n\n### Feature Branch Workflow \ud83c\udf31\n\nEach new feature or bug fix is developed in its own branch and then merge it\nback into the main branch once completed by opening a PR.\n\n>   * Strength: Isolation of changes and reducing conflicts.\n>   * Weakness: Can become complex and require diligent branch management.\n>\n\n### Gitflow Workflow \ud83c\udf0a\n\nGitflow defines a strict branching model with predefined branches for\ndifferent types of development tasks.\n\nIt includes long-lived branches such as main, develop, feature branches,\nrelease branches, and hotfix branches.\n\n>   * Strength: Suitable for projects with scheduled releases and long-term\n> maintenance.\n>   * Weakness: Can be overly complex for smaller teams\n>\n\n### Forking Workflow \ud83c\udf74\n\nIn this workflow, each developer clones the main repository, but instead of\npushing changes directly to it, they push changes to their own fork of the\nrepository. Developers then create pull requests to propose changes to the\nmain repository, allowing for code review and collaboration before merging.\n\nThis is the workflow we use to collaborate on the open-source Glasskube repos.\n\n>   * Strength: Encourages collaboration from external contributors without\n> granting direct write access to the main repository.\n>   * Weakness: Maintaining synchronization between forks and the main\n> repository can be challenging.\n>\n\n### Trunk-Based Development \ud83e\udeb5\n\nIf you are on a team focused on rapid iteration and continuous delivery, you\nmight use trunk-based development which developers work directly on the main\nbranch committing small and frequent changes.\n\n>   * Strength: Promotes rapid iteration, continuous integration, and a focus\n> on delivering small, frequent changes to production.\n>   * Weakness: Requires robust automated testing and deployment pipelines to\n> ensure the stability of the main branch, may not be suitable for projects\n> with stringent release schedules or complex feature development.\n>\n\n### What the fork?\n\nForking is highly recommended for collaborating on Open Source projects since\nyou have complete control over your own copy of the repository. You can make\nchanges, experiment with new features, or fix bugs without affecting the\noriginal project.\n\n> \ud83d\udca1 What took me a long time to figure out was that although forked\n> repositories start as separate entities, they retain a connection to the\n> original repository. This connection allows you to keep track of changes in\n> the original project and synchronize your fork with updates made by others.\n\nThat\u2019s why even when you push to your origin repository. Your changes will\nshow up on the remote also.\n\n## Git Cheatsheet\n\n    \n    \n    # Clone a Repository git clone <repository_url>\n    \n    # Stage Changes for Commit git add <file(s)>\n    \n    # Commit Changes git commit -m \"Commit message\"\n    \n    # Push Changes to the Remote Repository git push\n    \n    # Force Push Changes (use with caution) git push --force\n    \n    # Reset Working Directory to Last Commit git reset --hard\n    \n    # Create a New Branch git branch <branch_name>\n    \n    # Switch to a Different Branch git checkout <branch_name>\n    \n    # Merge Changes from Another Branch git merge <branch_name>\n    \n    # Rebase Changes onto Another Branch (use with caution) git rebase <base_branch>\n    \n    # View Status of Working Directory git status\n    \n    # View Commit History git log\n    \n    # Undo Last Commit (use with caution) git reset --soft HEAD^\n    \n    # Discard Changes in Working Directory git restore <file(s)>\n    \n    # Retrieve Lost Commit References git reflog\n    \n    # Interactive Rebase to Rearrange Commits git rebase --interactive HEAD~3\n    \n    # Pull changes from remote repo git pull <remote_name> <branch_name>\n    \n    # Fetch changes from remote repo git fetch <remote_name>\n\n## Bonus! Some Git tools and resources to make your life easier.\n\n  * Tool for interactive rebasing.\n\n  * Cdiff to view colorful, incremental diffs.\n\n  * Interactive Git branching playground\n\nIf you like this sort of content and would like to see more of it, please\nconsider supporting us by giving us a Star on GitHub \ud83d\ude4f\n\nStar\n\nLast updated on Apr 23, 2024 by Philip Miglinci\n\nDocs\n\n  * Architecture\n  * Getting started\n\nComparisons\n\n  * Glasskube vs Helm\n  * Glasskube vs Timoni\n  * Glasskube vs OLM\n\nCommunity\n\n  * Discord\n  * Twitter / X\n  * LinkedIn\n  * GitHub\n\nMore\n\n  * Blog\n  * Contact / Book appointment\n  * Imprint\n  * Data privacy policy\n\nCopyright \u00a9 2024 Glasskube Built with Docusaurus.\n\n", "frontpage": false}
