{"aid": "40176544", "title": "The importance of an ordinary space in a Unix shell command line", "url": "https://utcc.utoronto.ca/~cks/space/blog/unix/ShellImportanceOfASpace", "domain": "utcc.utoronto.ca", "votes": 3, "user": "thunderbong", "posted_at": "2024-04-27 02:18:56", "comments": 0, "source_title": "Chris's Wiki :: blog/unix/ShellImportanceOfASpace", "source_text": "Chris's Wiki :: blog/unix/ShellImportanceOfASpace\n\nChris Siebenmann :: CSpace \u00bb blog \u00bb unix \u00bb ShellImportanceOfASpace\n\nWelcome, guest.\n\n## The importance of an ordinary space in a Unix shell command line\n\nApril 25, 2024\n\nIn the sidebar to yesterday's entry I (originally) made a Unix command line\nmistake by unthinkingly leaving out an ordinary, innocent looking space (it's\ncorrected in the current version of the entry after it was noted by Emilio in\na comment). This innocent looking mistake and its consequences are an\nillustration of something in Unix shell command lines, although I'm not sure\nof just what, so I'm going to write it up.\n\nThe story starts with the general arguments of Bash's 'read' builtin:\n\n> read [-ers] [-a aname] [-d delim] [-i text] [-n nchars] [-N nchars] [-p\n> prompt] [-t timeout] [-u fd] [name ...]\n\nThe 'read' builtin follows the general standard behavior of Unix commands\nwhere '-d delim' and other options that take an argument can be shortened to\nomit the space, so '-ddelim'. So you can write, for example:\n\n>\n>     echo \"a:b:c\" | while IFS= read -r -d':' l; do echo \"$l\"; done\n\nBash also has a special feature for -d. Normally the first character of delim\nis taken as the 'line' terminator, but if delim is blank, read will terminate\nthe line when it reads a NUL character (0 byte), which is just what you want\nto handle the output of, for example, 'find ... -print0'.\n\nThe way you create an empty string argument in a Bash command line is to use\nan empty pair of quotes:\n\n>\n>     read -r -d '' line\n\nSo when I was writing the original command line in yesterday's entry, I\nabsently mashed these two things together in my mind and wrote:\n\n>\n>     read -r -d'' line\n\nI've used '' to create an empty argument and then I've done the standard thing\nof removing the space between -d and its argument. So clearly I've given '-d'\nan empty argument, right? Nope.\n\nIn Bash and other conventional shells, '' is nothingness. It only means an\nargument that is an empty string if it occurs on its own; this is a special\ninterpretation added by the shell, and programs don't actually see the ''s. If\nyou put a '' next to other non-whitespace characters, it disappears in the\ncommand line that the program will see. So writing -d'' was the same as\nwriting -d with no argument, and the command line as 'read' would see it was\nactually:\n\n>\n>     read -r -d line\n\nWhich would have caused 'read' to use 'l' as the line terminator.\n\nIn the process of writing this entry, I realized that there's a more\ninteresting way to make what is fundamentally the same mistake, although it\ngoes deeper into Unix arcana and doesn't look half as obvious. In many modern\nshells, the Bourne shell included, you can write a NUL character (0 byte) as\n$'\\0'. So you will see people write a 'read with NUL terminated lines' command\nline as:\n\n>\n>     IFS= read -r -d $'\\0' line\n\nThis works fine, and unlike the '' case we obviously have a real argument\nhere, not just an empty argument, so clearly we can shorten this to:\n\n>\n>     IFS= read -r -d$'\\0' line\n\nIf you try this you will discover it doesn't work. The fundamental problem is\nthat Unix command line arguments can't include NUL characters, because the\nUnix command line API passes the arguments as an array of NUL-terminate (C)\nstrings. No matter how you invoke a program, the first NUL character in an\nargument is the end of that argument from the program's perspective. So\nalthough it looked very different as typed, from read's perspective what we\ndid was the same as:\n\n>\n>     IFS= read -r -d line\n\n(And then it would have the same effect as my mistake.)\n\nPS: This is a little tangled because 'read' is a Bash builtin so in theory\nBash doesn't have to stick to the limits of the kernel API, but in practice I\nthink Bash does do so.\n\n(4 comments.)\n\nWritten on 25 April 2024.\n\n| \u00ab| Pruning some things out with (GNU) find options  \n---|---  \n| I wish projects would reliably use their release announcements mechanisms| \u00bb  \n---|---  \n  \nThese are my WanderingThoughts (About the blog)\n\nFull index of entries Recent comments\n\nThis is part of CSpace, and is written by ChrisSiebenmann. Mastodon: @cks\nTwitter @thatcks\n\n* * *\n\nCategories: links, linux, programming, python, snark, solaris, spam, sysadmin,\ntech, unix, web Also: (Sub)topics\n\nThis is a DWiki. GettingAround (Help)\n\nPage tools: View Source, Add Comment.\n\nAtom Syndication: Recent Comments.\n\nLast modified: Thu Apr 25 23:17:18 2024 This dinky wiki is brought to you by\nthe Insane Hackers Guild, Python sub-branch.\n\n", "frontpage": false}
