{"aid": "40136017", "title": "Porting a cross-platform GUI application to Rust", "url": "https://hacks.mozilla.org/2024/04/porting-a-cross-platform-gui-application-to-rust/", "domain": "hacks.mozilla.org", "votes": 2, "user": "feross", "posted_at": "2024-04-23 19:17:33", "comments": 0, "source_title": "Porting a cross-platform GUI application to Rust", "source_text": "Porting a cross-platform GUI application to Rust - Mozilla Hacks - the Web\ndeveloper blog\n\n# Hacks\n\n# Porting a cross-platform GUI application to Rust\n\n### By Alex Franchuk\n\nPosted on April 23, 2024 in Crash Reporting, Developer Tools, Featured\nArticle, Firefox, rust, and Rust\n\nFirefox\u2019s crash reporter is hopefully not something that most users experience\noften. However, it is still a very important component of Firefox, as it is\nintegral in providing insight into the most visible bugs: those which crash\nthe main process. These bugs offer the worst user experience (since the entire\napplication must close), so fixing them is a very high priority. Other types\nof crashes, such as content (tab) crashes, can be handled by the browser and\nreported gracefully, sometimes without the user being aware that an issue\noccurred at all. But when the main browser process comes to a halt, we need\nanother separate application to gather information about the crash and\ninteract with the user.\n\nThis post details the approach we have taken to rewrite the crash reporter in\nRust. We discuss the reasoning behind this rewrite, what makes the crash\nreporter a unique application, the architecture we used, and some details of\nthe implementation.\n\n## Why Rewrite?\n\nEven though it is important to properly handle main process crashes, the crash\nreporter hasn\u2019t received significant development in a while (aside from\ndevelopment to ensure that crash reports and telemetry continue to reliably be\ndelivered)! It has long been stuck in a local maximum of \u201cgood enough\u201d and\n\u201cscary to maintain\u201d: it features 3 individual GUI implementations (for\nWindows, GTK+ for Linux, and macOS), glue code abstracting a few things\n(mostly in C++, and Objective-C for macOS), a binary blob produced by\nobsoleted Apple development tools, and no test suite. Because of this, there\nis a backlog of features and improvements which haven\u2019t been acted on.\n\nWe\u2019ve recently had a number of successful pushes to decrease crash rates\n(including both big leaps and many small bug fixes), and the crash reporter\nhas functioned well enough for our needs during this time. However, we\u2019ve\nreached an inflection point where improving the crash reporter would provide\nvaluable insight to enable us to decrease the crash rate even further. For the\nreasons previously mentioned, improving the current codebase is difficult and\nerror-prone, so we deemed it appropriate to rewrite the application so we can\nmore easily act on the feature backlog and improve crash reports.\n\nLike many components of Firefox, we decided to use Rust for this rewrite to\nproduce a more reliable and maintainable program. Besides the often-touted\nmemory safety built into Rust, its type system and standard library make\nreasoning about code, handling errors, and developing cross-platform\napplications far more robust and comprehensive.\n\n## Crash Reporting is an Edge Case\n\nThere are a number of features of the crash reporter which make it quite\nunique, especially compared to other components which have been ported to\nRust. For one thing, it is a standalone, individual program; basically no\nother components of Firefox are used in this way. Firefox itself launches many\nprocesses as a means of sandboxing and insulating against crashes, however\nthese processes all talk to one another and have access to the same code base.\n\nThe crash reporter has a very unique requirement: it must use as little as\npossible of the Firefox code base, ideally none! We don\u2019t want it to rely on\ncode which may be buggy and cause the reporter itself to crash. Using a\ncompletely independent implementation ensures that when a main process crash\ndoes occur, the cause of that crash won\u2019t affect the reporter\u2019s functionality\nas well.\n\nThe crash reporter also necessarily has a GUI. This alone may not separate it\nfrom other Firefox components, but we can\u2019t leverage any of the cross-platform\nrendering goodness that Firefox provides! So we need to implement a cross-\nplatform GUI independent of Firefox as well. You might think we could reach\nfor an existing cross-platform GUI crate, however we have a few reasons not to\ndo so.\n\n  * We want to minimize the use of external code: to improve crash reporter reliability (which is paramount), we want it to be as simple and auditable as possible.\n  * Firefox vendors all dependencies in-tree, so we are hesitant to bring in large dependencies (GUI libraries are likely pretty sizable).\n  * There are only a few third-party crates that provide a native OS look and feel (or actually use native GUI APIs): it\u2019s desirable for the crash reporter to have a native feel to be familiar to users and take advantage of accessibility features.\n\nSo all of this is to say that third-party cross-platform GUI libraries aren\u2019t\na favorable option.\n\nThese requirements significantly narrow the approach that can be used.\n\n## Building a GUI View Abstraction\n\nIn order to make the crash reporter more maintainable (and make it easier to\nadd new features in the future), we want to have as minimal and generic\nplatform-specific code as possible. We can achieve this by using a simple UI\nmodel that can be converted into native GUI code for each platform. Each UI\nimplementation will need to provide two methods (over arbitrary platform-\nspecific &self data):\n\n    \n    \n    /// Run a UI loop, displaying all windows of the application until it terminates. fn run_loop(&self, app: model::Application) /// Invoke a function asynchronously on the UI loop thread. fn invoke(&self, f: model::InvokeFn)\n\nThe run_loop function is pretty self-explanatory: the UI implementation takes\nan Application model (which we\u2019ll discuss shortly) and runs the application,\nblocking until the application is complete. Conveniently, our target platforms\ngenerally have similar assumptions around threading: the UI runs in a single\nthread and typically runs an event loop which blocks on new events until an\nevent signaling the end of the application is received.\n\nThere are some cases where we\u2019ll need to run a function on the UI thread\nasynchronously (like displaying a window, updating a text field, etc). Since\nrun_loop blocks, we need the invoke method to define how to do this. This\nthreading model will make it easy to use the platform GUI frameworks:\neverything calling native functions will occur on a single thread (the main\nthread in fact) for the duration of the program.\n\nThis is a good time to be a bit more specific about exactly what each UI\nimplementation will look like. We\u2019ll discuss pain points for each later on.\nThere are 4 UI implementations:\n\n  * A Windows implementation using the Win32 API.\n  * A macOS implementation using Cocoa (AppKit and Foundation frameworks).\n  * A Linux implementation using GTK+ 3 (the \u201c+\u201d has since been dropped in GTK 4, so henceforth I\u2019ll refer to it as \u201cGTK\u201d). Linux doesn\u2019t provide its own GUI primitives, and we already ship GTK with Firefox on Linux to make a modern-feeling GUI, so we can use it for the crash reporter, too. Note that some platforms that aren\u2019t directly supported by Mozilla (like BSDs) use the GTK implementation as well.\n  * A testing implementation which will allow tests to hook into a virtual UI and poke things (to simulate interactions and read state).\n\nOne last detail before we dive in: the crash reporter (at least right now) has\na pretty simple GUI. Because of this, an explicit non-goal of the development\nwas to create a separate Rust GUI crate. We wanted to create just enough of an\nabstraction to cover the cases we needed in the crash reporter. If we need\nmore controls in the future, we can add them to the abstraction, but we\navoided spending extra cycles to fill out every GUI use case.\n\nLikewise, we tried to avoid unnecessary development by allowing some tolerance\nfor hacks and built-in edge cases. For example, our model defines a Button as\nan element which contains an arbitrary element, but actually supporting that\nwith Win32 or AppKit would have required a lot of custom code, so we special\ncase on a Button containing a Label (which is all we need right now, and an\neasy primitive available to us). I\u2019m happy to say there aren\u2019t really many\nspecial cases like that at all, but we are comfortable with the few that were\nneeded.\n\n### The UI Model\n\nOur model is a declarative structuring of concepts mostly present in GTK.\nSince GTK is a mature library with proven high-level UI concepts, this made it\nappropriate for our abstraction and made the GTK implementation pretty simple.\nFor instance, the simplest way that GTK does layout (using container GUI\nelements and per-element margins/alignments) is good enough for our GUI, so we\nuse similar definitions in the model. Notably, this \u201csimple\u201d layout definition\nis actually somewhat high-level and complicates the macOS and Windows\nimplementations a bit (but this tradeoff is worth the ease of creating UI\nmodels).\n\nThe top-level type of our UI model is Application. This is pretty simple: we\ndefine an Application as a set of top-level Windows (though our application\nonly has one) and whether the current locale is right-to-left. We inspect\nFirefox resources to use the same locale that Firefox would, so we don\u2019t rely\non the native GUI\u2019s locale settings.\n\nAs you might expect, each Window contains a single root element. The rest of\nthe model is made up of a handful of typical container and primitive GUI\nelements:\n\nThe crash reporter only needs 8 types of GUI elements! And really, Progress is\nused as a spinner rather than indicating any real progress as of right now, so\nit\u2019s not strictly necessary (but nice to show).\n\nRust does not explicitly support the object-oriented concept of inheritance,\nso you might be wondering how each GUI element \u201cextends\u201d Element. The\nrelationship represented in the picture is somewhat abstract; the implemented\nElement looks like:\n\n    \n    \n    pub struct Element { pub style: ElementStyle, pub element_type: ElementType }\n\nwhere ElementStyle contains all the common properties of elements (alignment,\nsize, margin, visibility, and enabled state), and ElementType is an enum\ncontaining each of the specific GUI elements as variants.\n\n#### Building the Model\n\nThe model elements are all intended to be consumed by the UI implementations;\nas such, almost all of the fields have public visibility. However, as a means\nof having a separate interface for building elements, we define an\nElementBuilder<T> type. This type has methods that maintain assertions and\nprovide convenience setters. For instance, many methods accept parameters that\nare impl Into<MemberType>, some methods like margin() set multiple values (but\nyou can be more specific with margin_top()), etc.\n\nThere is a general impl<T> ElementBuilder<T> which provides setters for the\nvarious ElementStyle properties, and then each specific element type can also\nprovide their own impl ElementBuilder<SpecificElement> with additional\nproperties unique to the element type.\n\nWe combine ElementBuilder<T> with the final piece of the puzzle: a ui! macro.\nThis macro allows us to write our UI in a declarative manner. For example, it\nallows us to write:\n\n    \n    \n    let details_window = ui! { Window title(\"Crash Details\") visible(show_details) modal(true) hsize(600) vsize(400) halign(Alignment::Fill) valign(Alignment::Fill) { VBox margin(10) spacing(10) halign(Alignment::Fill) valign(Alignment::Fill) { Scroll halign(Alignment::Fill) valign(Alignment::Fill) { TextBox content(details) halign(Alignment::Fill) valign(Alignment::Fill) }, Button halign(Alignment::End) on_click(move || *show_details.borrow_mut() = false) { Label text(\"Ok\") } } } };\n\nThe implementation of ui! is fairly simple. The first identifier provides the\nelement type and an ElementBuilder<T> is created. After that, the remaining\nmethod-call-like syntax forms are called on the builder (which is mutable).\n\nOptionally, a final set of curly braces indicate that the element has\nchildren. In that case, the macro is recursively called to create them, and\nadd_child is called on the builder with the result (so we just need to make\nsure a builder has an add_child method). Ultimately the syntax transformation\nis pretty simple, but I believe that this macro is a little bit more than just\nsyntax sugar: it makes reading and editing the UI a fair bit clearer, since\nthe hierarchy of elements is represented in the syntax. Unfortunately a\ndownside is that there\u2019s no way to support automatic formatting of such macro\nDSLs, so developers will need to maintain a sane formatting.\n\nSo now we have a model defined and a declarative way of building it. But we\nhaven\u2019t discussed any dynamic runtime behaviors here. In the above example, we\nsee an on_click handler being set on a Button. We also see things like the\nWindow\u2019s visible property being set to a show_details value which is changed\nwhen on_click is pressed. We hook into this declarative UI to change or react\nto events at runtime using a set of simple data binding primitives with which\nUI implementations can interact.\n\nMany GUI frameworks nowadays (both for Rust and other languages) have been\nbuilt with the \u201cdiffing element trees\u201d architecture (think React), where your\ncode is (at least mostly) functional and side-effect-free and produces the GUI\nview as a function of the current state. This approach has its tradeoffs: for\ninstance, it makes complicated, stateful alterations of the layout very simple\nto write, understand, and maintain, and encourages a clean separation of model\nand view! However since we aren\u2019t writing a framework, and our application is\nand will remain fairly simple, the benefits of such an architecture were not\nworth the additional development burden. Our implementation is more similar to\nthe MVVM architecture:\n\n  * the model is, well, the model discussed here;\n  * the views are the various UI implementations; and\n  * the viewmodel is (loosely, if you squint) the collection of data bindings.\n\n### Data Binding\n\nThere are a few types which we use to declare dynamic (runtime-changeable)\nvalues. In our UI, we needed to support a few different behaviors:\n\n  * triggering events, i.e., what happens when a button is clicked,\n  * synchronized values which will mirror and notify of changes to all clones, and\n  * on-demand values which can be queried for the current value.\n\nOn-demand values are used to get textbox contents rather than using a\nsynchronized value, in an effort to avoid implementing debouncing in each UI.\nIt may not be terribly difficult to do so, but it also wasn\u2019t difficult to\nsupport the on-demand implementation.\n\nAs a means of convenience, we created a Property type which encompasses the\nvalue-oriented fields as well. A Property<T> can be set to either a static\nvalue (T), a synchronized value (Synchronized<T>), or an on-demand value\n(OnDemand<T>). It supports an impl From for each of these, so that builder\nmethods can look like fn my_method(&mut self, value: impl Into<Property<T>>)\nallowing any supported value to be passed in a UI declaration.\n\nWe won\u2019t discuss the implementation in depth (it\u2019s what you\u2019d expect), but\nit\u2019s worth noting that these are all Clone to easily share the data bindings:\nthey use Rc (we don\u2019t need thread safety) and RefCell as necessary to access\ncallbacks.\n\nIn the example from the last section, show_details is a Synchronized<bool>\nvalue. When it changes, the UI implementations change the associated window\nvisibility. The Button on_click callback sets the synchronized value to false,\nhiding the window (note that the details window used in this example is never\nclosed, it is just shown and hidden).\n\nIn a former iteration, data binding types had a lifetime parameter which\nspecified the lifetime for which event callbacks were valid. While we were\nable to make this work, it greatly complicated the code, especially because\nthere\u2019s no way to communicate the correct covariance of the lifetime to the\ncompiler, so there was additional unsafe code transmuting lifetimes (though it\nwas contained as an implementation detail). These lifetimes were also\ninfectious, requiring some of the complicated semantics regarding their safety\nto be propagated into the model types which stored Property fields.\n\nMuch of this was to avoid cloning values into the callbacks, but changing\nthese types to all be Clone and store static-lifetime callbacks was worth\nmaking the code far more maintainable.\n\n#### Threading and Thread Safety\n\nThe careful reader might remember that we discussed how our threading model\ninvolves interacting with the UI implementations only on the main thread. This\nincludes updating the data bindings, since the UI implementations might have\nregistered callbacks on them! While we could run everything in the main\nthread, it\u2019s generally a much better experience to do as much off of the UI\nthread as possible, even if we don\u2019t do much that\u2019s blocking (though we will\nbe blocking when we send crash reports). We want our business logic to default\nto being off of the main thread so that the UI doesn\u2019t ever freeze. We can\nguarantee this with some careful design.\n\nThe simplest way to guarantee this behavior is to put all of the business\nlogic in one (non-Clone, non-Sync) type (let\u2019s call it Logic) and construct\nthe UI and UI state (like Property values) in another type (let\u2019s call it UI).\nWe can then move the Logic value into a separate thread to guarantee that UI\ncan\u2019t interact with Logic directly, and vice versa. Of course we do need to\ncommunicate sometimes! But we want to ensure that this communication will\nalways be delegated to the thread which owns the values (rather than the\nvalues directly interacting with each other).\n\nWe can accomplish this by creating an enqueuing function for each type and\nstoring that in the opposite type. Such a function will be passed boxed\nfunctions to run on the owning thread that get a reference to the owned type\n(e.g., Box<dyn FnOnce(&T) + Send + 'static>). This is simple to create: for\nthe UI thread, it is just the UI implementation\u2019s invoke method which we\nbriefly discussed previously. The Logic thread does nothing but run a loop\nwhich will get these functions and run them on the owned value (we just\nenqueue and pass them using an mpsc::channel). Now each type can\nasynchronously call methods on the other with the guarantee that they\u2019ll be\nrun on the correct thread.\n\nIn a former iteration, a more complicated scheme was used with thread-local\nstorage and a central type which was responsible for both creating threads and\ndelegating the functions. But with such a basic use case as two threads\ndelegating between each other, we were able to distill this to the essential\naspects needed, greatly simplifying the code.\n\n### Localization\n\nOne nice benefit of this rewrite is that we could bring the localization of\nthe crash reporter up to speed with our modern tooling. In almost every other\npart of Firefox, we use fluent to handle localization. Using fluent in the\ncrash reporter makes the experience of localizers more uniform and\npredictable; they do not need to understand more than one localization system\n(the crash reporter was one of the last holdouts of the old system). It was\nvery easy to use in the new code, with just a bit of extra code to extract the\nlocalization files from the Firefox installation when the crash reporter is\nrun. In the worst case scenario where we can\u2019t find or access these files, we\nhave the en-US definitions directly bundled in the crash reporter binary.\n\n## The UI Implementations\n\nWe won\u2019t go into much detail about the implementations, but it\u2019s worth talking\nabout each a bit.\n\n### Linux (GTK)\n\nThe GTK implementation is probably the most straightforward and succinct. We\nuse bindgen to generate Rust bindings to the GTK functions we need (avoiding\nvendoring any external crates). Then we simply call all of the corresponding\nGTK functions to set up the GTK widgets as described in the model (remember,\nthe model was made to mirror some of the GTK concepts).\n\nSince GTK is somewhat modern and meant to be written by humans (not automated\ntools like some of the other platforms), there weren\u2019t really any pain points\nor unusual behaviors that needed to be addressed.\n\nWe have a handful of nice features to improve memory safety and correctness. A\nset of traits makes it easy to attach owned data to GObjects (ensuring data\nremains valid and is properly dropped when the GObject is destroyed), and a\nfew macros set up the glue code between GTK signals and our data binding\ntypes.\n\n### Windows (Win32)\n\nThe Windows implementation may have been the most difficult to write, since\nWin32 GUIs are very rarely written nowadays and the API shows its age. We use\nthe windows-sys crate to access bindings to the API (which was already\nvendored in the codebase for many other Windows API uses). This crate is\ngenerated directly from Windows function metadata (by Microsoft), but\notherwise its bindings aren\u2019t terribly different from what bindgen might have\nproduced (though they are likely a bit more accurate).\n\nThere were a number of hurdles to overcome. For one thing, the Win32 API\ndoesn\u2019t provide any layout primitives, so the high-level layout concepts we\nuse (which allow graceful resize/repositioning) had to be implemented\nmanually. There\u2019s also quite a few extra API calls just to get to a GUI that\nlooks somewhat decent (correct window colors, font smoothing, high DPI\nhandling, etc). Even the default font ends up being a terrible looking\nbitmapped font rather than the more modern system default; we needed to\nmanually retrieve the system default and set it as the font to use, which was\na bit surprising!\n\nWe have a set of traits to facilitate creating custom window classes and\nmanaging associated window data of class instances. We also have wrapper types\nto properly manage the lifetimes of handles and perform type conversions\n(mainly String to null-terminated wide strings and back) as an extra layer of\nsafety around the API.\n\n### macOS (Cocoa/AppKit)\n\nThe macOS implementation had its tricky parts, as overwhelmingly macOS GUIs\nare written with XCode and there\u2019s a lot of automated and generated portions\n(such as nibs). We again use bindgen to generate Rust bindings, this time for\nthe Objective-C APIs in macOS framework headers.\n\nUnlike Windows and GTK, you don\u2019t get keyboard shortcuts like Cmd-C, Cmd-Q,\netc, for free if creating a GUI without e.g. XCode (which generates it for you\nas part of a new project template). To have these typical shortcuts that users\nexpect, we needed to manually implement the application main menu (which is\nwhat governs keyboard shortcuts). We also had to handle runtime setup like\ncreating Objective-C autorelease pools, bringing the window and application\n(which are separate concepts) to the foreground, etc. Even implementing invoke\nto call a function on the main thread had its nuances, since modal windows use\na nested event loop which would not call queued functions under the default\nNSRunLoop mode.\n\nWe wrote some simple helper types and a macro to make it easy to implement,\nregister, and create Objective-C classes from Rust code. We used this for\ncreating delegate classes as well as subclassing some controls for the\nimplementation (like NSButton); it made it easy to safely manage the memory of\nRust values underlying the classes and correctly register class method\nselectors.\n\n### The Test UI\n\nWe\u2019ll discuss testing in the next section. Our testing UI is very simple. It\ndoesn\u2019t create a GUI, but allows us to interact directly with the model. The\nui! macro supports an extra piece of syntax when tests are enabled to\noptionally set a string identifier for each element. We use these strings in\nunit tests to access and interact with the UI. The data binding types also\nsupport a few additional methods in tests to easily manipulate values. This UI\nallows us to simulate button presses, field entry, etc, to ensure that other\nUI state changes as expected as well as simulating the system side effects.\n\n## Mocking and Testing\n\nAn important goal of our rewrite was to add tests to the crash reporter; our\nold code was sorely lacking them (in part because unit testing GUIs is\nnotoriously difficult).\n\n### Mocking Everything\n\nIn the new code, we can mock the crash reporter regardless of whether we are\nrunning tests or not (though it is always mocked for tests). This is important\nbecause mocking allows us to (manually) run the GUI in various states to check\nthat the GUI implementations are correct and render well. Our mocking not only\nmocks the inputs to the crash reporter (environment variables, command line\nparameters, etc), it also mocks all side-effectful std functions.\n\nWe accomplish this by having a std module in the crate, and using crate::std\nthroughout the rest of the code. When mocking is disabled, crate::std is\nsimply the same as ::std. But when it is enabled, a bunch of functions that we\nhave written are used instead. These mock the filesystem, environment,\nlaunching external commands, and other side effects. Importantly, only the\nminimal amount to mock the existing functions is implemented, so that if e.g.\nsome new functions from std::fs, std::net, etc. are used, the crate will fail\nto compile with mocking enabled (so that we don\u2019t miss any side effects). This\nmight sound like a lot of effort, but you might be surprised at how little of\nstd really needed to be mocked, and most implementations were pretty\nstraightforward.\n\nNow that we have our code using different mocked functions, we need to have a\nway of injecting the desired mock data (both in tests and in our normal mocked\noperation). For example, we have the ability to return some data when a File\nis read, but we need to be able to set that data differently for tests.\nWithout going into too much detail, we accomplish this using a thread-local\nstore of mock data. This way, we don\u2019t need to change any code to accommodate\nthe mock data; we only need to make changes where we set and retrieve it. The\nprogramming language enthusiasts out there may recognize this as a form of\ndynamic scoping. The implementation allows our mock data to be set with code\nlike\n\n    \n    \n    mock::builder() .set( crate::std::env::MockCurrentExe, \"work_dir/crashreporter\".into(), ) .run(|| crash_reporter_main())\n\nin tests, and\n\n    \n    \n    pub fn current_exe() -> std::io::Result { Ok(MockCurrentExe.get(|r| r.clone())) }\n\nin our crate::std::env implementation.\n\n### Testing\n\nWith our mocking setup and test UI, we are able to extensively test the\nbehavior of the crash reporter. The \u201clast mile\u201d of this testing which we can\u2019t\nautomate easily is whether each UI implementation faithfully represents the UI\nmodel. We manually test this with a mocked GUI for each platform.\n\nBesides that, we are able to automatically test how arbitrary UI interactions\ncause the crash reporter to affect its own UI state and the environment\n(checking which programs are invoked and network connections are made, what\nhappens if they fail, succeed, or timeout, etc). We also set up a mock\nfilesystem and add assertions in various scenarios over the precise resulting\nfilesystem state once the crash reporter completes. This greatly increases our\nconfidence in the current behaviors and ensures that future changes will not\nalter them, which is of the utmost importance for such an essential component\nof our crash reporting pipeline.\n\n## The End Product\n\nOf course we can\u2019t get away with writing all of this without a picture of the\ncrash reporter! This is what it looks like on Linux using GTK. The other GUI\nimplementations look the same but styled with a native look and feel.\n\nNote that, for now, we wanted to keep it looking exactly the same as it\npreviously did. So if you are unfortunate enough to see it, it shouldn\u2019t\nappear as if anything has changed!\n\nWith a new, cleaned up crash reporter, we can finally unblock a number of\nfeature requests and bug reports, such as:\n\n  * detecting whether an installation is corrupt and telling the user to re-install Firefox,\n  * checking whether there is faulty memory hardware on the crashing system, and\n  * using the Firefox network stack for the first attempt at submitting crashes (which respects user network settings like proxies).\n\nWe are excited to iterate and improve further on crash reporter functionality.\nBut ultimately it\u2019d be wonderful if you never see or use it, and we are\nconstantly working toward that goal!\n\n## About Alex Franchuk\n\nMore articles by Alex Franchuk...\n\n## Thanks! Please check your inbox to confirm your subscription.\n\nIf you haven\u2019t previously confirmed a subscription to a Mozilla-related\nnewsletter you may have to do so. Please check your inbox or your spam filter\nfor an email from us.\n\n### No comments yet\n\nExcept where otherwise noted, content on this site is licensed under the\nCreative Commons Attribution Share-Alike License v3.0 or any later version.\n\n", "frontpage": false}
