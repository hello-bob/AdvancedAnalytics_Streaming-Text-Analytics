{"aid": "40221988", "title": "Everything I wish I knew before moving 50k LOC to React Server Components", "url": "https://www.mux.com/blog/what-are-react-server-components#how-do-you-mix-client-and-server-components", "domain": "mux.com", "votes": 1, "user": "banjoe", "posted_at": "2024-05-01 11:49:38", "comments": 0, "source_title": "We migrated 50,000 lines of code to React Server Components", "source_text": "We migrated 50,000 lines of code to React Server Components\n\nSkip to content\n\nMux Logo\n\nBack to Blog Home\n\nSign upSign up\n\nGet a demoGet a demoLog inLog in\n\nPublished on July 19, 2023 (10 months ago)\n\n# Everything I wish I knew before moving 50,000 lines of code to React Server\nComponents\n\nBy Darius Cepulis \u2022 20 min read \u2022 Engineering\n\nReact Server Components are a lot. We recently rethought our docs and\nrebranded Mux and, while we were at it, moved all of mux.com and docs.mux.com\nover to Server Components. So... believe me. I know. I also know that it\u2019s\npossible and not that scary and probably worth it.\n\nLet me show you why by answering the following questions: Why do Server\nComponents matter, and what are they good for? What are they not good for? How\ndo you use them, how do you incrementally adopt them, and what kind of\nadvanced patterns should you use to keep them under control? By the end of all\nthis, you should have a pretty good idea of whether you should use React\nServer Components and how to use them effectively.\n\n## How did we get here?\n\nOne great way to understand React Server Components is to understand what\nproblem they\u2019re solving. So let\u2019s start there.\n\nLong ago, in days of yore, we generated websites on servers using tech like\nPHP. This was great for fetching data by using secrets and doing CPU-heavy\nwork on big computers so that clients could just get a nice, light HTML page,\npersonalized to them.\n\nThen, we started wondering: What if we wanted faster responses and more\ninteractivity? Every time a user takes an action, do we really want to send\ncookies back to the server and make the server generate a whole new page? What\nif we made the client do that work instead? We can just send all the rendering\ncode to the client as JavaScript!\n\nThis was called client-side rendering (CSR) or single-page applications (SPA)\nand was widely considered a bad move. Sure, it\u2019s simple, which is worth a lot!\nIn fact, for a long time, the React team recommended it as the default\napproach with their tool, create-react-app. And for frequently changing,\nhighly interactive pages like a dashboard, it\u2019s probably enough. But what if\nyou want a search engine to read your page, and that search engine doesn\u2019t\nexecute JavaScript? What if you need to keep secrets on a server? What if your\nusers\u2019 devices are low-powered or have poor connections (as so many do)?\n\nThis is where server-side rendering (SSR) and static site generation (SSG)\ncame in. Tools like Next.js and Gatsby used SSR and SSG to generate the pages\non the server and send them to the client as HTML and JavaScript. The best of\nboth worlds. The client can immediately show that HTML so the user has\nsomething to look at. Then, once the JS loads, the site becomes nice and\ninteractive. Bonus: search engines can read that HTML, which is cool.\n\nThis is actually quite good! But there are still a few problems to solve.\nFirst: most SSR/SSG approaches send all the JavaScript used to generate the\npage to the client, where the client then runs it all again and marries that\nHTML with the JavaScript that just booted up. (This marriage, by the way, is\ncalled hydration \u2014 a term you\u2019ll see a lot in this neck of the woods.) Do we\nreally need to send and run all that JavaScript? Do we really need to\nduplicate all of the rendering work just to hydrate?\n\nSecond, what if that server-side render takes a long time? Maybe it runs a lot\nof code, maybe it\u2019s stuck waiting for a slow database call. Then the user\u2019s\nstuck waiting. Bummer.\n\nThis is where React Server Components come in.\n\n## What are React Server Components? What are they good for?\n\nReact Server Components (RSCs) are, unsurprisingly, React components that run\non the server instead of on the client. The \u201cwhat\u201d isn\u2019t nearly as interesting\nas the \u201cwhy,\u201d though. Why do we want RSCs? Well, frameworks that support RSCs\nhave two big advantages over SSR.\n\nFirst, frameworks that support RSCs give us a way to define where our code\nruns: what needs to run only on the server (like in the good ol' PHP days) and\nwhat should run on the client (like SSR). These are called Server Components\nand Client Components, respectively. Because we can be explicit about where\nour code runs, we can send less JavaScript to the client, leading to smaller\nbundle sizes and less work during hydration.\n\nThe second advantage of RSC-driven frameworks: Server Components can fetch\ndata directly from within the component. When that fetch is complete, Server\nComponents can stream that data to the client.\n\nThis new data-fetching story changes things in two ways. First, fetching data\nin React is way easier to think about now. Any Server Component can just...\nfetch data directly using a node library or using the fetch function we all\nknow and love. Your user component can fetch user data, your movie component\ncan fetch movie data, and so on and so forth. No more using a library or using\nuseEffect to manage complex loading states (react-query I still love you), and\nno more fetching a bunch of data at the page level with getServerSideProps and\nthen drilling it down to the component that needs it.\n\nSecond, it solves the problem we talked about earlier. Slow database call? No\nneed to wait; we\u2019ll just send that slow component to the client when it\u2019s\nready. Your users can enjoy the rest of the site in the meantime.\n\nBonus round: What if you need to fetch data on the server in response to a\nuser\u2019s action on the client (like a form submission)? We have a way to do\nthat, too. The client can send data to the server, and the server can do its\nfetching or whatever, and stream the response back to the client just like it\nstreamed that initial data. This two-way communication isn't technically React\nServer Components \u2014 this is React Actions \u2014 but it\u2019s built on the same\nfoundation and is closely related. We\u2019re not going to talk much about React\nActions here, though. Gotta save something for the next blog post.\n\n## What aren\u2019t React Server Components good for?\n\nUp until now, I\u2019ve been painting a pretty rosy picture. If RSCs are so much\nbetter than CSR and SSR, why wouldn\u2019t you use them? I was wondering the same\nthing, and I learned the hard way \u2014 as the title of this post suggests \u2014 that\nthere is indeed a catch. A few, actually. Here are the three things we spent\nthe most time on when migrating to React Server Components.\n\n### CSS-in-JS is a nonstarter\n\nTurns out that, as of right now, CSS-in-JS doesn\u2019t work in Server Components.\nThis one hurt. Moving from styled-components to Tailwind CSS was probably the\nbiggest part of our RSC conversion, although we thought it was worth the\ntrouble.\n\nSo, if you went all-in on CSS-in-JS, you\u2019ve got some work to do. At least it\u2019s\na great opportunity to migrate to something better, right?\n\n### React Context doesn\u2019t work in Server Components\n\nYou can access React Context only in Client Components. If you want to share\ndata between Server Components without using props, you\u2019ll probably have to\nuse plain ol' modules.\n\nAnd here\u2019s the kicker: If you want some sort of data to be limited to a\nsubtree of your React application, there is no great mechanism for doing that\nin Server Components. (If I'm wrong, please correct me. I really miss this.)\n\nOn our docs site, this wasn\u2019t too big of a problem. The places where we used\nReact Context heavily were also the places that were highly interactive and\nneeded to be shipped to the client anyway. Our search experience, for example,\nshares state like queryString and isOpen throughout the component tree.\n\nOn our marketing site, though, this really got us. Our marketing site has\nareas that share a theme. For example, in the screenshot below, each component\nin our pre-footer needs to understand that it is on a green background so it\nknows to use the dark green border. Normally, I would\u2019ve reached for Context\nto share that theme state, but since these are largely static components that\nare ideal candidates for Server Components, Context wasn\u2019t an option. We\nworked around this by leaning hard on CSS custom properties (which is probably\nbetter, since this is a styling concern, not a data concern). But other\ndevelopers may not be so lucky.\n\n### Honestly, it\u2019s hard to keep everything in your head all at once\n\nFundamentally, RSCs give you more flexibility about where your code runs and\nwhat your data fetching looks like. With flexibility comes complexity. No tool\ncan completely paint over this complexity, so at some point, you\u2019re going to\nhave to understand it and confront it and communicate it to other developers.\n\nEvery time a new developer picked up our codebase, the questions came up:\n\u201cWhat\u2019s running on the server? What\u2019s running on the client?\u201d Every PR had\nfeedback regarding something accidentally/unnecessarily shipped to the client.\nI frequently added console logs to my code to see if the server or the client\nwould do the logging. And don\u2019t even get me started on the complexity of\ncaching.\n\nThis has gotten better with practice and with reliable patterns. So let\u2019s talk\nabout that. How do we use React Server Components? How do we suggest migrating\nincrementally? How do we do tricky things without creating an illegible\nhairball of spaghetti code?\n\n## How do I use React Server Components?\n\nYou haven\u2019t been scared away yet? Think the pros outweigh the cons? Great!\nLet\u2019s dive in, starting with the basics.\n\nAs of the time of writing, the only production-ready implementation of RSCs is\nNext.js 13\u2019s new app directory. You could roll your own RSC framework, but if\nyou\u2019re the kind of developer who does that, you\u2019re probably not reading my\nblog post. Anyway, some notes here might be a bit specific to Next.js.\n\n### Server Components\n\nThe mental model of Server Components may be complicated, but the syntax is\nblissfully simple. By default, any component you write in Next.js 13\u2019s new app\ndirectory will be a Server Component. In other words, by default, none of your\npage\u2019s code is getting sent to the client.\n\nA basic Server Component\n\n    \n    \n    function Description() { return ( <p> None of this code is getting sent to the client. Just the HTML! </p> ) }\n\nAdd async to that Server Component and you can just... fetch data! Here\u2019s what\nthat might look like:\n\nA Server Component with data fetching\n\n    \n    \n    async function getVideo(id) { const res = await fetch(`https://api.example.com/videos/${id}`) return res.json() } async function Description({ videoId }) { const video = await getVideo(userId) return <p>{video.description}</p> }\n\nThere\u2019s one last ingredient to really unlock the power of RSCs. If you don\u2019t\nwant to be stuck waiting for one slow data fetch, you can wrap your Server\nComponents in React.Suspense. React will show the client a loading fallback,\nand when the server is done with its data fetching, it will stream the result\nto the client. The client can then replace the loading fallback with the full\ncomponent.\n\nIn the example below, the client will see \u201cloading comments\u201d and \u201cloading\nrelated videos.\u201d When the server is done fetching the comments, it will render\nthe <Comments /> component and stream the rendered component to the client;\nlikewise with related videos.\n\nA Server Component with data fetching and streaming\n\n    \n    \n    import { Suspense } from 'react' async function VideoSidebar({ videoId }) { return ( <Suspense fallback={<p>loading comments...</p>}> <Comments videoId={videoId} /> </Suspense> <Suspense fallback={<p>loading related videos...</p>}> <RelatedVideos videoId={videoId} /> </Suspense> ) }\n\nEmbracing React.Suspense has advantages beyond streaming data when it\u2019s ready.\nReact can also take advantage of Suspense boundaries to prioritize hydrating\ncertain parts of an app in response to user interaction. This is called\nselective hydration, and is probably a topic better left to the experts.\n\n### Client Components\n\nNow let\u2019s say you have some code that needs to run on the client. For example,\nmaybe you have an onClick listener, or you\u2019re reacting to data stored in\nuseState.\n\nA component gets shipped in one of two ways. The first: By adding \u201cuse client\u201d\nat the top of a file, that module will be shipped to the client so it can\nrespond to user interaction.\n\nA basic Client Component\n\n    \n    \n    \"use client\" import { useState } from 'react' function Counter() { const [count, setCount] = useState(0) const increment = () => setCount(count + 1) return ( <button onClick={increment}> The count is {count} </button> ) }\n\nThe second way a component gets shipped to the client is if it\u2019s imported by a\nClient Component. In other words, if you mark a component with \u201cuse client\u201d,\nnot only will that component be shipped to the client, but all the components\nit imports will also be shipped to the client.\n\n(Does this mean that a Server Component can\u2019t be a child of a Client\nComponent? No, but it\u2019s a little complicated. More on that later.)\n\nIf it\u2019s helpful, you can think of it this way: \u201cuse client\u201d is telling your\nbundler that this is the client/server boundary. If that\u2019s not helpful, well,\nignore the last sentence.\n\n### What if a library doesn\u2019t support Client Components?\n\nWe can leverage this second way to solve a common problem. Let\u2019s say you want\nto use a library that doesn\u2019t yet support React Server Components, so it\ndoesn\u2019t have \u201cuse client\u201d directives. If you want to make sure that library\nships to the client, import it from a Client Component, and it will be shipped\nto the client too.\n\nConverting a library to a Client Component\n\n    \n    \n    \"use client\" // because this library is imported in a Client Component, // it too becomes a Client Component import MuxPlayer from \"@mux/mux-player-react\" function ClientMuxPlayer(props) { return <MuxPlayer {...props} /> }\n\n### When should I opt in to Client Components?\n\nLet\u2019s take a step back and summarize.\n\nServer Components are the brave new React world. They\u2019re great for fetching\ndata and running expensive code that you don\u2019t want or need to send to the\nclient: rendering the text of a blog post, for example, or syntax-highlighting\na code block. When convenient, you should leave your code as Server Components\nto avoid bloating your client bundle.\n\nClient Components are the React you know and love. They can be server-side\nrendered, and they\u2019re sent to the client to be hydrated and executed. Client\nComponents are great when you want to react to user input or change state over\ntime.\n\nIf your whole app was made of Client Components, it would work just like it\nused to with yesterday\u2019s SSR frameworks. So don\u2019t feel pressured to convert\nyour whole app to Server Components all at once! Adopt them incrementally in\nplaces that would stand to gain the most. And... speaking of incremental\nadoption...\n\n## How do I incrementally adopt React Server Components in a real-life\ncodebase?\n\nThis is the part of the show where folks tend to say, \u201cNeat! But this seems\nlike a lot of work, and I don\u2019t have time to rewrite my whole codebase.\u201d Well,\nI\u2019m here to tell you that you don\u2019t need to. Here\u2019s the three-step playbook we\nused to bring most of our code to Server Components:\n\n  1. Add the \u201cuse client\u201d directive to the root of your app\n  2. Move the directive as low in the rendering tree as you can\n  3. Adopt advanced patterns when performance issues arise\n\nLet\u2019s walk through that.\n\n### 1\\. Add \u201cuse client\u201d directive to the root of your app\n\nYup. That\u2019s it. If you\u2019re in Next.js 13, go to your top-level page.tsx and\nplop in a \u201cuse client\u201d at the top. Your page works just like it used to,\nexcept now you\u2019re ready to take on the world of Server Components!\n\nvideo/page.jsx\n\n    \n    \n    \"use client\" export default function App() { <> <Player /> <Title /> </> }\n\nGot any server-side data fetching? We can\u2019t do that from a Client Component,\nso we\u2019re going to add a Server Component. Let\u2019s add it as a parent of the\nClient Component. That Server Component will perform the data fetching and\npass it into our page. Here\u2019s what that will look like:\n\nvideo/page.jsx\n\n    \n    \n    /** * All we're doing here is fetching data on the server, * and passing that data to the Client component. */ import VideoPageClient from './page.client.jsx' // this used to be getServerSideProps async function fetchData() { const res = await fetch('https://api.example.com') return await res.json() } export default async function FetchData() { const data = await fetchData() {/* We moved our page's contents into this Client Component */} const <VideoPageClient data={data} /> } export default Page\n\nvideo/page.client.jsx\n\n    \n    \n    /** * Our whole app, except for the data fetching, can live here. */ \"use client\" export default function App({ data }) { <> <Player videoId={data.videoId} /> <Title content={data.title} /> </> }\n\n### 2\\. Move the directive as low in the rendering tree as you can\n\nNext, take that \u201cuse client\u201d directive and move it from that top-level\ncomponent into each of its children. In our example, we\u2019ll be moving it from\nour <Client /> component into our <Player /> and <Title /> components.\n\nvideo/Player.jsx\n\n    \n    \n    \"use client\" import MuxPlayer from \"@mux/mux-player-react\" function Player({ videoId }) { return <MuxPlayer streamType=\"on-demand\" playbackId={videoId} /> }\n\nvideo/Title.jsx\n\n    \n    \n    \"use client\" function Title({ content }) { return <h1>{content}</h1> }\n\nAnd repeat! Except... because neither <Player /> nor <Title /> have children\ninto which we can push the \u201cuse client\u201d directive, let\u2019s remove it!\n\n<Title /> has no issues, because <Title /> doesn\u2019t require any client-side\ncode and can be shipped as pure HTML. Meanwhile, <Player /> throws an error.\n\nGreat. That\u2019s as low as we can go. Let\u2019s restore \u201cuse client\u201d to the <Player\n/> component to address that error and call it a day.\n\nSee? That wasn\u2019t too bad. We\u2019ve moved our app to Server Components. Now, as we\nadd new components and refactor old ones, we can write with Server Components\nin mind. And, we\u2019ve saved a bit of bundle size by not shipping <Title /> !\n\n### 3\\. Adopt advanced patterns when performance issues arise\n\nSteps 1 and 2 should be enough for most cases. But if you\u2019re noticing\nperformance issues, there are still some wins you can squeeze out of your RSC\nconversion.\n\nFor example, when we migrated our docs site to RSCs, we leaned on two patterns\nto unlock deeper gains. The first was wrapping key Server Components in\nSuspense to enable streaming of slow data fetches (as demonstrated earlier).\nOur whole app is statically generated except for the changelog sidebar, which\ncomes from a CMS. By wrapping that sidebar in Suspense, the rest of the app\ndoesn\u2019t have to wait for the CMS fetch to resolve. Beyond that, we leveraged\nNext.js 13\u2019s loading.js convention, which uses Suspense/streaming under the\nhood.\n\nThe second optimization we applied was creatively rearranging Client and\nServer Components to ensure that large libraries, like our syntax\nhighlighting, Prism, stayed on the server. And speaking of creatively\nrearranging Client and Server Components...\n\n## Did someone say advanced patterns?\n\n### How do you mix Client and Server Components?\n\nWe established earlier that any component imported from a Client Component\nwould itself become a Client Component. So... how do you make a Server\nComponent a child of a Client Component? Long story short, pass Server\nComponents as children or props instead of importing them. The Server\nComponent will be rendered on the server, serialized, and sent to your Client\nComponent.\n\nThis, imo, is the hardest thing to wrap your head around in this whole RSC\nmess. It gets easier with practice. Let\u2019s check out some examples, starting\nwith the wrong way.\n\nHow NOT to mix Client and Server Components\n\n    \n    \n    \"use client\" // Anything imported from a Client Component becomes a Client Component // so this is wrong! import ServerComponentB from './ServerComponentB.js' function ClientComponent() { return ( <div> <button onClick={onClickFunction}>Button</button> {/* because this was imported from a Client Component, it became a Client Component too. */} <ServerComponentB /> </div> ) }\n\nBy importing ServerComponent in a Client Component, we shipped ServerComponent\nto the client. Oh no! To do this properly, we have to go up a level to the\nnearest Server Component \u2014 in this case, ServerPage \u2014 and do our work there.\n\nHow to mix Client and Server Components\n\n    \n    \n    import ClientComponent from './ClientComponent.js' import ServerComponentB from './ServerComponentB.js' /** * The first way to mix Client and Server Components * is to pass a Server Component to a Client Component * as a child. */ function ServerComponentA() { return ( <ClientComponent> <ServerComponentB /> </ClientComponent> ) } /** * The second way to mix Client and Server Components * is to pass a Server Component to a Client Component * as a prop. */ function ServerPage() { return ( <ClientComponent content={<ServerComponentB />} /> ) }\n\n### Can you make half of a file a Server Component and half of it a Client\nComponent?\n\nNope! But here\u2019s a pattern we use a lot, when we want part of our component\u2019s\nfunctionality to stay on the server. Let\u2019s say we\u2019re making a <CodeBlock />\ncomponent. We might want the syntax highlighting to stay on the server so we\ndon\u2019t have to ship that large library, but we might also want some client\nfunctionality so that the user can switch between multiple code examples.\nFirst, we break the component into two halves: CodeBlock.server.js and\nCodeBlock.client.js. The former imports the latter. (The names could be\nanything; we use .server and .client just to keep things straight.)\n\ncomponents/CodeBlock/CodeBlock.server.js\n\n    \n    \n    // filename: components/CodeBlock/CodeBlock.server.js import Highlight from 'expensive-library' import ClientCodeBlock from './CodeBlock.client.js' import { example0, example1, example2 } from './examples.js' function ServerCodeBlock() { return ( <ClientCodeBlock // because we're passing these as props, they remain server-only renderedExamples={[ <Highlight code={example0.code} language={example0.language} />, <Highlight code={example1.code} language={example1.language} />, <Highlight code={example2.code} language={example2.language} /> ]} > ) } export default ServerCodeBlock\n\ncomponents/CodeBlock/CodeBlock.client.js\n\n    \n    \n    \"use client\" import { useState } from 'react' function ClientCodeBlock({ renderedExamples }) { // because we need to react to state and onClick listeners, // this must be a Client Component const [currentExample, setCurrentExample] = useState(1) return ( <> <button onClick={() => setCurrentExample(0)}>Example 1</button> <button onClick={() => setCurrentExample(1)}>Example 2</button> <button onClick={() => setCurrentExample(2)}>Example 3</button> { renderedExamples[currentExample] } </> ) } export default ClientCodeBlock\n\nNow that we have those two components, let\u2019s make them easy to consume with a\ndelightful file structure. Let\u2019s put those two files in a folder called\nCodeBlock and add an index.js file that looks like this:\n\ncomponents/CodeBlock/index.js\n\n    \n    \n    export { default } from './CodeBlock.server.js'\n\nNow, any consumer can import CodeBlock from \u2018components/CodeBlock.js\u2019 and the\nClient and Server Components remain transparent.\n\n### This is confusing. How can I be sure that my code is running on the\nserver?\n\nHonestly, at first, we just added console.log to our code during development\nand checked to see if that log came out of the server or web browser. This was\nenough to begin with, but we did eventually find a better way.\n\nIf you want to be extra sure that your Server Component will never get\nincluded in a bundle, you can import the server-only package. This is extra\nhandy if you want to make sure a large library or a secret key doesn\u2019t end up\nwhere it shouldn\u2019t. (Though if you\u2019re using Next.js, it will protect you from\naccidentally shipping your environment variables.)\n\nUsing server-only also had another subtle but meaningful benefit for us:\nlegibility and maintainability. Maintainers who see server-only at the top of\na file know exactly where that file is running without having to keep a\ncomplete mental model of the component tree.\n\n## So, should I use React Server Components?\n\nAt the end of the day, React Server Components don\u2019t come for free. It\u2019s not\njust those gotchas surrounding CSS-in-JS or React Context. It\u2019s also the added\ncomplexity: understanding what\u2019s running on the server and what\u2019s running on\nthe client, understanding hydration, incurring infrastructure costs, and of\ncourse, managing the code complexity (especially when mixing Client and Server\nComponents). Every facet of complexity adds another surface for bugs to sneak\nin and for code to become less maintainable. Frameworks reduce this\ncomplexity, but they don\u2019t eliminate it.\n\nWhen deciding whether to adopt RSCs, weigh these costs against the benefits \u2014\nlike smaller bundle sizes and faster execution, which can be critical to SEO.\nOr advanced data loading patterns that can be used to optimize complex data-\nheavy sites. Jeff Escalante, trying to answer the same question in their\nReactathon talk, nailed it with this diagram:\n\nIf your team is ready to take on the mental overhead and the performance\nbenefits are worthwhile, then RSCs might just be for you.\n\nBut wait, there's more! Server Components are just the beginning of the story.\nWant to learn about Server Actions? We wrote about that, too.\n\n## Written By\n\n### Darius Cepulis \u2013 Senior Community Engineer\n\nPretends he knows more about coffee than he does. Happier when he's outside.\nThinks the web is pretty neat.\n\n## Leave your wallet where it is\n\nNo credit card required to get started.\n\nSign upSign up\n\n## Read more like this\n\nPublished on January 31, 2024 \u2022 By Colton Karoses\n\n### AI models on CPUs: accurate audio transcriptions without breaking the bank\n\nPublished on March 8, 2023 \u2022 By Justin Sanford\n\n### Edge Config: first line of defense against script kiddies\n\nPublished on November 1, 2022 \u2022 By Darius Cepulis\n\n### How we made Mux Player\u2019s loading feel great\n\n### Check out our newsletter\n\nA monthly-ish digest of all the best new blog posts and features\n\nMux Logo\n\n## United States\n\n50 Beale Street, Floor 9 San Francisco, CA, 94105 510-402-2257\n\n## United Kingdom\n\n34-37 Liverpool Street London, EC2M 7PP\n\nContact usMux on TwitterMux on LinkedInMux on GitHub\n\n## Platform\n\n### Mux Video\n\nOverviewFeaturesOn-DemandLiveInteractiveEncodingPricing\n\n### Mux Data\n\nOverviewMonitoringPricing\n\n### Mux Player\n\nOverview\n\nBeta features\n\n## Docs and Tools\n\nMux Video docsMux Data docsMux Player docsAPI referenceWebhook referenceOpen\nsource software\n\n### Integrations\n\nNodeRubyPHPPythonElixirGoSvelteKitNext.jsRemix.jsGenerative AI\n\n## Company\n\nTeamJobsBlogCustomersResourcesPartnersSupportDownload Press Kit\n\n## More Video\n\nVideo glossaryLearn about videoSign up for our newsletterDemuxedHowVideo.Works\n\n\u00a9 Mux, Inc. 2024\n\nTerms of serviceSecurityPrivacy policySitemap\n\nStatus:Loading....\n\n", "frontpage": false}
