{"aid": "40155294", "title": "A brief history of web development. And why your framework doesn't matter", "url": "https://gebna.gg/blog/brief-history-of-web-development", "domain": "gebna.gg", "votes": 3, "user": "thunderbong", "posted_at": "2024-04-25 09:29:06", "comments": 0, "source_title": "A brief history of web development. And why your framework doesn't matter.", "source_text": "A brief history of web development. And why your framework doesn't matter.\n\ngebna.gg contact me\n\n# A brief history of web development. And why your framework doesn't matter.\n\n#### Written by Bahaa Zidan\n\n#### 2024-04-25\n\nHistory is very important. It helps keep our perspectives in check. This is\nhow I remember the crazy journey that web development has gone through in the\npast few years. This is my telling of it. So I will omit events. I may mess up\nthe timeline. This whole article may not be of any use to you. But for me,\nputting all of it into writing helped me appreciate how much things stay the\nsame no matter how much they change. So if you\u2019re curious and undeterred,\nallow me to start with ...\n\n### The good ol\u2019 days\n\nThe simplest architecture to build a website would be to have one server to\nhandle everything. That means that there\u2019s no frontend router, no hydration,\nno AJAX, and definitely no cache/store like Apollo or Redux. It\u2019s very simple,\nthe user requests an HTML page, the user gets an HTML page back. Oh and\nmutations will all be handled by native HTML forms. This used to be how\neverything worked. Not much JavaScript was written. Just whatever language you\npicked for backend and HTML/CSS. This worked because the web was made to be a\ndecentralized space for sharing information. The websites made in those days\nwere very static in nature and very little mutations happened so it was fine\nfor the page to refresh after each form submission. It was also fine to load\nan entirely new HTML document every time the user navigated to another page.\n\nBut then the web started to change. Websites started becoming more and more\nlike apps. More functionality was needed on the client side. So more\nJavaScript was written. Browser APIs were not enough so jQuery was made. And\nbefore we knew it, the language that was made to display sparkles and counters\non websites took over everything and we started writing single page\napplications or SPAs.\n\n### Not the SPA you\u2019re thinking of\n\nA SPA basically absolves the backend of its\u2019 HTML/CSS duties. Servers don\u2019t\nreturn HTML anymore. They expose REST endpoints. Each one returns JSON in\nresponse. In SPAs, when the user requests yourdomain.com/any-thing, the server\nresponds with an empty HTML document that has a JavaScript that then takes\nover. The frontend handles fetching data, rendering html pages, and routing\nbetween them. This is when frameworks like Knockout.js, Backbone.js, and\nAngular.js were released (late 2010). Three years later, React was released\nwith its\u2019 JSX syntax and one way data-binding. And it made writing web apps\neasier than ever. Or so we thought.\n\nIf a user submits a form, they don\u2019t expect the page to refresh anymore. Since\nit\u2019s an app, it should behave like one. If the data mutates, new data should\njust appear. Meaning developers had to write code to maintain state and react\nto any change in the state by re-rendering parts of the HTML accordingly.\nImagine the poor frontend devs doing that in a large scale app like Facebook\nwith so many moving part to take care of. Imagine the poor backend devs\nneeding to create numerous REST endpoints to accommodate all that\nfunctionality.\n\n### Facebook\n\nSay you\u2019re a frontend dev in the ads team at Facebook. A new feature is\nproposed by the product manager, you go through the requirements they wrote\nand you start implementing. You know the feature is going to need access to\nsome data from the backend but you\u2019re at ease because your backend REST\nendpoints are well documented. You search the API docs, and you find a couple\nAPIs that seem to fit what you need. You start writing your frontend code to\nfind out that the docs are outdated and one of endpoints has been removed\nbecause it\u2019s no longer in use. You let your project manager know and they\nassign a backend dev to work with you. After a couple days of waiting, they\nmessage you saying they added the endpoint you needed. You thank them and\ncontinue implementing the feature only to run into another problem. The other\nendpoint returns way too much data and is way too slow to be used within the\ncontext of the new feature you\u2019re implementing. Oh and the product manager\nmessaged you saying that requirements changed. So you repeat the previous\ncycle all over again.\n\nWhat went wrong there ? a few things, but I\u2019ll focus on two:\n\n  1. The API endpoints and there documentation are two separate things and so they can go out of sync.\n  2. There\u2019s no runtime guarantee that the API returns what it should. Essentially there\u2019s no strict contract between the server and the client. It can return any JSON and the response will still be 200 OK.\n\nNow you can probably solve the problems above by writing more automated tests\nand/or investing in doc-gen tools like Swagger. But these things treat the\nsymptoms (bugs) while not curing the disease (lack of contract). So in 2012,\nFacebook engineers thought of something better.\n\n### GraphQL\n\nGraphQL fixes the above problems by changing APIs from a set of untyped REST\nendpoints like this:\n\n  * GET /posts\n  * POST /posts\n  * GET /posts/:id\n  * DELETE /posts/:id\n\nTo a strictly typed, queryable schema like this:\n\n    \n    \n    type Post { id: ID! body: String date: Date Author: User } type User { id: ID! username: String first_name: String last_name: String full_name: String name: String @deprecated avatar_url: Url } scalar Url scalar Date type Query { Post(id: ID!): Post Posts(limit: Int, skip: Int, sort_field: String, sort_order: String): [Post] User(id: ID!): User } type Mutation { createPost ( body: String ): Post deletePost(id: ID!): Tweet }\n\nNow because the GraphQL server always checks coming requests and outgoing\nresponses against the schema we define, we now have our contract, our runtime\nguarantee that the frontend is only requesting fields that exist and the\nbackend will either respond with them or with an error. A few positive side\neffects of this design are:\n\n  * No need for explicit documentation anymore. The schema is most of the documentation you need. And it\u2019s always up to date.\n  * The client can pick precisely the fields they need. No need to request the entire User object if you just need id and a username.\n  * Frontend state management becomes way simpler thanks to GraphQL clients like Relay, Urql, And Apollo.\n\nSo that\u2019s it. A SPA frontend that is powered by a GraphQL server. That\u2019s the\nideal architecture for every web app. I mean, Facebook uses it so it must be\nthe best option right ? ... right ?\n\n### Remember websites ?\n\nWhat if one needs to create a blog ? Typically, all a blog has to do is show\nsome markdown and be SEO friendly. SPAs were notoriously difficult for SEO\ncrawlers to index because it takes a few more hundred milliseconds for\nJavaScript to render on the client. So what then ? Does one have to go back to\nWordpress ?\n\nAtwood\u2019s Law:\n\n> Any application that can be written in JavaScript, will eventually be\n> written in JavaScript.\n\nBy that point Node.js had picked up enough steam. We were beginning to see a\nnew generation of tooling that was birthed from the idea that JavaScript is\ngoing to run everywhere. Not just the browser. Among these tools was Gatsby.\nIt allowed you to write \u201cwebsites\u201d in React. It came riding on a wave of\n\u201cheadless\u201d CMS startups that were trying to compete in this new market. All of\na sudden we saw terms like \u201dJAM stack\u201d thrown around. All it meant is\ndecoupling presentation from data. Which was not a new idea. It turned out to\nbe a very short lived trend for JAM stack. Gatsby couldn\u2019t catch a break. Just\nas it was about to gain some traction as the defacto Node.js/React website\ngenerator, a new challenger approached.\n\n### Next.js\n\nBack then (around 2016), React was not opinionated. It was a library that only\nconcerned itself with rendering and state. While other frameworks like\nAngular.js came bundled with everything you may need to get up and running,\nReact opted to allow the community to figure things out. And figure out they\ndid. We had a new JavaScript bundler every other Tuesday, a new router every\nSunday, a new CSS-in-JS solution every Friday, and a new state management\nlibrary every f***ken day.\n\nEnters Next.js. Your very own open-source / blazingly-fast (not really) /\nbatteries-included React framework. While things like Gatsby offered a choice\nbetween a dynamic SPA or a static pre-rendered website, Next.js supported\nmultiple rendering modes. By default it pre-rendered pages which made site\ngenerators like Gatsby obsolete. In addition to pre-rendering, it supported\nserver-side rendering for cases when page content can\u2019t be known at build time\nand must be rendered depending on request params. It also came with client-\nside rendering support which also made it a viable option for SPAs.\nFurthermore, you could mix and match between all these rendering modes. The\nway it works is once the user requests a certain page from the server, the\nserver renders an HTML document with all the elements needed to view the page.\nThe JavaScript would take over and hydrate all the elements with the necessary\nevent listeners for the page to be interactive. A client side router would\nalso take over. This meant that we don\u2019t need to choose between websites and\napps anymore. As Next gave us the SEO/performance benefits of server-side-\nrendering while maintaining the app-like user experience. It meant the death\nof the website/web app dichotomy.\n\n### The CloudTM\n\nLet\u2019s take the timeline back a few years. At around 2006, another change\nbrewing in parallel was the rise of \u201cThe Cloud\u201d. In simple terms, it means you\ndon\u2019t have to use your bare metal servers anymore. You can use Amazon\u2019s. Yes,\nAmazon had a few servers they did not need and decided to start AWS. Amazon\u2019s\napproach was unique compared the OGs that existed at that time. Companies like\nIBM and Oracle went for big/exclusive enterprise contracts that aimed to take\nover the IT department of a company using their proprietary tools. AWS offered\na number of independent services that anyone could buy. Make no mistake, the\nend goal for AWS was the exact same: take over the IT department of your\ncompany. They just had you (the developer) work for it yourself. Genius if you\nask me.\n\nIn practice, AWS\u2019s approach of offering a large number of independent services\nthat you can stitch together to architect your app worked well for large\ncompanies with dedicated sys-admin/ops teams. It didn\u2019t work quite well for\nthe new wave of JavaScript developers that just graduated bootcamps. Why do I\nhave to fiddle with 15 services and an abhorrent dashboard to deploy my\ntwitter clone ? And so a new generation of cloud companies was birthed from\nthe market\u2019s need for simpler cloud platforms. To my knowledge most of which\nwere built on top of AWS. They just made the most common use cases easier than\never. Coming with things like CI/CD, scaling, analytics, and CDN out of the\nbox and packaged in a beautiful dashboard. Among these companies was a company\nnamed Vercel. The company that made Next.js.\n\n### JavaScript that\u2019s a lot more like C#\n\nThe more JavaScript took over, the more people started to realize that it was\ninadequate for its\u2019 new role as the one language to rule them all. Among its\u2019\nmany inadequacies is being a dynamically typed language. Which meant that\nbuilding libraries and big applications using JavaScript was a tedious process\nof console.loging everything and hoping you get what you need. So a statically\ntyped JavaScript was needed.\n\nMeanwhile, a team at Google was building Angular 2 (because the first one\nwasn\u2019t enough). They needed a typed JavaScript with support for decorator\nsyntax. They were about to create their own language when they discovered that\nMicrosoft had beat them to it and created TypeScript.\n\nTypeScript is simply a compiler that offers static type analysis to your\nJavaScript code. Its\u2019 syntax was very close to JavaScript so adopting it was\nvery simple. Facebook tried to compete with Flow. But TypeScript\u2019s familiarity\nended up winning and Flow ... flew into the mist (sorry). But why stop at\nstatic type analysis and syntactic sugar ? Why not make the most out of our\nbuild step ?\n\n### Svelte\n\nDriven by the belief that frameworks should only augment/enhance the web\nplatform not replace it or change it, Svelte was made. While most frameworks\nat the time of its\u2019 release had to ship a large JavaScript bundle to handle\nrendering and reactivity, Svelte was just a compiler. There\u2019s no Svelte script\nthat gets shipped to the browser. The Svelte compiler generates some highly\noptimized reactivity code that\u2019s much much smaller and faster than the rest.\n\nThe team behind it also made SvelteKit. A framework on top of Svelte that\nhandles bundling, routing, and pretty much everything you may need in a web\nframework. Its\u2019 very mature routing and data-loading patterns have made me\ngive up on using GraphQL in most of my projects. Why spend time and effort\nsecuring and optimizing a GraphQL schema when I can throw a database call in a\nload function and have everything be typed server to client ? It\u2019s an absolute\nwin when it comes to app development. Similar techniques are also available in\nother frameworks like Nuxt, Next, and SolidStart. This makes the overhead cost\nof GraphQL development very hard to justify in most cases.\n\n### HTMX: there and back again\n\nRemember the good ol\u2019 days ? When the server sent HTML instead of JSON ? HTMX\ngives all the power back to the server. You include an HTMX script tag on all\nyour pages. Any mutation that happens to the state will result in HTMX\nswapping an element on the screen with whatever the backend sent. This is not\na particularly new idea. For example, GitHub is already built that way using\nRuby. But HTMX revitalized it by posting memes on twitter. And I love it.\n\nWe must also appreciate the appeal it has to programmers who are not in the\nJavaScript bubble. Imagine you\u2019ve been writing Go, Java, or anything that\u2019s\nproper, and you went to make a website. People started telling you to use\nJavaScript. But why include JavaScript to begin with ? Why not do the whole\nthing in the one language you like? HTMX offers that to people without\ncoupling it with a complete backend framework like Rails does it. You pick\nwhatever backend language you like and as long as you\u2019re returning HTML in\nresponse, you\u2019re good to go. And speaking of Rails, why is that framework not\ndead yet ? Why is PHP still a thing ? And most importantly, why on earth is\nReact still alive ?\n\n### React is not going to die\n\nI know it\u2019s very hard. But let\u2019s look at this objectively. As of the time of\nwriting (early 2024), is React better at any particular thing compared to all\nthe other mainstream UI frameworks ? No, it is not. Even Angular, the\nframework everyone loves to hate has been getting updates that objectively\nimprove performance, maintainability, and developer experience.\n\nMeanwhile React seems to be wandering aimlessly. We started with class\ncomponents, then we changed some life cycle hooks, then everything became\n\u201cfunctional\u201d. Everyone was praising the new \u201cfunctional\u201d API with useState and\nuseEffect. But people quickly realized that useEffect was a very bad\nabstraction given the way React works. It was a foot gun. And for a while\nReact devs didn\u2019t know what was the alternative ? It was at this time that\nVercel started hiring a few of React\u2019s core maintainers. It was at this time\nwhen Next.js and React essentially became one and the same. And server\ncomponents became the new foot-gun API the React team is recommending. All\nthat and people are yet to figure out the \u201cReact\u201d way of doing things.\n\nRegardless of all that pain, React is still the most downloaded framework on\nNPM compared to other frameworks. It\u2019s not even close. But why ?\n\nLook around you. No technology that was once mainstream ever dies. People\nrarely pick \u201cthe best tool for the job\u201d. They say that. But what they mean is\n\u201cthe tool I\u2019m familiar with the most\u201d. That\u2019s it. That\u2019s why React is probably\nnot dying anytime soon. But it doesn\u2019t matter.\n\n### Really, it does not.\n\nWanna keep using React ? Wanna switch to something better like Svelte ? Wanna\navoid JavaScript like the plague and use HTMX ? It doesn\u2019t matter to the end\nuser. As long as you\u2019re providing value to people and/or having fun doing it,\nyou\u2019re good. Don\u2019t feel bad about your technical choices because someone on\nthe internet wants you to. Programming is a craft. There\u2019s way more leeway\nthan the person who\u2019s selling you a course about \u201cframework X\u201d, \u201clanguage Y\u201d,\nor a book about \u201cclean code/design/architecture\u201d wants you to believe. And\nputting all this history into writing only serves to enforce this sentiment.\nThings will change. And no matter how much they do, we\u2019ll still be\nprogrammers. Our primary function is to write useful programs. Have fun \ud83c\udf49\n\n", "frontpage": false}
