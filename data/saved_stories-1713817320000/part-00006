{"aid": "40114500", "title": "Show HN: ZenModel \u2013 Golang framework for LLM Agentic apps", "url": "https://github.com/zenmodel/zenmodel", "domain": "github.com/zenmodel", "votes": 1, "user": "ClayZhang", "posted_at": "2024-04-22 14:04:03", "comments": 0, "source_title": "GitHub - zenmodel/zenmodel: ZenModel is a framework for building LLM applications with agentic workflow", "source_text": "GitHub - zenmodel/zenmodel: ZenModel is a framework for building LLM\napplications with agentic workflow\n\nSkip to content\n\nSign in\n\n# Search code, repositories, users, issues, pull requests...\n\nSearch syntax tips\n\nSign in\n\nSign up\n\nYou signed in with another tab or window. Reload to refresh your session. You\nsigned out in another tab or window. Reload to refresh your session. You\nswitched accounts on another tab or window. Reload to refresh your session.\nDismiss alert\n\nzenmodel / zenmodel Public\n\n  * Notifications\n  * Fork 1\n  * Star 2\n\nZenModel is a framework for building LLM applications with agentic workflow\n\ngithub.com/zenmodel/zenmodel\n\n### License\n\nMIT license\n\n2 stars 1 fork Branches Tags Activity\n\nStar\n\nNotifications\n\n# zenmodel/zenmodel\n\nThis commit does not belong to any branch on this repository, and may belong\nto a fork outside of the repository.\n\n4 Branches\n\n0 Tags\n\n## Folders and files\n\nName| Name| Last commit message| Last commit date  \n---|---|---|---  \n  \n## Latest commit\n\nClayCheungMerge pull request #21 from zenmodel/feat/internationalApr 22,\n20240423bf1 \u00b7 Apr 22, 2024Apr 22, 2024\n\n## History\n\n62 Commits  \n  \n### examples\n\n|\n\n### examples\n\n| doc(*): README in English| Apr 22, 2024  \n  \n### internal\n\n|\n\n### internal\n\n| feat(maintainer): add neuron message cats_anyway| Mar 23, 2024  \n  \n### .gitignore\n\n|\n\n### .gitignore\n\n| chore(*): add gitignore| Apr 9, 2024  \n  \n### LICENSE\n\n|\n\n### LICENSE\n\n| chore(*): add license| Mar 13, 2024  \n  \n### README.md\n\n|\n\n### README.md\n\n| doc(*): README in English| Apr 22, 2024  \n  \n### README_zh.md\n\n|\n\n### README_zh.md\n\n| doc(*): README in English| Apr 22, 2024  \n  \n### brain.go\n\n|\n\n### brain.go\n\n| feat(memory): modify memory interface| Mar 28, 2024  \n  \n### brain_local.go\n\n|\n\n### brain_local.go\n\n| fix(brain): set unselected link to init when neuron casted| Apr 18, 2024  \n  \n### brain_runtime.go\n\n|\n\n### brain_runtime.go\n\n| doc(*): update README| Apr 15, 2024  \n  \n### brainprint.go\n\n|\n\n### brainprint.go\n\n| feat(*): define brain runtime interface for prcess function or select...|\nMar 23, 2024  \n  \n### go.mod\n\n|\n\n### go.mod\n\n| refactor(*): use go 1.19| Apr 13, 2024  \n  \n### go.sum\n\n|\n\n### go.sum\n\n| refactor(*): use go 1.19| Apr 13, 2024  \n  \n### link.go\n\n|\n\n### link.go\n\n| feat(brainprint): rename DeepCopy as Clone| Mar 23, 2024  \n  \n### maintainer.go\n\n|\n\n### maintainer.go\n\n| feat(*): add logger| Mar 19, 2024  \n  \n### neuron.go\n\n|\n\n### neuron.go\n\n| doc(*): update README| Apr 15, 2024  \n  \n### options.go\n\n|\n\n### options.go\n\n| feat(*): define brain runtime interface for prcess function or select...|\nMar 23, 2024  \n  \n### processor.go\n\n|\n\n### processor.go\n\n| chore(*): clean warning| Mar 24, 2024  \n  \n## Repository files navigation\n\n# ZenModel\n\n\u4e2d\u6587 | English\n\nUse Golang to develop Agentic applications with LLMs\n\n## Overview\n\nZenModel is a workflow programming framework designed for constructing agentic\napplications with LLMs. It implements by the scheduling of computational units\n(Neuron), that may include loops, by constructing a Brain (a directed graph\nthat can have cycles) or support the loop-less DAGs. A Brain consists of\nmultiple Neurons connected by Links. Inspiration was drawn from LangGraph. The\nMemory of a Brain leverages ristretto for its implementation.\n\n  * Developers can build a Brain with any process flow:\n\n    * Sequential: Execute Neurons in order.\n    * Parallel and Wait: Concurrent execution of Neurons with support for downstream Neurons to wait until all the specified upstream ones have completed before starting.\n    * Branch: Execution flow only propagates to certain downstream branches.\n    * Looping: Loops are essential for agent-like behaviors, where you would call an LLM in a loop to inquire about the next action to take.\n    * With-End: Stops running under specific conditions, such as after obtaining the desired result.\n    * Open-Ended: Continuously runs, for instance, in the scenario of a voice call, constantly listening to the user.\n  * Each Neuron is a concrete computational unit, and developers can customize Neuron to implement any processing procedure (Processor), including LLM calls, other multimodal model invocations, and control mechanisms like timeouts and retries.\n  * Developers can retrieve the results at any time, typically after the Brain has stopped running or when a certain Memory has reached an expected value.\n\n## Installation\n\nWith Go module support, simply add the following import to your code, and then\ngo mod [tidy|download] will automatically fetch the necessary dependencies.\n\n    \n    \n    import \"github.com/zenmodel/zenmodel\"\n\nOtherwise, run the following Go command to install the zenmodel package:\n\n    \n    \n    $ go get -u github.com/zenmodel/zenmodel\n\n## Quick Start\n\nLet's use zenmodel to build a Brain as shown below.\n\n### Defining a Brainprint\n\nDefine the graph's topology by outlining a brainprint (a shorthand for brain\nblueprint).\n\n#### 1\\. Create a brainprint\n\n    \n    \n    bp := zenmodel.NewBrainPrint()\n\n#### 2\\. Add Neurons\n\nBind a processing function to a neuron or custom Processor. In this example, a\nfunction is bound, and its definition is omitted for brevity. For more\ndetails, see examples/chat_agent_with_function_calling.\n\n    \n    \n    // add neuron with function bp.AddNeuron(\"llm\", chatLLM) bp.AddNeuron(\"action\", callTools)\n\n#### 3\\. Add Links\n\nThere are three types of Links:\n\n  * Normal Links: Include the source Neuron and destination Neuron\n  * Entry Links: Only have the destination Neuron\n  * End Links: The Brain will automatically go into a Sleeping state when there are no active Neurons and Links, but you can also explicitly define end links to set an endpoint for the Brain to run. You only need to specify the source Neuron, the destination Neuron will be END\n\n    \n    \n    /* This example omits error handling */ // add entry link _, _ = bp.AddEntryLink(\"llm\") // add link continueLink, _ := bp.AddLink(\"llm\", \"action\") _, _ = bp.AddLink(\"action\", \"llm\") // add end link endLink, _ := bp.AddEndLink(\"llm\")\n\n#### 4\\. Set cast select at a branch\n\nBy default, all outbound links of a Neuron will propagate (belonging to the\ndefault casting group). To set up branch selections where you only want\ncertain links to propagate, define casting groups (CastGroup) along with a\ncasting selection function (CastGroupSelectFunc). Each cast group contains a\nset of links, and the return string of the cast group selection function\ndetermines which cast group to propagate to.\n\n    \n    \n    // add link to cast group of a neuron _ = bp.AddLinkToCastGroup(\"llm\", \"continue\", continueLink) _ = bp.AddLinkToCastGroup(\"llm\", \"end\", endLink) // bind cast group select function for neuron _ = bp.BindCastGroupSelectFunc(\"llm\", llmNext)\n    \n    \n    func llmNext(b zenmodel.BrainRuntime) string { if !b.ExistMemory(\"messages\") { return \"end\" } messages, _ := b.GetMemory(\"messages\").([]openai.ChatCompletionMessage) lastMsg := messages[len(messages)-1] if len(lastMsg.ToolCalls) == 0 { // no need to call any tools return \"end\" } return \"continue\" }\n\n### Building a Brain from a Brainprint\n\nBuild with various withOpts parameters, although it can be done without\nconfiguring any, similar to the example below, using default construction\nparameters.\n\n    \n    \n    brain := bp.Build()\n\n### Running the Brain\n\nAs long as any Link or Neuron of Brain is activated, it is considered to be\nrunning. The Brain can only be triggered to run through Links. You can set\ninitial brain memory Memory before the Brain runs to store some initial\ncontext, but this is an optional step. The following methods are used to\ntrigger Links:\n\n  * Use brain.Entry() to trigger all entry links.\n  * Use brain.EntryWithMemory() to set initial Memory and trigger all entry links.\n  * Use brain.TrigLinks() to trigger specific Links.\n  * You can also use brain.SetMemory() + brain.TrigLinks() to set initial Memory and trigger specific Links.\n\n\u26a0\ufe0fNote: Once a Link is triggered, the program is non-block; the operation of\nthe Brain is asynchronous.\n\n    \n    \n    // import \"github.com/sashabaranov/go-openai\" // just for message struct // set memory and trigger all entry links _ = brain.EntryWithMemory(\"messages\", []openai.ChatCompletionMessage{{Role: openai.ChatMessageRoleUser, Content: \"What is the weather in Boston today?\"}})\n\n### Retrieving Results from Memory\n\nBrain operations are asynchronous and unlimited in terms of timing for\nfetching results. We typically call Wait() to wait for Brain to enter Sleeping\nstate or for a certain Memory to reach the expected value before retrieving\nresults. Results are obtained from Memory.\n\n    \n    \n    // block process until the brain is sleeping brain.Wait() messages, _ := json.Marshal(brain.GetMemory(\"messages\")) fmt.Printf(\"messages: %s\\n\", messages)\n\n## Concept\n\n### Link\n\n### Neuron\n\n### Brainprint\n\n### Brain\n\n## How to\n\n## Agent Examples\n\n### Tool Use Agent\n\n#### ChatAgent: With Function Calling\n\nChatAgent takes a list of chat messages as input and outputs new messages to\nthis list. In this example, OpenAI's function calling feature is utilized. It\nis recommended to use in models facilitated with the function calling feature.\n\n  * Chat Agent With Tools: An example of creating a chat agent from scratch using tools.\n\n### Reflection / Self-Critique\n\nWhen output quality becomes a primary concern, a combination of self-\nreflection, self-critique, and external validation is often used to optimize\nthe system output. The example below shows how to implement such a design.\n\n  * Basic Reflection: Adds a simple \"reflect\" step in the Brain to prompt your system for output modification.\n\n### Plan and Execute\n\nThe examples below implement a typical \"plan and execute\" style of agent\narchitecture, where an LLM planner decomposes user requests into a program, an\nexecutor executes the program, and the LLM synthesizes responses (and/or\ndynamically replans) based on the program\u2019s output.\n\n  * Plan & Execute: A simple agent with a Planner that generates a multistep task list, an Executing Agent that invokes tools from the plan, and a replanner that responds or creates an updated plan.\n\n### Multi-Agent\n\nMulti-agent systems consist of multiple decision-making agents that interact\nin a shared environment to achieve common or conflicting goals.\n\n  * agent-supervisor: An example of a multi-agent system with an agent supervisor to help delegate tasks. In the example, the Leader delegates tasks to RD (Research and Development) and QA (Quality Assurance), if the code doesn\u2019t pass the test, it is sent back to RD for rewriting and then tested again, and the Leader makes corresponding decisions based on feedback, finally returning the tested code.\n\n## \ud83c\udf89 One More Thing\n\nHere we introduce the zenmodel-contrib repository, a community-driven\ncollection of Brain and Processor contributions. At zenmodel-contrib, every\nline of code is a testament to ideas and innovation. Go ahead, unleash your\ncreativity, and build your Brain like assembling Lego bricks. Also, you can\nfind other members' creative ideas here, expanding the boundaries of your\nthoughts.\n\nLet's have a look at the current list of resources, awaiting your discovery\nand innovation:\n\n#### Brain\n\nBrain| Introduction  \n---|---  \nopenai_tool_agent| A chat agent based on the OpenAI model, with tool support\nand calling  \n  \n#### Processor\n\nProcessor| Introduction  \n---|---  \ncalltools| A Processor that calls tools, with tool support and calling  \nopenaichat| A chat Processor based on the OpenAI model  \nopenai_structured_output| A structured output Processor based on OpenAI\nFunction Calling  \ngo_code_tester| A Go unit test runner, often used for testing code generated\nby LLM  \n  \n## About\n\nZenModel is a framework for building LLM applications with agentic workflow\n\ngithub.com/zenmodel/zenmodel\n\n### Topics\n\nagent golang flow workflow framework ai graph llm agentic\n\n### Resources\n\nReadme\n\n### License\n\nMIT license\n\nActivity\n\nCustom properties\n\n### Stars\n\n2 stars\n\n### Watchers\n\n1 watching\n\n### Forks\n\n1 fork\n\nReport repository\n\n## Releases\n\nNo releases published\n\n## Packages 0\n\nNo packages published\n\n## Languages\n\n  * Go 100.0%\n\n## Footer\n\n\u00a9 2024 GitHub, Inc.\n\nYou can\u2019t perform that action at this time.\n\n", "frontpage": false}
