{"aid": "40205406", "title": "Swift for C++ Practitioners, Part 7: Closures", "url": "https://www.douggregor.net/posts/swift-for-cxx-practitioners-closures/", "domain": "douggregor.net", "votes": 2, "user": "chmaynard", "posted_at": "2024-04-29 23:25:46", "comments": 0, "source_title": "Swift for C++ Practitioners, Part 7: Closures | Doug's Compiler Corner", "source_text": "Swift for C++ Practitioners, Part 7: Closures | Doug's Compiler Corner\n\nDoug's Compiler Corner\n\nOriginally posted on 2024-04-28 03:09:00 +0000\n\nLast updated on 2024-04-29 06:15:39 +0000\n\n# Swift for C++ Practitioners, Part 7: Closures\n\nThroughout this series, I've been using closures in examples without really\ndefining them. Swift closures are a whole lot like C++ lambdas, with a similar\ndesign and syntax, and generally the same use cases. This post is going to dig\na little deeper into Swift closures to give a better feel for how they work\nand how to make the best use of them.\n\n## The syntax\n\nA Swift closure is an expression delimited by curly braces, { ... } that\nrepresents an anonymous function. For example, this\n\n    \n    \n    let hello = { \"Hello\" }\n\ndefines a local variable hello that stores the closure. The type of hello is\n() -> String, i.e., a function that takes no parameters.\n\nSwift closures can be provided with parameters in one of two ways: anonymous\nparameters $0, $1, $2, and so on let you write very short closures for quick\none-off operations. For example:\n\n    \n    \n    let arithmeticOp: (Double, Double) -> Double switch opCode { case \"+\": arithmeticOp = { $0 + $1 } case \"-\": arithmeticOp = { $0 - $1 } case \"*\": arithmeticOp = { $0 * $1 } case \"/\": arithmeticOp = { $0 / $1 } default: throw InterpreterError.invalidOpcode(opCode) }\n\nPlease only use this shorthand for the smallest closures. Once you get behind\na single short expression, it's much better to name your parameters. To do so,\nlist them prior to in within the curly braces. The in separates the\ndeclaration part of the closure from its statements. For example, the first\ncase above could instead by written like this:\n\n    \n    \n    { x, y in x + y }\n\nIn fact, prior to the in, you can write a full-fledged parameter list with\ntype annotations, result type, and effect specifiers, if you don't want to\nleave them up to inference:\n\n    \n    \n    { (x: Double, y: Double) throws -> Double in let result = try addSafely(x, y) } return result }\n\nIt's fairly uncommon to see such closures with all of the types written out\nlike this, because the parameter types are generally inferred by context and\nthe result type can be inferred from the closure body. Indeed, if you end up\nfinding yourself writing a long closure that needs the full type annotations,\nit's likely that you should write a local function. Local functions are just\nlike functions at module or type scope, e.g.,\n\n    \n    \n    func produceAdder(x: Double) {} func doAdd(y: Double) -> Double { return x + y } }\n\nLike closures, local functions can capture local variables (such as x in the\nexample above). Unlike closures, local functions have a name and can have\ntheir own generic parameters. I'm not going to talk about local functions\nmore, because there's nothing more to say: they're functions, and they're\nlocal, and they work as you'd expect. I do want to talk about captures,\nthough!\n\n## Captures\n\nA capture is when a closure refers to a local variable (or parameter) from its\nenclosing scope. In such cases, the closure needs to a way to reference that\nvariable---or it's value---when it executes. A simple example would be a\nclosure that inserts elements into a set to remove duplicates from a\ncollection, returning a new array with the elements uniqued:\n\n    \n    \n    func uniquing<C: Collection>(from collection: C) -> [C.Element] where C.Element: Hashable { var known: Set<C.Element> = [] return collection.filter({ known.insert($0).inserted }) }\n\nThe closure passed to filter captures the local variable known. Each time it\nis called, it tries inserting the element it was given into the known set. If\nsuccessful (i.e., the element wasn't there), the inserted field in the result\nis true, so the element is kept in the filtered sequence. If the element\nwasn't there, the inserted field in the result is false, so it's dropped.\n\nSwift's captures are by reference. You can explicitly state the variables you\nwant to capture by providing a capture list using the familiar square bracket\nsyntax from C++ lambdas, but within the curly braces and before the (optional)\nparameter list. The filter call could, equivalently, look like this:\n\n    \n    \n    return collection.filter({ [known] in known.insert($0).inserted })\n\nThis makes the capture more explicit to the reader, but doesn't change the\nsemantics. If you want a by-copy capture rather than a by-reference capture,\nyou can define a new captured variable and give it an initializer, again with\nsyntax lifted from C++ lambdas:\n\n    \n    \n    return collection.filter({ [known=known] in known.insert($0).inserted // error: known is immutable })\n\nThis will make a copy of known into a capture called known. Note that such\ncaptures are immutable, so the above code would actually fail with an error\ncannot assign to value: 'count' is an immutable capture. However, this is a\nreasonable way to compute a captured value at the point of capture, ensuring\nthat you get a copy. For example, here we create a bunch of closures that\nproduce string values of the index in the loop where they were created:\n\n    \n    \n    var closures: [() -> String] = [] for i in 0..<100 { closures.append({ [string = String(i)] in string }) }\n\nI wouldn't expect most of the above to be surprising to a C++ practitioner,\nbecause it's mostly the same as lambdas. But the \"captures are by reference\"\nstatement might be a little nerve-wracking, because what happens if you return\na closure that captures by reference?\n\n    \n    \n    // Produce a function that adds `x` to whatever integer value it is given. func adding(x: Int) -> ((Int) -> Int) { return { x + $0 } }\n\nBad news, right? Not in Swift... let's look into the implementation model a\nbit.\n\n### Implementation model for captures\n\nThe implementation of C++ lambdas is fairly straightforward: for each lambda,\nthe compiler synthesizes a class. The code of the lambda goes into its\noperator(), and for each capture the compiler will create a non-static data\nmember. For example, let's consider this C++ lambda expression:\n\n    \n    \n    std::vector<int> values; int target; auto fn = [&values,target]() { values[0] = target; };\n\nThe corresponding synthesized class will look something like this:\n\n    \n    \n    class Synthesized { std::vector<int> &values; int target; public: Synthesized(std::vector<int> &values, int target) : values(values), target(target) { } void operator()() const { values[0] = target; } };\n\nBy-reference captures produce a non-static member of reference type, while by-\nvalue captures are of non-reference type (so you get a copy).\n\nSwift's translation of closures is conceptually similar, but the main\ndifference is in the handling of by-reference captures. Semantically, a by-\nreference capture in Swift promotes the captured local to the heap, and uses a\nreference type to box it up. For example, imagine we have this Box type:\n\n    \n    \n    class Box<T> { var value: T init(value: T) { self.value = value } }\n\nWhen a local variable like\n\n    \n    \n    var numbers: [Int]\n\nis captured by-reference in a closure, it is as if the local variable were\nrewritten to\n\n    \n    \n    var numbers: Box<[Int]>\n\nand every initialization of numbers creates a box instance, and every\nsubsequent access to numbers, whether it's in the function or a closure that\ncaptures it by reference, is rewritten to numbers.value.\n\nThis model makes it safe to return a closure from a function, even when that\nclosure captures a local in the function by reference:\n\n    \n    \n    func numberAccessor() -> ((Int) -> Int) { var numbers: [Int] = ... return { x in numbers[x] } }\n\nSince numbers is promoted to a Box<[Int]>, the returned closure itself keeps\nthe \"local\" variable alive on the heap until the closure is no longer used.\nIt's a simple model, and a safe one.\n\nBut if you actually did this for every local variable captured everywhere, it\nwould be a very, very slow model. Let's talk about optimizations.\n\n### Optimizations for captures\n\nThere are two main optimizations for by-reference captures in Swift. The first\nis to realize when the capture doesn't need to be by-reference at all: if\nwe're capturing a let, its value can't change anyway, so we can capture by\nvalue to avoid the boxing overhead without changing the semantics. There are\nmore complicated analyses one can do when capturing a var: if the var isn't\nmodified after the point of capture (either in the closure or outside of it),\nthen we can capture by value because the value isn't going to change.\n\nThe second optimization is when you can be sure that the closure itself won't\nlive longer than the variables it is capturing. In these cases, it is safe to\ndo a by-reference capture of the stack variable, without moving it to the\nheap. As C++ programmers, we make this kind of decision all the time based on\nknowledge of the functions we are calling: it's perfectly reasonable to use\nby-reference captures when passing a lambda into std::transform, because the\nalgorithm isn't going to escape the closure.\n\nThe problem in C++, of course, is that we could be wrong: if the lambda does\nuse by-reference captures and escapes, we have a stack use-after-free. If the\nlambda uses expensive by-copy captures and it never escapes, we've wasted some\nprocessor cycles and some memory.\n\nShouldn't the optimizer just figure out for us? Ideally, when the closure\ndoesn't escape, we'd use by-reference captures that refer to the local\nvariable on the stack, with no overhead. And when the closure does escape,\nwe'd promote the captured local variables to the heap to maintain memory\nsafety. Easy, right?\n\nThe problem is that you can't always see the code you're calling to determine\nwhether it stashes a copy of the closure somewhere. If I call some C++\nfunction:\n\n    \n    \n    void doSomething(std::function<int(int)> f);\n\nwith a lambda, I have no idea what it is going to do with f. Even if it's a\nC++ template like this:\n\n    \n    \n    template<typename F> void doSomething(F f);\n\nthe code might be hidden behind an explicit instantiation, or do something\ntricky with f that obscures the fact that it's storing a copy of it to execute\nlater. So either the optimizer has to go through heroics to prove that\ndoSomething doesn't stash a copy of f somewhere on the side, or it has to\nconservatively assume that the lambda could escape. The end result is that\nescape analysis like the one we would need to have both safe and efficient by-\nreference closures isn't actually very effective in C++.\n\nTo address this issue in Swift, we decided to change the language to make this\noptimization more reliable. The idea is simple:\n\n### Parameters of function type are non-escaping by default\n\nIn Swift, a parameter of function type is (by default) not allowed to escape\nthe function's stack frame. Let's see an example:\n\n    \n    \n    struct S { var fn: () -> Int mutating func doSomething(f: () -> Int) { fn = f // error: assigning non-escaping parameter 'f' to an @escaping closure } }\n\nThe function doSomething is trying to escape the value of f out of its stack\nframe by writing into the instance property fn. The compiler prevents such\nescapes systematically, and only allows the code to use f in a manner that\neither calls it (which is fine) or passes it down the stack to other functions\nthat won't escape it.\n\nBecause the non-escaping behavior is part of the interface contrace, the\noptimizer can safely assume that a closure passed to doSomething won't outlive\nits own stack frame. So this kind of code:\n\n    \n    \n    var numbers: [Int] = ... s.doSomething { if let value = numbers.last { numbers.removeLast() return value } return 0 }\n\nwe get by-reference captures without the overhead of promoting the local\nvariables to the heap. By making non-escaping the default, we get better\nperformance for the common cases that use closures for (e.g.) algorithms and\ncallbacks while maintaining the safe model.\n\n### Escaping function types\n\nYou might have noticed that my struct S had an instance property of function\ntype:\n\n    \n    \n    struct S { var fn: () -> Int }\n\nOutside of function parameters, values of function type are assumed to be\nescaping. If I were to assign directly into S.fn, the closure provided would\nbe assumed to be escaping, so it would promote mutable captures to the heap:\n\n    \n    \n    s.fn = { // promotes numbers to the heap if let value = numbers.last { numbers.removeLast() return value } return 0 }\n\nA function parameter can be explicitly marked with @escaping to allow its\nvalue to escape the function's stack frame. This is part of the type of the\nfunction, so callers know that they need to promote captures to the heap. For\nour doSomething function, it would look like this:\n\n    \n    \n    struct S { var fn: () -> Int mutating func doSomething(f: @escaping () -> Int) { fn = f // ok, f is marked @escaping } }\n\n### Getting around the escaping restrictions\n\nThe restriction on non-escaping functions can feel pretty harsh some times:\nyou can't, for example, put the non-escaping value into another local variable\nor inside a local struct, because the Swift compiler will flag it as a local\nescape. For example, even this is disallowed:\n\n    \n    \n    func haveFun(f: () -> Int) -> Int { var s = S(fn: f) // error: passing non-escaping parameter 'f' to function expecting an @escaping closure return s.fn() }\n\nSwift does have a mechanism to deal with such cases, using the standard\nlibrary function withoutActuallyEscaping: the basic idea is that\nwithoutActuallyEscaping lets you temporarily convert a non-escaping closure\ninto an escaping one. The escaping one is passed into a second closure that is\nimmediately evaluated and its result returned. So haveFun can be implemented\nas follows:\n\n    \n    \n    func haveFun(f: () -> Int) -> Int { withoutActuallyEscaping(f, body: { escapingF in var s = S(fn: escapingF) return s.fn() }) }\n\nThe first parameter to withoutActuallyEscaping is the non-escaping function f.\nThe second parameter, body, is a closure that takes the escaping form of f and\nis executed immediately.\n\nI know what you're thinking: after all that talk about safety with non-\nescaping parameters, how can there possibly be a standard library function\nthat just throws all of it away? Madness!\n\nWhat withoutActuallyEscaping is actually doing is deferring the correctness\ncheck for a non-escaping closure into a runtime check. If you try any funny\nbusiness that actually escapes escapingF out of the body closure, the program\nwill trap at runtime:\n\n    \n    \n    0 escape 0x000000010423750c haveFun(f:) + 144 1 escape 0x00000001042374dc main + 24 2 dyld 0x0000000187fa87a8 start + 2360 closure argument was escaped in withoutActuallyEscaping block: file escape.swift, line 9, column 3\n\nI triggered this by writing escapingF into a global. The implementation of\nwithoutActuallyEscaping is actually pretty neat: since escaping closures are\nreference counted (like other reference types in Swift),\nwithoutActuallyEscaping records the reference count of the function escapingF\nwhen it's passed into the body closure. Then, it checks whether the reference\ncount is the same on the way out of the body closure---if it is, all is well.\nIf the reference count on the way out is different, it means that escapingF\nhas escaped out of body, and we need to halt lest we cause undefined behavior.\n\nYou probably won't need withoutActuallyEscaping often, but when you need it,\nyou really need it. It also illustrates an important principle: static safety\nis great, but sometimes you need to step outside of the bounds of what a\ncompiler can statically prove is safe. When that happens, Swift takes the view\nthat it's better to roll into dynamic checking to maintain the safety model\nrather than ban the code entirely or throw away safety. We saw this in our\ndiscussions of the law of exclusivity in part 1 of this series, and it comes\nup again as part of Swift's concurrency model.\n\n## Trailing closures\n\nWhen passing C++ lambdas into C++ standard library algorithms, we often end up\nwith this ugly like }) thing at the end of every call:\n\n    \n    \n    std::copy_if(numbers.begin(), numbers.end(), std::back_inserter(even_numbers), [](auto x) { return x % 2 == 0 });\n\nI know, it's just syntax. It shouldn't be a big deal. But these standard\nalgorithms are supposed to feel like extensions of the language. It turns out\nthat Ruby has a nice approach here, which allows a closure to be juxtaposed\nwith a function name or call to be passed like a normal parameter. The\nstd::copy_if above, in Swift, would be a filter operation that looks more like\nthis:\n\n    \n    \n    numbers.filter { $0 % 2 == 0 }\n\nThe actual filter function is a collection algorithm declared like this:\n\n    \n    \n    extension Collection { func filter(_ isIncluded: () -> Bool) -> [Element] { ... } }\n\nYou can call filter by passing a function in parentheses, e.g.,\nnumbers.filter(isPrime), or use trailing closure syntax as we did above. When\ndesigning Swift APIs involving closures, you generally want to put the closure\nparameter at the end to allow trailing closure syntax. For example, perhaps we\nwant a version of filter that puts an upper limit on the number of elements\nthat will be removed. We could design it like this:\n\n    \n    \n    extension Collection { func filtering(removingAtMost maxRemovals: Int? = nil, isIncluded: () -> Bool) -> [Element] { ... }) }\n\nThis filtering function can be called with or without removingAtMost, while\nstill using trailing closure syntax:\n\n    \n    \n    numbers.filtering(removingAtMost: 17) { ... } // A numbers.filtering { ... } // B, maxRemovals defaults to nil numbers.filtering(removingAtMost: 17, isIncluded: { ... }) // same as A numbers.filtering(isIncluded: { ... }) // same as B, maxRemovals defaults to nil\n\nYou may have noticed that the trailing closure is unlabeled: the responsibiity\nis on the author of the function to ensure that the name of the function\nstrongly implies what the trailing closure does, so that code using the\nfunction reads clearly. After all, clarity at the point of use is one of the\ncentral tenets of Swift's API design guidelines.\n\n### Multiple trailing closures\n\nWhen a function takes multiple closure parameters, it's possible to call it\nwith multiple trailing closures. This can help make code clearer when there\nare multiple actions that could be taken. For example, imagine an API that\nexecutes an operation with a timeout, cancelling it early if time expires:\n\n    \n    \n    /// Run the given 'operation'. If it takes more than 'seconds', call the `onTimeout` function to /// abort the operation and throw a `TimeoutError` instance. func run<R>(timeout seconds: Double, operation: () -> R, onTimeout: () -> Void) throws -> R\n\nA call to this function could make use of multiple trailing closures:\n\n    \n    \n    run(timeout: 0.5) { while !aborted { // part of a long-running operation } } onTimeout: { aborted = true }\n\nBeyond the first trailing closure, the remaining trailing closures must have\nlabels matching the corresponding parameter's label. Again, this needs to be\nreflected in API design: the primary \"control flow\" operation should be the\nfirst closure, and remaining closures should have labels that clearly express\nhow and when the closure will be run.\n\n## Wrap-up & what's next\n\nFor the most part, you can think of Swift closures like C++ lambdas. Similar\nuse cases, similar syntax. Swift provides a safe model of captures that means\nyou don't generally have to fret over returning a closure or how captures\noccur, although you will need to mark some parameters @escaping for those\ntimes when you want to save a closure to be called later.\n\nTrailing closure syntax is a little nicety in Swift that makes closure-based\nAPIs cleaner to use. Yes, it's basically nothing more than removing the\nunsightly }) from a bunch of calls, but it's part of a larger design goal of\nenabling the design of powerful libraries that feel like extensions of the\nlanguage. In fact, that's going to be our next topic: the features Swift\nprovides for language extensibility and domain-specific embedded languages.\n\nTagged with:\n\n  * Swift\n  * C++\n\nGenerated using Publish\n\nRSS feed\n\n", "frontpage": false}
