{"aid": "40062866", "title": "Handling Exceptions in Grape for Ruby", "url": "https://blog.appsignal.com/2024/04/17/handling-exceptions-in-grape-for-ruby.html", "domain": "appsignal.com", "votes": 1, "user": "unripe_syntax", "posted_at": "2024-04-17 10:57:49", "comments": 0, "source_title": "Handling Exceptions in Grape for Ruby | AppSignal Blog", "source_text": "Handling Exceptions in Grape for Ruby | AppSignal Blog\n\n  * Features\n\n### Monitoring features\n\n    * Error tracking\n\n    * Performance monitoring\n\n    * Host monitoring\n\n    * Anomaly detection\n\n    * Uptime monitoring\n\n    * Metric dashboards\n\n    * Workflow\n\n    * Log management\n\n    * Automated Dashboards\n\n  * Languages\n\n### Supported Languages\n\n    * Ruby (on Rails) APM\n\n    * Elixir APM\n\n    * Node.js APM\n\n    * JavaScript Error Tracking\n\n    * Python APM\n\n  * Learn\n  * Docs\n  * Blog\n  * Pricing\n\n  * Login\n  * Start free trial\n\nMenu\n\nruby\n\n# Handling Exceptions in Grape for Ruby\n\nKingsley Chijioke on Apr 17, 2024\n\nGrape is a popular Ruby framework for building RESTful APIs. Exception\nhandling plays a crucial role in ensuring the stability and reliability of any\napplication, including those made with Grape.\n\nThis article will explore the basics of Grape exception handling, including\ncustomizing exceptions. We'll also touch on some best practices, and how to\nintegrate your app with AppSignal for enhanced error monitoring and\nmanagement.\n\nLet's get started!\n\n## Basics of Grape Exception Handling\n\nIn this tutorial, we\u2019ll see how to handle exceptions in a Grape API built in\nRails. I have made a demo job board API for this, and you can check out the\nsource code on GitHub.\n\n### Raising an Exception\n\nYou can raise an exception in Grape by using error!. For example, in the job\nAPI mentioned above, we have a show route that returns a job based on the ID.\nWe can return a 404 error when the record is not available, like this:\n\nruby\n\n    \n    \n    get do if job present job else error!('404 Not Found', 404) end end\n\nWhen you raise an exception, you\u2019ll want to handle it in a \u201cunique\u201d way \u2014 you\nmost likely will not want to send the raised exception to your users.\n\nIn Ruby, we have a default mechanism for exception handling. It works by\nwrapping code that might raise an exception in a begin block. The rescue block\nis used to handle the exception that has been raised.\n\nruby\n\n    \n    \n    begin #... process, may raise an exception rescue => #... error handler else #... executes when no error ensure #... always executed end\n\nSo, here is what that will look like in a typical scenario:\n\nruby\n\n    \n    \n    begin File.readlines('input.txt').each { |line| values << Float(line) } rescue Errno::ENOENT p 'file not found' rescue ArgumentError p 'file contains unparsable numbers' else print values end\n\n### The rescue_from Method\n\nWhen you raise exceptions, or they happen without your direct involvement,\nyou\u2019ll want to handle them properly. By default, Grape provides a rescue_from\nmethod. This allows you to specify a block of code that gets executed when\ndefined exceptions are raised.\n\nSo, to \u201crescue\u201d or handle the 404 error we raised before any other one that\narises in the jobs resource, we can use the rescue_from method. The method is\nadded above the jobs resource.\n\nruby\n\n    \n    \n    # Rescue 404 errors rescue_from :all do |error| error!({ error: error.message }, 404) end # Jobs resource resource :jobs do desc 'Return list of jobs' get do ... end ... end\n\nWe can also specify the content type to be used:\n\nruby\n\n    \n    \n    rescue_from :all do |error| error!({ error: error.message }, 404, { 'Content-Type' => 'text/error' }) end\n\nThis way of handling an exception is too generic \u2014 we are rescuing every form\nof exception and returning an error with a 404 status code. That is misleading\nif our API users expect to get a 400 status code.\n\nWe can instead specify the exception we want to handle:\n\nruby\n\n    \n    \n    rescue_from ActiveRecord::RecordNotFound do |error| error!({ error: error.message }, 404, { 'Content-Type' => 'text/error' }) end rescue_from :all do |error| error!({ error: error.message }, 500, { 'Content-Type' => 'text/error' }) end\n\nWhen we encounter an ActiveRecord::RecordNotFound error, we\u2019ll return an error\nmessage with a 404 status code. Otherwise, we\u2019ll return an error message with\na 500 status code.\n\nThis shows that we can improve on what we currently have, but what if we want\nan error handler that rescues from all errors? That's where customizing\nexceptions comes in.\n\n\u2193 Article continues below\n\n#### Is your app broken or slow? AppSignal lets you know.\n\nMonitoring by AppSignal \u2192\n\n## Customizing Exceptions in Grape for Ruby\n\nDepending on the type of error encountered, this error handler should be able\nto return an error message alongside the correct status code.\n\nFirst, create a file called exceptions_handler. Then, we\u2019ll move our current\nexception handlers into the file:\n\nruby\n\n    \n    \n    # frozen_string_literal: true module V1 module ExceptionsHandler extend ActiveSupport::Concern included do rescue_from ActiveRecord::RecordNotFound do |error| error!({ error: error.message }, 404, { 'Content-Type' => 'text/error' }) end rescue_from :all do |error| error!({ error: error.message }, 500, { 'Content-Type' => 'text/error' }) end end end end\n\nOur ExceptionHandler module uses ActiveSupport::Concern , allowing us to\naccess functionalities like included and class_methods. In the snippet above,\nwe have the error handlers in the included block, so wherever this module is\nincluded, they will be available as they\u2019re defined.\n\nWe can go ahead and remove the error handler from the files where we had them\npreviously. Then we can include the ExceptionsHandler module in our API entry\nfile \u2014 api.rb:\n\nruby\n\n    \n    \n    # frozen_string_literal: true module V1 class API < Grape::API include ExceptionsHandler mount V1::Jobs end end\n\nLet\u2019s create a base error class for our errors. This class will be responsible\nfor returning the error response.\n\nruby\n\n    \n    \n    module V1 module Exceptions class BaseError < StandardError attr_reader :status, :message def initialize(message: nil, status: nil) @status = status || 500 @message = message || \"Something unexpected happened.\" end def body Rack::Response.new({ error: message }.to_json, status) end end end end\n\nThe class accepts two keyword parameters: a message string and a status. If\nnone is passed, we\u2019ll use the default.\n\nIn the body method, we return a Rack response. By default, the rescue_from\nhandler must return a Rack::Response object, call error!, or raise an\nexception.\n\nWe can go ahead and make use of it in the ExceptionsHandler:\n\nruby\n\n    \n    \n    included do rescue_from ActiveRecord::RecordNotFound do |error| error!({ error: error.message }, 404, { 'Content-Type' => 'text/error' }) end rescue_from :all do |error| Exceptions::BaseError.new(message: error.message).body end end\n\nWhen we call the /error endpoint, we\u2019ll see oops returned as the response. At\nthis point, we can create a class for NotFound errors.\n\nruby\n\n    \n    \n    module V1 module Exceptions class NotFound < BaseError def initialize(message: nil) super( status: 404, message: message || \"Oops, we could not find the record you are looking for.\" ) end end end end\n\nThe NotFound class only accepts message. Since it inherits from BaseError, we\nneed not return a Rack::Response again. We can go ahead and use it in the\nExceptionsHandler like this:\n\nruby\n\n    \n    \n    included do rescue_from ActiveRecord::RecordNotFound do |error| Exceptions::NotFound.new(message: error).body end rescue_from :all do |error| Exceptions::BaseError.new(message: error.message).body end end\n\nNow, if we attempt to raise an error like this manually:\n\nruby\n\n    \n    \n    raise Exceptions::NotFound.new(message: \"Something unexpected happened.......\")\n\nThis will work fine, but the status code will be 500, because it returns the\nresponse in the BaseError class (as the BaseError class handles the error). To\nfix that, we\u2019ll need to modify the ExceptionHandler to explicitly use the\nNotFound class to handle the error instead.\n\nSo, whenever an error corresponding to ActiveRecord::RecordNotFound and\nV1::Exceptions::NotFound is encountered, use Exceptions::NotFound. Otherwise,\nuse Exceptions::BaseError.\n\nruby\n\n    \n    \n    included do rescue_from ActiveRecord::RecordNotFound do |error| Exceptions::NotFound.new(message: error).body end rescue_from V1::Exceptions::NotFound do |error| Exceptions::NotFound.new(message: error.message).body end rescue_from :all do |error| Exceptions::BaseError.new(message: error.message).body end end\n\nYou can see that we\u2019ll need specific\ufffcrescue_from\ufffcblocks as we create more\nerror classes. We can improve this by using case statements:\n\nruby\n\n    \n    \n    module V1 module ExceptionsHandler extend ActiveSupport::Concern included do rescue_from :all do |error| case error.class.name when 'ActiveRecord::RecordNotFound', 'V1::Exceptions::NotFound' Exceptions::NotFound.new(message: error.message).body else Exceptions::BaseError.new(message: error.message).body end end end end end\n\nEt voil\u00e0!\n\n## Best Practices and Tips\n\nWhile there are tons of best practices that you can employ for exception\nhandling, here are a few quick tips to follow:\n\n  1. Group related exceptions: As we saw in the code above, grouping related exceptions allow us to have maintainable code. As the number of exceptions we want to handle increases, we can add them to our list.\n  2. Use helpers like error! to quickly raise exceptions. This simplifies your exception handling.\n  3. Make use of exception monitoring tools like AppSignal.\n\n## AppSignal Integration: Grape for Ruby\n\nAppSignal helps you to monitor and track errors in your applications.\nIntegrating AppSignal with your Grape API gives you valuable insights into\nexceptions. This guide shows you how to integrate AppSignal with your Grape\nAPI. Whenever an error occurs in your API, you\u2019ll see it in your AppSignal\ndashboard, like so:\n\n## Wrapping Up\n\nException handling is a critical aspect of developing robust APIs. In this\ntutorial, we\u2019ve seen how to properly handle exceptions in a Grape API. We also\nbriefly looked at some best practices and AppSignal's integration for Grape.\n\nException handling is an ongoing process \u2014 one you\u2019ll need to improve on\nconsistently.\n\nHappy coding!\n\nP.S. If you'd like to read Ruby Magic posts as soon as they get off the press,\nsubscribe to our Ruby Magic newsletter and never miss a single post!\n\nP.P.S. Did you know that AppSignal offers an Active Record integration? Find\nout more.\n\n# Share this article\n\nRSS\n\n# Kingsley Chijioke\n\nOur guest author Kingsley is a Software Engineer who enjoys writing technical\narticles.\n\nAll articles by Kingsley Chijioke\n\nBecome our next author!\n\nFind out more\n\n# Magicians never share their secrets. But we do. Subscribe to our Ruby Magic\nemail series and get in-depth Ruby articles.\n\n# AppSignal monitors your apps\n\nAppSignal provides insights for Ruby, Rails, Elixir, Phoenix, Node.js, Express\nand many other frameworks and libraries. We are located in beautiful\nAmsterdam. We love stroopwafels. If you do too, let us know. We might send you\nsome!\n\nDiscover AppSignal\n\n## Features\n\n  * Error tracking\n\n  * Performance monitoring\n\n  * Host monitoring\n\n  * Anomaly detection\n\n  * Uptime monitoring\n\n  * Metric dashboards\n\n  * Workflow\n\n  * Log management\n\n  * Automated Dashboards\n\n## Resources\n\n  * Plans & pricing\n\n  * Documentation\n\n  * Blog\n\n  * Customer Stories\n\n  * Compare AppSignal to Datadog\n\n  * Compare AppSignal to New Relic\n\n  * Changelog\n\n  * Learning Center\n\n  * Why AppSignal\n\n## Support\n\nDo you need help, have a feature request or just need someone to rubber duck\nwith? Get in touch with one of our engineers.\n\n  * Contact us\n\n  * Live chat\n\n  * Status\n\n  * Security\n\n## About us\n\nAppSignal is located in the beautiful Netherlands. We love stroopwafels. If\nyou do too, let us know. We might send you some!\n\n  * About\n\n  * Jobs\n\n  * Write for Our Blog\n\n  * Diversity\n\n  * Open Source\n\n  * Twitter\n\n## Languages\n\n  * Ruby\n\nActive Record, Capistrano, Delayed::Job, Garbage Collection, Global VM Lock,\nGrape, GraphQL, Hanami, MongoDB, Padrino, Puma, Que, Rake, Resque, Ruby on\nRails, Shoryuken, Sidekiq, Sinatra, Webmachine\n\n  * Elixir\n\nEcto, Erlang, Finch, Oban, Phoenix, Plug\n\n  * Node.js\n\nExpress, Fastify, fs Module, GraphQL, Knex.js, Koa, MongoDB, Mongoose, MySQL,\nNestJS, Next.js, PostgreSQL, Prisma, Redis, Remix, Restify\n\n  * JavaScript\n\nReact, Vue, Angular, Ember, Preact, Stimulus\n\n  * Python\n\nCelery, Django, FastAPI, Flask, Jinja2, Psycopg2, Redis, Request, Starlette,\nWSGI and ASGI\n\n  * Terms & Conditions\n  * Privacy Policy\n  * Cookie Policy\n  * GDPR compliance\n  * Contact us / Imprint\n\n", "frontpage": false}
