{"aid": "40165822", "title": "Why is my CPU usage always 100%? (Upgrading my Chumby 8 kernel part 9)", "url": "https://www.downtowndougbrown.com/2024/04/why-is-my-cpu-usage-always-100-upgrading-my-chumby-8-kernel-part-9/", "domain": "downtowndougbrown.com", "votes": 2, "user": "todsacerdoti", "posted_at": "2024-04-26 03:54:46", "comments": 0, "source_title": "Downtown Doug Brown \u00bb Why is my CPU usage always 100%? (Upgrading my Chumby 8 kernel part 9)", "source_text": "Downtown Doug Brown \u00bb Why is my CPU usage always 100%? (Upgrading my Chumby 8\nkernel part 9)\n\n# Downtown Doug Brown\n\n## Thoughts from a combined Apple/Linux/Windows geek.\n\n  * Home\n  * About\n  * Mac ROM SIMMs\n  * Software\n  * Microcontroller lessons\n  * Contact\n\nApr\n\n25\n\n## Why is my CPU usage always 100%? (Upgrading my Chumby 8 kernel part 9)\n\nDoug Brown Linux 2024-04-25\n\nIf you\u2019re new to this series, I\u2019ve been documenting the process I went through\nupgrading my old PXA166-based Chumby 8\u2019s 2.6.28 Linux kernel to a modern 6.x\nversion. Here are links to parts 1, 2, 3, 4, 5, 6, 7, and 8. At this point in\nthe project, all of the main hardware peripherals were working great. I\nnoticed something odd when running top though. The CPU usage was always really\nhigh, and it wasn\u2019t obvious why.\n\n    \n    \n    Mem: 47888K used, 55968K free, 168K shrd, 3116K buff, 27480K cached CPU: 100% usr 0% sys 0% nic 0% idle 0% io 0% irq 0% sirq Load average: 0.00 0.00 0.00 2/51 269 PID PPID USER STAT VSZ %VSZ %CPU COMMAND 267 200 root R 2936 3% 100% top 100 1 root S 12240 12% 0% /sbin/udevd -d 1 0 root S 2936 3% 0% init 200 1 root S 2936 3% 0% -sh 65 1 root S 2936 3% 0% /sbin/syslogd -n 71 1 root S 2936 3% 0% /sbin/klogd -n 34 2 root SW 0 0% 0% [irq/56-mmc0] 10 2 root IW 0 0% 0% [kworker/0:1-eve] 11 2 root IW 0 0% 0% [kworker/u2:0-ev] 41 2 root IW< 0 0% 0% [kworker/0:2H-kb] 8 2 root IW 0 0% 0% [kworker/0:0-lib] 22 2 root IW< 0 0% 0% [kworker/0:1H-mm] 32 2 root SW 0 0% 0% [irq/55-mmc1] 14 2 root IW 0 0% 0% [rcu_preempt] 17 2 root IW 0 0% 0% [kworker/u2:1-ev] 15 2 root SW 0 0% 0% [kdevtmpfs] 27 2 root IW 0 0% 0% [kworker/0:2-pm] 2 0 root SW 0 0% 0% [kthreadd] 13 2 root SW 0 0% 0% [ksoftirqd/0] 3 2 root SW 0 0% 0% [pool_workqueue_]\n\nThat\u2019s really weird! Why would top be using all of my CPU? It says 100% usr in\nthe second line. Sometimes the usage showed up as 50% usr and 50% sys. Other\ntimes it would show up as 100% sys. And very rarely, it would show 100% idle.\nIn that rare case, top would actually show up with 0% usage as I would expect.\nThe 2.6.28 kernel did not have this problem, so it was something different\nabout my newer kernel.\n\nI started theorizing about what might be wrong here. My ideas were nothing\nmore than wild guesses: maybe one of the drivers I got working earlier was\ntotally monopolizing the CPU and making it look like other processes were\nusing all the CPU. Or perhaps I was missing some kind of CPU idle support so\nthe processor was stuck running at 100% at all times, never able to take a\nbreak. Maybe there was some power management support missing from the mainline\nkernel or something. I needed to figure out a way to narrow down the\npossibilities.\n\nMy first step in diagnosing this problem was to go back in time. Several years\nago, I had played with getting Linux 3.13 working on my Chumby 8 before I gave\nup on the project due to not having enough time or experience. This ended up\nbeing useful in the present day because I could try booting the old 3.13\nkernel to see if it had the same issue.\n\nI quickly discovered that the 3.13 kernel had the same exact problem. This was\ndefinitely a useful data point. It meant nothing recent had broken it. Also, I\ndidn\u2019t have many drivers working in that old kernel, so it ruled out a lot of\npossible causes. I said goodbye to the old kernel and thanked it for its\ninsight.\n\nNext, I tried profiling my modern kernel by enabling CONFIG_PROFILING. Then I\nadded profile=2 to my kernel command line. Lastly, I made sure System.map from\nmy Linux build directory was copied over to /boot on my Chumby. Now I was\nready to do profiling.\n\n    \n    \n    readprofile -r # resets the counters top # run top and wait for a while, then type q to exit readprofile # this prints out the final profiling results\n\nThe readprofile results were interesting. The entire output was far too long\nto put here, but here is the bottom of what it spit out.\n\n    \n    \n    ... 38 lock_is_held_type 0.0888 8 debug_lockdep_rcu_enabled 0.1000 4 __schedule 0.0019 1 preempt_schedule_irq 0.0068 1 __mutex_unlock_slowpath 0.0012 1 mutex_trylock 0.0022 3 __mutex_lock 0.0017 1 down_read_killable 0.0093 3974 default_idle_call 24.2317 4 _raw_spin_lock 0.0435 1 _raw_spin_lock_irq 0.0078 1 _raw_spin_lock_irqsave 0.0081 29 _raw_spin_unlock_irq 0.2788 118 _raw_spin_unlock_irqrestore 0.8429 0 *unknown* 4722 total 0.0006\n\nAs you can see based on the total, default_idle_call used up the vast majority\nof the time. This seemed normal to me. After this test I felt pretty confident\nthat I shouldn\u2019t be blaming any of the random peripheral drivers I had worked\non. The CPU was definitely idle, but why didn\u2019t top think so?\n\nI traced my way through what happens in default_idle_call. It seems like the\nmain thing it ends up doing is calling arch_cpu_idle. On ARM, this ends up\ncalling arm_pm_idle if it exists, and otherwise it will call cpu_do_idle.\narm_pm_idle doesn\u2019t seem to be used on this particular ARM machine, so I kept\ntracing through cpu_do_idle. The final result is it ends up calling\ncpu_mohawk_do_idle on the PXA168, confirmed by disassembling the final vmlinux\nfile with objdump.\n\nThis function doesn\u2019t seem very complex (this is from the Linux 6.8 code):\n\n12345| ENTRY(cpu_mohawk_do_idle)mov r0, #0mcr p15, 0, r0, c7, c10, 4 @ drain\nwrite buffermcr p15, 0, r0, c7, c0, 4 @ wait for interruptret lr  \n---|---  \n  \nHere\u2019s the corresponding function in the 2.6.28 kernel source:\n\n123456| ENTRY(cpu_mohawk_do_idle)mov r0, #0#ifdef CONFIG_ENABLE_COREIDLEmcr\np15, 0, r0, c7, c0, 4 @ Wait for interrupt#endifmov pc, lr  \n---|---  \n  \nSo they\u2019re pretty much the same thing, except the newer kernel also drains the\nwrite buffer. I observed that CONFIG_ENABLE_COREIDLE was not defined on the\n2.6.28 kernel though, so that was quite a big difference. I double checked the\n2.6.28 kernel with objdump just to make sure:\n\n123| c0207000 <cpu_mohawk_do_idle>:c0207000: e3a00000 mov r0, #0c0207004:\ne1a0f00e mov pc, lr  \n---|---  \n  \nYeah, the wait for interrupt was definitely not there in 2.6.28. This gave me\nsome ideas to try and I was starting to feel some hope that I might have found\nsomething. I tinkered with making the modern kernel\u2019s cpu_mohawk_do_idle\nfunction identical to the old version. This honestly didn\u2019t make logical sense\nthough. Wouldn\u2019t removing a \u201cwait for interrupt\u201d instruction actually make\nthings worse in terms of idling the CPU? I shut off my brain and tried it out\nanyway. Why not?\n\nEven though I thought I was making great progress, this whole branch of\nresearch turned out to be a red herring. No matter what tinkering I did in\ncpu_mohawk_do_idle, top was taking up 100% CPU. I went from thinking I was on\nthe cusp of solving the problem, right back to square one.\n\nAfter walking away from the problem for a while, I realized I had been\nthrowing around random guesses instead of using logic. I decided to attack\nthis problem from another angle instead. One simple question led me in a new\ndirection: how does top calculate the CPU usage it displays? I realized I had\nno freaking clue how top worked. It was all just magic to me. I looked at\nBusyBox\u2019s source code to try to understand how it works.\n\nIt turns out that all of top\u2019s information comes from procfs, mounted at\n/proc. At the beginning of the source file you can see a comment that says \u201cAt\nstartup this changes to /proc, all the reads are then relative to that.\u201d This\nis confirmed on line 1150 where it changes the working directory.\n\nWhat it does is read several files: /proc/stat, /proc/meminfo, and all of the\n/proc/<pid>/stat files \u2014 one for each running process. Iterating through all\nof the processes is handled by procps_scan in BusyBox\u2019s implementation of top.\nA comment in the source helpfully informs us that man 5 proc gives more info\nabout the content of these files. I focused on /proc/stat, which is\nresponsible for providing the info in the second line of top\u2019s output showing\nhow the CPU load is distributed between user, system, idle, etc.\n\nThe man page says that the lines beginning with \u201ccpu\u201d in /proc/stat contain a\nbunch of numbers corresponding to the amount of time spent in a bunch of\ndifferent states. Here is some example output from my desktop computer:\n\n    \n    \n    cpu 33032 1025 8433 426488 1422 0 314 0 0 0\n\nThe numbers, in order from left to right, represent time spent in: user mode,\nnice (user mode low priority), system, idle, iowait, irq, softirq, steal,\nguest, and guest_nice. They are in units of USER_HZ, which it claims is\nusually 1/100ths of a second but can vary. I can see that is correct on my\nx86_64 machine:\n\n    \n    \n    $ getconf CLK_TCK 100\n\nI didn\u2019t have getconf available on my buildroot-generated Chumby rootfs. I\nprobably could have turned on a package to add it, but it\u2019s easy enough to\njust throw together a quick C program to figure it out instead:\n\n    \n    \n    #include <stdio.h> #include <unistd.h>\n    \n    int main(int argc, char *argv[]) { printf(\"%ld\\n\", sysconf(_SC_CLK_TCK)); return 0; }\n\nSurprise surprise, it\u2019s the same as my desktop PC.\n\n    \n    \n    # /tmp/test 100\n\nNow that I knew my units were 1/100ths of a second, I tried a few experiments.\nIt appears that top simply checks the values in /proc/stat periodically, and\ncalculates the load by looking at the differences in the values between each\niteration. So I theorized that if the CPU mostly has nothing going on, I\nshould be able to look at the file content, sleep 10 seconds, look at the file\ncontent again, and expect the idle count to go up by about 1000. That\u2019s\nbecause 1000 * (1/100ths of a second) = 10 seconds. I decided to try it out,\nstarting on my desktop PC:\n\n    \n    \n    $ cat /proc/stat | grep 'cpu' ; sleep 10 ; cat /proc/stat | grep 'cpu' cpu 49815 370 14743 25000206 3471 0 169 0 0 0 cpu0 2606 12 713 1563406 121 0 2 0 0 0 cpu1 2605 31 680 1563428 194 0 0 0 0 0 cpu2 4065 56 804 1562009 106 0 2 0 0 0 cpu3 2688 11 812 1563209 160 0 1 0 0 0 cpu4 3100 10 840 1562442 505 0 0 0 0 0 cpu5 2820 13 1032 1562568 150 0 1 0 0 0 cpu6 2714 42 821 1562976 241 0 1 0 0 0 cpu7 4316 25 1250 1560486 175 0 2 0 0 0 cpu8 3397 6 1132 1562333 117 0 2 0 0 0 cpu9 3366 16 1035 1562254 75 0 5 0 0 0 cpu10 3435 34 748 1562466 207 0 6 0 0 0 cpu11 3044 6 803 1562672 67 0 98 0 0 0 cpu12 3202 17 1007 1562161 287 0 2 0 0 0 cpu13 2612 18 1158 1562700 400 0 0 0 0 0 cpu14 2827 49 940 1562505 422 0 39 0 0 0 cpu15 3014 18 963 1562585 238 0 2 0 0 0\n\n...10 seconds passed by, and then this printed out:\n\n    \n    \n    cpu 49844 370 14756 25016161 3472 0 169 0 0 0 cpu0 2606 12 713 1564405 121 0 2 0 0 0 cpu1 2606 31 680 1564426 194 0 0 0 0 0 cpu2 4066 56 804 1563008 106 0 2 0 0 0 cpu3 2689 11 815 1564204 160 0 1 0 0 0 cpu4 3101 10 840 1563440 505 0 0 0 0 0 cpu5 2822 13 1032 1563566 150 0 1 0 0 0 cpu6 2714 42 821 1563976 241 0 1 0 0 0 cpu7 4316 25 1250 1561484 175 0 2 0 0 0 cpu8 3398 6 1132 1563332 117 0 2 0 0 0 cpu9 3367 16 1035 1563252 75 0 5 0 0 0 cpu10 3441 34 750 1563458 207 0 6 0 0 0 cpu11 3047 6 806 1563666 67 0 98 0 0 0 cpu12 3206 17 1007 1563156 287 0 2 0 0 0 cpu13 2614 18 1160 1563696 400 0 0 0 0 0 cpu14 2829 49 942 1563503 422 0 39 0 0 0 cpu15 3015 18 964 1563583 238 0 2 0 0 0\n\nAha, so there\u2019s a total, along with a separate line for each CPU. Remember\nthat the idle count is the 4th column. Let\u2019s look at a before and after\ncomparison of cpu13, for example:\n\n    \n    \n    cpu13 2612 18 1158 1562700 400 0 0 0 0 0 cpu13 2614 18 1160 1563696 400 0 0 0 0 0\n\nThat looks about right! The idle count for that CPU increased by 996, which is\nabout 1000. Here\u2019s a comparison between the \u201ctotal CPU\u201d lines:\n\n    \n    \n    cpu 49815 370 14743 25000206 3471 0 169 0 0 0 cpu 49844 370 14756 25016161 3472 0 169 0 0 0\n\nThe total idle count increased by 15955, which is about 1000 times 16. This is\nmy AMD Ryzen 5700G with 8 cores and 16 threads. Each thread is treated as a\nCPU as far as Linux is concerned. Okay, the math checked out! I felt like I\nunderstood how top does its calculations.\n\nNext, I performed a similar comparison in my modern Chumby kernel. There\u2019s\nonly one CPU, so it prints out cpu and cpu0 lines that are identical. I\ndecided to filter it further to only show the total CPU:\n\n    \n    \n    # cat /proc/stat | grep 'cpu ' ; sleep 10 ; cat /proc/stat | grep 'cpu ' cpu 420 0 3204 4 0 0 599 0 0 0 cpu 421 0 3213 6 0 0 600 0 0 0\n\nI had finally made some real progress in tracking down the issue. This output\nis just plain wrong. Even though 10 seconds elapsed between the two lines\nbeing printed, the idle count only went up by 2. This was indicating that the\nCPU had only spent 0.02 seconds idling during that period. That result made\nabsolutely no sense, because the other columns only increased by a total of 1\n+ 9 + 1 = 11 ticks = 0.11 seconds.\n\nAt this point, I excitedly booted up the old 2.6.28 kernel which seemed to\nbehave perfectly fine with top, and repeated the experiment:\n\n    \n    \n    # cat /proc/stat | grep 'cpu ' ; sleep 10 ; cat /proc/stat | grep 'cpu ' cpu 4 0 198 4067 5 1 16 0 0 cpu 4 0 199 5067 5 1 17 0 0\n\nThe idle tick count increased by exactly 1000 ticks, also known as 10 seconds\n\u2014 just as I would have expected! This gave me something to actually start\nlooking at in my new kernel. It wasn\u2019t incrementing the idle tick counter for\nsome reason. Well, occasionally it did, but not very often. This perfectly\nexplains why it would almost always show the CPU as being 100% busy. It\u2019s\nbecause top just calculates the percentages of each column\u2019s ticks added\nversus the total ticks added between each time it checks. With the difference\nin idle ticks being 0 or close to 0 every time, it makes sense that the CPU\nwas usually showing up as 100% busy.\n\nNow that I knew what was happening, the next question was: why? Where in the\nkernel would I find the code that increments the idle tick count? What could\npossibly be broken to only cause this to happen on the PXA16x?\n\nI searched around a bit and happened to find this commit to the OLPC kernel.\nIt\u2019s very straightforward: it disables CONFIG_NO_HZ in xo_4_defconfig. The\ncommit message by Jon Nettleton mentioned a problem that seemed very similar\nto mine:\n\n> There appears to be an accounting problem when CONFIG_NO_HZ is enabled in\n> our kernel that leads to high system cpu percentage reporting. This in turn\n> breaks fast user suspend.\n\nInteresting! The commit title starts with \u201carm: mmp3\u201d which means it\u2019s another\nMarvell CPU newer than mine, so I was intrigued by this. CONFIG_NO_HZ is\nexplained in detail in the kernel documentation. What it does is disables\nperiodic timer interrupts used by the scheduler when the CPU is idle. It turns\nout that my kernel had CONFIG_NO_HZ_IDLE=y, which is effectively the same\nthing as what used to be CONFIG_NO_HZ=y. So I had a config similar to the\nconfig OLPC was using when they experienced this problem!\n\nThis left me with some new ideas to try. Luckily, the kernel documentation\nlinked above explains old and new names for all of the relevant config\noptions. In particular, it told me that the equivalent of disabling\nCONFIG_NO_HZ on a newer kernel would be to set CONFIG_HZ_PERIODIC=y instead.\nIt also informed me that I could boot with an extra kernel command line option\n\u201cnohz=off\u201d to temporarily try it without recompiling. So I booted with\nnohz=off and reran my tests:\n\n    \n    \n    Mem: 50240K used, 53616K free, 200K shrd, 3116K buff, 27276K cached CPU: 0% usr 0% sys 0% nic 99% idle 0% io 0% irq 0% sirq\n\nI immediately knew the problem was gone, because top was no longer showing\n100% CPU usage. That \u201c99% idle\u201d section above was music to my ears. And\nobviously, running the same test with /proc/stat worked correctly too:\n\n    \n    \n    # cat /proc/stat | grep 'cpu ' ; sleep 10 ; cat /proc/stat | grep 'cpu ' cpu 345 0 731 7170 67 0 0 0 0 0 cpu 347 0 733 8167 67 0 0 0 0 0\n\nOLPC\u2019s workaround fixed the problem for me too!\n\nThis was exciting, but I didn\u2019t feel satisfied with it. It felt a bit like\nmagic. I knew I needed to dig further to discover exactly what the problem\nactually was. CONFIG_NO_HZ_IDLE should have been working fine, so I was pretty\nsure there was a bug somewhere deeper. I wanted to be able to use my CPU in\ndyntick-idle mode!\n\nI decided to trace backwards starting from /proc/stat. Where is the code in\nthe kernel that provides /proc/stat, and where does it get its idle time\nnumber?\n\nThe content of /proc/stat is provided by the show_stat function in\nfs/proc/stat.c. At the bottom of the file you can see the call to proc_create\nwhich sets up \u201cstat\u201d as a file in /proc. Anyway, show_stat calls\nget_idle_time, which calls get_cpu_idle_time_us. This last function is\ndefinitely interesting because the comment above it informs us that \u201cThis time\nis measured via accounting rather than sampling.\u201d\n\nIt looks at the time by calling get_cpu_sleep_time_us, which itself is calling\nktime_get to find the current time to use in its accounting. I couldn\u2019t\nimagine that any of the actual math being done here was wrong. Otherwise,\nwouldn\u2019t there be huge uproar and lots of people with different architectures\nwould all be seeing this? The fact that the same thing had happened on another\nMarvell ARCH_MMP processor was a major clue.\n\nWhat does ktime_get return and how does it work? The idea behind it is simple.\nIt returns a ktime_t which represents a monotonically increasing timer stored\nin nanoseconds. Specifically, the documentation says that the time returned by\nktime_get starts at system boot but pauses during suspend. At some point it\u2019s\ngoing to have to call into hardware-specific code, which is where I suspected\nthe problem was.\n\nIf you follow the chain of calls from ktime_get, you end up going through some\nfunctions in kernel/time/timekeeping.c, eventually ending up at tk_clock_read\nwhich calls the read function provided by a clocksource. A clocksource is, as\nthe kernel source code says, a \u201chardware abstraction for a free running\ncounter.\u201d Finally, I had found the path to some hardware-specific code.\n\nI searched in the kernel\u2019s arch/arm/mach-mmp source directory for anything\nrelated to clocksource. Bingo:\n\n    \n    \n    time.c: * Support for clocksource and clockevents time.c:static u64 clksrc_read(struct clocksource *cs) time.c:static struct clocksource cksrc = { time.c: .name = \"clocksource\", time.c: clocksource_register_hz(&cksrc, rate);\n\nLooking further at the clocksource that is registered in this file, I saw that\nthe relevant function for grabbing the current time would be clksrc_read:\n\n1234567| static struct clocksource cksrc = {.name = \"clocksource\",.rating =\n200,.read = clksrc_read,.mask = CLOCKSOURCE_MASK(32),.flags =\nCLOCK_SOURCE_IS_CONTINUOUS,};  \n---|---  \n  \nThat is simply a wrapper for timer_read, which is the actual code that reads\nfrom the hardware timer:\n\n1234567891011121314| /** FIXME: the timer needs some delay to stablize the\ncounter capture*/static inline uint32_t timer_read(void){int delay =\n100;__raw_writel(1, mmp_timer_base + TMR_CVWR(1));while\n(delay--)cpu_relax();return __raw_readl(mmp_timer_base + TMR_CVWR(1));}  \n---|---  \n  \nThis code is more complicated than what I expected to see. I was thinking it\nwould just be a simple register read. Instead, it has to write a 1 to the\nregister, and then delay for a while, and then read back the same register.\nThere was also a very noticeable FIXME in the comment for the function, which\ndefinitely raised a red flag in my mind.\n\nI decided to go back to the Armada 16x software manual to read up on the\nhardware timers. My first thought was perhaps I had the timer configured for\nthe wrong clock rate, but I was able to confirm that the timer was indeed\nconfigured for 3.25 MHz just like code said it was. At the bottom of page 683\nin the PDF, I found an interesting blurb about the timer count registers:\n\n> The timer values are read under risk of metastability. Therefore, reading\n> each one of the CR Register values in the timer clock time base is\n> accomplished by either of the following: Double-read procedure and comparing\n> the two read values to ensure that the value is valid using the CVWR\n> Register, especially effective for fast clock timers.\n\nSome formatting or punctuation must have been lost during creation of the\nmanual. I had to read the above paragraph about 10 times before I figured out\nwhat I think it was trying to say. Here\u2019s my edited version:\n\n> The timer values are read under risk of metastability. Therefore, reading\n> each one of the CR Register values in the timer clock time base is\n> accomplished by either of the following:\n>\n>   1. Double-read procedure and comparing the two read values to ensure that\n> the value is valid.\n>   2. Using the CVWR Register, especially effective for fast clock timers.\n>\n\nClearly the code in the Linux kernel was implementing the second solution. I\nchecked out Marvell\u2019s documentation for the CVWR register. Let\u2019s just say the\ndocumentation about the register was quite sparse:\n\n> This register prevents the risk of instability on counter value reading\n>\n> Write: 0x0: No effect 0x1: Capture value of CRn Read: Returns the captured\n> value of CRn Register\n\nYeah, that\u2019s definitely what the kernel was trying to do. On a whim, I decided\nto try replacing the existing code with a simple read of the counter register\ninstead, ignoring the metastability risk altogether:\n\n1234| static inline uint32_t timer_read(void){return\n__raw_readl(mmp_timer_base + TMR_CR(1));}  \n---|---  \n  \nIt worked! With this change, top showed good idle CPU time. I was confident I\nhad found the source of the problem. I went back to the original broken code\nreading from the CVWR register and played around some more. If I increased the\ndelay from 100 to 500 iterations, the original code started working. Tweaking\nit further, 200 didn\u2019t work but 300 did.\n\nI had finally found the root problem. My initial guesses about the issue were\ntotally wrong. It was a simple timing problem during register reads. The\nexisting code wasn\u2019t waiting long enough after asking the timer to capture the\nlatest value, so it was returning the value from the previous read attempt\ninstead. The FIXME comment above the function was correct. Too bad the\nsoftware manual didn\u2019t give me any info about what the delay should actually\nbe.\n\nAround this point, I remembered that Chumby\u2019s original 2.6.28 kernel worked\ncorrectly, so I decided to take a look at its version of this section of code.\nNot surprisingly, it had a different version of timer_read:\n\n123456789101112131415161718192021| /** Note: the timer needs some delay to\nstablize the counter capture*/static inline uint32_t timer_read(void){volatile\nint delay = 4;unsigned long flags;uint32_t val =\n0;local_irq_save(flags);__raw_writel(1, TIMERS_VIRT_BASE + TMR_CVWR(0));while\n(delay--) {val = __raw_readl(TIMERS_VIRT_BASE + TMR_CVWR(0));}val =\n__raw_readl(TIMERS_VIRT_BASE + TMR_CVWR(0));local_irq_restore(flags);return\nval;}  \n---|---  \n  \nFirst of all it was using timer 0 instead of timer 1, but the big difference\nwas it implemented the delay by performing multiple reads from the register\nrather than an empty loop. It was also disabling interrupts during the\ncapture.\n\nI searched for more Marvell vendor kernels to see if they did the timer read\nany differently:\n\n  * https://github.com/kumajaya/android_kernel_samsung_lt02/blob/24c62c9af6bf6d424aaa3f249099b0eef8ccbec4/arch/arm/mach-mmp/time.c#L60\n  * https://github.com/embeddedTS/linux-2.6.34-ts471x/blob/c3de2e89f23d328e99253b2320efd8944e524b08/arch/arm/mach-mmp/time.c#L61\n\nThe kernel at the first link seemed to be implementing the double-read\napproach that Marvell had suggested, but only if the timer was configured for\n32.768 KHz. Otherwise it did something similar to the Chumby 2.6.28 kernel,\nbut without disabling interrupts. The second link seemed to just ignore the\nrisk of metastability altogether when in 32.768 KHz mode, and otherwise also\nimplemented a solution similar to the old Chumby kernel.\n\nThis bug has been in the kernel ever since the MMP architecture was added. The\noriginal patch submission adding PXA168 support in early 2009 contained the\nproblematic code, but it was using timer 0 instead of timer 1. So it\u2019s kind of\na hybrid of the Chumby kernel\u2019s code and the newer mainline code. At this\npoint it didn\u2019t have FIXME in the comment:\n\n1234567891011121314| /** Note: the timer needs some delay to stablize the\ncounter capture*/static inline uint32_t timer_read(void){int delay =\n100;__raw_writel(1, TIMERS_VIRT_BASE + TMR_CVWR(0));while\n(delay--)cpu_relax();return __raw_readl(TIMERS_VIRT_BASE + TMR_CVWR(0));}  \n---|---  \n  \nHowever, the FIXME is in the initial commit in the kernel git history, so\nsomeone at the time must have known that something was still broken in the\ncode. It appears that changing to timer 1 instead of 0 was a change added\nlater to ensure that clockevents had their own timer instead, fixing a bug\nobserved on the OLPC XO-1.75.\n\nI was shocked that nobody had ever noticed this bug in the mainline kernel,\nbut that\u2019s what happened. I guess to be more accurate, the OLPC project did\nnotice it at one point, but since they had a workaround it wasn\u2019t a huge deal.\nI decided to go ahead and fix the underlying problem.\n\nBecause Marvell vendor kernels read from the register multiple times to\nimplement the delay for the CVWR approach, that\u2019s what I went for. I had to\ndecide how many iterations to delay. Chumby\u2019s kernel did a total of 5 reads of\nthe CVWR register. The other two kernels did a total of 3 reads. I opted to\nuse 4 as a middle ground, just in case Chumby had a real reason to have more\niterations. I also decided against disabling interrupts during the delay. It\nseemed pointless \u2014 what\u2019s the worst that could happen? Two timer reads happen\nnearly simultaneously and the first read ends up returning a slightly later\ntime value than it would have otherwise returned? Or maybe the first read\nattempt is canceled and returns the old timer value instead? I suppose that\ncould be problematic. Oh well, the existing code wasn\u2019t disabling interrupts\neither.\n\nI first submitted my fix for this problem in September 2022, but I didn\u2019t\nreceive any responses. I ended up resubmitting it later that year and CCing\nthe main SoC maintainers the second time, and they took care of merging my\nfix. It was finally released with Linux 6.2 and was also backported to several\n4.x, 5.x, and 6.x kernels. Ever since I implemented this fix, I haven\u2019t\nnoticed any problems with CPU time reporting on my Chumby.\n\nThat\u2019s the story of how I figured out why the CPU usage was always showing up\nas 100% on my Chumby 8. It was quite the journey through the source code of\nBusyBox, /proc, and multiple layers of kernel code to find a little gremlin in\nthe code that reads from the PXA168\u2019s timer count register. It was very\nsatisfying to be able to fix the problem! The time I spent was totally worth\nit too. I learned all about how procfs works and how top gets its info about\nCPU usage. I still feel like I know almost nothing about the internals of the\nLinux kernel, but solving a problem like this was a fantastic way to dip my\ntoes into it.\n\nIn the next post in my Chumby kernel upgrade series, I\u2019m going to go over how\nI got the real-time clock working, so that it would remember the date and time\nwhile it was turned off.\n\nAddress: https://www.downtowndougbrown.com/2024/04/why-is-my-cpu-usage-\nalways-100-upgrading-my-chumby-8-kernel-part-9/\n\n\u00ab Upgrading my Chumby 8 kernel part 8: audio\n\nTrackback\n\n### no comments\n\n### Add your comment now\n\n  * ## Subscribe\n\n  * ## Recent Posts\n\n    * Why is my CPU usage always 100%? (Upgrading my Chumby 8 kernel part 9)\n    * Upgrading my Chumby 8 kernel part 8: audio\n    * More fun with Apple\u2019s internal tools: creating a PDS card\n    * How Apple\u2019s developers reflashed Mac ROMs in the \u201990s\n    * Upgrading my Chumby 8 kernel part 7: touchscreen\n    * Revisiting programmable Mac ROM SIMMs in Quadras\n    * Porting my Mac ROM SIMM programmer from AVR to ARM\n    * How am I supposed to safely disable this warning on ARM GCC?\n  * ## Categories\n\n    * Classic Mac (8)\n    * Computer repair (8)\n    * Electronics repair (4)\n    * iOS (3)\n    * Linux (35)\n    * Mac ROM hacking (11)\n    * Microcontroller lessons (11)\n    * Microcontrollers (1)\n    * Product reviews (5)\n    * Python (1)\n    * Qt (5)\n    * Uncategorized (20)\n    * Windows (5)\n  * ## Archives\n\n    * April 2024 (2)\n    * December 2023 (1)\n    * November 2023 (2)\n    * September 2023 (3)\n    * August 2023 (3)\n    * June 2023 (1)\n    * May 2023 (1)\n    * April 2023 (1)\n    * March 2023 (2)\n    * January 2023 (1)\n    * December 2022 (3)\n    * August 2022 (1)\n    * May 2022 (2)\n    * March 2022 (1)\n    * December 2021 (1)\n    * June 2021 (1)\n    * April 2021 (1)\n    * January 2021 (1)\n    * September 2020 (1)\n    * August 2020 (1)\n    * July 2020 (1)\n    * May 2020 (1)\n    * June 2019 (1)\n    * April 2019 (1)\n    * December 2018 (1)\n    * August 2018 (1)\n    * May 2018 (1)\n    * April 2018 (3)\n    * February 2018 (1)\n    * October 2017 (1)\n    * July 2017 (1)\n    * May 2017 (3)\n    * March 2017 (1)\n    * October 2016 (1)\n    * June 2015 (1)\n    * March 2015 (1)\n    * November 2014 (1)\n    * August 2014 (3)\n    * July 2014 (1)\n    * April 2014 (1)\n    * March 2014 (1)\n    * February 2014 (1)\n    * November 2013 (1)\n    * August 2013 (1)\n    * June 2013 (3)\n    * April 2013 (1)\n    * March 2013 (1)\n    * January 2013 (2)\n    * December 2012 (2)\n    * August 2012 (1)\n    * July 2012 (2)\n    * June 2012 (1)\n    * May 2012 (1)\n    * February 2012 (3)\n    * January 2012 (1)\n    * November 2011 (1)\n    * October 2011 (2)\n    * August 2011 (3)\n    * May 2011 (1)\n    * April 2011 (1)\n    * March 2011 (2)\n    * November 2010 (2)\n    * October 2010 (3)\n    * July 2010 (5)\n  * ## Recent Comments\n\n    * Doug Brown on Upgrading my Chumby 8 kernel part 8: audio\n    * Oliv' on Upgrading my Chumby 8 kernel part 8: audio\n    * Doug Brown on How to create a Qt 5 ARM/Intel universal binary for Mac\n    * Natalia on How to create a Qt 5 ARM/Intel universal binary for Mac\n    * dave on Repairing a Microsoft IntelliMouse Explorer 4.0\n    * Doug Brown on Upgrading my Chumby 8 kernel part 8: audio\n    * Steve on Upgrading my Chumby 8 kernel part 8: audio\n    * Doug Brown on Parallel Port Tester\n    * Christopher J Siegle on Parallel Port Tester\n    * Doug Brown on Upgrading my Chumby 8 kernel part 7: touchscreen\n  * ## Spam Blocked\n\n189,466 spam blocked by Akismet\n\nDowntown Doug Brown \u00b7 coogee theme \u00b7 2008 \u00b7 Privacy Policy\n\nRSS Feed \u00b7 WordPress \u00b7 TOP\n\n", "frontpage": false}
