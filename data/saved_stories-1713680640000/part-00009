{"aid": "40101358", "title": "Nvidia on Wayland: A New Hope", "url": "https://zamundaaa.github.io/wayland/2024/04/05/explicit-sync.html", "domain": "zamundaaa.github.io", "votes": 1, "user": "adriatp", "posted_at": "2024-04-20 21:55:53", "comments": 0, "source_title": "Explicit sync", "source_text": "Explicit sync | Xaver\u2019s blog\n\nXaver's blog\n\n# Explicit sync\n\nApr 5, 2024\n\nRecently news went around about explicit sync being merged into Wayland\nprotocols, and in the wake of that I saw a lot of people having questions\nabout it, and why it was such a big deal... So here\u2019s a short-ish explanation\nof what it is, why it\u2019s needed and what the benefits are over the old model.\n\n# Why is synchronization needed?\n\nWhen applications \u201crender\u201d things, that rendering doesn\u2019t happen immediately.\nInstead, they effectively record a list of commands with OpenGL or Vulkan for\nthe GPU to execute, and that list then gets handed to the GPU to execute at\nits own pace.\n\nThis is needed for performance reasons: If the CPU had to wait for the GPU to\nexecute each command one by one, both CPU and GPU would often sit around,\ndoing nothing except waiting for the other one to finish its task. By\nexecuting commands on the GPU while the CPU does other things, like preparing\nnew commands for the GPU, both can do a lot more work in the same time.\n\nHowever, in practice, rendering commands don\u2019t stand alone on their own. You\nmight be running one task to render an image, and another one to process the\nresult into something else, or to read it back to the CPU, so that it can be\nsaved as a file on disk. If you do that without synchronization, you might be\nreading from the image in the middle of rendering, or even before the GPU has\nstarted to work on the buffer at all.\n\n# The \u201cold\u201d model: Implicit sync\n\nTraditionally with graphics APIs like OpenGL, the necessary synchronization\nhas been done implicitly, without the application\u2019s involvement. This means\nthat the kernel and/or the userspace graphics driver look at the commands the\napplication is sending to the GPU, check which images the commands are using,\nwhich previous tasks have to be completed before it, and potentially make the\napplication wait until the dependencies of the commands it wants to execute\nare resolved.\n\nThe so-called dma buffer infrastructure that the Linux graphics stack uses for\nexchanging images between applications - like Wayland apps and the compositor\n- also uses the same model. When the render commands from the compositor try\nto read from an app\u2019s buffer, the kernel will delay the command\u2019s execution\nuntil the app has completed its rendering to the buffer.\n\nThis model makes it easy for application developers to write correctly working\napplications, but it can also cause issues. The most relevant of them for\nWayland is that the application isn\u2019t aware of which tasks it\u2019s synchronizing\nto, and it can happen that you accidentally and unknowingly synchronize to GPU\ncommands that don\u2019t have any relevance to your task.\n\nThis has been a problem that Wayland compositors have been affected by for a\nlong time: When presenting application images to the screen, compositors\npicked the latest image that the application has provided, which could still\nhave GPU tasks running on it, instead of an earlier image that\u2019s actually\nready for presentation. This meant that sometimes presentation was delayed by\nthe kernel, and you\u2019d see a frame be dropped entirely, instead of just a\nslightly older image. This issue has been solved for most compositors in the\nlast two years using the kernel\u2019s implicit-explicit sync interop mechanism^1;\nI won\u2019t explain the details of that here, but you can read Michel D\u00e4nzer\u2019s\nblog post about it instead.\n\n# The \u201cnew\u201d model: Explicit sync\n\nThe name already suggests exactly what it does: Instead of the driver or the\nkernel doing potentially unexpected things in the background, the application\nexplicitly tells the relevant components (driver / kernel / compositor / other\napps) when rendering is complete and what tasks to synchronize to in the first\nplace, using various synchronization primitives.\n\nOn the application side, explicit sync is used in Vulkan, and the Wayland\nprotocol specifically is used internally by OpenGL and Vulkan drivers to\nsynchronize with the Wayland compositor.\n\nThis explicit way of synchronizing GPU commands doesn\u2019t just help avoid\naccidental synchronizations, it also helps improve performance by reducing the\nwork drivers have to do. Instead of having to figure out the dependencies of\ntasks from a relatively opaque list of commands, apps just tell them directly.\n\nAn important thing to mention here is that we already had a protocol for\nexplicit sync, zwp_linux_explicit_synchronization_unstable_v1, but it shared a\nlimitation with implicit sync: In order to get a synchronization primitive, it\nstill required the GPU commands to be first submitted to the kernel. The new\nprotocol in contrast allows to create and share synchronization primitives\nwithout submitting work to the GPU first, which - at least in theory - will\nallow applications to squeeze a little bit more performance out of your\nhardware in the future.\n\nDo keep in mind though that these performance improvements are minor. While\nthere may be some special cases where implicit sync between app and compositor\nwas the bottleneck before, you\u2019re unlikely to notice the individual difference\nbetween implicit and explicit sync at all.\n\n# Why the big fuzz then?\n\nIf we already have most of the compositor-side problems with implicit sync\nsolved, and explicit sync doesn\u2019t bring major performance improvements for\neveryone, why is it such big news then?\n\nThe answer is simple: The proprietary NVidia driver doesn\u2019t support implicit\nsync at all, and neither commonly used compositors nor the NVidia driver\nsupport the first explicit sync protocol, which means on Wayland you get\nsignificant flickering and frame pacing issues. The driver also ships with\nsome workarounds, but they don\u2019t exactly fix the problem either:\n\n  * it delays Wayland commits until rendering is completed, but it goes against how graphics APIs work on Wayland and can cause serious issues, even crash apps in extreme cases\n  * it delays X11 presentation until rendering is completed, but as Xwayland copies window contents sometimes, that still often causes glitches if Xwayland is also using the NVidia GPU for those copies\n\nThere\u2019s been a lot of discussions around the internet between people\nexperiencing the issues constantly, and others not seeing any, and now you\nshould know why it doesn\u2019t seem to affect everyone: It\u2019s not a deterministic\n\u201cthis doesn\u2019t work\u201d problem but a lack of synchronization, which means that a\nlot of factors - like the apps you use, the CPU and GPU you have, the driver\nversion, the kernel, compositor and so on - decide whether or not you actually\nsee the issue.\n\nWith the explicit sync protocol being implemented in compositors and very soon\nin Xwayland and the proprietary NVidia driver, all those problems will finally\nbe a thing of the past, and the biggest remaining blocker for NVidia users to\nswitch to Wayland will be gone.\n\n  1. this was referred to as \u201cexplicit sync through a backdoor\u201d in an earlier version of this post \u21a9\n\n## Xaver's blog\n\n  * Xaver Hugl\n  * xaver.hugl@gmail.com\n\nMore or less random posts about stuff in KDE and computer graphics.\n\n", "frontpage": false}
