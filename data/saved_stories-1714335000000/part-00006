{"aid": "40188378", "title": "Show HN: Fully Homomorphic Encryption from Scratch", "url": "https://www.daniellowengrub.com/blog/2024/01/03/fully-homomorphic-encryption", "domain": "daniellowengrub.com", "votes": 1, "user": "lowdanie", "posted_at": "2024-04-28 13:19:18", "comments": 0, "source_title": null, "source_text": "  * Blog\n  * About\n\n## Contents\n\n  * Introduction\n  * A Fully Homomorphic NAND Gate\n  * Learning With Errors\n\n    * Notation\n    * The Learning With Errors Problem\n    * An LWE Based Encryption Scheme\n    * Ciphertext Noise\n    * Message Encoding\n    * Homomorphic Operations\n    * Homomorphic Addition\n    * Homomorphic Multiplication By Plaintext\n    * Noise Analysis\n    * Trivial Encryption\n  * Homomorphic NAND Revisited\n\n    * Definition\n    * Implementation Strategy\n  * Bootstrapping\n\n    * Definition\n    * Noise Properties\n    * Implementation Strategy\n  * Ring LWE\n\n    * Introduction\n    * Negacyclic Polynomials\n    * The RLWE Encryption Scheme\n    * Message Encoding\n    * Homomorphic Addition\n    * Homomorphic Multiplication By Plaintext\n    * Trivial Encryption\n    * LWE To RLWE Keys\n  * A Homomorphic Multiplexer\n\n    * Introduction\n    * The GSW Encryption Scheme\n    * Encryptions Of Zero\n    * The Base-p Representation\n    * GSW Encryption and Homomorphic Multiplication\n  * Blind Rotation\n\n    * Definition\n    * Implementation\n    * Noise Analysis\n  * Sample Extraction\n\n    * Definition\n    * Implementation\n    * Noise Analysis\n  * Bootstrapping Implementation\n\n    * Building The Step Function From Polynomial Rotations\n    * A Homomorphic Step Function\n    * Noise Analysis\n    * Performance\n\n# Fully Homomorphic Encryption from Scratch\n\n03 Jan 2024\n\n# Introduction\n\nFully Homomorphic Encryption (FHE) is a form of encryption that makes it\npossible to evaluate functions on encrypted inputs without access to the\ndecryption key. For example, suppose you want to use a neural network running\non an untrusted server to determine whether your image contains a cat. Since\nthe server is untrusted, you do not want it to see your image. With FHE you\ncan encrypt the image with your secret key and upload the encrypted image to\nthe server. The server can then apply its neural network to the encrypted\nimage and produce an encrypted bit. You can then download the encrypted bit\nand decrypt it with your secret key to obtain the result.\n\nIn other words, FHE makes it possible to leverage the computational resources\nof an untrusted server without having to send it any unencrypted data.\n\nAt first glance it seems like FHE is impossible. Encrypted data should be\nindistinguishable from random bytes to a person without access to the\nencryption key. So how could such a person perform a meaningful calculation on\nthe encrypted data?\n\nIn this post we will explore a popular FHE encryption scheme called TFHE and\nimplement it from scratch in Python. All of the code in this post together\nwith tests can be found here: https://github.com/lowdanie/tfhe\n\nThe standard cryptography exposition disclaimer applies. Namely, that it\nprobably is not a good idea to copy paste code from this post to secure your\nsensitive data. You can use the official TFHE library instead.\n\n# A Fully Homomorphic NAND Gate\n\nAny boolean function can be implemented with a combination of NAND gates.\nTherefore, in this post we\u2019ll focus on implementing a homomorphic version of\nthe NAND gate which can be evaluated on encrypted inputs.\n\nSpecifically, we\u2019ll implement generate_key, encrypt and decrypt functions:\n\n    \n    \n    def generate_key() -> EncryptionKey: pass def encrypt(plaintext: Plaintext, key: EncryptionKey) -> Ciphertext: pass def decrypt(ciphertext: Ciphertext, key: EncryptionKey) -> Plaintext: pass\n\nand a homomorphic NAND gate:\n\n    \n    \n    def homomorphic_nand( ciphertext_left: Ciphertext, ciphertext_right: Ciphertext, ) -> Ciphertext: \"\"\"Homomorphically evaluate the NAND function.\"\"\" pass\n\nThe homomorphic property will allow us to perform the following type of\ncomputation:\n\n    \n    \n    # Client side: Create an encryption key and encrypt two bits. client_key = generate_key() b_0 = True b_1 = False ciphertext_0 = encrypt(b_0, client_key) ciphertext_1 = encrypt(b_1, client_key) # The client sends the ciphertexts to the server. # Server side: Compute an encryption of NAND(b_0, b_1) from # the two ciphertexts: ciphertext_nand = homomorphic_nand(ciphertext_0, ciphertext_1) # The server sends ciphertext_nand back to the client. # Client side: Decrypt ciphertext_nand. # The result should be equal to NAND(True, False) = True result = decrypt(ciphertext_nand, client_key) assert result\n\nImportantly, the server never receives the client_key and so it is not able to\nread the contents of ciphertext_left or ciphertext_right. Nevertheless, it can\nrun the homomorphic_nand function on the ciphertexts to produce\nciphertext_nand which encrypts NAND(b_0, b_1). Without the client_key, the\nserver cannot read the contents of ciphertext_nand. All it can do is send\nciphertext_nand back to the client who can use their client_key to decrypt it\nand reveal the result.\n\nOf course, all of this complexity is unnecessary if the client is only\ninterested in evaluating a single NAND gate. The client would be better off\njust evaluating the NAND function locally not involving a server at all.\n\nHomomorphic encryption becomes more useful when the client wants to evaluate a\ncomplex circuit such as a neural network which is composed of many billions of\nNAND gates. In that case the client may not have the compute or the permission\nto run the program locally. Instead they can offload the computation to an\nuntrusted server using the approach in the code snippet above, where the\nhomomorphic_nand function is used by the server to evaluate each of the NAND\ngates in the complex circuit.\n\nThe goal of this post is to implement generate_key, encrypt, decrypt and\nhomomorphic_nand.\n\n# Learning With Errors\n\nIn this section we wil implement generate_key, encrypt and decrypt. This\ncombination of functions is typically called an Encryption Scheme.\n\nEncryption schemes are usually based on a fundamental mathematical problem\nthat is assumed to be \u201chard\u201d. For example, RSA is based on the assumption that\nis is hard to find the prime factors of large integers. Similarly, TFHE is\nbased on a problem called Learning With Errors (LWE). In the next section we\nwill define the LWE problem and use it to construct an encryption scheme.\n\nAs we will see, in the LWE encryption scheme it is possible to homomorphically\nadd ciphertexts but not to homomorphically multiply them. This type of\nencryption scheme is called Partially Homomorphic because not all operations\nare supported. Despite this limitation, the partially homomorphic operations\nin the LWE scheme will be useful stepping stones on the path towards fully\nhomomorphic encryption.\n\nIn this section we will define the Learning With Errors (LWE) problem and use\nit to implement our encryption scheme as well as some homomorphic operations.\n\n## Notation\n\nLet be a positive integer. We will denote the integers modulo by . In this\npost, it will be convenient to set so that elements of can be represented by\nthe signed 32-bit integers: . One advantage of using 32-bit integers is that\nall operations are natively done modulo .\n\nSimilarly, will denote the integers modulo . We will identify with the set of\nintegers .\n\n## The Learning With Errors Problem\n\nLet be a length vector with elements in which is assumed to be secret. Let be\nrandom vectors and let be the dot product of with . As a warmup to the LWE\nproblem we can ask:\n\n> Given random vectors and the dot products , is it possible to efficiently\n> learn the secret vector ?\n\nIt is not hard to see that the answer is \u201cyes\u201d. Indeed, we can create an\nmatrix whose rows are the vectors and a length vector whose elements are :\n\nWe can then express as the solution to the linear equation:\n\nFinally, we can use Gaussian Elimination to solve for in polynomial time. Note\nthat the standard Gaussian elimination algorithm has to be tweaked a bit to\naccount for the fact that is not a field - but the general idea is the same.\n\nWe can think of the above problem as Learning Without Errors since we are\ngiven the exact dot products . It turns out that if we introduce errors by\nadding a bit of noise to each , then learning from the random vectors and the\nnoisy dot products is very hard. We can now state the Learning With Errors\nproblem:\n\n> Given random vectors and noisy dot products , is it possible to efficiently\n> learn the secret vector ?\n\nNote that we have not yet specified which distribution the errors are drawn\nfrom. In TFHE, they are sampled by first sampling a real number from a\nGaussian distribution with , and then scaling by to obtain a number in the\ninterval and finally rounding to the nearest integer:\n\nWe will denote the distribution on obtained in this way by .\n\nIn the next section we will see how to build a partially homomorphic\nencryption scheme based on the hardness of LWE.\n\n## An LWE Based Encryption Scheme\n\nFollowing the notation of the previous section, our encryption scheme will be\nparameterized by a modulus , a dimension and a noise level . Typical values\nwould be , and .\n\nThe valid inputs to an encryption function are known as the message space. The\nmessage space of the LWE scheme is . We will also call valid messages\nplaintexts.\n\nThe encryption keys are random length binary vectors .\n\nTo encrypt a message with a key we first uniformly sample a vector and sample\na noise element from the Gaussian distribution . The encrypted message, also\nknown as the ciphertext, is defined to be the pair\n\nIf we know the secret key , we can decrypt a ciphertext by computing:\n\nIn section Message Encoding we\u2019ll describe a method for removing the error\nterm in the equation above so that we can recover the exact message after\ndecryption.\n\nNote that the encryption function is not deterministic since it samples from\nthe distribution . It turns out that this is a feature and not a bug. Indeed,\nany semantically secure encryption scheme must have a non-deterministic\nencryption function. To see why, suppose we use the scheme to encrypt yes/no\nresponses to a poll. If the encryption function was deterministic, we could\ntell if two people voted the same way by comparing their encrypted responses.\nIn a non-deterministic scheme, this attack no longer works since even two\npeople that voted the same way will have different encrypted responses.\n\nLet be an LWE plaintext. Since the encryption function is non-deterministic,\nrather than saying that a ciphertext is the encryption of we will say that it\nis an encryption of . The set of valid encryptions of with key will be denoted\n. If then is an encryption of and so we can write:\n\nHere is an implementation of the LWE encryption scheme:\n\ntfhe/lwe.py\n\n    \n    \n    import dataclasses import numpy as np from tfhe import utils @dataclasses.dataclass class LweConfig: # Size of the LWE encryption key. dimension: int # Standard deviation of the encryption noise. noise_std: float @dataclasses.dataclass class LwePlaintext: message: np.int32 @dataclasses.dataclass class LweCiphertext: config: LweConfig a: np.ndarray # An int32 array of size config.dimension b: np.int32 @dataclasses.dataclass class LweEncryptionKey: config: LweConfig key: np.ndarray # An int32 array of size config.dimension def generate_lwe_key(config: LweConfig) -> LweEncryptionKey: return LweEncryptionKey( config=config, key=np.random.randint( low=0, high=2, size=(config.dimension,), dtype=np.int32 ), ) def lwe_encrypt( plaintext: LwePlaintext, key: LweEncryptionKey ) -> LweCiphertext: a = utils.uniform_sample_int32(size=key.config.dimension) noise = utils.gaussian_sample_int32(std=key.config.noise_std, size=None) # b = (a, key) + message + noise b = np.add(np.dot(a, key.key), plaintext.message, dtype=np.int32) b = np.add(b, noise, dtype=np.int32) return LweCiphertext(config=key.config, a=a, b=b) def lwe_decrypt( ciphertext: LweCiphertext, key: LweEncryptionKey ) -> LwePlaintext: return LwePlaintext( np.subtract(ciphertext.b, np.dot(ciphertext.a, key.key), dtype=np.int32) )\n\nwhere the utils module contains:\n\ntfhe/utils.py\n\n    \n    \n    from typing import Optional import numpy as np INT32_MIN = np.iinfo(np.int32).min INT32_MAX = np.iinfo(np.int32).max def uniform_sample_int32(size: int) -> np.ndarray: return np.random.randint( low=INT32_MIN, high=INT32_MAX + 1, size=size, dtype=np.int32, ) def gaussian_sample_int32(std: float, size: Optional[float]) -> np.ndarray: return np.int32(INT32_MAX * np.random.normal(loc=0.0, scale=std, size=size))\n\nThroughout this post, we will used the following LweConfig whose parameters\nare taken from the popular Lattice Estimator.\n\ntfhe/config.py\n\n    \n    \n    from tfhe import lwe LWE_CONFIG = lwe.LweConfig(dimension=1024, noise_std=2 ** (-24))\n\n## Ciphertext Noise\n\nLet be an LWE plaintext and let be an LWE encryption key. Let be an LWE\nencryption of . In the previous section we saw that:\n\nwhere is some small noise whose magnitude depends on the LWE parameters. In\nother words, when we decrypt we get the original message together with a small\nerror term. We will call the noise in the ciphertext .\n\nAs an example, we\u2019ll use the code above to encrypt the message one thousand\ntimes and plot a histogram of the ciphertext noise. We\u2019ll use the LWE config\nabove where the encryption noise has a standard deviation of . Since we\nmultiply this by during encryption following equation , we expect the\nciphertext noise to have a standard deviation of roughly .\n\nGenerate LWE Error Samples\n\n    \n    \n    # Generate an LWE key. key = lwe.generate_lwe_key(config.LWE_CONFIG) # This is the plaintext that we will encrypt. plaintext = lwe.LwePlaintext(2**29) # Encrypt the plaintext 1000 times and store the error of each ciphertext. errors = [] for _ in range(1000): ciphertext = lwe.lwe_encrypt(plaintext, key) errors.append(lwe.lwe_decrypt(ciphertext, key).message - plaintext.message)\n\nHere is a histogram of errors:\n\nThis matches our estimated standard deviation of pretty well.\n\n## Message Encoding\n\nIn the previous section we saw that when we decrypt a ciphertext with LWE we\nget the original message plus a small error. For some applications such as\nneural networks a small amount of error may be tolerable. An alternative\napproach is to restrict the set of possible messages so that a message can be\nrecovered from by rounding to the nearest message in the restricted set.\n\nFor the purposes of this post we will only need to distinguish between 8\ndifferent messages and so all of our messages will be of the form where .\n\nHere is a depiction of as a circle starting from in the \u201c3 o\u2019clock\u201d position\nand going counter clockwise all the way around to . Note that modulo which is\nwhy we are depicting as a closed circle. The eight messages are drawn as blue\ndots:\n\nWe will use the following encoding function to encode an integer as an LWE\nplaintext in (i.e as a 32-bit integer):\n\nSimilarly, we will use the following decoding function to convert a 32-bit LWE\nplaintext in back to an integer in :\n\nwhere denotes rounding to the nearest integer. In terms of the image above,\nthe decoding function maps a point on the circle to the nearest blue dot.\n\nThe thick segment of the circle depicts points whose distance from the message\nis less than . Note that for the points in this segment, the closest blue dot\nis . In general, if and then\n\nIn the previous section we saw that, using our standard LWE parameters, the\ndistribution of LWE ciphertext errors has a standard deviation of around which\nis significantly less than . This means that if and is an encryption of then\nwe can decrypt and remove the noise by decoding:\n\nIn summary, if we only encrypt messages that are encodings of then we can use\nthe decoding function to remove the noise from our decryption results.\n\nHere is an implementation of the encoding and decoding functions:\n\ntfhe/utils.py\n\n    \n    \n    def encode(i: int) -> np.int32: \"\"\"Encode an integer in [-4, 4) as an int32\"\"\" return np.multiply(i, 1 << 29, dtype=np.int32) def decode(i: np.int32) -> int: \"\"\"Decode an int32 to an integer in the range [-4, 4) mod 8\"\"\" d = int(np.rint(i / (1 << 29))) return ((d + 4) % 8) - 4\n\ntfhe/lwe.py\n\n    \n    \n    def lwe_encode(i: int) -> LwePlaintext: \"\"\"Encode an integer in [-4,4) as an LWE plaintext.\"\"\" return LwePlaintext(utils.encode(i)) def lwe_decode(plaintext: LwePlaintext) -> int: \"\"\"Decode an LWE plaintext to an integer in [-4,4) mod 8.\"\"\" return utils.decode(plaintext.message)\n\nIn the following example we\u2019ll use the encoding and decoding functions to\nencrypt a message and recover the exact message without noise after\ndecryption.\n\nLWE Message Encoding Example\n\n    \n    \n    key = lwe.generate_lwe_key(config.LWE_CONFIG) # Encode the number 2 as an LWE plaintext plaintext = lwe.lwe_encode(2) # Encrypt the plaintext ciphertext = lwe.lwe_encrypt(plaintext, key) # Decrypt the ciphertext. The result will contain noise. decrypted = lwe.lwe_decrypt(ciphertext, key) # Decode the result of the decryption. The decoded decryption # should be exactly equal to the initial message of 2. decoded = lwe.lwe_decode(decrypted) assert decoded == 2\n\n## Homomorphic Operations\n\nIn the next two sections we will show that the LWE scheme above is homomorphic\nunder addition and multiplication by a plaintext.\n\nMore precisely, we will define a homomorphic addition function with the\nfollowing signature:\n\nIn other words, takes as input encryptions of and and outputs an encryption of\n.\n\nSimilarly, let be an LWE plaintext. We will define a homomorphic\n\u201cmultiplication by \u201d function with the signature:\n\nIn other words, takes as input a plaintext and an encryption of and outputs an\nencryption of .\n\nImportantly, these homomorphic operations operate only on ciphertexts and do\nnot receive the secret key as an input.\n\nWe will add these operations to our library by implementing the following\nmethods:\n\ntfhe/lwe.py\n\n    \n    \n    def lwe_add( ciphertext_left: LweCiphertext, ciphertext_right: LweCiphertext ) -> LweCiphertext: \"\"\"Homomorphically add two LWE ciphertexts. If ciphertext_left is an encryption of m_left and ciphertext_right is an encryption of m_right then the output will be an encryption of m_left + m_right. \"\"\" pass def lwe_plaintext_multiply(c: int, ciphertext: LweCiphertext) -> LweCiphertext: \"\"\"Homomorphically multiply an LWE ciphertext with a plaintext integer. If the ciphertext is an encryption of m then the output will be an encryption of c * m. \"\"\" pass\n\nBefore showing how this works let\u2019s take a minute to explain why this is both\ninteresting and useful. Suppose a server hosts a simple linear regression\nmodel with weights and whose linear part is defined by:\n\nIn addition, suppose you have two secret numbers and and you want to use an\nuntrusted server to compute . Since the server is untrusted, you do not want\nto send or . Instead you can leverage the homomorphic addition and\nmultiplication methods above to run the following computation:\n\nHomomorphic Operations Example\n\n    \n    \n    # Client side: Generate and encryption key and encrypt m_0 and m_1 key = lwe.generate_lwe_key(config.LWE_CONFIG) ciphertext_0 = lwe.lwe_encrypt(m_0, key) ciphertext_1 = lwe.lwe_encrypt(m_1, key) # Send the ciphertexts to the untrusted server. # Server side: Generate an encryption of # f(m_0, m_1) = w_0*m_0 + w_1*m_1 ciphertext_result = lwe.lwe_add( lwe.lwe_plaintext_multiply(w_0, ciphertext_0), lwe.lwe_plaintext_multiply(w_1, ciphertext_1), ) # The server sends ciphertext_f back to the client # Client side: Decrypt ciphertext_result to obtain f(m_0, m_1) result = lwe.lwe_decrypt(ciphertext_result, key)\n\nNote that this example can easily be extended to general dot products between\na vector of weights and a vector of features which is a core component of\nneural networks.\n\n## Homomorphic Addition\n\nIn this section we\u2019ll implement the homomorphic addition function:\n\nLet be a LWE key, let be two messages and let and be encryptions of and\nrespectively.\n\nBy definition, should be equal to a ciphertext that is an encryption of .\n\nHow can we obtain from the inputs and ?\n\nIt turns out that all we have to do is add the coefficients of and :\n\nTo prove that is indeed an encryption of , let\u2019s decrypt it:\n\nIn summary:\n\nThis proves that is an encryption of with noise .\n\nLater in this post we will also use the analogous homomorphic subtraction\nfunction :\n\nHere are concrete implementations of and :\n\ntfhe/lwe.py\n\n    \n    \n    def lwe_add( ciphertext_left: LweCiphertext, ciphertext_right: LweCiphertext) -> LweCiphertext: \"\"\"Homomorphic addition evaluation. If ciphertext_left is an encryption of m_left and ciphertext_right is an encryption of m_right then return an encryption of m_left + m_right. \"\"\" return LweCiphertext( ciphertext_left.config, np.add(ciphertext_left.a, ciphertext_right.a, dtype=np.int32), np.add(ciphertext_left.b, ciphertext_right.b, dtype=np.int32)) def lwe_subtract( ciphertext_left: LweCiphertext, ciphertext_right: LweCiphertext) -> LweCiphertext: \"\"\"Homomorphic subtraction evaluation. If ciphertext_left is an encryption of m_left and ciphertext_right is an encryption of m_right then return an encryption of m_left - m_right. \"\"\" return LweCiphertext( ciphertext_left.config, np.subtract(ciphertext_left.a, ciphertext_right.a, dtype=np.int32), np.subtract(ciphertext_left.b, ciphertext_right.b, dtype=np.int32))\n\nHere is an example of homomorphic addition:\n\ntests/test_lwe.py\n\n    \n    \n    key = lwe.generate_lwe_key(config.LWE_CONFIG) # Encode the values 3 and -1 as LWE plaintexts plaintext_a = lwe.lwe_encode(3) plaintext_b = lwe.lwe_encode(-1) # Encrypt both plaintexts ciphertext_a = lwe.lwe_encrypt(plaintext_a, key) ciphertext_b = lwe.lwe_encrypt(plaintext_b, key) # Homomorphically add the ciphertexts. ciphertext_sum = lwe.lwe_add(ciphertext_a, ciphertext_b) # Decrypt the ciphertext_sum and then decode it. The result should # be equal to 3 + (-1) = 2 decrypted = lwe.lwe_decrypt(ciphertext_sum, key) decoded = lwe.lwe_decode(decrypted) assert decoded == 2\n\n## Homomorphic Multiplication By Plaintext\n\nIn this section we\u2019ll implement the homomorphic multiplication by plaintext\nfunction:\n\nLet be a LWE key, let be two messages and let be an encryption of .\n\nBy definition, should be equal to a ciphertext that is an encryption of .\n\nInspired by the previous section, we can attempt to implement by element wise\nmultiplication of the scalar with the vector :\n\nAs before, we can verify that this is correct by decrypting :\n\nThis shows that the result of decrypting is the product together with some\nnoise that is equal to . If is small then the noise is small and so is a valid\nencryption of . We\u2019ll analyze the noise more closely in the next section.\n\nHere is an implementation of :\n\ntfhe/lwe.py\n\n    \n    \n    def lwe_plaintext_multiply(c: int, ciphertext: LweCiphertext) -> LweCiphertext: \"\"\"Homomorphically multiply an LWE ciphertext with a plaintext integer.\"\"\" return LweCiphertext( ciphertext.config, np.multiply(c, ciphertext.a, dtype=np.int32), np.multiply(c, ciphertext.b, dtype=np.int32), )\n\n## Noise Analysis\n\nIn this section we\u2019ll analyze the effects of homomorphic operations on\nciphertext noise.\n\nLet and be LWE plaintexts. Let be an LWE encryption of with noise . By\nequation , is an encryption of with noise . This means that when we\nhomomorphically add two ciphertexts, the noise in each of the inputs gets\nadded to the result.\n\nFor example, let\u2019s see what happens when we take an encryption of and\nhomomorphically add it to itself 10 times. We\u2019ll repeat the entire process\n1000 times and plot the ciphertext error distribution before and after the\nhomomorphic addition:\n\nHomomorphic Addition Noise Analysis\n\n    \n    \n    key = lwe.generate_lwe_key(config.LWE_CONFIG) plaintext_zero = lwe.LwePlaintext(0) initial_errors = [] addition_errors = [] for _ in range(1000): # Encrypt the plaintext and record the ciphertext error. ciphertext_zero = lwe.lwe_encrypt(plaintext_zero, key) initial_errors.append(lwe.lwe_decrypt(ciphertext_zero, key).message) # Homomorphically add the ciphertext to itself 10 times. ciphertext_sum = ciphertext_zero for _ in range(10): ciphertext_sum = lwe.lwe_add(ciphertext_sum, ciphertext_zero) # Record the error of the ciphertext sum. addition_errors.append(lwe.lwe_decrypt(ciphertext_sum, key).message)\n\nThe graph on the left shows the distribution of initial_errors which records\nthe errors in the initial encryptions of . The graph on the right shows the\ndistribution of addition_errors which contains the ciphertext errors after 10\nhomomorphic additions. As expected, the noise on the right is about 10 times\nlarger.\n\nThe maximum error in the graph on the right is around 5000 which is still\nsignificantly smaller than the maximal acceptable error of . However, after\nhomomorphic additions we\u2019d eventually surpass that limit and no longer be able\nto accurately decode messages.\n\nA major goal for the rest of this post is to develop a homomorphic operation\nwhose output noise is independent of the input noise. This will make it\npossible to compose an arbitrary number of homomorphic operations, without\nrunning into the noise issue above.\n\n## Trivial Encryption\n\nLet be an LWE plaintext and let be an LWE encryption key. Consider the tuple:\n\nwhere is a length vector of zeroes. We claim that is a valid LWE encryption of\nwith no noise. Indeed, the decryption of is exactly equal to :\n\nThe ciphertext is called the trivial encryption of .\n\nHere is our library implementation:\n\ntfhe/lwe.py\n\n    \n    \n    def lwe_trivial_ciphertext(plaintext: LwePlaintext, config: LweConfig): \"\"\"Generate a trivial encryption of the plaintext.\"\"\" return LweCiphertext( config=config, a=np.zeros(config.dimension, dtype=np.int32), b=plaintext.message, )\n\nAs an example of why this is useful, let be an LWE plaintext and let be an LWE\nencryption of . How can we homomorphically add to to produce an encryption of\n?\n\nIn section Homomorphic Addition we implemented the function which\nhomomorphically adds two LWE ciphertexts. We cannot directly apply since we\nare trying to add the plaintext to the ciphertext . Instead, we can first\nconvert to its trivial encryption and then compute .\n\n# Homomorphic NAND Revisited\n\nIn the previous section we introduced the LWE encryption scheme together with\nsome basic homomorphic operations. This will allow us to refine our definition\nof the homomorphic NAND gate from section A Fully Homomorphic Nand Gate and\ngive an overview of our implementation strategy.\n\n## Definition\n\nIn this section we\u2019ll introduce an encoding of boolean values as LWE messages\nand precisely define the homomorphic NAND function.\n\nWe\u2019ll use the function from section Message Encoding to represent boolean\nvalues as LWE plaintexts. Specifically, we\u2019ll represent by and represent by .\n\nLet and denote two booleans with the above representation. The homomorphic\nNAND gate has the signature:\n\nIn other words, if is an LWE encryption of and is an LWE encryption of then is\nan LWE encryption of .\n\nAnother important requirement for is that the noise of the output ciphertext\nshould be bounded and independent of the noise of the inputs and . This\nproperty will make it possible to compose an arbitrary number of homomorphic\nNAND gates without suffering from the noise explosion issue that we saw in\nsection Noise Analysis.\n\nHere are the functions we\u2019ll use to encode booleans as LWE plaintexts and to\ndecode plaintexts back to booleans. Note that we\u2019re using the encode and\ndecode functions defined here.\n\ntfhe/utils.py\n\n    \n    \n    def encode_bool(b: bool) -> np.int32: \"\"\"Encode a bit as an int32.\"\"\" return encode(2 * int(b)) def decode_bool(i: np.int32) -> bool: \"\"\"Decode an int32 to a bool.\"\"\" return bool(decode(i) / 2)\n\ntfhe/lwe.py\n\n    \n    \n    def lwe_encode_bool(b: bool) -> LwePlaintext: \"\"\"Encode a boolean as an LWE plaintext.\"\"\" return LwePlaintext(utils.encode_bool(b)) def lwe_decode_bool(plaintext: LwePlaintext) -> bool: \"\"\"Decode an LWE plaintext to a boolean.\"\"\" return utils.decode_bool(plaintext.message)\n\nThe signature of our homomorphic NAND function is:\n\ntfhe/nand.py\n\n    \n    \n    def lwe_nand( lwe_ciphertext_left: lwe.LweCiphertext, lwe_ciphertext_right: lwe.LweCiphertext, bootstrap_key: bootstrap.BootstrapKey, ) -> lwe.LweCiphertext: \"\"\"Homomorphically evaluate the NAND function. Suppose that lwe_ciphertext_left is an LWE encryption of lwe_encode_bool(b_left) and lwe_ciphertext_right is an LWE encryption lwe_encode_bool(b_right). Then the the output is an LWE encryption lwe_encode_bool(NAND(b_left, b_right)). \"\"\" pass\n\nAs we\u2019ll see later, bootstrap_key is a public key that untrusted parties can\nuse to homomorphically evaluate functions.\n\nHere is an example:\n\ntests/test_nand.py\n\n    \n    \n    # Generate a private LWE encryption key. lwe_key = lwe.generate_lwe_key(config.LWE_CONFIG) # Generate a public bootstrapping key. gsw_key = gsw.convert_lwe_key_to_gsw(lwe_key, config.GSW_CONFIG) bootstrap_key = bootstrap.generate_bootstrap_key(lwe_key, gsw_key) # Encode two boolean values as LWE plaintexts. plaintext_0 = lwe.lwe_encode_bool(False) plaintext_1 = lwe.lwe_encode_bool(True) # Encrypt the plaintexts. ciphertext_0 = lwe.lwe_encrypt(plaintext_0, lwe_key) ciphertext_1 = lwe.lwe_encrypt(plaintext_1, lwe_key) # Homomorphically compute the NAND function on the inputs. ciphertext_nand = nand.lwe_nand( ciphertext_0, ciphertext_1, bootstrap_key ) # Decrypt the homomorphic NAND result with the LWE key. plaintext_nand = lwe.lwe_decrypt(ciphertext_nand, lwe_key) # Decode the LWE plaintext back to a bool. boolean_nand = lwe.lwe_decode_bool(plaintext_nand) # The result should be equal to NAND(False, True) = True assert boolean_nand == True\n\n## Implementation Strategy\n\nThe remainder of this post will be dedicated to implementing lwe_nand. In this\nsection we\u2019ll discuss our high level strategy.\n\nRecall that our encoding function maps values from to and is defined by :\n\nWe\u2019ll start by expressing NAND in terms of elementary operations on .\n\nAs before, we will identify with and with . Let be two boolean values and\nconsider the expression:\n\nIn terms of the diagram above, we start at and move two dots counter clockwise\nfor each that is \u201ctrue\u201d. Here are the four possible values (modulo ) that this\nexpression can take:\n\nNote that if and only if . We can therefore upgrade to a NAND function by\ncomposing it with the step function which is defined on as follows:\n\nHere\u2019s what happens when we apply to :\n\nIt is evident from the table that\n\nIn summary, we\u2019ve expressed the NAND function in terms of two operations on :\nsubtraction and the step function.\n\nIn section Homomorphic Addition we already implemented a homomorphic\nsubtraction function . Therefore, all that remains is to implement a\nhomomorphic step function. In the remainder of this post we will develop the\nbootstrapping function which is essentially a homomorphic step function that\nalso has bounded output noise.\n\nWe can then use and to implement :\n\nHere is the python implementation:\n\ntfhe/nand.py\n\n    \n    \n    import numpy as np from tfhe import bootstrap, lwe def lwe_nand( lwe_ciphertext_left: lwe.LweCiphertext, lwe_ciphertext_right: lwe.LweCiphertext, bootstrap_key: bootstrap.BootstrapKey, ) -> lwe.LweCiphertext: \"\"\"Homomorphically evaluate the NAND function. Suppose that lwe_ciphertext_left is an LWE encryption of an encoding of the boolean b_left and lwe_ciphertext_right is an LWE encryption of an encoding of the boolean b_right. Then the the output is an LWE encryption of an encoding of NAND(b_left, b_right). \"\"\" # Compute an LWE encryption of: encode(-3) - b_left - b_right # First create a trivial encryption of encode(-3) initial_lwe_ciphertext = lwe.lwe_trivial_ciphertext( plaintext=lwe.lwe_encode(-3), config=lwe_ciphertext_left.config, ) # Homomorphically subtract lwe_ciphertext_left and lwe_ciphertext_right lwe_ciphertext = lwe.lwe_subtract( initial_lwe_ciphertext, lwe_ciphertext_left ) lwe_ciphertext = lwe.lwe_subtract( test_lwe_ciphertext, lwe_ciphertext_right ) # Bootstrap lwe_ciphertext to output encode_bool(False) or # encode_bool(True). return bootstrap.bootstrap( lwe_ciphertext, bootstrap_key, scale=utils.encode_bool(True) )\n\n# Bootstrapping\n\n## Definition\n\nIn the context of TFHE, the function is a homomorphic version of the function\ndefined in equation .\n\nMore precisely, let be an LWE message. The signature of is:\n\nIn other words, takes as input an LWE encryption of a message and outputs an\nLWE encryption of .\n\nThe other key property of is that the noise distribution of its output\nciphertext is independent of the noise of the input. This property is what\nwill allow us to compose an arbitrary number of homomorphic NAND functions\nwithout an explosion of the ciphertext noise.\n\nHere is the declaration of the function:\n\ntfhe/bootstrap.py\n\n    \n    \n    def bootstrap( lwe_ciphertext: lwe.LweCiphertext, bootstrap_key: BootstrapKey, scale: np.int32, ) -> lwe.LweCiphertext: \"\"\"Bootstrap the LWE ciphertext. Suppose that lwe_ciphertext is an encryption of the int32 i. If -2^30 < i <= 2^30 then return an LWE encryption of the scale argument. Otherwise return an LWE encryption of 0. In both cases the ciphertext noise will be bounded and independent of the lwe_ciphertext noise. \"\"\" pass\n\nThe bootstrap_key argument will be explained later in this post. The scale\nparameter is the non zero output value of the step function. Our definition of\nabove corresponds to scale = utils.encode(2).\n\n## Noise Properties\n\nAs mentioned in the previous section, a key property of the bootstrap function\nis that it has bounded output noise. In this section we\u2019ll explore this\nproperty in more detail through an example.\n\nLet and be two LWE messages. Let be an encryption of and and encryption of .\n\nSuppose we homomorphically multiply by and add the result to :\n\nAs we saw in section Homomorphic Multiplication By Plaintext, is an encryption\nof . Therefore, is an encryption of . Furthermore, as we saw in section Noise\nAnalysis, we the expect noise distribution of to roughly have a standard\ndeviation of .\n\nThe following program computes the ciphertexts and 1000 times so that we can\ncompare the distributions of the decryptions and :\n\nBootstrap Noise Distribution\n\n    \n    \n    from tfhe import bootstrap, gsw, lwe, utils lwe_key = lwe.generate_lwe_key(config.LWE_CONFIG) gsw_key = gsw.convert_lwe_key_to_gsw(lwe_key, config.GSW_CONFIG) bootstrap_key = bootstrap.generate_bootstrap_key(lwe_key, gsw_key) plaintext_0 = lwe.lwe_encode(0) plaintext_3 = lwe.lwe_encode(3) decryptions = [] bootstrap_decryptions = [] for _ in range(1000): ciphertext_0 = lwe.lwe_encrypt(plaintext_0, lwe_key) ciphertext_3 = lwe.lwe_encrypt(plaintext_3, lwe_key) ciphertext = lwe.lwe_add( ciphertext_3, lwe.lwe_plaintext_multiply(2**20, ciphertext_0)) bootstrap_ciphertext = bootstrap.bootstrap( ciphertext, bootstrap_key, scale=utils.encode(2) ) decryptions.append(lwe.lwe_decrypt(ciphertext, lwe_key).message) bootstrap_decryptions.append( lwe.lwe_decrypt(bootstrap_ciphertext, lwe_key).message)\n\nHere is a comparison of the array decryptions which holds decryptions of and\nthe array bootstrap_decryptions which holds decryptions of :\n\nAs expected, the distribution of decryptions of is centered at with a standard\ndeviation of .\n\nAfter bootstrapping, the distribution of decryptions is centered at\n\nFurthermore, the distribution clearly is less noisy after bootstrapping.\nIndeed, the standard deviation of is which is less than the standard deviation\nof !\n\n## Implementation Strategy\n\nThe rest of this post will build towards an implementation of . The\nimplementation will rely on an extension of LWE called Ring LWE where messages\ncan be polynomials rather than scalars. The general idea is that we will\nexpress in terms of polynomial multiplication, and then use homomorphic\npolynomial multiplication to derive a homomorphic version of .\n\nIf you prefer to get a high level picture of the implementation before diving\ninto all the details, then it would make sense to start with the following\nsections:\n\n  1. Ring LWE\n  2. Blind Rotation Definition\n  3. Sample Extraction Definition\n  4. Bootstrapping Implementation\n\n# Ring LWE\n\n## Introduction\n\nRing LWE (RLWE) is a variation of LWE in which messages are polynomials rather\nthan scalars. As mentioned in the previous section, the RLWE encryption scheme\nwill be an important ingredient in our bootstrapping implementation.\n\nIn the next section we\u2019ll define the message space of RLWE more precisely.\nThen we\u2019ll define the RLWE encryption scheme.\n\n## Negacyclic Polynomials\n\nThe message space of the RLWE scheme is the ring of polynomials\n\nIn this section we will describe this polynomial ring.\n\nFirst, denotes the ring of polynomials with coefficients in . As before, we\nwill assume that and identify with signed 32 bit integers. In this context\ndenotes the ring of polynomials integer coefficients.\n\nHere is an example of an element in :\n\nWe call a Ring because we can add and multiply elements. For example, if and\nthen and .\n\nThe highest power of in a polynomial is called the degree. For example, the\ndegree of is and the degree of is . Polynomials in can have arbitrarily high\ndegrees.\n\nWe now turn to the ring . The denominator plays a similar role to the\ndenominator in . Two integers are considered to be equal modulo if they differ\nby a multiple of . Similarly, two polynomials are considered to be equal\nmodulo if they differ by a multiple of .\n\n> is defined to be the ring of polynomials modulo .\n\nAs an important special case, . Therefore, if we are given a polynomial with a\ndegree larger than , we can find it\u2019s representative modulo by replacing with\nas many times as necessary. For example, if then we have the following\nequivalences modulo :\n\nNote that as monomials reach they loop back to but with a negative sign. For\nthis reason polynomials of this form are sometimes called negacyclic.\n\nNow let\u2019s see an example of multiplication in . Let and be elements of . Their\nproduct is:\n\nHere is some negacyclic polynomial code that will be used later:\n\ntfhe/polynomial.py\n\n    \n    \n    import numpy as np import dataclasses @dataclasses.dataclass class Polynomial: \"\"\"A polynomial in the ring Z_q[x] / (x^N + 1)\"\"\" N: int coeff: np.ndarray # Polynomial coefficients f_0, f_1, ..., f_{N-1} def polynomial_constant_multiply(c: int, p: Polynomial) -> Polynomial: return Polynomial(N=p.N, coeff=np.multiply(c, p.coeff, dtype=np.int32)) def polynomial_multiply(p1: Polynomial, p2: Polynomial) -> Polynomial: \"\"\"Multiply two negacyclic polynomials. Note that this is not an optimal implementation. See https://www.jeremykun.com/2022/12/09/negacyclic-polynomial-multiplication/ for a more efficient version which uses FFTs. \"\"\" N = p1.N # Multiply and pad the result to have length 2N-1. # Note that the polymul function expects the coefficients to be from highest # to lowest degree so we reverse our coefficients before and after using it. prod = np.polymul(p1.coeff[::-1], p2.coeff[::-1])[::-1] prod_padded = np.zeros(2 * N - 1, dtype=np.int32) prod_padded[: len(prod)] = prod # Use the relation x^N = -1 to obtain a polynomial of degree N-1 result = prod_padded[:N] result[:-1] -= prod_padded[N:] return Polynomial(N=N, coeff=result) def polynomial_add(p1: Polynomial, p2: Polynomial) -> Polynomial: return Polynomial(N=p1.N, coeff=np.add(p1.coeff, p2.coeff, dtype=np.int32)) def polynomial_subtract(p1: Polynomial, p2: Polynomial) -> Polynomial: return Polynomial( N=p1.N, coeff=np.subtract(p1.coeff, p2.coeff, dtype=np.int32) ) def zero_polynomial(N: int) -> Polynomial: return Polynomial(N=N, coeff=np.zeros(N, dtype=np.int32)) def build_monomial(c: int, i: int, N: int) -> Polynomial: \"\"\"Build a monomial c*x^i in the ring Z[x]/(x^N + 1)\"\"\" coeff = np.zeros(N, dtype=np.int32) # Find k such that: 0 <= i + k*N < N i_mod_N = i % N k = (i_mod_N - i) // N # If k is odd then the monomial picks up a negative sign since: # x^i = (-1)^k * x^(i + k*N) = (-1)^k * x^(i % N) sign = 1 if k % 2 == 0 else -1 coeff[i_mod_N] = sign * c return Polynomial(N=N, coeff=coeff)\n\n## The RLWE Encryption Scheme\n\nIn this section we will define the RLWE Encryption Scheme which is very\nsimilar to the LWE encryption scheme but with messages in rather than .\n\nA secret key in RLWE is a polynomial in with random binary coefficients. For\nexample, if then a secret key may look like:\n\nTo encrypt a message with the secret key we first sample a polynomial with\nuniformly random coefficients in and an error polynomial with small error\ncoefficients sampled from . The encryption of by is then given by the pair:\n\nTo decrypt a ciphertext we compute:\n\nSimilarly to LWE, the encryption function is not deterministic and so each\nmessage has many valid encryptions. The set of valid encryptions of a message\nwith the key will be denoted .\n\nHere is our implementation of the RLWE scheme:\n\ntfhe/rlwe.py\n\n    \n    \n    import dataclasses import numpy as np from tfhe import lwe, polynomial, utils from tfhe.polynomial import Polynomial @dataclasses.dataclass class RlweConfig: degree: int # Messages will be in the space Z[X]/(x^degree + 1) noise_std: float # The std of the noise added during encryption. @dataclasses.dataclass class RlweEncryptionKey: config: RlweConfig key: Polynomial @dataclasses.dataclass class RlwePlaintext: config: RlweConfig message: Polynomial @dataclasses.dataclass class RlweCiphertext: config: RlweConfig a: Polynomial b: Polynomial def generate_rlwe_key(config: RlweConfig) -> RlweEncryptionKey: return RlweEncryptionKey( config=config, key=Polynomial( N=config.degree, coeff=np.random.randint( low=0, high=2, size=config.degree, dtype=np.int32 ), ), ) def rlwe_encrypt( plaintext: RlwePlaintext, key: RlweEncryptionKey ) -> RlweCiphertext: a = Polynomial( N=key.config.degree, coeff=utils.uniform_sample_int32(size=key.config.degree), ) noise = Polynomial( N=key.config.degree, coeff=utils.gaussian_sample_int32( std=key.config.noise_std, size=key.config.degree ), ) b = polynomial.polynomial_add( polynomial.polynomial_multiply(a, key.key), plaintext.message ) b = polynomial.polynomial_add(b, noise) return RlweCiphertext(config=key.config, a=a, b=b) def rlwe_decrypt( ciphertext: RlweCiphertext, key: RlweEncryptionKey ) -> RlwePlaintext: message = polynomial.polynomial_subtract( ciphertext.b, polynomial.polynomial_multiply(ciphertext.a, key.key) ) return RlwePlaintext(config=key.config, message=message)\n\nWe\u2019ll use the following RLWE parameters in this post:\n\ntfhe/config.py\n\n    \n    \n    RLWE_CONFIG = rlwe.RlweConfig(degree=1024, noise_std=2 ** (-24))\n\n## Message Encoding\n\nAs with LWE, after decrypting a ciphertext we get the original message\ntogether with a small amount of noise . To achieve noiseless decryptions we\u2019ll\nextend the and functions from Message Encoding to polynomials by encoding and\ndecoding each individual coefficient.\n\nThe extended function encodes a polynomial with coefficients in as a\npolynomial with coefficients in :\n\nSimilarly, the extended function will decode a polynomial with coefficients in\nto a polynomial with coefficients in :\n\nJust like with LWE, we\u2019ll restrict our message space to encodings of . We can\nthen apply to remove the decryption error as long as the absolute values of\nthe coefficients of are all less than\n\nHere is an implementation of the encoding and decoding functions for RLWE\nmessages:\n\ntfhe/rlwe.py\n\n    \n    \n    def rlwe_encode(p: Polynomial, config: RlweConfig) -> RlwePlaintext: \"\"\"Encode a polynomial with coefficients in [-4, 4) as an RLWE plaintext.\"\"\" encode_coeff = np.array([utils.encode(i) for i in p.coeff]) return RlwePlaintext( config=config, message=polynomial.Polynomial(N=p.N, coeff=encode_coeff) ) def rlwe_decode(plaintext: RlwePlaintext) -> Polynomial: \"\"\"Decode an RLWE plaintext to a polynomial with coefficients in [-4, 4) mod 8.\"\"\" decode_coeff = np.array([utils.decode(i) for i in plaintext.message.coeff]) return Polynomial(N=plaintext.message.N, coeff=decode_coeff)\n\nHere is an example of using the RLWE encryption scheme with the above\nencoding:\n\nRLWE Message Encoding Example\n\n    \n    \n    key = rlwe.generate_rlwe_key(config.RLWE_CONFIG) # p(x) = 2x^3 p = polynomial.build_monomial(c=2, i=3, N=config.RLWE_CONFIG.degree) # Encode the polynomial p(x) as an RLWE plaintext. plaintext = rlwe.rlwe_encode(p, config) # Encrypt the plaintext with the key. ciphertext = rlwe.rlwe_encrypt(plaintext, key) # Decrypt the ciphertext. decrypted = rlwe.rlwe_decrypt(ciphertext, key) # Decode the decrypted message to remove the noise. decoded = rlwe.rlwe_decode(decrypted) # The final decoded result should be equal to the original polynomial p. assert np.all(decoded.coeff == p.coeff)\n\n## Homomorphic Addition\n\nIn this section we\u2019ll develop the RLWE analog of LWE Homomorphic Addition.\n\nLet be an RLWE encryption key and let be RLWE plaintexts. The signature of the\nhomomorphic addition function is:\n\nIn other words, takes an input RLWE encryptions of and and outputs an RLWE\nencryption of .\n\nSimilarly to LWE Homomorphic Addition, we can implement for the RLWE scheme by\nadding the input ciphertexts element-wise:\n\nThe RLWE version of the homomorphic subtraction function is analogous.\n\nHere is the corresponding code:\n\ntfhe/rlwe.py\n\n    \n    \n    def rlwe_add( ciphertext_left: RlweCiphertext, ciphertext_right: RlweCiphertext ) -> RlweCiphertext: \"\"\"Homomorphically add two RLWE ciphertexts.\"\"\" return RlweCiphertext( ciphertext_left.config, polynomial.polynomial_add(ciphertext_left.a, ciphertext_right.a), polynomial.polynomial_add(ciphertext_left.b, ciphertext_right.b), ) def rlwe_subtract( ciphertext_left: RlweCiphertext, ciphertext_right: RlweCiphertext ) -> RlweCiphertext: \"\"\"Homomorphically subtract two RLWE ciphertexts.\"\"\" return RlweCiphertext( ciphertext_left.config, polynomial.polynomial_subtract(ciphertext_left.a, ciphertext_right.a), polynomial.polynomial_subtract(ciphertext_left.b, ciphertext_right.b), )\n\n## Homomorphic Multiplication By Plaintext\n\nIn this section we\u2019ll develop the RLWE analog of LWE Homomorphic\nMultiplication By Plaintext.\n\nLet be an RLWE encryption key and let be RLWE plaintexts. The signature of the\nhomomorphic multiplication by plaintext function is:\n\nLet be an RLWE encryption of . Similarly to LWE Homomorphic Multiplication By\nPlaintext, we can implement for the RLWE scheme by multiplying with the vector\n:\n\nJust like in the LWE case, is a valid RLWE encryption of under the condition\nthat the coefficients of are small.\n\nHere is an implementation:\n\ntfhe/rlwe.py\n\n    \n    \n    def rlwe_plaintext_multiply( c: RlwePlaintext, ciphertext: RlweCiphertext ) -> RlweCiphertext: \"\"\"Homomorphically multiply an RLWE ciphertext by a plaintext polynomial.\"\"\" return RlweCiphertext( ciphertext.config, polynomial.polynomial_multiply(c.message, ciphertext.a), polynomial.polynomial_multiply(c.message, ciphertext.b), )\n\nAnd here is an example:\n\ntests/test_rlwe.py\n\n    \n    \n    key = rlwe.generate_rlwe_key(config.RLWE_CONFIG) # c(x) = x, m(x) = 2x^2 c = polynomial.build_monomial(1, 1, N=config.RLWE_CONFIG.degree) m = polynomial.build_monomial(2, 2, N=config.RLWE_CONFIG.degree) # Convert c(x) into an RLWE plaintext without encoding. Note that encoding is # not necessary since c(x) will not be encrypted. c_plaintext = rlwe.RlwePlaintext(config=config.RLWE_CONFIG, message=c) # Encode m(x) as an RLWE plaintext. m_plaintext = rlwe.rlwe_encode(m, config) # Encrypt m(x) m_ciphertext = rlwe.rlwe_encrypt(m_plaintext, key) # Homomorphically multiply the encryption of m(x) with c(x) cm_ciphertext = rlwe.rlwe_plaintext_multiply(c_plaintext, m_ciphertext) # Decrypt the product. cm_decrypted = rlwe.rlwe_decrypt(cm_ciphertext, key) # Decode the result. cm_decoded = rlwe.rlwe_decode(cm_decrypted) # The decoded result should be equal to c(x)*m(x) = 2x^3 assert np.all(cm_decoded.coeff == polynomial.polynomial_multiply(c, m))\n\n## Trivial Encryption\n\nIn this section we\u2019ll define the RLWE analog of LWE Trivial Encryption\n\nLet be an RLWE plaintext. The trivial encryption of is defined to be:\n\nAs in the LWE case, it is easy to verify that this is a valid RLWE encryption\nof with zero noise.\n\nHere is an implementation:\n\ntfhe/rlwe.py\n\n    \n    \n    def rlwe_trivial_ciphertext( f: Polynomial, config: RlweConfig ) -> RlweCiphertext: \"\"\"Generate a trivial encryption of the plaintext.\"\"\" if f.N != config.degree: raise ValueError( f\"The degree of f ({f.N}) does not match the config degree ({config.degree}) \" ) return RlweCiphertext( config=config, a=polynomial.zero_polynomial(config.degree), b=f, )\n\n## LWE To RLWE Keys\n\nRecall from section An LWE Based Encryption Scheme that LWE encryption keys\nare length vectors\n\nwhere .\n\nAs we just saw, RLWE encryption keys are degree polynomials\n\nwhere as well.\n\nIn this post, we\u2019ll be using the parameters . Therefore, we can convert an LWE\nkey to an RLWE key by forming a polynomial from the coefficients of .\n\ntests/test_rlwe.py\n\n    \n    \n    def convert_lwe_key_to_rlwe(lwe_key: lwe.LweEncryptionKey) -> RlweEncryptionKey: rlwe_config = RlweConfig( degree=lwe_key.config.dimension, noise_std=lwe_key.config.noise_std ) return RlweEncryptionKey( config=rlwe_config, key=Polynomial(N=rlwe_config.degree, coeff=lwe_key.key), )\n\nThe ability to convert LWE keys to RLWE keys will come in handy in sections\nBlind Rotate and Sample Extraction where we\u2019ll implement homomorphic\noperations that combine both LWE and RLWE ciphertexts.\n\n# A Homomorphic Multiplexer\n\n## Introduction\n\nThe Multiplexer gate has three inputs: a selector bit and two lines and . The\noutput is defined by:\n\nIn other words, the multiplexer outputs one of the two input lines depending\non the selector bit.\n\nOur implementation of bootstrapping will require a homomorphic multiplexer .\nThe function also has three inputs: An encrypted selector bit and RLWE\nencryptions of the two lines and . The output is an RLWE encryption of :\n\nNote that, for reasons that will soon become clear, we have not yet specified\nthe encryption scheme used to encrypt .\n\nThe goal of this section is to implement .\n\nThe first step is to note that we can express the standard function in terms\nof addition, subtraction and multiplication:\n\nTherefore, all we need to do to implement is to homomorphically evaluate the\nright hand side of equation . In section Homomorphic Addition we saw how to\nhomomorphically evaluate addition and subtraction of RLWE ciphertexts. In\nsection Homomorphic Multiplication By Plaintext we saw how to homomorphically\nmultiply an RLWE ciphertext by an RLWE plaintext. This is not quite enough to\nhomomorphically evaluate the multiplication in equation since both the\nselection bit and the lines and need to be encrypted.\n\nIn the next section we will introduce the GSW encryption scheme and implement\nhomomorphic multiplication between a GSW ciphertext and an RLWE ciphertext:\n\nWe\u2019ll use the GSW scheme to encrypt the selector bit, and so we can update the\nsignature of to:\n\nWe can implement this version of using , and to homomorphically evaluate the\nright hand side of equation . More precisely, let be a GSW encryption of and\nlet be RLWE encryptions of and . Then:\n\nHere is an implementation of which builds on the GSW encryption scheme and the\nfunction that we\u2019ll explore in the next section.\n\ntfhe/gsw.py\n\n    \n    \n    def cmux( gsw_ciphertext: GswCiphertext, rlwe_ciphertext_0: rlwe.RlweCiphertext, rlwe_ciphertext_1: rlwe.RlweCiphertext, ) -> rlwe.RlweCiphertext: \"\"\"Homomorphically evaluate the multiplexer function. Suppose that rlwe_ciphertext_0 is an encryption of l_0 and rlwe_ciphertext_1 is an encryption of l_1. If gsw_ciphertext is a GSW encryption of 0, then the output will be an RLWE encryption of l_0. Otherwise, the output will be an RLWE encryption of l_1. \"\"\" return rlwe.rlwe_add( gsw_multiply( gsw_ciphertext, rlwe.rlwe_subtract(rlwe_ciphertext_1, rlwe_ciphertext_0), ), rlwe_ciphertext_0, )\n\nHere is an example:\n\ntests/test_gsw.py\n\n    \n    \n    rlwe_config = config.RLWE_CONFIG gsw_config = config.GSW_CONFIG # Generate an RLWE key and convert it to a GSW key. rlwe_key = rlwe.generate_rlwe_key(rlwe_config) gsw_key = gsw.convert_rlwe_key_to_gsw(rlwe_key, gsw_config) # The selector bit is b=1 selector = polynomial.build_monomial(c=1, i=0, N=rlwe_config.degree) # The lines are: l_0(x) = x, l_1(x) = 2x line_0 = polynomial.build_monomial(c=1, i=1, N=rlwe_config.degree) line_1 = polynomial.build_monomial(c=2, i=1, N=rlwe_config.degree) # Create a GSW plaintext from the selector bit. selector_plaintext = gsw.GswPlaintext(config=gsw_config, message=selector) # Create RLWE plaintexts by encoding the lines. line_0_plaintext = rlwe.rlwe_encode(line_0, rlwe_config) line_1_plaintext = rlwe.rlwe_encode(line_1, rlwe_config) # Encrypt the selector bit with GSW and the lines with RLWE. selector_ciphertext = gsw.gsw_encrypt(selector_plaintext, gsw_key) line_0_ciphertext = rlwe.rlwe_encrypt(line_0_plaintext, rlwe_key) line_1_ciphertext = rlwe.rlwe_encrypt(line_1_plaintext, rlwe_key) # Apply the CMux function to homomorphically evaluate Mux(b, l_0, l_1). # This can be done on an untrusted server since all the inputs are encrypted. cmux_ciphertext = gsw.cmux( selector_ciphertext, line_0_ciphertext, line_1_ciphertext) # Decrypt the cmux result using the RLWE key. cmux_decrypted = rlwe.rlwe_decrypt(cmux_ciphertext, rlwe_key) # Decode the decrypted result. cmux_decoded = rlwe.rlwe_decode(cmux_decrypted) # Since the selector bit was b=1, the cmux result should be equal to line_1. assert np.all(cmux_decoded.coeff == line_1.coeff)\n\n## The GSW Encryption Scheme\n\nThe GSW encryption scheme was proposed in 2013 by Gentry, Sahai and Waters. In\nthis section we\u2019ll define GSW encryption and implement homomorphic\nmultiplication between a GSW ciphertext and an RLWE ciphertext:\n\nIn terms of our python implementation, our goal is to implement the following\nmethods:\n\ntfhe/gsw.py\n\n    \n    \n    @dataclasses.dataclass class GswConfig: rlwe_config: rlwe.RlweConfig log_p: int # Homomorphic multiplication will use the base-2^log_p representation. @dataclasses.dataclass class GswPlaintext: config: GswConfig message: polynomial.Polynomial @dataclasses.dataclass class GswCiphertext: config: GswConfig rlwe_ciphertexts: Sequence[rlwe.RlweCiphertext] @dataclasses.dataclass class GswEncryptionKey: config: GswConfig key: polynomial.Polynomial def convert_rlwe_key_to_gsw( rlwe_key: rlwe.RlweEncryptionKey, gsw_config: GswConfig ) -> GswEncryptionKey: pass def gsw_encrypt( plaintext: GswPlaintext, key: GswEncryptionKey ) -> GswCiphertext: pass def gsw_multiply( gsw_ciphertext: GswCiphertext, rlwe_ciphertext: rlwe.RlweCiphertext ) -> rlwe.RlweCiphertext: \"\"\"Homomorphically multiply a GSW ciphertext with an RLWE ciphertext. If gsw_ciphertext is a GSW encryption of f(x) and rlwe_ciphertext is an RLWE encryption of g(x) then the output is an RLWE encryption of f(x)g(x). \"\"\" pass\n\n## Encryptions Of Zero\n\nAn encryption of zero is an RLWE encryption of the zero polynomial.\n\nIn this section we\u2019ll see how encryptions of zero can help us make progress\ntowards implementing homomorphic multiplication between ciphertexts.\n\nLet be an RLWE secret key, let and be two RLWE messages and let be an RLWE\nencryption of . The goal of homomorphic multiplication is to compute an\nencryption of :\n\nwithout revealing the plaintexts .\n\nIn section Homomorphic Multiplication By Plaintext we saw that is a valid\nencryption of the product . Our goal in this section is to obtain such an\nencryption without revealing . We\u2019ll achieve this by using encryptions of\nzeros to mask before multiplying it with .\n\nLet be encryptions of zero let to be the matrix whose -th row is :\n\nAlso, let denote the identity matrix:\n\nWe claim that\n\nis also a valid RLWE encryption of under the assumption that the coefficients\nof and are small.\n\nThe idea of the GSW scheme is to encrypt a plaintext by masking it with RLWE\nencryptions of zeros:\n\nMotivated by equation , we can then define homomorphic multiplication between\na GSW ciphertext and an RLWE ciphertext to be:\n\nAccording to the claim above, will be a valid RLWE encryption of so long as\nthe coefficients of , and are small.\n\nThe small coefficient requirement on is not an issue for us. In fact, in this\npost we will only consider GSW encryptions of the constant polynomials and .\nThe requirements on and however are an issue. Since and are the elements of\nthe ciphertext , their coefficients should be indistinguishable from\nrandomness and so they certainly are not small.\n\nPerhaps the simplest way to decrease the magnitude of the coefficients of the\nciphertext is to divide by a constant inside the implementation of . In order\nfor the output to still be an encryption of , we can balance this out by\nredefining the GSW encryption of to be:\n\nTogether we get:\n\nIt is not hard to show that with this new definition, the division and\nmultiplication by cancel out and is still an RLWE encryption of . Furthermore,\nthe noise of is now only\n\nWe can therefore obtain an acceptable bound on the noise by choosing to be\nsufficiently large.\n\nUnfortunately this simple approach does not quite work since division by is\nnot well defined on the 32-bit integers . The best we can do is to choose so\nthat is divisible by and then divide elements of modulo , but then we\u2019ll loose\na lot of precision which would counter our goal of reducing noise.\n\nThe key trick of the GSW scheme is to upgrade from a simple division to\nsomething like a binary representation. I.e, rather than decomposing an\ninteger as\n\nWe\u2019ll decompose it using multiple powers of :\n\nIn the next section we\u2019ll describe the details of the base- representation.\nThen we\u2019ll see how to incorporate it into homomorphic multiplication so as to\nobtain a better bound on the noise.\n\n## The Base-p Representation\n\nRecall that in this post, and is represented by the signed 32-bit integers .\nIn this section we\u2019ll similarly set and will denote the signed 8-bit integers\n. We\u2019ll also set .\n\nLet be a signed 32-bit integer. The base- representation of is defined to be a\nlength sequence of elements of , , satisfying:\n\nFor example,\n\nwhich means that the base- representation of is .\n\nAnother interesting example is :\n\nHere we are relying on the fact that\n\nWe\u2019ll define to be the function that converts an element of to its base-\nrepresentation:\n\nFor example, .\n\nThe remainder of this section will be concerned with implementing the function\n.\n\nFirst, note that the analog of the base- representation for an unsigned\ninteger can easily be deduced from the binary representation of . For example,\nthe binary representation of is:\n\n    \n    \n    00000000000000000000001111101000\n\nTo get an unsigned base- representation, we can simply split this into chunks\nof size :\n\n    \n    \n    x_0 = 0b11101000 = 232 x_1 = 0b00000011 = 3 x_2 = 0b00000000 = 0 x_3 = 0b00000000 = 0\n\nIndeed:\n\nNote that this is not a valid signed base- representation since . To implement\nfor signed integers, we\u2019ll first add an offset (whose value will be specified\nlater) to and compute the unsigned base- representation of , denoted , where .\nWe\u2019ll then subtract from the elements of the unsigned representation to get\nthe signed representation:\n\nWhat should we use for the offset ? Note that by the definition of the\n(signed) base- representation:\n\nRearranging this give us:\n\nThis means that we should the offset to .\n\nHere is an implementation of the signed base- representation. Our\nimplementation uses a \u201cshift and mask\u201d method to comptue the unsigned\nrepresentation.\n\ntfhe/gsw.py\n\n    \n    \n    def base_p_num_powers(log_p: int): \"\"\"Return the size of a base 2^log_p representation of an int32.\"\"\" return 32 // log_p def array_to_base_p(a: np.ndarray, log_p: int) -> Sequence[np.ndarray]: \"\"\"Compute the base 2^log_p representation of each element in a. a: An array of type int32 log_p: Compute the representation in base 2^log_p \"\"\" num_powers = base_p_num_powers(log_p) half_p = np.int32(2 ** (log_p - 1)) offset = half_p * sum(2 ** (i * log_p) for i in range(num_powers)) mask = 2 ** (log_p) - 1 a_offset = (a + offset).astype(np.uint32) output = [] for i in range(num_powers): output.append( (np.right_shift(a_offset, i * log_p) & mask).astype(np.int32) - half_p ) return output def base_p_to_array(a_base_p: Sequence[np.ndarray], log_p) -> np.ndarray: \"\"\"Reconstruct an array of int32s from its base 2^log_p representation.\"\"\" return sum(2 ** (i * log_p) * x for i, x in enumerate(a_base_p)).astype( np.int32 )\n\nWe\u2019ll similarly define the base- representation of a polynomial to be a\nsequence of polynomials satisfying:\n\nand we\u2019ll extend the function defined above to include polynomials:\n\nThe base- representation of a polynomial can be computed from the base-\nrepresentations of the coefficients:\n\ntfhe/gsw.py\n\n    \n    \n    def polynomial_to_base_p( f: polynomial.Polynomial, log_p: int ) -> Sequence[polynomial.Polynomial]: \"\"\"Compute the base 2^log_p of the polynomial f.\"\"\" return [ polynomial.Polynomial(coeff=v, N=f.N) for v in array_to_base_p(f.coeff, log_p=log_p) ] def base_p_to_polynomial( f_base_p: Sequence[polynomial.Polynomial], log_p: int ) -> polynomial.Polynomial: \"\"\"Recover the polynomial f from its base 2^log_p representation.\"\"\" f = polynomial.zero_polynomial(f_base_p[0].N) for i, level in enumerate(f_base_p): p_i = 2 ** (i * log_p) f = polynomial.polynomial_add( f, polynomial.polynomial_constant_multiply(p_i, level) ) return f\n\nNote that equation can also be written as a dot product:\n\nWe\u2019ll define the row vector to be:\n\nEquation can now be written more succinctly as:\n\nIn the next section we will apply the base- representation to an RLWE\nciphertext . For that purpose we\u2019ll define the matrix :\n\nwhere denotes a column vector of zeros. It\u2019s easy to see that:\n\nwhere denotes the concatenation of and .\n\nNote that similarly to the trivial factorization from the previous section,\nthe coefficients on the left hand side of the base- factorization are small.\nIndeed, the output of is, by definition, a polynomial with coefficients in the\nrange , which is small compared to .\n\nThe advantage of the base- representation is that, unlike the trivial\nfactorization, it is well defined.\n\n## GSW Encryption and Homomorphic Multiplication\n\nWe\u2019ll now use the base- representation to upgrade our implementations of GSW\nencryption and homomorphic multiplication from section Encryptions Of Zero to\none that is both well defined and has a tighter error bound.\n\nLet be an RLWE encryption key and let be an RLWE plaintext. The GSW encryption\nof is a matrix defined by:\n\nwhere is the matrix defined in equation and is a matrix whose -th row is an\nRLWE encryption of zero.\n\nWe\u2019ll now implement homomorphic multiplication. Let be a GSW encryption of and\nlet be an RLWE encryption of . Motivated by equation , homomorphic\nmultiplication between and is defined by:\n\nWe claim that is a valid RLWE encryption of and that the ciphertext noise is\nsmall assuming only that is small. The proof uses equation and follows the\nsame format as our proof of the preliminary version.\n\nLet\u2019s do a quick sanity check on the dimensions. Since and are length row\nvectors, is a length row vector. Furthermore, is a matrix. Therefore, the\nproduct is a length row vector which is indeed the correct shape for an RLWE\nciphertext.\n\nHere are the implementations of GSW encryption and homomorphic multiplication:\n\ntfhe/gsw.py\n\n    \n    \n    def convert_rlwe_key_to_gsw( rlwe_key: rlwe.RlweEncryptionKey, gsw_config: GswConfig ) -> GswEncryptionKey: return GswEncryptionKey(config=gsw_config, key=rlwe_key.key) def convert_gws_key_to_rlwe( gsw_key: GswEncryptionKey, ) -> rlwe.RlweEncryptionKey: return rlwe.RlweEncryptionKey( config=gsw_key.config.rlwe_config, key=gsw_key.key ) def gsw_encrypt( plaintext: GswPlaintext, key: GswEncryptionKey ) -> GswCiphertext: gsw_config = key.config num_powers = base_p_num_powers(log_p=gsw_config.log_p) # Create 2 RLWE encryptions of 0 for each element of a base-p representation. rlwe_key = convert_gws_key_to_rlwe(key) rlwe_plaintext_zero = rlwe.build_zero_rlwe_plaintext(gsw_config.rlwe_config) rlwe_ciphertexts = [ rlwe.rlwe_encrypt(rlwe_plaintext_zero, rlwe_key) for _ in range(2 * num_powers) ] # Add multiples p^i * message to the RLWE ciphertexts. for i in range(num_powers): p_i = 2 ** (i * gsw_config.log_p) scaled_message = polynomial.polynomial_constant_multiply( p_i, plaintext.message ) rlwe_ciphertexts[i].a = polynomial.polynomial_add( rlwe_ciphertexts[i].a, scaled_message ) b_idx = i + num_powers rlwe_ciphertexts[b_idx].b = polynomial.polynomial_add( rlwe_ciphertexts[b_idx].b, scaled_message ) return GswCiphertext(gsw_config, rlwe_ciphertexts) def gsw_multiply( gsw_ciphertext: GswCiphertext, rlwe_ciphertext: rlwe.RlweCiphertext ) -> rlwe.RlweCiphertext: gsw_config = gsw_ciphertext.config rlwe_config = rlwe_ciphertext.config # Concatenate the base-p representations of rlwe_ciphertext.a and rlwe_ciphertext.b rlwe_base_p = polynomial_to_base_p( rlwe_ciphertext.a, log_p=gsw_config.log_p ) + polynomial_to_base_p(rlwe_ciphertext.b, log_p=gsw_config.log_p) # Multiply the row vector rlwe_base_p with the # len(rlwe_base_p)x2 matrix gsw_ciphertext.rlwe_ciphertexts. rlwe_ciphertext = rlwe.RlweCiphertext( config=rlwe_config, a=polynomial.zero_polynomial(rlwe_config.degree), b=polynomial.zero_polynomial(rlwe_config.degree), ) for i, p in enumerate(rlwe_base_p): rlwe_ciphertext.a = polynomial.polynomial_add( rlwe_ciphertext.a, polynomial.polynomial_multiply( p, gsw_ciphertext.rlwe_ciphertexts[i].a ), ) rlwe_ciphertext.b = polynomial.polynomial_add( rlwe_ciphertext.b, polynomial.polynomial_multiply( p, gsw_ciphertext.rlwe_ciphertexts[i].b ), ) return rlwe_ciphertext\n\nThis completes our implementation of the homomorphic multiplexer that was\nstarted in the Introduction.\n\n# Blind Rotation\n\n## Definition\n\nConsider the polynomial\n\nin the negacyclic polynomial ring of degree . If we multiply by then due to\nthe negacyclic property we get\n\nIn other words, multiplying by rotates the coefficients of one step to the\nright and the coefficient that wraps around (in this case ) picks up a minus\nsign:\n\nFor this reason, multiplication by a monomial in a negacyclic polynomial ring\nis sometimes referred to as rotation by .\n\nNote that in the negacyclic polynomial ring , the monomial is well defined\neven if is negative. For instance, we can use the relation to rewrite as\n\nTherefore, we can define a function that rotates a polynomial by an integer :\n\nNote that due to the negacyclic relation , the function is periodic in the\nfirst variable with period :\n\nIn this post we\u2019re working with the integers modulo , , rather than the\nregular integers . Unfortunately, is not well defined on in the first\nvariable. The reason for this is that operations in are defined modulo\nwhereas, as we just saw, has a period of .\n\nWe can reconcile this difference by rescaling by before using it to rotate .\nSpecifically, we\u2019ll upgrade to the function :\n\nIn other words, takes as input an integer and a negacyclic polynomial and\noutputs a rotation of by :\n\nFor example, if then rotates by .\n\nIt\u2019s easy to see that has a period of in the first variable, which is why we\ncan apply it to elements of .\n\nis the homomorphic version of . Its inputs are an LWE encryption of the index\ntogether with an RLWE encryption of the polynomial . Its output is an RLWE\nencryption of the polynomial :\n\nNote that in the equation above, is an LWE encryption key and is the\nassociated RLWE encryption key as discussed in section LWE To RLWE Keys.\n\nThe goal of this section will be to implement blind rotation. Here is the\nsignature of the function that we will implement:\n\ntfhe/bootstrap.py\n\n    \n    \n    def blind_rotate( lwe_ciphertext: lwe.LweCiphertext, rlwe_ciphertext: rlwe.RlweCiphertext, bootstrap_key: BootstrapKey, ) -> rlwe.RlweCiphertext: \"\"\"Homomorphically evaluate the function: Rotate(i, f(x)) = x^((2N/q)*i)) * f(x). Suppose lwe_ciphertext is an encryption of i and rlwe_ciphertext is an encryption of f(x). Then the output will be an encryption of x^((2N/q)*i) * f(x). \"\"\" pass\n\nThe bootstrapping_key argument will be explained in the following section.\n\n## Implementation\n\nLet be an LWE encryption key and let be the associated RLWE encryption key.\nLet be an LWE encryption of and let be an RLWE encryption of .\n\nTo facilitate notation, in this section we\u2019ll define:\n\nOur goal is to evaluate . By definition, this means that we must use the\nciphertexts and to compute an RLWE encryption of .\n\nFirst, we\u2019ll define and to be:\n\nRecall that the LWE decryption operation is defined by:\n\nSince is an encryption of , the decryption is equal to where is a small error.\nTherefore:\n\nThis equality is not exact, but we\u2019ll absorb the difference into the error and\nwrite:\n\nTherefore:\n\nSince each is either or , is equal to or . Therefore, we can evaluate by\niteratively applying a multiplexer with as the selector bit. More concretely,\nwe\u2019ll start with and inductively define:\n\nfor . From the definition of it follows that:\n\nTherefore, it is easy to prove by induction that:\n\nBy equation it follows that:\n\nOur strategy for producing an RLWE encryption of is to iteratively produce\nRLWE encryptions of for by replacing the operations in our inductive equation\nwith their homomorphic counterparts.\n\nThe first modification is to replace with a GSW encryption of that we will\ndenote by :\n\nThe second modification is to replace the multiplexer with the homomorphic\nmultiplexer that we implemented in A Homomorphic Multiplexer. Finally, we\u2019ll\nreplace the product with the homomorphic product from section Homomorphic\nMultiplication By Plaintext. Putting this all together, our new inductive\nequation is:\n\nfor where the initial value is defined to be the homomorphic product of and\nthe input ciphertext :\n\nWe claim that is an RLWE encryption of of .\n\nIn particular, from the case it follows that is an RLWE encryption of . We can\ntherefore implement by using equations and to iteratively compute and set:\n\nNote that our implementation of relies on the GSW encryptions . We\u2019ll call the\nlist the Bootstrapping Key. Since the bootstrapping key is itself encrypted,\nit is considered to be a public key that can be shared with untrusted parties.\n\nHere is a concrete implementation of our algorithm:\n\ntfhe/bootstrap.py\n\n    \n    \n    @dataclasses.dataclass class BootstrapKey: config: gsw.GswConfig gsw_ciphertexts: Sequence[gsw.GswCiphertext] def generate_bootstrap_key( lwe_key: lwe.LweEncryptionKey, gsw_key: gsw.GswEncryptionKey ) -> BootstrapKey: bootstrap_key = BootstrapKey(config=gsw_key.config, gsw_ciphertexts=[]) for b in lwe_key.key: b_plaintext = rlwe.build_monomial_rlwe_plaintext( b, 0, gsw_key.config.rlwe_config ) bootstrap_key.gsw_ciphertexts.append( gsw.gsw_encrypt(b_plaintext, gsw_key) ) return bootstrap_key def blind_rotate( lwe_ciphertext: lwe.LweCiphertext, rlwe_ciphertext: rlwe.RlweCiphertext, bootstrap_key: BootstrapKey, ) -> rlwe.RlweCiphertext: \"\"\"Homomorphically evaluate the function: Rotate(i, f(x)) = x^i * f(x). Suppose lwe_ciphertext is an encryption of i and rlwe_ciphertext is an encryption of a polynomial f(x). Then the output will be an encryption of x^i * f(x). \"\"\" N = rlwe_ciphertext.config.degree # Scale the lwe_ciphertext by N / 2^31 so that the message is between -N and N scaled_lwe_a = np.int32(np.rint(lwe_ciphertext.a * (N * 2 ** (-31)))) scaled_lwe_b = np.int32(np.rint(lwe_ciphertext.b * (N * 2 ** (-31)))) # Initialize the rotation by X^b rotated_rlwe_ciphertext = rlwe.rlwe_plaintext_multiply( rlwe.build_monomial_rlwe_plaintext( 1, scaled_lwe_b, rlwe_ciphertext.config ), rlwe_ciphertext, ) # Rotate by X^-a_i if s_i = 1 for i, a_i in enumerate(scaled_lwe_a): rotated_rlwe_ciphertext = gsw.cmux( bootstrap_key.gsw_ciphertexts[i], rotated_rlwe_ciphertext, rlwe.rlwe_plaintext_multiply( rlwe.build_monomial_rlwe_plaintext( 1, -a_i, rlwe_ciphertext.config ), rotated_rlwe_ciphertext, ), ) return rotated_rlwe_ciphertext\n\nHere is an example:\n\ntests/test_bootstrap.py\n\n    \n    \n    # Generate random encryption keys. lwe_key = lwe.generate_lwe_key(config.LWE_CONFIG) rlwe_key = rlwe.generate_rlwe_key(config.RLWE_CONFIG) gsw_key = gsw.convert_rlwe_key_to_gsw(rlwe_key, config.GSW_CONFIG) bootstrap_key = bootstrap.generate_bootstrap_key(lwe_key, gsw_key) # f(x) = -1 -x ... -x^(N/2-1) + x^(N/2) + ... + x^(N-1) N = config.RLWE_CONFIG.degree f = polynomial.Polynomial(N=N, coeff=np.ones(N, dtype=np.int32)) f.coeff[: N // 2] = -1 # Encode f(x) as an RLWE plaintext and encrypt it with the key. f_plaintext = rlwe.rlwe_encode(f, config.RLWE_CONFIG) f_ciphertext = rlwe.rlwe_encrypt(f_plaintext, rlwe_key) # i = 3/8 * q. This means that we will rotate by (2N/q)*i = 3/4 * N. # Encode i as an LWE plaintext and encrypt it with the key. index_plaintext = lwe.lwe_encode(3) index_ciphertext = lwe.lwe_encrypt(index_plaintext, lwe_key) # Use blind_rotate to rotate f(x) by i, using only the ciphertexts # index_ciphertext and f_ciphertext. rotated_ciphertext = bootstrap.blind_rotate( index_ciphertext, f_ciphertext, bootstrap_key ) # Use the encryption key to decrypt rotated_ciphertext, and then decode it. rotated_f = rlwe.rlwe_decode( rlwe.rlwe_decrypt(rotated_ciphertext, rlwe_key) ) # The rotated result should be approximately: # x^(3/4 * N)f(x) = 1 + x ... + x^(N/4-1) - x^(N/4) - ... - x^(N-1) assert rotated_f.coeff[0] == 1 assert rotated_f.coeff[N // 2] == -1 assert rotated_f.coeff[-1] == -1\n\n## Noise Analysis\n\nLet be an LWE ciphertext and let be an RLWE encryption of . An interesting\nproperty of is that noise in can affect the positions of the coefficients in\nthe output ciphertext , but it does not affect their magnitude.\n\nFor example, suppose that and . A plaintext (i.e not blind) rotation of by is\nequal to :\n\nLet be an LWE encryption of and let be an RLWE encryption of . Now we\u2019ll\ncompute the blind rotation of using and and decrypt the result to get a\nrotated polynomial :\n\nWhat does look like? Since is an RLWE encryption of , the decryption is\napproximately equal to . More concretely, it turns out that will have the\nform:\n\nwhere the are small error terms and is close to . If is noisier, the index\nwill move further from but the magnitude of the errors will not be affected.\n\nTo see why has this property, consider our inductive equation . The key\nobservation is that the coefficients of only appear in the homomorphic\nmultiplication\n\nMultiplying the ciphertext by the plaintext changes the position of the\ncoefficients in underlying plaintext but not their magnitudes.\n\nThis property of will play an important role in our analysis of bootstrapping\nnoise.\n\n# Sample Extraction\n\n## Definition\n\nThe coefficient function takes as input an index and a polynomial\n\nand outputs , the -th coefficient of :\n\nSample Extraction is the homomorphic version of the coefficient function. The\nfunction takes as input an index and an RLWE encryption of and outputs an LWE\nencryption of :\n\nAs before, in the definition above is an LWE encryption key and is the\nassociated RLWE encryption key.\n\nThe goal of this section is to implement sample extraction. Here is the\ndefinition of the function in our library:\n\ntfhe/bootstrap.py\n\n    \n    \n    def extract_sample( i: int, rlwe_ciphertext: rlwe.RlweCiphertext ) -> lwe.LweCiphertext: \"\"\"Homomorphically extract the i-th coefficient from the RLWE ciphertext. If rlwe_ciphertext is an RLWE encryption of f(x) = f_0 + f_1*x + ... + f_{N-1}x^{N-1} then the output will be an LWE encryption of f_i. \"\"\" pass\n\n## Implementation\n\nLet be an LWE encryption key and let be the corresponding RLWE key. Let be an\nRLWE encryption of with the key .\n\nLet be an index. How can we convert the RLWE ciphertext into an LWE encryption\nof with the key ?\n\nBy the definition of RLWE encryption:\n\nfor some small error .\n\nLet denote the -th coefficient of . Since we are working with negacyclic\npolynomials, the -th coefficient satisfies a variation on the typical\npolynomial convolution:\n\nNote that if we define the vector to be:\n\nThen we can rewrite equation as a dot product:\n\nPlugging this into equation and considering the -th coefficient gives us:\n\nBut note that the right hand side of the last equation is exactly the LWE\ndecryption of the ciphertext with the encryption key ! This implies that is an\nLWE encryption of with the key .\n\nIn summary, we can implement by:\n\nHere is a concrete implementation:\n\ntfhe/bootstrap.py\n\n    \n    \n    def extract_sample( i: int, rlwe_ciphertext: rlwe.RlweCiphertext ) -> lwe.LweCiphertext: \"\"\"Homomorphically extract the i-th coefficient from the RLWE ciphertext. If rlwe_ciphertext is an RLWE encryption of f(x) = c_0 + c_1*x + ... + c_{N-1}x^{N-1} then the output will be an LWE encryption of c_i. \"\"\" lwe_config = lwe.LweConfig( dimension=rlwe_ciphertext.config.degree, noise_std=rlwe_ciphertext.config.noise_std, ) a = np.hstack( [ rlwe_ciphertext.a.coeff[: i + 1][::-1], -1 * rlwe_ciphertext.a.coeff[i + 1 :][::-1], ] ) b = rlwe_ciphertext.b.coeff[i] return lwe.LweCiphertext(lwe_config, a, b)\n\nHere is an example:\n\ntests/test_bootstrap.py\n\n    \n    \n    lwe_key = lwe.generate_lwe_key(config.LWE_CONFIG) rlwe_key = rlwe.convert_lwe_key_to_rlwe(lwe_key) N = lwe_key.config.dimension # f(x) = 2x f = polynomial.build_monomial(2, 1, N) # Encode f(x) as an RLWE plaintext and encrypt it. f_plaintext = rlwe.rlwe_encode(f, config.RLWE_CONFIG) f_ciphertext = rlwe.rlwe_encrypt(f_plaintext, rlwe_key) # Homomorphically extract an LWE encryption of the coefficient f_1 sample_ciphertext = bootstrap.extract_sample(1, f_ciphertext) # Decrypt and decode sample_ciphertext. The result should be equal to f_1=2. coeff_decoded = lwe.lwe_decode(lwe.lwe_decrypt(sample_ciphertext, lwe_key)) assert coeff_decoded == 2\n\n## Noise Analysis\n\nAs before, let be an LWE encryption key and let be the corresponding RLWE key.\nLet be an RLWE encryption of with the key and noise .\n\nWe\u2019ve seen that for an integer , is an LWE encryption of . In this section we\nwill show that the LWE ciphertext has the same amount of noise as the RLWE\nciphertext . In other words, sample extraction does not affect the ciphertext\nnoise.\n\nThe claim follows immediately from equation . Indeed, by the definition of and\nequation we have:\n\nTherefore, the ciphertext has noise which is one of the coefficients of , the\nnoise of .\n\n# Bootstrapping Implementation\n\nWe now have all the pieces required to implement the bootstrapping function.\nRecall from section Bootstrap that is a homomorphic version of the step\nfunction . Our strategy for implementing is to implement using the function\nfrom section Blind Rotation and the function from section Sample Extraction.\n\nThen we will leverage the homomorphic versions of these functions, and , to\nimplement .\n\n## Building The Step Function From Polynomial Rotations\n\nConsider the polynomial whose first coefficients are and the last coefficients\nare :\n\nWe will refer to as the Test Polynomial. What happens if we rotate by an\ninteger ? Let\u2019s start with :\n\nAll of the coefficients get shifted one place to the right, and the last\ncoefficient, , circles back to the beginning and, due to the negacyclic\nproperty, picks up a minus sign to become . In summary, the number of negative\ncoefficients has grown by one from to and the number of positive coefficients\nhas decreased by one.\n\nBy iterating this process, we can see that if we rotate by then all of the\ncoefficients will become :\n\nWhat happens if we rotate one more time? Since the last coefficient of is ,\nwhen we rotate one more time it circles back to the beginning and picks up a\nnegative sign, turning it into a 1:\n\nNow the ordering between the positive and negative coefficient has flipped.\nstarts with a and ends with negative ones. If we rotate more times for a total\nof times, then a similar analysis as before shows that all of the coefficients\nof the resulting polynomial will be :\n\nThe above analysis shows that the zeroth coefficient of is equal to when and\nequal to when . In other words:\n\nIn fact, it is not hard to generalize this to the case where can be negative:\n\nIn section Blind Rotation we defined , a scaled version of that is well\ndefined on :\n\nPlugging this into equation gives us:\n\nNote that this equation looks very similar to the definition of the step\nfunction from section Implementation Strategy:\n\nIndeed, we can obtain the step function by translating and scaling . The\nfollowing equality follows directly from equation :\n\nThis realizes our objective of expressing in terms of and .\n\n## A Homomorphic Step Function\n\nIn section Bootstrapping we introduced the bootstrapping function as a\nhomomorphic version of the step function . In this section we will implement\nby building a homomorphic step function.\n\nIn equation in the previous section we expressed in terms of the polynomial\nrotation function and the coefficient function .\n\nIn section Blind Rotation we implemented a homomorphic version of called and\nin section Sample Extraction we implemented a homomorphic version of called .\nWe can plug these homomorphic functions into equation to obtain a homomorphic\nversion of that we will call .\n\nMore precisely, let be an LWE encryption of . Also, let be a trivial RLWE\nencryption of the scaled test polynomial and let be a trivial LWE encryption\nof the translation factor .\n\nWe can compute using the homomorphic analog of equation :\n\nHere is a concrete implementation:\n\ntfhe/bootstrap.py\n\n    \n    \n    def _build_test_polynomial(N: int) -> polynomial.Polynomial: p = polynomial.Polynomial(N=N, coeff=np.ones(N, dtype=np.int32)) p.coeff[: N // 2] = -1 return p def bootstrap( lwe_ciphertext: lwe.LweCiphertext, bootstrap_key: BootstrapKey, scale: np.int32, ) -> lwe.LweCiphertext: \"\"\"Bootstrap the LWE ciphertext. Suppose that lwe_ciphertext is an encryption of the int32 i. If -2^30 < i <= 2^30 then return an LWE encryption of the scale argument. Otherwise return an LWE encryption of 0. In both cases the ciphertext noise will be bounded and independent of the lwe_ciphertext noise. \"\"\" N = bootstrap_key.config.rlwe_config.degree test_polynomial = polynomial.polynomial_constant_multiply( scale // 2, _build_test_polynomial(N) ) test_rlwe_ciphertext = rlwe.rlwe_trivial_ciphertext( test_polynomial, bootstrap_key.config.rlwe_config ) rotated_rlwe_ciphertext = blind_rotate( lwe_ciphertext, test_rlwe_ciphertext, bootstrap_key ) sample_lwe_ciphertext = extract_sample(0, rotated_rlwe_ciphertext) offset_lwe_ciphertext = lwe.lwe_trivial_ciphertext( plaintext=lwe.LwePlaintext(scale // 2), config=sample_lwe_ciphertext.config, ) return lwe.lwe_add(offset_lwe_ciphertext, sample_lwe_ciphertext)\n\nNote that this implementation of bootstrap returns either an encryption of 0\nor an encryption of the scale parameter. In the presentation above we used\nscale=utils.Encode(2).\n\n## Noise Analysis\n\nRecall from section Bootstrapping that a key property of is that if is an LWE\nciphertext then the noise of should be bounded independently of the noise in .\n\nThis bound follows immediately from our previous noise analyses of the two\nbootstrapping building blocks: and . In section Blind Rotation we saw that the\ncoefficient noise of is bounded and independent of the input ciphertext . And\nin section Sample Extraction we saw that preserves the noise in the input\nciphertext .\n\nThe desired bound on the noise of now follows from these two results together\nwith equation .\n\n## Performance\n\nThe official TFHE implementation reports that one bootstrapping operation\ntakes around 20ms on a single core of an intel i7 processor. In comparison,\nour bootstrap function runs in about 20 seconds on a single core of an intel\ni5 processor. There are two factors which contribute to this 1000x\ndiscrepancy.\n\nFirst of all, computationally intensive python programs are typically around\n100x slower than their C++ counterparts. This is especially true for our\nimplementation in which we made no attempt to cache frequently computed values\nor optimize loops with numpy vectorization.\n\nSecond of all, the blind_rotate function is essentially a loop of 1024 cmux\noperations, each of which involves around 10 polynomial_multiply calls. For\nsimplicity, our implementation of polynomial_multiply uses the numpy polymul\nmethod. That numpy method implements naive coefficient-by-coefficient\npolynomial multiplication whose runtime complexity is . In contrast, the\nofficial TFHE implementation uses the FFT based approach described here which\nhas a runtime complexity of .\n\nSince even heavily optimized implementations take over a millisecond to\nperform a single homomorphic NAND gate, use of FHE to secure real-world\ncomputations will likely require additional algorithmic advances.\n\n# Comments\n\nThe comments are powered by the utterences Github app. If you do not want the\napp to post on your behalf, you can comment directly on this Github issue.\n\nemail\n\ngithub.com/lowdanie\n\n", "frontpage": false}
