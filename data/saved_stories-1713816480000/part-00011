{"aid": "40112487", "title": "Computing Engine on Web", "url": "https://github.com/SPLWare/esProc/wiki/Computing-engine-on-WEB", "domain": "github.com/splware", "votes": 1, "user": "Judyrabbit", "posted_at": "2024-04-22 08:44:25", "comments": 0, "source_title": "Computing engine on WEB", "source_text": "Computing engine on WEB \u00b7 SPLWare/esProc Wiki \u00b7 GitHub\n\nSkip to content\n\nSign in\n\n# Search code, repositories, users, issues, pull requests...\n\nSearch syntax tips\n\nSign in\n\nSign up\n\nYou signed in with another tab or window. Reload to refresh your session. You\nsigned out in another tab or window. Reload to refresh your session. You\nswitched accounts on another tab or window. Reload to refresh your session.\nDismiss alert\n\nSPLWare / esProc Public\n\n  * Notifications\n  * Fork 310\n  * Star 4.4k\n\n# Computing engine on WEB\n\nJump to bottom\n\nesProcSPL edited this page Feb 23, 2024 \u00b7 1 revision\n\nThe data interfaces on the Web are mainly restful and WebService, and the data\nformats usually are hierarchical JSON and XML. Hierarchical data can carry\nmore general and richer information, yet it is more complex in structure and\nmore difficult to compute than traditional two-dimensional data. There seem to\nbe many tools or engines available for Web computing, but each has its own\nshortcomings. Specifically, the libraries like JsonPath/XPath are good at\nparsing but not good at computing; Python Pandas is relatively powerful in\ncomputing, but it is difficult to integrate it into Java and, since its data\nobject DataFrame is not specifically designed for hierarchical data, it will\nresult in a difficulty to code when the calculation task is complex; Scala\nSpark is better in integration but heavy in framework and difficult to learn.\n\nFor computing engines on Web, there is a better choice: esProc SPL.\n\nesProc SPL, as an JVM-based open-source programming language, offers built-in\nspecialized hierarchical data objects and convenient Web parsing/generating\nfunctions that can simplify complex hierarchical data calculation, and it is\neasy to integrate SPL into Java applications.\n\n## Specialized hierarchical data object\n\nSPL offers table sequence \u2013 the built-in specialized hierarchical data object,\nwhich is suitable for carrying Web data formats and good at expressing complex\nhierarchical relationships.\n\nFor example, perform conditional query on a Json string, and return the result\nin the form of Json string:\n\nA| B  \n---|---  \n1| =json(p_JsonStr)| Parse Jason string as SPL table sequence  \n2| =A1.conj(Orders)| Merge lower-level records  \n3| =A2.select(Amount>1000 && Amount<=2000)| Conditional query  \n4| =json(A3)| Convert result to Json string  \n  \nA1: the external parameter p_JsonStr is a Json string, and the function json\nconverts it to a table sequence (SPL\u2019s structured data object). In SPL\u2019s IDE,\nclick cell A1, we can see a hierarchical table sequence structure, where the\nfields like Eid and State store the data of simple types, and Orders field\nstores the set of records (two-dimensional table). Click a row under Orders,\nwe can expand the value to view details:\n\nA2, A3: calculate the table sequence, and the calculation result is also a\ntable sequence. A4: the function json is capable of either converting a Json\nstring to table sequences or vice-versa.\n\nSPL provides convenient hierarchical data access methods, allowing us to\nlocate the data on different level through dot, and the data at different\nposition through index.\n\nGet a set of values of a single field on level 1: A1.(Client)\n\nGet a set of values of multiple fields on level 1: A1.(\\\\[Client,Name\\\\])\n\nGet the 10th record on level 1: A1(10)\n\nGet Orders field of the 10th record on level 1 (all lower-level records):\nA1(10).Orders\n\nGet a set of values of a single field under Orders field of the 10th record on\nlevel 1: (A1(10).Orders).(Amount)\n\nGet the 5th record of Orders field of the 10th record on level 1:\n(A1(10).Orders)(5)\n\nGet 10th to 20th records on level 1: A1(to(10,20))\n\nGet the last three records on level 1: A1.m(\\\\[-1,-2,-3\\\\])\n\nAs a high-level data object independent of string format, the table sequence\ncan parse both Json and XML strings, and the calculation code is universal.\nFor example, p_XMLStr is a hierarchical XML string (having same structure as\nthe previous Json), when we perform the same conditional query on it, we only\nneed to modify A1 to: =xml(p_XMLStr,\"xml/row\").\n\nSimilar to function json, function xml also supports bi-directional\nconversion.\n\nSPL provides various Web data interfaces, allowing us to access restful or\nWebService conveniently, and parse them as uniform table sequence. For\nexample, when we want to access restful interface, we only need to modify A1\nin the previous example to:\n\nA  \n---  \n1| =httpfile(\"http://127.0.0.1:6868/restful/emp_orders\").read())  \n2| =json(A1)  \n  \nThe function httpfile is used to access URL address. With this function, we\ncan specify the port, Header, character set, IPV4/V6, Post/Get. In addition,\nit supports authentication methods using cookies or tokens.\n\nAccess WebService interface:\n\nA  \n---  \n1| =ws_client(\"http://127.0.0.1:6868/ws/RQWebService.asmx?wsdl\")  \n2| =ws_call(A1,\"RQWebService\":\"RQWebServiceSoap\":\"getEmp_orders\")  \n  \nThe function ws_client is used to establish WebService client, and the\nfunction ws_call is used to query WebService service.\n\nSince the table sequence has nothing to do with the string format and data\nsource, the following examples are generally applicable to Json\\XML\\parameter\nstring\\Web, unless otherwise specified. It is not difficult to imagine that\nSPL can also parse local Json files or XML files. Since two-dimensional data\ncan be regarded as simplified hierarchical data, the table sequence can also\nparse and calculate csv file or database table (this is not the point of this\narticle).\n\n## Powerful computing ability\n\nFor the parsed table sequence, SPL offers rich computing functions, making it\npossible to easily accomplish everyday SQL-style calculations.\n\nA| B  \n---|---  \n1| ...| Generate hierarchical table sequence  \n2| =A1.conj(Orders)| Merge lower-level records  \n3| =A2.groups(State,Gender;avg(Salary),count(1))| Group and aggregate multiple\nfields  \n4|\n=A1.new(Name,Gender,Dept,Orders.OrderID,Orders.Client,Orders.Client,Orders.SellerId,Orders.Amount,Orders.OrderDate)|\nAssociate  \n5| =A1.sort(Salary)| Sort  \n6| =A1.id(State)| Distinct  \n7| =A2.top(-3;Amount)| topN  \n8| =A2.groups(Client;top(3,Amount))| In-group TopN (window function)  \n  \nIn addition, SPL provides the syntax that conforms to SQL92 standard, and\nsupports the set calculation, case when, with, nested subqueries, etc.\n\nSPL is highly expressive and suitable for computing hierarchical data with\ncomplex structure. For example: restful returns hierarchical Json data\ncontaining multiple subdocuments, and the structure is complex. Some of the\ndata are as follows:\n\n    \n    \n    [ { \"race\": { \"raceId\":\"1.33.1141109.2\", \"meetingId\":\"1.33.1141109\" }, ... \"numberOfRunners\": 2, \"runners\": [ { \"horseId\":\"1.00387464\", \"trainer\": { \"trainerId\":\"1.00034060\" }, \"ownerColours\":\"Maroon,pink,dark blue.\" }, { \"horseId\":\"1.00373620\", \"trainer\": { \"trainerId\":\"1.00010997\" }, \"ownerColours\":\"Black,Maroon,green,pink.\" } ] }, ... ]\n\nNow we want to group and aggregate the data on different levels (group by\ntrainerId and count the number of ownerColours members in each group). It is\nhard to handle the computation if we use common way directly in Java, SPL is\nmuch simpler:\n\nA  \n---  \n1| ...  \n2| =A1(1).runners  \n3| =A2.groups(trainer.trainerId; ownerColours.array().count():times)  \n  \nSPL supports logically complex calculations such as stepwise calculation,\nordered calculation and calculation after grouping. Many calculations that are\ndifficult to handle in SQL/stored procedures can be easily solved in SPL. For\nexample, find out the top n customers whose cumulative sales account for half\nof the total sales, and sort them by sales in descending order:\n\nA| B  \n---|---  \n1| ...| /Fetch data  \n2| =A1.sort(amount:-1)| /Sort by sales in descending order  \n3| =A2.cumulate(amount)| /Get a sequence of cumulative amounts  \n4| =A3.m(-1)/2| /Calculate the final accumulative amount, i.e., the total  \n5| =A3.pselect(~>=A4)| /Find the position where the amount exceeds half of the\ntotal  \n6| =A2(to(A5))| /Get target values by position  \n  \nSPL provides a wealth of date and string functions, making it possible to\neffectively simplify related calculations.\n\nGet the date before or after a specified number of quarters:\nelapse@q(\"2020-02-27\",-3) // Return 2019-05-27\n\nGet the date after N workdays: workday(date(\"2022-01-01\"),25) // Return\n2022-02-04\n\nString functions: check if a string consists entirely of numbers:\nisdigit(\"12345\") // Return true\n\nGet a string before a specified substring: substr@l(\"abCDcdef\",\"cd\") // Return\nabCD\n\nSplit a string into an array of substrings by vertical bar:\n\"aa|bb|cc\".split(\"|\") // Return [\"aa\",\"bb\",\"cc\"]\n\nSPL also offers many other functions, for example, get a date before or after\nspecified number of years, get which quarter the date belongs to, split a\nstring according to a regular expression, get words from a string, split HTML\nby the specific marker, etc.\n\nIt is worth mentioning that in order to further improve development\nefficiency, SPL invents unique function syntax. For example, we can use option\nto distinguish similar functions. If we only want to filter out the first\nrecord that meets condition, we can use the option @1:\n\n    \n    \n    T.select@1(Amount>1000)\n\nIf we want to search for the first record from back to front, we can use the\noption @z:\n\n    \n    \n    T.select@z1(Amount>1000)\n\n## Hot deployment integrated framework\n\nSPL provides JDBC driver, through which it can be easily integrated into Java\ncode: Simple SPL code can be embedded directly in Java like SQL:\n\n    \n    \n    String jsonStr=... //Json string Class.forName(\"com.esproc.jdbc.InternalDriver\"); Connection connection =DriverManager.getConnection(\"jdbc:esproc:local://\"); Statement statement = connection.createStatement(); String query=\"=json(json($[\"+jsonStr+\"]).conj(Orders).select((Amount>1000 && Amount<=2000)))\"; ResultSet result = statement.executeQuery(query);\n\nFor complex SPL code, we can save it as a script file first, and then invoke\nit by a Java program in the way of invoking a stored procedure, which can\neffectively reduce the coupling between computing code and front-end\napplication.\n\n    \n    \n    Class.forName(\"com.esproc.jdbc.InternalDriver\"); Connection conn =DriverManager.getConnection(\"jdbc:esproc:local://\"); CallableStatement statement = conn.prepareCall(\"{call getRestful(?, ?)}\"); statement.setObject(1, \"2020-01-01\"); statement.setObject(2, \"2020-01-31\"); statement.execute();\n\nSPL is an interpreted language, and the outside-application SPL code can be\nexecuted without compiling. In addition, SPL supports non-stop hot deployment,\nthis makes it suitable for the changing business logic, and makes O&M\ncomplexity low.\n\nSPL Resource: SPL Official Website | SPL Blog | Download esProc SPL | SPL Source Code\n\n  * Learn performance optimization skills from TPCH tests\n  * Ordered storage of SPL\n  * The impasse of SQL performance optimizing\n  * The Open-source SPL Redefines OLAP Server\n\n##### Clone this wiki locally\n\n## Footer\n\n\u00a9 2024 GitHub, Inc.\n\nYou can\u2019t perform that action at this time.\n\n", "frontpage": false}
