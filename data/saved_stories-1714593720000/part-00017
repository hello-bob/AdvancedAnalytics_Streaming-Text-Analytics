{"aid": "40220900", "title": "iOS: A journey in the USB networking stack", "url": "https://www.synacktiv.com/en/publications/ios-a-journey-in-the-usb-networking-stack", "domain": "synacktiv.com", "votes": 3, "user": "l2dy", "posted_at": "2024-05-01 08:39:47", "comments": 0, "source_title": "iOS: a journey in the USB networking stack", "source_text": "iOS: a journey in the USB networking stack\n\nSkip to main content\n\nSearch\n\nSwitch Language\n\n  * EN\n  * FR\n\n  * Github\n  * Twitter\n  * Linkedin\n\nMain navigation\n\n  * Our offer \u00bb\n\n    * Penetration Test / Red Team\n    * Incident response\n    * Trainings\n    * Reverse-engineering\n    * Development\n    * Products\n    * CSIRT\n  * Join us\n  * Publications \u00bb\n\n    * Posts\n    * Advisories\n    * Resources\n  * The company\n  * Contact\n\n  * Our offer \u00bb\n\n    * Penetration Test / Red Team\n    * Incident response\n    * Trainings\n    * Reverse-engineering\n    * Development\n    * Products\n    * CSIRT\n  * Join us\n  * Publications \u00bb\n\n    * Posts\n    * Advisories\n    * Resources\n  * The company\n  * Contact\n\n  * Github\n  * Twitter\n  * Linkedin\n\n# iOS: a journey in the USB networking stack\n\nWritten by Florian Le Minoux - 30/04/2024 - in Syst\u00e8me - Download\n\nIn this article, we give a small journey inside the implementation of\nnetworking interfaces exposed by iOS when connected via USB. These are used\nfor sharing a computer's connection with iPhone (tethering), sharing an\niPhone's connection with a computer (reverse tethering) and since the latest\nversions of iOS, USB networking even carries RemoteXPC packets which seems to\nbe the future common ground for all Apple based cross-device communications.\n\nThere is an ongoing hot topic in the Synacktiv development team between a\nhandful of iOS developers that are willing to work on a full macOS environment\nand people that'd rather spend an insane amount of time to make it work on\ntheir Linux development setup.\n\nThis Linux-extremist gang was recently interested in making reverse tethering\non iOS devices work on Linux hosts. This is particularly useful to avoid\ncreating Wi-Fi networks to connect iPhones to a controlled network.\n\nThis process somehow led us to explore the USB networking devices exposed by\niOS in recent versions.\n\nVery few literature exists on that matter, hence we'll try to aggregate the\nknowledge we gathered in this article.\n\n## A foreword on tethering\n\nTethering is the process of sharing your phone's internet connection with a\ncomputer. The idea is that the phone acts as a router, routing packets sent by\nthe computer to whichever air interface is connected. As a user, it's\nbasically like doing a Wi-Fi hotspot but over USB.\n\nOn iOS, this feature has been around for a very long time: it was introduced\nin iOS 3.\n\nAt that time, Apple developed a very thin protocol layer over USB to\nencapsulate Ethernet frames (the associated driver in iOS is named\nAppleUSBEthernetDevice). The protocol consists in encapsulating a single\nEthernet frame in each USB request block and sending them over two dedicated\nUSB bulk endpoints: one for each direction (RX/TX).\n\n    \n    \n    $ lsusb -d 05ac:12a8 -vvv [...] Interface Descriptor: bLength 9 bDescriptorType 4 bInterfaceNumber 2 bAlternateSetting 1 bNumEndpoints 2 bInterfaceClass 255 Vendor Specific Class bInterfaceSubClass 253 bInterfaceProtocol 1 iInterface 0 Endpoint Descriptor: bLength 7 bDescriptorType 5 bEndpointAddress 0x86 EP 6 IN bmAttributes 2 Transfer Type Bulk Synch Type None Usage Type Data wMaxPacketSize 0x0200 1x 512 bytes bInterval 0 Endpoint Descriptor: bLength 7 bDescriptorType 5 bEndpointAddress 0x05 EP 5 OUT bmAttributes 2 Transfer Type Bulk Synch Type None Usage Type Data wMaxPacketSize 0x0200 1x 512 bytes bInterval 0 [...]\n\nThis protocol has a dedicated Linux kernel driver, mainlined many years ago,\ncalled ipheth. This driver has seen very minimal changes over the years1 and\nthus the tethering protocol is compatible very broadly with all iOS versions\neven the recent ones.\n\n## The world of reverse tethering\n\nReverse tethering is the process of sharing your computer's internet\nconnection with the phone. The idea being that the computer receives packets\nfrom the phone and routes them to the internet. On macOS system its only a\nmatter of ticking a box in the network preferences.\n\nWhile tethering and reverse tethering could have been implemented with a\nsingle protocol, it would have implied some modifications to allow for\nexchanging the traffic direction and gateway. As there is no code in ipheth\nimplying a possibility to reverse the packet flow, we decided to take a look\nat USB exchanges while using the reverse tethering feature on a macOS system.\n\nWe quickly noticed that it uses the CDC-NCM protocol (Communications Device\nClass - Network Control Model, one of the few protocols used by the industry\nto perform Ethernet over USB2) on a USB interface that we did not see on\nLinux.\n\nAs you can see in the two screenshots below, there is one additional\nconfiguration advertised by iPhone when hooked to a macOS host compared to\nwhen hooked to a Linux machine. This is rather unusual.\n\nUSB descriptors on LinuxUSB descriptors on macOS\n\n## A quick detour on iOS USB internals\n\nThis weird behavior made us wonder how these USB interfaces are exposed and\nwhich were the kernel space and user space actors behind the USB networking\nfunctionalities, so that we could ultimately figure out how to reproduce the\nmacOS behavior.\n\nWhile searching keywords linked to our objective, we figured that USB devices\nconfigurations used by iOS are listed in a file stored at\n/System/Library/AppleUSBDevice/USBDeviceConfiguration.plist holding a\nconfigurations dictionary containing things like:\n\n    \n    \n    <key>stdMuxPTPEthValIDA</key> <array> [...] <dict> <key>Description</key> <string>PTP + Apple Mobile Device</string> <key>Interfaces</key> <array> <string>PTP</string> <string>AppleUSBMux</string> </array> <key>DefaultConfiguration</key> <true/> </dict> <dict> <key>Interfaces</key> <array> <string>PTP</string> <string>AppleUSBMux</string> <string>AppleUSBEthernet</string> </array> <key>Description</key> <string>PTP + Apple Mobile Device + Apple USB Ethernet</string> </dict> <dict> <key>Description</key> <string>PTP + Apple Mobile Device + NCM</string> <key>Interfaces</key> <array> <string>PTP</string> <string>AppleUSBMux</string> <string>AppleUSBNCMControl</string> <string>AppleUSBNCMData</string> <string>AppleUSBNCMControlAux</string> <string>AppleUSBNCMDataAux</string> </array> <key>ExtendedConfiguration</key> <true/> </dict> <dict> <key>Description</key> <string>PTP + Apple Mobile Device + Valeria</string> <key>Interfaces</key> <array> <string>PTP</string> <string>AppleUSBMux</string> <string>Valeria</string> <string>AppleUSBNCMControlAux</string> <string>AppleUSBNCMDataAux</string> </array> <key>ExtendedConfiguration</key> <true/> </dict> [...] <dict> <key>Description</key> <string>PTP + Apple Mobile Device + Apple USB Ethernet + NCM</string> <key>Interfaces</key> <array> <string>PTP</string> <string>AppleUSBMux</string> <string>AppleUSBEthernet</string> <string>AppleUSBNCMControl</string> <string>AppleUSBNCMData</string> <string>AppleUSBNCMControlAux</string> <string>AppleUSBNCMDataAux</string> </array> <key>ExtendedConfiguration</key> <true/> </dict> </array>\n\nIn fact, a lot of configurations are available including Carplay related ones,\nUVC Camera, audio, as well as some testing configurations.\n\nThis file is used by a very central user space daemon called configd. This\ndaemon is in charge of keeping state for a lot of network related tasks\n(link/IP/PPP state for example) as well as creating interfaces such as BSD's.\nIt has a modular structure composed of binary bundles3 that gets loaded and\nexecuted.\n\nAmong these executables, a very small bundle named\nUSBDeviceConfiguration.bundle is in charge of loading and parsing the\nUSBDeviceConfiguration.plist file (via the IOKit API\nIOUSBDeviceDescriptionCreateFromDefaultsAndController). The specific\nconfiguration which will be selected will by default is based on the\nconfiguration-string property hardcoded in the iOS device-tree.\n\nIn current versions of iOS, the default configuration loaded is named\nstdMuxPTPEthValIDA.\n\nThis selected configuration is forwarded by the userland to the kernel via the\nIOUSBDeviceControllerSendCommand API. Ultimately, this configuration is used\nby the kernel initialization function IOUSBDeviceController::createUSBDevice\nwhich will match each interface of the selected configuration (e.g.\nAppleUSBMux, AppleUSBNCMControl, shown in the property list above) to an\n(IOKit) driver that will provide the functionality.\n\n## Back to these CDC-NCM interfaces\n\nIf you look carefully at the default loaded configuration specified in\nUSBDeviceConfiguration.plist (in the previous part), you can see that there is\nsome mention of CDC-NCM interfaces. These are located inside dictionaries\ncontaining a special ExtendedConfiguration property.\n\nAfter some research, it turns out that these Extended Configurations can be\nswitched to and from using a proprietary USB control transfer packet with\nbRequest = 0x52. Indeed, this is confirmed by a USB capture showing that it is\nperformed by macOS to enable the CDC-NCM interface. This control transfer is\ncalled kVendorRequestSelectExtendedFunction inside the iOS kernel. The\nExtended Configurations that are allowed to be switched to are hardcoded in\nthe kernel and are limited to the possibilities below.\n\nThis proprietary modeswitch4 was quite recently implemented in usbmuxd5 by\nexposing an environment variable named USBMUXD_DEFAULT_DEVICE_MODE allowing to\nswitch between the different configurations on Linux.\n\nValues| Description  \n---|---  \n1| Switch to mode with the initial descriptors (with UsbMux descriptors only)  \n2| Switch to mode with Valeria descriptors (proprietary protocol used by\nQuickTime to gather a video/audio stream of the device)  \n3| Switch to mode with CDC-NCM descriptors (used for internet sharing)  \n  \nUnfortunately, this means that some configurations are not made to coexist:\ne.g. it seems you can't stream your device screen with reverse tethering at\nthe same time.\n\nAfter relaunching usbmuxd with the environment variable\nUSBMUXD_DEFAULT_DEVICE_MODE=3, a new USB interface descriptor appears and\nLinux recognizes it properly as a generic CDC-NCM device as shown in the lsusb\ndump below. This is now the default mode that is requested by usbmuxd in the\nlatest release.\n\n    \n    \n    $ lsusb -d 05ac:12a8 -vvv [...] Interface Descriptor: bLength 9 bDescriptorType 4 bInterfaceNumber 2 [...] iInterface 16 NCM Control CDC Union: bMasterInterface 2 bSlaveInterface 3 CDC Header: bcdCDC 1.10 CDC Ethernet: iMacAddress 15 XXXXXXXXXXXX bmEthernetStatistics 0x00000000 wMaxSegmentSize 1514 wNumberMCFilters 0x0000 bNumberPowerFilters 0 CDC NCM: bcdNcmVersion 1.00 bmNetworkCapabilities 0x3b 8-byte ntb input size crc mode max datagram size net address packet filter Endpoint Descriptor: bLength 7 bDescriptorType 5 bEndpointAddress 0x86 EP 6 IN bmAttributes 3 Transfer Type Interrupt Synch Type None Usage Type Data wMaxPacketSize 0x0010 1x 16 bytes bInterval 11 [...] Interface Descriptor: bLength 9 bDescriptorType 4 bInterfaceNumber 3 bAlternateSetting 1 bNumEndpoints 2 bInterfaceClass 10 CDC Data bInterfaceSubClass 0 bInterfaceProtocol 1 iInterface 21 NCM Data Endpoint Descriptor: bLength 7 bDescriptorType 5 bEndpointAddress 0x87 EP 7 IN bmAttributes 2 Transfer Type Bulk Synch Type None Usage Type Data wMaxPacketSize 0x0200 1x 512 bytes Endpoint Descriptor: bLength 7 bDescriptorType 5 bEndpointAddress 0x05 EP 5 OUT bmAttributes 2 Transfer Type Bulk Synch Type None Usage Type Data wMaxPacketSize 0x0200 1x 512 bytes\n    \n    \n    [173575.291851] usb 3-4.1: New USB device strings: Mfr=1, Product=2, SerialNumber=3 [173575.291857] usb 3-4.1: Product: iPhone [173575.291862] usb 3-4.1: Manufacturer: Apple Inc. [173575.291866] usb 3-4.1: SerialNumber: xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx [173575.407645] cdc_ncm 3-4.1:5.2: MAC-Address: xx:xx:xx:xx:xx:xx [173575.407868] cdc_ncm 3-4.1:5.2 usb0: register 'cdc_ncm' at usb-0000:08:01.0-4.1, CDC NCM (NO ZLP), xx:xx:xx:xx:xx:xx [173575.418259] cdc_ncm 3-4.1:5.2 enxxxxxxxxxxxxx: renamed from usb0\n\nOn iOS, the drivers associated to this CDC-NCM interface are\nAppleUSBDeviceNCMControl and AppleUSBDeviceNCMData.\n\nAfter that, it's only a matter of bringing up this interface, giving it an\naddress, making a DHCP server listen and iPhone will promptly send a DHCP\nrequest and start throwing packets at your Linux box.\n\n    \n    \n    sudo ip addr add dev enxxxxxxxxxxxxx 192.168.1.1/24 sudo ip link set dev enxxxxxxxxxxxxx up sudo dnsmasq -i enxxxxxxxxxxxxx -K -F 192.168.1.2,192.168.1.3\n\nSo we achieved our objective of making iOS reverse tethering work on Linux,\nright ?\n\n## iOS 16 broke my workflow\n\nTurns out that things are not so easy. Starting with iPhones running iOS 16,\nafter switching modes with usbmuxd, we see not one but two CDC-NCM\ninterfaces6.\n\nOur first assumption was that Apple began to unify their tethering and reverse\ntethering networking stacks by using CDC-NCM for both. This later turned out\nto be completely false.\n\nFurthermore, depending on the specific version of iOS and the SoC, one or both\ninterfaces made the Linux kernel unhappy in these terms:\n\n    \n    \n    [93636.679508] cdc_ncm 3-2:5.2: setting rx_max = 16384 [93636.679961] cdc_ncm 3-2:5.2: setting tx_max = 16384 [93636.681232] cdc_ncm 3-2:5.2 usb0: register 'cdc_ncm' at usb-0000:08:01.0-2, CDC NCM (NO ZLP), xxxxxxxxxxxxxxxxx [93636.712089] cdc_ncm 3-2:5.4: bind() failure [93636.714769] cdc_ncm 3-2:5.2 enxxxxxxxxxxxxx: renamed from usb0\n\nIn this case (iOS 16), one interface (5.2) was successfully recognized but the\nsecond (5.4) made the kernel error out bind() failure.\n\nThis error message happens because the interrupt endpoint used in CDC-NCM to\npass link status messages is missing. This endpoint, although mandatory in the\nspec, does not do much, so it's easy to work around the problem by patching\nthe driver7 in Linux to comment out all occurrences of the interrupt endpoint\n(dev->status).\n\nFortunately, I won't share this horrible solution with you because someone8\nwrote a much cleaner (and smaller) patch for this.\n\nHowever, after fixing the kernel driver, reverse-tethering only works on one\nof the two exposed endpoints and this other one does not respond to anything.\n\nWatching the IORegistry on an iPhone running iOS 16.7.2 gives some insight of\nwhat's happening:\n\n    \n    \n    | | +-o usb-complex@30000000 <class AppleARMIODevice, id 0x100000178, registered, matched, active, busy 0 (330 ms), retain 11> | | | +-o AppleT8011USBArbitrator <class AppleT8011USBArbitrator, id 0x100000245, registered, matched, active, busy 0 (165 ms), retain 12> | | | +-o usb-device@100000 <class AppleEmbeddedUSBNub, id 0x100000179, registered, matched, active, busy 0 (88 ms), retain 13> | | | | { [...] | | | | \"product-string\" = <\"iPhone\"> | | | | \"ncm-interrupt-ep-disabled\" = <01000000> | | | | \"device-mac-address\" = <XXXXXXXXXXX> [...] | | | +-o AppleUSBNCMControl@6 <class IOUSBDeviceInterface, id 0x100000690, registered, matched, active, busy 0 (38 ms), retain 11> | | | | +-o AppleUSBDeviceNCMControl@6 <class AppleUSBDeviceNCMControl, id 0x1000006a3, registered, matched, active, busy 0 (9 ms), retain 7> | | | | { | | | | \"CFBundleIdentifierKernel\" = \"com.apple.driver.AppleUSBDeviceNCM\" | | | | } | | | | | | | +-o AppleUSBNCMData@7 <class IOUSBDeviceInterface, id 0x100000691, registered, matched, active, busy 0 (44 ms), retain 11> | | | | +-o AppleUSBDeviceNCMData <class AppleUSBDeviceNCMData, id 0x1000006aa, registered, matched, active, busy 0 (5 ms), retain 8> | | | | +-o en2 <class IOEthernetInterface, id 0x1000006b0, registered, matched, active, busy 0 (4 ms), retain 10> | | | | | { | | | | | \"BSD Name\" = \"en2 | | | | | } | | | | | | | | | +-o IONetworkStack <class IONetworkStack, id 0x100000393, registered, matched, active, busy 0 (0 ms), retain 14> | | | | +-o IONetworkStackUserClient <class IONetworkStackUserClient, id 0x10000057d, !registered, !matched, active, busy 0, retain 5> | | | | { | | | | \"IOUserClientCreator\" = \"pid 43, configd\" | | | | \"IOUserClientDefaultLocking\" = Yes | | | | } | | | | | | | +-o AppleUSBNCMControlAux@8 <class IOUSBDeviceInterface, id 0x100000692, registered, matched, active, busy 0 (37 ms), retain 13> | | | | +-o AppleUSBDeviceNCMControl@8 <class AppleUSBDeviceNCMControl, id 0x1000006a1, registered, matched, active, busy 0 (7 ms), retain 7> | | | | { | | | | \"ncm-control-use-aux\" = <01000000> | | | | \"CFBundleIdentifierKernel\" = \"com.apple.driver.AppleUSBDeviceNCM\" | | | | } | | | | | | | +-o AppleUSBNCMDataAux@9 <class IOUSBDeviceInterface, id 0x100000693, registered, matched, active, busy 0 (43 ms), retain 13> | | | | +-o AppleUSBDeviceNCMData <class AppleUSBDeviceNCMData, id 0x10000069e, registered, matched, active, busy 0 (5 ms), retain 8> | | | | | { | | | | | \"IOClass\" = \"AppleUSBDeviceNCMData\" | | | | | \"IOActiveMedium\" = \"00100026\" | | | | | \"waitControlStart\" = 45591 | | | | | \"IOMatchedAtBoot\" = Yes | | | | | \"IOMinPacketSize\" = 64 | | | | | \"IOProviderClass\" = \"IOUSBDeviceInterface\" | | | | | \"IOLinkStatus\" = 1 | | | | | \"IOProbeScore\" = 0 | | | | | \"HiddenInterface\" = Yes | | | | | \"HostAttached\" = 0 | | | | | \"CFBundleIdentifierKernel\" = \"com.apple.driver.AppleUSBDeviceNCM\" | | | | | \"IOMACAddress\" = <XXXXXXXXXXX> | | | | | \"CFBundleIdentifier\" = \"com.apple.driver.AppleUSBDeviceNCM\" | | | | | } | | | | | | | | | +-o anpi0 <class AppleUSBDeviceNCMPrivateEthernetInterface, id 0x1000006ae, registered, matched, active, busy 0 (4 ms), retain 10> | | | | +-o IONetworkStack <class IONetworkStack, id 0x100000393, registered, matched, active, busy 0 (0 ms), retain 14> | | | | +-o IONetworkStackUserClient <class IONetworkStackUserClient, id 0x10000057d, !registered, !matched, active, busy 0, retain 5> | | | | { | | | | \"IOUserClientCreator\" = \"pid 43, configd\" | | | | \"IOUserClientDefaultLocking\" = Yes | | | | } | | | |\n\nFirst of all, by watching the usb-device node inside this output, we can\nconfirm that the absence of the interrupt descriptor is intentional because of\nthe existence of a key named ncm-interrupt-ep-disabled. This key originates\nfrom the device-tree and is not consistent across devices and versions of iOS.\n\nWe also notice that two interfaces are bound to this usb-device: the first one\nis a standard Ethernet interface (BSD interface prefixed en) that can be used\nfor reverse tethering. The second one however is handled by a new driver\nAppleUSBDeviceNCMPrivateEthernetInterface (BSD interface prefixed anpi). It is\nalso designated by the Aux suffix (and the ncm-control-use-aux property).\n\nThis driver has been in the kernel cache at least since 15.0.1, but doesn't\nseem to have really been used until iOS 17, even though it was already loaded\n(with HiddenInterface=1) on iOS 16.\n\nUntil iOS 17, there were very few explanations on what was the purpose of this\nendpoint and driver.\n\n## iOS 17 broke my mind\n\nThis endpoint is a transport medium for the RemoteXPC protocol which is\n(notably) used by XCode since iOS 17.\n\nIt turns out that, with iOS 17, Apple introduced a new way of communicating\nwith a device using this special CDC-NCM interface. The RemoteXPC protocol\nallows establishing an encrypted tunnel between the phone and a (trusted) host\ntransporting all host-phone exchanges including to services that, until then,\nused to be handled exclusively via the usbmux protocol and lockdownd.\n\nApple pushed a lot of recent protocols in this new communication stack: the\nRemoteXPC protocol itself is based on HTTP/2, all communications are happening\nover IPv6 and the tunnel is based on QUIC.\n\nIf you are looking into that topic, I suggest you have a look at the reverse-\nengineering efforts by the Duo Team9 (made as part of a research on the T2\ncoprocessor), and the documentation efforts by people from pymobiledevice10.\n\nIt turns out that the only obstacle preventing Linux users from using the\nRemoteXPC interfaces is the CDC-NCM Linux driver not supporting the missing\ninterrupt endpoint. This problem is known since 202311, but the proposed patch\nhasn't been mainlined in the kernel, yet.\n\n## Conclusion\n\nIn this article we summarized the knowledge we gathered on USB network\ninterfaces exposed by iOS while doing research to make reverse tethering work\non Linux.\n\nCoincidentally, we stumbled upon the new RemoteXPC-based communication stack\nrelying on more standard and modern transport protocols over an (almost)\nstandard tethering interface. This new stack will presumably, at some point,\nreplace the usbmux protocol.\n\nThose changes will bring some integration challenges to the Linux community:\nnot only does the CDC-NCM driver modifications need to be mainlined at some\npoint, but the question of the integration of the USB modeswitching and new\npairing/tunneling protocol introduced by iOS 17 will need to be addressed\neither in libimobiledevice, pymobiledevice or somewhere.\n\n  * 1\\. https://github.com/torvalds/linux/commits/master/drivers/net/usb/ipheth...\n  * 2\\. https://en.wikipedia.org/wiki/Ethernet_over_USB\n  * 3\\. https://real-world-systems.com/docs/configd.1.html\n  * 4\\. Intended reference to the usb_modeswitch era that existed on some WAN USB sticks. Apple kind of recycled their techniques.\n  * 5\\. https://github.com/libimobiledevice/usbmuxd/issues/205\n  * 6\\. This is seemingly not the case for iPads which still have a unique interface.\n  * 7\\. https://github.com/torvalds/linux/blob/master/drivers/net/usb/cdc_ncm.c...\n  * 8\\. https://marc.info/?l=linux-usb&m=170138175510294&w=4\n  * 9\\. https://duo.com/labs/research/apple-t2-xpc\n  * 10\\. https://github.com/doronz88/pymobiledevice3/blob/master/misc/RemoteXPC...\n  * 11\\. https://github.com/doronz88/pymobiledevice3/issues/566\n\nShare this article\n\nFacebook Twitter\n\n## Other publications\n\n### iOS: a journey in the USB networking stack\n\nIn this article, we give a small journey inside the implementation of\nnetworking interfaces exposed by iOS when connected via USB. These are used\nfor sharing a computer's connection with iPhone (tethe ...\n\nFlorian Le Minoux - 30/04/2024 - Syst\u00e8me\n\n### \ud83d\udc7b Souls without bodies, phantom types shenanigans \ud83d\udc7b\n\nIn this article, we will present strange data types that only exist in the\nrealm of types, called phantom types. We will also briefly introduce GADTs,\nand how to emulate some of their safety guarantee ...\n\nSimon Marechal - 26/04/2024 - Outils\n\n### So I became a node: exploiting bootstrap tokens in Azure Kubernetes\nService\n\nDuring one of our assessments, we managed to retrieve a Kubernetes bootstrap\ntoken from an AKS pod. It was a good opportunity to get a closer look at these\ntokens, how they work and how to exploit the ...\n\nPaul Barb\u00e9 , K\u00e9vin Schouteeten - 23/04/2024 - Pentest\n\n## Contact us\n\n+33 1 45 79 74 75\n\ncontact@synacktiv.com\n\nGPG key\n\n## PARIS\n\n5 boulevard Montmartre 75002 Paris\n\n## TOULOUSE\n\n4 Rue du Pont Guilhemery 31000 Toulouse\n\n## LYON\n\n56 rue Smith 69002 Lyon\n\n## RENNES\n\n7D Rue de Ch\u00e2tillon 35000 Rennes\n\n## LILLE\n\n7 Boulevard Louis XIV 59000 Lille\n\nCopyright \u00a9 Synacktiv 2024\n\n\u2713\n\nThanks for sharing!\n\nFacebook Twitter Email Pinterest LinkedIn Reddit WhatsApp Gmail Telegram\nPocket Mix Tumblr Amazon Wish List AOL Mail Balatarin BibSonomy Bitty Browser\nBlinklist Blogger BlogMarks Bookmarks.fr Box.net Buffer Care2 News CiteULike\nCopy Link Design Float Diary.Ru Diaspora Digg Diigo Douban Draugiem DZone\nEvernote Facebook Messenger Fark Flipboard Folkd Google Bookmarks Google\nClassroom Hacker News Hatena Houzz Instapaper Kakao Kik Push to Kindle Known\nLine LiveJournal Mail.Ru Mastodon Mendeley Meneame MeWe Mixi MySpace Netvouz\nOdnoklassniki Outlook.com Papaly Pinboard Plurk Print PrintFriendly Protopage\nBookmarks Pusha Qzone Rediff MyPage Refind Renren Sina Weibo SiteJot Skype\nSlashdot SMS StockTwits Svejo Symbaloo Bookmarks Threema Trello Tuenti Twiddla\nTypePad Post Viadeo Viber VK Wanelo WeChat WordPress Wykop XING Yahoo Mail\nYoolink Yummly\n\nAddToAny\n\nFacebook Twitter Email Pinterest LinkedIn Reddit WhatsApp Gmail\n\nEmail Gmail AOL Mail Outlook.com Yahoo Mail\n\nMore...\n\n", "frontpage": false}
