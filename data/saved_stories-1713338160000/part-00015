{"aid": "40057025", "title": "Error Checking Is Hard", "url": "https://breadchris.com/thinkies/error-checking-is-hard/", "domain": "breadchris.com", "votes": 1, "user": "breadchris", "posted_at": "2024-04-16 20:51:19", "comments": 0, "source_title": "error checking is hard", "source_text": "error checking is hard | breadchris\n\n# error checking is hard\n\nApril 16, 2024 \u00b7 2 min \u00b7 breadchris\n\nError checking is a complicated problem. It is like a garbage problem;\neveryone produces garbage, but no one wants to pick it up. Errors come from\ncode that might behave unexpectedly due to forces outside of the developer\u2019s\ncontrol. Code accepts user input, and it will do its best to make sense of it,\nbut there are scenarios where it is not possible for the code to handle the\ndata that it was given (the code does addition but gets \u201chamburger\u201d). Maybe\nthe file that was expected to be at some location isn\u2019t, what then? A naive\napproach to handling this is ceasing the execution of the program, the\nequivalent of putting your hands up and saying, \u201cfuck this shit, I\u2019m done\nhere\u201d. If your code is simple and only being used by you, this might be OK,\nbut what happens when other people want to use your code? To the code caller,\nthe panics will be set off like hidden land mines to them.\n\nIn Go, errors are treated as values rather than being thrown and caught like\nin other languages. This approach has several advantages:\n\n  * Explicit error handling: In Go, errors are returned as values and need to be handled explicitly by the caller. This forces developers to think about and address potential errors at the point where they occur rather than burying them in a try-catch block or ignoring them altogether. This helps in writing more robust and reliable code.\n\n  * Error propagation: In Go, errors are passed up the call stack as regular values would be, allowing for easy propagation of errors through function calls. This makes it easier to track where errors originate and how they are handled throughout the program.\n\n  * Clean and simple error handling: By treating errors as values, Go code tends to have clean and simple error handling mechanisms. Developers can easily check for errors using if statements and handle them in a way that makes sense for their specific use case.\n\n  * Less overhead: Because errors are not thrown and caught, there is less overhead involved in error handling in Go compared to languages that use exceptions. This can lead to better performance in error-prone code paths.\n\nOverall, treating errors as values in Go results in more explicit and concise\nerror handling, making it easier to write reliable and maintainable code.\n\n  * thinkies\n  * go\n\n\u00a9 2024 breadchris Powered by Hugo & PaperMod\n\n", "frontpage": false}
