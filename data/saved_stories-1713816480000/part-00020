{"aid": "40112568", "title": "Address Sanitizer for Bare-Metal Firmware", "url": "https://security.googleblog.com/2024/03/address-sanitizer-for-bare-metal.html", "domain": "googleblog.com", "votes": 1, "user": "minetest2048", "posted_at": "2024-04-22 09:00:31", "comments": 0, "source_title": "Address Sanitizer for Bare-metal Firmware", "source_text": "Google Online Security Blog: Address Sanitizer for Bare-metal Firmware\n\n## Security Blog\n\nThe latest news and insights from Google on security and safety on the\nInternet\n\n## Address Sanitizer for Bare-metal Firmware\n\nMarch 26, 2024\n\nPosted by Eugene Rodionov and Ivan Lozano, Android Team\n\nWith steady improvements to Android userspace and kernel security, we have\nnoticed an increasing interest from security researchers directed towards\nlower level firmware. This area has traditionally received less scrutiny, but\nis critical to device security. We have previously discussed how we have been\nprioritizing firmware security, and how to apply mitigations in a firmware\nenvironment to mitigate unknown vulnerabilities.\n\nIn this post we will show how the Kernel Address Sanitizer (KASan) can be used\nto proactively discover vulnerabilities earlier in the development lifecycle.\nDespite the narrow application implied by its name, KASan is applicable to a\nwide-range of firmware targets. Using KASan enabled builds during testing\nand/or fuzzing can help catch memory corruption vulnerabilities and stability\nissues before they land on user devices. We've already used KASan in some\nfirmware targets to proactively find and fix 40+ memory safety bugs and\nvulnerabilities, including some of critical severity.\n\nAlong with this blog post we are releasing a small project which demonstrates\nan implementation of KASan for bare-metal targets leveraging the QEMU system\nemulator. Readers can refer to this implementation for technical details while\nfollowing the blog post.\n\n### Address Sanitizer (ASan) overview\n\nAddress sanitizer is a compiler-based instrumentation tool used to identify\ninvalid memory access operations during runtime. It is capable of detecting\nthe following classes of temporal and spatial memory safety bugs:\n\n  * out-of-bounds memory access\n  * use-after-free\n  * double/invalid free\n  * use-after-return\n\nASan relies on the compiler to instrument code with dynamic checks for virtual\naddresses used in load/store operations. A separate runtime library defines\nthe instrumentation hooks for the heap memory and error reporting. For most\nuser-space targets (such as aarch64-linux-android) ASan can be enabled as\nsimply as using the -fsanitize=address compiler option for Clang due to\nexisting support of this target both in the toolchain and in the libclang_rt\nruntime.\n\nHowever, the situation is rather different for bare-metal code which is\nfrequently built with the none system targets, such as arm-none-eabi. Unlike\ntraditional user-space programs, bare-metal code running inside an embedded\nsystem often doesn\u2019t have a common runtime implementation. As such, LLVM can\u2019t\nprovide a default runtime for these environments.\n\nTo provide custom implementations for the necessary runtime routines, the\nClang toolchain exposes an interface for address sanitization through the\n-fsanitize=kernel-address compiler option. The KASan runtime routines\nimplemented in the Linux kernel serve as a great example of how to define a\nKASan runtime for targets which aren\u2019t supported by default with\n-fsanitize=address. We'll demonstrate how to use the version of address\nsanitizer originally built for the kernel on other bare-metal targets.\n\n### KASan 101\n\nLet\u2019s take a look at the KASan major building blocks from a high-level\nperspective (a thorough explanation of how ASan works under-the-hood is\nprovided in this whitepaper).\n\nThe main idea behind KASan is that every memory access operation, such as\nload/store instructions and memory copy functions (for example, memmove and\nmemcpy), are instrumented with code which performs verification of the\ndestination/source memory regions. KASan only allows the memory access\noperations which use valid memory regions. When KASan detects memory access to\na memory region which is invalid (that is, the memory has been already freed\nor access is out-of-bounds) then it reports this violation to the system.\n\nThe state of memory regions covered by KASan is maintained in a dedicated area\ncalled shadow memory. Every byte in the shadow memory corresponds to a single\nfixed-size memory region covered by KASan (typically 8-bytes) and encodes its\nstate: whether the corresponding memory region has been allocated or freed and\nhow many bytes in the memory region are accessible.\n\nTherefore, to enable KASan for a bare-metal target we would need to implement\nthe instrumentation routines which verify validity of memory regions in memory\naccess operations and report KASan violations to the system. In addition we\nwould also need to implement shadow memory management to track the state of\nmemory regions which we want to be covered with KASan.\n\n### Enabling KASan for bare-metal firmware\n\n## KASan shadow memory\n\nThe very first step in enabling KASan for firmware is to reserve a sufficient\namount of DRAM for shadow memory. This is a memory region where each byte is\nused by KASan to track the state of an 8-byte region. This means accommodating\nthe shadow memory requires a dedicated memory region equal to 1/8th the size\nof the address space covered by KASan.\n\nKASan maps every 8-byte aligned address from the DRAM region into the shadow\nmemory using the following formula:\n\nshadow_address = (target_address >> 3 ) + shadow_memory_base where\ntarget_address is the address of a 8-byte memory region which we want to cover\nwith KASan and shadow_memory_base is the base address of the shadow memory\narea.\n\n## Implement a KASan runtime\n\nOnce we have the shadow memory tracking the state of every single 8-byte\nmemory region of DRAM we need to implement the necessary runtime routines\nwhich KASan instrumentation depends on. For reference, a comprehensive list of\nruntime routines needed for KASan can be found in the linux/mm/kasan/kasan.h\nLinux kernel header. However, it might not be necessary to implement all of\nthem and in the following text we focus on the ones which were needed to\nenable KASan for our target firmware as an example.\n\n## Memory access check\n\nThe routines __asan_loadXX_noabort, __asan_storeXX_noabort perform\nverification of memory access at runtime. The symbol XX denotes size of memory\naccess and goes as a power of 2 starting from 1 up to 16. The toolchain\ninstruments every memory load and store operations with these functions so\nthat they are invoked before the memory access operation happens. These\nroutines take as input a pointer to the target memory region to check it\nagainst the shadow memory.\n\nIf the region state provided by shadow memory doesn\u2019t reveal a violation, then\nthese functions return to the caller. But if any violations (for example, the\nmemory region is accessed after it has been deallocated or there is an out-of-\nbounds access) are revealed, then these functions report the KASan violation\nby:\n\n  * Generating a call-stack.\n  * Capturing context around the memory regions.\n  * Logging the error.\n  * Aborting/crashing the system (optional)\n\n## Shadow memory management\n\nThe routine __asan_set_shadow_YY is used to poison shadow memory for a given\naddress. This routine is used by the toolchain instrumentation to update the\nstate of memory regions. For example, the KASan runtime would use this\nfunction to mark memory for local variables on the stack as\naccessible/poisoned in the epilogue/prologue of the function respectively.\n\nThis routine takes as input a target memory address and sets the corresponding\nbyte in shadow memory to the value of YY. Here is an example of some YY values\nfor shadow memory to encode state of 8-byte memory regions:\n\n  * 0x00 -- the entire 8-byte region is accessible\n  * 0x01-0x07 -- only the first bytes in the memory region are accessible\n  * 0xf1 -- not accessible: stack left red zone\n  * 0xf2 -- not accessible: stack mid red zone\n  * 0xf3 -- not accessible: stack right red zone\n  * 0xfa -- not accessible: globals red zone\n  * 0xff -- not accessible\n\n## Covering global variables\n\nThe routines __asan_register_globals, __asan_unregister_globals are used to\npoison/unpoison memory for global variables. The KASan runtime calls these\nfunctions while processing global constructors/destructors. For instance, the\nroutine __asan_register_globals is invoked for every global variable. It takes\nas an argument a pointer to a data structure which describes the target global\nvariable: the structure provides the starting address of the variable, its\nsize not including the red zone and size of the global variable with the red\nzone.\n\nThe red zone is extra padding the compiler inserts after the variable to\nincrease the likelihood of detecting an out-of-bounds memory access. Red zones\nensure there is extra space between adjacent global variables. It is the\nresponsibility of __asan_register_globals routine to mark the corresponding\nshadow memory as accessible for the variable and as poisoned for the red zone.\n\nAs the readers could infer from its name, the routine\n__asan_unregister_globals is invoked while processing global destructors and\nis intended to poison shadow memory for the target global variable. As a\nresult, any memory access to such a global will cause a KASan violation.\n\n## Memory copy functions\n\nThe KASan compiler instrumentation routines __asan_loadXX_noabort,\n__asan_storeXX_noabort discussed above are used to verify individual memory\nload and store operations such as, reading or writing an array element or\ndereferencing a pointer. However, these routines don't cover memory access in\nbulk-memory copy functions such as memcpy, memmove, and memset. In many cases\nthese functions are provided by the runtime library or implemented in assembly\nto optimize for performance.\n\nTherefore, in order to be able to catch invalid memory access in these\nfunctions, we would need to provide sanitized versions of memcpy, memmove, and\nmemset functions in our KASan implementation which would verify memory buffers\nto be valid memory regions.\n\n## Avoiding false positives for noreturn functions\n\nAnother routine required by KASan is __asan_handle_no_return, to perform\ncleanup before a noreturn function and avoid false positives on the stack.\nKASan adds red zones around stack variables at the start of each function, and\nremoves them at the end. If a function does not return normally (for example,\nin case of longjmp-like functions and exception handling), red zones must be\nremoved explicitly with __asan_handle_no_return.\n\n## Hook heap memory allocation routines\n\nBare-metal code in the vast majority of cases provides its own heap\nimplementation. It is our responsibility to implement an instrumented version\nof heap memory allocation and freeing routines which enable KASan to detect\nmemory corruption bugs on the heap.\n\nEssentially, we would need to instrument the memory allocator with the code\nwhich unpoisons KASan shadow memory corresponding to the allocated memory\nbuffer. Additionally, we may want to insert an extra poisoned red zone memory\n(which accessing would then generate a KASan violation) to the end of the\nallocated buffer to increase the likelihood of catching out-of-bounds memory\nreads/writes.\n\nSimilarly, in the memory deallocation routine (such as free) we would need to\npoison the shadow memory corresponding to the free buffer so that any\nsubsequent access (such as, use-after-free) would generate a KASan violation.\n\nWe can go even further by placing the freed memory buffer into a quarantine\ninstead of immediately returning the free memory back to the allocator. This\nway, the freed memory buffer is suspended in quarantine for some time and will\nhave its KASan shadow bytes poisoned for a longer period of time, increasing\nthe probability of catching a use-after-free access to this buffer.\n\n### Enable KASan for heap, stack and global variables\n\nWith all the necessary building blocks implemented we are ready to enable\nKASan for our bare-metal code by applying the following compiler options while\nbuilding the target with the LLVM toolchain.\n\nThe -fsanitize=kernel-address Clang option instructs the compiler to\ninstrument memory load/store operations with the KASan verification routines.\n\nWe use the -asan-mapping-offset LLVM option to indicate where we want our\nshadow memory to be located. For instance, let\u2019s assume that we would like to\ncover address range 0x40000000 - 0x4fffffff and we want to keep shadow memory\nat address 0x4A700000. So, we would use -mllvm -asan-mapping-offset=0x42700000\nas 0x40000000 >> 3 + 0x42700000 == 0x4A700000.\n\nTo cover globals and stack variables with KASan we would need to pass\nadditional options to the compiler: -mllvm -asan-stack=1 -mllvm -asan-\nglobals=1. It\u2019s worth mentioning that instrumenting both globals and stack\nvariables will likely result in an increase in size of the corresponding\nmemory which might need to be accounted for in the linker script.\n\nFinally, to prevent significant increase in size of the code section due to\nKASan instrumentation we instruct the compiler to always outline KASan checks\nusing the -mllvm -asan-instrumentation-with-call-threshold=0 option.\nOtherwise, the compiler might inline\n\n__asan_loadXX_noabort, __asan_storeXX_noabort routines for load/store\noperations resulting in bloating the generated object code.\n\nLLVM has traditionally only supported sanitizers with runtimes for specific\ntargets with predefined runtimes, however we have upstreamed LLVM sanitizer\nsupport for bare-metal targets under the assumption that the runtime can be\ndefined for the particular target. You\u2019ll need the latest version of Clang to\nbenefit from this.\n\n### Conclusion\n\nFollowing these steps we managed to enable KASan for a firmware target and use\nit in pre-production test builds. This led to early discovery of memory\ncorruption issues that were easily remediated due to the actionable reports\nproduced by KASan. These builds can be used with fuzzers to detect edge case\nbugs that normal testing fails to trigger, yet which can have significant\nsecurity implications.\n\nOur work with KASan is just one example of the multiple techniques the Android\nteam is exploring to further secure bare-metal firmware in the Android\nPlatform. Ideally we want to avoid introducing memory safety vulnerabilities\nin the first place so we are working to address this problem through adoption\nof memory-safe Rust in bare-metal environments. The Android team has developed\nRust training which covers bare-metal Rust extensively. We highly encourage\nothers to explore Rust (or other memory-safe languages) as an alternative to\nC/C++ in their firmware.\n\nIf you have any questions, please reach out \u2013 we\u2019re here to help!\n\nAcknowledgements: Thank you to Roger Piqueras Jover for contributions to this\npost, and to Evgenii Stepanov for upstreaming LLVM support for bare-metal\nsanitizers. Special thanks also to our colleagues who contribute and support\nour firmware security efforts: Sami Tolvanen, Stephan Somogyi, Stephan Chen,\nDominik Maier, Xuan Xing, Farzan Karimi, Pirama Arumuga Nainar, Stephen Hines.\n\nGoogle\n\nLabels: android , android security\n\n#### No comments :\n\nPost a Comment\n\n## Labels\n\n  * #sharethemicincyber\n  * #supplychain #security #opensource\n  * android\n  * android security\n  * android tr\n  * app security\n  * big data\n  * biometrics\n  * blackhat\n  * C++\n  * chrome\n  * chrome enterprise\n  * chrome security\n  * connected devices\n  * CTF\n  * diversity\n  * encryption\n  * federated learning\n  * fuzzing\n  * Gboard\n  * google play\n  * google play protect\n  * hacking\n  * interoperability\n  * iot security\n  * kubernetes\n  * linux kernel\n  * memory safety\n  * Open Source\n  * pha family highlights\n  * pixel\n  * privacy\n  * private compute core\n  * Rowhammer\n  * rust\n  * Security\n  * security rewards program\n  * sigstore\n  * spyware\n  * supply chain\n  * targeted spyware\n  * tensor\n  * Titan M2\n  * VDP\n  * vulnerabilities\n  * workshop\n\n## Archive\n\n  * 2024\n\n    * Jan\n\n    * Feb\n\n    * Mar\n\n    * Apr\n\n  * 2023\n\n    * Jan\n\n    * Feb\n\n    * Mar\n\n    * Apr\n\n    * May\n\n    * Jun\n\n    * Jul\n\n    * Aug\n\n    * Sep\n\n    * Oct\n\n    * Nov\n\n    * Dec\n\n  * 2022\n\n    * Jan\n\n    * Feb\n\n    * Mar\n\n    * Apr\n\n    * May\n\n    * Jun\n\n    * Jul\n\n    * Aug\n\n    * Sep\n\n    * Oct\n\n    * Nov\n\n    * Dec\n\n  * 2021\n\n    * Jan\n\n    * Feb\n\n    * Mar\n\n    * Apr\n\n    * May\n\n    * Jun\n\n    * Jul\n\n    * Aug\n\n    * Sep\n\n    * Oct\n\n    * Nov\n\n    * Dec\n\n  * 2020\n\n    * Jan\n\n    * Feb\n\n    * Mar\n\n    * Apr\n\n    * May\n\n    * Jun\n\n    * Jul\n\n    * Aug\n\n    * Sep\n\n    * Oct\n\n    * Nov\n\n    * Dec\n\n  * 2019\n\n    * Jan\n\n    * Feb\n\n    * Mar\n\n    * Apr\n\n    * May\n\n    * Jun\n\n    * Jul\n\n    * Aug\n\n    * Sep\n\n    * Oct\n\n    * Nov\n\n    * Dec\n\n  * 2018\n\n    * Jan\n\n    * Feb\n\n    * Mar\n\n    * Apr\n\n    * May\n\n    * Jun\n\n    * Jul\n\n    * Aug\n\n    * Sep\n\n    * Oct\n\n    * Nov\n\n    * Dec\n\n  * 2017\n\n    * Jan\n\n    * Feb\n\n    * Mar\n\n    * Apr\n\n    * May\n\n    * Jun\n\n    * Jul\n\n    * Sep\n\n    * Oct\n\n    * Nov\n\n    * Dec\n\n  * 2016\n\n    * Jan\n\n    * Feb\n\n    * Mar\n\n    * Apr\n\n    * May\n\n    * Jun\n\n    * Jul\n\n    * Aug\n\n    * Sep\n\n    * Oct\n\n    * Nov\n\n    * Dec\n\n  * 2015\n\n    * Jan\n\n    * Feb\n\n    * Mar\n\n    * Apr\n\n    * May\n\n    * Jun\n\n    * Jul\n\n    * Aug\n\n    * Sep\n\n    * Oct\n\n    * Nov\n\n    * Dec\n\n  * 2014\n\n    * Jan\n\n    * Feb\n\n    * Mar\n\n    * Apr\n\n    * Jun\n\n    * Jul\n\n    * Aug\n\n    * Sep\n\n    * Oct\n\n    * Nov\n\n    * Dec\n\n  * 2013\n\n    * Jan\n\n    * Feb\n\n    * Mar\n\n    * Apr\n\n    * May\n\n    * Jun\n\n    * Aug\n\n    * Oct\n\n    * Nov\n\n    * Dec\n\n  * 2012\n\n    * Jan\n\n    * Feb\n\n    * Mar\n\n    * Apr\n\n    * May\n\n    * Jun\n\n    * Aug\n\n    * Sep\n\n    * Dec\n\n  * 2011\n\n    * Feb\n\n    * Mar\n\n    * Apr\n\n    * May\n\n    * Jun\n\n    * Jul\n\n    * Aug\n\n    * Sep\n\n    * Oct\n\n    * Nov\n\n    * Dec\n\n  * 2010\n\n    * Mar\n\n    * Apr\n\n    * May\n\n    * Jul\n\n    * Aug\n\n    * Sep\n\n    * Oct\n\n    * Nov\n\n  * 2009\n\n    * Mar\n\n    * Jun\n\n    * Jul\n\n    * Aug\n\n    * Oct\n\n    * Nov\n\n  * 2008\n\n    * Feb\n\n    * May\n\n    * Jul\n\n    * Aug\n\n    * Oct\n\n    * Nov\n\n    * Dec\n\n  * 2007\n\n    * May\n\n    * Jun\n\n    * Jul\n\n    * Sep\n\n    * Oct\n\n    * Nov\n\n## Feed\n\nFollow\n\nGive us feedback in our Product Forums.\n\n  * Google\n  * Privacy\n  * Terms\n\nDiese Website verwendet Cookies von Google, um Dienste anzubieten und Zugriffe\nzu analysieren. Deine IP-Adresse und dein User-Agent werden zusammen mit\nMesswerten zur Leistung und Sicherheit f\u00fcr Google freigegeben. So k\u00f6nnen\nNutzungsstatistiken generiert, Missbrauchsf\u00e4lle erkannt und behoben und die\nQualit\u00e4t des Dienstes gew\u00e4hrleistet werden.Weitere InformationenOk\n\n", "frontpage": false}
