{"aid": "40131050", "title": "Building a Magical 3D Button with CSS", "url": "https://www.joshwcomeau.com/animation/3d-button/", "domain": "joshwcomeau.com", "votes": 2, "user": "yothisisyo", "posted_at": "2024-04-23 12:17:01", "comments": 0, "source_title": "Building a Magical 3D Button", "source_text": "Building a Magical 3D button with HTML and CSS\n\nSkip to content\n\nJoshWComeau\n\nHomeTutorialsAnimation\n\n# Building a Magical 3D Button\n\nBet you can't click just once!\n\n## Introduction\n\nI had a neat realization recently: Buttons are the \u201ckiller feature\u201d of the\nweb.\n\nEvery significant thing we do online, from ordering food to scheduling an\nappointment to playing a video, involves pressing a button. Buttons (and the\nforms they submit) make the web dynamic and interactive and powerful.\n\nBut so many of those buttons are lackluster. They can trigger enormous changes\nin the real world, but they don't feel tangible at all. The feel like dull\neveryday pixels.\n\nIn this tutorial, we'll build a whimsical 3D button:\n\nIntended audience\n\nThis is an intermediate-level tutorial for front-end developers. It's focused\non HTML/CSS, no JavaScript knowledge required.\n\nIf you're relatively new to CSS transitions, I'd recommend reading \u201cAn\nInteractive Guide to CSS Transitions\u201d first.\n\n##\n\nLink to this heading\n\nOur strategy\n\nThere's one main trick we'll use a couple times in this tutorial to create the\nillusion of a 3D button.\n\nHere's how it works: when the user interacts with our button, we'll slide a\nforeground layer up and down, in front of a stationary background:\n\n0\n\n(Try sliding the \"Reveal\" slider, and then interacting with the button!)\n\nWhy not use box-shadow or border? Those properties are super expensive to\nanimate. If we want a buttery-smooth transition on the button, we'll have way\nmore success with this strategy.\n\nHere's our MVP button in code:\n\n### Code Playground\n\nHTML\n\nResult\n\nEnable \u2018tab\u2019 key\n\nOur button element provides the burgundy background color that simulates the\nbottom edge of our button. We also strip away the default border/padding that\ncomes with button elements.\n\n.front is our foreground layer. it gets a bright pink-crimson background\ncolor, as well as some text styles.\n\nWe'll slide the foreground layer around with transform: translate. This is the\nbest way to accomplish this effect, since transforms can be hardware-\naccelerated.\n\nWhile the mouse is held down on the button, the :active styles will apply.\nWe'll shift the front layer down so that it sits 2px above the bottom. We\ncould drop it to 0px, but I want to keep the 3D illusion going at all times.\n\n##\n\nLink to this heading\n\nThe details\n\nWe've created a solid foundation, and now it's time to build some cool stuff\non top of it!\n\n###\n\nLink to this heading\n\nFocus outlines\n\nMost browsers will add an outline to a button when it's clicked, to indicate\nthat the element has captured focus.\n\nHere's what this looks like by default, on Chrome / MacOS:\n\nIn the MVP above, I took the liberty of adding an outline-offset declaration.\nThis property gives our button a bit of a buffer:\n\n    \n    \n    css\n    \n    \n    .pushable {\n    \n    outline-offset: 4px;\n    \n    }\n\nThis is a dramatic improvement, but it's still a bit of an eyesore. Plus, it\ndoesn't work consistently: on Firefox, outline-offset doesn't work for the\ndefault \"focus\" outlines.\n\nWe can't simply remove it, though\u2014that outline is super important for folks\nwho navigate using their keyboard. They rely on it to let them know which\nelement is focused.\n\nFortunately, we can use a swanky CSS pseudo-class to help us out: :focus-\nvisible\n\n### Code Playground\n\nResult\n\nEnable \u2018tab\u2019 key\n\nThat's one heck of a selector, so let's break it down.\n\nThe :focus pseudo-class will apply its declarations when an element is\nfocused. This works regardless of whether the element is focused by tabbing to\nit on the keyboard, or by clicking it with a mouse.\n\n:focus-visible is similar, but it only applies when the element is focused and\nthe user would benefit from seeing a visual focus indicator (because they're\nusing a keyboard to navigate, for example).\n\nFinally, :not allows us to mix in some logic. The styles will apply when the\nelement matches the :focus selector, but not the :focus-visible selector. In\npractical terms, this means that we'll hide the outline when the button is\nfocused and the user is using a pointer device (eg. a mouse, a trackpad, a\nfinger on a touchscreen).\n\nBrowser support and accessibility\n\nI'll be honest about it: the rule above is pretty confusing!\n\nIs there a clearer way we could accomplish the same effect? What if we wrote\nit like this instead?\n\n    \n    \n    css\n    \n    \n    button {\n    \n    outline: none;\n    \n    }\n    \n    button:focus-visible {\n    \n    outline: revert;\n    \n    }\n\nrevert is a special keyword that will revert back to whatever the value ought\nto be, based on the browser's defaults. In Chrome on MacOS, this equates to a\nsolid blue line.\n\nIt's simpler, right? We're saying \u201cHide the outline, except when visibly\nfocused\u201d.\n\nUnfortunately, however, this alternative method has a problem: it doesn't work\nin older browsers.\n\nClicking and focus\n\nIn most browsers, clicking a button will focus it. Depending on your browser\nand operating system, however, this might not be true for you!\n\nMDN has a great writeup that covers how different browsers behave when\nclicking buttons.\n\nAdditionally, in Safari, buttons can be focused via \u201cOption + Tab\u201d. In other\nbrowsers, the \u201cTab\u201d key alone is sufficient.\n\n###\n\nLink to this heading\n\nA hover state\n\nSo, in real life, buttons don't rise up to meet your finger before you press\non it.\n\nBut wouldn't it be cool if they did?\n\nLet's shift the button up by a few pixels when they hover. Also, let's slap a\ntransition on the front layer. This will animate the state changes, producing\na more fluid interaction.\n\n### Code Playground\n\nResult\n\nEnable \u2018tab\u2019 key\n\nI add the will-change: transform declaration so that this animation can be\nhardware-accelerated. This topic is covered in my Introduction to CSS\nTransitions.\n\n###\n\nLink to this heading\n\nInjecting personality\n\nWith a blanket transition: transform 250ms, we've given our button an\nanimation, but it still doesn't have much in the way of .\n\nLet's consider the different actions that can be performed on this button:\n\n  * It can be pressed\n\n  * It can be released\n\n  * It can be hovered\n\n  * It can be departed from (when the user mouses away)\n\nShould each of these actions share the same characteristics? I don't think so.\nI want the button to snap down quickly when clicked, and I want it to bounce\nback when released. When the cursor wanders away, I want it to sink back to\nits natural position at a glacial pace.\n\nHere's what that looks like. Try interacting with the button to see the\ndifference:\n\n### Code Playground\n\nResult\n\nEnable \u2018tab\u2019 key\n\nWe can set overrides for each state, to change how the animation behaves. In\naddition to picking different speeds, we can also change the timing functions!\n\nOur default transition, inside .front, is applied when the mouse leaves the\nbutton. It's our \"return to equilibrium\" transition. I've given it a leisurely\nduration of 600ms\u2014an eternity when it comes to micro-interactions. I've also\ngiven it a custom easing curve, via cubic-bezier.\n\nI'll be writing more about cubic B\u00e9zier curves soon. In essence, they let us\ncreate our own timing curve. This is a lower-level tool that gives us a ton of\ncontrol.\n\nIn the case of our \u201cequilibrium\u201d curve, it's essentially a more-aggressive\nease-out:\n\nWhen we press down on the button, we switch to our :active transition. I've\nchosen a lightning-quick transition time of 34ms\u2014roughly 2 frames at 60fps. I\nwant this one to be speedy, since this is how people tend to press buttons in\nreal life!\n\nFinally, our :hover transition. This state tackles two separate actions:\n\n  * The rise-up when mousing over the button\n\n  * The snap-back after releasing the button\n\nIdeally, I would pick different transitions for each of these actions, but it\nisn't possible in pure CSS. If I really wanted to go the extra mile, I'd need\nto write some JS to disambiguate between these states.\n\nI've crafted a \"springy\" B\u00e9zier curve that overshoots a little bit. This gives\nthe button a ton more personality. Here's what this curve looks like:\n\nUltimately, B\u00e9zier curves will never look quite as lush as spring physics, but\nthey can get pretty close with enough tinkering!\n\n###\n\nLink to this heading\n\nAdding a shadow\n\nTo really sell the whole \u201c3D\u201d thing, we can add a shadow:\n\nYou may be tempted to reach for box-shadow to accomplish this, but we'll have\nmuch more success by repeating a trick we saw earlier. Our shadow will be a\nseparate layer, and it'll move in the opposite direction of our front layer.\n\n0\n\nIn order for this to work, we'll need to restructure things a bit. Here's the\nmarkup for our new setup:\n\n    \n    \n    html\n    \n    \n    <button>\n    \n    <span class=\"shadow\"></span>\n    \n    <span class=\"edge\"></span>\n    \n    <span class=\"front\">Push Me</span>\n    \n    </button>\n\nBefore, we were using the <button> itself as our edge layer. Now, though, we\nneed a shadow to sit below it. Our <button> will become a wrapper, holding 3\nlayers stacked one on top of the other.\n\nHere's the CSS, with some stuff removed for brevity:\n\n### Code Playground\n\nResult\n\nEnable \u2018tab\u2019 key\n\nIn order to stack HTML elements, we use absolute positioning. The final layer,\n.front, uses relative positioning, since we need 1 in-flow child to give the\n<button> its width and height.\n\nWe can rely purely on DOM order; no z-index required to control the stacking\norder!\n\nIn terms of how to set the translate: our shadow moves in the opposite\ndirection from our front layer. The shadow doesn't quite move as far from the\nbaseline position: While .front moves up by 6px, .shadow only moves down by\n4px. This is a subjective choice;you might prefer different values.\nExperimentation is encouraged!\n\nWe can also add a bit of blurring, for a softer, more natural shadow:\n\n50\n\nThis can be accomplished with the blur filter:\n\n    \n    \n    css\n    \n    \n    .shadow {\n    \n    filter: blur(4px);\n    \n    }\n\n###\n\nLink to this heading\n\nColor and aesthetics\n\nWe're just about there, but we can do two more small things to complete the\neffect.\n\nThis first one is super subtle, but really satisfying. I apply a linear\ngradient to the \"edge\" element, to make it seem like the rounded corners are\nreflecting less light:\n\nHere's the CSS for this bit:\n\n    \n    \n    css\n    \n    \n    .edge {\n    \n    background: linear-gradient(\n    \n    to left,\n    \n    hsl(340deg 100% 16%) 0%,\n    \n    hsl(340deg 100% 32%) 8%,\n    \n    hsl(340deg 100% 32%) 92%,\n    \n    hsl(340deg 100% 16%) 100%\n    \n    );\n    \n    }\n\nWe're almost there \u2014 let's toss a cherry onto this sundae and call it a day.\n\nThe last little detail is an additional hover effect:\n\nOn hover, the button brightens. Both layers get lighter.\n\nHow should we tackle this? We could switch out the colors, but that gets a bit\ncomplicated because of the gradient we just added. Fortunately, we can\nleverage another CSS filter: brightness.\n\n    \n    \n    css\n    \n    \n    .pushable {\n    \n    transition: filter 600ms;\n    \n    }\n    \n    .pushable:hover {\n    \n    transition: filter 250ms;\n    \n    filter: brightness(110%);\n    \n    }\n\nOn hover, the button gets 10% brighter. This affects all 3 layers. filter is a\nsurprisingly performant property to animate, so we won't be stressing out the\nhardware too much.\n\n###\n\nLink to this heading\n\nMobile enhancements\n\nWhen tapping an interactive element on mobile devices, the browser will flash\na \"tap rectangle\" on top:\n\nNotice the grey rectangle that flashes quickly? The color varies between iOS\nand Android, but the effect is constant.\n\nWhy does it do this? Well, the box can serve as helpful feedback, to confirm\nthat you've successfully tapped the target. But our button offers plenty of\nfeedback as-is, so we don't need it in this case.\n\nWe can remove it with this declaration:\n\n    \n    \n    css\n    \n    \n    .pushable {\n    \n    -webkit-tap-highlight-color: transparent;\n    \n    }\n\nOne more thing: on iOS, if the button is held down for a second, the phone\nwill try and select the text within the button:\n\nLet's make the button unselectable, to improve this situation:\n\n    \n    \n    css\n    \n    \n    .pushable {\n    \n    user-select: none;\n    \n    }\n\nWith great power comes great responsibility. We should exercise great caution\nwhen disabling browser features meant to improve usability! In this case, I\nfeel pretty confident that we are improving the experience, not degrading it,\nbut these properties should be used extremely rarely.\n\n##\n\nLink to this heading\n\nStarted from the button now we here\n\nIt's been quite a journey, but I hope you'll agree that we've built a very\nsatisfying button.\n\nIt's also very ostentatious; you probably want to be pretty selective about\nwhere you use this sort of button. I wouldn't use this button for a GDPR\ncookie-consent banner! But for grand and exciting actions, you now have a\nbutton that matches \ud83c\udf89\n\nIf you're interested in leveling-up your CSS skills, I recently launched a\ncourse! It's specifically tailored for JS devs. If you work with a framework\nlike React or Vue and you don't feel super comfortable with CSS, my mission\nthis year is to change that. It's called CSS for JavaScript Developers, and\nyou can learn more at css-for-js.dev.\n\n\u2728 Here's the final source code for our big pushable button:\n\n    \n    \n    html\n    \n    \n    <style>\n    \n    .pushable {\n    \n    position: relative;\n    \n    border: none;\n    \n    background: transparent;\n    \n    padding: 0;\n    \n    cursor: pointer;\n    \n    outline-offset: 4px;\n    \n    transition: filter 250ms;\n    \n    }\n    \n    .shadow {\n    \n    position: absolute;\n    \n    top: 0;\n    \n    left: 0;\n    \n    width: 100%;\n    \n    height: 100%;\n    \n    border-radius: 12px;\n    \n    background: hsl(0deg 0% 0% / 0.25);\n    \n    will-change: transform;\n    \n    transform: translateY(2px);\n    \n    transition:\n    \n    transform\n    \n    600ms\n    \n    cubic-bezier(.3, .7, .4, 1);\n    \n    }\n    \n    .edge {\n    \n    position: absolute;\n    \n    top: 0;\n    \n    left: 0;\n    \n    width: 100%;\n    \n    height: 100%;\n    \n    border-radius: 12px;\n    \n    background: linear-gradient(\n    \n    to left,\n    \n    hsl(340deg 100% 16%) 0%,\n    \n    hsl(340deg 100% 32%) 8%,\n    \n    hsl(340deg 100% 32%) 92%,\n    \n    hsl(340deg 100% 16%) 100%\n    \n    );\n    \n    }\n    \n    .front {\n    \n    display: block;\n    \n    position: relative;\n    \n    padding: 12px 42px;\n    \n    border-radius: 12px;\n    \n    font-size: 1.25rem;\n    \n    color: white;\n    \n    background: hsl(345deg 100% 47%);\n    \n    will-change: transform;\n    \n    transform: translateY(-4px);\n    \n    transition:\n    \n    transform\n    \n    600ms\n    \n    cubic-bezier(.3, .7, .4, 1);\n    \n    }\n    \n    .pushable:hover {\n    \n    filter: brightness(110%);\n    \n    }\n    \n    .pushable:hover .front {\n    \n    transform: translateY(-6px);\n    \n    transition:\n    \n    transform\n    \n    250ms\n    \n    cubic-bezier(.3, .7, .4, 1.5);\n    \n    }\n    \n    .pushable:active .front {\n    \n    transform: translateY(-2px);\n    \n    transition: transform 34ms;\n    \n    }\n    \n    .pushable:hover .shadow {\n    \n    transform: translateY(4px);\n    \n    transition:\n    \n    transform\n    \n    250ms\n    \n    cubic-bezier(.3, .7, .4, 1.5);\n    \n    }\n    \n    .pushable:active .shadow {\n    \n    transform: translateY(1px);\n    \n    transition: transform 34ms;\n    \n    }\n    \n    .pushable:focus:not(:focus-visible) {\n    \n    outline: none;\n    \n    }\n    \n    </style>\n    \n    <button class=\"pushable\">\n    \n    <span class=\"shadow\"></span>\n    \n    <span class=\"edge\"></span>\n    \n    <span class=\"front\">\n    \n    Push me\n    \n    </span>\n    \n    </button>\n\n### Last Updated\n\nJanuary 1st, 2022\n\n### Hits\n\n## A front-end web development newsletter that sparks joy\n\nMy goal with this blog is to create helpful content for front-end web devs,\nand my newsletter is no different! I'll let you know when I publish new\ncontent, and I'll even share exclusive newsletter-only content now and then.\n\nNo spam, unsubscribe at any time.\n\nJoshWComeau\n\nThanks for reading!\n\n\u00a9 2020-present Joshua Comeau. All Rights Reserved.\n\nTutorials\n\nReactAnimationCSSCareerJavaScriptNext.jsPerformance\n\nLinks\n\nTwitterContactTerms of UsePrivacy Policy\n\n\u00a9 2020-present Joshua Comeau. All Rights Reserved.\n\n", "frontpage": false}
