{"aid": "40264337", "title": "A History of C Compilers \u2013 Part 1: Performance, Portability and Freedom", "url": "https://thechipletter.substack.com/p/a-history-of-c-compilers-part-1-performance", "domain": "thechipletter.substack.com", "votes": 12, "user": "gulced", "posted_at": "2024-05-05 12:28:30", "comments": 0, "source_title": "Freedom and Portability", "source_text": "Freedom and Portability - by Babbage - The Chip Letter\n\n# The Chip Letter\n\nShare this post\n\n#### A History of C Compilers - Part 1: Performance, Portability and Freedom\n\nthechipletter.substack.com\n\n# A History of C Compilers - Part 1: Performance, Portability and Freedom\n\n### The first part of a whistle stop tour of the history of C compilers. Also\nGNU/Linux, dragons and lots of architectures!\n\nBabbage\n\nMay 05, 2024\n\n\u2219 Paid\n\n4\n\nShare this post\n\n#### A History of C Compilers - Part 1: Performance, Portability and Freedom\n\nthechipletter.substack.com\n\n2\n\nShare\n\n> The economic advantages of portability are very great. In many segments of\n> the computer industry, the dominant cost is development and maintenance of\n> software.\n>\n> Dennis Ritchie and Stephen Johnson 1978\n\n> ... many insist that C is the programming language and that it will last\n> forever.\n>\n> Byte Magazine 1983\n\nThe August 1983 issue of Byte Magazine devoted its cover, and a large part of\nits editorial content, to the C programming language. After an introduction to\nC, co-authored by Brian Kernighan of K&R fame, Byte reviewed as many as 20 C\ncompilers - programs to turn C language code into \u2018executable programs\u2019 that\ncould be run on the IBM PC or personal computers running the CP/M or CP/M-86\noperating systems.\n\nThat same year, MIT\u2019s Richard Stallman approached Andrew Tanenbaum for\npermission to use the 'Free University Compiler Kit' (better known as the\n'Amsterdam Compiler Kit') as the C compiler for his planned GNU (\u2018GNU\u2019s Not\nUnix\u2019) operating system. Stallman's GNU would be 'Free as in Freedom'\nsoftware. However, Tanenbaum's compiler was only 'Free as in the Free\nUniversity of Amsterdam' and so deemed unsuitable by Stallman for GNU.\n\nSo Stallman set about creating his own \u201cfree software\u201d C compiler. The first\nversion, 0.9, was released to the world as a download from MIT in March 1987.\n\nForty years after that Byte issue, C remains an essential language and will\ncontinue to be so for the foreseeable future. If anything this illustration\nfrom Wikipedia, designed to show the pervasiveness of C, understates how\nwidely used it is. C, and its object-oriented derivative, C++ are everywhere!\n\nSome software written in C - By \u041c\u0430\u043a\u0441\u0438\u043c \u041f\u0435 - Own work, CC BY-SA 4.0,\nhttps://commons.wikimedia.org/w/index.php?curid=109712425\n\nThe compilers that Byte discussed, though, have mostly disappeared, along with\nthe companies that made them. By contrast, Stallman's compiler, now known as\nGCC for the 'GNU Compiler Collection', and a more recent open-source compiler\necosystem - LLVM / Clang - are pervasive. Other compilers, including important\nproprietary compilers from Microsoft and Intel, are available, but none can\nmatch GCC and LLVM's broad reach - in architectures, operating systems, and\nlanguages - and utility.\n\nAs we've seen, after a period of relative stability, or perhaps stagnation, in\ncomputer architecture, we are now living through a period of much greater\ncompetition and innovation. Arm is challenging x86, and RISC-V in turn is\nchallenging Arm. GPUs and a wide range of AI-focused Application Specific\nIntegrated Circuits (ASICs), such as Google's TPUs, are becoming key pieces of\nhardware in the data center and elsewhere.\n\nBut none of this hardware innovation would be useful without software. Almost\nall other software for these new architectures, from operating systems to\nmachine learning tools, depends on having available performant compilers for\nC, C++, and more specialized C-like languages, such as that used for GPU\nkernels in Nvidia\u2019s CUDA. So now is a good point to look at the history of the\ncompiler and to try to understand what has shaped the development of these\nvital tools.\n\nNote that this is a free post with additional material including further\nreading at the end of the post for premium subscribers.\n\nThe Chip Letter is a reader-supported publication. To support my work, please\nconsider becoming a free or paid subscriber.\n\n####\n\nGrace Hopper's non-compiler 'compiler', Manchester 'Autocodes', and early\nmainframe compilers.\n\nGrace Hopper coined the term 'compiler' but used it for a piece of software\nthat would today be called a linker and loader.\n\nThe first compiler, in the modern sense of the term, was written at the\nUniversity of Manchester in the UK by Alick Glennie for the Manchester Mark 1\ncomputer. This was a compiler for one of the Manchester 'Autocodes' or, as we\nwould now say, programming languages - see a sample of Glennie\u2019s first\nAutocode below.\n\n    \n    \n    c@VA t@IC x@1\u20442C y@RC z@NC INTEGERS +5 \u2192c # Put 5 into c \u2192t # Load argument from lower accumulator # to variable t +t TESTA Z # Put |t| into lower accumulator -t ENTRY Z SUBROUTINE 6 \u2192z # Run square root subroutine on # lower accumulator value # and put the result into z +tt \u2192y \u2192x # Calculate t^3 and put it into x +tx \u2192y \u2192x +z+cx CLOSE WRITE 1 # Put z + (c * x) into # lower accumulator # and return\n\nFORTRAN is the first compiled 'high-level' language that is still in\nwidespread use today. The language was developed under the supervision of John\nBackus who delivered the first FORTRAN compiler, for the IBM 704 mainframe, in\n1957 after a three-year development project.\n\nAs an aside, some indication of the challenges around compiler construction in\nthis era can be gained from the approach taken by the FORTRAN compiler for the\nIBM 1401 (announced in 1959) which needed 63 passes to compile a program.\n\n> FORTRAN was provided for the IBM 1401 by an innovative 63-pass compiler that\n> ran in only 8k of core. It kept the program in memory and loaded overlays\n> that gradually transformed it, in place, into executable form, ... The\n> executable form was not machine language; rather it was interpreted ...\n\nIn this era, most new machines came with new architectures. Mainframes were\nhugely expensive - even large firms would sometimes rent rather than buy their\nmachine. Compilers would usually be made available for free or bundled in with\nhardware sales. In these circumstances why would anyone try to create a\nFORTRAN or COBOL compiler that would compete with, say, IBM's?\n\n####\n\nMinicomputers, Unix, and C\n\nThe wider availability of lower-cost minicomputers from companies such as DEC\nin the later 1960s and early 1970s created new opportunities for the\ndevelopment of operating systems, computer languages, and their compilers by\nthird parties. The DEC PDP-11 alone had several dozen operating systems\nwritten for it.\n\nThe most famous and consequential example of third-party software for the\nPDP-11 was the development of the Unix operating system and the C programming\nlanguage at Bell Labs. Unix was originally written in PDP-11 assembly\nlanguage, but seeking greater portability, in 1972 Dennis Ritchie developed\nthe C language (a development of B which in turn was a development of BCPL)\nand a compiler for his new language and then rewrote Unix in C.\n\n####\n\nThe Portable C Compiler\n\nRitchie's C compiler was written for the DEC PDP-11 but soon made its way onto\nother machines. According to Ritchie and Stephen Johnson:\n\n> C was developed for the PDP-11 on the UNIX system in 1972. Portability was\n> not an explicit goal in its design, even though limitations in the\n> underlying machine model assumed by the predecessors of C made us well aware\n> that not all machines were the same. Less than a year later, C was also\n> running on the Honeywell 6000 system at Murray Hill. Shortly thereafter, it\n> was made available on the IBM 370 series machines as well. The compiler for\n> the Honeywell was a new product but the IBM compiler was adapted from the\n> PDP-11 version, as were compilers for several other machines.\n\nAlthough the original PDP-11 compiler was adapted for other machines it was\nnot ideally suited for porting. A few years later, the 'Portable C Compiler'\n(or 'pcc') was written by Johnson, also at Bell Labs, which would provide a C\ncompiler for Unix that made this adaptation much easier. It was quickly ported\nto a range of other machines. Quoting Johnson:\n\n> To summarize, however, if you need a C compiler written for a machine with a\n> reasonable architecture, the compiler is already three-quarters finished!\n\n> A large fraction of the machine-dependent code can be converted in a\n> straightforward, almost mechanical way.\n\nJohnson's pcc was used as the C Compiler in Seventh Edition Unix (Version 7\nUnix) in 1979. Before long Johnson and Ritchie could report that pcc:\n\n> is now in use on the IBM System/370 under both OS and TSS, the Honeywell\n> 6000, the Interdata 8/32, the SEL86 the Data General Nova and Eclipse, the\n> DEC VAX-11/780, and a Bell System processor.\n\nThe portability of pcc was a key in enabling Unix itself to be ported to new\nmachines. The first machine for which this task was undertaken was another\nminicomputer, the Interdata 8/32, which was notable for being the first\nminicomputer priced under $10,000. Porting of Unix with pcc to the Interdata\nmachine went relatively smoothly:\n\n> In about six months, we have been able to move the UNIX operating system and\n> much of its software from its original host, the PDP11, to another, rather\n> different machine, the Interdata 8/32. The standard of portability achieved\n> is fairly high for such an ambitious project: the operating system (outside\n> of device drivers and assembly language primitives) is about 95 percent\n> unchanged between the two systems; inherently machine-dependent software\n> such as the compiler, assembler, loader, and debugger are 75 to 80 percent\n> unchanged; other user-level software (amounting to about 20,000 lines so\n> far) is identical, with few exceptions, on the two machines.\n\nLater, the portability of pcc enabled Version 7 Unix and its derivatives to be\nported to a wide range of the new 16-bit microprocessor architectures,\nincluding the Motorola 68000 (e.g. the first Sun Workstations), the Intel 8086\n(including Xenix) the Zilog Z8000, and more.\n\nA repository of the code of pcc is available today for inspection on GitHub\n(see further reading at the end of this post) and can produce code for sixteen\narchitectures ranging from the PDP-11 and Data General Nova from the 1960s and\nearly 1970s, all the way to modern 64-bit x86 (AMD64).\n\n####\n\nTwo Books - K&R and the Dragon\n\nThe first Unix, Ritchie's C compiler, and pcc were initially proprietary\nsoftware, with the rights owned by Bell Labs. The story of Unix, and the\ntortuous disputes around it, is for another time. It's worth noting though\nthat the C language itself was not subject to copyright or other intellectual\nproperty restrictions. It was soon well known, in large part through Kernighan\nand Ritchie's famous 1978 book, 'The C Programming Language'.\n\nThe year before that Alfred Aho and Jeffrey Ullman (both of whom also worked\nat Bell Labs for a time) published the book Principles of Compiler Design. The\nbook would become known as the \u2018Green Dragon Book\u2019 as it featured a cartoon of\na medieval knight on a horse battling a green dragon labeled \u2018Complexity of\nCompiler Design\u2019. According to the introduction to the book, its purpose was:\n\n> to acquaint the reader with the basic constructs of modern programming\n> languages and to show how they can be efficiently implemented in the machine\n> language of a typical computer.\n\nIn addition to teaching the theory behind compiler design, the book also looks\nbriefly at some then-current \u2018real world\u2019 compilers, noting that by 1977:\n\n> C compilers exist for a number of machines, including the [Dennis Ritchie\u2019s\n> for the] PDP-11, [and Stephen Johnson\u2019s for] the Honeywell 6070, and the\n> IBM-370 series.\n\nThe \u2018green dragon book\u2019 and its successor, Compilers: Principles, Techniques,\nand Tools - also known as the \u2018red dragon book\u2019 published in 1986, would\nbecome standard textbooks for anyone wanting to learn how to build compilers.\nThey would make the theory and the techniques creating a compiler available to\nall.\n\n####\n\n8-Bit Compilers\n\nMeanwhile, when Intel launched their first 8-bit microprocessor, the 8008, in\n1972 they commissioned Gary Kildall to write a compiler for the architecture.\nKildall wrote a compiler for PL/M, a language that he designed specially for\nthe purpose.\n\n> Famously, Kildall would go on to create CP/M, the most popular operating\n> system for 8-bit Intel and Zilog processors and its 16-bit successor CPM-86.\n> Less well known is that he also did novel research on compiler design, see\n> more in the further reading at the end of this post.\n\nThere were soon efforts to port the C language to 8-bit architectures, most\nnotably in the form of Ron Cain\u2019s small-C for the Intel 8080. Cain has written\nthat:\n\n> ... I ran off a listing of the Small-C compiler, strapped it to the back of\n> my motorcycle (which must have been a BMW if memory serves) and ran it over\n> to the local office of Dr. Dobbs. This was an unsolicited and unexpected\n> visit, so you can appreciate the look of puzzlement when I said \"Here's a\n> compiler for a subset of the C language. Sorry all I have is hard copy. Want\n> to run it?\"\n>\n> \"Sure,\" they said, \"just give us a day or so to look at the code to make\n> sure it does what you say it does. Er, a compiler you say? C to 8080 ASM\n> code? You wrote this? Sure you don't have it on mag tape or something?\"\n\nA listing of Cain\u2019s Small-C duly appeared in Dr Dobb\u2019s journal and soon\nspawned several derivative compilers for 8-bit machines.\n\nThese 8-bit C compilers remained primitive though. Most successful commercial\n8-bit software, limited by the quality of the compilers and needing to make\nthe most of the limited resources offered by 8-bit machines, continued to be\nwritten in assembly language.\n\n####\n\nEarly PC Compilers\n\nCommercial programs continued to be written in assembly language in the early\n16-bit microprocessor and the (IBM) PC era. The first (1983) version of Lotus\n1-2-3, the spreadsheet that was one of the most important early PC software\npackages, was written in 8086 assembly language, before being rewritten in C a\nfew years later.\n\nBut with the increase in RAM that the new 16-bit systems like the IBM PC\noffered, with a maximum of 1 Megabyte compared to 64 KBytes for 8-bit systems,\nsoftware was growing in complexity, and using assembly language was becoming\nmore problematic. And with a range of competing platforms and architectures,\nportability became more important. As the software market grew, so did the\ndemand for software development tools, including compilers.\n\nThis takes us to the 1983 Byte 'C Programming Language' edition. Commentary on\nC in the 'Features' section of the magazine starts with a clear articulation\nof one of the key attractions of the language.\n\n> The C language provides a new standard for portability in a computer world\n> characterized by a plethora of processors.\n\nLater on in the magazine, an article titled \u2018The C Language and Models for\nSystems Programming\u2019 by, none other than, Stephen Johnson and Brian Kernighan\nstates that:\n\n> Using functions to extend the base language explains why a language that is\n> so low level can be so portable. C compilers have been built for more than\n> 40 different machines, from the Z80 to the Cray-l.\n\nByte\u2019s introductory feature also discusses C's growing popularity in the world\nof microcomputer software:\n\n> Most major microcomputer manufacturers and software developers use C for\n> writing systems programs-operating systems, languages, and applications.\n> [Gary Kildall\u2019s] Digital Research is writing all of its new products in C,\n> including CP/M-68K for the 68000 microprocessor and the new Personal BASIC.\n> Both Microsoft and Visicorp have used C extensively in products ranging from\n> Multiplan and Xenix to Visiword and VisiOn.\n\nAnd again emphasizing the importance of C's portability.\n\n> Why is C so popular? The primary reason is that it allows programmers to\n> easily transport programs from one computer or operating system to another\n> while taking advantage of the specific features of the microprocessor in\n> use. And C is at home with systems from 8-bit micro-computers to the Cray-1,\n> the world's fastest computer. As a result, C has been called a 'portable\n> assembly language'...\n\nByte highlighted that growing interest in Unix was a key part of the reason\nfor C's increasing popularity.\n\n> No discussion of C is complete without mentioning the Unix operating system,\n> which is written in C. Unix and its utilities comprise over 300,000 lines of\n> C source code, certainly the most ambitious C project yet. Developed more\n> than 10 years ago at Bell Laboratories, both Unix and C are now coming into\n> widespread use.\n\nKernighan and Johnson write about how radical the use of a high-level language\nfor performance-critical applications had been when Ritchie had created C, but\nhow well C programs had, in fact, performed when compared to assembly\nlanguage:\n\n> At the time, using a high-level language for such applications was a radical\n> departure from standard practice; everyone knew that these programs had to\n> be written in assembly language \"for efficiency.\" Yet in many cases the C\n> code, although clearly less efficient in any given routine, produced\n> programs that outperformed similar programs written in assembly language.\n\nKernighan and Johnson end their article noting some of C\u2019s drawbacks but\nfinish on an optimistic note:\n\n> One or two such goofs while learning the language can lead a beginner to\n> burn the manual. Despite its problems, however, C continues to be used and\n> developed, a good sign that there is a place for a portable low-level\n> language with powerful model-building facilities.\n\nThis strong interest in C had already led to the development of a large number\nof C compilers and Byte tested twenty such compilers, for 8080, Z80, and\n8086-based machines. The compilers tested were:\n\n  * 8080/Z80 running Digital Research\u2019s CP/M-80: Aztec, BDS, C/80, Telecon, Whitesmiths.\n\n  * 8086/88 running Digital Research\u2019s CP/M-86: Lattice, Mark DeSmet, Digital Research, Mark Williams, Computer Innovations, Supersoft.\n\n  * 8086/88 running Microsoft\u2019s MS-DOS: c-systems, Caprock, Computer Innovations, DeSmet, Intellect, Lattice, Quantum, Supersoft, Telecon.\n\nAll the compilers tested by Byte were proprietary products, ranging in price\nfrom $35 to $750.\n\nLet's briefly look at one of the featured C compilers for CP/M-86, Mark\nWilliams C which was priced starting at $500.\n\nThe Mark Williams Company, based in Chicago Illinois, tried to capitalize on\nthe increasing interest in Unix and C, releasing Coherent, a Unix-like\noperating system for the IBM PC, and several C compilers including Mark\nWilliams CC86 for CP/M-86 and a low-cost C compiler 'Let's C' for the IBM PC.\nThe Mark Williams CC86 C Compiler for CP/M 86 was a high-quality product and\nByte commented:\n\n> CC86 has the most professional feel of any package we tested. It makes a\n> good attempt at full Kernighan and Ritchie and Unix version 7 compatibility.\n\nNotably, and perhaps surprisingly, absent from the list of companies offering\nC compilers was Microsoft. MS-DOS 4.0, which was released as late as 1988,\nstill included large amounts of 8086 assembly.\n\n####\n\nAnother approach: UCSD Pascal\n\n> Now you can design for the whole market. Once and for all.\n>\n> Softech UCSD Pascal Advertisement\n\nAt this point, it's worth mentioning another then-popular language that\npromised a strong level of portability but used a very different approach,\nNiklaus Wirth\u2019s Pascal. UCSD Pascal implemented a virtual machine (the\np-machine) that enabled it to run on a wide variety of architectures. One\nadvertisement from the time captured the appeal very effectively.\n\nIn practice, UCSD Pascal wasn't successful as an alternative to a native code\nC compiler and soon faded. Unlike compiled C there was a significant\nperformance penalty when compared to using assembly language. A successful\nbytecode ecosystem would have to wait until the Java programming language and\nthe Java Virtual Machine were released in 1995.\n\n####\n\nStallman and GCC\n\nRichard Stallman's recursively named 'GNU' operating system project was 'Not\nUnix' but was closely modeled on Unix.\n\nIn the 'GNU Manifesto' written in 1985 Stallman stated:\n\n> GNU, which stands for Gnu's Not Unix, is the name for the complete Unix-\n> compatible software system which I am writing so that I can give it away\n> free to everyone who can use it.\n\nUnix used C and so GNU would need a C compiler. Stallman, disappointed by the\n'unfree' nature of Andrew Tanenbaum's compiler, set out to create his own. The\nfirst version of the compiler - originally called the GNU C Compiler - was\naimed at the more powerful 16/32-bit microprocessors then becoming\nincreasingly popular. Stallman announced the first release of GCC in March\n1987.\n\n> The GNU C compiler is now available for ftp from the file /u2/emacs/gcc.tar\n> on prep.ai.mit.edu. This includes machine descriptions for vax and sun, 60\n> pages of documentation on writing machine descriptions (internals.texinfo,\n> internals.dvi and Info file internals). This also contains the ANSI standard\n> (Nov 86) C preprocessor and 30 pages of reference manual for it. This\n> compiler compiles itself correctly on the 68020 and did so recently on the\n> vax\n\nThe compiler included the, by now aging, DEC VAX minicomputer as a target as\nStallman had been offered a VAX 11/750 at MIT as a free development machine.\n\nThe first published version of GCC (0.9) is still available for download.\n\nCrucially, and aligned with Stallman\u2019s objectives for the GNU project, GCC was\nreleased with one of Stallman\u2019s \u2018free software\u2019 licenses. Users could freely\ntake and modify the code for their own use, but if they distributed those\nchanges they had to share them with others.\n\n####\n\nPortability and the RISC Cambrian Explosion\n\nThe portability of GNU and GCC wasn't an explicit objective of Stallman's\nmanifesto, but it was surely a necessary consequence. What was the point of\nfreedom if it was limited to the users of a few architectures?\n\nHowever, envisioning difficulties with less powerful machines, Stallman left\nthem to others:\n\n> The extra effort to make it run on smaller machines will be left to someone\n> who wants to use it on them.\n\nThe timing of the release of GCC was fortuitous. As we saw in The RISC Wars:\nThe Cambrian Explosion, the mid-1980s saw the appearance of a large number of\nnew RISC architectures. The firms creating these new designs sometimes had\ntheir own C compilers but, with the appearance of GCC, there was a new option:\njust write a new \u2018back-end\u2019 to enable GCC to target the new architecture.\n\n## The RISC Wars Part 1 : The Cambrian Explosion\n\nBabbage\n\n\u00b7\n\nApril 30, 2023\n\nI\u2019d like to start this week\u2019s post with a small confession. In last week\u2019s\npost, I called Berkeley RISC-I \u2018the first RISC microprocessor\u2019. In fact, some\nbelieve that a derivative of the IBM 801, known as ROMP, was the first RISC\nmicroprocessor. The story of the 801\u2019s successors, including ROMP, will be the\nsubject of a later post. I believe that RISC-I ...\n\nRead full story\n\nBefore long GCC was being ported to a range of other operating systems and\narchitectures. To give just one example, the Sun SPARC port appeared as early\nas 1988. One can sense the breadth of interest in GCC over the 1990s from a\n2001 list of contributors and their work. It includes some of the machines\nthat GCC had been ported to by that stage (most of which have now\ndisappeared!)\n\n> Vax, Sony NEWS Machine, NatSemi 32000, Motorola 88000, Convex, MIPS, Tahoe,\n> Pyramid, Charles River Data Systems, Elxsi, Clipper, PowerPC, Hitachi SH,\n> Fujitsu G/Micro Tron, AMD 29000, DEC Alpha, IBM RT, IBM RS/6000\n\nAlong with architectures, GCC was also adding languages, including Bjarne\nStroustrup\u2019s C++, which had appeared as an extension to the C programming\nlanguage as recently as 1985. According to Michael Tiemann:\n\n> I wrote GNU C++ in the fall of 1987, making it the first native-code C++\n> compiler in the world.\n\n####\n\nThe 80386, GCC and GNU / Linux\n\nThe first version of GCC (1.27) supporting the Intel 80386 appeared in 1988,\nwith most of the work on that port being done by Bill Schelter, a maths\nprofessor at the University of Texas, Austin.\n\nThe availability of 80386 support would later be helpful for Linus Torvalds.\nTorvalds has said that he preferred the architecture of the Motorola 68000\nseries, but he could see where the desktop computer market was heading. In his\nautobiographical book 'Just for Fun' he wrote:\n\n> I faced a geek's dilemma. Like any good computer purist raised on a 68008\n> chip, I despised PCs. But when the 386 chip came out in 1986, PCs started to\n> look, well, attractive. They were able to do everything the 68020 did, and\n> by 1990, mass-market production and the introduction of inexpensive clones\n> would make them a great deal cheaper. I was very money-conscious because I\n> didn't have any. So it was, like, this is the machine I want to get. And\n> because PCs were flourishing, upgrades and add-ons would be easy to obtain.\n> Especially when it came to hardware, I wanted to have something that was\n> standard.\n>\n> I decided to jump over and cross the divide. I would be getting a new CPU.\n\nWhen he started his Masters Degree course in Computer Science in Helsinki, C\nand Unix were two of the main attractions:\n\n> \"... I was most looking forward to was in the C programming language and the\n> Unix operating system\"\n\nTorvalds soon started developing his kernel for a Unix-like operating system.\nAs with Stallman, there was interest in, but eventual rejection of, Andrew\nTanenbaum's work, in this case, the MINIX operating system:\n\n> Early Linux kernel development was done on a MINIX host system, which led to\n> Linux inheriting various features from MINIX, such as the MINIX file system.\n> Eric Raymond claimed that Linus hasn't actually written Linux from scratch,\n> but rather reused source code of MINIX itself to have working codebase. As\n> the development progressed, MINIX code was gradually phased out completely.\n\nTorvalds needed a C compiler and an 80386 version of GCC was readily\navailable. When he first announced his project to the world in 1991, via a\nUsenet posting, GCC even got a mention:\n\n> I've currently ported bash(1.08) and gcc(1.40), and things seem to work.\n> This implies that I'll get something practical within a few months, and I'd\n> like to know what features most people would want. Any suggestions are\n> welcome, but I won't promise I'll implement them :-)\n\nTorvalds had written that:\n\n> \"It is NOT protable (uses 386 task switching etc)\"\n\nbut, despite this, the first responses to Torvalds's announcement were very\ninterested in the portability of the system to other architectures.\n\n> \"How much of it is in C? What difficulties will there be in porting? Nobody\n> will believe you about non-portability ;-), and I for one would like to port\n> it to my Amiga (Mach needs a MMU and Minix is not free).\"\n\nThe combination of Torvald's kernel and Richard Stallman's GNU software tools,\nincluding GCC, would soon become widely known as Linux. GCC has been an\nessential part of Linux ever since.\n\n####\n\nMicrosoft Visual C\n\nBy the early 1990s the availability of Linux as a free Unix-like operating\nsystem for the x86 and other architectures, along with GCC as a high-quality C\ncompiler, meant that, with a few exceptions, commercial competitors struggled\nto compete. Most of the compilers tested by Byte in 1983 quickly disappeared\ncompletely. The Mark Williams Company, for example, closed its operations in\n1995.\n\nOne that has survived is Lattice C, one of the most performant of the\ncompilers tested by Byte. Lattice C was so good that it was licensed by\nMicrosoft and sold as Microsoft C V1.0 before being replaced by Microsoft\u2019s\nown in-house Microsoft C V2.0 compiler.\n\nOther compilers for the MS-DOS and then Windows operating systems, notably\nBorland\u2019s Turbo C and Borland C++ and Watcom C/C++ did well for an extended\nperiod before the combination of GCC and Microsoft\u2019s own C/C++ compilers ended\ntheir commercial viability.\n\n> Borland\u2019s C and C++ - and other Borland products - and Watcom C/C++ really\n> deserve an article all to themselves, but although they were popular and\n> important at the time their impact on today\u2019s compiler ecosystems is smaller\n> than the other compilers we dicuss.\n\nToday, Microsoft still offers the descendants of its first in-house compiler,\nin the form of Microsoft Visual C++. Just as Windows has become and remains\nthe most popular operating system on the desktop, Microsoft\u2019s compiler has\nremained dominant on Windows.\n\n####\n\nGCC and EGCS\n\nThe open-source nature of GCC soon led to several experimental forks with\nchanges that were not accepted back into the main GCC project. This led to the\ncreation of the Experimental/Enhanced GNU Compiler System (EGCS) in 1997,\nwhich merged a number of these forks. According to Wikipedia:\n\n> EGCS development proved considerably more vigorous, so much so that the FSF\n> officially halted development on their GCC 2.x compiler, blessed EGCS as the\n> official version of GCC, and appointed the EGCS project as the GCC\n> maintainers in April 1999. With the release of GCC 2.95 in July 1999 the two\n> projects were once again united.\n\n####\n\nGCC Today\n\nToday GCC has been ported to a wide range of architectures and operating\nsystems, almost certainly more than any other compiler. It also compiles a\nrange of programming languages, including C++, Fortran, Ada, and more.\n\nOn architectural portability, according to the GCC website:\n\n> GCC itself aims to be portable to any machine where int is at least a 32-bit\n> type. It aims to target machines with a flat (non-segmented) byte addressed\n> data address space (the code address space can be separate). Target ABIs may\n> have 8, 16, 32 or 64-bit int type. char can be wider than 8 bits.\n\nHere is a list of the architectures that GCC supported in 2023 (source):\n\n> aarch64, alpha, arc, arm, avr, bfin, c6x,cr16, cris, csky, epiphany, fr30,\n> frv, gcn, h8300, i386,ia64, iq2000, lm32, m32c, m32r, m68k, more, mep,\n> microblaze, mips, mmix,mn10300, moxie, msp430, nds32, nios2, nvptx, pa,\n> pdp11, pru, riscv, rl78, rs6000, rx, s390, sh, sparc, stormy16, tilegx,\n> tilepro, v850, vax, visium, xtensa.\n\nNote that both of the originally supported architectures - m68k and vax - are\nstill supported today! Notably absent, though, are the 8-bit microprocessors\nand microcontrollers that Richard Stallman left to others to implement back in\n1987.\n\nAlong with this growth in architectural and language support GCC itself has\ngrown hugely. By 2019 GCC had grown in size to over 15 million lines of code.\n\nToday though, GCC isn\u2019t the only pervasive open-source C compiler. The LLVM\necosystem has gained increasing popularity and is vital to the success of many\nof the new architectures and hardware that we\u2019ve discussed in recent posts.\nWe'll discuss LLVM, and its relationship with GCC, in more detail in the next\npost in this series.\n\nBefore we leave though, a reminder of how important compilers are to the\nsuccess of an architecture. Intel's Itanium architecture, on which the company\nspent billions of dollars, is generally thought to have failed, in large part,\nbecause the company failed to get a compiler for the new architecture to work\nwell enough. The recent announcement of the removal of support for it in the\nnext GCC (version 15) provides final confirmation of the fact that the\narchitecture is obsolete:\n\n> Support for the ia64*-*- target ports which have been unmaintained for quite\n> a while has been declared obsolete in GCC 14. The next release of GCC will\n> have their sources permanently removed.\n\nThe success or failure of many of the 'Cambrian Explosion' of machine learning\nASICs will, in many cases, depend on the success or failure of their software\necosystems and the availability of a high-quality compiler for C and C-like\nlanguages is essential to all those ecosystems.\n\nShare\n\nThe rest of this post is for premium subscribers and includes links to:\n\n  * Brian Kernighan on the C programming language.\n\n  * Dennis Ritchie and Stephen Johnson on the portability of C and Unix.\n\n  * The earliest known version of Dennis Ritchie\u2019s first C compiler.\n\n  * The C Language and Models for Systems Programming Byte article by Stephen Johnson and Brian Kernighan.\n\n  * Gary Kildall\u2019s compiler research.\n\n  * Dr Dobb\u2019s Journal Articles and Resources on C.\n\n  * More on Small C.\n\n  * More on the Portable C compiler.\n\n  * Running the first GCC with 80386 support.\n\n  * C++ on the Commodore 64.\n\nUpgrade your subscription by clicking on this button.\n\n###### Cover image credit XC68020 - prototype of the Motorola 68020, one of\nthe first GCC targets, By David Monniaux - Own work, CC BY-SA 3.0,\nhttps://commons.wikimedia.org/w/index.php?curid=1594209\n\n## This post is for paid subscribers\n\nAlready a paid subscriber? Sign in\n\n\u00a9 2024 The Chip Letter\n\nPrivacy \u2219 Terms \u2219 Collection notice\n\nStart WritingGet the app\n\nSubstack is the home for great culture\n\nShare\n\n", "frontpage": true}
