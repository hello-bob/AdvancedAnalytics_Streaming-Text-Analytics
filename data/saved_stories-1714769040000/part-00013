{"aid": "40247597", "title": "Building gdocweb with Java 21, Spring Boot 3.x and Beyond", "url": "https://debugagent.com/building-gdocweb-with-java-21-spring-boot-3x-and-beyond", "domain": "debugagent.com", "votes": 1, "user": "mooreds", "posted_at": "2024-05-03 13:45:16", "comments": 0, "source_title": "Building gdocweb with Java 21, Spring Boot 3.x and Beyond", "source_text": "Building gdocweb with Java 21, Spring Boot 3.x and Beyond\n\n# Building gdocweb with Java 21, Spring Boot 3.x and Beyond\n\n## Explore the journey of building gdocweb: a developer's insight into\nchoosing Java 21, Spring Boot 3.x, and navigating tech stack challenges.\n\nShai Almog\n\n\u00b7Jan 16, 2024\u00b7\n\n9 min read\n\n## Table of contents\n\n  * Introducing gdocweb\n\n    * Java 21 and Spring Boot 3.x: Innovation and Maturity\n\n  * GraalVM Native Image for Efficiency\n\n    * Implementing GraalVM\n\n    * Facing the Production Challenges\n\n    * The Decision to Move On\n\n  * Deployment: VPS and Docker Compose\n\n    * Avoiding Raw VPS Deployment\n\n    * Steering Clear of Managed Containers & Orchestration\n\n    * The Choice of Docker Compose\n\n  * Front-End: Thymeleaf Over Modern Alternatives\n\n    * React: Modern but Not a One-Size-Fits-All Solution\n\n    * The Appeal of Thymeleaf\n\n    * Considering HTMX for Dynamic Functionality\n\n  * Final Word\n\nStarting a new project is always a mix of excitement and tough decisions,\nespecially when you're stitching together familiar tools like Google Docs with\npowerhouses like GitHub Pages. This is the story of building gdocweb, a tool\nthat I hoped would make life easier for many. I'll be diving into why I chose\nJava 21 and Spring Boot 3.x, ditched GraalVM after some trial and error, and\nwhy a simple VPS with Docker Compose won out over more complex options. I also\nwent with Postgres and JPA, but steered clear of migration tools like Flyway.\nIt's a no-frills, honest recount of the choices, changes, and the occasional\n'aha' moments of an engineer trying to make something useful and efficient.\n\n## Introducing gdocweb\n\nBefore we dive into the technical intricacies and the decision-making\nlabyrinth of building gdocweb, let's set the stage by understanding what\ngdocweb is and the problem it solves. In simple terms, gdocweb connects Google\nDocs to GitHub Pages. It's a simple web builder that generates free sites with\nall the raw power of GitHub behind it and all the usability of Google Docs.\n\nI decided to build gdocweb to eliminate the complexities typically associated\nwith website building and documentation. It's for users who seek a hassle-free\nway to publish and maintain their content, but also for savvy users who enjoy\nthe power of GitHub but don't want to deal with markdown nuances.\n\nHere's a short video explaining gdocweb for the general public:\n\nhttps://youtu.be/aaDBFVx6qC8\n\n### Java 21 and Spring Boot 3.x: Innovation and Maturity\n\nWhen you're spearheading a project on your own, like I was with gdocweb, you\nhave the liberty to make technology choices that might be more challenging in\na team or corporate environment. This freedom led me to choose Java 21 and\nSpring Boot 3.x for this project. The decision to go with the current Long-\nTerm Support (LTS) version of Java was a no-brainer. It's always tempting to\nuse the latest and greatest, but with Java 21, it wasn't just about using\nsomething new; it was about leveraging a platform that has stood the test of\ntime and has evolved to meet modern development needs. Virtual threads were a\nmajor part of the decision to go with Java 21. Cost is a huge factor in such\nprojects, and squeezing the maximum throughput from a server is crucial in\nthese situations.\n\nJava, being a mature technology, offered a sense of reliability even in its\nlatest iteration. Similarly, Spring Boot 3.x, despite being a newer version,\ncomes from a lineage of robust and well-tested frameworks. It's a conservative\nchoice in the sense of its long-standing reputation, but innovative in its\nfeatures and capabilities.\n\nHowever, this decision wasn't without its hiccups. During the process of\nintegrating Google API access, I had to go through a security CASA tier 2\nreview. Here's where the choice of Java 21 threw a curveball. The review tool\nwas tailored for JDK 11, and although it worked with JDK 21, it still added a\nbit of stress to the process. It was a reminder that when you're working with\ncutting-edge versions of technologies, there can be unexpected bumps along the\nroad. Even if they are as mature as Java.\n\nThe transition to Spring Boot 3.x had its own set of challenges, particularly\nwith the changes in security configurations. These modifications rendered most\nonline samples and guides obsolete, breaking a lot of what I had initially set\nup. It was a learning curve, adjusting to these changes and figuring out the\nnew way of doing things. However, most other aspects were relatively simple\nand the best compliment I can give to Spring Boot 3.x is that it's very\nsimilar to Spring Boot 2.x.\n\n## GraalVM Native Image for Efficiency\n\nMy interest in GraalVM native image for gdocweb was primarily driven by its\npromise of reduced memory usage and faster startup times. The idea was that\nwith lower memory requirements, I could run more server instances, leading to\nbetter scalability and resilience. Faster startup times also meant quicker\nrecovery from failures, a crucial aspect for maintaining a reliable service.\n\n### Implementing GraalVM\n\nGetting GraalVM to work was nontrivial but not too hard. After some trial and\nerror, I managed to set up a Continuous Integration (CI) process that built\nthe GraalVM project and uploaded it to Docker. This was particularly necessary\nbecause I'm using an M2 Mac, while my server runs on Intel architecture. This\nsetup meant I had to deal with an 18-minute wait time for each update \u2013 a\nsignificant delay for any development cycle.\n\n### Facing the Production Challenges\n\nThings started getting rocky when I started to test the project production and\nstaging environments. It became a 'whack-a-mole' scenario with missing library\ncode from the native image. Each issue fixed seemed to only lead to another,\nand the 18-minute cycle for each update added to the frustration.\n\nThe final straw was realizing the incompatibility issues with Google API\nlibraries. Solving these issues would require extensive testing on a GraalVM\nbuild, which was already burdened by slow build times. For a small project\nlike mine, this became a bottleneck too cumbersome to justify the benefits.\n\n### The Decision to Move On\n\nWhile GraalVM seemed ideal on paper for saving resources, the reality was\ndifferent. It consumed my limited GitHub Actions minutes and required\nextensive testing, which was impractical for a project of this scale.\nUltimately, I decided to abandon the GraalVM route.\n\nIf you do choose to use GraalVM then this was the GitHub Actions script I\nused, I hope it can help you with your journey:\n\n    \n    \n    name: Java CI with Maven on: push: branches: [ \"master\" ] pull_request: branches: [ \"master\" ] jobs: build: runs-on: ubuntu-latest services: postgres: image: postgres:latest env: POSTGRES_PASSWORD: yourpassword ports: - 5432:5432 options: >- --health-cmd pg_isready --health-interval 10s --health-timeout 5s --health-retries 5 steps: - uses: actions/checkout@v3 - uses: graalvm/setup-graalvm@v1 with: java-version: '21' version: '22.3.2' distribution: 'graalvm' cache: 'maven' components: 'native-image' native-image-job-reports: 'true' github-token: ${{ secrets.GITHUB_TOKEN }} - name: Wait for PostgreSQL run: sleep 10 - name: Build with Maven run: mvn -Pnative native:compile - name: Build Docker Image run: docker build -t autosite:latest . - name: Log in to Docker Hub uses: docker/login-action@v1 with: username: ${{ secrets.DOCKERHUB_USERNAME }} password: ${{ secrets.DOCKERHUB_TOKEN }} - name: Push Docker Image run: | docker tag autosite:latest mydockeruser/autosite:latest docker push mydockeruser/autosite:latest\n\nThis configuration was a crucial part of my attempt to leverage GraalVM's\nbenefits, but as the project evolved, so did my understanding of the trade-\noffs between idealism in technology choice and practicality in deployment and\nmaintenance.\n\n## Deployment: VPS and Docker Compose\n\nWhen it came to deploying gdocweb, I had a few paths to consider. Each option\ncame with its pros and cons, but after careful evaluation, I settled on using\na Virtual Private Server (VPS) with Docker Compose. Here\u2019s a breakdown of my\nthought process and why this choice made the most sense for my needs.\n\n### Avoiding Raw VPS Deployment\n\nI immediately ruled out the straightforward approach of installing the\napplication directly on a VPS. This method fell short in terms of migration\nease, testing, and flexibility. Containers offer a more streamlined and\nefficient approach. They provide a level of abstraction and consistency across\ndifferent environments, which is invaluable.\n\n### Steering Clear of Managed Containers & Orchestration\n\nManaged containers and orchestration (e.g k8s) were another option, and while\nthey offer scalability and ease of management, they introduce complexity in\nother areas. For instance, when using a managed Kubernetes service it would\noften mean relying on cloud storage for databases, which can get expensive\nquickly. My philosophy was to focus on cost before horizontal scale,\nespecially in the early stages of a project.\n\nIf we don't optimize and stabilize when we're small, the problems will only\nget worse as we grow. Scaling should ideally start with vertical scaling\nbefore moving to horizontal, vertical scaling means more CPU/RAM while\nhorizontal adds additional machines. Vertical scaling is not only more cost-\neffective but also crucial from a technical standpoint. It makes it easier to\nidentify performance bottlenecks using simple profiling tools.\n\nIn contrast, horizontal scaling can often mask these issues by adding more\ninstances, which could lead to higher costs and hidden performance problems.\n\n### The Choice of Docker Compose\n\nDocker Compose emerged as the clear winner for several reasons. It allowed me\nto seamlessly integrate the database and the application container. Their\ncommunication is contained within a closed network, adding an extra layer of\nsecurity with no externally open ports. Moreover, the cost is fixed and\npredictable, with no surprises based on usage.\n\nThis setup offered me the flexibility and ease of containerization without the\noverhead and complexity of more extensive container orchestration systems. It\nwas the perfect middle ground, providing the necessary features without\novercomplicating the deployment process.\n\nBy using Docker Compose, I maintained control over the environment and kept\nthe deployment process straightforward and manageable. This decision aligned\nperfectly with the overall ethos of gdocweb \u2013 simplicity, efficiency, and\npracticality.\n\n## Front-End: Thymeleaf Over Modern Alternatives\n\nThe front-end development of gdocweb presented a bit of a challenge for me. In\nan era where React and similar frameworks are dominating the scene, opting for\nThymeleaf might seem like a step back. However, this decision was based on\npractical considerations and a clear understanding of the project's\nrequirements and my strengths as a developer.\n\n### React: Modern but Not a One-Size-Fits-All Solution\n\nReact is undeniably modern and powerful, but it comes with its own set of\ncomplexities. My experience with React is akin to many developers dabbling\noutside their comfort zone - functional but not exactly proficient. I've seen\nthe kind of perplexed expressions from seasoned React developers when they\nlook at my code, much like the ones I have when I'm reading complex Java code\nwritten by others.\n\nReact\u2019s learning curve, coupled with its slower performance in certain\nscenarios and the risk of not achieving an aesthetically pleasing result\nwithout deep expertise, made me reconsider its suitability for gdocweb.\n\n### The Appeal of Thymeleaf\n\nThymeleaf, on the other hand, offered a more straightforward approach,\naligning well with the project's ethos of simplicity and efficiency. Its HTML-\nbased interfaces, while perhaps seen as antiquated next to frameworks like\nReact, come with substantial advantages:\n\n  1. Simplicity in Page Flow: Thymeleaf provides an easy-to-understand and easy-to-debug flow, making it a practical choice for a project like this.\n\n  2. Performance and Speed: It\u2019s known for its fast performance, which is a significant factor in providing a good user experience.\n\n  3. No Need for NPM: Thymeleaf eliminates the need for additional package management, reducing complexity and potential vulnerabilities.\n\n  4. Lower Risk of Client-Side Vulnerabilities: The server-side nature of Thymeleaf inherently reduces the risk of client-side issues.\n\n### Considering HTMX for Dynamic Functionality\n\nThe idea of incorporating HTMX for some dynamic behavior in the front-end did\ncross my mind. HTMX has been on my radar for a while, promising to add dynamic\nfunctionalities easily. However, I had to ask myself if it was truly necessary\nfor a tool like gdocweb, which is essentially a straightforward wizard. My\nconclusion was that opting for HTMX might be more of Resume Driven Design\n(RDD) on my part, rather than a technical necessity.\n\nIn summary, the choice of Thymeleaf was a blend of practicality, familiarity,\nand efficiency. It allowed me to build a fast, simple, and effective front-end\nwithout the overhead and complexity of more modern frameworks, which, while\npowerful, weren't necessary for the scope of this project.\n\n## Final Word\n\nThe key takeaway in this post is the importance of practicality in technology\nchoices. When we're building our own projects it's much easier to experiment\nwith newer technologies, but this is a slippery slope. We need to keep our\nfeet grounded in familiar territories while experimenting.\n\nMy experience with GraalVM highlights the importance of aligning technology\nchoices with project needs and being flexible in adapting to challenges. It\u2019s\na reminder that in technology, sometimes the simpler, tried-and-tested paths\ncan be the most effective.\n\n## Subscribe to our newsletter\n\nRead articles from Java, Debugging, DevOps & Open Source directly inside your\ninbox. Subscribe to the newsletter, and don't miss out.\n\nJavaSpringbootGoogleGitHubStartups\n\n### Written by\n\n# Shai Almog\n\nEntrepreneur, author, blogger, open source hacker, speaker, Java rockstar,\ndeveloper advocate and more. ex-Sun/Oracle guy with 30 years of professional\ndevelopment experience. Shai built virtual machines, development tools, mobile\nphone environments, banking systems, startup/enterprise backends, user\ninterfaces, development frameworks and much more. Shai is an award winning\nhighly rated speaker with a knack for engaging the audience and deep technical\nchops.\n\nEntrepreneur, author, blogger, open source hacker, speaker, Java rockstar,\ndeveloper advocate and more. ex-Sun/Oracle guy with 30 years of professional\ndevelopment experience. Shai built virtual machines, development tools, mobile\nphone environments, banking systems, startup/enterprise backends, user\ninterfaces, development frameworks and much more. Shai is an award winning\nhighly rated speaker with a knack for engaging the audience and deep technical\nchops.\n\n### Published on\n\n# Java, Debugging, DevOps & Open Source\n\nAuthor, Open Source Hacker, Entrepreneur, Blogger, DevRel, Java Rockstar,\nConference Speaker and Instructor\n\nAuthor, Open Source Hacker, Entrepreneur, Blogger, DevRel, Java Rockstar,\nConference Speaker and Instructor\n\nShare this\n\nArticle Series\n\n### gdocweb\n\n1\n\n# Introducing gdocweb\n\nThis Post is a Google Docs Document... Note: This post was originally\npublished here. Yes. This post s...\n\n2\n\n# Building gdocweb with Java 21, Spring Boot 3.x and Beyond\n\nStarting a new project is always a mix of excitement and tough decisions,\nespecially when you're sti...\n\n3\n\n# Blog Comments\n\nNote: this post was originally published on the gdocweb blog. Comments are Now\nAvailable in gdocweb ...\n\n4\n\n# Styling and Dark Mode\n\nNote: this post was originally published on the gdocweb blog. Styling a\nDocument isn\u2019t as Trivial as...\n\n5\n\n# Regenerate Immediately and RSS\n\nNote: this post was originally published on the gdocweb blog. gdocweb has its\nfirst few users and on...\n\nImpressum\n\n\ud83d\udcd6 Read my Books Practical Debugging at Scale, Java Basics & Java 8 to 21\n\n\u25b6\ufe0f Learn Java, Debugging & DevOps with my Video Tutorials on YouTube\n\n\u00a92024 Java, Debugging, DevOps & Open Source\n\nArchive\u00b7Privacy policy\u00b7Terms\n\nWrite on Hashnode\n\nPowered by Hashnode - Home for tech writers and readers\n\n", "frontpage": false}
