{"aid": "40153672", "title": "Tale of a Suicidal Container", "url": "https://ai.ragv.in/posts/a-tale-of-suicidal-container/", "domain": "ai.ragv.in", "votes": 5, "user": "kn81198", "posted_at": "2024-04-25 05:08:44", "comments": 0, "source_title": "A Tale of a Suicidal Container", "source_text": "A Tale of a Suicidal Container | AI Logs\n\nHome \u00bb Posts\n\n# A Tale of a Suicidal Container\n\nFebruary 21, 2024 \u00b7 4 min \u00b7 Raghava Dhanya\n\nOne fine day, I sat down to optimize the size of a Docker image. Like many\ntimes before, I opted for distroless images as my base, a choice I had made\ncountless times before without a hitch.\n\nDistroless images, for the uninitiated, are peak minimalism, containing only\nthe essential libraries and binaries required to run the application. Not only\ndo they trim the fat off the image size, but they also mitigate the risk of\nCVEs lurking within.\n\nLittle did I know, what appeared to be a simple task soon spiraled into hours\nof troubleshooting and head-scratching.\n\nI made a seemingly innocuous change to the Dockerfile.\n\nFrom:\n\n    \n    \n    FROM golang:1.20 COPY go.mod go.sum ./ RUN go mod download COPY . . RUN go build -o /app ENTRYPOINT ./app\n\nto :\n\n    \n    \n    FROM golang:1.20 AS build COPY go.mod go.sum ./ RUN go mod download COPY . . RUN go build -o /app FROM gcr.io/distroless/base COPY --from=build /app / ENTRYPOINT [\"/app\"]\n\nWith the changes made, I deployed to the development environment. To my\nsurprise, the pods failed to spin up, with containers exiting immediately and\nlogging exit status 1.\n\nInteresting! The code remained untouched; it had to be the change in the base\nimage. I swapped gcr.io/distroless/base for golang:1.20 in the Dockerfile in\nthe second stage. But the issue persisted. Oddly, the app ran fine outside the\ncontainers and with the earlier Dockerfile. But the newer Dockerfile, with or\nwithout distroless base, was not working.\n\nAttempting to gain more insight, I toggled debug mode to true, hoping for\nadditional logs. Wait what? It works. Yet, the mystery deepened as the same\nDockerfile, with the distroless base, functioned seamlessly only in debug\nmode. Debug mode merely adjusts the log level and operates with a single\nworker, effectively disabling preforking.\n\nThe issue likely lies with the preforking mechanism in the gofiber library\nwhich the app uses. Upon inspecting the codebase, I stumbled upon a familiar\npiece of code:\n\n    \n    \n    ... for range time.NewTicker(watchInterval).C { if os.Getppid() == 1 { os.Exit(1) //nolint:revive // Calling os.Exit is fine here in the prefork } } ...\n\nThis snippet essentially checks if the parent process is still alive. If not,\nit exits. Such behavior is common in preforking servers. The parent process\nlistens to the port and forks children to handle requests. If the parent\nprocess dies, the children are useless. So, they exit. But how do they know if\nthe parent died? They check if the parent process id is 1. In Linux, the\nparent process id 1 is init process. Any orphaned process is adopted by init\nprocess.\n\nThe culprit? The line ENTRYPOINT [\"/app\"] in the Dockerfile. Docker assigns\nPID 1 to the entrypoint process, this unwittingly condemned my application to\nan existential crisis. With no parent process to claim it, the app chose the\npath of least resistance: to commit suicide. Effectively it kills itself\nbecause it thinks it\u2019s an orphan.\n\nThere\u2019s a significant distinction between ENTRYPOINT ./app and ENTRYPOINT\n[\"/app\"] in Docker. The former treats ./app as a string executed by the shell,\nmaking the app a child of the shell. The latter, however, directly executes\n[\"/app\"], leading the app to assume PID 1.\n\nSwitching back to ENTRYPOINT ./app wasn\u2019t an option due to distroless\u2019 lack of\na shell. Enter tini, a lightweight init system designed to solve precisely\nthis problem. While I\u2019ve encountered tini in Dockerfiles before, I never truly\ngrasped its necessity until now. It serves as dummy process to avoid the PID 1\nproblem.\n\nAnother aspect I previously overlooked was the distinction between CMD and\nENTRYPOINT. CMD executes the command within ENTRYPOINT.\n\n    \n    \n    FROM golang:1.20 AS build COPY go.mod go.sum ./ RUN go mod download COPY . . RUN go build -o /app ENV TINI_VERSION v0.19.0 ADD https://github.com/krallin/tini/releases/download/${TINI_VERSION}/tini /tini RUN chmod +x /tini FROM gcr.io/distroless/base COPY --from=build /app / ENTRYPOINT [\"/tini\", \"--\"] CMD [\"/app\"]\n\nThis is essentially the same as ENTRYPOINT [\"/tini\", \"--\". \"/app\"].\n\n  * Kubernetes\n  * Mlops\n  * Golang\n  * Docker\n  * Containers\n  * Linux\n  * Tini\n\n\u00a9 2023 Raghava Dhanya | License | Powered by Hugo & PaperMod\n\n", "frontpage": false}
