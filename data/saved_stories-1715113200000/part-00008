{"aid": "40284121", "title": "Prisma with PostgreSQL: the hard things about building a no code database", "url": "https://www.cycle.app/blog/prisma-with-postgresql-the-hard-things-about-building-a-no-code-database", "domain": "cycle.app", "votes": 3, "user": "mart1", "posted_at": "2024-05-07 10:49:09", "comments": 0, "source_title": "Prisma with PostgreSQL: the hard things about building a no code database | Cycle", "source_text": "Prisma with PostgreSQL: the hard things about building a no code database | Cycle\n\nLog in\n\nStart free trial\n\n7-day free trial unlocked by onboarding call\n\nAll blog posts\n\nON THIS PAGE\n\nIntroduction\n\nThe constraints\n\nThe hard thing about pagination\n\nThe hard thing about view configuration (filters, group by, ...)\n\nThe hard thing about separation of concerns\n\nThe hard things made easier\n\nSHARE THIS POST\n\nMartin Delobbe\n\non\n\nMay 6, 2024\n\n13\n\nmin read\n\n# Prisma with PostgreSQL: the hard things about building a no code database\n\n## Introduction\n\nBuilding Cycle has been a challenging journey. We initially built the product,\nthen rebuilt it a year later, and finally built it again the year after that.\nIt took us a total of two and a half years to establish a solid foundation\nthat we could be proud of. However, why was it so complicated to create a\nseemingly simple product? What were the requirements that made developing a\ntool for product teams so complex? Luckily, we were naive enough to jump in\nand believe that everything would go smoothly!\n\n## The constraints\n\nEvery product team has its own unique typology, with its own process,\nconcepts, and way of structuring product information. From the very beginning,\nit was a requirement to build a framework that could adapt to these different\ntypologies. Some teams prefer to create bugs and features, while others prefer\nto create problems and solutions. Some teams even combine all of these\nelements and link them together with a well-thought-out hierarchical\nstructure. This left us no choice but to build a no-code relational database.\nWhat could go wrong, right? \ud83d\ude05\n\nCycle's basic entities are simple. The \"Doc\" is the atomic unit. The \"Doctype\"\nsimply refers to the type of Doc you want to create (e.g., a bug, a feature,\netc.). You can also add hierarchy constraints between your Doctypes.\n\"Properties\" are custom links with Doctypes and allow you to decide which\nvalues can be assigned to a Doc. Lastly, there is the \"View,\" which is the way\nto visualize your Docs. You can actually make a comparison with a relational\ndatabase, where Doctypes are Tables, Docs are Rows, Properties are Fields, and\nViews are, well... Views.\n\n## The hard thing about pagination\n\nIn Cycle, a Doc can be shared across any View without duplicating it. It means\nevery View can potentially contain all the Docs of a workspace. If a workspace\nhas +100K Docs, a view configuration that says \u00ab I want all the Docs from all\nDoctypes \u00bb (or select * from all_tables where all_tables would be a join on\neach table in SQL) will request +100K Docs.\n\nWe cannot afford to have the same approach as most companies who load all the\nids then handle pagination from the front end, the load times would be\nterrible. Specifically in the case of grouped by views (group by clause in an\nSQL query). This is what we initially did in the past and it forced us to\nrewrite the implementation. That\u2019s why the pagination is made backend side:\nthe first view query only requests 8 groups and 15 docs by group. The\npagination is then handled group by group; we query 15 more docs for the group\nwe scroll in but the frontend is agnostic of those docs.\n\nThis is only made possible via an existing entity in the database for each and\nevery group. And every group by can be created out of any property in the\nworkspace. This adds some complexity when building table stakes features like\nsorts or multi group by but this is the best way to scale with our\nconstraints.\n\nHereunder, a comparison of the different fetching strategies from flexible\nmanagement tools. As stated, this works well in their context where tasks,\npages or issues live in the context of a single view/database/board but not\nfor ours where docs are global.\n\n  * Notion\n\n    * Inital query: queryCollection query fetches all the ids of the pages contained in the Board and all the groups\n    * Group query: Groups are built out of the already fetched data. The processing time being simply the client rendering the groups.\n  * Clickup\n\n    * Initial query: genericView query fetches all the ids of the tasks contained in the Board and all the groups.\n    * Group query: Every group knows which task is part of the group and fetches the task when scrolling in the group.\n  * Trello\n\n    * Initial query: cards=visible query parameters fetches all the cards with all the informations.\n    * Group query: No group query, the groups are built out of the first query and scrolling does not trigger any query or socket.\n  * Asana\n\n    * Initial query: The initial data is fetched over a single synced socket\n    * Group query: The group query is only triggered for builtin property (like status). For custom properties everything is fetched and groups are built out of the first query.\n\n## The hard thing about view configuration (filters, group by, ...)\n\nWhen first building Cycle, we weren\u2019t quite sure of the data structure\nregarding Views which led us to store the information in a JSON format. This\nwas a mistake because everything in Cycle is relational and deeply linked.\nLeveraging the relational features of a PostgreSQL database makes much more\nsense (as for most B2B productivity softwares). The migration from an\nunstructured json format was hard but necessary.\n\nIn Cycle, any property can be used in a filter which implies the value of a\nfilter to be linked to the value assigned to a Doc, itself defined in the\nProperty settings. This is made possible via a generic Value entity in the\ndatabase. Anything can be a Value. From a Doc to a User, from a Customer to a\nDoctype or a simple Single select value. This Value table being so centric, it\nis important to adopt a proper indexing strategy as explained in this previous\narticle (you may suffer from latency leading to database timeouts otherwise).\n\n## The hard thing about separation of concerns\n\nReflecting on our journey, I have thought many times about the reasons we\ncouldn\u2019t build the proper foundation from the very beginning. There are many\nreasons, including the inherent complexity and the typical iterations when\nstarting a business. However a less obvious one hit me when we rebuilt the\nproduct the last time.\n\nAt the very beginning of Cycle, everyone was full-stack. But what does full-\nstack actually mean ? Does it mean you\u2019re as good in frontend as in backend ?\nDo you have the same expertise as a Senior frontend engineer and a Senior\nbackend engineer ? If not why are you claiming yourself full-stack ? Trust me\nI fully understand the full-stack vibe and what it means in term of culture\nbut when building a product where every interaction must be optimised there is\nno room for lack of expertise and you\u2019ll iterate way faster if there is a\nproper separation of concerns (even in a small team).\n\nCycle is an API first product. It took us some time to embrace this philosophy\nbut it was game changer. How did it impact the way we work ? Well, as stated\nby Conway's law, the structure of a product reflects the structure of its\norganization. Therefore, we structured the team in a way that aligns with the\ndesired product outcome. The backend team aligns on the DB schema and the API\nschema serves as a way to align the frontends with the backends. The two\nschemas being clearly decoupled.\n\n## The hard things made easier\n\nCycle\u2019s data model is the essence of the product. It was hard to build but if\nyou want to adopt the same approach, here is a visual representation to start\nfrom :\n\nAnd its prisma schema\n\ndatasource db {  \n---  \nprovider = \"postgresql\"  \nurl = env(\"DATABASE_URL\")  \n}  \nmodel Doctype {  \nid String @id @default(uuid()) @db.Uuid  \nproperties DoctypePropertyMap[]  \nvalue Value?  \n}  \nmodel DoctypePropertyMap {  \ndoctype Doctype @relation(fields: [doctypeId], references: [id], onDelete:\nCascade)  \ndoctypeId String @db.Uuid  \nproperty Property @relation(fields: [propertyId], references: [id], onDelete:\nCascade)  \npropertyId String @db.Uuid  \n@@id([doctypeId, propertyId])  \n}  \nmodel Property {  \nid String @id @default(uuid()) @db.Uuid  \ndoctypes DoctypePropertyMap[]  \npropertyValues PropertyValue[]  \n}  \nmodel PropertyValue {  \nid String @id @default(uuid()) @db.Uuid  \nproperty Property @relation(fields: [propertyId], references: [id], onDelete:\nCascade)  \npropertyId String @db.Uuid  \nvalue Value?  \n}  \nmodel Value {  \nid String @id @default(uuid()) @db.Uuid  \npropertyValue PropertyValue? @relation(fields: [propertyValueId], references:\n[id], onDelete: Cascade)  \npropertyValueId String? @unique @db.Uuid  \ndoctype Doctype? @relation(fields: [doctypeId], references: [id], onDelete:\nCascade)  \ndoctypeId String? @unique @db.Uuid  \ndoc Doc? @relation(fields: [docId], references: [id], onDelete: Cascade)  \ndocId String? @unique @db.Uuid  \ndocValues DocValueMap[]  \ngroup Group[]  \n}  \nmodel DocValueMap {  \ndoc Doc @relation(fields: [docId], references: [id], onDelete: Cascade)  \ndocId String @db.Uuid  \nvalue Value @relation(fields: [valueId], references: [id], onDelete: Cascade)  \nvalueId String @db.Uuid  \n@@id([docId, valueId])  \n}  \nmodel Doc {  \nid String @id @default(uuid()) @db.Uuid  \ndoctypeId String @db.Uuid  \nvalue Value?  \nvalues DocValueMap[]  \n}  \nmodel View {  \nid String @id @default(uuid()) @db.Uuid  \nviewConfig ViewConfig[]  \n}  \nmodel ViewConfig {  \nid String @id @default(uuid()) @db.Uuid  \nview View @relation(fields: [viewId], references: [id], onDelete: Cascade)  \nviewId String @unique @db.Uuid  \ngroups Group[]  \n}  \nmodel Group {  \nid String @id @default(uuid()) @db.Uuid  \nvalue Value @relation(fields: [valueId], references: [id], onDelete: Cascade)  \nvalueId String @unique @db.Uuid  \nviewConfig ViewConfig @relation(fields: [viewConfigId], references: [id],\nonDelete: Cascade)  \nviewConfigId String @unique @db.Uuid  \n}  \n  \nview raw metaSchema.prisma hosted with \u2764 by GitHub\n\nFeel free to build whatever you want from this abstraction and to get in touch\nif you have any question (martin@cycle.app). To see it in action, you can\naccess our API directly from our documentation.\n\nRead next\n\n## AI on a real-time app is hard\n\nRead next\n\n## Prisma with PostgreSQL: the hard things about building a no code database\n\nRead next\n\n## Launching the first self-organizing feedback hub\n\nRead next\n\n## Product discovery on top of Linear\n\nRead next\n\n## Deconstructing PLG\n\nRead next\n\n## Stop counting feature requests\n\nRead next\n\n## Building future proof data models: How Salesforce, Intercom and Cycle do it\n\nRead next\n\n## Why Product Managers Are the Co-Founders, Not CEOs, of Their Products\n\nRead next\n\n## Cycle's story\n\nRead next\n\n## Best Notion Alternative for Product Feedback\n\nRead next\n\n## Resilience, PH launches and my 3 biggest mistakes while building Cycle\n\nRead next\n\n## Don't prioritize based on what people ask\n\nRead next\n\n## The Product Manifesto: 15 principles to ship stuff people need\n\nRead next\n\n## Exploring Airsaas: How our oldest customer utilizes Cycle from Discovery to\nDelivery\n\nRead next\n\n## Crafting a new paradigm of company-wide agility - Cycle's impact on Juno\n\nRead next\n\n## Poppins' secret weapon for exceptional customer care\n\nRead next\n\n## Requirements for a feedback system that scales : moka's deep dive\n\nRead next\n\n## 10 psychological nudges used by the best B2B SaaS to nail user onboarding\n\nRead next\n\n## Scaling GraphQL with Postgres - Lessons learned from our database timeout\nissues\n\nRead next\n\n## How Fabriq's product workflows evolved as they scaled.\n\nRead next\n\n## How eFounders and Hexa use Cycle to ship MVPs in 3 months.\n\nRead next\n\n## How Kraaft opened the product black box and inspired a culture of\ntransparency with Cycle\n\nRead next\n\n## How Figures uses Cycle and nailed an efficient product delivery workflow\nthanks to Cycle\n\nRead next\n\n## How Choose built better products and enhanced Engagement with Cycle\n\nRead next\n\n## How Epoch became even more customer-centric with Cycle\n\nRead next\n\n## How Contrast uses Cycle to build out its feedback system as they grow\n\nRead next\n\n## Announcing Cycle 1.0 and our $6M Funding\n\nRead next\n\n## Launching Cycle beta \u26a1\ufe0f \ud83d\udeb2\n\nRead next\n\n## So you\u2019re building a \u201cSuperhuman of X\u201d?\n\n## Subscribe for updates\n\nJoin tens of thousands of subscribers Product insights, customer stories, and\nrelease notes straight to your inbox.\n\nThank you! Your subscription has been received!\n\nOops! Something went wrong while submitting the form.\n\nNo spam, ever.\n\n## Try Cycle today\n\nStart free trialExplore Cycle\n\n7-day free trial unlocked by onboarding call\n\n\u00a9 Cycle. 2024 \u2014 All rights reserved.\n\n### Explore\n\nDocs\n\nIntegrations\n\nSlack\n\nChangelog\n\nBlog\n\nPricing\n\nSecurity\n\n### Company\n\nManifesto\n\nPress Kit\n\nStatus\n\n### Legal\n\nTerms of Service\n\nPrivacy Policy\n\nProduct Hunt \u2014 2022\n\nProduct of the Week\n\n", "frontpage": false}
