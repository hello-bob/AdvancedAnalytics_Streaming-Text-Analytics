{"aid": "40234363", "title": "HTTP Fundamentals: Routing fetch() to an in-memory server instance", "url": "https://blog.platformatic.dev/http-fundamentals-routing-fetch-to-an-in-memory-server-instance", "domain": "platformatic.dev", "votes": 2, "user": "feross", "posted_at": "2024-05-02 09:46:56", "comments": 0, "source_title": "HTTP Fundamentals: Routing fetch() to an in-memory server instance", "source_text": "HTTP Fundamentals: Routing fetch() to an in-memory server instance\n\n# HTTP Fundamentals: Routing fetch() to an in-memory server instance\n\nMatteo Collina\n\n\u00b7May 2, 2024\u00b7\n\n3 min read\n\nIn web development, user interactions trigger backend actions, which rely\nheavily on efficient HTTP calls. Over time, HTTP has become the most popular\ninterface largely due to its robust security measures and ease of\ndebuggability.\n\nIn this blog, we\u2019ll provide you with a quick guide to understanding the\nconcept of HTTP and how to turbocharge it with Undici and Fastify.\n\n## HTTP: The Optimal Standard Interface\n\nWith the advent of RFC 9110, the semantics of the HTTP/1.1 and HTTP/2\nprotocols were distinctly delineated, accentuating the significance of the\nwiring format as a crucial implementation detail.\n\nDespite the emergence of three major versions\u2014HTTP/1.0, HTTP/1.1, and\nHTTP/2.0\u2014none has rendered the others obsolete. Instead, they coexist, each\noffering specific benefits and limitations depending on the usage context. RFC\n9110 coalesced all of them and provided shared semantics beyond individual\nprotocols, extending HTTP's versatility beyond network boundaries and\nfacilitating interactions through familiar libraries and APIs.\n\nIn this article, we are going to explain how we can route HTTP requests in\nmemory, without the need to perform any I/O. To do so, we are going to use\nUndici and Fastify.\n\n## Undici\n\nUndici is a modern HTTP/1.1 client library for Node.js, known for its\nefficiency and speed. Undici was designed to handle a large number of\nconcurrent requests with low overhead, and is built using Node.js's\nasynchronous I/O capabilities, making it suitable for applications requiring\nhigh throughput and low latency. Undici boasts over 30 million monthly\ndownloads.\n\n## Fastify\n\nFastify is one of the speediest web frameworks for Node.js, boasting an\nimpressive average of 6 million monthly downloads. With 17 collaborators and\ncurrently in its fourth iteration, Fastify offers a robust platform for web\ndevelopment.\n\n### Fastify-undici-dispatcher\n\nAs we have seen in https://blog.platformatic.dev/http-fundamentals-\nunderstanding-undici-and-its-working-mechanism, the underpinning of Undici are\nthe dispatchers. fastify-undici-dispatcher implements the Dispatcher interface\nto route HTTP requests targeting a local domain to a Fastify application.\nBelow is a demo of how this works:\n\n    \n    \n    const { request, Agent, setGlobalDispatcher } = require('undici') const server = Fastify() server.get('/', async (req, reply) => { return 'hello world' }) const dispatcher = new FastifyUndiciDispatcher({ dispatcher: new Agent(), // optional domain: '.local' // optional }) dispatcher.route('myserver', server) setGlobalDispatcher(dispatcher) const res = await fetch('http://myserver.local') console.log(await res.text())\n\nCan Undici dispatcher facilitate network HTTP implementation?\n\nNotably, Fastify comes equipped with embedded support for request injection,\nfacilitating seamless injection of HTTP requests. Below is a demonstration of\nthis capability:\n\n    \n    \n    import fastify from \"fastify\" const app = fastify(); app.get('/', async()=> 'hello world'); const res = await app.inject('/'); console.log(res.body.toString())\n\nThe FastifyUndiciDispatcher then internally calls the .inject() function to\ndeliver the incoming HTTP request.\n\nFastify implements this capability with the light-my-request library which\ninjects HTTP requests into a Node server. This library enables developers to\nmimic the functionality of http.createServer by passing in a function.\n\nBelow is a demonstration of integrating the library within a Node server.\n\n    \n    \n    const http = require('node:http') const inject = require('light-my-request') const dispatch = function (req, res) { const reply = 'Hello World' res.writeHead(200, { 'Content-Type': 'text/plain', 'Content-Length': reply.length }) res.end(reply) } const server = http.createServer(dispatch) inject(dispatch, { method: 'get', url: '/' }, (err, res) => { console.log(res.payload) })\n\n## Wrapping up\n\nHTTP calls form the backbone of production-level Node.js applications. Undici\noffers a standout Node.js HTTP library, as well as the underpinning of Node.js\nfetch() implementation.\n\nCombining Fastify with Undici within the fastify-undici-dispatcher library\nallows to implement in-memory HTTP calls from fetch(), enabling new use cases\nas patterns.\n\nThanks to this library, Platformatic can implement its runtime and control\nfunctionality.\n\n### Want to learn more about HTTP Clients?\n\nhttps://www.youtube.com/watch?v=LcBykd25NaU&list=PL_x4nRdxj60K2j9l_SflmqmaTA2XVBuqc\n\n  * Take a deep dive into HTTP Clients: Axios, Requests, and Node-Fetch\n\n  * Discover Undici and its working mechanism\n\nhttpplatformaticundicifetchfastifyhttpclient\n\n### Written by\n\n# Matteo Collina\n\n### Published on\n\n# Platformatic Blog\n\nShare this\n\n### More articles\n\nLuca Maraschi\n\n# Navigating Digital Architectures: A Roadmap for Technological Evolution\n\nThe architecture of our applications plays a pivotal role in determining their\nsuccess and adaptabil...\n\nMatteo Collina\n\n# HTTP Fundamentals: Understanding Undici and its Working Mechanism\n\nNavigating through Node.js http/https can be a daunting task that often calls\nfor updates. This is p...\n\nMatteo Collina\n\n# A Deep Dive into Meraki 1.0\n\nImagine this: your development team kicks off a new project which includes\ninnovative new features. ...\n\n\u00a92024 Platformatic Blog\n\nArchive\u00b7Privacy policy\u00b7Terms\n\nWrite on Hashnode\n\nPowered by Hashnode - Home for tech writers and readers\n\n", "frontpage": false}
