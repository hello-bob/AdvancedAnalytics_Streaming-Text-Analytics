{"aid": "40051775", "title": "Emulating a Fake Console", "url": "https://dogue.dev/blog/chip8/", "domain": "dogue.dev", "votes": 1, "user": "ingve", "posted_at": "2024-04-16 13:44:31", "comments": 0, "source_title": "dogue.dev", "source_text": "dogue.dev\n\n~dogue\n\n# Emulating A Fake Console\n\n2024-04-14\n\nI recently started on an emulator for the CHIP-8. I began the project in Go a\nfew days ago, but switched to Odin because goroutines are too easy and I\nhaven't done much work in Odin lately.\n\nDisclaimer: This post is not a tutorial on building an emulator. Instead,\nconsider it a brain dump. We'll take a look at how the CHIP-8 works, some\nimplementation choices, and an undocumented Odin core package.\n\n> The information in this post and my understanding of the CHIP-8 are largely\n> derived from this excellent guide by Tobias V. Langhoff. If you want to\n> build your own, it's a great place to start.\n>\n> The repo for my version can be found here.\n\n### fake console?\n\nAccording to Wikipedia, \"CHIP-8 is an interpreted programming language\".\n\nWhile the CHIP-8 never existed as hardware, for all intents and purposes we\nwill be treating it as if it did. This means we'll be dealing with registers,\na stack, memory, a display, instructions, etc.\n\nThe CHIP-8 specification is pretty straightforward:\n\n  * 4096 bytes of memory with direct access\n  * 64x32 pixel monochrome display\n  * 16 bit program counter\n  * 16 bit index register for pointing to memory\n  * a stack for 16 bit addresses\n  * two 8 bit timers for delay and sound\n  * 16 8-bit general purpose \"variable\" registers\n\nInterestingly, it uses 16 bit opcodes that are interpreted as four nibbles. A\ngreat example of this is the drawing instruction DXYN. The entire opcode is 16\nbits with the first 4 specifying the type of instruction (D). The second and\nthird sets of 4 bits (X and Y) specify which of the V registers contain the\ncoordinates at which to draw. The final nibble (N) specifies the height of the\nsprite in pixels.\n\nAs of the time of writing this post, I've only implemented the bare minimum\ninstruction set required to run the IBM logo test program. Those instructions\nare:\n\n  * 00E0 clear screen\n  * 1NNN jump to NNN\n  * 6XNN set VX to NN\n  * 7XNN add NN to VX\n  * ANNN set index register to NNN\n  * DXYN draw\n\nIf you'd like to dive deeper into the workings of the CHIP-8, I very much\nrecommend the Tobias Langhoff post linked above.\n\n### implementation\n\nI'm using Raylib for the windowing/drawing parts of the project. Rather than\ncalling into Raylib while executing the draw instruction, I decided to\nslightly overengineer the problem.\n\nI've been wanting to do more with threads as it's a weak point in my skillset\nand this is a place where it makes sense (at least in theory). By spinning the\nemulator execution off into its own thread, I can keep the framerate at 60\nwhile the emulator runs as fast as it is able. I haven't done any profiling to\nsee if this actually matters performance-wise, but that wasn't the point.\n\nThe pixel buffer is represented as a two-dimensional array of booleans in row-\ncol (arr[y][x]) order internally. When the draw instruction is finished it\nsends the entire buffer to the render thread. Here, we iterate over the buffer\nand draw each true (or \"on\" pixel) as a 16x16 white square. This effectively\nupscales the 64x32 native resolution of the CHIP-8 to a friendlier 1024x512.\n\n### undocumented fun\n\nThat begs the question then, how do we get the pixel data from the emulator\nthread to the render thread?\n\nThis is where Go was really nice because it was as simple as creating a\nchannel and sending the data across it at the end of the draw instruction. But\nwe're not in Go anymore. If you search on Odin's package docs you won't find\nchannels anywhere.\n\nI considered for a bit using some good ol' shared mutable state behind a mutex\nbefore I remembered that some of Odin's packages aren't documented yet (and\nthus don't show on the site). So I did some digging in the repo and...\n\n_core/sync/chan/chan.odin\n\n    \n    \n    Chan :: struct($T: typeid, $D: Direction = Direction.Both) { #subtype impl: ^Raw_Chan `fmt:\"-\"`, }\n\nWelp. There ya go. Odin has channels too.\n\nLooking through the source for the package, it was pretty easy to figure out\nhow to use them.\n\n    \n    \n    import \"core:sync/chan\" PixBuf :: distinct [32][64]bool channel, err := chan.create_buffered( chan.Chan(PixBuf), 16, context.allocator, ) chan.send(channel, pixels)\n\nThis creates a buffered channel which passes a PixBuf type and can buffer up\nto 16 messages. The choice of a 16 wide buffered channel was arbitrary. It\nseems to run the IBM logo test just fine with an unbuffered channel. \u0304\\\\_(\u30c4)_/\n\u0304\n\n> Note: the send() and recv() procs in sync/chan are blocking. If you need\n> non-blocking behavior, you can use can_send() and can_recv() to check if the\n> call will block.\n\nThat's all I have right now. I may write up a second part to this when/if I\nget farther along with the project.\n\nThanks for reading! Read other posts?\n\n\u2190 What Makes Odin Fun?\n\n\u00a9 2024 dogue :: Theme: Terminimal by pawroman\n\n", "frontpage": false}
