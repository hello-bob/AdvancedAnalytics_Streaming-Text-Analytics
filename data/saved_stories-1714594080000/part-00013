{"aid": "40221810", "title": "The Mediocre Programmer's Guide to Rust", "url": "https://www.hezmatt.org/~mpalmer/blog/2024/05/01/the-mediocre-programmers-guide-to-rust.html", "domain": "hezmatt.org", "votes": 2, "user": "LorenDB", "posted_at": "2024-05-01 11:20:20", "comments": 0, "source_title": "Brane Dump: The Mediocre Programmer's Guide to Rust", "source_text": "Brane Dump: The Mediocre Programmer's Guide to Rust\n\n# Brane Dump\n\nThe thoughts of Matt Palmer\n\n  * BlogNav:\n  * Archive of all posts\n\n# The Mediocre Programmer's Guide to Rust\n\nPosted: Wed, 1 May 2024 | permalink | No comments\n\n> Me: \u201cHi everyone, my name\u2019s Matt, and I\u2019m a mediocre programmer.\u201d\n>\n> Everyone: \u201cHi, Matt.\u201d\n>\n> Facilitator: \u201cAre you an alcoholic, Matt?\u201d\n>\n> Me: \u201cNo, not since I stopped reading Twitter.\u201d\n>\n> Facilitator: \u201cThen I think you\u2019re in the wrong room.\u201d\n\nYep, that\u2019s my little secret \u2013 I\u2019m a mediocre programmer. The definition of\nthe word \u201chacker\u201d I most closely align with is \u201csomeone who makes furniture\nwith an axe\u201d. I write simple, straightforward code because trying to\nunderstand complexity makes my head hurt.\n\nWhich is why I\u2019ve always avoided the more \u201cacademic\u201d languages, like OCaml,\nHaskell, Clojure, and so on. I know they\u2019re good languages \u2013 people far\nsmarter than me are building amazing things with them \u2013 but the time I hear\nthe word \u201cendofunctor\u201d, I\u2019ve lost all focus (and most of my will to live). My\npreferred languages are the ones that come with less intellectual overhead,\nlike C, PHP, Python, and Ruby.\n\nSo it\u2019s interesting that I\u2019ve embraced Rust with significant vigour. It\u2019s by\nfar the most \u201ccomplicated\u201d language that I feel at least vaguely comfortable\nwith using \u201cin anger\u201d. Part of that is that I\u2019ve managed to assemble a set of\nprinciples that allow me to almost completely avoid arguing with Rust\u2019s\ndreaded borrow checker, lifetimes, and all the rest of the dark, scary corners\nof the language. It\u2019s also, I think, that Rust helps me to write better\nsoftware, and I can feel it helping me (almost) all of the time.\n\nIn the spirit of helping my fellow mediocre programmers to embrace Rust, I\npresent the principles I\u2019ve assembled so far.\n\n# Neither a Borrower Nor a Lender Be\n\nIf you know anything about Rust, you probably know about the dreaded \u201cborrow\nchecker\u201d. It\u2019s the thing that makes sure you don\u2019t have two pieces of code\ntrying to modify the same data at the same time, or using a value when it\u2019s no\nlonger valid.\n\nWhile Rust\u2019s borrowing semantics allow excellent performance without\ncompromising safety, for us mediocre programmers it gets very complicated,\nvery quickly. So, the moment the compiler wants to start talking about\n\u201cexplicit lifetimes\u201d, I shut it up by just using \u201cowned\u201d values instead.\n\nIt\u2019s not that I never borrow anything; I have some situations that I know are\n\u201cborrow-safe\u201d for the mediocre programmer (I\u2019ll cover those later). But any\ntime I\u2019m not sure how things will pan out, I\u2019ll go straight for an owned\nvalue.\n\nFor example, if I need to store some text in a struct or enum, it\u2019s going\nstraight into a String. I\u2019m not going to start thinking about lifetimes and\n&'a str; I\u2019ll leave that for smarter people. Similarly, if I need a list of\nthings, it\u2019s a Vec<T> every time \u2013 no &'b [T] in my structs, thank you very\nmuch.\n\n# Attack of the Clones\n\nFollowing on from the above, I\u2019ve come to not be afraid of .clone(). I scatter\nthem around my code like seeds in a field. Life\u2019s too short to spend time\ntrying to figure out who\u2019s borrowing what from whom, if I can just give\neveryone their own thing.\n\nThere are warnings in the Rust book (and everywhere else) about how a clone\ncan be \u201cexpensive\u201d. While it\u2019s true that, yes, making clones of data\nstructures consumes CPU cycles and memory, it very rarely matters. CPU cycles\nare (usually) plentiful and RAM (usually) relatively cheap. Mediocre\nprogrammer mental effort is expensive, and not to be spent on premature\noptimisation. Also, if you\u2019re coming from most any other modern language, Rust\nis already giving you so much more performance that you\u2019re probably ending up\nahead of the game, even if you .clone() everything in sight.\n\nIf, by some miracle, something I write gets so popular that the \u201cexpense\u201d of\nall those spurious clones becomes a problem, it might make sense to pay\nsomeone much smarter than I to figure out how to make the program a zero-copy\nmasterpiece of efficient code. Until then... clone early and clone often, I\nsay!\n\n# Derive Macros are Powerful Magicks\n\nIf you start .clone()ing everywhere, pretty quickly you\u2019ll be hit with this\nerror:\n\n    \n    \n    error[E0599]: no method named `clone` found for struct `Foo` in the current scope\n\nThis is because not everything can be cloned, and so if you want your thing to\nbe cloned, you need to implement the method yourself. Well... sort of.\n\nOne of the things that I find absolutely outstanding about Rust is the \u201cderive\nmacro\u201d. These allow you to put a little marker on a struct or enum, and the\ncompiler will write a bunch of code for you! Clone is one of the available so-\ncalled \u201cderivable traits\u201d, so you add #[derive(Clone)] to your structs, and\npoof! you can .clone() to your heart\u2019s content.\n\nBut there are other things that are commonly useful, and so I\u2019ve got a set of\ntraits that basically all of my data structures derive:\n\n    \n    \n    #[derive(Clone, Debug, Default)] struct Foo { // ... }\n\nEvery time I write a struct or enum definition, that line #[derive(Clone,\nDebug, Default)] goes at the top.\n\nThe Debug trait allows you to print a \u201cdebug\u201d representation of the data\nstructure, either with the dbg!() macro, or via the {:?} format in the\nformat!() macro (and anywhere else that takes a format string). Being able to\nsay \u201cwhat exactly is that?\u201d comes in handy so often, not having a Debug\nimplementation is like programming with one arm tied behind your Aeron.\n\nMeanwhile, the Default trait lets you create an \u201cempty\u201d instance of your data\nstructure, with all of the fields set to their own default values. This only\nworks if all the fields themselves implement Default, but a lot of standard\ntypes do, so it\u2019s rare that you\u2019ll define a structure that can\u2019t have an auto-\nderived Default. Enums are easily handled too, you just mark one variant as\nthe default:\n\n    \n    \n    #[derive(Clone, Debug, Default)] enum Bar { Something(String), SomethingElse(i32), #[default] // <== mischief managed Nothing, }\n\n# Borrowing is OK, Sometimes\n\nWhile I previously said that I like and usually use owned values, there are a\nfew situations where I know I can borrow without angering the borrow checker\ngods, and so I\u2019m comfortable doing it.\n\nThe first is when I need to pass a value into a function that only needs to\ntake a little look at the value to decide what to do. For example, if I want\nto know whether any values in a Vec<u32> are even, I could pass in a Vec, like\nthis:\n\n    \n    \n    fn main() { let numbers = vec![0u32, 1, 2, 3, 4, 5]; if has_evens(numbers) { println!(\"EVENS!\"); } } fn has_evens(numbers: Vec<u32>) -> bool { numbers.iter().any(|n| n % 2 == 0) }\n\nHowver, this gets ugly if I\u2019m going to use numbers later, like this:\n\n    \n    \n    fn main() { let numbers = vec![0u32, 1, 2, 3, 4, 5]; if has_evens(numbers) { println!(\"EVENS!\"); } // Compiler complains about \"value borrowed here after move\" println!(\"Sum: {}\", numbers.iter().sum::<u32>()); } fn has_evens(numbers: Vec<u32>) -> bool { numbers.iter().any(|n| n % 2 == 0) }\n\nHelpfully, the compiler will suggest I use my old standby, .clone(), to fix\nthis problem. But I know that the borrow checker won\u2019t have a problem with\nlending that Vec<u32> into has_evens() as a borrowed slice, &[u32], like this:\n\n    \n    \n    fn main() { let numbers = vec![0u32, 1, 2, 3, 4, 5]; if has_evens(&numbers) { println!(\"EVENS!\"); } } fn has_evens(numbers: &[u32]) -> bool { numbers.iter().any(|n| n % 2 == 0) }\n\nThe general rule I\u2019ve got is that if I can take advantage of lifetime elision\n(a fancy term meaning \u201cthe compiler can figure it out\u201d), I\u2019m probably OK. In\nless fancy terms, as long as the compiler doesn\u2019t tell me to put 'a anywhere,\nI\u2019m in the green. On the other hand, the moment the compiler starts using the\nwords \u201cexplicit lifetime\u201d, I nope the heck out of there and start cloning\neverything in sight.\n\nAnother example of using lifetime elision is when I\u2019m returning the value of a\nfield from a struct or enum. In that case, I can usually get away with\nreturning a borrowed value, knowing that the caller will probably just be\ntaking a peek at that value, and throwing it away before the struct itself\ngoes out of scope. For example:\n\n    \n    \n    struct Foo { id: u32, desc: String, } impl Foo { fn description(&self) -> &str { &self.desc } }\n\nReturning a reference from a function is practically always a mortal sin for\nmediocre programmers, but returning one from a struct method is often OK. In\nthe rare case that the caller does want the reference I return to live for\nlonger, they can always turn it into an owned value themselves, by calling\n.to_owned().\n\n# Avoid the String Tangle\n\nRust has a couple of different types for representing strings \u2013 String and\n&str being the ones you see most often. There are good reasons for this,\nhowever it complicates method signatures when you just want to take some sort\nof \u201cbunch of text\u201d, and don\u2019t care so much about the messy details.\n\nFor example, let\u2019s say we have a function that wants to see if the length of\nthe string is even. Using the logic that since we\u2019re just taking a peek at the\nvalue passed in, our function might take a string reference, &str, like this:\n\n    \n    \n    fn is_even_length(s: &str) -> bool { s.len() % 2 == 0 }\n\nThat seems to work fine, until someone wants to check a formatted string:\n\n    \n    \n    fn main() { // The compiler complains about \"expected `&str`, found `String`\" if is_even_length(format!(\"my string is {}\", std::env::args().next().unwrap())) { println!(\"Even length string\"); } }\n\nSince format! returns an owned string, String, rather than a string reference,\n&str, we\u2019ve got a problem. Of course, it\u2019s straightforward to turn the String\nfrom format!() into a &str (just prefix it with an &). But as mediocre\nprogrammers, we can\u2019t be expected to remember which sort of string all our\nfunctions take and add & wherever it\u2019s needed, and having to fix everything\nwhen the compiler complains is tedious.\n\nThe converse can also happen: a method that wants an owned String, and we\u2019ve\ngot a &str (say, because we\u2019re passing in a string literal, like \"Hello,\nworld!\"). In this case, we need to use one of the plethora of available \u201cturn\nthis into a String\u201d mechanisms (.to_string(), .to_owned(), String::from(), and\nprobably a few others I\u2019ve forgotten), on the value before we pass it in,\nwhich gets ugly real fast.\n\nFor these reasons, I never take a String or an &str as an argument. Instead, I\nuse the Power of Traits to let callers pass in anything that is, or can be\nturned into, a string. Let us have some examples.\n\nFirst off, if I would normally use &str as the type, I instead use impl\nAsRef<str>:\n\n    \n    \n    fn is_even_length(s: impl AsRef<str>) -> bool { s.as_ref().len() % 2 == 0 }\n\nNote that I had to throw in an extra as_ref() call in there, but now I can\ncall this with either a String or a &str and get an answer.\n\nNow, if I want to be given a String (presumably because I plan on taking\nownership of the value, say because I\u2019m creating a new instance of a struct\nwith it), I use impl Into<String> as my type:\n\n    \n    \n    struct Foo { id: u32, desc: String, } impl Foo { fn new(id: u32, desc: impl Into<String>) -> Self { Self { id, desc: desc.into() } } }\n\nWe have to call .into() on our desc argument, which makes the struct building\na bit uglier, but I\u2019d argue that\u2019s a small price to pay for being able to call\nboth Foo::new(1, \"this is a thing\") and Foo::new(2, format!(\"This is a thing\nnamed {name}\")) without caring what sort of string is involved.\n\n# Always Have an Error Enum\n\nRust\u2019s error handing mechanism (Results... everywhere), along with the\nquality-of-life sugar surrounding it (like the short-circuit operator, ?), is\na delightfully ergonomic approach to error handling. To make life easy for\nmediocre programmers, I recommend starting every project with an Error enum,\nthat derives thiserror::Error, and using that in every method and function\nthat returns a Result.\n\nHow you structure your Error type from there is less cut-and-dried, but\ntypically I\u2019ll create a separate enum variant for each type of error I want to\nhave a different description. With thiserror, it\u2019s easy to then attach those\ndescriptions:\n\n    \n    \n    #[derive(Clone, Debug, thiserror::Error)] enum Error { #[error(\"{0} caught fire\")] Combustion(String), #[error(\"{0} exploded\")] Explosion(String), }\n\nI also implement functions to create each error variant, because that allows\nme to do the Into<String> trick, and can sometimes come in handy when creating\nerrors from other places with .map_err() (more on that later). For example,\nthe impl for the above Error would probably be:\n\n    \n    \n    impl Error { fn combustion(desc: impl Into<String>) -> Self { Self::Combustion(desc.into()) } fn explosion(desc: impl Into<String>) -> Self { Self::Explosion(desc.into()) } }\n\nIt\u2019s a tedious bit of boilerplate, and you can use the thiserror-ext crate\u2019s\nthiserror_ext::Construct derive macro to do the hard work for you, if you\nlike. It, too, knows all about the Into<String> trick.\n\n# Banish map_err (well, mostly)\n\nThe newer mediocre programmer, who is just dipping their toe in the water of\nRust, might write file handling code that looks like this:\n\n    \n    \n    fn read_u32_from_file(name: impl AsRef<str>) -> Result<u32, Error> { let mut f = File::open(name.as_ref()) .map_err(|e| Error::FileOpenError(name.as_ref().to_string(), e))?; let mut buf = vec![0u8; 30]; f.read(&mut buf) .map_err(|e| Error::ReadError(e))?; String::from_utf8(buf) .map_err(|e| Error::EncodingError(e))? .parse::<u32>() .map_err(|e| Error::ParseError(e)) }\n\nThis works great (or it probably does, I haven\u2019t actually tested it), but\nthere are a lot of .map_err() calls in there. They take up over half the\nfunction, in fact. With the power of the From trait and the magic of the ?\noperator, we can make this a lot tidier.\n\nFirst off, assume we\u2019ve written boilerplate error creation functions (or used\nthiserror_ext::Construct to do it for us)). That allows us to simplify the\nfile handling portion of the function a bit:\n\n    \n    \n    fn read_u32_from_file(name: impl AsRef<str>) -> Result<u32, Error> { let mut f = File::open(name.as_ref()) // We've dropped the `.to_string()` out of here... .map_err(|e| Error::file_open_error(name.as_ref(), e))?; let mut buf = vec![0u8; 30]; f.read(&mut buf) // ... and the explicit parameter passing out of here .map_err(Error::read_error)?; // ...\n\nIf that latter .map_err() call looks weird, without the |e| and such, it\u2019s\npassing a function-as-closure, which just saves on a few characters typing.\nJust because we\u2019re mediocre, doesn\u2019t mean we\u2019re not also lazy.\n\nNext, if we implement the From trait for the other two errors, we can make the\nstring-handling lines significantly cleaner. First, the trait impl:\n\n    \n    \n    impl From<std::string::FromUtf8Error> for Error { fn from(e: std::string::FromUtf8Error) -> Self { Self::EncodingError(e) } } impl From<std::num::ParseIntError> for Error { fn from(e: std::num::ParseIntError) -> Self { Self::ParseError(e) } }\n\n(Again, this is boilerplate that can be autogenerated, this time by adding a\n#[from] tag to the variants you want a From impl on, and thiserror will take\ncare of it for you)\n\nIn any event, no matter how you get the From impls, once you have them, the\nstring-handling code becomes practically error-handling-free:\n\n    \n    \n    Ok( String::from_utf8(buf)? .parse::<u32>()? )\n\nThe ? operator will automatically convert the error from the types returned\nfrom each method into the return error type, using From. The only tiny\ndownside to this is that the ? at the end strips the Result, and so we\u2019ve got\nto wrap the returned value in Ok() to turn it back into a Result for\nreturning. But I think that\u2019s a small price to pay for the removal of those\n.map_err() calls.\n\nIn many cases, my coding process involves just putting a ? after every call\nthat returns a Result, and adding a new Error variant whenever the compiler\ncomplains about not being able to convert some new error type. It\u2019s\npractically zero effort \u2013 outstanding outcome for the mediocre programmer.\n\n# Just Because You\u2019re Mediocre, Doesn\u2019t Mean You Can\u2019t Get Better\n\nTo finish off, I\u2019d like to point out that mediocrity doesn\u2019t imply shoddy\nwork, nor does it mean that you shouldn\u2019t keep learning and improving your\ncraft. One book that I\u2019ve recently found extremely helpful is Effective Rust,\nby David Drysdale. The author has very kindly put it up to read online, but\nbuying a (paper or ebook) copy would no doubt be appreciated.\n\nThe thing about this book, for me, is that it is very readable, even by us\nmediocre programmers. The sections are written in a way that really \u201cclicked\u201d\nwith me. Some aspects of Rust that I\u2019d had trouble understanding for a long\ntime \u2013 such as lifetimes and the borrow checker, and particularly lifetime\nelision \u2013 actually made sense after I\u2019d read the appropriate sections.\n\n# Finally, a Quick Beg\n\nI\u2019m currently subsisting on the kindness of strangers, so if you found\nsomething useful (or entertaining) in this post, why not buy me a refreshing\nbeverage? It helps to know that people like what I\u2019m doing, and helps keep me\nfrom having to sell my soul to a private equity firm.\n\n# Post a comment\n\nAll comments are held for moderation; markdown formatting accepted.\n\n\u00ab How I Tripped Over the Debian Weak Keys Vulnerability\n\nPowered by Jekyll!\n\n", "frontpage": false}
