{"aid": "40173986", "title": "Design Principles Behind Smalltalk", "url": "https://www.cs.virginia.edu/%7Eevans/cs655/readings/smalltalk.html", "domain": "virginia.edu", "votes": 2, "user": "smartmic", "posted_at": "2024-04-26 20:37:29", "comments": 0, "source_title": "Design Principles Behind Smalltalk", "source_text": "Design Principles Behind Smalltalk\n\nUniversity of Virginia, Department of Computer Science CS655: Programming\nLanguages Spring 2001\n\n# Design Principles Behind Smalltalk\n\nDaniel H. H. Ingalls Learning Research Group Xerox Palo Alto Research Center\n\nBYTE Magazine, August 1981. (c) by The McGraw-Hill Companies, Inc., NY. Copied\nfrom\nhttp://users.ipa.net/~dwighth/smalltalk/byte_aug81/design_principles_behind_smalltalk.html\nScanned in and converted to HTML (with recreated graphics) by Dwight Hughes.\n\nThe purpose of the Smalltalk project is to provide computer support for the\ncreative spirit in everyone. Our work flows from a vision that includes a\ncreative individual and the best computing hardware available. We have chosen\nto concentrate on two principle areas of research: a language of description\n(programming language) that serves as an interface between the models in the\nhuman mind and those in computing hardware, and a language of interaction\n(user interface) that matches the human communication system to that of the\ncomputer. Our work has followed a two- to four-year cycle that can be seen to\nparallel the scientific method:\n\n  * Build an application program within the current system (make an observation)\n  * Based on that experience, redesign the language (formulate a theory)\n  * Build a new system based on the new design (make a prediction that can be tested)\n\nThe Smalltalk-80 system marks our fifth time through this cycle. In this\narticle, I present some of the general principles we have observed in the\ncourse of our work. While the presentation frequently touches on Smalltalk\n\"motherhood\", the principles themselves are more general and should prove\nuseful in evaluating other systems and in guiding future work. Just to get\nwarmed up, I'll start with a principle that is more social than technical and\nthat is largely responsible for the particular bias of the Smalltalk project:\n\n    Personal Mastery: If a system is to serve the creative spirit, it must be entirely comprehensible to a single individual.\n\nThe point here is that the human potential manifests itself in individuals. To\nrealize this potential, we must provide a medium that can be mastered by a\nsingle individual. Any barrier that exists between the user and some part of\nthe system will eventually be a barrier to creative expression. Any part of\nthe system that cannot be changed or that is not sufficiently general is a\nlikely source of impediment. If one part of the system works differently from\nall the rest, that part will require additional effort to control. Such an\nadded burden may detract from the final result and will inhibit future\nendeavors in that area. We can thus infer a general principle of design:\n\n    Good Design: A system should be built with a minimum set of unchangeable parts; those parts should be as general as possible; and all parts of the system should be held in a uniform framework.\n\nLanguage In designing a language for use with computers, we do not have to\nlook far to find helpful hints. Everything we know about how people think and\ncommunicate is applicable. The mechanisms of human thought and communication\nhave been engineered for millions of years, and we should respect them as\nbeing of sound design. Moreover, since we must work with this design for the\nnext million years, it will save time if we make our computer models\ncompatible with the mind, rather that the other way around. Figure 1\nillustrates the principle components in our discussion. A person is presented\nas having a body and a mind. The body is the site of primary experience, and,\nin the context of this discussion, it is the physical channel through which\nthe universe is perceived and through which intentions are carried out.\nExperience is recorded and processed in the mind. Creative thought (without\ngoing into its mechanism) can be viewed as the spontaneous appearance of\ninformation in the mind. Language is the key to that information:\n\n    Purpose of Language: To provide a framework for communication.\n\nThe interaction between two individuals is represented in figure 1 as two\narcs. The solid arc represents explicit communication: the actual words and\nmovements uttered and perceived. The dashed arc represents implicit\ncommunication: the shared culture and experience that form the context of the\nexplicit communication. In human interaction, much of the actual communication\nis achieved through reference to shared context, and human language is built\naround such allusion. This is the case with computers as well. It is no\ncoincidence that a computer can be viewed as one of the participants in figure\n1. In this case, the \"body\" provides for visual display of information and for\nsensing input from a human user. The \"mind\" of a computer includes the\ninternal memory and processing elements and their contents. Figure 1 shows\nthat several different issues are involved in the design of a computer\nlanguage:\n\n    Scope: The design of a language for using computers must deal with internal models, external media, and the interaction between these in both the human and the computer.\n\nThis fact is responsible for the difficulty of explaining Smalltalk to people\nwho view computer languages in a more restricted sense. Smalltalk is not\nsimply a better way of organizing procedures or a different technique for\nstorage management. It is not just an extensible hierarchy of data types, or a\ngraphical user interface. It is all of these things and anything else that is\nneeded to support the interactions shown in figure 1.\n\nFigure 1: The scope of language design. Communication between two people (or\nbetween one person and a computer) includes communication on two levels.\nExplicit communication includes the information that is transmitted in a given\nmessage. Implicit communication includes the relevant assumptions common to\nthe two beings.  \n---  \n  \nCommunicating Objects The mind observes a vast universe of experience, both\nimmediate and recorded. One can derive a sense of oneness with the universe\nsimply by letting this experience be, just as it is. However, if one wishes to\nparticipate, literally to take a part, in the universe, one must draw\ndistinctions. In so doing one identifies an object in the universe, and\nsimultaneously all the rest becomes not-that-object. Distinction by itself is\na start, but the process of distinguishing does not get any easier. Every time\nyou want to talk about \"that chair over there\", you must repeat the entire\nprocesses of distinguishing that chair. This is where the act of reference\ncomes in: we can associate a unique identifier with an object, and, from that\ntime on, only the mention of that identifier is necessary to refer to the\noriginal object. We have said that a computer system should provide models\nthat are compatible with those in the mind. Therefore:\n\n    Objects: A computer language should support the concept of \"object\" and provide a uniform means for referring to the objects in its universe.\n\nThe Smalltalk storage manager provides an object-oriented model of memory for\nthe entire system. Uniform reference is achieved simply by associating a\nunique integer with every object in the system. This uniformity is important\nbecause it means that variables in the system can take on widely differing\nvalues and yet can be implemented as simple memory cells. Objects are created\nwhen expressions are evaluated, and they can be passed around by uniform\nreference, so that no provision for their storage is necessary in the\nprocedures that manipulate them. When all references to an object have\ndisappeared from the system, the object itself vanishes, and its storage is\nreclaimed. Such behavior is essential to full support of the object metaphor:\n\n    Storage Management: To be truly \"object-oriented\", a computer system must provide automatic storage management.\n\nA way to find out if a language is working well is to see if programs look\nlike they are doing what they are doing. If they are sprinkled with statements\nthat relate to the management of storage, then their internal model is not\nwell matched to that of humans. Can you imagine having to prepare someone for\neach thing you tell them or having to inform them when you are through with a\ngiven topic and that it can be forgotten? Each object in our universe has a\nlife of its own. Similarly, the brain provides for independent processing\nalong with storage of each mental object. This suggests a third principle of\ndesign:\n\n    Messages: Computing should be viewed as an intrinsic capability of objects that can be uniformly invoked by sending messages.\n\nJust as programs get messy if object storage is dealt with explicitly, control\nin the system becomes complicated if processing is performed extrinsically.\nLet us consider the process of adding 5 to a number. In most computer systems,\nthe compiler figures out what kind of number it is and generates code to add 5\nto it. This is not good enough for an object-oriented system because the exact\nkind of number cannot be determined by the compiler (more on this later). A\npossible solution is to call a general addition routine that examines the type\nof the arguments to determine the approximate action. This is not a good\napproach because it means that this critical routine must be edited by novices\nwho just want to experiment with their own class of numbers. It is also a poor\ndesign because intimate knowledge about the internals of objects is sprinkled\nthroughout the system. Smalltalk provides a much cleaner solution: it sends\nthe name of the desired operation, along with any arguments, as a message to\nthe number, with the understanding that the receiver knows best how to carry\nout the desired operation. Instead of a bit-grinding processor raping and\nplundering data structures, we have a universe of well-behaved objects that\ncourteously ask each other to carry out their various desires. The\ntransmission of messages is the only process that is carried on outside of\nobjects and this is as it should be, since messages travel between objects.\nThe principle of good design can be restated for languages:\n\n    Uniform Metaphor: A language should be designed around a powerful metaphor that can be uniformly applied in all areas.\n\nExamples of success in this area include LISP, which is built on the model of\nlinked structures; APL, which is built on the model of arrays; and Smalltalk,\nwhich is built on the model of communicating objects. In each case, large\napplications are viewed in the same way as the fundamental units from which\nthe system is built. In Smalltalk especially, the interaction between the most\nprimitive objects is viewed in the same way as the highest-level interaction\nbetween the computer and its user. Every object in Smalltalk, even a lowly\ninteger, has a set of messages, a protocol, that defines the explicit\ncommunication to which that object can respond. Internally, objects may have\nlocal storage and access to other shared information which comprise the\nimplicit context of all communication. For instance, the message + 5 (add\nfive) carries an implicit assumption that the augend is the present value of\nthe number receiving the message.\n\nOrganization A uniform metaphor provides a framework in which complex systems\ncan be built. Several related organizational principles contribute to the\nsuccessful management of complexity. To begin with:  \n\nModularity: No component in a complex system should depend on the internal\ndetails of any other component.\n\nFigure 2: System complexity. As the number of components in a system\nincreases, the chances for unwanted interaction increase rapidly. Because of\nthis, a computer language should be designed to minimize the possibilities of\nsuch interdependence.  \n---  \n  \nThis principle is depicted in figure 2. If there are N components in a system,\nthen there are roughly N-squared potential dependencies between them. If\ncomputer systems are ever to be of assistance in complex human tasks, they\nmust be designed to minimize such interdependence. The message-sending\nmetaphor provides modularity by decoupling the intent of a message (embodied\nin its name) from the method used by the recipient to carry out the intent.\nStructural information is similarly protected because all access to the\ninternal state of an object is through this same message interface. The\ncomplexity of a system can often be reduced by grouping similar components.\nSuch grouping is achieved through data typing in conventional programming\nlanguages, and through classes in Smalltalk. A class describes other objects\n-- their internal state, the message protocol they recognize, and the internal\nmethods for responding to those messages. The objects so described are called\ninstances of that class. Even classes themselves fit into this framework; they\nare just instances of class Class, which describes the appropriate protocol\nand implementation for object description.\n\n    Classification: A language must provide a means for classifying similar objects, and for adding new classes of objects on equal footing with the kernel classes of the system.\n\nClassification is the objectification of nessness. In other words, when a\nhuman sees a chair, the experience is taken both literally an \"that very\nthing\" and abstractly as \"that chair-like thing\". Such abstraction results\nfrom the marvelous ability of the mind to merge \"similar\" experience, and this\nabstraction manifests itself as another object in the mind, the Platonic chair\nor chairness. Classes are the chief mechanism for extension in Smalltalk. For\ninstance, a music system would be created by adding new classes that describe\nthe representation and interaction protocol of Note, Melody, Score, Timbre,\nPlayer, and so on. The \"equal footing\" clause of the above principle is\nimportant because it insures that the system will be used as it was designed.\nIn other words, a melody could be represented as an ad hoc collection of\nIntegers representing pitch, duration, and other parameters, but if the\nlanguage can handle Notes as easily as Integers, then the user will naturally\ndescribe a melody as a collection of Notes. At each stage of design, a human\nwill naturally choose the most effective representation if the system provides\nfor it. The principle of modularity has an interesting implication for the\nprocedural components in a system:\n\n    Polymorphism: A program should specify only the behavior of objects, not their representation.\n\nA conventional statement of this principle is that a program should never\ndeclare that a given object is a SmallInteger or a LargeInteger, but only that\nit responds to integer protocol. Such generic description is crucial to models\nof the real world. Consider an automobile traffic simulation. Many procedures\nin such a system will refer to the various vehicles involved. Suppose one\nwished to add, say, a street sweeper. Substantial amounts of computation (in\nthe form of recompiling) and possible errors would be involved in making this\nsimple extension if the code depended on the objects it manipulates. The\nmessage interface establishes an ideal framework for such an extension.\nProvided that street sweepers support the same protocol as all other vehicles,\nno changes are needed to include them in the simulation:\n\n    Factoring: Each independent component in a system would appear in only one place.\n\nThere are many reasons for this principle. First of all, it saves time,\neffort, and space if additions to the system need only be made in one place.\nSecond, users can more easily locate a component that satisfies a given need.\nThird, in the absence of proper factoring, problems arise in synchronizing\nchanges and ensuring that all interdependent components are consistent. You\ncan see that a failure in factoring amounts to a violation of modularity.\nSmalltalk encourages well-factored designs through inheritance. Every class\ninherits behavior from its superclass. This inheritance extends through\nincreasingly general classes, ultimately ending with class Object which\ndescribes the default behavior of all objects in the system. In our traffic\nsimulation above, StreetSweeper (and all other vehicle classes) would be\ndescribed as a subclass of a general Vehicle class, thus inheriting\nappropriate default behavior and avoiding repetition of the same concepts in\nmany different places. Inheritance illustrates a further pragmatic benefit of\nfactoring:\n\n    Leverage: When a system is well factored, great leverage is available to users and implementers alike.\n\nTake the case of sorting an ordered collection of objects. In Smalltalk, the\nuser would define a message called sort in the class OrderedCollection. When\nthis has been done, all forms of ordered collections in the system will\ninstantly acquire this new capability through inheritance. As an aside, it is\nworth noting that the same method can alphabetize text as well as sort\nnumbers, since comparison protocol is recognized by the classes which support\nboth text and numbers. The benefits of structure for implementers are obvious.\nTo begin with, there will be fewer primitives to implement. For instance, all\ngraphics in Smalltalk are performed with a single primitive operation. With\nonly one task to do, an implementer can bestow loving attention on every\ninstruction, knowing that each small improvement in efficiency will be\namplified throughout the system. It is natural to ask what set of primitive\noperations would be sufficient to support an entire computing system. The\nanswer to this question is called a virtual machine specification:\n\n    Virtual Machine: A virtual machine specification establishes a framework for the application of technology.\n\nThe Smalltalk virtual machine establishes an object-oriented model for\nstorage, a message-oriented model for processing, and a bitmap model for\nvisual display of information. Through the use of microcode, and ultimately\nhardware, system performance can be improved dramatically without any\ncompromise to the other virtues of the system.\n\nUser Interface A user interface is simply a language in which most of the\ncommunication is visual. Because visual presentation overlaps heavily with\nestablished human culture, esthetics plays a very important role in this area.\nSince all capability of a computer system is ultimately delivered through the\nuser interface, flexibility is also essential here. An enabling condition for\nadequate flexibility of a user interface can be stated as an object-oriented\nprinciple:\n\n    Reactive Principle: Every component accessible to the user should be able to present itself in a meaningful way for observation and manipulation.\n\nThis criterion is well supported by the model of communicating objects. By\ndefinition, each object provides an appropriate message protocol for\ninteraction. This protocol is essentially a microlanguage particular to just\nthat kind of object. At the level of the user interface, the appropriate\nlanguage for each object on the screen is presented visually (as text, menus,\npictures) and sensed through keyboard activity and the use of a pointing\ndevice. It should be noted that operating systems seem to violate this\nprinciple. Here the programmer has to depart from an otherwise consistent\nframework of description, leave whatever context has been built up, and deal\nwith an entirely different and usually very primitive environment. This need\nnot be so:\n\n    Operating System: An operating system is a collection of things that don't fit into a language. There shouldn't be one.\n\nHere are some examples of conventional operating system components that have\nbeen naturally incorporated into the Smalltalk language:\n\n  * Storage management -- Entirely automatic. Objects are created by a message to their class and reclaimed when no further references to them exist. Expansion of the address space through virtual memory is similarly transparent.\n  * File system -- Included in the normal framework through objects such as Files and Directories with message protocols that support file access.\n  * Display handling -- The display is simply an instance of class Form, which is continually visible, and the graphical manipulation messages defined in that class are used to change the visible image.\n  * Keyboard Input -- The user input devices are similarly modeled as objects with appropriate messages for determining their state or reading their history as a sequence of events.\n  * Access to subsystems -- Subsystems are naturally incorporated as independent objects within Smalltalk: there they can draw on the large existing universe of description, and those that involve interaction with the user can participate as components in the user interface.\n  * Debugger -- The state of the Smalltalk processor is accessible as an instance of class Process that owns a chain of stack frames. The debugger is just a Smalltalk subsystem that has access to manipulate the state of a suspended process. It should be noted that nearly the only run-time error that can occur in Smalltalk is for a message not to be recognized by its receiver.\n\nSmalltalk has no \"operating system\" as such. The necessary primitive\noperations, such as reading a page from the disk, are incorporated as\nprimitive methods in response to otherwise normal Smalltalk messages.\n\nFuture Work As might be expected, work remains to be done on Smalltalk. The\neasiest part to describe is the continued application of the principles in\nthis paper. For example, the Smalltalk-80 system falls short in its factoring\nbecause it supports only hierarchical inheritance. Future Smalltalk systems\nwill generalize this model to arbitrary (multiple) inheritance. Also, message\nprotocols have not been formalized. The organization provides for protocols,\nbut it is currently only a matter of style for protocols to be consistent from\none class to another. This can be remedied easily by providing proper protocol\nobjects that can be consistently shared. This will then allow formal typing of\nvariables by protocol without losing the advantages of polymorphism. The other\nremaining work is less easy to articulate. There are clearly other aspects to\nhuman thought that have not been addressed in this paper. These must be\nidentified as metaphors that can complement the existing models of the\nlanguage. Sometimes the advance of computer systems seems depressingly slow.\nWe forget that steam engines were high-tech to our grandparents. I am\noptimistic about the situation. Computer systems are, in fact, getting simpler\nand, as a result, more usable. I would like to close with a general principle\nwhich governs this process:\n\n    Natural Selection: Languages and systems that are of sound design will persist, to be supplanted only by better ones.\n\nEven as the clock ticks, better and better computer support for the creative\nspirit is evolving. Help is on the way.\n\nUniversity of Virginia CS 655: Programming Languages| evans@cs.virginia.edu\nLast modified: Mon Mar 19 17:13:22 2001  \n---|---\n\n", "frontpage": false}
