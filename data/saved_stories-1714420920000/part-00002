{"aid": "40195763", "title": "Exploiting the NT Kernel in 24H2", "url": "https://exploits.forsale/24h2-nt-exploit/", "domain": "exploits.forsale", "votes": 1, "user": "lemper", "posted_at": "2024-04-29 08:03:59", "comments": 0, "source_title": "Exploiting the NT Kernel in 24H2: New Bugs in Old Code & Side Channels Against KASLR", "source_text": "Exploiting the NT Kernel in 24H2: New Bugs in Old Code & Side Channels Against\nKASLR\n\n# Exploiting the NT Kernel in 24H2: New Bugs in Old Code & Side Channels\nAgainst KASLR\n\n2024 - Apr 26 \u2022 gabe_k \u2022 mastodon\n\nSource code: https://github.com/exploits-forsale/24h2-nt-exploit\n\n## Background\n\nThe upcoming version of Windows 11, 24H2, is currently in public preview via\nthe Windows Insider Program. This post covers the process of discovering\nmultiple kernel vulnerabilities introduced in 24H2 and writing an exploit,\nincluding bypassing new hardening to kernel ASLR (KASLR).\n\nAll the vulnerabilities described here are in the NT kernel itself\n(ntoskrnl.exe), in syscalls which may be called by any process, regardless of\nits privilege level or sandbox.\n\n## New Bugs in Old Code\n\nWhile reverse engineering various parts of the NT kernel in 24H2 I discovered\ntwo vulnerabilities, both of which were double-fetches of user mode memory\n(credit: j00ru). These bugs were especially interesting because they appeared\nin long\u2013present code that had previously been safe.\n\n### Changes Regarding The Volatility of User Mode Memory\n\nI\u2019d like to start this section with a disclaimer: much of the following is\nbest-guess speculation. Without access to source code and the exact compiler\nused it is impossible to know with complete certainty what changed on\nMicrosoft\u2019s side to introduce the observed changes to the binaries.\n\nIn 24H2 there appears to have been broad changes made to treat user mode\nmemory as volatile within the kernel. One piece of evidence for this is the\naddition of a new memory copy function named RtlCopyVolatileMemory which, as\nthe name suggests, behaves exactly like RtlCopyMemory but explicitly for\naccessing volatile memory. Many instances where the kernel previously copied\nuser mode memory into kernel mode with inlined read and store instructions\nhave been replaced with calls to this new function. A few instances of this\ncan be seen below:\n\nCase 1: a 4-byte read from user mode memory in NtCreateTimer2\n\nCase 2: a 16-byte read from user mode memory in ObpCaptureBoundaryDescriptor\n\nThis change to treating user mode memory as volatile in 24H2 can also be seen\nin a public pull request on Microsoft\u2019s GitHub, in my view lending credibility\nto the theory that this was a wide-ranging change.\n\nThese changes also explain the appearance of double-fetches in areas where\nthey may previously have been hidden by compiler optimization. A traditional\ndouble-fetch in source code, dereferencing the same location in user mode\nmemory twice, may have been optimized into a single dereference in the\nresulting binary. If the memory location is treated as volatile however, every\ndereference in source code should correspond to a unique dereference in the\nbinary. Below I will detail the two vulnerabilities I found that I suspect are\na result of this pattern.\n\n### CVE-2024-26218: Double-Fetch in PspBuildCreateProcessContext Leads to\nStack Buffer Overflow\n\nWhen creating a process, various attributes about the process being created\nare provided to the NtCreateUserProcess syscall in a PS_ATTRIBUTE_LIST\nstructure. The PS_ATTRIBUTE_LIST is, as the name suggests, an array of\nPS_ATTRIBUTE structures. The PspBuildCreateProcessContext function processes\nthis list of attributes which reside in user mode memory.\n\nPspBuildCreateProcessContext contains a large number of cases for handling\neach type of attribute. When handling attributes of types\nPsAttributeMitigationOptions and PsAttributeMitigationAuditOptions there is a\ndouble-fetch of the Size field in the PS_ATTRIBUTE. By changing the value of\nSize in the time between the fetches it is possible to trigger a stack buffer\noverflow.\n\nBelow I have provided pseudo-code and the corresponding disassembly from the\nbinaries of the 23H2 version of the relevant code which does not contain a\ndouble-fetch, followed by the pseudo-code and disassembly for the vulnerable\nversion in 24H2.\n\n23H2\n\n24H2\n\nAs shown above, the change to treating the attribute as volatile results in\nwhat was previously a single dereference being replaced with two separate\ndereferences.\n\nA proof-of-concept for this bug is available on GitHub.\n\n### CVE-2024-21345: Double-Fetch in NtQueryInformationThread Leads to\nArbitrary Write\n\nThis bug is similar to the previous one in that it is once again double-\nfetching a length field in code that previously only contained a single fetch.\nIn contrast to the previous bug this bug does not lead to a buffer overflow,\nbut rather to the bypass of the probe of a user provided address. Bypassing a\nprobe allows a user to specify a completely arbitrary address, including a\nkernel address, to be written to.\n\nNtQueryInformationThread, like other NtQueryInformation* syscalls, contains a\ngigantic switch statement for handling different information classes that can\nbe passed in to query information about kernel objects from user mode. This\nspecific bug is in the handling of the ThreadTebInformation information class,\nwhich allows reading of parts of the thread\u2019s TEB. The input for this specific\ncase is a THREAD_TEB_INFORMATION structure residing in user mode memory. This\nstruct contains a destination pointer for where to store the TEB data, as well\nas a size specifying how much data to read from the TEB.\n\nThe code for this bug is less straightforward than the previous one. In this\nbug the user supplied struct is copied entirely into kernel mode, however,\nwhen performing a call to ProbeForWrite, the struct in user mode memory is\ndereferenced again to pass the size. For all uses of the user input after the\ncall to ProbeForWrite the kernel copy of the structure is used. ProbeForWrite\ncontains a little-known quirk: if a size of zero is passed the function will\nreturn immediately without checking the passed address. This means that if a\nkernel address is passed to ProbeForWrite with a size of zero, no exception\nwill be raised, thereby essentially bypassing the probe.\n\nAs in the previous case I have provided my pseudo-code representing how the\nsource code may look, alongside with the assembly from the binary, for both\nthe 23H2 binary which does not include the vulnerable as well as the\nvulnerable code in 24H2.\n\n23H2\n\n24H2\n\nAs the code above shows, by having BytesToRead in user mode be a non-zero\nvalue at the time of the first dereference, and then changing it to zero\nbefore the second dereference, the code will pass a size of zero to\nProbeForWrite, bypassing the check of the actual address and allowing a kernel\naddress to be specified. Later, when memmove is called, the size will be the\noriginal value of BytesToRead from the first dereference. This allows a copy\nof the contents of the TEB to be performed to a controlled address with a\ncontrolled size.\n\nBecause the TEB resides in user mode memory, the contents of it are also\ncontrollable. By writing to the TEB and then triggering this vulnerability to\nread from the TEB it is possible to write entirely controlled data anywhere in\nkernel mode memory.\n\nA proof-of-concept for this bug is available on GitHub.\n\n## KASLR in 24H2\n\nIn previous Windows versions defeating KASLR has been trivial due to a number\nof syscalls including kernel pointers in their output. In 24H2 however, as\ndocumented by Yarden Shafir in a blog post analyzing the change, these kernel\naddress leaks are no longer available to unprivileged callers.\n\nIn the absence of the classic KASLR bypasses, in order to determine the layout\nof the kernel a new technique is needed. I had heard of one technique used on\nLinux called EntryBleed, which used a timing side-channel to determine the\naddress of the kernel, and decided to investigate if something similar could\nbe used on Windows.\n\n### EntryBleed & Intro to Prefetch\n\nA very brief summary of EntryBleed is as follows: KPTI (Kernel Page Table\nIsolation) was a feature introduced in Linux to mitigate Spectre style attacks\nby separating the user and kernel page tables by removing all kernel memory\nfrom user mode page tables. One flaw in this, however, is that when a user\nmode application performs a syscall the memory containing the syscall handler\ncode must be present in the page tables. This meant that a small region of\nkernel memory, the syscall handler, was still present in the user mode page\ntables.\n\nSince the syscall handler\u2019s memory is present in the user mode page tables,\none could locate the memory\u2019s address if it is possible to determine if a\ngiven address is present in the page tables or not. This is where the prefetch\ninstruction comes in. Prefetch takes an address and attempts to load the\ncontent of it into the CPU\u2019s cache so that future accesses will be faster.\nUnlike instructions that read or write to a given address, prefetch does not\ncare if the address provided is a kernel address. It turns out that by\nmeasuring the amount of time a prefetch instruction takes to execute given a\ntarget address, it is possible to determine if the target address is in the\ncurrent page tables.\n\nThis is, as stated above, a very short summary of EntryBleed. For a much more\ndetailed description I highly recommend reading the original article.\n\n### Prefetch on Windows\n\nAfter getting an understanding of EntryBleed on Linux, I started porting the\ntechnique to Windows. I initially assumed that I would have to contend with\nKVA shadowing (the Windows equivalent of KPTI) but soon realized that KVA\nshadowing is now disabled on modern Windows 11 machines. This means that since\nthere is no longer any isolation between user and kernel page tables, not only\nis the memory for the syscall handler present in user mode page tables, but\nthe entire kernel address space is present.\n\nAdditionally I discovered a paper by Daniel Gruss, Cl\u00e9mentine Maurice, and\nAnders Fogh from 2016 which described exactly the sort of prefetch attack\nagainst Windows that I was hoping to achieve. With the help of these resources\nI started measuring prefetch times on all of the machines I had at my\ndisposal, and put together a (fairly) reliable tool to determine the base\naddress of the Windows kernel.\n\nThis tool is very much a proof-of-concept with lots of room for improvement,\nbut I found it to be reliable on modern Intel CPUs. AMD CPUs appear to be less\nconsistent in their behavior when prefetching a mapped address. I was able to\nget the AMD support reliable for the VM in which I was testing, but had issues\nwhen running on other hardware. Any improvements from folks more experienced\nwith side channels would be greatly appreciated! Source code for this tool can\nbe found on GitHub.\n\nThe prefetch tool in action!\n\n## Exploitation\n\nAt this point we have enough to start building an actual exploit. We have\nbypassed KASLR and located the base address of the kernel in memory, and we\nhave a vulnerability that allows us to write arbitrary data anywhere in the\nkernel. In prior versions of Windows it was possible to get the kernel address\nfor a specific object by its handle, which could then be the target for\ncorruption. The only kernel address we have now is the base address of the\nkernel, so we will need to start by corrupting global objects within the\nkernel.\n\n### Building a Kernel Read\n\nOur first task will be building a read primitive. With a write primitive\nalready firmly in hand, having a read will fully open up the kernel for us to\ndo whatever we want. To accomplish this we will need to find global in the\nkernel which we can target for corruption to create a read primitive. To look\nfor candidates for this I went to the ever helpful NtQuerySystemInformation\nsyscall (long a source of KASLR leaks itself). The ideal situation would be to\nfind a case where the syscall uses a global variable storing a pointer, reads\nthe data pointed to by the global, and returns the read data to user mode.\n\nI found the perfect case in the handling of the SystemManufacturingInformation\ninformation class. When handling this information class the kernel would copy\na global UNICODE_STRING structure named ExpManufacturingInformation to user\nmode. The UNICODE_STRING structure contains a pointer and a length, so by\noverwriting those in the global structure it is possible to read from an\narbitrary address and size and return the data to user mode.\n\n### Pre-Elevation Checklist\n\nNow that we have come up with a kernel read primitive, let us quickly review\neverything in our arsenal:\n\n  * \u2705Kernel ASLR bypass\n\n    * Using a timing side channel.\n  * \u2705Arbitrary kernel write\n\n    * Using a double-fetch in NtQueryInformationThread.\n  * \u2705Arbitrary kernel read\n\n    * Via corrupting the ExpManufacturingInformation global and NtQuerySystemInformation.\n\n      * Dependent on both the KASLR bypass and the kernel write.\n\nWith these primitives all reliably in hand, it is time to finally put it all\ntogether and elevate our privileges.\n\n### The Actual Exploit: Token Swapping\n\nThe technique I used in the final exploit was a classic process token swap\n(described in this post by hasherezade). I walked the list of processes\nrunning on the system by reading the PsActiveProcessHead global in the kernel.\nOnce I found a privileged process in the list, I recorded the address of its\ntoken object. I then walked the process list again to find my exploit process,\nand replaced its token with the token from the privileged process. Once this\nwas done I called CreateProcess to pop up a shiny new command prompt window\nrunning as NT AUTHORITY\\SYSTEM!\n\nOur exploit is complete :)\n\nSource code for the finished exploit is available on GitHub.\n\n## Final Thoughts\n\n### Binaries Change in Mysterious Ways\n\nAs I mentioned at the start, and would like to emphasize again, without having\naccess to the source code and compiler it\u2019s basically impossible to know\nexactly what led to the two bugs described here being introduced. As a\nsecurity researcher, these kinds of bugs appearing from nowhere are a nice\nsurprise, but for the vendor I believe these can highlight the risk of\napplying seemingly inconsequential changes to existing code.\n\n### KASLR: A Long Way to Go\n\nKASLR was trivial on Windows for so long that any change is going to be an\nimprovement. Microsoft\u2019s attitude toward KASLR also suggests that they don\u2019t\nregard it as a meaningful mitigation, given that they neither service nor\naward bounty for KASLR bypasses. The decision to disable KVA shadowing in\nWindows 11 also weakens the isolation of kernel memory from user mode. While\nthe elimination of many classic KASLR leaks will certainly create a little\nextra work for exploit developers I don\u2019t believe it poses a real challenge.\nI\u2019m sure in the future we\u2019ll see more KASLR bypasses as well that don\u2019t\nrequire any side-channel trickery ;)\n\nspecial thanks: lander chompie squif maks doomy\n\n", "frontpage": false}
