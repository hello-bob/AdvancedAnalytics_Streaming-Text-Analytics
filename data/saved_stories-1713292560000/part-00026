{"aid": "40050665", "title": "The Last Mile \u2013 The Problem with FOSS", "url": "https://bitbanksoftware.blogspot.com/2024/04/the-last-mile.html", "domain": "bitbanksoftware.blogspot.com", "votes": 1, "user": "iamflimflam1", "posted_at": "2024-04-16 11:20:32", "comments": 0, "source_title": "The Last Mile", "source_text": "The Last Mile\n\nSkip to main content\n\n### Search This Blog\n\n# Follow me down the optimization rabbit hole\n\nI optimize software for a living. This blog is to share some personal projects\nwhich others may find interesting.\n\n### The Last Mile\n\n  * Get link\n  * Facebook\n  * Twitter\n  * Pinterest\n  * Email\n  * Other Apps\n\nApril 14, 2024\n\n# The Last Mile - The problem with FOSS\n\nThis article is about FOSS (free and open-source software). The expression\n\"The Last Mile\" refers to supply chain or delivery services that get the\nproducts or packages into people's hands. A larger company or service may\nproduce it and ship it across the world, but it is usually up to a local\ncompany/carrier to bring it the last mile. I see FOSS as having a \"Last Mile\"\nproblem. The problem is that it's missing proper incentives to\nmaintain/finish/optimize projects which become important to a large set of\ncomputer users. Occasionally I benefit from this problem - I optimize other\npeople's software for a living; some of that software starts out as an open\nsource project.\n\n### Problem #1 (lack of upstreamed improvements)\n\nA few years ago I optimized a FOSS tool (ETCPACK - Ericsson Texture\nCompressor) for a large Silicon Valley company. This tool is used for\ncompressing RGB images into a lossy texture that GPUs can directly decompress.\nMy optimizations gave a significant speedup and I asked my supervisor to\nupstream the changes so that others could benefit. The response was typical,\nbut not surprising - \"The legal department won't approve of this, so forget\nabout it\". I've been in similar situations with the same decision when working\nwith other companies. In this case, I felt quite strongly that this was a\nshortsighted move because there was no competitive advantage to be lost by\nsharing the code, it simply makes artists and programmer's jobs go faster.\n\n### Problem #2 Intrinsic vs. Extrinsic Motivation\n\nA great majority of open source projects start out in a similar humble way -\nthe author had a need or desire to write some software and shared it with the\ncommunity. The reasons for sharing it can be altruistic or not. This is\nintrinsic motivation - when you want to get something done because \"reasons\".\nFor me, I sometimes want to test an idea for making code execute faster, or I\nneed something for a personal project (e.g. a LCD display library). Maybe the\nexisting solutions don't quite fit or I want to do it \"My Way TM\ufe0f\". All of\nthese reasons are perfectly valid and some great FOSS projects started this\nway. What comes next? Well, the project will get supported (or exist) as long\nas the original author wants it to. Perhaps other people join in, fork the\nproject, and make improvements. Great, this happened with libjpeg. The JPEG\n(joint photographers expert group) released some reference code in the early\n1990s to get people started and unfortunately no one improved it (at least\npublicly) for a long time. Someone was eventually inspired to create the\nlibjpeg-turbo project. It may have been for personal (intrinsic) reasons or\nmaybe a company seeded the money to do the work. This is a major flaw in the\nwhole system - most people on the Earth operate in a capitalist society and\nneed money as a (extrinsic) motivation to work. The avenues for getting paid\nto work on open source are mostly non-existent.\n\n### Problem #3 The FOSS Checkbox Item\n\nAnother aspect of FOSS I've encountered too many times is when companies\n\"Support FOSS and the community\" because it serves their business needs (e.g.\nthey sell hardware and share FOSS projects to support their hardware). When\npressed to actually support the FOSS community (e.g. financial support for\nother's code they profit from), crickets. The other frequent situation is the\nFOSS purist who won't share the code used in the \"binary blob\" in their\nproducts. They support FOSS as long is they get to keep trade secrets when\nthey feel like it serves their needs. A good name for some of this behavior\nmight be \"FINO = FOSS in name only\". Microsoft is a recognizable name in the\nFINO category.\n\n### Problem #4 Theft\n\nThe various licenses in use for FOSS (e.g. LGPL, Apache) are there to protect\nthe rights of the author(s). The truth is that a lot of FOSS ends up in\ncommercial products with the attribution/copyright notice removed, no\nroyalties paid and no respect for the original author's rights. There's not\nmuch that can be done about that. I'm confident that this has kept a lot of\ngreat code from being shared.\n\n### Problem #5 The Wasted Cycles\n\nThere are billions of computers in use these days - they form \"the internet\"\nas well as the private machines running in homes and offices. A lot of that\ncode has been carefully optimized to use as few cycles / gigawatts as\npossible. You can bet that the most optimized software in use will be the code\nwhich runs the cloud services of big companies like Google, Amazon and Apple.\nTheir services and processes need to be efficient because the electricity and\ntime represent a measurable and significant part of their operating expenses\n(How much does one search cost?). That's a strong incentive for the big\ncompanies to use the most efficient processors and optimize their software to\nthe fullest... but what about the users who pay to rent those machines (aka\nvirtual machines / cloud services)? Do you think Amazon cares how inefficient\nyour python scripts running on their machines are? This is the issue that irks\nme the most. Amazon/Google/Apple actually benefit financially from your\nprocesses being wasteful. They may provide tools and advice for helping you to\noptimize your code, but they still benefit from your inefficient use of their\ncomputer time - the slower your code, the more money they make. This isn't a\nsurprise for a capitalistic arrangement, but it is detrimental to the\nenvironment because most electric generation is still not emission free.\n\n### The Last Mile\n\nAll of these problems with FOSS bring us back to the point of this article -\nfor someone like me to contribute to the FOSS community purely out of\nintrinsic motivation is really shortsighted. The lack of extrinsic motivation\nlimits the possibilities of making significant improvements to popular\nprojects which could in turn have significant cost savings at scale. Let's use\nan example that shows my point. The libjpeg project comes with several command\nline utilities. One of these is jpegtran - a tool to transform JPEG images\n(rotate/crop/convert/etc). Several of these options are specialized code which\nuses specific knowledge of JPEG encoding to perform functions like lossless\ncropping. If you were to decompress a JPEG image, crop it, then recompress it\nusing the normal JPEG functions, it would suffer additional distortions and\nloss of quality. The jpegtran CLI is used in many server back-end processes to\ncleanly extract pieces of larger images without further degrading the quality.\njpegtran does the lossless cropping by decoding the image only to the point of\nthe DCT coefficients; it essentially keeps the pixels in the frequency domain\ninstead of doing the lossy part (converting them back and forth from the\nspatial domain). This idea also happens to save time since the forward and\nreverse discrete cosine transforms are skipped. The libjpeg-turbo project\noptimized this even further. Now we're at the point where things will become\nclear. The way that jpegtran does lossless crop is reasonable, logical and\nassumed to be the best/right way to do the job. I thought about this problem\nand a new idea entered my head. I spent many hours prototyping my idea and it\nworked. My version of lossless crop is much faster than jpegtran-turbo. When I\nsay much faster, I don't mean a 25% improvement, I'm talking about 300-500%\nfaster. On my MacBook Air M1 I created a command line utility which takes the\nsame parameters as jpegtran. I ran it multiple times against jpegtran to\neliminate and file/memory caching differences. Here are the results when\nrequesting a 1024x1024 crop from a 7200x5400 image:\n\ntime ./jpegtran -crop 1024x1024 ~/Downloads/large.jpg > out.jpg 0.20s user\n0.03s system 86% cpu 0.268 total\n\ntime jpegcrop -crop 1024x1024 ~/Downloads/large.jpg > out.jpg 0.06s user 0.01s\nsystem 96% cpu 0.069 total\n\nThese same speed differences are repeatable with different images and\ndifferent sized crop areas. The output pixels are identical, but my file\nheader information is slightly different because I created it differently from\nlibjpeg. My point in mentioning this is that it would be beneficial for a lot\nof users/projects if I did a pull request to the libjpeg-turbo Github repo and\ngave them my idea+code. As I'm sure you've gathered, without extrinsic\nmotivation I have very little incentive to give away my idea and code for\nfree. libjpeg-turbo is one of the few open source projects that gets funded on\na regular basis - not a lot, but enough to keep support active. There are many\ncontributors to that project, so dividing funding among them isn't an easy\ntask.\n\nYou can see where I'm headed with this - there are a lot of popular/important\nFOSS projects in use on millions of computers (maybe billions) that can be\noptimized further. Who will carry them the last mile when there's no\nincentive? I did some testing and saw optimization opportunities in ffmpeg,\nzlib, libjpeg, libtiff, libpng and others. Will the incentives to contribute\nto FOSS ever change to allow someone like me to take them from \"functional\" to\n\"optimal\"?\n\n  * Get link\n  * Facebook\n  * Twitter\n  * Pinterest\n  * Email\n  * Other Apps\n\n### Comments\n\n#### Post a Comment\n\n### Popular posts from this blog\n\n### How much current do OLED displays use?\n\nJune 30, 2019\n\nThose little OLED displays are everywhere, and there's a good reason. They're\ninexpensive, easy to program and they look good. I wanted to explore how much\ncurrent they draw so that I can plan better for battery powered projects.\nQuestions I want answered: How much idle current is drawn when the controller\nis off versus on (blank display)? What's the minimum current to see text\nindoors? What's the maximum current when all pixels are on at their brightest?\nHow does display size affect current draw? How does active data writing affect\ncurrent draw? It's obvious they use more, but how much current do grayscale\nand color OLEDs use? How practical are OLED displays compared to common LCDs\nfor battery powered projects? Materials: Cheap multimeter (manual scale,\nassumed accuracy +/-10% at worst) Various OLED displays (72x40, 96x16, 128x32,\n64x32, 128x64-0.96\", 128x64-1.3\") Arduino compatible microcontroller (\nAdafruit nRF52840 Feather Express )\n\nRead more\n\n### Fast SSD1306 OLED drawing with I2C bit banging\n\nMay 05, 2018\n\nWhat The SSD1306 OLED displays are very popular with hobbyists due to their\nlow cost and easy interfacing. The majority of the ones sold expose a two wire\ninterface (TWI) aka I2C. The default speed for I2C is 100Khz and the \"fast\"\nmode is 400Khz. These are the 2 standard speeds supported by most AVR\nArduinos. An I2C clock rate of around 800Khz is also possible on AVR MCUs, but\nnot supported directly by the Wire library. The I2C standard recently added\nsome higher speeds (1Mhz and 3.4Mhz). The 3.4Mhz version uses a slightly\ndifferent protocol. At 400Khz, using the I2C hardware and the Wire library, I\nwas able to refresh the display around 23.5 frames per second (FPS) with my\ncode. Why I have already written a SSD1306 library for both Linux and Arduino,\nbut I wanted to drive the display from an ATtiny85 and learn about the I2C\nprotocol in the process. The ATtiny85 doesn't have I2C hardware built in, so\nit needs to be emulated in software using GPIO pins. There\n\nRead more\n\n### Building the Pocket CO2 Project\n\nApril 26, 2023\n\nIntro Most of my previous posts have been focused on software topics. I'm\ngoing to stray a little into hardware for this article. At the end of 2022 I\nmade a promise to myself to learn how to use KiCad so that I could design my\nown printed circuit boards. I have some experience with electronics and I\nthought that I could design some relatively simple PCBs for my own use. I\nfound this 100 minute YouTube tutorial and it provided enough practical info\nto get me started. This blog post is not about learning KiCad; instead I'm\ngoing to walk through all of the steps and equipment necessary to build my\nPocket CO2 sensor project. The KiCad files and firmware can be found here .\n(SMD) Surface Mount Soldering is Easy? After seeing videos of professional\nmakers such as Seon \"Unexpected Maker\" Rozenblum use pick-n-place machines to\nbuild complex PCB boards with impossibly small components, I wrongly assumed\nthat SMD soldering required expensive equipment and lots of expertise.\n\nRead more\n\nPowered by Blogger\n\nTheme images by Radius Images\n\nLarry Bank\n\nVisit profile\n\n## Followers\n\n### Report Abuse\n\nDiese Website verwendet Cookies von Google, um Dienste anzubieten und Zugriffe\nzu analysieren. Deine IP-Adresse und dein User-Agent werden zusammen mit\nMesswerten zur Leistung und Sicherheit f\u00fcr Google freigegeben. So k\u00f6nnen\nNutzungsstatistiken generiert, Missbrauchsf\u00e4lle erkannt und behoben und die\nQualit\u00e4t des Dienstes gew\u00e4hrleistet werden.Weitere InformationenOk\n\n", "frontpage": false}
