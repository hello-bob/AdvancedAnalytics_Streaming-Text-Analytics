{"aid": "40196418", "title": "Befreak is a purely reversible two-dimensional programming language", "url": "http://tunes.org/~iepos/befreak.html", "domain": "tunes.org", "votes": 1, "user": "akkartik", "posted_at": "2024-04-29 09:53:22", "comments": 0, "source_title": "The Befreak Programming Language", "source_text": "The Befreak Programming Language\n\n# The Befreak Programming Language\n\nBrent Kerby: iepos@tunes.org Hilton Campbell: chauchauchau@msn.com Last\nrevised: March 26, 2003\n\n  * Introduction\n  * Hello World\n  * Arithmetic\n  * Bitwise Operators\n  * Stack Combinators\n  * Comparisons\n  * Inverted Mode\n  * Control Flow\n  * Input/Output\n  * Download Befreak\n  * Instruction Reference\n  * Links\n\nBefreak is a purely reversible two-dimensional programming language. It was\ninspired by the Chris Pressey's Befunge programming language. Like Befunge,\nall Befreak instructions are written as a single character, and execution can\nflow north, south, east, and west.\n\nThe thing that makes Befreak special is its reversibility. Every instruction\nin Befreak is by its very nature reversible. At any point during execution, if\nyou'd like, you can pause the system, toggle the \"reverse\" flag, and then upon\nresuming, the program will run itself backwards from its current state,\neventually ending up at the very beginning, where it started. This feature is\nnot accomplished by keeping a history of past states, but simply by virtue of\nthe fact that each individual instruction is reversible. This means that\nBefreak contains no instructions that can destroy information; this can make\nprogramming in the language both challenging and interesting.\n\n## Hello World\n\nWe'll begin with the classic \"Hello world\" program. In Befreak, this is not\ntrivial, so buckle your seatbelts. To help make things easier to follow, I'd\nrecommend downloading the Befreak system, and stepping through the program\nwith the interpreter.\n\n    \n    \n    /\"Hello world!\"01\\ \\(13v 'wsv)@(/ \\(=13=13)/\n\nIn Befreak, execution always begins at the @ symbol and proceeds east. Thus,\nthe first instruction encountered is \"(\", which pushes a zero onto the stack\n(in Befreak, data is manipulated through a stack, a la FORTH). The next\ninstruction, \"/\", is a mirror that causes the IP (the instruction pointer) to\nchange direction; in this case, it will make IP go north; next is \"\\\", which\nis another mirror, and in this case causes IP to go west. Next we have the\ninstruction \"01\", or rather \"10\" since we're coming from the east: this causes\nthe top item on the stack to be XOR'd with 10 (decimal); since the top of\nstack was zero, this makes the top of stack 10, which is the ASCII code for\nnewline.\n\nNext, the \" instruction is encountered, which causes the program to go into\nstring mode until the next \" is reached. In string mode, the ASCII value of\neach character encountered (not including the quotes themselves) is pushed\nonto the stack. In Hello World above, when we reach the second \", the top item\non the stack is 'H', and the other characters are underneath.\n\nNext, we hit \"/\" which makes the IP go south. Then we hit \"\\\" which makes the\nIP go east. Then we hit \"(\" and \"13\", which together push 13 onto the stack\n(\"(\" pushes a 0 and then 13 XORs it with 13); 13 is the number of characters\nin our string; this \"13\" will serve as a counter telling how many times our\nmain loop will execute; it will be decremented each time through the loop, and\nwhen it reaches 0, the loop will be exited.\n\nSo, we next hit \"v\", which is the entrance to our main loop. The \"v\" here is\nnot exactly the same as in Befunge; it makes the IP go south, but it also\npushes a value onto an auxiliary stack, called the \"control stack\", telling\nwhere we came from. In this case, it pushes a 1, since we made a right turn\n(if we'd made a left turn, e.g., came from the east, a 0 would have been\npushed). This value, called a \"control bit\", is needed for reversibility:\nimagine we're past the \"v\", going south, and then we want to reverse, making\nthe IP go back north. What happens when we hit the \"v\"? How do we know if we\ncame from the right or the left? (we don't need to consider the possibility\nthat we came from the north, as will be explained in the control flow\nsection.) By the control bit on the control stack, of course...\n\nThe next instructions \"(=13=13)\" serve as the condition of the loop, which\nwill determine whether the loop will continue or not. Recall that at this\npoint we have a 1 on the control stack, because we turned right entering the\n\"v\". Notice that if this 1 remains how it is, then when we hit the next \"v\"\ncoming up in a few instructions, we'll turn right again, exiting the loop.\nThus, the instructions coming up had better change the 1 to a 0, so that the\nloop will continue. In fact, they do:\n\nFirst we push a zero onto the stack, with \"(\". Then we execute \"=\"; this tests\nto see if the top two items on the stack are equal, and if so, the top item on\nthe control stack will be XOR'd with 1 (effectively toggling it between 0 and\n1). \"=\" has no effect if the top two items are unequal. In this case, the top\ntwo items are indeed unequal (13, our counter, is not equal to 0) and thus\nnothing happens. But, next we have the sequence \"13=\", which changes the 0 to\na 13 (by an XOR) and then checks to see if the loop counter is equal to that,\nwhich it is. Thus the 1 on the control stack is toggled to a 0. Finally, we\nexecute \"13)\" which cleans things up, changing the 13 back to a 0, and\nremoving it (the \")\" instruction removes a zero from the stack; it is an error\nfor the top item to be non-zero with this instruction; if it happens, the\ninterpreter will block, refusing to execute the offending instruction).\n\nThen we hit the mirror \"/\" which bounces us up into the \"v\", and we remove the\n\"0\" from the stack and turn left. Here we have the body of the loop, which is\nfairly simple. The \"s\" instruction swaps the top two items on the stack; in\nthis case, it swaps the loop counter out of the way, pulling up a character\n(\"H\"). Then, we write the character to stdout using \"w\" (this removes the\ncharacter from the stack). Then we decrement the loop counter with \"`\", pass\nover some spaces (which are no-ops) and hit the \"v\" and re-enter the loop; but\nthis time, a 0 is pushed, instead of a 1, since we're turning left. That means\nthat the upcoming conditional code need not change that 0, since as it is, it\nwill cause a left turn at the next \"v\", making the loop continue.\n\nIndeed, as you may have figured out, our code only changes the control bit\nwhen the loop counter is either 0 or 13, so the loop will keep executing in\nthe same fashion, until the counter reaches 0, at which point the condition\nwill be toggled from a 0 to a 1, causing a right turn at the \"v\", which makes\nus exit the loop.\n\nIt may seem peculiar that, in essence, we are forced to put both an entrance\ncondition and an exit condition in loop code, instead of just an exit\ncondition. This is a natural phenomenon in reversible programming, since if we\nwere running the loop backwards, we need to know at what point we are done so\nwe can \"exit\" the loop (through the entrance).\n\nAnyhow, eventually the loop exits, and then removes the loop counter, which is\nnow zero, with \")\". Then we ram into the left side of the \"@\", which the\nproper way of terminating a Befreak program.\n\nYou might be wondering why we used a counter in our Hello World, instead of\njust using a null-terminated string like one would do in Befunge. The answer\nis that trying to naively print out a null-terminated string won't work in\nBefreak becauses its inherently irreversible; if we try to run the program\nbackwards, to unprint the string, how will the program know when the beginning\nof the string has been reached? But, there are in fact other solutions to the\nproblem besides using a counter: for example, we could fix the first character\nof the output to be a newline, which would act as a signal when going in\nreverse (although the output may not look the way we want), or we could\npreserve a copy of the string as we write.\n\n## Arithmetic\n\nBefreak also has basic arithmetic instructions. For example, take addition and\nsubtraction: Befreak has \"+\" and \"-\". However, be careful, because they\nfunction differently than in FORTH or Befunge. The normal interpretation for\n\"+\" in a stack-based language is to take two operands and replace both of them\nwith their sum. However, Befreak cannot do this, because that operation is\nirreversible. Befreak takes two operands and replaces the bottom one with the\nsum, while leaving the top item unchanged. For example, the following code\n(entering forwards from the left) will add 5 to the top item on the stack:\n\n    \n    \n    (5+5)\n\nIt works by pushing a zero with \"(\", changing it to a 5, performing the\naddition, and then removing the 5 which was left there by \"+\" (remember, \"5\"\nis an XOR; since 5 is already at the stack at this point, XORing it with 5\nchanges it back to a zero, so it can be removed with \")\").\n\nBefreak also has a similar subtraction operator; to subtract 5 instead of\nadding, use the exact same code as above except replacing \"+\" with \"-\". Also,\nBefreak has the instructions ' and ` which increment and decrement the top\nitem, respectively.\n\nBy the way, if an overflow occurs on an addition or subtraction, Befreak will\nhappily wrap around, since this type of overflow is reversible.\n\nOn the other hand, multiplication and division gets a bit trickier. Befreak's\ndivision instruction \"%\" works like so: it takes the dividend on bottom and a\ndivisor on top (which must be non-zero). It performs the division, replacing\nthe dividend with both the quotient and the remainder (the quotient is on\nbottom, and the remainder is above that, with the original divisor staying\nuntouched on the very top). Thus, division takes 2 items and leaves you with 3\nitems.\n\nBefreak's inverse to the divide instruction is called \"*\", however this can be\nmisleading, because it is not a normal multiplication operator. It takes 3\nitems, multiplies the first (e.g., top item, which is the multiplier, and must\nbe non-zero) by the third and adds in the second (which must be less than the\nfirst), and leaves you with that result on bottom, with the original top item\nunchanged. So you might say this is sort of a restricted \"multiply-and-\naccumulate\" instruction; to do a normal multiplication, simply use a 0 as the\nsecond item.\n\nBy the way, in Befreak it is an error to cause an overflow in a\nmultiplication, because, if the multiplier is even, bits are shifted off the\nhigh-end and lost, thus being irreversible. Technically, multiplying by an odd\nnumber is reversible even through overflows, because of the number theory fact\nthat odd numbers have inverses modulo 2^n; however, Befreak does not use this.\n(Another fact is that if we did multiplication modulo a prime, then all\nmultiplication, except by zero, would be reversible).\n\n## Bitwise Operators\n\nBefreak has basic bit manipulation operators. \"&\" performs a bitwise AND on\nthe top two items, XOR'ing he result into the the third (i.e., bottom) item\n(the top two items being left unchanged).\n\nSimilarly, there is \"|\" which takes the bitwise OR of the top two items,\nXOR'ing the result into the third.\n\nNext, there's \"#\", which performs XORs. This is a bit simpler than \"&\" and\n\"|\", since XOR'ing is reversible. The top item is simply XOR'd onto the second\nitem, leaving the top item unchanged. This is similar to how \"+\" and \"-\" work.\n\nAnd then, there's \"~\", which performs a bitwise NOT on the top item. As a\nhandy fact, you can push a -1 by doing \"(~\" (Befreak assumes two's complement\narithmetic).\n\nFinally, there's \"{\" and \"}\" which perform left and right bitwise rotations;\nthey rotate the second item by the amount specified in the top item, leaving\nthe top item untouched.\n\n## Stack Combinators\n\nWe've already seen the swap \"s\" operator, which interchanges the top two items\non the stack. Befreak also has a few more complex operators for rearranging\nthe top few items on the stack:\n\nThere's \"d\", which digs up the third item, bringing it to the top of the stack\n(causing the original first and second items to become second and third). The\ninverse to this is \"b\", which buries the top item underneath the next two,\nmaking it the third item.\n\nThere's \"c\", which swaps the second and third items, leaving the top\nuntouched. And, there's \"f\", which flips (e.g., reverses the order of) the top\nthree items, effectively swapping the first item with the third.\n\nThat's it for the permutators. Befreak also has the equivalent of \"DUP\"; it's\ncalled \":\", as in Befunge. This simply duplicates the top item, leaving you\nwith two items that are the same. The inverse is \";\", which unduplicates two\nthings, leaving you with one (it is an error if the two things are not the\nsame).\n\nAs an interesting fact, it's possible to construct \":\" as \"(s#\" or \"(s+\".\n\nFinally, as mentioned earlier, Befreak uses an extra stack called the \"control\nstack\"; it is is mainly used as a place to put control bits for loops or\nconditionals; however, it may also be used like the \"return stack\" of FORTH,\nas a convenient place to temporarily shove stack items that won't be needed\nfor a while. The instruction to transfer an item from the main stack to the\nextra stack is \"[\"; to bring it back, use \"]\" (notice that \"[\" and \"]\" move,\nnot copy, the items). Also, there's the \"$\" instruction, that swaps the top\nitem on the main stack with the top item on the control stack.\n\n## Comparisons\n\nWe've already seen \"=\", which looks at the top two items, and, if they're\nequal, toggles the top item on the control stack (i.e., XORs it with 1).\nBefreak also has \"l\", which checks to see if the second item is less than the\nfirst item, and if so toggles the top item on the control stack. Similarly,\nthere's \"g\" which checks to see if the second item is greater than the first\nitem, toggling the top of the control stack if so.\n\nNotice, these comparisons can be conveniently combined; for example, to do a\nlesser-than-or-equals-to comparison, simply do \"l=\". For not-equals, do \"lg\".\n\n## Inverted Mode\n\nIn Befreak, every operator as an inverse. For example, the inverse of \"+\" is\n\"-\"; the inverse of \"(\" is \")\". Many instructions are their own inverses, such\nas \"s\", \"&\", \"|\", \"#\", \"~\", \"=\", \"l\", \"g\", and the number-literals.\n\nOne of the neat things about a reversible programming language is the ability\nto run code backwards. In Befreak, sometimes it is expedient to run a portions\nof code backwards. There is a way to do that: that \"?\" instruction toggles the\nsystem's \"inverted mode\". If inverted mode is on, then the inverse of each\nindividual instruction is used, instead of the normal instruction. However,\nthe IP keeps moving the same way that it normally would.\n\nThere's one particular pattern of coding that \"?\" is very handy for; often in\nreversible coding, you want to do some code that sets up some information,\nthen do some code \"FOO\", and then go back and undo the code that did the\nsetup. That is, you want to do \"SETUP FOO UNSETUP\". However, if \"SETUP\" is\nlarge, then it can be inconvenient to have to write it again backwards for\n\"UNSETUP\". In Befreak, using \"?\", you can solve the problem this way (here,\n\"SETUP\" and \"FOO\" represent arbitrary blocks of code; they may be much larger\nthan just 5 or 3 characters):\n\n    \n    \n    @v? S E T U P / ^?\\ \\FOO/\n\nRecall that the IP starts at \"@\" and goes east. We hit the \"v\", turn right,\nand do the \"SETUP\". Then, we hit \"^\", turn right again, and do FOO. We hit \"?\"\nwhich puts the system into inverted mode; then we hit the \"^\" again, and turn\nright, going north, and undo \"SETUP\", and hit \"v\", turn right again, and hit\n\"?\", which restores the system to normal mode. Thus, looking at the whole\nthing, we've done \"SETUP\", done \"FOO\", and then undone \"SETUP\".\n\n## Control Flow\n\nWe've already seen the \"v\" and \"^\" instructions above; \"v\" is called a \"South\nbranch\" instruction. As already mentioned, if it is entered from the west or\nfrom the east, then the IP is made to go south, and an item is pushed onto the\ncontrol stack (a 0 if a left turn was made, or a 1 if a right turn was made).\nIf it is entered from the south, then it functions as a branch: it removes the\ntop item from the control stack and turns left if it's a 0 and right if it's a\n1 (it is an error for it to be something other than a 0 or 1).\n\nIn inverted mode, the roles of 0 and 1 are interchanged, in that 0 then\ncorresponds to a right turn and 1 to a left turn, both in entering and exiting\nthe branch. This is neccessary for it to run backwards properly.\n\nBefreak also has \"^\", \">\", and \"<\", which are north, east, and west branches.\nThey function exactly symmetrically to \"v\". For example, \">\" makes the IP go\neast (and push a 0 or 1 onto the stack), when coming from the north or south,\nand makes the IP branch when coming from the east. In all four kinds of\nbranches, 0 corresponds to a left turn, and 1 to a right turn (except that in\ninverted mode, this is reversed).\n\nOne helpful way to think about branches is to avoid thinking too much about\nthe control bits, and simply realize that if we enter a loop or branch by\nturning right, then it will also exit by turning right, (unless the control\nbit or the inverted mode is toggled in between), and if we enter by turning\nleft, then it will exit by turning left. You can take a portion of code (that\nincludes branches) and flip it on it horizontally or vertically (i.e., along\nan x-axis or y-axis), and it will normally function exactly the same way,\nalthough all the control bits will be reversed.\n\nNow, we have too look at what happens if a branch is entered from the \"wrong\"\nside (for example, if \"v\" is entered from the north). Here's what happens: the\ntop item on the control stack is toggled, the system enters inverted mode (or\nrather, inverted mode is toggled), and IP reverses direction (in the case of\n\"v\", IP goes back north). This may seem a bit peculiar, but in fact this is a\nuseful behavior in many situations; it gives a slick way of doing\nbacktracking, or aborting due to an exceptional condition. Here's an abstract\ncode example:\n\n    \n    \n    @ v? HANDLE_EXCEPTION C O D E / KEEP_GOING > IS_THERE_AN_EXCEPTIONAL_CONDITION < v\n\nHere's what happens: we hit the first \"v\" and go south (and push a bit onto\nthe control stack), do \"CODE\", and then hit \">\", which sets up a bit on the\ncontrol stack to be potentially toggled by the\n\"IS_THERE_AN_EXCEPTIONAL_CONDITION\" (note, we could have set up that bit by\nmanually pushing zero using \"([\", but that would be less proper, because if we\nreflected the whole program vertically, it would then no longer function\ncorrectly, because then a 1 would be needed to be pushed, instead of a zero;\nalso, the \">\" is visually a structural match to the upcoming \"<\").\n\nNow, as long as that exceptional condition doesn't happen, the IP will turn\nleft again at the \"<\" and execute \"KEEP_GOING\", and the program will go on its\nmerry way. However, if there is an exceptional condition, then IP turns right\nand we hit \"v\" the wrong way, which causes the top item on the control stack\n(the bit pushed by the original \"v\") to be toggled, inverted mode to be\nentered, and IP to go back north. At this point, the program backtracks until\nwe reach the original \"v\" (i.e., whatever was done by \"CODE\" and\n\"IS_THERE_AN_EXCEPTIONAL_CONDITION\" is undone). If it wasn't for the fact that\nthe abort (hitting \"v\" the wrong way) toggled the top item on the control\nstack, then the abort would be permanent, causing us to backtrack all the way\nto the beginning of the program, with no way to stop it. However, since it\ndoes toggle the top item on the control stack, we end up going east when we\nhit that original \"v\", and then hit the \"HANDLE_EXCEPTION\" stuff (first\nrestoring the system to normal mode using \"?\"). One last and important thing\nto notice here is that from the perspective of the \"HANDLE_EXCEPTION\" stuff,\nit is as if the \"CODE\" had never been executed at all, since it was unexecuted\nin the backtracking process.\n\n## Input/Output\n\nWe've already seen the \"w\" instruction, which writes the top item on the stack\nto stdout. It expects the top item to be within the range of a byte (0 to\n255), otherwise an error occurs.\n\nAlso, Befreak has the \"r\" instruction, which reads a character from stdin onto\nthe top of the stack.\n\nWe might question the reversibility of these instructions. In fact, writing to\nstdout is irreversible since we cannot, within the constraints of an\nirreversible operating system, take back the characters that we've written.\nAlso, we cannot give back characters that we've read from stdin.\n\nHowever, the interpreter handles this problem by keeping a stack of characters\nthat have been outputed, and a stack of characters than can be input\n(\"uninputing\" something puts a character back on the top of that stack,\nwhereas input from the keyboard comes in at the bottom of the stack). Thus,\nwithin the cozy bubble of the interpreter, everything, including input/output,\nis completely reversible. However, if Befreak is interacting with the outside\nworld, then we'll have to accept this degree of irreversibility.\n\n## Download Befreak\n\nThe Befreak system is free: befreak.tar.gz (DOS executable: BFI.EXE). Included\nis the interpreter, BFI, and the compiler, BFC, and several sample programs.\nBFC currently happily compiles Befreak code to C (other targets will hopefully\nbe supported in the future).\n\nAs a final note, for kicks, here's a program that prints out the prime numbers\n(the bottom half of the program outputs an integer in decimal form, character\nby character, since Befreak has no special instruction to do this):\n\n    \n    \n    /1)@(1\\ >)1=1(< \\'(v?)/ >'%s(\\ ^ >*s)=/ >=< ( /s'0v^?w23(v`s]:(48\\ [ ( ) + ) = = 4 0 c c 8 1 = = ) % ) ( w \\01(^ ^)01*01(/\n\n## Instruction Reference\n\n    \n    \n    1-9 XOR top item with a value 1 thru 9 (multidigit also works) . [x] -> [x'] ( Push a zero onto the stack ..................................... -> [0] ) Pop a zero from the stack .................................. [0] -> [ Transfer the top of main stack to control stack ............ [x] -> ] Transfer the top of control stack to the main stack ............ -> [x] $ Swap the top item with the top of control stack ............ [x] -> [y] w Write the top item to stdout as a character ................ [x] -> r Read a character from stdin to the top of stack ................ -> [x] ' Increment the top item ..................................... [x] -> [x'] ` Decrement the top item ..................................... [x] -> [x'] + Add the top item to the next item ...................... [y] [x] -> [y+x] [x] - Subtract the top item from the next item ............... [y] [x] -> [y-x] [x] % Divide x by d, leaving a quotient and remainder ........ [y] [x] -> [y/x] [y%x] [x] * Undo the effects of %, using multiplication ........ [z] [y] [x] -> [z*x+y] [x] ~ Bitwise NOT the top item ................................... [x] -> [~x] & Bitwise AND top two items, XOR'ing to the third ... [z] [y] [x] -> [z^(y&x)] [y] [x] | Bitwise OR top two items, XOR'ing to the third ..... [z] [y] [x] -> [z^(y|x)] [y] [x] # Bitwise XOR the top item to the next item .............. [y] [x] -> [y^x] [x] { Rotate \"y\" to the left \"x\" bits ........................ [y] [x] -> [y'] [x] } Rotate \"y\" to the right \"x\" bits ....................... [y] [x] -> [y'] [x] ! Toggle top of control stack (i.e., XOR it with 1) .............. -> = If y equals x, toggle top of control stack ............. [y] [x] -> [y] [x] l If y is less than x, toggle top of control stack ....... [y] [x] -> [y] [x] g If y is greater than x, toggle top of control stack .... [y] [x] -> [y] [x] s Swap the top two items ................................. [y] [x] -> [x] [y] d Dig the third item to the top ...................... [z] [y] [x] -> [y] [x] [z] b Bury the first item under the next two ............. [z] [y] [x] -> [x] [z] [y] f Flip the order of the top three items .............. [z] [y] [x] -> [x] [y] [z] c Swap the second and third items .................... [z] [y] [x] -> [y] [z] [x] o \"Over\": dig copy of second item to the top ............. [y] [x] -> [y] [x] [y] u \"Under\": the inverse of \"over\" ..................... [y] [x] [y] -> [y] [x] : Duplicate the top item ..................................... [x] -> [x] [x] ; Unduplicate the top two items .......................... [x] [x] -> [x] \" Enter string mode .............................................. ? Toggle reverse mode ............................................ @ Halt. Also signals the entrance point for the program .......... \\ If going east or west, turn right; otherwise, turn left ........ / If going east or west, turn left; otherwise, turn right ........ > If going north, go east and push 1 (in reverse mode, push 0) ... If going south, go east and push 0 (in reverse mode, push 1) ... If going west, pop and go south if 0, north if 1. (opposite in reverse mode) If going east, toggle top of control stack, toggle inverted mode, and go west. < If going north, go west and push 0 (in reverse mode, push 1) ... If going south, go west and push 1 (in reverse mode, push 0) ... If going east, pop and go north if 0, south if 1. (opposite in reverse mode) If going west, toggle top of control stack, toggle inverted mode, and go east. v If going east, go south and push 1 (in reverse mode, push 0) ... If going west, go south and push 0 (in reverse mode, push 1) ... If going north, pop and go west if 0, east if 1. (opposite in reverse mode) If going south, toggle top of control stack, toggle inverted mode, and go north. ^ If going east, go north and push 0 (in reverse mode, push 1) ... If going west, go north and push 1 (in reverse mode, push 0) ... If going south, pop and go east if 0, west if 1. (opposite in reverse mode) If going north, toggle top of control stack, toggle inverted mode, and go south.\n\n## Links\n\n  * Cat's Eye Technologies: Befunge. The makers of Befunge.\n  * Ping Pong Programming Language. Another Befunge-like language; it shares Befreak's use of \"/\" and \"\\\" as mirrors.\n  * Mike's Reversible Computing Page. A great resource for reversible computing: \"Janus\" (the first reversible programming language), Mike's thesis \"Reversibility for Efficient Computing\", info on reversible CPU projects, etc.\n  * Zyvex Reversible Computation Page. Discusses reversible computing in the context of nanotechnology.\n  * Henry Baker's Archive of Research Papers. Here there some classic papers on reversible programming and other topics; conveniently enough, they're available in HTML format.\n  * The FORTH Interest Group. Excellent resource on the FORTH programming language.\n  * The Joy Programming Language. An interesting stack-based programming language that supports higher-order programming.\n\n", "frontpage": false}
