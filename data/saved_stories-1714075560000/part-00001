{"aid": "40155346", "title": "Software Design Principles I Learned the Hard Way", "url": "https://read.engineerscodex.com/p/4-software-design-principles-i-learned", "domain": "engineerscodex.com", "votes": 2, "user": "thunderbong", "posted_at": "2024-04-25 09:36:18", "comments": 0, "source_title": "4 Software Design Principles I Learned the Hard Way", "source_text": "4 Software Design Principles I Learned the Hard Way\n\n# Engineer\u2019s Codex\n\nShare this post\n\n#### 4 Software Design Principles I Learned the Hard Way\n\nread.engineerscodex.com\n\n#### Discover more from Engineer\u2019s Codex\n\nExplaining tools and technologies used and created by big tech companies.\nBecome a smarter software engineer in just 7 minutes a week.\n\nOver 24,000 subscribers\n\nContinue reading\n\nSign in\n\n# 4 Software Design Principles I Learned the Hard Way\n\n### If there\u2019s two sources of truth, one is probably wrong. And yes, please\nrepeat yourself.\n\nApr 22, 2024\n\n56\n\nShare this post\n\n#### 4 Software Design Principles I Learned the Hard Way\n\nread.engineerscodex.com\n\n3\n\nShare\n\nEngineer\u2019s Codex is a publication about real-world software engineering.\n\nI recently built and designed a massive service that (finally) launched\nsuccessfully last month. During the design and implementation process, I found\nthat the following list of \u201crules\u201d kept coming back up over and over in\nvarious scenarios.\n\nThese rules are common enough that I daresay that at least one of them will be\nuseful for a project that any software engineers reading this are currently\nworking on. But if you can\u2019t apply it directly now, I hope that these\nprinciples are a useful thought exercise that you are free to comment on below\nor challenge directly too.\n\n##\n\n1\\. Maintain one source of truth.\n\nIf there\u2019s two sources of truth, one is probably wrong. If it\u2019s not wrong,\nit\u2019s not wrong... yet.\n\nBasically, if you\u2019re trying to maintain a piece of state in two different\nlocations within the same service... just don\u2019t. It\u2019s better to try to just\nreference the same state wherever you can. For example, if you\u2019re maintaining\na frontend application and have a bank balance that is from the server, I\u2019ve\nseen enough sync bugs in my time that I always want to get that balance from\nthe server. If there is some balance that is derived from that, such as\n\u201cspendable balance\u201d versus \u201ctotal\u201d (for example, some banks make you keep a\nminimum balance), then that \u201cspendable balance\u201d should be derived on-the-fly\nrather than stored separately. Else, you\u2019ll now have to update both balances\nwhenever a transaction happens.\n\nIn general, if there is a piece of data that is derived from another value,\nthen that value should be derived rather than stored. Storing that value leads\nto synchronization bugs. (Yes, I know this isn\u2019t always possible. There will\nalways be other factors in play, like the expense of the derivation. At the\nend of the day, it\u2019s a tradeoff.)\n\n##\n\n2\\. Yes, please repeat yourself.\n\nWe\u2019ve heard of DRY (Don\u2019t Repeat Yourself) and now I present to you PRY\n(Please Repeat Yourself).\n\nFar too many times I\u2019ve seen code that looks mostly the same try to get\nabstracted out into a \u201cre-usable\u201d class. The problem is, this \u201cre-usable\u201d\nclass gets one method added to it, then a special constructor, then a few more\nmethods, until it\u2019s this giant Frankenstein of code that serves multiple\ndifferent purposes and the original purpose of the abstraction no longer\nexists.\n\nA pentagon may be similar-looking to a hexagon, but there is still enough of a\ndifference that they are absolutely not the same.\n\nI\u2019m also guilty of spending way too much time trying to make things reusable,\nwhen a bit of code duplication works perfectly fine. (Yes, you have to write\nmore tests and it doesn\u2019t scratch the \u201crefactoring\u201d itch, but oh well.)\n\n##\n\n3\\. Don\u2019t overuse mocks.\n\nMocks. I have a love-hate relationship with mocks. Mocks are great when I have\nto write unit tests to test something quickly and don\u2019t want to mess with\n\u201cprod-level\u201d code. Mocks are not great when prod breaks because as it turns\nout - something you mocked broke deeper down the stack, even though that\n\u201cdeeper down the stack\u201d is owned by another team. It doesn\u2019t matter because it\nwas your service that broke so it's your responsibility to fix it.\n\nWriting tests is hard. The line between unit tests and integration tests is\nblurrier than you think. Knowing what to mock and not mock is subjective.\n\nIt\u2019s much nicer to find things while developing rather than in prod. As I\ncontinue writing software, I try to stay away from mocks if possible. Tests\nbeing a bit more heavyweight is completely worthwhile when it comes to a much\nhigher reliability. If mocks are really required by my code reviewer, I\u2019d\nrather write more (and maybe even redundant) tests rather than skip out on\ntests. Even if I can\u2019t use a real dependency in a test, I will still try to\nuse other options first before mocks, like a local server.\n\nGoogle\u2019s \u201cTesting on the Toilet\u201d has a good note on this from 2013. They note\nthat overusing mocks causes:\n\n  * Tests can be harder to understand because now you have this extra code someone has to understand along with the actual production code.\n\n  * Tests can be harder to maintain because you have to tell a mock how to behave, which means you leak implementation details into your test.\n\n  * Tests overall provide less assurance now because the reliability of your software now is only guaranteed IF your mocks behave exactly like your real implementations (which is hard to guarantee and often ends up out of sync).\n\n##\n\n4\\. Minimize mutable state.\n\nComputers are VERY fast. In the optimization game, it\u2019s super popular to\ninstantly throw caching and store everything in a database immediately. I\nthink this is probably the end state of most successful software products and\nservices. Of course, most services will need some sort of state, but it\u2019s\nimportant to figure out what is truly necessary storage-wise versus what can\nbe derived on-the-fly.\n\nIn the \u201cv1\u201d of something, I\u2019ve found that minimizing as much mutable state as\npossible gets you pretty far. It lets you develop faster because you don\u2019t\nhave to worry about sync bugs, conflicting data, and stale state. It also lets\nyou develop functionality piece-by-piece, rather than introducing too much at\nonce. Machines are fast enough today where doing a few redundant calculations\nis totally fine. If machines are supposedly \u201creplacing us\u201d soon, then they can\nhandle a few extra work units of calculations.\n\n### Subscribe to Engineer\u2019s Codex\n\nBy Leonardo Creed \u00b7 Launched 7 months ago\n\nExplaining tools and technologies used and created by big tech companies.\nBecome a smarter software engineer in just 7 minutes a week.\n\n56 Likes\n\n\u00b7\n\n3 Restacks\n\n56\n\nShare this post\n\n#### 4 Software Design Principles I Learned the Hard Way\n\nread.engineerscodex.com\n\n3\n\nShare\n\n3 Comments\n\nWilliam PanApr 22Liked by Leonardo CreedPRY is more commonly known as Write\nEverything Twice (WET)Expand full commentLike (4)ReplyShare  \n---  \n  \nJoshApr 23Liked by Leonardo CreedNot bad ideas here but I think there's some\nissues that need addressed. Don't confuse DRY with bad design. The idea behind\nDRY is to abstract and encapsulate in case you need code later, not create bad\ndesign trying to make the perfect function or class. The example provided\nactually breaks SOLID principles so it should never happen if DRY is applied\ncorrectly. You should also never setup local servers in unit tests. I don't\ncare what Google says. Google has hundreds of developers that do nothing more\nthan write internal tooling. Have you seen a large CI/CD pipeline with in-\nmemory servers running? It can take up to 20 minutes for a deployment\ndepending on the size of the project. Especially if you're a monorepo team\ntaking advantage of GitOps, in-memory anything will be a nightmare to\nhandle.Expand full commentLike (2)ReplyShare  \n---  \n  \n1 more comment...\n\nHow to burnout a software engineer, in 3 easy steps\n\nThe Burnout Playbook for software engineers\n\nOct 16, 2023\n\n96\n\nShare this post\n\n#### How to burnout a software engineer, in 3 easy steps\n\nread.engineerscodex.com\n\n19\n\n7 simple habits of the top 1% of engineers\n\nHow elite software engineers maintain outperformance\n\nSep 11, 2023\n\n304\n\nShare this post\n\n#### 7 simple habits of the top 1% of engineers\n\nread.engineerscodex.com\n\n11\n\nHow Google takes the pain out of code reviews, with 97% dev satisfaction\n\nA study of Google's code review tooling (Critique), AI-powered improvements,\nand recent statistics\n\nDec 4, 2023\n\n135\n\nShare this post\n\n#### How Google takes the pain out of code reviews, with 97% dev satisfaction\n\nread.engineerscodex.com\n\n22\n\nReady for more?\n\n\u00a9 2024 Engineer\u2019s Codex\n\nPrivacy \u2219 Terms \u2219 Collection notice\n\nStart WritingGet the app\n\nSubstack is the home for great culture\n\nShare\n\n## Create your profile\n\n## Only paid subscribers can comment on this post\n\nAlready a paid subscriber? Sign in\n\n#### Check your email\n\nFor your security, we need to re-authenticate you.\n\nClick the link we sent to , or click here to sign in.\n\n", "frontpage": false}
