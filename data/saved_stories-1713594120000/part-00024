{"aid": "40091946", "title": "How to Exploit a Buffer Overrun", "url": "https://blog.cakers.io/posts/buffer-overrun-exploit/", "domain": "cakers.io", "votes": 1, "user": "tetsuto", "posted_at": "2024-04-19 21:11:21", "comments": 0, "source_title": "Let\u2019s Exploit a Buffer Overrun!", "source_text": "Let's Exploit a Buffer Overrun! | blog.cakers.io\n\n# blog.cakers.io\n\ntechnical faffing\n\nPost\n\n# Let's Exploit a Buffer Overrun!\n\nPosted Jan 4, 2024 Updated Feb 29, 2024\n\nBy Christopher Akers 21 min read\n\nWell, sort of...\n\n### Disclaimer\n\nThis is not a particularly \u2018clever\u2019 example or one that can be used for\ngenuine nefarious purposes in the year 2023.\n\nThe example program we \u2018hack\u2019 is small, written by me, and deliberately\ncontrived for success. We compile it using vanilla cl.exe on the command-line\nwith no additional options and we deliberately disable Microsoft\u2019s\nSafebuffers, something nobody is going to do. Finally, we exploit through a\nvery old C standard library function, a function that was officially replaced\nin 2011 due to the very vulnerability we\u2019re exploiting.\n\nIn all, this example is best described, in British colloquial parlance, as\n\u2018Noddy\u2019. It might have gotten you somewhere in 1987 but not now. It\u2019s purpose\nis to illustrate what a buffer overrun is, exactly, and just one way in which\nthey can leave software open to attack. Plus, it\u2019s fun.\n\nInspiration for this exercise came from an early chapter of Expert C\nProgramming: Deep C Secrets by Peter Van De Linden, a book that was last\npublished in 1994. This should give you some idea of how out of date this\nexample is. Despite it\u2019s age, though, the book is a great read filled with\nhistoric anecdotes and info about the C language. It\u2019s still available from\nAmazon for Kindle.\n\nExpert C Programming: Deep C Secrets, by Peter Van De Linden\n\n## Overview\n\nTake the code snippet below.\n\n    \n    \n    1 2 3 4 5\n\n|\n\n    \n    \n    int print_message() { char message[14]; message = \"Hello World!\\n\"; printf(\"%s\"); }  \n  \n---|---  \n  \nWe define an array of char with fourteen elements then fill the array with the\nmessage \u2018Hello World!\u2019 (twelve characters plus the new-line and room for the\nterminating NUL character).\n\nThe array contents are printed to stdout using printf.\n\nThe array is local so it\u2019s stored in the Local Variables section of the stack-\nframe for print_message(). The diagram below shows a simplified version of the\nWin64 stack layout.\n\nWindows x64 Stack Layout\n\nThe size of the local variables section of a stack-frame is fixed at compile\ntime. The compiler detects the number of local variables in a function, what\ntype they are (and, therefore, what size they are) and emits specific cpu\ninstructions to create and size the stack-frame whenever that function is\ncalled. In this example, space for fourteen char elements will be allocated in\nthe local variables section of the stack-frame for print_message() which is\n14-bytes.\n\nNow look at this small modification to the code.\n\n    \n    \n    1 2 3 4 5\n\n|\n\n    \n    \n    int print_message() { char message[14]; message = \"Hello World, how are you all?\\n\"; printf(\"%s\"); }  \n  \n---|---  \n  \nIt\u2019s the same sized array, but this time we load it with thirty one elements\n(including newline and terminating NUL). In C and a lot of lower-level\nlanguages there\u2019s nothing stopping you from doing this. There are no runtime\nchecks to ensure you\u2019re only loading up to the maximum number of elements\nallocated to an array. If you want these checks you have to program them\nyourself and, it turns out, many developers in the past ..er.. didn\u2019t.\n\nSo, where are these additional elements stored? Well, along with the rest of\nthe array in the Local Variable section of the print_message() stack-frame.\nExcept, now, those extra elements have overwritten parts of that section\nreserved for other local variables. They could even have bled outside the\nsection and overwritten the return address and parts of the calling\nfunctions\u2019s stack-frame. We\u2019ve overrun our buffer.\n\nOrdinarily, this would result in stack corruption and probably a crash shortly\nafter, but there are a number of, arguably, more worrying vulnerabilities.\n\nFor example, it\u2019s possible to add enough elements to our array so that it\noverwrites the return address with a new return address. That is, when the\nfunction finishes execution we can make it branch to code not intended by the\noriginal programmer.\n\n... Which is what we\u2019re going to do in this post.\n\n## The Vulnerability: gets()\n\ngets() man page\n\nThe gets() function (Get String) used to be part of the standard C library. It\ntakes an array of char as a parameter then waits for the user to input a\nstring via stdin to be terminated by newline (pressing enter). The string is\nstored in the array.\n\nThere are no array bounds checks in gets(). You may pass it a char array of\ntwenty but the user could then input ten, fifty, one-thousand characters. It\nwill still write that entire array back to the stack, overwriting anything in\nthe way.\n\ngets() was ejected from the C standard library in 2011 (along with other,\nsimilar functions) and has since been replaced with fgets() which takes an\nadditional int parameter representing the size of the array. This version does\ncarry out a bounds check and only stores the maximum number of char\u2019s\nallocated, regardless of how many the user enters. By now, I\u2019m sure fgets()\nhas replaced any occurrence of gets() in everybody\u2019s Production code ....\nright?\n\n## Our Target Program\n\nBelow is the example program we\u2019re going to use for this demonstration.\n\n    \n    \n    1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25\n\n|\n\n    \n    \n    #include <stdio.h> #include <stdbool.h> static __declspec(safebuffers) bool check_password() { char pwd[20]; printf(\"Enter your super secret password:\"); gets(pwd); // You can never enter the right password in this // program ;-) return false; } int main() { // We want to by-pass this check if (!check_password()) { printf(\"Oh no! You entered the wrong password!\"); exit(1); } // Past this point, you're loose in the system printf(\"Logging you on....\\n\"); exit(0); }  \n  \n---|---  \n  \nA function called check_password() uses gets() to accept a string which will\nbe loaded into an array of char\u2019s. A Boolean value is returned causing main()\nto exit with return code 1 if false, or continue if true.\n\nThe thing is check_password() never returns true, always false. It\u2019s\nimpossible to enter the correct password and you will never get past the check\n... unless you can find some way of jumping over it and into the rest of the\nprogram.\n\n## Safebuffers\n\nOur target program will run on Windows and we\u2019l compile it using the MSVC\nCompiler (cl.exe). By default cl.exe inserts a check called Safebuffers to\nmitigate against buffer overrun attacks. A \u2018cookie\u2019, or value is inserted at\nthe top of the Local Variables section of the stack during the function\nprologue, and then checked again during the function epilogue. A change in\nthat value is seen as a strong indication that some variable in the function\nhas written beyond it\u2019s allocated space. Windows will terminate the program\nimmediately.\n\nBelow is an IDA disassembly of check_password() with Safebuffers enabled. You\ncan see the stack cookie being set-up in the prologue where it\u2019s stored in a\nlocal variable (var_10) at the top of the Local Variables section of the\nstack-frame. It\u2019s generated by xor\u2018ing a global __security_cookie value with\nthe value in rsp (the stack base-pointer). The variable is checked just before\nfunction epilogue with a call to __security_check_cookie.\n\nNote that __security_check_cookie will actually terminate the program if it\nfinds a problem which is why you don\u2019t see anything checking a return value\nafter the call. If there isn\u2019t an issue everything can just continue.\n\ncheck_password() disassembly with Safebuffers enabled\n\nSafebuffers can be disabled for specific functions by adding the following\nline above the function prototype.\n\n    \n    \n    1\n\n|\n\n    \n    \n    static __declspec(safebuffers)  \n  \n---|---  \n  \nYou can see this in line 4 of our program listing, above.\n\nBelow is an IDA disassembly of check_password() again, but this time with\nsafebuffers disabled. You can see the injected security cookie checks are no\nlonger present.\n\ncheck_password() disassembly with Safebuffers disabled\n\nFor more information, see Microsoft\u2019s documentation:\nhttps://learn.microsoft.com/en-us/cpp/cpp/safebuffers?view=msvc-170\n\n## Let\u2019s Exploit!\n\n  1. Compile the test program. I do this using the Visual Studio x64 Native Tools Command Line and cl.exe as this removes a lot of the default options that Visual Studio applies when you build through the IDE. We want this to be a vanilla compilation.\n\nCompiling the Test Program\n\n  2. Once compiled, load into the IDA Disassembler. This can be downloaded for free: https://hex-rays.com/ida-free/.\n\nNote down the offset of the main() function in the image. IDA will probably\nopen the file in \u2018Graph Mode\u2019, so you will need to right-click and select\n\u2018Text Mode\u2019.\n\nThe full diassembly for main() is below and you can see the function image\nstarts at an offset of 0x00000001`40001030 in the executable (the offsets are\nthe numbers on the left).\n\nFinding the location of the main() function in the executable\n\nBy default, Windows 64 executables store their code image at offset\n0x00000001`40000000 (known as the Image Base), but it can be changed. To\nconfirm, we can scroll to the top of the IDA disassembly and check the global\nImage Base value.\n\nFinding the global image base value in the executable\n\nTaking the difference between the two, we now know that the main() function is\nat a 0x1030 byte off-set from the global image base in the executable.\nRemember this number because we\u2019ll use it to locate the function in memory\nwhen we run the program.\n\n  3. Start our Target Program executable but stop at the empty password prompt.\n\nStart the program but stop right here\n\nImmediately take a dump of the process from Task Manager but leave it running.\n\nTake a dump of the program but leave it running\n\n  4. Start WinDbg and load the dump taken in step 1, above.\n\n  5. Find out where our Target Program\u2019s code-base has been loaded by using the lm command and noting the value in the start column.\n    \n        1 2 3 4\n\n|\n\n    \n        0:000> lm m exploit_buffer_overrun Browse full module list start end module name 00007ff7`beb40000 00007ff7`beb69000 exploit_buffer_overrun C (no symbols)  \n  \n---|---  \n  \nAdd the offset found above (0x1030), to the start address. This gives us an\naddress of 00007ff7`beb41030, our expected location of main().\n\n  6. Disassemble using uf to confirm.\n    \n        1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22\n\n|\n\n    \n        0:000> uf 00007ff7`beb41030 exploit_buffer_overrun+0x1030: 00007ff7`beb41030 4883ec28 sub rsp,28h 00007ff7`beb41034 e8c7ffffff call exploit_buffer_overrun+0x1000 (00007ff7`beb41000) 00007ff7`beb41039 0fb6c0 movzx eax,al 00007ff7`beb4103c 85c0 test eax,eax 00007ff7`beb4103e 7516 jne exploit_buffer_overrun+0x1056 (00007ff7`beb41056) Branch exploit_buffer_overrun+0x1040: 00007ff7`beb41040 488d0de11f0200 lea rcx,[exploit_buffer_overrun+0x23028 (00007ff7`beb63028)] 00007ff7`beb41047 e884000000 call exploit_buffer_overrun+0x10d0 (00007ff7`beb410d0) 00007ff7`beb4104c b901000000 mov ecx,1 00007ff7`beb41051 e85a690000 call exploit_buffer_overrun+0x79b0 (00007ff7`beb479b0) exploit_buffer_overrun+0x1056: 00007ff7`beb41056 488d0df31f0200 lea rcx,[exploit_buffer_overrun+0x23050 (00007ff7`beb63050)] 00007ff7`beb4105d e86e000000 call exploit_buffer_overrun+0x10d0 (00007ff7`beb410d0) 00007ff7`beb41062 33c9 xor ecx,ecx 00007ff7`beb41064 e847690000 call exploit_buffer_overrun+0x79b0 (00007ff7`beb479b0) 00007ff7`beb41069 33c0 xor eax,eax 00007ff7`beb4106b 4883c428 add rsp,28h 00007ff7`beb4106f c3 ret  \n  \n---|---  \n  \nSeems legit. You can compare it with the dissembler output in IDA but the\nfunction is very simple and, in this test case, we actually have the source\ncode so can confirm quickly that it\u2019s the right one.\n\n  7. Now, we\u2019re going to take a look at the stack trace.\n    \n        1 2 3 4 5 6 7 8 9 10 11 12 13\n\n|\n\n    \n        0:000> k # Child-SP RetAddr Call Site 00 000000c8`298ffbc8 00007ffe`a58a6b2b ntdll!NtReadFile+0x14 01 000000c8`298ffbd0 00007ff7`beb53e21 KERNELBASE!ReadFile+0x7b 02 000000c8`298ffc40 00007ff7`beb53b2a exploit_buffer_overrun+0x13e21 03 000000c8`298ffce0 00007ff7`beb51db7 exploit_buffer_overrun+0x13b2a 04 000000c8`298ffd20 00007ff7`beb475bb exploit_buffer_overrun+0x11db7 05 000000c8`298ffd50 00007ff7`beb4101a exploit_buffer_overrun+0x75bb 06 000000c8`298ffdb0 00007ff7`beb41039 exploit_buffer_overrun+0x101a 07 000000c8`298ffe00 00007ff7`beb41318 exploit_buffer_overrun+0x1039 08 000000c8`298ffe30 00007ffe`a7e2257d exploit_buffer_overrun+0x1318 09 000000c8`298ffe70 00007ffe`a84eaa58 kernel32!BaseThreadInitThunk+0x1d 0a 000000c8`298ffea0 00000000`00000000 ntdll!RtlUserThreadStart+0x28  \n  \n---|---  \n  \nNote the RetAddr value for stack-frame 0x06: 0x00007ff7`beb41039. It is 0x9\nbytes offset from the start of our main() function, according to the location\nwe worked out in the previous step. You can see what instruction this is in\nthe main() disassembly, above. It\u2019s just after the first call on line 4. It\u2019s\na weird looking one, but all it\u2019s doing is zeroing out all values in eax\nexcept for the ones in its lower byte (move with zero-extension).\n\n    \n        1 2\n\n|\n\n    \n        00007ff7`beb41034 e8c7ffffff call exploit_buffer_overrun+0x1000 (00007ff7`beb41000) 00007ff7`beb41039 0fb6c0 movzx eax,al  \n  \n---|---  \n  \nMy money is on this call being the call to check_password(). We can confirm by\nlooking in IDA again to get the location of check_password(). According to\nthis call instruction, we should expect it at an offset of 0x1000 from the\nprogram\u2019s code-base.\n\nFinding the location of check_password() in the executable\n\nYep, that seems to be it. This means check_password() should be at address\n0x00007ff7`beb40000 + 0x1000 (0x00007ff7`beb41000) in memory. Let\u2019s uf that\naddress in WinDbg.\n\n    \n        1 2 3 4 5 6 7 8 9 10 11\n\n|\n\n    \n        0:000> uf 0x00007ff7`beb41000 exploit_buffer_overrun+0x1000: 00007ff7`beb41000 4883ec48 sub rsp,48h 00007ff7`beb41004 488d0df51f0200 lea rcx,[exploit_buffer_overrun+0x23000 (00007ff7`beb63000)] 00007ff7`beb4100b e8c0000000 call exploit_buffer_overrun+0x10d0 (00007ff7`beb410d0) 00007ff7`beb41010 488d4c2420 lea rcx,[rsp+20h] 00007ff7`beb41015 e882660000 call exploit_buffer_overrun+0x769c (00007ff7`beb4769c) 00007ff7`beb4101a 32c0 xor al,al 00007ff7`beb4101c 4883c448 add rsp,48h 00007ff7`beb41020 c3 ret  \n  \n---|---  \n  \nYay, there it is!\n\n  8. Now to find the exact location of our array (pwd) in the stack-frame.\n\nIn the check_password() disassembly above there are two call instructions.\nLooking in IDA, we can see the first is a call to printf which will be the\npassword prompt. The second call is to gets(), the function that reads input\nand the one we\u2019re trying to exploit. Just above both call\u2019s are lea\ninstructions (Load Effective Address) loading the address of something into\nrcx. (rcx is used to pass first parameter when calling a function according to\nthe Windows ABI). In the first case, this will be the address of the string\n\u2018Enter your super secret password:\u2019 as the parameter to printf(), and in the\nsecond case it will be the address of our array (rsp+20h).\n\nWe can replace rsp with the stack-frame base address to find out exactly where\nthis is in the stack-frame.\n\n    \n        1 2\n\n|\n\n    \n        0:000> ?000000c8`298ffdb0+20h Evaluate expression: 859690761680 = 000000c8`298ffdd0  \n  \n---|---  \n  \nSo, we expect our pwd array to be stored at address 000000c8`298ffdd0.\n\n  9. Now, lets dump out the entire stack-frame so we can find our array and the return address.\n    \n        1 2 3 4 5\n\n|\n\n    \n        # Child-SP RetAddr Call Site ... 06 000000c8`298ffdb0 00007ff7`beb41039 exploit_buffer_overrun+0x101a 07 000000c8`298ffe00 00007ff7`beb41318 exploit_buffer_overrun+0x1039 ...  \n  \n---|---  \n  \nDump out bytes between the two Child-SP locations for stack-frame 06 and 07. I\nlike dumping them 1 byte per column because I find it easier to read. It does\ngenerate a long listing, though.\n\nThe command is: db /c1 000000c8298ffdb0 (000000c8298ffe00-1)\n\nWe subtract 1 from the address of stack-frame 0x7 (main()) because that is\nactually the base address of stack-frame 0x7 which we don\u2019t need.\n\nInstead of just duplicating the listing from WinDbg, I\u2019ve imported it into\nExcel and mapped out the different stack-frame sections for easier reading,\nbut if you were to just view it in WinDbg you would see the first three\ncolumns.\n\nStack-frame 06\n\nAt the top we have the four eight-byte sections for register parameter home\nspace. According to the Windows ABI 32-bytes of space must be always preserved\nfor fastcall parameters, that is parameters passed in registers RCX, RDX, R8\nand R9 when one function calls another. Note that the space is for parameters\nto be passed to a subsequent calling function, not actually this one. When a\nfunction is called from this one (in our case it will be gets()) it\u2019s the new\nfunction that actually deposits their register parameters, here, just before\nit modifies the stack-pointer. Also note that this space can be used as\nseparate scratch storage, too, especially if the code has been compiled as an\noptimised release. Either way we\u2019re not concerned about this section in this\nexercise, or what it contains.\n\nThere\u2019s no Additional Parameters section in the stack-frame because we only\ncall gets() with one parameter which will be loaded into the RCX register then\nbacked up in the home-space, as described above.\n\nThe Local Variables section has space allocated for our array at the exact\naddress we expected from the step above: 000000c8`298ffdd0 and continuing for\n20 bytes. There is an additional 20 bytes allocation after this which I\nbelieve is for alignment purposes. The stack-frame pointer (rsp) must be\naligned on a 16-byte boundary, again according to the Windows ABI.\n\nFinally, just outside the stack-frame, we have the 8-byte return address\nbeginning at 0x000000c8`298ffdf8 (it appears backward due to the way it\u2019s\nstored). The address is 0x00007ff7`beb41039 which matches the return address\nin our stack trace, above, and is the address of the line in main() just\nbeneath the call where the result is loaded into rax ready for the check. This\nis the address we want to manipulate.\n\n  10. Let\u2019s look at the disassembly of main() again.\n    \n        1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22\n\n|\n\n    \n        0:000> uf 00007ff7`beb41030 exploit_buffer_overrun+0x1030: 00007ff7`beb41030 4883ec28 sub rsp,28h 00007ff7`beb41034 e8c7ffffff call exploit_buffer_overrun+0x1000 (00007ff7`beb41000) 00007ff7`beb41039 0fb6c0 movzx eax,al 00007ff7`beb4103c 85c0 test eax,eax 00007ff7`beb4103e 7516 jne exploit_buffer_overrun+0x1056 (00007ff7`beb41056) Branch exploit_buffer_overrun+0x1040: 00007ff7`beb41040 488d0de11f0200 lea rcx,[exploit_buffer_overrun+0x23028 (00007ff7`beb63028)] 00007ff7`beb41047 e884000000 call exploit_buffer_overrun+0x10d0 (00007ff7`beb410d0) 00007ff7`beb4104c b901000000 mov ecx,1 00007ff7`beb41051 e85a690000 call exploit_buffer_overrun+0x79b0 (00007ff7`beb479b0) exploit_buffer_overrun+0x1056: 00007ff7`beb41056 488d0df31f0200 lea rcx,[exploit_buffer_overrun+0x23050 (00007ff7`beb63050)] 00007ff7`beb4105d e86e000000 call exploit_buffer_overrun+0x10d0 (00007ff7`beb410d0) 00007ff7`beb41062 33c9 xor ecx,ecx 00007ff7`beb41064 e847690000 call exploit_buffer_overrun+0x79b0 (00007ff7`beb479b0) 00007ff7`beb41069 33c0 xor eax,eax 00007ff7`beb4106b 4883c428 add rsp,28h 00007ff7`beb4106f c3 ret  \n  \n---|---  \n  \nLine\u2019s 5, 6 and 7 are testing the check_password() result and branching if\nthat result is true.\n\nThe test command (line 6) simply performs a logical AND on it\u2019s parameters and\nsets the CPU zero-flag accordingly. In this case, if eax contains 0 (false)\nthen ANDing it with itself will also result in 0 and will set the CPU zero-\nflag. If it contains 1 (true) then ANDing it with itself will result in 1\nwhich will not set the zero flag (true).\n\nJNE (Jump if Not Equal) is an instruction to branch if the previous command\ndidn\u2019t set the zero flag (check_password() returned true). If it did, then\nexecution just drops to the next instruction at line 10 (0x00007ff7`beb41040)\nwhich is the section that prints the error message and exits with code 1.\n\nHow can we modify the the return address in stack-frame 06 so that it points\nto the same location as the one jumped to in line 7 (0x00007ff7`beb41056), as\nif the password check evaluated to true?\n\nWe overrun the buffer (or the array).\n\nIf we enter twenty characters into the password prompt of our program we fill\nup the array. If we then entered another 20 we fill up the alignment section\nof Local Variables (according to the diagram, above). Then all we need to do\nis enter: 5610b4bef77f0000 and the return address will be replaced.\n\n... Well, not quite.\n\nThe string 5610b4bef77f0000 is just that, a string. All that will happen is\nthe ASCII codes for each digit in 5610b4bef77f0000 will be loaded into the\nstack. What we want is the actual numbers, themselves, not their ASCII codes.\nTo do that we\u2019re going to need to use the Windows Numpad along with the ALT\nkey.\n\n  11. Split the address up into it\u2019s individual bytes: 56 10 b4 be f7 7f 00 00.\n\n  12. Convert those individual bytes into their decimal representation: 86 16 68 116 127 247 00 00\n\n  13. Now, open Notepad and, using the number-pad only on your keyboard, hold down ALT and enter each number up to the 00\u2019s. After each number, release ALT. You will see whatever symbol notepad interprets the number as.\n\nThe table below formats it out so it\u2019s a bit clearer:\n\nHEX| DEC| Symbol  \n---|---|---  \n56| 86| V  \n10| 16| \u25ba  \nb4| 180| \u2524  \nbe| 190| \u255b  \nf7| 247| \u2248  \n7f| 127| \u2302  \n  \nWhy don\u2019t we add the 00\u2019s? Fortunately, gets() adds the terminating 00 to our\nstring, so we only need to make sure we enter up to the first 00. Entering 00\n(effectively, hard-coded NUL) using the keyboard is actually quite tricky,\nanyway \ud83d\ude09.\n\nSo the string we have to enter when replacing the return address is: V\u25ba\u2524\u255b\u2248\u2302\nThis will insert the correct bytes to make up our new address. Exciting.\n\n  14. Now back to the command prompt where we started our program and to enter the following string (remember, yours will be different, but following the steps above will get you the correct one)\n\n> For the \u2018special\u2019 characters that represent the new return address it\u2019s best\n> to enter those in Notepad first then paste them into the prompt at the right\n> point. This saves having to do it all again if you make a mistake with the\n> ALT key or the Windows command prompt decides to mess with you!\n\nString to enter: XXXXXXXXXXXXXXXXXXXXZZZZZZZZZZZZZZZZZZZZV\u25ba\u2524\u255b\u2248\u2302\n\nThis maps out to:\n\nArray (20-bytes)| Alignment (20-bytes)| Return Address (6-bytes minus the\n00\u2019s)  \n---|---|---  \nXXXXXXXXXXXXXXXXXXXX| ZZZZZZZZZZZZZZZZZZZZ| V\u25ba\u2524\u255b\u2248\u2302  \n  \nThere\u2019s no particular reason I chose X and Z, they\u2019re just filler characters.\nYou can use whichever ones you want.\n\nFingers crossed, here we go...\n\n  15. ...Did it work?\n\nLogging You On!\n\nWohoo! We\u2019ve replaced the check_password() function return address which has\nenabled us to ignore the result of the password check entirely. We\u2019re in! \ud83d\ude31\n\n## Conclusion\n\nOnce you get away from the abstractions of higher-level languages you get a\nsense of how everything is just a number to a CPU. It doesn\u2019t understand the\ncontext in which you\u2019re using these values, it doesn\u2019t care that you might be\nbehaving badly (or even mistakenly) when asking it to recalculate certain\nvalues in registers. It will simply do as its told.\n\nIn modern computing, compilation is still often seen as the end of the\nsoftware engineers job. A lot of graduates will come out having mastered, say,\nthe latest functional programming paradigm, but have never seen what any of\ntheir software looks like when it\u2019s running through a CPU. There\u2019s an\nassumption that the gate-keeping and rules of modern languages and\nabstractions mean code is safe if it gets as far as an executable. Anything\nelse would have been caught by a compiler or an interpreter or a linter or\neven testing.\n\nWhat actually happens is the gate-keeping is stripped-out altogether, it\ndoesn\u2019t exist at a machine-code level. Even something as basic as a type\ndoesn\u2019t really exist. All you need is a way in and you can start making\nchanges that breach the cosy rules of your favourite programming language.\nSomething as simple as a buffer overrun is one of those ways in.\n\nAttacks can get way more sophisticated than a simple fudging of a return\naddress, too. For instance, in the example above, we actually have 40-bytes to\nplay with in the Local Variable space. Can we load opcode bytes into that\nlocal array, effectively writing a small program within the 40 bytes of space\navailable and then set the return address to the top of the array? Why not? As\nlong as there\u2019s a way in.\n\nEven Safebuffers can be circumvented if you know what the security-cookie\nvalue is, and you can find that out by dumping the stack-frame and getting its\naddress from the disassembly, as we did above to locate the array. The CPU\ndoesn\u2019t care that those values make up a security cookie, that\u2019s an\nabstraction implemented by the Windows ABI on top of those values. The CPU\nwill happily change them or write over them if you ask it to.\n\nAs I pointed out earlier, the example in this post isn\u2019t a particularly\nsophisticated hack, especially in 2023, but I had fun going through it to see\nif I could get it to work. It was surprisingly simple, and I think that\u2019s\nimportant. It\u2019s easy to dismiss these kinds of things as something only\nsomeone with intimate cyber knowledge and experience can accomplish but,\ndespite the set-up being very contrived, I still managed to do it without any\nparticularly sophisticated knowledge or expensive tools.\n\nAll good, clean fun! \ud83d\ude2c\n\ntech\n\ncyber c assembler engineering Windows\n\nThis post is licensed under CC BY 4.0 by the author.\n\nShare\n\n## Recently Updated\n\n  * MASM: Bubble Sorting in Assembler lol!\n  * Python: OneDriveTokenHandler (Microsoft Graph API)\n  * Book: Thank You Jeeves, P.G. Wodehouse\n  * Python: MSAL Token Persistence & Auto-Refresh (Microsoft Graph API)\n  * Let's Exploit a Buffer Overrun!\n\n## Trending Tags\n\nassembler engineering Microsoft Graph MSAL Python C fiction biography bubble\nsort c\n\n## Contents\n\n### Further Reading\n\n\u00a9 2024 Christopher Akers. Some rights reserved.\n\nUsing the Chirpy theme for Jekyll.\n\n## Trending Tags\n\nassembler engineering Microsoft Graph MSAL Python C fiction biography bubble\nsort c\n\nA new version of content is available.\n\n", "frontpage": false}
