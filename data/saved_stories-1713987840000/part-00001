{"aid": "40144309", "title": "Patching requests for fun and (concurrent) profit", "url": "https://blog.borrego.dev/entries/patching-requests-for-fun-and-concurrent-profit.html", "domain": "borrego.dev", "votes": 1, "user": "agubelu", "posted_at": "2024-04-24 13:42:20", "comments": 0, "source_title": "Patching requests for fun and (concurrent) profit", "source_text": "Patching requests for fun and (concurrent) profit\n\nBack to index\n\n# Patching requests for fun and (concurrent) profit\n\n24 apr. 2024\n\nBecause life is too short to spam calls to SSL_CTX_load_verify_locations().\n\n## What's the issue?\n\nLet's consider the following script. It runs a bunch of concurrent requests\nagainst a URL using the requests library, both with certificate verification\nenabled and disabled, and outputs the time it takes to do it in both cases.\n\n    \n    \n    from time import time from threading import Thread import requests import urllib3 # Mute warnings when cert verification is disabled urllib3.disable_warnings() def do_request(verify): requests.get('https://example.com', verify=verify) def measure(verify): threads = [Thread(target=do_request, args=(verify,)) for _ in range(30)] start = time() for t in threads: t.start() for t in threads: t.join() end = time() print(end - start) measure(verify=True) measure(verify=False)\n\nWhat's the time difference between the two? It turns out it is highly\ndependent on your local configuration. On my local machine, with a relatively\nmodern config (Python 3.12 + OpenSSL 3.0.2), the times are ~1.2s for\nverify=True and ~0.5s for verify=False.\n\nIt's a >100% difference, but we initially blamed it on cert verification not\nbeing trivial and taking some time. However, we observed even larger\ndifferences (>500%) in some of our environments, and decided to find out what\nwas going on.\n\n## What's going on?\n\nOur main use case for requests is running lots of requests concurrently, and\nwe spent some time bisecting this oddity to see if there was room for a\nperformance optimization.\n\nThe issue is a bit more clear after profiling the concurrent executions. When\nverifying certs, these are the top 3 function calls by total time spent in\nthem among all threads:\n\n    \n    \n    ncalls tottime percall cumtime percall filename:lineno(function) 30/1 0.681 0.023 0.002 0.002 {method 'load_verify_locations' of '_ssl._SSLContext' objects} 30/1 0.181 0.006 0.002 0.002 {method 'connect' of '_socket.socket' objects} 60/2 0.180 0.003 1.323 0.662 {method 'read' of '_ssl._SSLSocket' objects}\n\nConversely, this is how the top 3 looks like without cert verification:\n\n    \n    \n    ncalls tottime percall cumtime percall filename:lineno(function) 30/1 0.233 0.008 0.001 0.001 {method 'do_handshake' of '_ssl._SSLSocket' objects} 30/1 0.106 0.004 0.002 0.002 {method 'connect' of '_socket.socket' objects} 60/2 0.063 0.001 0.505 0.253 {method 'read' of '_ssl._SSLSocket' objects}\n\nIn the first case, a full 0.68 seconds are spent in the\nload_verify_locations() function of the ssl module, which configures a\nSSLContext object to use a set of root CA certificates for validation. This is\ndone via a C FFI call to OpenSSL's SSL_CTX_load_verify_locations() which is\nknown to be quite slow. This happens once per request (hence the 30 on the\nleft).\n\nTaken at face value, 0.68 seconds isn't that big of a deal, but please note\nthat this is longer than the network wait for the requests themselves. In\nscenarios with a higher concurrency, we have also observed some global\nblocking going on, either because each FFI call locks up the GIL or because of\nsome thread safety mechanisms in OpenSSL itself. In either case, the\nperformance hit gets worse and worse as you scale the number of concurrent\nrequests up. We also think that this is more or less pronounced depending on\ninternal changes between OpenSSL's versions, hence the variability between\nenvironments.\n\nWhen cert validation isn't needed, these calls are skipped which speeds up\nconcurrent performance dramatically.\n\n## A possible fix\n\nIt isn't possible to skip loading root CA certificates entirely, but it isn't\nnecessary to do it on every request. At the time of writing this, a call to\nload_verify_locations() happens when:\n\n  * A new urllib3.connectionpool.HTTPSConnectionPool is created, or\n\n  * On each connection, by urllib3's ssl_wrap_socket(), when the connection's ca_certs or ca_cert_dir attributes are set (see the relevant code).\n\nRecently, Requests added an internal _get_connection() function that caches\nconnection pools, and so, for most cases, the first case doesn't need to be\naddressed anymore, since most HTTPS requests will share the same cached\nHTTPSConnectionPool instead of creating one per request.\n\nThe second one is addressed in the submitted PR. It creates a default\nSSLContext with the default CA certificates already loaded, and patches the\nfunction that hooks up each connection with a secure context to reuse the\ndefault one:\n\n    \n    \n    DEFAULT_SSL_CONTEXT = create_urllib3_context() DEFAULT_SSL_CONTEXT.load_verify_locations(extract_zipped_paths(DEFAULT_CA_BUNDLE_PATH)) def _urllib3_request_context( ... cert_reqs = \"CERT_REQUIRED\" if verify is False: cert_reqs = \"CERT_NONE\" + elif verify is True: + pool_kwargs[\"ssl_context\"] = DEFAULT_SSL_CONTEXT + elif isinstance(verify, str): + if not os.path.isdir(verify): + pool_kwargs[\"ca_certs\"] = verify + else: + pool_kwargs[\"ca_cert_dir\"] = verify pool_kwargs[\"cert_reqs\"] = cert_reqs\n\nWhen verify=True, we provide the connection pool with a SSLContext with the CA\ncertificates already loaded. As shown, by not setting ca_certs or ca_cert_dir\nin that case, we avoid a spurious call to load_verify_locations() by urllib3\nand cert verification still works as intended. A couple of additional changes\nare also made in the PR to carefully avoid setting those two connection\nparameters when not needed.\n\nA small caveat happens when verify isn't a boolean, but rather a string\nindicating a path to an alternative CA bundle or cert store. In those cases,\nwe do set ca_certs or ca_cert_dir accordingly to ensure that the alternative\nCA bundle requested by the user is loaded instead. There is further room for\noptimization here, because this use case will still incur in a call to\nload_verify_locations() per request. Perhaps the previous approach could be\ngeneralized by caching different SSLContext objects depending on the CA bundle\nthat the request wishes to use.\n\nNB: Most of the content of this post is taken from the corresponding pull\nrequest that I submitted to Requests. As of publishing this, it doesn't seem\nto be in a very active state, and to the best of my knowledge the issue still\npersists.\n\n# Agust\u00edn Borrego\n\nHi! I'm a software engineer from Spain.\n\nCurrently, Data Engineer @ MixRank.\n\n", "frontpage": false}
