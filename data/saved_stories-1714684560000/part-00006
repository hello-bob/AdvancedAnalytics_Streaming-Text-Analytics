{"aid": "40236334", "title": "Modeling usage-based billing with Stripe, from pricing model to code", "url": "https://prefab.cloud/blog/modeling-usage-based-billing-with-stripe/", "domain": "prefab.cloud", "votes": 3, "user": "louisbennett", "posted_at": "2024-05-02 13:52:46", "comments": 0, "source_title": "Modeling Usage Based Billing with Stripe", "source_text": "Modeling Usage Based Billing with Stripe | Prefab\n\nSkip to main content\n\n### First-Class Feature Flags. Out of the box.\n\nSay goodbye to context switching and hello to feature flags in your IDE.\n\nLearn More\n\n# Modeling Usage Based Billing with Stripe\n\nApril 25, 2024 \u00b7 9 min read\n\nJeff Dwyer\n\nPrefab Founder & Engineer\n\nLet's take a look at the Prefab pricing page and go step through step how we\nmodelled it using Stripe's new Usage Based Billing APIs.\n\nPrefab sells things like Feature Flags and Dynamic Log Levels with awesome\ndeveloper tooling. We charge money on two dimensions, both of which try to\nreflect the effort it takes us to support our customers. Those dimensions are:\n\nServers We need to keep a live connection open for each of the servers side\nSDK that you use to connect. We charge $2 / server for this, but that goes\ndown to $1 or $.80 at higher volume.\n\nRequests Front end clients make requests to get feature flag evaluations. We\ncharge for these requests at the rate of $10 per 1.5M, with better pricing on\nthe higher tiers.\n\n## Modeling Associated Products\n\nTo setup billing in Stripe, you need to decide what your products and prices\nare going to be. This sounds like it should be easy, but there are actually a\nlot of different ways to go about modeling things. Here's what we did.\n\nIn this diagram the green boxes represent the \"product\" and the blue represent\nprices.\n\nHaving a single \"product\" for \"Servers\" is clearly the right move, but what\nabout the base tier pricing? You could probably model the 3\nFree/Basic/Enterprise as a single \"product\" called \"platform\" with 3 different\nprices. Why not do that? Well the Stripe pricing table let's you use an HTML\nwidget <stripe-pricing-table>. It was our intention to use this weidget,\nbecause the less code the better, right? When you go to setup that widget\nhowever, it was very much \"add your product\" as the primary choices. Since for\nus, the choice here is Basic/Pro/Enterprise, this lead us to have a Product\nfor each.\n\nnote\n\nThe <stripe-pricing-table> lets you add more than one price for the same\nproduct, but this seems to be for allowing monthly / annual billing.\n\nnote\n\n#### Moving Beyond Pure Usage Based\n\nOriginally, we were purely usage based, ie \"just $1 / server\" but we\ndiscovered customers wanted easier ways to estimate their bill. Ask a customer\nto estimate their bill and there's friction, but tell them it's \"$99 for up to\n100 server connections\" and they can just say \"oh great, we have fewer than\nthat so the bill won't be more than $99/month\". It's a touch irrational when\nyou've got your engineer hat on, but it turns out that being kind to the\nactual people doing the software purchasing is a good idea for us.\n\nIn order to have tiers in combination with usage based overage we end up with\npricing of the form \"$99 for the first 100 and then $99 per 100 after that\".\nThe term of art for this is Graduated / Tier based pricing even though our\ntiers are the same price. We'll get into more details shortly.\n\n## Connecting Subscriptions to Prices\n\nWhen we go to create a subscription, we'll see that a subscription is\nbasically just a payment method, associated with a set of prices. Each\nconnection is called a SubscriptionItem.\n\n    \n    \n    Stripe::SubscriptionItem.create({ subscription: 'sub_1Mr6rbL', price: 'price_1Mr6rdLkdI' })\n\nHere's an ER diagram of the billing modeling, representing a customer\nsubscribed to the Pro plan. You can see that the basic and enterprise prices\nare not connected to the user's subscription.\n\ntip\n\nI've named the prices Pro.Servers.0 I would highly recommend that you do\nsomething similar and add in a number to indicate the price version. These\nprices are pretty immutable once you get going and it's easy to make mistakes.\nA little bit of version control in your naming will prevent server-price-\nbasic-v2-copy-use-this-one type fiascos.\n\nThe important take-away here is that in our world, there are really \"tightly\ncorrelated prices\". If you have the \"pro\" prices for your subscription, then\nyou need to have the \"pro.server\" price for your Server product.\n\nThe main code that we're going to end up writing is the logic to ensure that\nthese prices remain correlated as subscriptions change.\n\n## Usage Based Billing\n\nHere's the data model of Stripe's usage based billing, right from their\ndocumentation.\n\nThis is much better than the previous model, which we discussed earlier.\n\nOur usage based tracking is really going to be very simple. For the prices\nbasic.requests.0, pro.requests.0 etc, we just set them up to reference the\nsame meter: billable_requests. This makes our code that records usage totally\noblivious to what subscription the customer has, which is just what we want.\n\nThis is also really useful for trials / free tiers. We create a customer for\neach Prefab team when they signup and we can instantly start tracking usage\nfor them against a Meter. Eventually our customer will add a subscription and\nat that point the usage can start making it onto an invoice. But it's nice to\nbe able fully separate the concern of measuring and tracking usage from the\nmore intricate dance of creating and adjusting subscriptions & prices.\n\n    \n    \n    def create_billable_requests_meter_events(amount, api_usage, event_type) attr = { event_name: \"billable_requests\", timestamp: api_usage.day.to_time(:utc).to_i, payload: { stripe_customer_id: @team.stripe_customer_id, value: amount, } Stripe::Billing::MeterEvent.create(attr) end\n\n## Rendering the Pricing Table\n\nOk, so we've seen how we modelled our Products and Prices. We've started\nrecording metered usage for our customers. How do we connect the two? How do\nwe actually create a subscription and add the correct 3 prices as subscription\nitems?\n\nThe promise of Stripe handling the entire pricing table was appealing to me.\nWith our product information already in the system, I was able to quickly\ncreate a PricingTable object from my Stripe Product Catalog and then I just\ndropped the following into my billing page.\n\n    \n    \n    <script async src=\"https://js.stripe.com/v3/pricing-table.js\"></script> <stripe-pricing-table pricing-table-id=\"prctbl_9999999\" publishable-key=\"pk_live_uCl3999999999\"> </stripe-pricing-table>\n\nThis rendered me a nice looking pricing table and clicking on the button took\nme to a nice checkout experienve, so at first I thought I was all done.\n\nProblems:\n\n  1. A small thing, but I had to make a separate dark mode and light mode table which was... unfortunate.\n\n  2. It only worked for Creating a subscription. I couldn't use the same tool to let people upgrade / downgrade a subscription. This was bigger bummer. (You see I can only 'cancel' the subscription from the Customer Portal).\n\nBecause of #2, if I was going to let people switch from Basic to Pro without\ncanceling Basic, I essentially felt the need to rewrite a pricing table. If I\nwas going to do that anyway, then I wanted it to be consistent, so I did not\nend up using this pricing widget.\n\n## The Code We Wrote\n\nThe code we wrote came in 4 parts. Here are the 4 things that our code needs\nto accomplish:\n\n  1. Creating a subscription. eg basic and basic.requests.0 and basic.servers.0.\n  2. Change a subscription from eg basic to pro which should remove basic and add pro\n  3. Catch webhook for subscription change and \"reconcile\". Remove basic.requests.0 and basic.servers.0 and add pro.requests.0 and pro.servers.0.\n  4. Mapping in code of the underlying stripe price IDs, so that when we reconcile we can know what price ID to add in production for pro.\n\n### 1) Basic Create of the Core Subscription\n\n    \n    \n    def self.create_checkout_session(team, new_plan_name, return_url) new_object = StripeProducts.find_by(name: new_plan_name)\n    \n    session = Stripe::Checkout::Session.create( customer: team.stripe_customer_id, line_items: [{ price: new_object.product_price_id, quantity: 1 }, { price: new_object.servers_price_id }, { price: new_object.requests_price_id } ], mode: 'subscription', success_url: return_url, cancel_url: return_url, subscription_data: { billing_cycle_anchor: StripeProducts.get_billing_cycle_anchor } ) session end\n\nWe don't actually have to add the servers and requests prices here, since the\nwebhook would reconcile them for us. However the checkout page is better if it\nhas all 3 prices at the time of customers adding a credit card.\n\n### 2) Change a Subscription\n\n    \n    \n    def self.change_subscription(team, new_plan_name) subscription = team.get_subscription\n    \n    old_product_object = get_product_for(subscription) new_object = StripeProducts.find_by(name: new_plan_name)\n    \n    if old_product_object old_si = subscription.items.filter { |si| si.price.id == old_product_object.product_price_id }.first Stripe::SubscriptionItem.delete(old_si.id) end\n    \n    new_si = Stripe::SubscriptionItem.create( subscription: subscription.id, price: new_object.product_price_id ) end\n\n### 3) Ensure Correct Related Products\n\n    \n    \n    def process_webhooks case data.dig(\"type\") when 'customer.subscription.created' || 'customer.subscription.updated' process_subscription end end\n    \n    def process_new_subscription subscription = data.dig(\"data\", \"object\") team = Team.find_by_stripe_customer_id(subscription.dig(\"customer\")) ensure_correct_subscription_items(team) end\n    \n    def ensure_correct_subscription_items(team) subscription = team.get_subscription\n    \n    prices_to_add(subscription).each do |price_id| Stripe::SubscriptionItem.create({ subscription: subscription.id, price: price_id }) end\n    \n    subscription_items_to_remove(subscription).each do |item| Stripe::SubscriptionItem.delete(item.id, clear_usage: true) end end\n    \n    def prices_to_add(subscription) ## if subscription is Pro, return [pro.requests.0, pro.servers.0] end def prices_to_remove(subscription) ## if subscription is Pro, return anything that isn't \"pro.*\" end\n\n### 4) A Mapping of Associated Products\n\nBacking all of this, we did have to have a map of these \"associated prices\".\nWhen the \"reconciler\" runs it can use this mapping to find the request and\nserver price ids for the given product price id.\n\n    \n    \n    class StripeProducts < ActiveHash::Base LOG = SemanticLogger[self] self.data = [ { id: 1, name: 'Basic', default: OpenStruct.new( product_price_id: 'price_1Or44444444', requests_price_id: 'price_1Or5555555', servers_price_id: 'price_1Or06666666' ), production: OpenStruct.new( product_price_id: 'price_1O77777777', requests_price_id: 'price_1O8888888', servers_price_id: 'price_1Oz1999999' ) }, { id: 2, name: 'Pro', default: OpenStruct.new( product_price_id: 'price_1Or4111111', ...\n\nThis big file of the various Pricing IDs is not my favorite, but it works. I\nconsidered Stripe Terraform but it didn't have support for the new Meter\nobject yet. I considered generating my prices in code and then saving the IDs\nout to a file. That might be a more elegant solution, but the quantity of\nthese was below the threshold that was an obvious win for automation in my\nopinion.\n\n## Conclusion\n\nThe great thing about Stripes new support for Usage Based Billing and Meters\nis that the \"usage\" part has gotten very simple and is hardly something you\nneed to think about anymore. Just decide your meters and record usage for the\ncustomer.\n\nIt still takes a decent amount of thinking for correctly model your products\nand prices, but now you can focus on these as their own problem. I hope taking\na look at what we did at Prefab was helpful. Get in touch if you want to run\nyour modeling past me while this is all still loaded in my brain.\n\nTags:\n\n  * Engineering\n\nLike what you read? You might want to check out what we're building at Prefab.\nFeature flags, dynamic config, and dynamic log levels. Free trials and great\npricing for all of it.\n\nSee our Feature Flags\n\nAbout us\n\n  * We like standing on the back of giants. We\u2019re pushing the boundaries of what\u2019s possible, instead of re-writing the same system we wrote someplace else. We help you tackle new challenges, instead of repeating old ones.\n\n  * Twitter\n  * LinkedIn\n\nFeatures\n\n  * Feature Flags\n  * Dynamic Configuration\n  * Dynamic Log Levels\n  * Secret Management\n  * Developer Tools\n  * Rate Limits\n\nSupport & Resources\n\n  * Get Help\n  * Documentation\n  * Tutorials\n  * Status\n  * Blog\n  * Github\n\nCompany\n\n  * Privacy Policy\n  * Terms of Service\n  * Contact Us\n\nCopyright \u00a9 2024 Prefab, Inc.\n\n", "frontpage": false}
