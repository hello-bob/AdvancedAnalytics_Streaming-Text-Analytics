{"aid": "40179811", "title": "Lessons to a Junior Software Developer", "url": "https://qedpost.substack.com/p/lessons-to-a-junior-software-developer", "domain": "qedpost.substack.com", "votes": 1, "user": "davyAdewoyin", "posted_at": "2024-04-27 13:28:31", "comments": 0, "source_title": "Lessons to a junior software developer", "source_text": "Lessons to a junior software developer - by Davy - QED\n\n# QED\n\nShare this post\n\n#### Lessons to a junior software developer\n\nqedpost.substack.com\n\n#### Discover more from QED\n\nMusings on ideas, innovation and the human impact.\n\nContinue reading\n\nSign in\n\n# Lessons to a junior software developer\n\n### Here are a few important lessons and insights I've gained to help you grow\non your software development journey.\n\nDavy\n\nApr 26, 2024\n\nShare this post\n\n#### Lessons to a junior software developer\n\nqedpost.substack.com\n\nShare\n\n###\n\n1.Writing code doesn't magically become easier,\n\nWriting code doesn\u2019t magically become easier but the more you code, the faster\nyou become at making the decisions needed to write it.\n\nAs a beginner, you'll always feel frustrated and overthink every detail. You\nconstantly question your choices: \"Should I use an if statement here or a for\nloop? and the compiler will scream at you a lot with cryptic error messages\nwhen you feel you just got it right.\n\nThanks for reading QED! Subscribe for free to receive new posts and support my\nwork.\n\nEvery language has its quirks and its own set of esoteric rules, and in your\nattempt to learn them, you will have a lot of headaches. But that's just the\nnature of learning, and programming is no exception. You will trip a lot\nlearning how to dance, , and mastering an instrument requires you to memorize\nevery note and key. However, with consistent practice, the rules become\ningrained, almost like an instinct or second nature, and that, my friend, is\ncalled mastery.\n\nIn the early days of learning Rust, there were so many rules, making it hard\nto imagine anyone being productive. But over time and with practice, I stopped\ngetting tripped up by the rules. I still understand them all and keep track of\nthem, but now I use them without even thinking subconsciously This fluency in\nRust, maybe even more than other languages, came entirely from practice and\nlearning. So keep practicing until it becomes natural and you will achieve\nmastery.\n\n###\n\n2.To get faster, you need a lot of knowledge.\n\nFor young devs, the most important goal is learn continuously. The more you\nlearn, the more rewarding and enjoyable coding becomes. No developer\nappreciates stumbling upon errors and being left puzzled about what to do. And\nthe key to having a wonderful coding experience is to get as knowledgeable as\npossible. You will need to know a few things, including:\n\n1\\. Understanding the Problem domain: Before you code, take time to grasp the\nproblem you're trying to solve. This involves understanding the \"what\" - the\ndomain and its specific needs.\n\n2\\. Mastering the tools and how to accomplish your task: understand the how.\nThis includes familiarity with your preferred programming language, tools, and\ngeneral software development principles. For backend engineers, that means\nlearning about Rest, Http and the like.\n\n3\\. And as a junior programmer, the most crucial thing you should know, is how\nto acquire the necessary information in the future. Yes, gaining knowledge\nabout how to acquire knowledge. You should be familiar with stack overflow,\nGitHub, and forums, and don't be hesitant to read documentation for any\nlanguage or tool you use.\n\nMany programmers started their learning journey by watching tutorials, but to\nadvance, you must go deeper into documentation and articles. When you don't\nunderstand something, you should be able to able figure your way around it and\nask polite and reasonable questions. An AI chatbot, such as Copilot or Gemini,\nis an important tool in your arsenal that you should use extensively but with\ncaution, as they are not a substitute for true documentation.\n\nSo develop a framework for learning and a systematic approach to problem\nsolving. To learn how to perform most things effectively, always start with\ndocumentation and then move on to articles, tutorials, Reddit, and Stack\noverflow to get more details.\n\n###\n\n3\\. Learn Deeply or don't bother learn at all\n\nTo be honest, don't bother learning anything unless you're going to learn it\nwell enough. And why? because you will be deluded into thinking you know\neverything, or you will become too lazy to go back and learn more. Many\nprogrammers with years of experience opt for half-baked and expensive\nsolutions, such as purchasing a new NoSQL database, when thorough indexing,\ndata modelling, and database optimization will provide twice the performance.\n\nA 45-minute YouTube video isn't enough to make you expect anything, so don't\nbe duped. It's simpler to learn deeply at first than to patch half-baked\nknowledge, and believe me, I still struggle with Git today because I never\nlearned it well, but I'm confident in my SQL and data modelling skills because\nI did put enough energy into learning it well. So, do yourself a courtesy and\nset aside time to understand thoroughly the fundamental requirements of\nsoftware development, such as your preferred programming language, SQL and\nNoSQL data models, and others. It's not about learning it all, but for the\nmost important stuff, learning it well enough.\n\n###\n\n4\\. Know the rule to break it.\n\nSoftware development is fundamentally about tradeoffs, and a guideline you\nlearned as the \"best\" way may not always be the most efficient way to address\nyour specific problem. It is important to learn the rules first so that you\nunderstand why and when you may break them later.\n\nIn the field of databases, there are usually golden rules, such as\nnormalization in relational databases (like Postgres). However, in certain\ninstances, denormalization may improve performance. What about the trade-off?\nYou might lose some data consistency. This is only one example. In many cases,\nthe \"best practice\" isn't the greatest or easiest solution. The idea is to\nfirst grasp the rules so you can make informed decisions about when to bend\nthem. Remember that each piece of advise has its limitations. Bending the\nrules may sometimes be necessary for the best outcome, but do it with caution\nand only after learning the rules!\n\n###\n\n5\\. Take on hard projects, even if you don't finish them.\n\nWhile gathering knowledge is crucial, pushing yourself with challenging\nprojects can be an amazing growth accelerator.\n\nAfter learning Go and making small toy web apps, I attempted to build a video-\nsharing website. I didn't know any better, or I wouldn't have attempted, but I\nlearned a lot from my mistakes. Taking on difficult projects allows you to\nidentify your weaknesses very early on.\n\nOne of my weaknesses back then was how disorganized the codebase was;\neverything was a jumbled mess, and I couldn't get anything done. So I did the\nbest thing I could: I paused the project and proceeded to learn everything I\ncould about codebase structure and organization. I read The Gang of Four,\nClean Architecture, Domain-Driven Design, and everything on Hexagonal\narchitecture, and videos on the subject. Though I don't follow everything in\nthose books verbatim (no one should), I believe that understanding how to\ndesign manageable and refactorable codebases was one of the most significant\nthings I learnt.\n\n###\n\n6\\. Gain experience to value the right things.\n\nWhile I have emphasized the importance of gaining as much knowledge as\npossible, most knowledge is not truly valuable unless you experience firsthand\nwhy you need it. There are a lot of things in software development that you\nwill take lightly, regardless of how much you read about their importance.\nlike reading how to drive does not make you a driver, so is a software\ndeveloper with knowledge without experience.\n\nYou might not value testing until you find it difficult to pin errors or\nrefactor codes, and you won't value logging or tracing until you experience\nthe situation where logs will serve you. So try to get as much experience as\npossible, whether by taking on personal or open source projects or working on\na production system. It helps you to value the right things.\n\n###\n\n7\\. Sometimes, the best solutions come unexpectedly.\n\nSometimes the best solutions arrive unexpectedly. Problem-solving isn't always\nabout brute force or endless research. Stepping away from the problem can be\njust as valuable. So, take a break, go for a walk, or do anything else that\nwill clear your mind; this is all you need to gain a new perspective on things\nthat have eluded you.\n\n###\n\n8\\. You are not always wrong; others are as well.\n\nAs a new developer, you are typically the one making mistakes and misusing a\npackage; nevertheless, every now and then, the problem isn't you but the\npackage itself, and you have just encountered your first bug.\n\nI once lost time thinking I was doing something wrong. It turned out that the\nbug had already been reported on Github. Software do get buggy, and even smart\nengineers make unusual design decisions that are just odd and\ncounterintuitive. So, ask questions, look at Github issues, and check in the\ncommunity, and you'll see that others are also prone to errors.\n\n###\n\n9\\. Be careful of blind ideologies\n\nLast but not least, avoid blind ideologies or one size fits all. What do I\nmean by ideology? Any recommended solution that is not supported by a thorough\nunderstanding of the tradeoffs and specific use cases is an ill-informed\nideology especially if shun other solutions.\n\nSometimes, even seasoned developers might recommend complex architectures like\nserverless, microservices, or Kubernetes when a simpler approach like a\nmodular monolith would be more efficient. These technologies are powerful\ntools, but they're not the answer for every situation.\n\nEvery developer has their own ideology; I prefer and will always choose\nPostgres over MySQL, even though MySQL performs better in many instances. And\nI can't picture writing thousands of lines in Ruby or another dynamic\nlanguage, despite the fact that successful organizations like Shopify and\nGitHub use it on a daily basis. So do better than me, and base every decision\nnot only on personal preferences, but also on the best available option.\n\n####\n\nWorth mentioning\n\n1\\. Watch language/tool conferences: this helps to stay updated and build a\nstrong developer mindset.\n\n2\\. Join online communities and follow subject experts: I check the rust\ncommunity on Reddit once a week for new articles, crates, and other useful\ninformation.\n\n3\\. Think critically: Consider edge cases, potential problems, and how to\noptimize your code.\n\nThanks for reading QED! Subscribe for free to receive new posts and support my\nwork.\n\nShare this post\n\n#### Lessons to a junior software developer\n\nqedpost.substack.com\n\nShare\n\nComments\n\nNo posts\n\nReady for more?\n\n\u00a9 2024 QED\n\nPrivacy \u2219 Terms \u2219 Collection notice\n\nStart WritingGet the app\n\nSubstack is the home for great culture\n\nShare\n\n## Create your profile\n\n## Only paid subscribers can comment on this post\n\nAlready a paid subscriber? Sign in\n\n#### Check your email\n\nFor your security, we need to re-authenticate you.\n\nClick the link we sent to , or click here to sign in.\n\n", "frontpage": false}
