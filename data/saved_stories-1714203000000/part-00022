{"aid": "40174312", "title": "Porting the EndBASIC Console to an LCD", "url": "https://blogsystem5.substack.com/p/porting-the-endbasic-console-to-an", "domain": "blogsystem5.substack.com", "votes": 2, "user": "eatonphil", "posted_at": "2024-04-26 21:08:40", "comments": 0, "source_title": "Porting the EndBASIC console to an LCD", "source_text": "Porting the EndBASIC console to an LCD - by Julio Merino\n\n# Blog System/5\n\nShare this post\n\n#### Porting the EndBASIC console to an LCD\n\nblogsystem5.substack.com\n\n#### Discover more from Blog System/5\n\nA newsletter on operating systems, build systems, programming languages,\nsoftware engineering, and my own software projects. Specifics include FreeBSD,\nLinux, Rust, Bazel and EndBASIC.\n\nContinue reading\n\nSign in\n\n# Porting the EndBASIC console to an LCD\n\n### My exciting quest to leverage a teeny-tiny display to play retro-style\ngames\n\nJulio Merino\n\nApr 26, 2024\n\nShare this post\n\n#### Porting the EndBASIC console to an LCD\n\nblogsystem5.substack.com\n\nShare\n\nHello again Blog System/5 and sorry for the radio silence for the last couple\nof months. I had been writing too much in here and neglecting my side projects\nso I needed to get back to them. And now that I\u2019ve made significant progress\non cool new features for EndBASIC, it\u2019s time to write about them a little!\n\nOne of the defining characteristics of EndBASIC is its hybrid console: what\nlooks like a simple text terminal at first glance can actually render\noverlapping graphics and text at the same time. This is a feature that I\nbelieve is critical to simplify learning and it first appeared with the 0.8\nrelease back in 2021.\n\nEndBASIC's hybrid console running in the web browser, rendering text and\noverlapping graphics at once, all controlled from the built-in command prompt.\n\nA few months before that, I had added support for simple GPIO manipulation in\nthe 0.6 release and, around that same time, I impulse-bought a tiny LCD for\nthe Raspberry Pi with the hope of making the console work on it. But life\nhappened and I lost momentum on the project... until recently.\n\nIn this post, I\u2019ll guide you through the process of porting the EndBASIC\nhybrid console to the ST7735s 1.44\" LCD shown below, which sports a resolution\nof 128x128 pixels, a D-pad, and 3 other buttons. I will cover the prerequisite\nwork to make the port possible, dig into the GPIO and SPI interface of an LCD,\noutline the design for a fast rendering engine, and conclude with pointers for\nyou to build your own \u201cdeveloper kit\u201d. Let\u2019s go!\n\nThe ST7735s 1.44\" LCD. Photo from back when I first unboxed this little\ndevice... on February 7th, 2021.\n\n#\n\nPrevious implementation\n\nEven though I had plans to support graphics in the EndBASIC console from the\nvery beginning, the first versions of the product did not support graphics.\nThat fact didn\u2019t prevent me from defining a Console abstraction anyway because\nI needed to support various operating systems and, more importantly, write\nunit tests for the console. Such abstraction was a straightforward trait\nrepresenting text-only operations, like this:\n\n    \n    \n    trait Console { fn clear(&mut self, how: ClearType) -> io::Result<()>; fn color(&self) -> (Option<u8>, Option<u8>); fn print(&mut self, text: &str) -> io::Result<()>; // ... and more text operations ... }\n\nLater on, when the time came to add graphics support, I extended the Console\ntrait with additional rendering primitives, like this:\n\n    \n    \n    trait Console { // ... same as previous ... fn draw_circle(&mut self, _center: PixelsXY, _radius: u16) -> io::Result<()> { Err(io::Error::new(io::ErrorKind::Other, \"No graphics support\")) } fn draw_pixel(&mut self, _xy: PixelsXY) -> io::Result<()> { Err(io::Error::new(io::ErrorKind::Other, \"No graphics support\")) } // ... and more graphics operations ... }\n\nWhat constitutes a primitive or not depends on the graphics device. In the\nsnippet above, it\u2019s fairly easy to understand why draw_pixel exists. But why\nis draw_circle there? SDL2, for example, does not provide a circle drawing\nprimitive and forces you to implement your own algorithm on top of individual\npixel plotting. However, the HTML canvas element does provide such a primitive\nand thus it is important to expose access to it for performance reasons.\n\nA reasonable design, right?\n\nSubscribe to Blog System/5 to support my writing and my work in projects like\nEndBASIC. It\u2019s free but donations are appreciated!\n\nNot quite. The problem is that mixing the textual and graphical operations\nunder just one abstraction bundles two concepts together. Take, for example,\nthe innocent-looking print function: writing text to the console requires\nknowing the current cursor position, writing text at that location, wrapping\nlong lines, and then updating the cursor position and moving its glyph. This\nsequence of operations is given to us \u201cfor free\u201d when the Console is backed by\na terminal\u2014the kernel or terminal emulator handle all details\u2014but none of this\nexists when you stare at a blank graphical canvas.\n\nAs a result, the SDL2 and the HTML canvas console implementations had to\nsupply their own code to represent a textual console on top of their backing\ngraphical canvases. But due to tight timelines\u2014I wanted to release graphics\nsupport in time for a conference\u2014I ended up with a lot of copy/pasted code\nbetween the two. Unfortunately, it wasn\u2019t just copy/pasted code. Oh no. It was\ncopy/pasted code with minor variations throughout. For example: SDL2\ncoordinates are i32 whereas HTML canvas coordinates are floats.\n\nThis duplication with minor differences required unification before attempting\nto write a console driver for the LCD because I could not afford to introduce\nyet another duplicate of the same code.\n\n#\n\nPast NetBSD experience to the rescue\n\nThe first step to resolving this conundrum was to unify the implementation of\nthe two graphical consoles as much as possible. Having worked on NetBSD\u2019s\nwscons console framework eons ago, I knew how this had to be done.\n\nThe idea was to separate the text console manipulation from the underlying\ngraphics primitives. As you can imagine, the way to do this was via a new\nabstraction, RasterOps, providing direct access to the \u201craster operations\u201d of\nthe graphics device. Take a look:\n\n    \n    \n    trait RasterOps { fn draw_circle(&mut self, center: PixelsXY, radius: u16) -> io::Result<()>; fn draw_pixel(&mut self, xy: PixelsXY) -> io::Result<()>; fn move_pixels(&mut self, x1y1: PixelsXY, x2y2: PixelsXY, size: SizeInPixels) -> io::Result<()>; fn write_text(&mut self, xy: PixelsXY, text: &str) -> io::Result<()>; // ... and more operations ... }\n\nAs you can see in this snippet, the earlier operations draw_circle and\ndraw_pixel exist as raster operations because some devices may provide them as\nprimitives. But we now see other functions like move_pixels and write_text\n(which differs from print because it writes text at a specific pixel location,\nnot at the \u201ccurrent cursor position\u201d) and these are meant to expose other\nprimitives of the device.\n\nHaving done this, I added a new GraphicsConsole type that encapsulates the\nlogic to implement a terminal backed by an arbitrary graphical display, and\nthen relies on a specific implementation of the RasterOps trait to do the\nscreen manipulation:\n\n    \n    \n    impl<RO> Console for GraphicsConsole<RO> where RO: RasterOps, { // ... implement Console in terms of RasterOps ... }\n\nMost details of this refactor are uninteresting at this point, except for the\nfact that it eliminated all of the tricky duplicate code between the SDL2 and\nHTML canvas variants. A side-effect was that these changes increased my\nconfidence in the HTML canvas variant because most code was now unit-tested\nindirectly via the SDL2 implementation. Here is how the simplification looked\nlike:\n\n    \n    \n    $ wc -l {before,after}/sdl/src/host.rs {before,after}/web/src/canvas.rs 1245 before/sdl/src/host.rs 887 after/sdl/src/host.rs # 358 fewer lines 760 before/web/src/canvas.rs 444 after/web/src/canvas.rs # 320 fewer lines\n\nI was now ready to reuse the GraphicsConsole to quickly provide a new backend\non top of the LCD.\n\n#\n\nPlaying with the C interface\n\nWith the foundational abstractions in place, it was time to prove that my idea\nof rendering the EndBASIC console on the tiny LCD was feasible cool enough to\npursue. But I knew absolutely nothing about the LCD so, before diving right\ninto the \u201ccorrect\u201d implementation, I had to create a prototype to get used to\nits API.\n\nFortunately, I found an \u201cSDK\u201d\u2014and I put it in quotes because SDK is quite an\noverstatement\u2014for the LCD somewhere online. The SDK consists of a pair of C\nand Python libraries that provide basic graphics drawing primitives, text\nrendering, and access to the D-pad and the buttons. This was a \u201cperfect\u201d\nfinding because the code was simple enough to understand, functional enough to\nbuild a prototype, and allowed me to skip reading through the data sheet.\n\nSo I chose to do the easiest thing: I folded the C library into EndBASIC using\nRust\u2019s C FFI and quickly implemented a RasterOps on it. With that, I could\ninstantiate a GraphicsConsole backed by the LCD and demonstrate, in just a\ncouple of hours before the crack of dawn, that the idea was feasible. And it\nwas more than feasible: it was super-exciting! Here, witness the very first\nresults:\n\n(Caption: First prototype of the EndBASIC console on the ST7735s LCD display,\nreusing the vendor-provided C library from Rust with lots of hacks.)\n\nBut performance was also awful. Using the C library was enough to show that\nthis idea was cool and worth pursuing, but it was not the best path forward.\nOn the one hand, the code in the C library was rather crappy and fragile to\nintegrate into Rust via build.rs; and, on the other hand, I needed precise\ncontrol of the hardware primitives to achieve good rendering performance\nlevels.\n\n#\n\nThe LCD hardware interface\n\nBefore diving into the solution, let\u2019s take a quick peek at the hardware\ninterface of the LCD. Note that this is just a very simplified picture of what\nthe LCD offers and is derived from my reverse-engineering of the code in the\nSDK. I\u2019m sure there is more to it, but I do not have the drive to go through\nthe aforementioned data sheet.\n\nThe LCD is a matrix of pixels where each position contains an integer\nrepresenting the color of the pixel. The representation of each color value\ndepends on the selected pixel format, but what the SDK uses by default is\nRGB565: a 16-bit value decomposed into two 5-bit quantities for red and blue\nand one 6-bit quantity for green.\n\nThis is pretty standard stuff for a framebuffer-style device but the mechanism\nto write to the LCD is different. Unlike most framebuffer devices backed by\nvideo cards, the LCD matrix is not memory-mapped: we have to issue specific\nreads and writes via the GPIO and SPI busses. The GPIO bus is used to control\nhardware registers and the SPI bus is used to transfer large data sequences.\n\nSimplifying, the LCD offers just two primitives. The first is a \u201cset window\u201d\noperation to define the window for rendering. This tells the LCD what\nrectangular region to update with new pixel values on the subsequent \u201cset\ndata\u201d operation. Executing this operation requires a GPIO write to select the\noperation followed by an SPI write to set the window position and dimensions.\n\nRepresentation of an LCD's \"set window\" operation.\n\nThe second is a \u201cset data\u201d primitive to set the contents of the previously-\ndefined window. This primitive just sends a stream of pixel color values that\nwill be written on the window, top-left to bottom-right. Executing this\noperation requires a GPIO write to select the operation followed by a \u201cvery\nlarge\u201d SPI write to write the pixel data.\n\nRepresentation of an LCD's \"set data\" operation.\n\nBy default, SPI writes on Linux are limited to 4KB in size and the full LCD\ncontent is 128x128 pixels * 2 bytes per pixel = 32KB, which means drawing the\nwhole LCD requires 8 separate SPI writes. (It is possible to raise the default\nvia a kernel setting, which I did too, but let\u2019s ignore that for now.)\n\nUnderstanding that the LCD hardware interface is as simple and constrained as\nthis is super-important to devise an efficient higher-level API, which is what\nwe are going to do next.\n\n#\n\nDouble-buffering\n\nHaving figured out the native interface, I faced two problems.\n\nThe first one was performance. Issuing individual \u201cset window\u201d and \u201cset data\u201d\ncommands works great to draw on large portions of the LCD, but sending these\ncommands on a pixel basis as would be necessary to render letters or shapes\nlike circles would be prohibitively slow.\n\n(Caption: An EndBASIC demo program bouncing a bunch of rectangles on the\nscreen running with the prototype console driver that relied on the C library\nwithout double-buffering or damage tracking.)\n\nThe second one was the inability to read the contents of the LCD. Certain\noperations of the console, like moving the cursor or entering/exiting the\nbuiltin editor, require saving portions of the screen aside for later\nrestoration. The LCD does not offer an interface to read what it currently\ndisplays. (Actually I don\u2019t know because I did not read the data sheet... but\neven if it does, the reads would involve slow SPI bus traffic which we should\navoid.)\n\nTo address these two problems, I decided to implement double-buffering for the\nLCD: the console driver reserves a portion of main memory to track the content\nof the LCD and all operations that update the LCD first write to this buffer.\nThis allows the code to decide when to send the buffer to the LCD, allowing it\nto compose complex patterns in memory\u2014e.g. plotting letters pixel by\npixel\u2014before ever touching the GPIO and SPI busses. And this also allows\ntrivially reading portions of the LCD.\n\nRepresentation of the double-buffering and damage tracking techniques.\n\nWhich brings me to the next point. Part of this solution required adding\ndamage tracking as well. Flushing the full in-memory buffer to the LCD is\nexpensive\u2014remember, with the default SPI configuration, we need to issue 8\nseparate writes to flush 32KB of data\u2014and many times, like when moving the\ncursor around in the editor, this is not necessary. Therefore, it is important\nto keep track of the portion of the display that has been \u201cdamaged\u201d by drawing\noperations and then only flush that portion of the buffer to the LCD. This\nmaps perfectly well to the hardware primitives offered by the LCD.\n\nWith that in mind, and after a bit of iteration, I ended up splitting the\nimplementation of the LCD RasterOps into two pieces. One is the Lcd trait,\nwhich exposes the basic \u201cset window\u201d and \u201cset data\u201d primitives of an LCD as a\nsingle set_data operation:\n\n    \n    \n    trait Lcd { fn set_data(&mut self, x1y1: LcdXY, x2y2: LcdXY, data: &[u8]) -> io::Result<()>; // ... some more stuff ... }\n\nThe other is the BufferedLcd type, which implements the general idea of\nbuffering and damage tracking on top of a generic Lcd:\n\n    \n    \n    impl<L> RasterOps for BufferedLcd<L> where L: Lcd, { // ... implementation of RasterOps in terms of an Lcd ... }\n\nThis design keeps all of the complex logic in one place and, as was the case\nwith the Console abstraction, allowed me to unit-test the tricky corner cases\nof the double-buffering and damage tracking by supplying a test-only Lcd\nimplementation. This was critical during development because I wrote most of\nthis code while I was on a trip without access to the device, and when I came\nback home, the \u201creal thing\u201d worked on the first try.\n\n(Caption: Same EndBASIC demo program as before but running with the improved\nconsole that implements double-buffering and damage tracking. No more\nflickering.)\n\nInvest in Rust and exhaustive unit testing! They really are worth it to\ndeliver working software quickly. But I digress...\n\n#\n\nFont rendering\n\nThe last interesting part of the puzzle was rendering text. You see: for the\nprevious graphical consoles I wrote based on SDL2 and the HTML canvas element,\nI was able to use a nice TTF font. But with the LCD... well, the LCD has no\nbuiltin mechanism to render text and the very restrictive 128x128 resolution\nmeans that most fonts would render poorly at small sizes anyway.\n\nTo solve this problem, I had to implement my own text rendering code, which\nsounds scary at first but isn\u2019t as hard as it sounds. One issue was coming up\nwith the font data, but the SDK for the LCD came with a free reusable 5x8 font\nthat I took over. Another issue was coming up with a mechanism to efficiently\nrender the letters because plotting them pixel by pixel on the LCD would be\nunfeasible, but this was solved by the previous buffering and damage tracking\ntechniques.\n\nHaving my own font rendering code is interesting. If you used a BASIC machine\nback in the 1980s, the computer-supplied manual would show you the glyphs used\nby the machine like this page demonstrates:\n\nPage 9 of Chapter 7 of the Amstrad CPC 6128 user manual showing the glyphs\ncorresponding to characters 32\u201348.\n\nIn some machines like the Amstrad CPC 6128, you could use the SYMBOL command\nto define your own glyphs. And in some others, you could POKE the memory\nlocations where the glyphs were stored to (re)define them. So I\u2019m thinking\nthat... maybe I should forget about the TTF font and instead expose a custom\nbitmap font in all EndBASIC consoles to allow for these neat tricks.\n\n#\n\nPutting it all together\n\nAnd that\u2019s all folks! Having gone through all the pieces involved in providing\nsupport for the LCD, we can now connect them all. Here is how the code on the\nmain branch looks like with additional inline commentary:\n\n    \n    \n    // Instantiate access to the GPIO bus, required to control the LCD and // to read the status of the D-pad and buttons. let mut gpio = Gpio::new().map_err(gpio_error_to_io_error)?; // Build the struct used to interface with the LCD. let lcd = ST7735SLcd::new(&mut gpio)?; // Wrap the low-level LCD with the double-buffering and damage tracking // features for high speed. let lcd = BufferedLcd::new(lcd); // Instantiate the input controller. I haven't covered this in the post // because it's uninteresting. let input = ST7735SInput::new(&mut gpio, signals_tx)?; // Wrap the display and the buttons with the generic graphical console // logic -- the same one used by the SDL2 and HTML canvas variants. let inner = GraphicsConsole::new(input, lcd)?;\n\nEven though this looks complex, this composition of three different types\nkeeps the responsibilities of each layer separate. The layers help make the\nlogic simpler to understand, allow the possibility of supporting more LCDs\nwith ease, and make unit-testing a reality. And thanks to Rust\u2019s static\ndispatch, the overhead of the separate types is minimal.\n\nWitness the finished result:\n\n(Caption: EndBASIC running the snake game on the Raspberry Pi with the ST7735s\nconsole, showing the final graphics support as well as interaction with the\nphysical buttons.)\n\n#\n\nBuild your own Developer Kit\n\nDoes the above sound cool? Do you want to play with it? Here are the parts\nyou\u2019ll need to build you own:\n\n  * Raspberry Pi 3 B+: I suppose a newer model will work but I don\u2019t have one to try it out; let me know if it does! I also have my eyes on the Libre Computer Board - Le Potato, but if you go this route, know that it will definitely require extra work in EndBASIC to be functional. Hardware donations welcome if you want me to give it a try \ud83d\ude09.\n\n  * CanaKit 5V 2.5A Power Supply: Yes, the Raspberry Pi is USB-powered but you need a lot of power for it to run properly\u2014particularly if you are going to attach any USB devices like hard disks. Don\u2019t skimp on the power supply. This is the one I have and works well.\n\n  * PNY 32GB microSD card: Buy any microSD card you like. The SD bay is incredibly slow no matter what and 32GB should be plenty for experimentation.\n\n  * waveshare 1.44inch LCD Display HAT 128x128: The star product of this whole article! You may find other LCD hats and I\u2019m sure they can be made to work, but they\u2019ll require code changes. Hopefully the abstractions I implemented make it easy to support other hats, but I can\u2019t tell yet. Again, hardware donations welcome if you want to keep me busy \ud83d\ude09.\n\nOnce you have those pieces, get either Raspbian or Ubuntu, flash the image to\nthe microSD, and boot the machine. After that, you have to build and run\nEndBASIC from unreleased sources until I release 0.11:\n\n    \n    \n    $ cargo install --git=https://github.com/endbasic/endbasic.git --features=rpi $ ~/.cargo/bin/endbasic --console=st7735s\n\nI know, I know, this is all quite convoluted. You have to manually go through\nthe process of setting up Linux, then installing Rust, and then building\nEndBASIC from source. All of this is super-slow too.\n\nWhich means... what I want to do next is to build a complete \u201cDeveloper Kit\u201d,\nincluding a lightweight prebuilt SD image that gives you access to EndBASIC\nout of the box in just a few seconds. Right now I\u2019m playing with downsizing a\nNetBSD/evbarm build so that the machine can boot quickly and, once I have that\nready, I\u2019ll have to port EndBASIC\u2019s hardware-specific features to work on it.\nI don\u2019t think I\u2019ll postpone 0.11 until this is done, but we\u2019ll see.\n\nInterested in any of this? Please leave a note! And if you have tried the\nabove at all with your own hardware, post your story too!\n\nThanks for reading and please take a little moment to subscribe to Blog\nSystem/5.\n\n1 Like\n\nShare this post\n\n#### Porting the EndBASIC console to an LCD\n\nblogsystem5.substack.com\n\nShare\n\nComments\n\nThe IDEs we had 30 years ago... and we lost\n\nA deep dive into the text mode editors we had and how they compare to today's\n\nDec 25, 2023 \u2022\n\nJulio Merino\n\n44\n\nShare this post\n\n#### The IDEs we had 30 years ago... and we lost\n\nblogsystem5.substack.com\n\n63\n\nFrom 0 to 1 MB in DOS\n\nA tour on how DOS was able to use most of the 1 MB address space of the 8086\n\nJan 17 \u2022\n\nJulio Merino\n\n15\n\nShare this post\n\n#### From 0 to 1 MB in DOS\n\nblogsystem5.substack.com\n\n18\n\nHard disk LEDs and noisy machines\n\nThe little annoyances that alerted us developers of performance problems\n\nDec 15, 2023 \u2022\n\nJulio Merino\n\n8\n\nShare this post\n\n#### Hard disk LEDs and noisy machines\n\nblogsystem5.substack.com\n\n3\n\nReady for more?\n\n\u00a9 2024 Julio Merino\n\nPrivacy \u2219 Terms \u2219 Collection notice\n\nStart WritingGet the app\n\nSubstack is the home for great culture\n\nShare\n\n## Create your profile\n\n## Only paid subscribers can comment on this post\n\nAlready a paid subscriber? Sign in\n\n#### Check your email\n\nFor your security, we need to re-authenticate you.\n\nClick the link we sent to , or click here to sign in.\n\n", "frontpage": false}
