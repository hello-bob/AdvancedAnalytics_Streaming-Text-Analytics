{"aid": "40093604", "title": "WebAssembly Spin 2.4: Internal Service Chaining / OpenTelemetry / MQTT", "url": "https://www.fermyon.com/blog/spin-v24", "domain": "fermyon.com", "votes": 1, "user": "tony-allan", "posted_at": "2024-04-20 01:01:49", "comments": 0, "source_title": "Announcing Spin 2.4", "source_text": "Announcing Spin 2.4\n\nIntroducing SpinKube and Fermyon Platform for Kubernetes - making Wasm a\nfirst-class workload in K8s\n\nNEW: Making Wasm a first-class workload in Kubernetes\n\nProjects\n\nDevelopment Spin Open Source The developer tool for composing serverless Wasm\napps. SpinKube Open Source Run WebAssembly workloads on Kubernetes. A CNCF\nsandbox project.Infrastructure Cloud Fermyon\u2019s hosted cloud makes it quick and\neasy to run and manage serverless apps. Platform for Kubernetes Enterprise\nsolution to deliver denser, faster serverless apps in your Kubernetes stack.\n\nView all projects\n\nDeveloper\n\nDocumentation Example Apps GitHub\n\nChangelog\n\nBlog\n\nContact Sales Cloud LoginSign Up Free\n\nBlog\n\nApril 04, 2024\n\n# Announcing Spin 2.4\n\nKate Goldenring\n\nspin webassembly wasi component model release wasmtime\n\nToday we\u2019re happy to announce the release of Spin 2.4, which includes several\nenhancements to Spin:\n\n  * Spin now supports application-internal service chaining, removing the overhead of network requests when making requests to other components of the same application\n  * Apps can emit traces with experimental support for OpenTelemetry (OTEL) observability\n  * The Spin Redis trigger can listen to events from multiple Redis servers\n  * Spin now supports an experimental MQTT interface, which allows you to publish messages from your Spin application using MQTT protocol\n\nLet\u2019s dive into a couple of these new features.\n\n## Installing Spin\n\nIf you haven\u2019t already, please go ahead and install Spin.\n\n> Upgrading Spin: If you already have Spin installed, please see the Spin\n> upgrade page in the developer documentation.\n\n## First-Class Support for Application-Internal Service Chaining\n\nSpin applications have always been able to make requests to other components\nin the same application (\u201cself-requests\u201d). This effectively makes Spin\napplications a set of connected microservices. In Spin 2.2, we streamlined\nthis by adding support for sending self-requests by route, avoiding the need\nto specify a hostname, port, or protocol. With Spin 2.4, we\u2019re introducing\nsupport for application-internal service chaining. Now, if you opt-in,\napplications will enforce that requests between components within the\napplication are handled in the same process. This removes some key sources of\ncomplexity for distributed applications, namely infrastructure-induced partial\nfailures and unpredictable latency.\n\nWhat Spin 2.4 adds is the ability to ensure - at deploy time - that the\nruntime environment will handle these self-requests internally, turning it\ninto something that the developer can rely on as part of the application\u2019s\narchitecture. This means that developers can benefit from microservice\npatterns, language flexibility, and smaller components without accidentally\nbuilding a distributed application and all of the complexity that comes with\nit.\n\nApplication-internal service chaining is guaranteed for requests that make use\nof the special <component-id>.spin.internal hostname. For example, to ensure\nthat a request from component-a to component-b is handled internally, the\nrequest must use the hostname component-b.spin.internal. And to enable this\nrequest, as well as explicitly opt in to this behavior, component-a\u2019s\nallowed_outbound_hosts field must include that hostname.\n\nYou can learn more about the feature in the Spin HTTP requests documentation.\nTo dive into the implementation, see the Spin Improvement Proposal introducing\nit.\n\n## Experimental Support for OpenTelemetry Observability\n\nSpin now has experimental support for the OpenTelemetry (OTEL) observability\nstandard. When configured, Spin will now emit traces of your Spin App as an\nOTEL signal. Here is a teaser of how to configure it.\n\nFirst, run an OTEL compliant collector to collect the traces. Jaeger is an\nopen source distributed tracing platform that can act as an OTEL collector and\nenables viewing taces. You can run Jaeger using Docker:\n\n    \n    \n    docker run -d -p16686:16686 -p4317:4317 -p4318:4318 -e COLLECTOR_OTLP_ENABLED=true jaegertracing/all-in-one:latest\n\nNow, you can start your Spin app, setting the endpoint of the OTEL collector\nin the OTEL_EXPORTER_OTLP_ENDPOINT environment variable:\n\n    \n    \n    OTEL_EXPORTER_OTLP_ENDPOINT=http://localhost:4318 spin up\n\nAfter sending some requests to your Spin app, navigate to Jaeger\n(http://localhost:16686) to view the traces.\n\nSpin supports both inbound and outbound trace context propagation. This allows\nyou to include Spin in your distributed traces that span all your services.\n\nThis observability support in Spin is still experimental. Only the HTTP\ntrigger, the LLM host component, and outbound HTTP requests are instrumented\nat this time. Going forward we will be adding tracing to the remainder of Spin\ntriggers and host components. We also hope to add support for the OTEL metrics\nsignal in the future. Try it out, let us know what you think and help us\nimprove the observability experience in Spin!\n\n## Experimental Support for Outbound MQTT Messaging\n\nAs of v2.4.2, Spin supports an experimental interface for you to publish\nmessages using the MQTT protocol. This is a common protocol used for machine-\nto-machine communications, typically in resource-constrained devices. With\nthis experimental interface, you can use Spin applications to establish a\nconnection with an MQTT server and publish a payload for a specific topic.\nLet\u2019s take a look at what this might look like in practice.\n\nFirst grant your Spin application access to make network calls to the\nparticular host for your desired MQTT server by specifying the host and\nallowed port:\n\n    \n    \n    [component.uses-mqtt] allowed_outbound_hosts = [\"mqtt://messaging.example.com:1883\"]\n\nFrom within your application\u2019s source code, you can then establish a\nconnection:\n\n    \n    \n    let connection = spin_sdk::mqtt::Connection::open(&address, &username, &password, keep_alive_secs)?;\n\nAnd then implement your business logic to publish the appropriate payload to\nyour host as an outbound MQTT message:\n\n    \n    \n    let cat_picture: Vec<u8> = request.body().to_vec(); connection.publish(\"pets\", &cat_picture, spin_sdk::mqtt::Qos::AtLeastOnce)?;\n\nFor a more detailed review, please visit the Spin SDK reference documentation,\nor get started with this Rust code example on GitHub.\n\n## Thank You!\n\nWe would like to thank the over 75 contributors to the Spin project and\nespecially our new contributor @thesuhas. We hope to see you again in the\ncommit history soon! Thank you to everyone in our growing community. Every\ncomment, issue, and pull request helps us to make Spin better!\n\nA special mention goes out to the maintainers of the Bytecode Alliance\nprojects, particularly the Wasmtime project and the developers working on WASI\nand the WebAssembly component model. Their work is instrumental in supporting\nSpin.\n\n## Stay In Touch\n\nIf you are interested in Spin, Fermyon Cloud, or other Fermyon projects, join\nthe chat in the Fermyon Discord server and follow us on X (formerly Twitter)\n@fermyontech and @spinframework!\n\nIf you want to get involved in the Spin project, join us at our Spin Community\nDevelopers Meeting on the fourth Monday of every month at 11 a.m. Eastern US\nTime (5 p.m. Berlin Time). Our next one is on April 22. You can watch\nrecordings of the previous meetings on our YouTube Channel.\n\n## \ud83d\udd25 Recommended Posts\n\n# The Next Generation of Serverless is Happening\n\nThe term \u201cserverless\u201d is used ambiguously, so let\u2019s start off with a specific\ndefinition. Serverless apps are applications that are...\n\n# The Spin and Kubernetes Story\n\nServer-side WebAssembly (Wasm) applications built with Spin can run anywhere.\nThe ability to run Spin applications on any......\n\n# WebAssembly, WASI, and the Component Model\n\nWebAssembly has garnered enough attention that it now has its conferences,\nforums, and a dedicated community of developers ...\n\n#### Quickstart Your Serveless Apps with Spin\n\nGet Started\n\n### Projects\n\nSpin Fermyon Cloud Fermyon Platform\n\n### Resources\n\nWasm Language Guide Open Source Promise Guide to Serverless Apps\n\n### Company\n\nAbout Contact Press\n\n## Building faster, denser cloud compute - powered by WebAssembly.\n\nSubscribe to Updates\n\n## Connect with Fermyon\n\n### Chat on Discord\n\n### Schedule a Meeting\n\n### Become an Insider\n\nAlso, we're hiring!\n\nHi! Could we please enable some additional services for Analytics & Support?\nYou can always change or withdraw your consent later.\n\nLet me choose\n\n", "frontpage": false}
