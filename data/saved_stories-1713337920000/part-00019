{"aid": "40056256", "title": "Upgrading 3M Variables to Envelope Encryption", "url": "https://blog.railway.app/p/envelope-encryption", "domain": "railway.app", "votes": 7, "user": "05bmckay", "posted_at": "2024-04-16 19:38:25", "comments": 2, "source_title": "Upgrading 3 Million Variables to Envelope Encryption", "source_text": "Upgrading 3 Million Variables to Envelope Encryption\n\nGreg Schier\n\nApr 16, 2024\n\n# Upgrading 3 Million Variables to Envelope Encryption\n\nRailway is (temporarily, at least) hosted entirely on Google Cloud Platform\nwhile we begin transitioning our infrastructure to bare metal.\n\nIn the beginning, taking advantage of existing GCP-provided services to launch\na start-up made total sense. Building core services like container registry,\nblock storage, load balancers, or key management would\u2019ve only gotten in the\nway of building a product.\n\nMoving to bare metal gets us the margins required to build a profitable\nbusiness but, even disregarding cost, relying on a single infrastructure\nprovider is a huge technical risk. \u201cHow often does GCP fail though?\u201d You may\nask. Enough to warrant an entire blogpost on the subject!\n\nThe GCP service that continues to cause the most problems for us is Key\nManagement Service (KMS). And, while the dependency still technically exists,\nour usage of KMS has been greatly reduced, making migrating away almost\ntrivial.\n\nLet\u2019s dig into how we removed this KMS dependency while also improving\nperformance, all with no downtime.\n\nView of cryptographic requests to KMS before and after\n\n## The downsides of KMS\n\nRailway is all about making it easy for users to deploy code. These\ndeployments often require configuration values like API keys and database\ncredentials to be available. Railway solves this with Service Variables, which\nare automatically injected into deployments at runtime.\n\nSince these values often contain sensitive information, they get encrypted\nprior to storage in our Postgres database. Until now, these encryption\noperations have been done by calling KMS directly.\n\nThis works as expected when the number of variables per deployment is average\n(around 10), but some deployments have hundreds \ud83e\udee3.\n\nThis spiky KMS usage pattern leads to problems.\n\n  * KMS is an external service \u2192 Decrypting hundreds of variables for a deployment requires many network request (~20ms each) which slows down large batches, even if done concurrently\n  * KMS enforces a quota \u2192 Exceeding the quota will cause all operations to fail temporarily. Quotas can be raised by request but approval is not guaranteed, and GCP has lowered quotas without warning in the past\n  * KMS is not meant for unlimited keys \u2192 All variables are currently encrypted using the same KMS key, meaning a brute-force attack could compromise variables across all of Railway\n\nFortunately, there\u2019s a standard practice that solves all these problems at\nonce and is actually what KMS is designed for. (Yes, we were holding it\nwrong.)\n\n## Encrypting keys with keys\n\nEnvelope encryption is the practice of encrypting plaintext data \u2014 like\nvariables \u2014 with a data encryption key (DEK), then encrypting the DEK with a\nkey encryption key (KEK).\n\nThis reduces the surface area of an attack by allowing each user (or Railway\nproject) to use separate encryption keys. Using locally generated data keys\nalso means less reliance on an external key management service. Precisely what\nwe\u2019re after!\n\nGCP\u2019s explanation of KMS\n\nAs mentioned, KMS is designed for envelope encryption and is the reason for\nits maximum input size of 64KiB (enough to encrypt a large DEK). We knew this\nwhen implementing variable encryption, but since 99% of variables fit within\nthe maximum size (about the length of a 10,000 word blogpost), it made sense\nto use KMS directly to get feature out the door.\n\n## Implementing envelope encryption\n\nEnvelope encryption eliminates the need call KMS hundreds of times for large\nbatches of variables by requiring only one data encryption key (DEK) for the\nentire batch. We simply generate one DEK per Environment (an isolated instance\nof a project, like production or staging) and use it for all encryption\noperations.\n\nThe DEK is generated locally (256-bit AES using GCM), encrypted once using\nKMS, then stored on the Environment data model. We created a helper utility to\nhandle encryption, decryption, and key generation, and attached it to our\nrequest context, which has a lifetime of the current HTTP request or\nbackground job.\n\n    \n    \n    interface EnvelopeEncryptionManager { generateEncryptedDek(): Promise<string>; encrypt(plaintext: string, encryptedDek: string): Promise<string>; decrypt(encrypted: string): Promise<string>; }\n\nThis means that for each deployment (or other action), the encryption helper\ndecrypts the necessary DEK once and caches it in memory for further\noperations, reducing the 100+ trips to KMS to 1.\n\nThere\u2019s some other magic in here though. Did you notice that decrypt() doesn\u2019t\nrequire a DEK? How does that work?\n\n## Enabling key rotation\n\nOne of the requirements for envelope encryption was the ability to easily\nrotate keys. As we\u2019ve seen, the DEK is stored on the Environment model, but\nhow would we rotate it if needed? We\u2019d either have to store a list of old keys\nto try during the encryption process, or re-encrypt all variables and update\nthe database inside a potentially huge database transaction.\n\nNot great.\n\nLuckily there\u2019s also a best-practice for this, which is to store the\nencryption key next to the encrypted value (cipher text). For us, this meant\nserializing the encrypted DEK with the cipher text before storing the value in\nthe database as a JSON string:\n\n    \n    \n    variable.encryptedValue = `{\"encryptedDek\":\"...\",\"cipherText\":\"...\"}`\n\nVariable decryption with this setup can be done by decrypting the DEK using\nKMS (if not already cached in memory) and using it to decrypt the variable\nlocally (without KMS). It also makes passing around encrypted values easier\nbecause the associated Environment or DEK doesn\u2019t need to go along for the\nride.\n\nThe basic implementation of this strategy was only a few hundred lines of code\nbut we still had to convert over 3 million existing variables to the new\nsystem.\n\n## Migrating 3 million variables\n\nStoring the encrypted DEK next to the cipher text is also what made it\npossible to support both legacy and envelope encryption simultaneously,\nallowing us to progressively upgrade over 3 million variables.\n\nFor decryption fallback, if a DEK isn\u2019t found within the encrypted variable,\nKMS is called directly to decrypt just like before.\n\nSimilarly for encryption fallback, if no DEK exists yet on the Environment,\nKMS is called directly.\n\nThis makes it possible to generate a DEK for a single environment. Modified\nvariables within this environment will be upgraded to envelope encryption on\nwrite, reducing the migration effort to the following steps:\n\n  1. Deploy initial envelope encryption code (does nothing by itself)\n  2. Start generating DEKs for newly created environments\n  3. Run data migration to generate DEKs for all environments\n  4. Run data migration to re-encrypt all variables\n\n## Moving forward\n\nIt\u2019s been a few weeks since introducing envelope encryption and it\u2019s been a\nsuccess. Our KMS usage has dropped by 10x with no usage spikes, and we\u2019ve been\nable to realize the benefits mentioned earlier:\n\n  * Better performance \u2192 Decrypting DEKs with KMS once per batch reduced the slow-case for variable decryption from ~10s at the slowest to only a handful of milliseconds\n  * No service disruption \u2192 The more consistent usage pattern means we no longer have to worry about spiking above our KMS quota and causing downtime. We\u2019ve also been able to reduce our quota by several orders of magnitude\n  * Better security \u2192 Using a separate data key per environment means that a brute-force attack of one environment won\u2019t compromise data for any others\n  * More flexible encryption \u2192 While we don\u2019t necessarily need to surpass the 64KiB KMS limit, the use of symmetric AES encryption means we can now encrypt data of any length\n\nNot only do we get these direct benefits but we\u2019ve also already used this\nenvelope encryption system to persist credentials for our recently-released\nPrivate Registry Support.\n\nWe\u2019re one step closer to having no dependencies on GCP. Yes, we\u2019re still\ntechnically using KMS, but replacing it with something like Vault can now be\ndone incrementally by repeating the above migration steps to rotate the DEKs\nfor each environment.\n\nSo that\u2019s how we upgraded 3 million variables to envelope encryption.\nMigrating data is always a scary task. Migrating sensitive data is even worse!\nBut, as it goes, even the most daunting work can be broken down into\nmanageable chunks, which is how we lived to tell this tale.\n\nDid we do something wrong? Let us know on Twitter and stay tuned for more of\nthese stories as we get further and further along our path to bare metal.\n\n### Continue Reading...\n\nView All Engineering \u2192\n\nEngineering\n\nIncident Report: January 31st, 2024\n\nWe recently experienced an outage on our platform due to a DDoS attack that\npeaked at 12M requests per second. When production outages occur, it is\nRailway\u2019s policy to share the public details of what occurred.\n\nAngelo SaracenoJan 31, 2024\n\nEngineering\n\nSupport Engineering Is Engineering\n\nWhy Support Engineering is a critical systems design problem, and how we solve\nit.\n\nRay ChenJan 9, 2024\n\n### Your train has arrived!\n\nJoin thousands of developers deploying hundreds of thousands of applications\neffortlessly on Railway.\n\nStart a New Project\n\nCopyright \u00a9 2024 Railway Corp. All rights reserved.\n\nProduct\n\n  * Changelog\n  * Pricing\n  * Starters\n  * Feedback\n  * OSS Kickback\n\nCompany\n\n  * About\n  * Careers\n  * Blog\n  * Shop\n\nContact\n\n  * Discord\n  * Twitter\n  * GitHub\n  * Email\n\nLegal\n\n  * Fair Use\n  * Privacy Policy\n  * Terms of Service\n\n", "frontpage": true}
