{"aid": "40253056", "title": "Rendering on the Web (2019)", "url": "https://web.dev/articles/rendering-on-the-web", "domain": "web.dev", "votes": 1, "user": "aragonite", "posted_at": "2024-05-03 22:26:34", "comments": 0, "source_title": "Rendering on the Web | Articles | web.dev", "source_text": "Rendering on the Web | Articles | web.dev\n\nweb.dev uses cookies from Google to deliver and enhance the quality of its\nservices and to analyze traffic. Learn more.\n\n  * English\n  * Deutsch\n  * Espa\u00f1ol \u2013 Am\u00e9rica Latina\n  * Fran\u00e7ais\n  * Indonesia\n  * Italiano\n  * Polski\n  * Portugu\u00eas \u2013 Brasil\n  * Ti\u1ebfng Vi\u1ec7t\n  * T\u00fcrk\u00e7e\n  * \u0420\u0443\u0441\u0441\u043a\u0438\u0439\n  * \u05e2\u05d1\u05e8\u05d9\u05ea\n  * \u0627\u0644\u0639\u0631\u0628\u064a\u0651\u0629\n  * \u0641\u0627\u0631\u0633\u06cc\n  * \u0939\u093f\u0902\u0926\u0940\n  * \u09ac\u09be\u0982\u09b2\u09be\n  * \u0e20\u0e32\u0e29\u0e32\u0e44\u0e17\u0e22\n  * \u4e2d\u6587 \u2013 \u7b80\u4f53\n  * \u4e2d\u6587 \u2013 \u7e41\u9ad4\n  * \u65e5\u672c\u8a9e\n  * \ud55c\uad6d\uc5b4\n\nSign in\n\n  * On this page\n  * Terminology\n\n    * Rendering\n    * Performance\n  * Server-side rendering\n  * Static rendering\n  * Server-side rendering versus static rendering\n  * Client-side rendering\n  * Rehydration combines server-side and client-side rendering\n\n    * A rehydration problem: one app for the price of two\n  * Stream server-side rendering and rehydrate progressively\n\n    * Partial rehydration\n    * Trisomorphic rendering\n  * SEO considerations\n  * Conclusion\n  * Credits\n\n  * Home\n  * Articles\n\n# Rendering on the Web\n\nbookmark_borderbookmark Stay organized with collections Save and categorize\ncontent based on your preferences.\n\n  * On this page\n  * Terminology\n\n    * Rendering\n    * Performance\n  * Server-side rendering\n  * Static rendering\n  * Server-side rendering versus static rendering\n  * Client-side rendering\n  * Rehydration combines server-side and client-side rendering\n\n    * A rehydration problem: one app for the price of two\n  * Stream server-side rendering and rehydrate progressively\n\n    * Partial rehydration\n    * Trisomorphic rendering\n  * SEO considerations\n  * Conclusion\n  * Credits\n\nAddy Osmani\n\nJason Miller\n\nOne of the core decisions web developers must make is where to implement logic\nand rendering in their application. This can be difficult because there are so\nmaby ways to build a website.\n\nOur understanding of this space is informed by our work in Chrome talking to\nlarge sites over the past few years. Broadly speaking, we encourage developers\nto consider server-side rendering or static rendering over a full rehydration\napproach.\n\nTo better understand the architectures we're choosing from when we make this\ndecision, we need a solid understanding of each approach and consistent\nterminology to use when speaking about them. The differences between rendering\napproaches help illustrate the tradeoffs of rendering on the web from the\nperspective of page performance.\n\n## Terminology\n\n### Rendering\n\nServer-side rendering (SSR)\n\n    Rendering a client-side or universal app to HTML on the server.\nClient-side rendering (CSR)\n\n    Rendering an app in a browser, using JavaScript to modify the DOM.\nRehydration\n\n    \"Booting up\" JavaScript views on the client so they reuse the server-rendered HTML's DOM tree and data.\nPrerendering\n\n    Running a client-side application at build time to capture its initial state as static HTML.\n\n### Performance\n\nTime to First Byte (TTFB)\n\n    The time between clicking a link and the first byte of content loading on the new page.\nFirst Contentful Paint (FCP)\n\n    The time when requested content (article body, etc) becomes visible.\nInteraction to Next Paint (INP)\n\n    A representative metric that assesses whether a page consistently responds quickly to user inputs.\nTotal Blocking Time (TBT)\n\n    A proxy metric for INP that calculates how long the main thread was blocked during page load.\n\n## Server-side rendering\n\nServer-side rendering generates the full HTML for a page on the server in\nresponse to navigation. This avoids additional round trips for data fetching\nand templating on the client, because the renderer handles them before the\nbrowser gets a response.\n\nServer-side rendering generally produces a fast FCP. Running page logic and\nrendering on the server lets you avoid sending lots of JavaScript to the\nclient. This helps to reduce a page's TBT, which can also lead to a lower INP,\nbecause the main thread isn't blocked as often during page load. When the main\nthread is blocked less often, user interactions have more opportunities to run\nsooner. This makes sense, because with server-side rendering, you're really\njust sending text and links to the user's browser. This approach can work well\nfor a variety of device and network conditions, and opens up interesting\nbrowser optimizations like streaming document parsing.\n\nFCP and TTI with server-side rendering.\n\nWith server-side rendering, users are less likely to be left waiting for CPU-\nbound JavaScript to run before they can use your site. Even when you can't\navoid third-party JS, using server-side rendering to reduce your own first-\nparty JavaScript costs can give you more budget for the rest. However, there\nis one potential trade-off with this approach: generating pages on the server\ntakes time, which can increase your page's TTFB.\n\nWhether server-side rendering is enough for your application largely depends\non what type of experience you're building. There's a long-standing debate\nover the correct applications of server-side rendering versus client-side\nrendering, but you can always choose to use server-side rendering for some\npages and not others. Some sites have adopted hybrid rendering techniques with\nsuccess. For example, Netflix server-renders its relatively static landing\npages, while prefetching the JS for interaction-heavy pages, giving these\nheavier client-rendered pages a better chance of loading quickly.\n\nMany modern frameworks, libraries and architectures let you render the same\napplication on both the client and the server. You can use these techniques\nfor server-side rendering. However, architectures where rendering happens both\non the server and on the client are their own class of solution with very\ndifferent performance characteristics and tradeoffs. React users can use\nserver DOM APIs or solutions built on them like Next.js for server-side\nrendering. Vue users can use Vue's server-side rendering guide or Nuxt.\nAngular has Universal. Most popular solutions use some form of hydration,\nthough, so be aware of the approaches your tool uses.\n\n## Static rendering\n\nStatic rendering happens at build time. This approach offers a fast FCP, and\nalso a lower TBT and INP, as long as you limit the amount of client-side JS on\nyour pages. Unlike server-side rendering, it also achieves a consistently fast\nTTFB, because the HTML for a page doesn't have to be dynamically generated on\nthe server. Generally, static rendering means producing a separate HTML file\nfor each URL ahead of time. With HTML responses generated in advance, you can\ndeploy static renders to multiple CDNs to take advantage of edge caching.\n\nFCP and TTI with static rendering.\n\nSolutions for static rendering come in all shapes and sizes. Tools like Gatsby\nare designed to make developers feel like their application is being rendered\ndynamically, not generated as a build step. Static site generation tools such\nas 11ty, Jekyll, and Metalsmith embrace their static nature, providing a more\ntemplate-driven approach.\n\nNote: Abstractions of popular frameworks such as Next.js or Nuxt offer both\nstatic rendering and server-side rendering. This lets developers opt into\nstatic rendering for pages that qualify, or use server-side rendering for\npages that need to be dynamically generated in response to a request.\n\nOne of the downsides to static rendering is that it must generate individual\nHTML files for every possible URL. This can be challenging or even infeasible\nwhen you can't predict what those URLs will be ahead of time, or for sites\nwith a large number of unique pages.\n\nReact users might be familiar with Gatsby, Next.js static export, or Navi, all\nof which make it convenient to create pages from components. However, static\nrendering and prerendering behave differently: statically rendered pages are\ninteractive without needing to execute much client-side JavaScript, whereas\nprerendering improves the FCP of a Single Page Application that must be booted\non the client to make pages truly interactive.\n\nIf you're unsure whether a given solution is static rendering or prerendering,\ntry disabling JavaScript and load the page you want to test. For statically\nrendered pages, most interactive features still exist without JavaScript.\nPrerendered pages might still have some basic features like links with\nJavaScript disabled, but most of the page is inert.\n\nAnother useful test is to use network throttling in Chrome DevTools and see\nhow much JavaScript downloads before a page becomes interactive. Prerendering\ngenerally needs more JavaScript to become interactive, and that JavaScript\ntends to be more complex than the progressive enhancement approach used in\nstatic rendering.\n\n## Server-side rendering versus static rendering\n\nServer-side rendering isn't the best solution for everything, because its\ndynamic nature can have significant compute overhead costs. Many server-side\nrendering solutions don't flush early, delay TTFB, or double the data being\nsent (for example, inlined states used by JavaScript on the client). In React,\nrenderToString() can be slow because it's synchronous and single-threaded.\nNewer React server DOM APIs support streaming, which can get the initial part\nof an HTML response to the browser sooner while the rest of it is still being\ngenerated on the server.\n\nGetting server-side rendering \"right\" can involve finding or building a\nsolution for component caching, managing memory consumption, using memoization\ntechniques, and other concerns. You're often processing or rebuilding the same\napp twice, once on the client and once on the server. Server-side rendering\nshowing content sooner doesn't necessarily give you less work to do. If you\nhave a lot of work on the client after a server-generated HTML response\narrives on the client, this can still lead to higher TBT and INP for your\nwebsite.\n\nServer-side rendering produces HTML on demand for each URL, but it can be\nslower than just serving static rendered content. If you can put in the\nadditional legwork, server-side rendering plus HTML caching can significantly\nreduce server render time. The upside to server-side rendering is the ability\nto pull more \"live\" data and respond to a more complete set of requests than\nis possible with static rendering. Pages that need personalization are a\nconcrete example of the type of request that doesn't work well with static\nrendering.\n\nServer-side rendering can also present interesting decisions when building a\nPWA: is it better to use full-page service worker caching, or just server-\nrender individual pieces of content?\n\n## Client-side rendering\n\nClient-side rendering means rendering pages directly in the browser with\nJavaScript. All logic, data fetching, templating, and routing are handled on\nthe client instead of on the server. The effective outcome is that more data\nis passed to the user's device from the server, and that comes with its own\nset of tradeoffs.\n\nClient-side rendering can be difficult to make and keep fast for mobile\ndevices. With a little work to keep a tight JavaScript budget and deliver\nvalue in as few round-trips as possible, you can get client-side rendering to\nalmost replicate the performance of pure server-side rendering. You can get\nthe parser to work for you faster by delivering critical scripts and data\nusing <link rel=preload> We also recommend considering using patterns like\nPRPL to ensure that initial and subsequent navigations feel instant.\n\nFCP and TTI with client-side rendering.\n\nThe primary downside to client-side rendering is that the amount of JavaScript\nrequired tends to grow as an application grows, which can impact a page's INP.\nThis becomes especially difficult with the addition of new JavaScript\nlibraries, polyfills, and third-party code, which compete for processing power\nand must often be processed before a page's content can render.\n\nExperiences that use client-side rendering and rely on large JavaScript\nbundles should consider aggressive code-splitting to lower TBT and INP during\npage load, as well as lazy-loading JavaScript to serve only what the user\nneeds, when it's needed. For experiences with little or no interactivity,\nserver-side rendering can represent a more scalable solution to these issues.\n\nFor folks building single page applications, identifying core parts of the\nuser interface shared by most pages lets you apply the application shell\ncaching technique. Combined with service workers, this can dramatically\nimprove perceived performance on repeat visits, because the page can load its\napplication shell HTML and dependencies from CacheStorage very quickly.\n\n## Rehydration combines server-side and client-side rendering\n\nRehydration is an approach that tries to smooth over the tradeoffs between\nclient-side and server-side rendering by doing both. Navigation requests like\nfull page loads or reloads are handled by a server that renders the\napplication to HTML, then the JavaScript and data used for rendering is\nembedded into the resulting document. When done carefully, this achieves a\nfast FCP like server-side rendering, then \"picks up\" by rendering again on the\nclient. This is an effective solution, but it can have considerable\nperformance drawbacks.\n\nThe primary downside of server-side rendering with rehydration is that it can\nhave a significant negative impact on TBT and INP, even if it improves FCP.\nServer-side rendered pages can appear to be loaded and interactive, but can't\nactually respond to input until the client-side scripts for components are\nexecuted and event handlers have been attached. On mobile, this can take\nminutes, confusing and frustrating the user.\n\n### A rehydration problem: one app for the price of two\n\nFor the client-side JavaScript to accurately \"pick up\" where the server left\noff, without re-requesting all the data the server rendered its HTML with,\nmost server-side rendering solutions serialize the response from a UI's data\ndependencies as script tags in the document. Because this duplicates a lot of\nHTML, rehydration can cause more problems than just delayed interactivity.\n\nDuplicated code in the HTML document.\n\nThe server is returning a description of the application's UI in response to a\nnavigation request, but it's also returning the source data used to compose\nthat UI, and a complete copy of the UI's implementation which then boots up on\nthe client. The UI doesn't become interactive until after bundle.js has\nfinished loading and executing.\n\nPerformance metrics collected from real websites using server-side rendering\nand rehydration indicate that it's rarely the best option. The most important\nreason is its effect on the user experience, when a page looks ready but none\nof its interactive features work.\n\nThe effects of client-side rendering on TTI.\n\nThere's hope for server-side rendering with rehydration, though. In the short\nterm, only using server-side rendering for highly cacheable content can reduce\nTTFB, producing similar results to prerendering. Rehydrating incrementally,\nprogressively, or partially might be the key to making this technique more\nviable in the future.\n\n## Stream server-side rendering and rehydrate progressively\n\nServer-side rendering has had a number of developments over the last few\nyears.\n\nStreaming server-side rendering lets you send HTML in chunks that the browser\ncan progressively render as it's received. This can get markup to your users\nfaster, speeding up your FCP. In React, streams being asynchronous in\nrenderToPipeableStream(), compared to synchronous renderToString(), means\nbackpressure is handled well.\n\nProgressive rehydration is also worth considering, and React has implemented\nit. With this approach, individual pieces of a server-rendered application are\n\"booted up\" over time, instead of the current common approach of initializing\nthe entire application at once. This can help reduce the amount of JavaScript\nneeded to make pages interactive, because it lets you defer client-side\nupgrading of low-priority parts of the page to prevent it from blocking the\nmain thread, letting user interactions happen sooner after the user initiates\nthem.\n\nProgressive rehydration can also help you avoid one of the most common server-\nside rendering rehydration pitfalls: a server-rendered DOM tree gets destroyed\nand then immediately rebuilt, most often because the initial synchronous\nclient-side render required data that wasn't quite ready, often a Promise that\nhasn't resolved yet.\n\n### Partial rehydration\n\nPartial rehydration has proven difficult to implement. This approach is an\nextension of progressive rehydration that analyzes individual pieces of the\npage (components, views, or trees) and identifies the pieces with little\ninteractivity or no reactivity. For each of these mostly-static parts, the\ncorresponding JavaScript code is then transformed into inert references and\ndecorative features, reducing their client-side footprint to nearly zero.\n\nThe partial hydration approach comes with its own issues and compromises. It\nposes some interesting challenges for caching, and client-side navigation\nmeans we can't assume that server-rendered HTML for inert parts of the\napplication are available without a full page load.\n\n### Trisomorphic rendering\n\nIf service workers are an option for you, consider trisomorphic rendering.\nIt's a technique that lets you use streaming server-side rendering for initial\nor non-JS navigations, and then have your service worker take on rendering of\nHTML for navigations after it has been installed. This can keep cached\ncomponents and templates up to date and enable SPA-style navigations for\nrendering new views in the same session. This approach works best when you can\nshare the same templating and routing code between the server, client page,\nand service worker.\n\nA diagram of how trisomorphic rendering works.\n\n## SEO considerations\n\nWhen choosing a web rendering strategy, teams often consider the impact of\nSEO. Server-side rendering is a popular choice for delivering a \"complete\nlooking\" experience that crawlers can interpret. Crawlers can understand\nJavaScript, but there are often limitations to how they render. Client-side\nrendering can work, but often needs additional testing and overhead. More\nrecently, dynamic rendering has also become an option worth considering if\nyour architecture depends heavily on client-side JavaScript.\n\nWhen in doubt, the mobile friendly test tool is a great way to test that your\nchosen approach does what you're hoping for. It shows a visual preview of how\nany page appears to Google's crawler, the serialized HTML content it finds\nafter JavaScript is executed, and any errors encountered during rendering.\n\nThe Mobile-Friendly Test UI.\n\n## Conclusion\n\nWhen deciding on an approach to rendering, measure and understand what your\nbottlenecks are. Consider whether static rendering or server-side rendering\ncan get you most of the way there. It's fine to mostly ship HTML with minimal\nJavaScript to get an experience interactive. Here's a handy infographic\nshowing the server-client spectrum:\n\nRendering options and their tradeoffs.\n\n## Credits\n\nThanks to everyone for their reviews and inspiration:\n\nJeffrey Posnick, Houssein Djirdeh, Shubhie Panicker, Chris Harrelson, and\nSebastian Markb\u00e5ge\n\nExcept as otherwise noted, the content of this page is licensed under the\nCreative Commons Attribution 4.0 License, and code samples are licensed under\nthe Apache 2.0 License. For details, see the Google Developers Site Policies.\nJava is a registered trademark of Oracle and/or its affiliates.\n\nLast updated 2019-02-06 UTC.\n\n", "frontpage": false}
