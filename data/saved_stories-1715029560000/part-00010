{"aid": "40275200", "title": "The Death of Code as Craft", "url": "https://every.to/p/the-death-of-code-as-craft", "domain": "every.to/p", "votes": 1, "user": "yarapavan", "posted_at": "2024-05-06 14:36:51", "comments": 0, "source_title": "The Death of Code as Craft", "source_text": "The Death of Code as Craft\n\nSubscribe\n\n\u2261\n\n  * About\n  * Collections\n  * Contact Us\n  * Sponsor Us\n  * Login\n\n# The Death of Code as Craft\n\nWhat is the business value in keeping developers happy?\n\nby Jon Christensen\n\nMay 6, 2024\n\n12\n\nDALL-E/Every illustration.\n\nAre developers artists, or are they cogs? If they are artists, individual care\nand craft\u2014the hallmarks of great work\u2014are prized, and handcrafting code would\nbe highly profitable. If coding is just a cog in the industrial machine, then\nthe job of the software engineer is diminished. For many years, Jon\nChristensen\u2014a software engineer himself\u2014argued the former, but with the rise\nof AI, he worries that the latter is becoming true. It signals a profound\nshift in the economics of the tech industry and our relationship to the labor\nof technology company building. I found his perspective honest and refreshing.\n\u2014Evan Armstrong\n\nSubscribe\n\nI have a confession to make.\n\nFor the better part of two decades, I've been a card-carrying member of the\ncode-as-craft cult, which espouses the belief that deeply considered, finely\nhoned code can create better products. I used to evangelize the ideology to\nanyone who would listen. I\u2019ve waxed poetic about the sanctity of clean code.\nThe nobility of well-architected systems. The pride of a perfect pull request.\n\nAs the founder of Kelsus, a software development services company that has\nbuilt products for more than 40 startups and large companies, including Chewy,\nIntel, Equifax, and Splunk, I've browbeaten teammates to adopt rigorous coding\nstandards and argued myself hoarse in conference rooms fighting for more time\nto hone our digital craftsmanship. I've even rage-quit projects where\nmanagement failed to recognize the value of well-honed code.\n\nCode as craft was my religion, my identity. And among developers, I was not\nalone.\n\nBut a blinding light on the horizon of technology has made me question\neverything I once believed. The meteoric rise of Large Language Models (LLMs)\nhas cast a shadow over the concept of code as craft, threatening to eclipse it\nentirely.\n\nIn this piece, we'll embark on a journey beyond the horizon and into the land\nof AI-driven development. We'll explore the far-reaching implications of LLMs\non the way we write, design, and think about code.\n\nAnd I'll make the case for why\u2014as painful as it is to admit\u2014code as craft\nmight just be a relic of a bygone era.\n\n## Crafting a talent magnet\n\nTo truly grasp the rise of code as craft, we\u2019ll need to understand its role in\nthe fierce battle for programming talent.\n\nIn the early days of software, coding was considered a niche, almost clerical\nskill. When the first electronic computers were developed in the 1940s, the\npeople responsible for \"programming\" these machines were often women, many of\nwhom had previously worked as clerks or secretaries. Due to ingrained biases,\npeople still believed women were better suited for repetitive tasks, despite\nthe complex skills required for programming. These women, known as \"computers\"\nor \"coders,\" were tasked with translating mathematical equations into machine\nlanguage, a tedious and error-prone process.\n\nEven as coding became more sophisticated in the 1950s and \u201960s, with the\nadvent of higher-level programming languages like FORTRAN and COBOL, most\norganizations still treated it as a secondary, support role. Programmers were\nthere to serve the \"real\" stars\u2014the hardware engineers and business analysts\nwho were responsible for designing the physical systems and making high-level\nbusiness decisions.\n\nIn 1975, in an article titled \"The Humble Programmer,\" computer scientist\nEdsger Dijkstra lamented this perception of early programming as a second-\nclass intellectual activity:\n\nBut most important of all, the programmer himself had a very modest view of\nhis own work: his work derived all its significance from the existence of that\nwonderful machine. Because that was a unique machine, he knew only too well\nthat his programs had only local significance, and also because it was\npatently obvious that this machine would have a limited lifetime, he knew that\nvery little of his work would have a lasting value.\n\nBut things were changing. Software was finding a foothold in every industry,\nand programmers like Donald Knuth and Dijkstra started to push back against\nthis \"second-class\" ethos. They believed that it was as much a craft as\nanything else, and that a disciplined, aesthetic-minded approach would lead to\nprograms that were more efficient, reliable, and easier to maintain. Knuth\nfamously declared that programming was an art form, stating in a 1974 article:\n\u201cThe chief goal of my work as educator and author is to help people learn how\nto write beautiful programs.\u201d\n\nHis words were deeply influential. As the personal computer revolution\nunfolded into the internet boom, demand for software developers exploded.\nSuddenly, programmers were the rock stars of the business world, and companies\nwere locked in an all-out war to attract and retain the best coding talent.\nFor employers, craft became a subtle form of marketing to signal to developer\ntalent that their company cared about code and was a good place to work.\n\nHowever, the language people used to describe craft was foreign to standard\nboardroom dwellers. Developers mostly talked about mantras and idioms they had\ninvented, like \u201ccontinuous integration\u201d (which is about reducing the amount of\nrepeated effort required to release a new version of an application) and \u201cDRY\ncode\u201d (short for \u201cdon\u2019t repeat yourself,\u201d referring to code that has very\nlittle repetition despite an application\u2019s functionality being repeated in\ndifferent places). None of this meant anything to the vast majority of CEOs.\n\nSometimes, the easiest way to convince the CEOs of the value of craft was just\nto say: The engineers say it\u2019s good, and we need the engineers. Keep that in\nmind. Code as craft doesn\u2019t always have to do with the bottom line. Sometimes,\nit has more to do with winning developer talent.\n\n## The great AI divide\n\nLLMs have sparked a fierce battle, pitting the old guard of code as craft\nagainst a new wave of AI enthusiasts.\n\nOn one side of the divide are the stalwarts of craftsmanship, like Dave,* a\nveteran software architect with 20 years of work experience. When he first\nexperimented with ChatGPT, he was alarmed by what he describes as middling\ncode quality and unvetted code finding its way into his codebase.\n\n\u201cI want an engineer who has carefully considered every line and how it fits\ninto the larger system,\" he explained to an online group of senior tech\nleaders. For Dave and others like him, LLMs are a potential threat to the\nstability and reliability of their software because they sacrifice the careful\nplanning of well-crafted code. This ideology runs deep. Before LLMs, they had\nbeen training staff to avoid Stack Overflow, which, as an aggregator of crowd-\nsourced answers for programming questions, was the former best friend of\njunior developers worldwide. Now, LLMs are seen as just another way of\ndeveloping bad habits.\n\nOn the other side are young, ambitious programmers like Abby.* Abby sees LLMs\nas a liberating force. Where Dave sees risk, Abby sees opportunity. It may be\nthat Abby is less encumbered by the past\u2014as a newer developer, she is more\nopen to the solutions provided by LLMs. She doesn\u2019t mind that the code isn\u2019t\nbeautiful because she believes perfection is the enemy of excellence, and AI-\nproduced code helps her learn. \"It was like having a highly knowledgeable\ncoding partner,\" she explains about her first time using an LLM. \"It could\nhandle a lot of the repetitive tasks, and even suggest improvements and\noptimizations I hadn't considered.\"\n\nAbby and her compatriots believe that the automation of low-level tasks will\nfree up developers to be more creative and focus on the big picture rather\nthan getting bogged down in the details\u2014or worrying about code beauty. She\nalso points out the potential for LLMs to aid in code comprehension and\nmaintenance\u2014the very thing that Dave\u2019s side worries about: \"With an LLM, I can\nunderstand someone else's complex code without having to spend hours reading\nthrough it and adding breakpoints to see what it's doing...\" In Abby\u2019s world,\nthere\u2019s no need to care about the beauty of code. The LLMs will sort out our\nmess.\n\nWho will win this war for the soul of code?\n\nSource: DALL-E. Prompt: Pandora's box covered in runes opening into a\nlandscape with the aurora borealis.\n\n## The future is bright...and weird\n\nIf the evangelists are right that AI will be able to \u201c[outmatch] humans on a\nrange of tasks,\u201c we could be on the cusp of a golden age, where the drudgery\nof coding is largely eliminated and developers are free to focus on higher-\nlevel problems\u2014and, I have argued, build ever more complex systems.\n\nIf they are wrong, the world will stay largely as it is, with an ongoing\nshortage of software developers unable to meet the insatiable demand for\nsoftware, as venture capitalists Paul Kedrosky and Eric Norlen have argued.\n\nIt\u2019s more interesting to consider what will happen in a changing world. What\nsoftware development practices will change under Abby\u2019s regime?\n\nSubscribe\n\n#### Configuration over convention\n\nFirst, we'll need to flip the script on the \"convention over configuration\"\ndogma that's become popular in recent years, thanks in large part to\nframeworks like Ruby on Rails and newer ones like the Serverless Framework.\n\nHumans don\u2019t like reading long lists of technical details, known as\nconfiguration files. Programmers like David Heinemeier Hansson, who wrote The\nRail Doctrine, realized that these lists were often 80\u201390 percent the same\nacross programs. They decided to come up with conventions that essentially\ntold the computer: \u201cDo it the usual way.\u201d For example, in Ruby on Rails,\nsimply labeling a variable \u201cresource\u201d will add all the necessary pipes to be\nable to insert, retrieve, and update it in a database, and to do so from a web\npage. That\u2019s a powerful word.\n\nBut while they are useful for human developers because we can pack a lot of\n\u201cintention\u201d into a name\u2014such as including the word \"save\" in a function name\nto wire its result to a database without additional configuration\u2014they\u2019re a\nnightmare for LLMs. If an LLM is trying to understand a codebase, it needs to\nreason about the behavior and purpose of every component. If those components'\nbehaviors are implied by their names, rather than explicit configurations, the\nLLM has to carry around a huge amount of context about naming conventions. And\nif those names change, the LLM's understanding could be completely broken.\n\nIn an LLM-driven world, explicit is better than implicit. We should strive to\nmake our code as self-describing as possible so that an LLM can understand\nwhat the code will do by \u201creading\u201d it rather than having to \u201cmentally\nsimulate\u201d running it (if those are the right words for what LLMs do!). It\nshould be more akin to an illustrated instruction manual than a rule book.\n\n#### Language selection (training)\n\nWe'll also need to be strategic about the languages and ecosystems we choose\nto work in. LLMs are only as good as the data they're trained on, so it makes\nsense to develop with languages that have a wealth of publicly available code\nexamples.\n\nBased on GitHub's language stats, widely used languages like JavaScript and\nPython are likely to have a significant advantage over more niche languages\nlike Go or Kotlin. The more examples an LLM has to learn from, the better it\nwill be at understanding and generating code in that language.\n\n#### Language selection (static versus dynamic)\n\nThat said, not all popular languages are created equal in terms of LLM-\nfriendliness. Heavily dynamic languages like Ruby, Python, and Javascript\u2014in\nwhich a lot of the behavior isn\u2019t determined until the program runs\u2014are likely\nto present challenges.\n\nIn contrast, programming languages that have strict rules about the types of\ndata they can work with and catch potential errors before the code is run\u2014such\nas TypeScript (a variant of JavaScript with added type checks), Kotlin, Rust,\nand Go\u2014will be much easier for LLMs to understand and work with. The more\nclearly defined and predictable the code's behavior is, the easier it will be\nfor an LLM to generate code that matches the developer's intent.\n\n#### Contextualizing the entire developer experience\n\nPerhaps the most exciting possibilities lie in the ways we can actively design\nour tools to be more LLM-friendly.\n\nLet\u2019s start with a cooking analogy to explain. Imagine a chef with an idea for\na new dish. When they describe it, you can almost taste the food. That's what\ndevelopers do when they set out to create a new piece of software. They have\nthis idea\u2014this intent\u2014of what they want to build and how it should work.\n\nNow, to make that vision a reality, developers need to write code. Code is\nlike the ingredients and instructions in a recipe. But just like a dish can go\nwrong with the wrong ingredients or if you cook it for too long, code can have\nbugs and errors that prevent it from working as intended.\n\nSoftware tests help ensure accuracy. They're like the taste tests you do while\ncooking. You take a little bit of your code and check to make sure it works\nthe way you expect it to. If something tastes off, you know you need to make\nsome adjustments. It's the same with code\u2014if a test fails, developers roll up\ntheir sleeves and debug.\n\nFinally, once the code is written and tested, developers run it to see the\nfinal result. It's like serving up that finished dish to your eager guests.\nThe runtime output is the moment of truth where developers see whether they\u2019ve\ncreated something that works as intended.\n\nDevelopers currently copy-paste code from their code window to the GPT window\nto tell GPT about their intent, code, tests, and runtime output. They ask\nquestions based on parts of those four things. It\u2019s inefficient and error-\nprone, especially because GPT doesn\u2019t keep track of everything at once, it\nonly knows as much from your development efforts and running code as you have\npasted into your conversation.\n\nImagine an integrated development environment (IDE) that keeps four layers of\ncontext: developer intent, code, tests, and runtime output. If it could, it\nwould be much more useful. Already, companies like Cursor, Cognition (which\ncreated AI software engineering assistant Devin), and GitHub Copilot Workspace\nare trying to solve this problem.\n\nSource: DALL-E. Prompt: A leather apron-wearing, beard-wielding, craft-loving\nsoftware engineer in a Craftsman house.\n\n#### Return to monoliths\n\nMore radically, the rise of LLMs could lead to a resurgence of monolithic\narchitectures. In monolithic architectures, code is packaged together and\ncompiled into a single executable program\u2014kind of like an iPhone where you\ncan\u2019t swap the battery, screen, or antenna without rebuilding the whole thing.\nThese types of architectures for big systems have lost favor to microservices,\nwhich are small applications that typically have singular purposes\u2014like\nupdating a user\u2019s profile in a database. Microservices allow large teams to\nwork on isolated features independently without stepping on each other's toes.\n\nBut microservices come with a significant cost: complexity. Managing the\ninteractions, dependencies, and side effects among scores of microservices is\na Herculean task, one that often requires dedicated teams and sophisticated\ntooling. And it will become more difficult for an LLM to reason about the\nbehavior of the system as a whole as the number of services grows.\n\nEnter LLMs. The larger its context window, the more code an LLM can understand\nand reason about at once. In a world where LLMs are a primary tool for code\ngeneration and modification, the benefits of microservices start to look less\ncompelling.\n\nWhy split your system into 100 microservices when an LLM can understand and\nmodify a monolith just as easily? With LLMs automating much of the code\nwriting, the need for separate teams working on separate services diminishes.\n\nInstead, we might see a return to what we could call \"mesoservices\"\u2014not quite\nthe hulking monoliths of old, but larger and more integrated than the\nmicroservices of today. These mesoservices would be large enough to\nencapsulate significant business functionality, but small enough for an LLM to\nfully grasp and manipulate.\n\nIt's a vision of a future where the structure of our systems is determined not\nby the limitations of human developers, but by the capabilities of our AI\ntools. A future where the age-old trade-offs between complexity and\nmodularity, between coupling and cohesion, are fundamentally rewritten by the\npower of LLMs.\n\nOf course, this is all speculation. The reality is that we're in uncharted\nterritory, and the path forward is anything but clear. But one thing seems\ncertain: The rise of LLMs will force us to reconsider many of our long-held\nassumptions about programming and how it should be done.\n\nThe developers and organizations that are able to adapt, to embrace the power\nof AI while also understanding its limitations, will be the ones that thrive\nin this Hunger Games of software. It won't be easy, and there will undoubtedly\nbe missteps and setbacks along the way. But the potential rewards\u2014a world in\nwhich software development is more accessible, more efficient, and more\nfocused on high-level problem solving\u2014are too great to ignore.\n\n## Reconnecting craft and business value\n\nWe\u2019ve spent long enough with CEOs unable to understand the terminology of\nsoftware engineers and why the things they care about matter. LLMs are likely\nto be both a revolution and an evolution for the world of software\ndevelopment. They will fundamentally change many of our day-to-day practices\nand assumptions.\n\nIf an LLM can understand and maintain a function with 50 nested \u201cif\u201d\nstatements as easily as it can understand a clean, well-factored one, and they\nboth functionally do the same thing, does one have greater business value than\nthe other? If an LLM can generate a new feature from a simple description\nfaster than we can write the code ourselves, does it still make sense to\nobsess over clean, minimal code?\n\nLLMs will force us to rethink what we value in code and in developers. The\ncraft of software development, as we've traditionally understood it, may\nbecome less about the minutiae of code structure and more about the high-level\ndesign of systems and architectures.\n\nOn the other hand, many of the fundamental truths about software development\nare likely to remain unchanged. The skills that truly great developers bring\nto the table\u2014creativity, problem-solving, systems thinking\u2014will be more\nvaluable than ever in a world where the low-level details of coding are\nlargely automated.\n\nIn this world, the value of these top developers won't just be high\u2014it will be\nstratospheric. Companies will compete fiercely for their attention and\nservices. The gap between the best developers and the rest will widen, and the\nimpact of these star performers will be felt across the industry.\n\nOrganizations that value and nurture this kind of craftsmanship, just like\nbefore, will have a significant advantage in the war for talent. And in an\nindustry where the quality of your human capital is often the difference\nbetween success and failure, that's an advantage that can't be overstated.\n\nCode as craft is dead. Long live code as craft.\n\n*Names have been changed.\n\nJon Christensen is the founder of Kelsus, a startup-focused development\ncompany that has helped launch more than 40 startupsPreviously, he cut his\nteeth at Denver-based startups like Boldtech, StorePerform, and IP Commerce.\nHe graduated from Amherst College with a degree in computer science.\n\nTo read more essays like this, subscribe to Every, and follow us on X at\n@every and on LinkedIn.\n\nSubscribe\n\n#### What did you think of this post?\n\nAmazing Good Meh Bad\n\n### Like this? Become a subscriber.\n\nSubscribe \u2192\n\nOr, learn more.\n\nThanks for rating this post\u2014join the conversation by commenting below.\n\n## Comments\n\n## Your boss reads this newsletter\n\nGet one actionable essay a day on AI, tech, and personal development\n\nSubscribe\n\nAlready a subscriber? Login\n\nContact Us \u00b7 Sponsor Us \u00b7 Search \u00b7 Terms\n\n\u00a92024 Every Media, Inc\n\nBy continuing to browse the site, you agree to our use of cookies.\n\n", "frontpage": false}
