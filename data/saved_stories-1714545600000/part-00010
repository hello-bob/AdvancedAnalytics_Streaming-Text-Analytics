{"aid": "40214736", "title": "Passkey Implementation: Misconceptions, pitfalls and unknown unknowns", "url": "https://www.corbado.com/blog/passkey-implementation-pitfalls-misconceptions-unknowns", "domain": "corbado.com", "votes": 2, "user": "vdelitz", "posted_at": "2024-04-30 18:52:07", "comments": 0, "source_title": "Why Passkey Implementation is 100x Harder Than You Think \u2013 Misconceptions, Pitfalls and Unknown Unknowns", "source_text": "Why Passkey Implementation is 100x Harder Than You Think \u2013 Misconceptions,\nPitfalls and Unknown Unknowns\n\nBack to Overview\n\nImplementation\n\n# Why Passkey Implementation is 100x Harder Than You Think \u2013 Misconceptions,\nPitfalls and Unknown Unknowns\n\n## Read our learnings about passkey implementation challenges, pitfalls and\nmisconceptions we faced while building passkey-first authentication\n\n## Vincent\n\nCreated: April 27, 2024\n\nUpdated: April 27, 2024\n\n\u201cAh yes passkeys, pretty cool technology and great that there\u2019s already wide\nsupport, plus an open standard that they are built on. I\u2019ll just grab one of\nthe libraries for my framework and that should do the job. I don\u2019t think I\nneed any help or service. I\u2019m a decent coder and have added auth packages\ndozens of times in the past.\u201d\n\nThis is a typical conversation I had over the past 24 months with many\ndevelopers. And I have to admit, that this was also my initial thought when I\nencountered passkeys for the first time in May 2022: It shouldn\u2019t be too hard.\nIt shouldn\u2019t be too complicated. Hey, in the end, it\u2019s just another way of\ndoing (passwordless) authentication. And here I am in mid-2024, still\ndiscovering new cases you need to take care of in real-life applications.\nThat\u2019s the reality - which fascinates me.\n\nWith this blog post, I want to share with you the learnings on my way when\nworking on a passkey-first auth solution with Corbado. All the hard truths,\nthe unknown unknowns (factors that were not anticipated prior to my\nexperience, essentially things we did not know we did not know), and the\nmisconceptions should be uncovered, so that you know what to consider when\nimplementing your own passkey-based authentication.\n\nWhether you're at the initial stages of adoption, considering enhancing your\nexisting systems with passkeys or starting a passkey-first authentication\nproject, this guide will help you avoid common pitfalls.\n\n## TL;DR:\n\n\u201cCan you add passkeys as new auth solution in our next sprint?\u201d asks the\nproduct manager, as he\u2019s heard about passkeys as the new passwordless login\nmethod that all the big players in the tech industry implement. No more\npassword resets. Higher conversion rates. No more phishing attacks (also a\ndream of every IT security manager). Everyone is excited for this new way of\nauthentication. Even the developer who has to implement it. Even though he\u2019s\nread some controversial posts on Hacker News about passkeys, he still thinks\nit\u2019s a cool concept and from the company\u2019s perspective, it makes a ton of\nsense to add it as an option (though, no one should be forced to use it, of\ncourse, so let the users decide what they want!).\n\nThe developer starts his research on passkeys just as he would do for any\nother new feature that the product team has requested. He opens Google and\ntypes in \u201cwebauthn specification\u201d, \u201cpasskey tutorial\u201d, \u201chow to implement\npasskeys\u201d, \u201cpasskeys in react\u201d and \u201cpasskey libraries\u201d. This should be a good\nstart. Skim through the specification to get a rough understanding, scroll\nthrough some tutorials and sample projects. Check if there are some libraries\non GitHub that can be used. In the end, it will probably all come down to some\nbackend API endpoints that need to be implemented, a quick frontend\nintegration and then just use the session management that is already in place.\n\nHowever, the more the developer researches the topics, the more things come to\nhis mind: how do passkeys work on devices that are older? What if the user\ncancels the flow or loses the device where the passkey is stored? How can the\nnew passkey login be tested on different devices, operating systems and\nbrowsers. He realizes that this might not be only a 1-sprint-task.\n\nThis is not an isolated story. Many developers that reached out to us and\nscratched below the surface of passkeys faced similar challenges. Implementing\npasskeys in a real-life project is 100x harder than you might initially think\n(trust us \u2013 we\u2019ve gone through it).\n\nOur mission is to help developers implement passkeys. That\u2019s why we created\nthis blog post. So, let\u2019s take a look at the 15 most common misconceptions\nwhen implementing passkeys, so that you know what to take care of.\n\n#1 Creating Passkeys is Just Triggering navigator.credentials.create()\n\n#2 Passkeys Logins are Only About When to Trigger navigator.credentials.get()\n\n#3 Available Passkeys can be Detected from the Browser\n\n#4 User Agents are Great for Device Recognition\n\n#5 An Open Standard like WebAuthn is Easy-to-Read\n\n#6 Passkey Management UI is Easy-to-Build\n\n#7 Passkeys are New but Common Use Cases are Well Supported\n\n#8 Passkey UX/UI is Great and Predefined\n\n#9 Conditional UI Always Ensures a Smooth Login Experience\n\n#10 Passkeys Work in All Browsers as Expected\n\n#11 Passkeys' Availability Equals Accessibility\n\n#12 QR Codes are Simple and Appear only When Needed\n\n#13 Passkeys Are Universal and Thus Easily Testable\n\n#14 Only Adding Passkeys to an Existing Auth Solution is Easy\n\n#15 Please Help Me: I Think I Don't Want Passkeys Anymore\n\n## #1 Creating Passkeys is Just Triggering navigator.credentials.create()\n\nI\u2019ve seen this WebAuthn JavaScript API where I can simply create a new passkey\nby calling navigator.credentials.create().\n\nNot really! It\u2019s one of biggest misconception that one API call is enough.\nEven though the WebAuthn JavaScript API (called with\nnavigator.credentials.create()) is the simplest component and most\nstraightforward part of any passkeys project, the real complexities arise\nbefore and after this API call. If you want to adopt a passkeys-first\napproach, you need to consider many more things, such as:\n\n  * Implement two backend API endpoints for one simple passkey creation: Developers who have mostly worked with password-based authentication often think that they simply need to call one backend API endpoint, like in the password world, and get a success / failure message returned. However, with WebAuthn you need to call two backend API endpoints with the JavaScript API call from above in between and then receive the response. For new starters, this can be quite complex as the information sent along needs to be in the right order and correctly encoded / formatted.\n  * Provide fallbacks if passkeys don\u2019t work or the flow is canceled: You need alternative authentication options like email OTP, SMS OTP, social logins or passwords (if you don\u2019t want to fully passwordless yet). They are needed in case the device is not passkey-ready or the user deliberately cancels the passkey registration flow. Then, you need to provide equally comfortable options for signing up.\n  * Verify the user to avoid account take-overs: Passkeys can also work in usernameless way. However, in real-life applications, you need to verify the user and their login identifier (e.g. email address or phone number) to avoid account take-over attacks. In the worst case, someone could simply create a passkey and use your email address as login identifier (so no verification took place). If the system is designed in such a way that you can use this email address (e.g., through a passkey append flow with an email OTP) to create another passkey on a different device, then an attacker could potentially use the first passkey to log into your account.\n  * Detect if passkeys are already stored on the device: It's important to know which devices have passkeys stored and which do not (in order to know where passkey creation / logins can be securely offered to users \u2013 more on that later). In the passkey creation case, allowing multiple passkeys per account could lead to major user confusion. We call these decision rules \u201cpasskey intelligence\u201d, as a logic around passkeys, users and devices needs to be developed.\n  * Support cross-device registration & hardware security keys: Do you want to allow the creation of a passkey on a different device from the one you are currently using to access the application? Or do you need to support hardware / FIDO2 security keys (e.g. YubiKeys)? If yes, there are some important things to consider for your implementation, that have impact on the PublicKeyCredentialCreationOptions used in navigator.credentials.create():\n\n    * Do you want to prioritize cross-device registration / hardware security keys over local passkeys?\n    * Do you want to offer them as an equal option?\n    * Do you want to offer them only as a fallback? Should this fallback only be available in logins or also in account sign-ups?\n  * Adapt the backend & database: Choosing the WebAuthn server (basically a library) is pretty straightforward and so is the installation (e.g. npm install @simplewebauthn/server). But then the real challenge starts:\n\n    * How are you going to connect the passkey logic to your system? All passkey detection and passkey intelligence operations (see #2, #11 and #23) are influenced by this decision. The most complex aspect is how to integrate things. Adapting existing flows, taking care of session management and transitioning existing users to passkey requires adaptations. You need to provide intelligence for passkeys, user and devices, as well as fallbacks in case of non-passkey-readiness.\n    * Have you already drafted the credential database table with all the columns, flags, data types, that work with your database system, your WebAuthn server and your programming language. If yes, please don\u2019t forget to look at the right encodings (WebAuthn challenges are Base64URL encoded, while public keys are encoded in COSE format and authenticatorData is serialized in CBOR). Hopefully, you also have an idea on how to store credential-specific attributes and settings (e.g. transports information or authenticatorAttachments)? The hard things is that most of the existing WebAuthn server libraries do not come with the actual credential storage. It needs to be designed and implemented all by yourself (also all relevant credential information needs to be extracted from the WebAuthn responses manually).\n  * Implement passkey-specific UX: Creating passkeys is great for UX. But that only counts for the creation process itself when the Face ID modal comes up and the user just scans their face as they do countless times during the day. The challenge lies more often before and after this particular ceremony and requires a lot of additional user flows that need to be implemented:\n\n    * Consider when to offer the passkey creation: after every successful login with an existing method? Even after a social login with a Google account?\n    * What about users that have not verified their email address / phone number? How should they be treated, given that, from a technical point of view, they could create a passkey without any problem?\n    * Where will users manage their passkeys? Do they use a first-party passkey provider (e.g. iCloud Keychain or Google Password Manager) or a third-party passkey provider (e.g. Dashlane, 1Password or KeePassXC). All that affects where passkeys can later be used for logins.\n    * Should users be allowed to add multiple passkeys per device?\n\n## #2 Passkeys Logins are Only About When to Trigger\nnavigator.credentials.get()\n\nOkay, there\u2019s some more to creating a passkey but to login with a passkey, I\nsimply call the WebAuthn JavaScript API via navigator.credentials.get(), as\nthe passkey already exists.\n\nEh nope. It\u2019s the other way around. Outstanding passkey experience during\nauthentication means to figure out when not to start a passkey authentication\nceremony in the first place to prevent dead-ends and unnecessary loops. Yes,\nthis can even happen on devices that support passkeys in general if there is\nno passkey available at this device (see also #3)! Don\u2019t believe us? Then,\ntake a look the following examples:\n\n  * Example 1 \u201cWindows 10 or 11 desktop without Bluetooth\u201d: A user signs up and creates a passkey on their iPhone with iOS 17. Then, the users uses their desktop that runs on Windows 11. Although Windows 11 supports passkeys, the computer lacks Bluetooth, which is required for WebAuthn Cross-Device Authentication (CDA) via QR codes (it's a security measure to ensure both devices are in proximity).\n  * Example 2 \u201cDevice-bound passkeys\u201d: Often, workplace computers run on Windows 10 or Windows 11. Passkeys created on these systems are not synced to other devices (-> device-bound passkeys). Attempts to login with a passkey on another device will fail because the user does not have an alternative passkey on a mobile device for CDA.\n\nHowever, the scenario can also reverse:\n\n  * Example 3 \u201cThird-party passkey providers\u201d: Some users might use password managers like 1Password, KeePassXC or Dashlane, which now also store passkeys as third-party passkeys providers across operating systems. If the passkey from example 1 or 2 is stored in one of these password managers, the passkey login should be permitted. Therefore, you need to know where the passkey was created, whether the current device has the password manager installed and active, and if the passkey is synced, to provide a convenient login experience without locking the user out.\n\nTo ensure a seamless passkey login experience, it\u2019s essential to be highly\ncertain that the login process will succeed before initiating the passkey\nlogin ceremony. This helps avoid false positives (thus, it's necessary to\ntrack how often and how a user logs in to influence the decision on which\nlogin method to offer), minimizes disruptions, and prevents inefficient\nauthentication loops that could frustrate users and lower conversion rates.\n\n## #3 Available Passkeys can be Detected from the Browser\n\nOkay, I understand that I need to check if a passkey is available before\ntriggering a login. This should be fairly easy with some other browser feature\nor JavaScript API, right?\n\nAbsolutely not. This is a big fallacy \u2013 if not the biggest \u2013 and it actually\ncauses many of the subsequent fallacies or is related to them. Knowing in\nadvance (before any WebAuthn ceremony starts) whether a passkey is available\non a device would be a tremendous help in facilitating the login, as you would\nthen know that there can\u2019t be a mismatch or error in the login process.\nWithout this knowledge, you need to use other factors that help improve the UX\nand avoid any unexpected failures that disrupt the login experience.\n\nLet\u2019s understand why available passkeys on a device cannot be detected from\nthe browser. Passkeys and the FIDO Alliance, as the driving force behind them,\nhave a strong privacy-by-design mindset. All passkey operations are designed\nto prevent identification of users and the revealing of any privacy-related\ndata based on their available passkeys. Only after an authentication on the\ndevice using fingerprint scanning or Face ID, which is treated like explicitly\nproviding user consent, more information is given. That\u2019s why you can test for\npasskey-readiness of a device and browser with one of the following methods\nbut it is impossible to directly detect whether a passkey already exists on a\nspecific device prior to any WebAuthn operation:\n\n  * Is my device & browser WebAuthn-ready: PublicKeyCredential\n  * Is my device & browser passkey-ready (platforma-authenticator-ready): PublicKeyCredential.isUserVerifyingPlatformAuthenticatorAvailable()\n  * Is my device & browser Conditional-UI-ready: PublicKeyCredential.isConditionalMediationAvailable()\n\n## #4 User Agents are Great for Device Recognition\n\nI see that there is no feature to directly detect passkey availability from\nthe browser, so I think I\u2019ll just use the good older user agent to manage\ndevices and passkeys.\n\nGood idea \u2013 might just not work as easy, especially not on all browsers! After\nreading through the first fallacies, you might consider implementing a proper\ndevice management system (in this context called passkey intelligence) to\ndetect where passkeys were created and from where the user might try to login\nwith a passkey. Building such a passkey intelligence to detect devices in 2024\nis not as easy as it used to be:\n\n  * User agents are phased out: A robust user-agent parsing library is essential to accurately detect the operating system, browser, and device type (mobile or desktop) from the user-agent HTTP header. Unfortunately, this method remains fully effective only for Safari. All other browsers are about to phase out the user agent soon (or have already done so).\n  * Chromium\u2019s user-agent reduction initiative: Chromium-based browsers (e.g. Chrome, Edge) and Firefox have significantly reduced the level of detail in their user-agent strings as part of their user-agent reduction initiative (primarily to avoid tracking and protect user privacy). To effectively recognize devices using Chrome, Edge or Firefox, the usage of client hints (e.g. via navigator.userAgentData.getHighEntropyValues()) is necessary. This JavaScript API is used for the precise distinction between operating systems and browsers (+ corresponding versions). Note that Safari does not support this API, and also that client hints cannot be retrieved via HTTP headers out-of-the-box.\n\nConsequently, to provide passkey intelligence for all browsers, you need to\nsupport both methods (user agent & client hint parsing). Implementing these\nAPIs in your passkey intelligence is a lot of work and don\u2019t forget: devices\nand browsers update continuously. That\u2019s why you need passkey intelligence\nthat supports updates for operating systems and browsers.\n\n## #5 An Open Standard like WebAuthn is Easy-to-Read\n\nThe WebAuthn specification should facilitate the use of secure and simple\nauthentication. Therefore, it will be probably easy-to-read and\nunderstandable.\n\nNope \u2013 unless you are an expert authentication or have a PhD in cyber\nsecurity. Cryptographic protocols and authentication standards are difficult\nto read and understand. And so is WebAuthn. There are a lot of complexities to\nbe understood, when you want to implement passkeys / WebAuthn. You\u2019ll need a\nlot of know-how that is not part of the WebAuthn standard. How come? To answer\nthis question, you need to understand the different WebAuthn Levels,\nespecially from a chronological perspective and that the older ones were\nwritten in a time where hardware security keys were the primary method for\nWebAuthn (and not platform authenticators like Face ID or Windows Hello):\n\n  * WebAuthn Level 2 (current version; since April 2021): Passkeys were initially not included in this released version, as the term 'passkeys' and the sync feature were introduced in 2022. There is significant industry effort, especially by the FIDO Alliance, to make the WebAuthn standard in general more passkey-like. As a result, many features have been incorporated into the draft of WebAuthn Level 3, which has not yet been released. But passkeys are already available today, so the WebAuthn level 2 is still the official version. This add complexity (especially as some aspects are no longer in the passkey-era or are redundant, e.g. requireResidentKey vs. residentKey or recommendations regarding the usage of attestation).\n  * WebAuthn Level 3 (expected from the end of 2024 onwards): The WebAuthn Level 3 standard is supported by a wide range of industry players. When the Web Authentication Working Group agrees on a new feature and organizations like Google, Apple, Microsoft, and Mozilla implement this feature in their browsers, it immediately becomes the de facto standard. Usually, the market pressure is significant when Apple (with Safari, iOS, and macOS) and Google (with Chrome and Android) implement the feature, as they control the majority of the desktop and mobile browser market, along with their respective operating systems.\n\nTo stay up-to-date with the WebAuthn standard and keep pace with the passkey\nusability of larger platforms (e.g., Android, iOS, macOS, Windows), it is\nnecessary to monitor a variety of input sources besides the existing (and\ncontinuously updated) WebAuthn spec:\n\n  * Follow the WebAuthn GitHub issues to anticipate new passkey / WebAuthn features early on and understand why they might or might not be introduced.\n  * Regularly take a look at WebAuthn Level 3: Editor's draft commits to see how the standard changes\n  * Check Chromium feature requests and releases to test new features and adapt your auth solution accordingly\n  * Review Mozilla & Webkit issues to test new features and understand browser behavior\n\nAs the passkey / WebAuthn ecosystem is highly heterogeneous, the standard is\ninterpreted and implemented differently. Therefore, depending on the WebAuthn\nserver library used, you need to handle various WebAuthn levels in your\nceremonies. Since new passkeys are continuously being developed, it\u2019s almost\ncertain that there will be new changes in the future, which will further\ncomplicate matters. To feel this heterogeneity and complexity yourself, feel\nfree to research the following topics in the context of WebAuthn and check the\ncorresponding discussions:\n\n  * Passkeys themselves (especially the sync feature)\n  * Conditional UI\n  * supplementalPubKeys\n  * PublicKeyCredentialHints (to deprecate AuthenticatorAttachment)\n\n## #6 Passkey Management UI is Easy-to-Build\n\nBuilding a passkey management UI and the corresponding functionality to\ncreate, edit and delete passkeys should be rather simple.\n\nYes and no \u2013 while building a passkey management UI isn\u2019t too hard there are\nsome things which are rather counter-intuitive. Industry best practice for\nmanaging passkeys is to list all available passkeys for a user in the account\nsettings. Thanks to resources like https://passkeys.dev, having access to a\ncomprehensive list of passkey providers with logos and names is\nstraightforward. It can be used to display passkey-provider-specific\ninformation for a passkey. However, managing passkeys involves more:\n\n  * Exclude credentials when adding passkeys: When offering an \u201cAdd passkey\u201d button in the account settings, the excludeCredentials PublicKeyCredentialRequestOption property must be used correctly to prevent mismatches between the user's passkeys on the client-side on their device and those stored server-side in the backend.\n  * Deleting passkeys server-side could lead to confusion: Deleting a passkey in the account settings (server-side) is more complex. A good UI typically includes a delete button for each listed passkey. When a passkey is deleted server-side, it remains on the client-side (on the device). The user might still attempt to log in with it, which is problematic. The passkey should be flagged as deleted on the server-side. Additionally, to prevent future confusion, the AllowCredentials list of the PublicKeyCredentialRequestOptions in the authentication ceremony should not be left blank if a passkey was deleted server-side. Instead, AllowCredentials should be filled with all passkeys except the deleted ones. Implementing such a logic requires intelligent passkey management on the server-side.\n\nIn general, we have often received questions about whether the\nAllowCredentials list should be left empty or filled with credentials. The\nanswer depends on the specific security and operational needs:\n\n  * Empty AllowCredentials: This approach avoids credential enumeration, reducing the risk of exposing user information to attackers. It also maximizes the available options for the user, as it allows any stored credential to be used for authentication.\n  * Filled AllowCredentials: Filling the AllowCredentials list with credentials enables the backend to filter out deleted passkeys. This is especially useful in scenarios where the user identifier is known when the WebAuthn login ceremony starts (thus not possible in usernameless login scenarios). This allows the system to list only those passkeys that match this identifier and are not deleted. This targeted approach enhances security by restricting the authentication process to specific credentials.\n\nAs you see, there is no clear answer to this question and you need to decide\nbased on your specific requirements.\n\n## #7 Passkeys are New but Common Use Cases are Well Supported\n\nEven though passkeys are new, they are backed by some of the most UX-oriented\ncompanies, so the most common use cases for supporting passkey authentication\nshould be well supported.\n\nYes, passkeys are a relatively new technology, and while they effectively\nsupport the most important use cases, particularly the plain sign-up and login\nprocess, and rise in adoption, they fall short on other common real-life\ncases:\n\n  * Use Case 1: Deleting a passkey on the device (client-side): If the user decides to locally delete the passkey on their device, the server never receives the information that this passkey cannot be used anymore. This could lead to serious friction:\n\n    * Passkey login fails completely: Let\u2019s assume the following scenario: a user has deleted their passkey on a Windows 11 computer using Chrome. Passkey intelligence might recognize the device as a known Windows 11 system and incorrectly assume the passkey is still present and accessible. However, the authentication process will inevitably fail because the passkey (private key) no longer exists on the device. The user will then need to rely on a fallback method. To address this issue, passkey intelligence should be capable of detecting when a passkey is repeatedly used for authentication attempts but never successfully, suggesting it is likely inactive or has been deleted.\n\n    * Confusing QR codes in CDA scenarios: In this scenario, if a user, for example, deletes their mobile phone passkey from their iPhone (CDA authenticator), passkey intelligence may continue to try Cross-Device Authentication via QR code, operating under the assumption that the passkey locally still exists. This leads to the generation of erroneous QR codes, further complicating the situation as outlined in #12.\n\nThis issue is becoming increasingly prevalent due to the passkey management\nUIs for deleting passkeys introduced by Apple, Android, and Microsoft. As\nsuch, the case, where the local passkey is missing, can arise unexpectedly and\nsignificantly disrupt the user experience. To mitigate this, the passkey\nintelligence should automatically detect such situations through analysis of\nuser behavior.\n\n  * Use Case 2: Automatic transition from password-based to passkey-based accounts: Currently, there is no fully standardized method for signaling that a website supports passkeys, which would enable password managers to automatically transition password-based accounts into passkey-based accounts. However, Google Password Manager supports an initial implementation, which should be closely monitored and integrated into the passkey authentication solution as soon as it gets broader support:\n\n  * Use Case 3: Change passkey-associated meta data: When a passkey is created, the following meta data is associated with the passkey and stored on the client:\n\n    * user.name: Serves as a visible login identifier, typically an email address, phone number or username.\n\n    * user.displayName: Represents the readable name of the user, used to personalize Conditional UI and the passkey modal experience for users.\n\nThis meta data is very helpful for users to distinguish different accounts and\npasskeys on a device. However, there is a crucial aspect missing: When a user\nchanges any of this information today, it cannot be reliably updated across\nall associated passkeys.\n\nWhile user.name and user.displayName play an important role for providing a\ngood UX, there\u2019s one other, less documented WebAuthn field that causes more\nissues in the login process, when there was a change: user.id. This field\nstores the actual primary account identifier (i.e., the ID that identifies the\nuser account in your user database). Consequently, the following situation\ncould occur: a user changes their email address (user.id) from\nold.mail@gmail.com to new.mail@gmail.com in the account settings. Then, the\nuser provides the new email address in the email input field\nnew.mail@gmail.com, triggering a passkey login ceremony linked to the old\nemail old.mail@gmail.com, as the passkey still has the old email stored (also\nin a usernameless scenario, the user would still see the old email address in\nthe passkey autofill dropdown). Yet, access is granted (even though from a UX\nperspective it\u2019s not obvious why the old email address still works for\nWebAuthn logins). Therefore, it's important to carefully manage how database\nlookups are performed.\n\nuser.name, user.displayName, user.id, response.userHandle, and Credential ID\ncan be major sources of confusion and errors if not thoroughly understood in\nthe beginning of your passkey implementation.\n\nWhile these three use cases may be less relevant for smaller user bases, they\nbecome increasingly common as the user base grows, particularly where unused\npasskeys pose challenges for passkey intelligence operations (see #2 and #12).\n\n## #8 Passkey UX/UI is Great and Predefined\n\nOkay I get it: developing passkey authentication is technically complex, but\nonce it's implemented, the process becomes quite straightforward, right?\n\n  * Passkey icon: The good news is the FIDO alliance has created an icon for you.\n  * Product management decisions: As in any other project, where UX plays an important role (and authentication is probably one the most crucial ones in regard to UX), the product management team wants to provide a significant input. The most common questions from a product management perspective are:\n  * Which devices to support?: What kind of devices can we expect among our users? How high will the coverage of passkey-ready devices be? To answer these questions, we recommend any organization to start analyzing the passkey-readiness of their user base\u2019s devices prior to any passkey launch.\n\n    * When and how should users be verified?: If you are considering a passkey-first approach, do you plan to verify the email or phone number associated with the passkeys at sign-up, on first login, or never?\n    * Which mockups do we need to provide?: Expect that you will need specific mockups for passkey-related flows:\n\n      * Sign-up via passkeys or via fallback method (e.g. email OTP)\n      * Login via passkeys or via fallback method (e.g. email OTP)\n      * Offer adding passkeys after fallback-login on new devices\n      * Create understandable error messages\n      * Design a user-friendly passkey management UI\n  * UX/UI best practices: To provide a really appealing passkey UX/UI, a few more things need to be considered before the rollout:\n\n    * Define a passkey introduction strategy: Considering your user base, how do you plan to announce and introduce passkeys? Options include an explanatory page, email communications, pop-up notifications, or push notifications. We\u2019ve seen a great a variety of approaches here.\n    * Facilitate transition to passkeys: There\u2019s a lack of best practices how you can nudge your users, especially non-technical ones, to transition to passkeys, so you need to come up with own strategies and flows.\n    * Look for UI recommendations: Choose your best practices from a wide list of partially contradicting guidelines:\n\n      * Google\n      * FIDO alliance\n      * web.dev\n      * Real world examples (e.g. Kayak, Amazon, GitHub)\n    * Define fallback strategy: How are you handling passkey errors? Are you going to immediately trigger fallback authentication or do you allow re-tries?\n    * Handle errors and provide troubleshooting guidance: Have you ever considered what happens when a user is on a modern iPhone with the latest browser but hasn't activated the iCloud Keychain? From the JavaScript API calls in the browser, the passkey intelligence would detect that the device is passkey-ready, but once the user starts the passkey registration ceremony, an error message will pop up instructing the user to activate the Keychain. This could be an error screen that they have never seen before, potentially causing confusion. Developing proper error handling and providing fallbacks for these scenarios is crucial.\n\nIn conclusion, while passkeys are technically complex to implement, do not\nunderestimate the effort required to address various product management\naspects.\n\n## #9 Conditional UI Always Ensures a Smooth Login Experience\n\nI love Conditional UI as it\u2019s the most seamless login I\u2019ve ever seen. I don\u2019t\neven need to provide a username anymore and it works so smoothly on supported\ndevices.\n\nIndeed, Conditional UI provides one of the smoothest login experiences. There\nare however some things to consider or even improve on top. In general, one of\nthe best things about passkeys is that the user does not need to explicitly\ncome up and memorize passwords anymore. Passkeys are automatically saved by\nthe operating system (or by a third party passkey provider like 1Password,\nKeePassXC or Dashlane) from where they can be used in any future login\nattempt. Generally, with passkeys, there are three modes to log in:\n\n  * Regular passkey login with WebAuthn modal (after asking for login identifier first):\n\nCalling the WebAuthn startLogin() backend API to initiate a regular passkey\nlogin is the way to go if the user enters their identifier first and clicks on\na submit button. This allows for preliminary checks to determine if the user\nexists and to assess if passkeys exist and are accessible via passkey\nintelligence (see #11, #12). If the user exists but cannot use passkeys, a\nfallback method is immediately triggered. Passkey intelligence should then\nstop the WebAuthn login process before the authenticator modal appears.\nOtherwise the regular WebAuthn login process is executed.\n\nRegular passkey login\n\nRegular passkey login with filled email address\n\nConnect to the authenticator for login\n\n  * Passkey login button (on top level):\n\nSometimes, we see implementations that are not passkey-first (because\npasswords are presented as an equally viable option). This often involves a\nlayout where users must actively click on a 'Login with Passkey' button. We\nrecommend this approach only when a large existing user base is gradually\ntransitioning to passkeys and the current authentication flow should not be\ndisrupted. However, the downside is clear: users who have not set up passkeys\nmay be confused.\n\n  * Conditional UI Login: Conditional UI, also known as usernameless login, behaves differently depending on the operating system. For example, Safari on iOS might display a modal suggesting the last used passkey, while Chrome on Windows shows a dropdown of all available passkeys for immediate login. These dropdowns are initiated with the navigator.credentials.get() call, using the \u2018mediation: \u201cconditional\u201d\u2019 flag:\n\n    \n    \n    // Availability of `window.PublicKeyCredential` means WebAuthn is usable. if ( window.PublicKeyCredential && PublicKeyCredential.isConditionalMediationAvailable ) { // Check if conditional mediation is available. const isCMA = await PublicKeyCredential.isConditionalMediationAvailable(); if (isCMA) { // Call WebAuthn authentication const publicKeyCredentialRequestOptions = { // Server generated challenge challenge: ****, // The same RP ID as used during registration rpId: \"example.com\", }; const credential = await navigator.credentials.get({ publicKey: publicKeyCredentialRequestOptions, signal: abortController.signal, // Specify 'conditional' to activate conditional UI mediation: \"conditional\", }); } }\n\nIn the source-code sample above, no username is transmitted initially. The\nWebAuthn server simply creates a challenge. If the user selects an account\nfrom the Conditional UI list, the browser signs the challenge. The assertion\nincludes the user.id (as response.userHandle) and the private key is used to\nsign the challenge. The backend then verifies the challenge and logs in to the\ncorrect account.\n\nWell, seeing these different login options sounds very promising so far, but\nthere are some caveats. From our user testing and funnel analysis of passkeys,\nwe've observed that passkey modals / popups sometimes interfere with user\ninteractions. Users might abort the automatically initiated modals / popups,\nand moreover, Conditional UI is not supported on all platforms. Therefore, we\nrecommend leveraging LocalStorage information to optimize the passkey login\nexperience:\n\n  * Store recently used passkey hints in LocalStorage: Storing information about recently used passkeys (e.g. credential IDs and login identifier) can help to optimize user experience. This information can also be leveraged as input to the passkey intelligence (further improving: #2, #11, #12). Users can log in to a 'recently accessed' account with a single click, bypassing dropdowns or modals. If the user wishes to access a different account, the UI then switches to Conditional UI.\n\nThe information displayed can be increasingly precise: For example, if a\nmobile device was used for Cross-Device Authentication, this detail could be\nincluded in the message to guide the user to the correct device.\n\n## #10 Passkeys Work in All Browsers as Expected\n\nAs passkeys are supported by all major browsers, the behavior and UX should be\nthe same everywhere.\n\nWell no. In general, for passkeys to work, there are two different things to\nconsider:\n\n  1. Available passkeys on the login device: The operating system and the browser must support passkeys (moreover the different versions of operating system and browser play an important role). This can be detected using PublicKeyCredential.isUserVerifyingPlatformAuthenticatorAvailable().\n  2. Passkeys in Cross-Device Authentication or Registration: Support from the operating system or browser for Cross-Device Authentication is required. Unfortunately, this cannot be detected with PublicKeyCredential.isUserVerifyingPlatformAuthenticatorAvailable(). It may erroneously return false for devices that are capable of proceeding with Cross-Device Authentication (CDA). You also need to check for Bluetooth availability (e.g. Bluetooth.getAvailability()- note that even if this function returns true, it does not imply that Bluetooth is activated currently) and provide the right PublicKeyCredentialRequestOptions for the WebAuthn server (both of which can hold their own problems) \u2013 see #4 for more details.\n\nWhile the UI for biometric authentication modals in the operating system\ncannot be altered, browsers have implemented dialogs that appear before these\noperating system UIs. These dialogs vary based on your WebAuthn server\nsettings (especially for authenticatorAttachment). Consider the following\ncross-device (and simultaneously cross-platform) example where you want to use\nan Android to log into a MacBook. Besides, hardware security keys (e.g.\nYubiKeys) could be used. Therefore, we define the following WebAuthn server\nsettings:\n\n    \n    \n    \"authenticatorSelection\": { \"residentKey\": \"required\", \"requireResidentKey\": true, \"userVerification\": \"required\", \"authenticatorAttachment\": \"platform\" }\n\nThe user interfaces vary significantly for these WebAuthn server settings, as\nillustrated in the following screenshots. For example, Safari (first\nscreenshot) streamlines the process of creating passkeys by presenting a clear\npath, with a subtle hint for additional options at the bottom. Consequently,\nmost users are likely to use Touch ID right away to proceed.\n\nIn contrast, Chrome (second screenshot) displays a dialog that might be\ncomplex to understand for inexperienced users, as you can decide between\n\u201ciCloud Keychain\u201d (the first-party passkey provider), \u201cS21 von Vincent\u201d (a\nstored device), \u201cOther smartphone, other table or other security key\u201d (CDA or\nhardware security key) or \u201cMy Chrome Profile\u201d. On top of that, there\u2019s a\nbutton on the bottom left to \u201cManage Devices\u201d which even increases number of\nclickable options for the user. Where should a non-technical user click to log\nin the most seamless way?\n\nWhen building your passkey experience, all different browsers as well as all\noperating systems and platforms have to be kept in mind. Most importantly, you\nneed to also take operating systems and browsers into consideration that do\nnot (fully) support passkeys (e.g. Linux, ChromeOS and older versions of\nFirefox).\n\nMoreover, one might expect that browser support for passkeys will increase\nover time, leading many current problems to resolve naturally. However, what\nwe have witnessed is somewhat different. While most users (depending on their\ndevices and technical savviness) will see improvements, support must also\ncontinue for those using older browsers on outdated devices. This situation\nonly complicates things, as newer versions introduce advanced passkey\nfeatures. Still, the most crucial aspect is ensuring that every user enjoys a\nsuperior login experience with passkeys compared to traditional password-based\nmethods.\n\n## #11 Passkeys\u2019 Availability Equals Accessibility\n\nPasskeys are supported by Apple, Google and Microsoft. So, no matter which\ndevice I use, I should be able to use them for logins.\n\nThat\u2019s only the half truth. Passkeys are widely adopted by the most popular\noperating systems and browser (mainly due the backing by Apple, Google &\nMicrosoft that control devices, operating systems and browsers).\n\nHowever, this universal availability and support does not mean that during an\nauthentication event, you can simply look up public keys of passkeys in the\ndatabase. It\u2019s a two-side detection that needs to happen during each login\nevent, as each login event depends on the registered passkeys and used device.\nThe following two questions are posed during each login:\n\n  * Are passkeys and / or CDA supported?: Does the device itself support passkey authentication? If not, does it support WebAuthn Cross-Device Authentication (CDA) via QR codes & Bluetooth?\n  * Are passkeys available?: Does the user trying to log in possess any passkeys? If yes, can these passkeys be used in Cross-Device Authentication (e.g. they might be stored on a mobile device only)? Are these passkeys synced in some form (e.g., from an iPhone to a Macbook via iCloud Keychain, or from Macbook to Windows desktop via a password manager like Dashlane)?\n\nPasskeys are considered truly available and accessible only if there's a match\nin both aspects: the device is passkey-ready and passkeys are available. Only\nthen, passkey login can be possible. This is what passkey intelligence is for:\nIt combines all available information for passkey decisions and is built on\ntop of any WebAuthn server / client library.\n\n## #12 QR Codes are Simple and Appear only When Needed\n\nThe passkey login via QR code looks a like a great and user-friendly way to\nfacilitate authentication across-devices. Most users should be able to\nunderstand and use it.\n\nYes and no. While Cross-Device Authentication (CDA) and registration with QR\ncodes can be incredibly effective and powerful tools when used correctly,\nthere is also a significant downside: QR codes often appear when the browser\ncannot find the passkeys (on the device) that the server has suggested in the\nallowCredentials list of the PublicKeyCredentialRequestOptions. If the\npasskeys are not found on the local device, the browser assumes they might\nexist on an another mobile device, potentially available for cross-device\nauthentication. This assumption can lead to UX surprises with QR codes:\n\nThe problem is: The user has no idea what to do in case they don\u2019t have a\npasskey available. They might scan the QR code and then get this cryptic popup\non their smartphone.\n\nWe have listed over 40 of the combinations of WebAuthn\nPublicKeyCredentialRequestOptions, operating systems (+ versions) and browsers\n(+versions) here for you. A summary of the different browser behavior can be\nfound below:\n\nOn older Windows versions, the popups / screen, a user might face, can be even\nmore confusing when the device / browser does not support passkeys. See the\nfollowing screenshot from an authentication process with Windows 10 (21H2;\nnot-passkeys-ready) on Chrome. This might be case not to neglect, as Windows\ncontinues to account for the vast majority of the desktop device market share:\n\nThis demonstrates the importance of passkey intelligence in order to avoid\nunusable QR codes and other confusing screens resulting from passkey logins\nthat should have been avoided (see #11).\n\n## #13 Passkeys Are Universal and Thus Easily Testable\n\nNice, passkeys are available on most devices. That should also make testing\nnot a big deal.\n\nWell, that\u2019s not the full story. Passkeys are great as they introduce the\nfirst phishing-resistant auth method, that is also user-friendly. They can\nonly be used on the domain where they have been created for. This is great in\nreal-life, but makes development and testing of passkey-based applications\npainful:\n\n  * Secure context (https) required for all systems: Passkeys only work in secure contexts (https is required). This also implies that all testing and staging systems need to be set up to work with https.\n  * Local testing is complex: Local testing of passkeys (localhost) is possible and the only exception to the secure context requirement. The thing is that usually, you want to test your passkey-based app from different, real-life operating system / browser combinations. Especially if cross-device authentication is involved, the entire local test setup presents a significant challenge, as local web applications are often not reachable from other devices than the device they are being developed on. Using a local IP address, if you are in the same Wi-Fi, is no option, as Relying Party IDs cannot be IP addresses, but need to be domains. Also setting up a tunnel or using a service like ngrok might be only short-term solution. Each time you get a new ngrok URL, you need to change the Relying Party ID in your WebAuthn server settings.\n  * Authenticator performance decreases with number of test credentials: Testing typically involves setting up passkeys on authenticators and frequently re-registering them, whether it\u2019s because you've flushed the database, changed the Relying Party ID, or simply wish to conduct multiple tests of the passkey creation process. One issue is that some authenticators, especially on Windows, tend to slow down as the number of passkeys they need to handle increases (e.g., 200+).\n  * Debugging is cumbersome: To properly debug your backend, you typically need a set of custom-developed tools that parse and decode details and properties of passkeys. These tools help investigate issues with your passkey intelligence, such as decoding WebAuthn challenges in Base64URL, decoding public keys in COSE format, or deserializing authenticatorData information in CBOR.\n  * Native app testing requires a publicly reachable server: If you develop for a native app (e.g. iOS or Android), new things become important during testing. You need to have the apple-app-site-association file or the assetlinks.json file hosted on a server and this association file needs to be reachable by Apple and Google (to check its validity). This implies that only having a local relying party server is no option (contrary to web apps where this would suffice). Plus, things become even more complex when you want to test a scenario with a web app and native app that should share the same passkeys (thus needing to have the same relying party ID).\n\nWhile many libraries and code snippets support basic WebAuthn server\nimplementation and client-side functionality, there is a notable lack of\ndocumentation for real-life use cases such as Cross-Device Authentication,\nend-to-end passkey testing, or general passkey debugging.\n\n## #14 Only Adding Passkeys to an Existing Auth Solution is Easy\n\nOkay, I understand that designing and implementing a full-fledged passkey-\nfirst authentication solution might be tricky, but simply adding passkey as an\nauthentication option to our current auth solution should be a lot easier.\n\nThat\u2019s sadly not the full story. From what we have experienced with existing\napps that already have larger user bases, avoiding friction in any kind and\noffering a seamless passkeys experience are even more important than in to-be-\nbuilt apps. Here, it\u2019s crucial to provide an easy-to-understand onboarding to\npasskeys and avoid friction to today\u2019s authentication process at any cost. To\nfulfil these requirements, there is usually a ton of additional things to\ndevelop that are no fun and will distract you from actually building your core\nproduct features. The following things need to be built or adapted:\n\n  * Adapt the passkey intelligence to fit current database fields and login flows: All issues when developing your passkey intelligence also apply to the case of simply plugging passkeys into existing authentication flows. It can sometimes be even more complicated when existing fields for password-based authentication need to remain as they are. That\u2019s going to be particularly interesting in the case of autofill, where password and passkey autofill may be used concurrently (Conditional UI can facilitate the process but sometimes it does not work or email fields are autofilled via LocalStorage).\n  * Gradual device-, user- or cohort-based rollout: Product managers usually want to gradually start their passkey rollout and provide users the possibility to opt in to passkeys. The \u201cDo you want to add a passkey\u201d popup becomes the center of attention and developers will face questions from the product department like:\n\n    * What is the take-rate for passkeys?\n    * Can we start by only deploying passkeys to internal users (based on our domains or our company office IP address) before making it available to other user groups?\n    * Can we quickly switch passkey logins off in case of unforeseen events?\n    * Can we start only with certain devices (e.g. only MacBooks & iPhones), as they are in a more or less closed ecosystem and have high passkey-readiness?\n    * What are the auth funnel metrics of passkeys and how much better are they than today\u2019s authentication?\n    * Can we easily add custom rules to exclude certain browser and operating system combinations from passkey authentication if we encounter a problem with them?\n  * Audit logging & KPI reporting: The aspects mentioned above are usually not exhaustive. Once the initial launch is successfully completed, the product team requires KPIs for various purposes, and the IT security / compliance team needs logs for auditing purposes. From product-side, the following KPIs are among the most-requested ones:\n\n    * How fast are passkey logins attempts (especially compared to the password-based auth)?\n    * How many Conditional UI logins do we have?\n    * What errors are my users facing?\n    * Are potential errors originating from the backend or the frontend / JavaScript?\n\nThe more users there are, the more additional features \u2013 such as gradual\nrollout, logging, analytics, and reporting \u2013 are needed to control risk.\nImplementing these features in mature systems is no fun for developers due to\nthe significant additional overhead (remember you just wanted to add passkeys\nto the product?).\n\n## #15 Please Help Me: I Think I Don\u2019t Want Passkeys Anymore\n\nOkay, after reading the article, I think I\u2019ll stick with my current password-\nbased auth solution and do not implement passkeys, as it seems like too much\nimplementation work.\n\nWe understand the challenges that come with rapidly evolving technology and\nthe introduction of new features. However, rest assured, we've got your back.\nPasskeys are set to become the most popular login method shortly. Once\nconsumers experience the speed and simplicity of using passkeys, there\u2019s no\nturning back. The demand for passkeys and biometric authentication is only\nexpected to grow as more people realize their immediate benefits (refer to the\nGoogle Trends screenshot below\u2014the significant spike occurred when Google made\npasskeys the default login method for all their accounts in May 2023). We\noften joke that passkeys are like a drug \u2013 once you've experienced them, you\ndon't want to go back to using passwords.\n\nMoreover, most consumers cannot tell the difference between websites/apps\nsecured with local biometric authentication (e.g., Face ID) and those\nprotected with passkeys (when explaining passkeys to friends, no matter how\ntechnical their background, they often mention that this isn\u2019t a new feature\nbecause their iCloud Keychain has had such a biometric feature to log them in\nautomatically on websites and apps for several years). We have to admit: both\nmethods \u2013 passkeys and local biometric authentication \u2013 are similar and\ninstinctively natural to users. That\u2019s also why we strongly believe that it's\nonly a matter of time before companies without passkey capabilities will seem\noutdated. Just think of:\n\n  * Stationary shops that don't support Apple / Google Pay\n  * People using SMS instead of messenger apps like WhatsApp or Telegram\n  * People unlocking their smartphone with a password instead of biometrics / PIN pattern\n\nUltimately, consumers drive market changes, and they are clearly signaling\nthat passkeys are the future.\n\nImplementing passkeys is hard. The devil is in the unknown unknowns. What\nmight initially seem like a simple one sprint task could escalate into a major\nimplementation project if you aim to fully leverage all the benefits of\npasskeys.\n\nTo help address this challenge at scale, we want to help all developers in\nimplementing passkeys quickly and for free with our community plan. Our\ncomponents and SDKs are easy to integrate and customizable, enabling you to\nprovide your users with the most secure and most convenient login. If you\u2019re\ninterested, you can get started here. Feel free to also join our Passkeys\nCommunity or subscribe to our Passkeys Substack. Let\u2019s make the Internet a\nsafer place together!\n\n## Bonus #1: Prepare Your Setup\n\nTo help you get a set of devices needed to properly test your self-built\npasskey authentication solution, we have compiled a list of devices that we\nuse for internal testing. Trust us, using BrowserStack and other emulators\nworks only to a certain extent:\n\n  1. PC with Windows 10 (where Bluetooth can be switched on and off)\n  2. PC with Windows 11 (21H2)\n  3. PC with Windows 11 (22H2+)\n  4. MacBook with macOS <=12 (Monterey or older)\n  5. MacBook with macOS 13+ (Ventura or newer; but not with version 13.6.5 where passkey auth is broken)\n  6. Android with Android <=8 (Oreo or older)\n  7. Android with Android 9+ (Pie or newer)\n  8. iPhone with iOS <=15\n  9. iPhone with iOS 16+\n\nMoreover, the following resources are required or useful in your passkey\ndevelopment efforts:\n\n  * WebAuthn Server: See our guide for finding your WebAuthn server here (also this WebAuthn server needs to be reachable during your local development, so you need a tunnel or tool like ngrok - with all the fun that comes with local relying party IDs)\n  * Database Schema: See our introduction guide on databases here.\n  * Passkeys Cheat Sheet: Speed up your development with the most important passkey / WebAuthn know-how from the specification including examples.\n  * WebAuthn Virtual Authenticator: Browser dev tool to simulate passkey / WebAuthn sign-ups and logins and save time / resources for real authenticators.\n  * End-2-End Testing Framework: See here how we do it.\n  * Unit Test Set for Passkey Intelligence: The test set should cover most use cases (probably at least 50). A good start point is the compatibility matrix from passkeys.dev\n\n## Bonus #2: Passkeys are Only Authentication but You Need More\n\nSo far, we have only described the considerations you need to address when\nimplementing passkeys. However, passkeys represent just one authentication\noption in modern systems. In real-life scenarios, to truly leverage most of\nthe value of passkeys, there are additional things you need to implement,\nwhich can complicate matters.\n\n  * Combine passkeys with other auth methods: Depending on your requirements, you might need to provide other auth options (e.g. passwords, OTPs via email / SMS, TOTP, social logins) \u2013 be it as fallback or as an adequate alternative the user can choose from. Specifically, in the context of B2B enterprise software, there might the requirement to integrate SSO / SAML along passkeys, which could be another major endeavor.\n  * Add secure and efficient session management: Authentication using passkeys is the initial step, but to avoid requiring users to re-authenticate at every page load, you need to implement session management. This is a complex field in itself, with various approaches, such as decentralized JWTs versus centrally-stored sessions.\n  * Introduce authorization, roles & permissions: Anyone who needs authentication and works in enterprise workforce contexts will soon also require authorization. It's essential to provide your users with roles and different permissions. Additionally, please familiarize yourself with prominent concepts like Role-Based Access Control (RBAC) and Attribute-Based Access Control (ABAC).\n\n# Enjoyed this read?\n\n### \ud83e\udd1d Join our passkeys community\n\nBest place to share passkeys implementation tips and get support to free the\nworld from passwords.\n\nJoin for free\n\n### \ud83d\ude80 Stay up to date\n\nGet the latest news, strategies, and insights about passkeys sent straight to\nyour inbox.\n\nSubscribe for free\n\nWe provide UI components, SDKs and guides to help you add passkeys to your app\nin <1 hour\n\n### Start for free\n\n# Recent Articles\n\nIndustry\n\n### #1 Developer Tool of the Week @ Product Hunt: How we did it\n\nLukas R. - February 26, 2024\n\nPasskeys\n\n### September 2023 Update & Insights into Passkey-Readiness\n\nVincent - September 1, 2023\n\nImplementation\n\n### Passkeys E2E Playwright Testing via WebAuthn Virtual Authenticator\n\nAnders - March 30, 2024\n\nImplementation\n\n### Passkeys Cheat Sheet for Developers\n\nLukas R. - March 6, 2024\n\nIndustry\n\n### NIST Passkeys: Synced Passkeys Recognized as AAL2-Compliant\n\nVincent - April 24, 2024\n\nPasskeys\n\n### WebAuthn Cross-Device-Authentication: Passkeys via Mobile-First Strategy\n\nVincent - April 9, 2024\n\n### contact@corbado.com\n\n### +49 (0) 89 2441 8235\n\n## Product\n\n  * Overview\n  * Pricing\n  * Corbado Complete\n  * Corbado Connect\n  * Passkeys\n  * Passkeys Analyzer\n  * Email Magic Links\n  * SMS OTP\n  * Session Management\n  * WebAuthn\n\n## Developer\n\n  * Quickstart\n  * Docs\n  * Community\n  * FAQ\n  * Status\n  * API Reference\n  * Changelog\n  * Support\n\n## Resources\n\n  * Blog\n  * Why Corbado?\n  * About Us\n  * Contact Us\n  * Jobs\n  * Corbado vs. Auth0\n  * Glossary\n\nImprintTerms of ServicePrivacy Policy\n\n### \u00a9 2024 Corbado GmbH\n\n", "frontpage": false}
