{"aid": "40050655", "title": "A Debugging Framework", "url": "https://addyo.substack.com/p/the-debuggers-toolkit", "domain": "addyo.substack.com", "votes": 1, "user": "asachanfbd", "posted_at": "2024-04-16 11:19:13", "comments": 0, "source_title": "The Debugger's Toolkit", "source_text": "The Debugger's Toolkit - by Addy Osmani - Elevate\n\nShare this post\n\n#### The Debugger's Toolkit\n\naddyo.substack.com\n\n#### Discover more from Elevate\n\nAddy Osmani's newsletter on elevating your effectiveness. Join his community\nof 600,000 readers across social media.\n\nOver 10,000 subscribers\n\nContinue reading\n\nSign in\n\n# The Debugger's Toolkit\n\n### Understanding the thoughtful art of debugging code\n\nAddy Osmani\n\nApr 09, 2024\n\n31\n\nShare this post\n\n#### The Debugger's Toolkit\n\naddyo.substack.com\n\nShare\n\nDebugging is an essential skill for any programmer, yet it remains somewhat of\na mysterious art. Some developers seem to have an uncanny knack for tracking\ndown bugs quickly, while others struggle with even basic issues. What\nseparates the debugging wizards from the debugging novices?\n\nI have observed some common traits and techniques of master debuggers through\nour work on Chrome DevTools. The central theme is having a systematic,\nthoughtful approach rather than haphazardly tweaking code. Let's explore some\nkey principles.\n\nElevate is a reader-supported publication. To receive new posts and support my\nwork, consider becoming a free or paid subscriber.\n\n##\n\nUnderstand the system\n\nBuild a robust mental model first.\n\nBefore attempting to diagnose a bug, it's crucial to solidly understand how\nthe overall system and specific subsystem are supposed to work.\n\nRead the documentation, study the architecture diagrams, step through the\ncode, and experiment with normal operation.\n\nWhen a bug is reported, your mental model is apparently flawed or incomplete\nin some way. Approach the debugging process as a way to find those flaws and\ncorrect your understanding. Which of your assumptions might be invalid?\n\n##\n\nReproduce the issue and isolate it\n\nGet a consistent reproduction of the problem.\n\nOnce you can make the bug happen on demand, you gain a tighter debugging loop\nand clearer insights into the failure conditions. Create a minimal test case\nif possible.\n\nWith a reproducible test case, your next goal is to isolate the issue through\na process of elimination. Methodically remove or disable components and\nobserve the results. Use a binary search strategy - if the bug still occurs,\nthe problem is in the remaining half of the system. If it doesn't, the culprit\nwas in the now disabled part.\n\nRepeat until you zero in on a specific line of code.\n\nUnderstand how to reproduce difficult bugs.\n\nFor intermittent or hard-to-reproduce bugs, you can be stuck playing a\nfrustrating guessing game. That's why it's worth investing significant effort\nup front to get a reproducible test case before attempting to fix anything.\nResist the temptation to start blindly tweaking code in the hopes of stumbling\nupon a fix.\n\nThe hardest bugs to solve are where nothing seems to happen at all. When you\nexpect the program to do X but instead it just sits there silently, you don't\neven have a starting point for your investigation.\n\nIn these cases, it's crucial to identify the code paths that should have been\nexecuted and sprinkle them with debug logging to trace the program's journey.\nOften you will find it is aborting early or taking an unexpected detour.\nKnowing what didn't happen can be just as informative as knowing what did.\n\n##\n\nForm and test hypotheses\n\nDefine a few ideas for \u201cwhy\u201d the bug happens.\n\nAs you gather clues and study the code and system, you should be forming\nhypotheses about potential root causes. Make them as specific as possible, to\nthe level of \"the bug happens because X does Y incorrectly due to Z.\"\n\nThen systematically test each of those hypotheses. Study the relevant code\npaths and add targeted logging to expose the actual behavior. If the data\nmatches your expectation, the hypothesis was incorrect; move on to the next.\n\nIf it differs, you are likely on the right track; drill down further until you\ncompletely understand the issue.\n\n##\n\nCompare to known good\n\nWhen and did the system last work correctly?\n\nAn underutilized debugging technique is finding a similar area of the code\nthat doesn't have the bug and comparing the two implementations.\n\nOften this will highlight an assumption, initialization, or edge case that is\nbeing handled correctly in one place but not the other.\n\nThis same principle applies to debugging across time as well as space. If a\nbug was newly introduced, comparing the current code to the last known good\nversion (typically found through version control annotations/blame) will\nreveal the problematic changes.\n\n##\n\nInstrument, log and visualize\n\nInstrument enough data to diagnose root causes.\n\nInstrumentation is key to capturing enough information to diagnose the\nproblem. Think carefully about what data is needed and add targeted logging,\nideally in a structured format that can be easily queried.\n\nIn addition to obvious things like error conditions and exception stack\ntraces, consider logging overall request flow and key decision points in the\ncode.\n\nSometimes translating the log data into visual form can make patterns pop out.\nPlot variables over time, render activity as rows on a waterfall chart, or\npipe the data into a visualization tool to explore graphically.\n\nLearn about pitfalls experienced developers fall into.\n\nThe first is the tendency to play guessing games instead of systematically\ninstrumenting the code and walking through the problem step-by-step. It's\nnatural to have hunches about where the bug might lie based on past experience\nor code familiarity. Checking those hunches is a fine starting point.\n\nBut if those initial guesses don't pan out after a quick investigation, it's\ncrucial to shift into a more methodical approach. Add logging statements or\nbreakpoints to trace the actual code paths being executed. Inspect the program\nstate at each step to validate your assumptions about what should be\nhappening. Let the evidence guide your debugging rather than just taking shots\nin the dark.\n\nThe second trap is finding a bug and immediately assuming it is the root cause\nyou were seeking. In complex systems, many different errors can often produce\nthe same visible symptoms. Smart developers are especially prone to this as\nthey are quick to recognize faults. But that very first bug you find is often\njust a domino knocked over by the real culprit upstream. Don't declare victory\nprematurely.\n\nUntil you can fully explain the mechanism by which that fault creates the\nobserved problem, keep digging. Make sure the fix actually resolves the\noriginal issue before closing the case.\n\n##\n\nCollaborate and rubber duck\n\nAsk for help if you need it. Talk through the problem.\n\nEven the best programmers sometimes get stuck on a gnarly issue. There is no\nshame in asking for help. In fact, often the mere act of explaining the\nproblem to another person (or even a rubber duck) can trigger an \"aha\" moment\nas you are forced to verbalize your assumptions and reasoning.\n\nDebugging complex systems is fundamentally a collaborative act. Different\npeople have domain expertise in different parts of the codebase or technology\nstack.\n\nInvolving someone with deep knowledge in a particular area can dramatically\naccelerate the process. And sometimes fresh eyes can spot something that\nsomeone too close to the issue glossed over.\n\n##\n\nTake breaks and leverage the subconscious\n\nSometimes stepping away briefly is the best debugging technique.\n\nWhen stumped by a tricky bug, learn to recognize the point of diminishing\nreturns. Continuing to stare at the same code for hours frequently just leads\nto frustration. Sometimes the most productive thing to do is walk away and\ntake a break.\n\nThe subconscious mind is amazingly powerful at working on problems in the\nbackground. Go for a walk, take a shower, sleep on it.\n\nVery often the solution will suddenly pop into your head when you are doing\nsomething unrelated. Never underestimate the power of putting your brain into\ndiffuse mode.\n\n##\n\nLearn and share\n\nFinally, don't let the knowledge gained from each debugging session evaporate.\nTake a few minutes to document the problem and solution, both for your future\nself and for other team members who may encounter something similar. Consider\ncontributing to the company knowledge base or even writing up a public blog\npost.\n\nEach bug is an opportunity not just to fix an immediate issue but to deepen\nyour understanding of the system and expand your debugging toolbox. Embrace\nthe challenges and over time you will develop the skills and instincts of a\ndebugging master.\n\n##\n\nEmbrace modern debugging tools\n\n####\n\nUnderstand your \u201cfull\u201d debugging toolkit\n\nMany developers rely solely on ad hoc print/log statements for debugging.\nWhile that can be useful, it is extremely low leverage compared to using\npowerful debugging tools. Modern IDEs offer visual debuggers, conditional\nbreakpoints, expression evaluation, and even time travel features like reverse\nexecution.\n\nThese tools allow you to inspect the full program state at any point, not just\nwhatever you thought to output in a log message. You can set a breakpoint deep\nin a failing code path and then explore backwards to see how it arrived in\nthat state. You can modify variables and re-execute code to test fixes.\n\nMaster debuggers use these advanced tools to accelerate their workflow and\ngain insights not easily available through print statements alone. And for\nmultithreaded and asynchronous code, a visual representation of thread\ninteractions can be invaluable for detecting race conditions and deadlocks\nthat are otherwise maddeningly difficult to diagnose.\n\n####\n\nAI-Assisted Debugging\n\nIn recent years, the emergence of large language models and AI coding\nassistants has opened up new possibilities in debugging. Tools like ChatGPT,\nGemini, Anthropic's Claude, and GitHub Copilot can serve as a pair-programmer\nin understanding code, generating explanations and even suggesting fixes.\n\nFor example, when puzzling over a particular error message or inscrutable line\nof code, you can paste it into ChatGPT and ask for an explanation in plain\nEnglish. The model can provide context on what the code is doing, explain\narcane error messages, and even show examples of how to use a particular API\ncorrectly.\n\nGoing a step further, you can ask the AI to suggest what might be causing a\nparticular bug based on a description of the symptoms. While it may not always\nguess correctly, it can often point you in a promising direction or suggest\nthings to check. It's like having an extra set of eyes and a research\nassistant at your fingertips.\n\nWhere these AI tools may shine is in their ability to generate code. If you\nhave a hunch about how to fix a bug but are fuzzy on the exact syntax or API\ncalls required, you can ask a tool to write the code for you based on a\nnatural language description or code comment. They can auto-complete entire\nfunctions or suggest alternative implementations.\n\nOf course, you shouldn't blindly accept the AI's suggestions. It's crucial to\nunderstand and test any generated code. But used judiciously, AI can help you\narrive at a correct fix faster, or at least provide a starting point that you\ncan tweak and adapt.\n\nSome caveats and best practices when using AI for debugging:\n\n  * Be specific in your queries. The more context you can provide about what the code does and what problem you are seeing, the more relevant the AI's responses will be.\n\n  * Paste in the full error message and any relevant code snippets. Don't make the AI guess based on a vague description.\n\n  * Critically evaluate any suggested fixes or explanations. The AI can hallucinate or make mistakes, especially on niche topics or bleeding edge technologies. Trust but verify.\n\n  * Use the AI as an augmentation of your own debugging skills, not a complete replacement. The goal is to leverage it for quick answers and suggestions when you are stuck, not to blindly defer to it.\n\n  * Be mindful of security and IP concerns. Don't paste sensitive code or data into public AI models. If in doubt, use an in-house or private instance.\n\n##\n\nComplex debugging scenarios require care\n\nWhile the general principles of debugging apply across a wide range of\nsituations, some bugs pose extra challenges that require additional strategies\nand mindset shifts.\n\nHeisenbugs are notoriously difficult to pin down because any attempt to\nobserve them can alter the system's behavior enough to mask the issue.\n\nSymptoms that only manifest under precise timing or resource constraints can\ndisappear when you add instrumentation or attach a debugger. In these cases,\nyou may need to resort to non-invasive logging or capturing and replaying\nprogram state to diagnose the problem without disrupting it.\n\nBugs where the expected behavior simply doesn't occur can be even more\nperplexing than those that produce a visible error.\n\nYou don't have an obvious starting point for your investigation. When nothing\nhappens, it's crucial to proactively log key decision points and code paths.\nThese debug logs become your trail of breadcrumbs to trace the program's\njourney and identify the point where it deviated from the expected route.\n\nBeware the temptation of debugging by superstition - making a guess, poking\naround, and latching onto the first bug you find as the presumed culprit.\n\nWhile intuition can be a helpful guide, it's not a substitute for validating\nyour hypothesis. Always circle back to the original failure mode and confirm\nthat your proposed fix actually resolves the reported symptoms. Resist the\nsiren song of the \"aha!\" moment until you've tied the cause directly to the\neffect.\n\nWhen facing an intractable bug in a complex system, debugging by bisection can\nbe a powerful technique.\n\nBy repeatedly removing or simplifying components and checking if the problem\npersists, you can progressively narrow the search space. This systematic\nprocess of elimination is more reliable than flailing around based on hunches.\n\nFor codebases or environments with immature debugging tooling, the most\nvaluable skill is the ability to systematically debug with nothing more than\nwell-placed logging statements.\n\nWhile modern debuggers and profilers are incredibly helpful, debugging mastery\nis more about the process than the tools. Hone your ability to hypothesize,\nisolate, and step through code paths mentally. Those skills will serve you\nwell in any environment.\n\nFinally, don't underestimate the impact of attitude and ego on debugging\neffectiveness.\n\nOverconfidence can lead you to overlook subtle clues, stubbornness can blind\nyou to alternative explanations, and an unwillingness to question assumptions\ncan send you down fruitless rabbit holes. Approach debugging with a spirit of\nhumility, open-mindedness, and persistence. Remember that every bug is an\nopportunity to refine your mental model, not a personal affront to your\nskills.\n\n##\n\nConclusion\n\nDebugging complex issues is as much art as science. Arm yourself with the\nright techniques, the right tools, and the right mindset, and you'll be well-\nequipped to tackle even the most insidious bugs.\n\nAnd always remember the wise words of Sherlock Holmes: \"When you have\neliminated the impossible, whatever remains, however improbable, must be the\ntruth.\" Happy hunting!\n\n##\n\nRead more\n\n  * What a good debugger can do\n\n  * The unreasonable effectiveness of print debugging\n\n  * A collection of debugging stories\n\n##\n\nMy other work\n\nIf you enjoy my writing, you may be interested in one of the recent books I\u2019ve\npublished on topics I\u2019m passionate about. These include \u201cSuccess at scale\u201d\n(case studies from the world\u2019s biggest apps), \u201cBuilding large-scale web apps\u201d\n(a React field guide) or \u201cDeveloper Experience\u201d. Enjoy reading whatever form\nit may take \ud83d\ude4f\n\nElevate is a reader-supported publication. To receive new posts and support my\nwork, consider becoming a free or paid subscriber.\n\n31 Likes\n\n\u00b7\n\n4 Restacks\n\n31\n\nShare this post\n\n#### The Debugger's Toolkit\n\naddyo.substack.com\n\nShare\n\nComments\n\nSoft Skills books for developers\n\nInsights and recommendations from 40+ books I read\n\nDec 26, 2023 \u2022\n\nAddy Osmani\n\n97\n\nShare this post\n\n#### Soft Skills books for developers\n\naddyo.substack.com\n\n9\n\nStick to boring architecture for as long as possible.\n\nDon't get lost in the tech; keep your sight fixed on the value created.\n\nFeb 19 \u2022\n\nAddy Osmani\n\n85\n\nShare this post\n\n#### Stick to boring architecture for as long as possible.\n\naddyo.substack.com\n\n4\n\nLeading Effective Engineering Teams\n\nWhat are the most important dynamics for an effective team?\n\nJan 18 \u2022\n\nAddy Osmani\n\n54\n\nShare this post\n\n#### Leading Effective Engineering Teams\n\naddyo.substack.com\n\n2\n\nReady for more?\n\n\u00a9 2024 Addy Osmani\n\nPrivacy \u2219 Terms \u2219 Collection notice\n\nStart WritingGet the app\n\nSubstack is the home for great culture\n\nShare\n\n## Create your profile\n\n## Only paid subscribers can comment on this post\n\nAlready a paid subscriber? Sign in\n\n#### Check your email\n\nFor your security, we need to re-authenticate you.\n\nClick the link we sent to , or click here to sign in.\n\n", "frontpage": false}
