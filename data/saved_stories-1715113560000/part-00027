{"aid": "40284937", "title": "DOS Directory Searches Are Bizarre", "url": "http://www.os2museum.com/wp/learn-something-old-every-day-part-xi-dos-directory-searches-are-bizarre/", "domain": "os2museum.com", "votes": 2, "user": "ingve", "posted_at": "2024-05-07 13:00:03", "comments": 0, "source_title": "Learn Something Old Every Day, Part XI: DOS Directory Searches are Bizarre", "source_text": "Learn Something Old Every Day, Part XI: DOS Directory Searches are Bizarre | OS/2 Museum\n\nOS/2 Museum\n\nOS/2, vintage PC computing, and random musings\n\nSkip to content\n\n  * Home\n  * About\n\n    * Wanted List\n  * OS/2 History\n\n    * OS/2 Beginnings\n    * OS/2 1.0\n    * OS/2 1.1\n    * OS/2 1.2 and 1.3\n    * OS/2 16-bit Server\n    * OS/2 2.0\n    * OS/2 2.1 and 2.11\n    * OS/2 Warp\n    * OS/2 Warp, PowerPC Edition\n    * OS/2 Warp 4\n    * OS/2 Timeline\n    * OS/2 Library\n\n      * OS/2 1.x SDK\n      * OS/2 1.x Programming\n      * OS/2 2.0 Technical Library\n    * OS/2 Videos, 1987\n  * DOS History\n\n    * DOS Beginnings\n    * DOS 1.0 and 1.1\n    * DOS 2.0 and 2.1\n    * DOS 3.0, 3.1, and 3.2\n    * DOS 3.3\n    * DOS 4.0\n    * DOS Library\n  * NetWare History\n\n    * NetWare Timeline\n    * NetWare Library\n  * Windows History\n\n    * Windows Library\n  * PC UNIX History\n\n    * Solaris 2.1 for x86\n\n\u2190 Learn Something Old Every Day, Part X: The VGA Attribute Controller Is Weird\n\n# Learn Something Old Every Day, Part XI: DOS Directory Searches are Bizarre\n\nPosted on May 7, 2024 by Michal Necasek\n\nA while ago I started playing with EMU2, a piece of software which calls\nitself \u201cA simple text-mode x86 + DOS emulator\u201d. It is indeed relatively\nsimple, only emulating an 8086 (or maybe 80186, with little bits of 80286 here\nand there), but it\u2019s in some ways quite capable, doing a remarkably good job\nof running at least some text-mode DOS programs (such as the Turbo Pascal\nIDE).\n\nSpurred by the release of the MS-DOS 4.0 source code, I thought I\u2019d see if I\ncould use EMU2 to build MS-DOS 4.0 on a non-DOS system. It did not go well.\n\nThe MS-DOS 4.0 source BAK includes almost everything needed to build, with the\nexception of COMMAND.COM, which is required by NMAKE to execute certain\ncommands. OK, I thought, let\u2019s just grab an existing MS-DOS 4.0 COMMAND.COM.\n\nNot even a single DIR command worked right. After a bit of tinkering, I got\nthat working, only to find that TREE.COM was hopelessly broken. And I found\nother programs mysteriously failing, such as Watcom wmake (wmaker.exe to be\nexact, since the default 386-extended version has no chance of running under\nEMU2).\n\nIn the process I learned a lot about how DOS directory searches work, and what\nkinds of seemingly crazy things DOS itself does.\n\nLet\u2019s start with DOS 2.x directory searches, using INT 21h/4Eh (Find First)\nand INT 21h/4Fh (Find Next). Find First takes an ASCIIZ string as an input,\noptionally including a path; the file name may include wildcards (asterisks or\nquestion marks).\n\nThe results of the search are stored in the DTA, or Disk Transfer Area, which\nis located at an address set by INT 21h/1Ah. The DTA will contain the name,\nattributes, size, timestamp, etc. of the first search result, if any.\n\nThe DTA notably starts with a 21-byte data area which is undocumented, and\ncontains information required to continue the search. In essence, this area\ncontains information about what the search is looking for (file name with\noptional wildcards, search attributes) and what the current position is in the\ndirectory that is being searched.\n\nThe structure of the information in the first 21 bytes of the DTA differs\nacross DOS versions. It can be also used by emulated DOS environments (such as\nthe OS/2 MVDM) to store information in a format completely different from DOS.\n\n### Case One: Watcom wmake\n\nMy first \u201cpatient\u201d was Watcom wmake. It had trouble finding any files at all\nunder EMU2. I quickly established that it does something that works fine on\nDOS and in most if not all emulated DOS environments, but not in EMU2.\n\nNamely, the Watcom run-time library sets the DTA address (using INT 21h/1Ah),\nand calls Find First (INT 21h/4Eh). Then it copies the first 21 bytes of the\nDTA to a different memory location, sets the DTA address to point at the new\nlocation, and calls Find Next (INT 21h/4Fh).\n\nThis broke down in EMU2 because EMU2 ran the host side search during Find\nFirst, and associated the search with the DTA address. When the Find Next\ncame, the DTA address was different, and EMU2 said, in so many words, oops, I\nhave no idea what you want from me.\n\nSo I tweaked EMU2 to store a unique \u201ccookie\u201d in the DTA, and use that cookie\nwhen locating the corresponding host-side search. That was enough to make\nwmake work.\n\n### Case Two: Microsoft NMAKE\n\nThen I started trying to build the MS-DOS 4.0 source code. As one might\nimagine, NMAKE runs quite a lot of directory searches. And EMU2 started\nfailing because it kept running out of host-side directory searches (the\nmaximum was defined as 64, and it seemed like supporting that many\nsimultaneous searches should be more than enough).\n\nThis problem with searches is one that people have encountered in the past,\nlikely many times. When DOS drives aren\u2019t local FAT-formatted disks, searching\ngets tricky. Often the \u201cserver\u201d (networked or not) needs to keep more\ninformation than fits in the 21-byte area, potentially lots more.\n\nIn the case of EMU2, the host-side search is completed in the Find First call,\nand results are returned on successive Find Next calls. If the directory is\nlarge, there may be quite a bit of data that needs to be kept in memory on the\nhost side.\n\nThe problem is that although DOS has Find First and Find Next calls, it has no\nFind Close call. In other words, searches are started, continued, but not\nended. Or not explicitly.\n\nSolving this problem requires heuristics (especially in light of Case Three).\nIf a DOS program issues Find First with no wildcards, there will be zero or\none result. The search is effectively over by the time Find First finished,\nbecause there will be no further results. Thus the host-side data can be freed\nright away.\n\nWhen a DOS program uses wildcards, things get a lot more complicated. Assuming\nthat the search found multiple results, the host-side information obviously\nneeds to be kept while DOS repeatedly calls Find Next.\n\nThe host-side state can be more or less safely discarded when Find Next\nreaches the end of the search results. In most cases, wildcard searches will\nin fact keep calling Find Next until the results are exhausted. But not\nalways.\n\nA well working solution appears to be a heuristic which more or less\nintelligently decides when searches are completed, combined with some sort of\nLRU approach to discard old searches.\n\n### Case Three: MS-DOS 4.0 TREE.COM\n\nAfter improving the logic discarding host-side search state, I was able to\nbuild most of MS-DOS 4.0 with EMU2. This included TREE.COM. When I tried\nrunning the freshly build TREE utility, bad things happened.\n\nFortunately I had the TREE.COM source code, and I was able to understand what\nwas going on. What TREE does is... interesting. To recap, TREE prints a\n\u201cgraphical\u201d directory tree that looks like this:\n\n    \n    \n    ... \u251c\u2500\u2500\u2500DOS \u251c\u2500\u2500\u2500H \u251c\u2500\u2500\u2500INC \u251c\u2500\u2500\u2500LIB \u251c\u2500\u2500\u2500MAPPER \u251c\u2500\u2500\u2500MEMM \u2502 \u251c\u2500\u2500\u2500EMM \u2502 \u2514\u2500\u2500\u2500MEMM \u251c\u2500\u2500\u2500MESSAGES \u251c\u2500\u2500\u2500SELECT \u2514\u2500\u2500\u2500TOOLS \u2514\u2500\u2500\u2500BLD \u251c\u2500\u2500\u2500INC \u2502 \u2514\u2500\u2500\u2500SYS \u2514\u2500\u2500\u2500LIB\n\nWhen displaying a line of text with another directory item, TREE needs to know\nwhether it should print an I-shape or an L-shape character. An L-shape is\nprinted for the last entry in a directory, and an I-shape is printed for all\nother entries.\n\nAnd here\u2019s where TREE is very tricky, and does something that one might not\nexpect to work at all. For example, when it prints the line for DOS (at the\ntop of the diagram above), it already called Find Next and found the DOS\ndirectory. TREE then saves the DTA contents (those 21 bytes) on its internal\ndirectory stack, and calls Find Next again. In this case, there is another\nresult, the H directory, so TREE prints an I-shape and goes into the DOS\ndirectory to find out if there are any sub-directories.\n\nWhen TREE gets back to where it was (in this case quickly, since no sub-\ndirectories exist), it restores the saved DTA contents and runs Find Next\nagain. And as before, Find Next has to return the H directory as the next\nresult.\n\nIn other words, TREE saves and restores the DTA contents in order to rewind\nthe search to a previous position. Depending on the directory tree depth,\nthere may be a number of simultaneously active searches, each for one level of\nthe directory hierarchy.\n\nUnderstanding the inner workings of TREE.COM necessitated further changes to\nEMU2. The information stored in the DTA needs to include not only an\nidentifier associating the search with host-side state, but also a position in\nthe host side search. That way TREE can successfully return to a previous\nposition.\n\nNote that this does not break the heuristics for freeing host-side state. TREE\nonly ever rewinds the search back by one entry. Thus when Find Next reaches\nthe end of the search results, the host-side state can be discarded. Although\nTREE may rewind the search, it only needs to call Find Next again to see that\nthere are (still) no further results.\n\n### Case Four: MS-DOS 6.0 COMMAND.COM\n\nSince I had the MS-DOS 4.0 COMMAND.COM working reasonably well, I thought the\nCOMMAND.COM from MS-DOS 6.0 would work too.\n\nNot so. The DIR command only returned one result, which necessitated further\ndigging.\n\nFor reasons that aren\u2019t terribly obvious to me, COMMAND.COM uses FCB searches\nto query directory contents. Now, FCB searches work a little differently from\n\u201cnormal\u201d directory searches.\n\nINT 21h/11h (Find First FCB) takes an unopened FCB (File Control Block) as\ninput. The FCB contains the file name (possibly containing wildcards) and\nsearches the current directory. The search results are then stored in the DTA\n(again set by INT 21h/1Ah).\n\nEMU2 originally associated the host-side search state with the DTA address for\nboth FCB and non-FCB searches. While implementing fixes to cases One to Three,\nI saved the search state in the DTA.\n\nBut then I found that MS-DOS 6.0 COMMAND.COM calls Find First FCB, which\nplaces the first search result into the DTA, and then calls INT 21h/47h (Get\nCurrent Directory)... which happens to place the result into the same memory\narea that also holds the DTA.\n\nThis led to a facepalm moment when I read through the MS-DOS 4.0 source code\nin order to understand how FCB searches work. It turned out that the search\ncontinuation information is not placed into the DTA at all, but rather into\nthe unopened FCB that is passed as input to both INT 21h/11h (Find First FCB)\nas well as INT 21h/12h (Find Next FCB). If only I had read the RBIL more\ncarefully, the information was right there.\n\nNot too surprisingly, it turned out that the magic 21-byte search continuation\nstate area is actually the same for FCB and non-FCB searches, and its layout\nis derived from the unopened FCB format, going back to DOS 1.x.\n\nOne way or another, the search continuation area includes the input filename\n(possibly with wildcards) and attributes, to know what it\u2019s looking for. It\nalso needs to contain the cluster number of the directory being searched, as\nwell as position within the directory.\n\n### What\u2019s Reasonable and What Isn\u2019t?\n\nThe design (or lack thereof) of DOS directory searches raises an obvious\nquestion: Just how long are directory searches valid?\n\nThe answer is \u201cas long as the directory being searched remains unmodified\u201d. As\nlong as a DOS process doing the searches has control, it can (but of course\ndoesn\u2019t have to!) ensure that directory contents don\u2019t change. As soon as the\nDOS EXEC call is invoked to start a new process, it can\u2019t be assumed that\ndirectory contents remain static.\n\nIn practice, searches remain valid indefinitely, because DOS makes no effort\nto ensure that directory searches are invalidated even when directory contents\nchange. However, the term \u201cvalid\u201d needs to be understood to mean that Find\nNext can be called, not that Find Next will return sensible data. It is easy\nto imagine a situation when a search is started, the directory is deleted, and\nthe clusters it used to occupy are replaced with completely different data.\nFind Next will then attempt to process random file data as a directory, with\nunpredictable results.\n\nThat\u2019s not even considering a situation when a program modifies the search\ncontinuation information (in the DTA or FCB). DOS has no way of preventing\nthat, but fortunately DOS programs have no incentive to do so.\n\nRedirectors (whatever method they use to interface with DOS) are thus in a\ndifficult situation, because they often need to associate some \u201cserver side\u201d\nstate with a search (necessitated by the fact that the 21-byte search\ncontinuation area is likely not large enough to store all required data in\nit). Since there is no \u201cFind Close\u201d API, redirectors are forced to guess when\na search is done.\n\nAn approach using LRU logic may not be sufficient. When performing recursive\ndirectory searches (such as TREE.COM), a program may start searching the root\ndirectory, descend into a sub-directory, and search hundreds or thousands of\nnested directories before returning back to the top-level directory. The\nsearch of the top-level directory must remain active on the server side the\nentire time, without being discarded.\n\nThat\u2019s where heuristics help, because they greatly reduce the number of open\nsearches, thus making it much more likely that still-active searches won\u2019t be\ninadvertently recycled.\n\nFortunately well behaved DOS programs do not actively try to break such\nheuristics, and although they may do surprising things, the list of such\nsurprises is (probably!) not endless.\n\nThis entry was posted in Development, DOS, Undocumented. Bookmark the\npermalink.\n\n\u2190 Learn Something Old Every Day, Part X: The VGA Attribute Controller Is Weird\n\n### Leave a Reply\n\nThis site uses Akismet to reduce spam. Learn how your comment data is\nprocessed.\n\n  * ### Archives\n\n    * May 2024\n    * April 2024\n    * March 2024\n    * February 2024\n    * January 2024\n    * October 2023\n    * September 2023\n    * August 2023\n    * July 2023\n    * June 2023\n    * May 2023\n    * April 2023\n    * March 2023\n    * January 2023\n    * December 2022\n    * November 2022\n    * October 2022\n    * September 2022\n    * July 2022\n    * June 2022\n    * May 2022\n    * April 2022\n    * March 2022\n    * February 2022\n    * January 2022\n    * December 2021\n    * November 2021\n    * October 2021\n    * September 2021\n    * August 2021\n    * July 2021\n    * June 2021\n    * May 2021\n    * April 2021\n    * March 2021\n    * February 2021\n    * January 2021\n    * December 2020\n    * November 2020\n    * October 2020\n    * September 2020\n    * August 2020\n    * July 2020\n    * June 2020\n    * May 2020\n    * April 2020\n    * March 2020\n    * February 2020\n    * January 2020\n    * December 2019\n    * November 2019\n    * October 2019\n    * September 2019\n    * August 2019\n    * July 2019\n    * June 2019\n    * May 2019\n    * April 2019\n    * March 2019\n    * February 2019\n    * January 2019\n    * December 2018\n    * November 2018\n    * October 2018\n    * August 2018\n    * July 2018\n    * June 2018\n    * May 2018\n    * April 2018\n    * March 2018\n    * February 2018\n    * January 2018\n    * December 2017\n    * November 2017\n    * October 2017\n    * August 2017\n    * July 2017\n    * June 2017\n    * May 2017\n    * April 2017\n    * March 2017\n    * February 2017\n    * January 2017\n    * December 2016\n    * November 2016\n    * October 2016\n    * September 2016\n    * August 2016\n    * July 2016\n    * June 2016\n    * May 2016\n    * April 2016\n    * March 2016\n    * February 2016\n    * January 2016\n    * December 2015\n    * November 2015\n    * October 2015\n    * September 2015\n    * August 2015\n    * July 2015\n    * June 2015\n    * May 2015\n    * April 2015\n    * March 2015\n    * February 2015\n    * January 2015\n    * December 2014\n    * November 2014\n    * October 2014\n    * September 2014\n    * August 2014\n    * July 2014\n    * June 2014\n    * May 2014\n    * April 2014\n    * March 2014\n    * February 2014\n    * January 2014\n    * December 2013\n    * November 2013\n    * October 2013\n    * September 2013\n    * August 2013\n    * July 2013\n    * June 2013\n    * May 2013\n    * April 2013\n    * March 2013\n    * February 2013\n    * January 2013\n    * December 2012\n    * November 2012\n    * October 2012\n    * September 2012\n    * August 2012\n    * July 2012\n    * June 2012\n    * May 2012\n    * April 2012\n    * March 2012\n    * February 2012\n    * January 2012\n    * December 2011\n    * November 2011\n    * October 2011\n    * September 2011\n    * August 2011\n    * July 2011\n    * June 2011\n    * May 2011\n    * April 2011\n    * March 2011\n    * January 2011\n    * November 2010\n    * October 2010\n    * August 2010\n    * July 2010\n\n  * ### Categories\n\n    * 286\n    * 386\n    * 386MAX\n    * 3Com\n    * 3Dfx\n    * 486\n    * 8086/8088\n    * Adaptec\n    * AGP\n    * AMD\n    * AMD64\n    * Apple\n    * Archiving\n    * Assembler\n    * ATi\n    * BIOS\n    * Books\n    * Borland\n    * BSD\n    * Bugs\n    * BusLogic\n    * C\n    * C&T\n    * CD-ROM\n    * Cirrus Logic\n    * CompactFlash\n    * Compaq\n    * Compression\n    * Computing History\n    * Conner\n    * Corrections\n    * CP/M\n    * Creative Labs\n    * Crystal Semi\n    * Cyrix\n    * DDR RAM\n    * Debugging\n    * DEC\n    * Development\n    * Digital Research\n    * Documentation\n    * DOS\n    * DOS Extenders\n    * Dream\n    * E-mu\n    * Editors\n    * EISA\n    * Ensoniq\n    * ESDI\n    * Ethernet\n    * Fakes\n    * Fixes\n    * Floppies\n    * Graphics\n    * Hardware Hacks\n    * I18N\n    * IBM\n    * IDE\n    * Intel\n    * Internet\n    * Keyboard\n    * Kryoflux\n    * Kurzweil\n    * LAN Manager\n    * Legal\n    * Linux\n    * MCA\n    * Microsoft\n    * MIDI\n    * NetWare\n    * Networking\n    * NeXTSTEP\n    * NFS\n    * Novell\n    * NT\n    * OS X\n    * OS/2\n    * PC architecture\n    * PC hardware\n    * PC history\n    * PC press\n    * PCI\n    * PCMCIA\n    * Pentium\n    * Pentium 4\n    * Pentium II\n    * Pentium III\n    * Pentium Pro\n    * Plug and Play\n    * PowerPC\n    * Pre-release\n    * PS/2\n    * QNX\n    * Quantum\n    * Random Thoughts\n    * RDRAM\n    * Roland\n    * Ryzen\n    * S3\n    * SCO\n    * SCSI\n    * Seagate\n    * Security\n    * Site Management\n    * SMP\n    * Software Hacks\n    * Solaris\n    * Sound\n    * Sound Blaster\n    * Source code\n    * Standards\n    * Storage\n    * Supermicro\n    * TCP/IP\n    * ThinkPad\n    * Trident\n    * UltraSound\n    * Uncategorized\n    * Undocumented\n    * UNIX\n    * UnixWare\n    * USB\n    * VGA\n    * VirtualBox\n    * Virtualization\n    * VLB\n    * Watcom\n    * Wave Blaster\n    * Western Digital\n    * Windows\n    * Windows 95\n    * Windows XP\n    * Wireless\n    * WordStar\n    * x86\n    * x87\n    * Xenix\n    * Xeon\n    * Yamaha\n\nOS/2 Museum\n\nProudly powered by WordPress.\n\n", "frontpage": false}
