{"aid": "40112966", "title": "Are aarch64 atomics this sensitive?", "url": "https://eighty-twenty.org/2024/04/22/aarch64-atomics", "domain": "eighty-twenty.org", "votes": 2, "user": "todsacerdoti", "posted_at": "2024-04-22 10:27:51", "comments": 0, "source_title": "Are aarch64 atomics really this sensitive? (eighty-twenty news)", "source_text": "Are aarch64 atomics really this sensitive? (eighty-twenty news)\n\n# eighty-twenty\n\nabout | sitemap\n\n## Are aarch64 atomics really this sensitive?\n\n### Mon 22 Apr 2024 12:00 CEST\n\nTony Garnock-Jones\n\n#guile #tech\n\npermalink\n\nI noticed a bug in Guile 3.0.9\u2019s aarch64 atomics handling, and found a couple\nof apparent solutions (1, 2), but one of them is weird enough for me to write\nthis post.\n\nLong story short, the problem was with the equivalent of C\u2019s atomic_exchange.\nHere\u2019s the code that Guile\u2019s JIT was generating:\n\n    \n    \n    1: mov x16, x0 ldaxr x0, [x1] stlxr w17, x16, [x1] cbnz w17, 1b\n\nThis code appears to occasionally lose writes (!). The first patch I wrote\nboringly replaced the lot with a single\n\n    \n    \n    swpal x0, x0, [x1]\n\nwhich is fine, if you have an ARM v8.1 device to hand, but not if you don\u2019t\nhave a machine with Large System Extensions. So I tried, on a hunch, the\nsecond patch, which just changed the target of the cbnz, producing code like\nthis:\n\n    \n    \n    mov x16, x0 1: ldaxr x0, [x1] stlxr w17, x16, [x1] cbnz w17, 1b\n\n... and the issue disappeared! What! This shouldn\u2019t have made a difference!\nShould it?\n\nAre aarch64 atomics really this sensitive? Is there only One True Instruction\nSequence that should be used to implement atomic_exchange? Why does making\nthis seemingly-insignificant change produce such a noticeable effect?\n\n", "frontpage": false}
