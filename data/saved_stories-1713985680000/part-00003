{"aid": "40143913", "title": "Should You Use Ruby on Rails or Hanami?", "url": "https://blog.appsignal.com/2024/04/24/should-you-use-ruby-on-rails-or-hanami.html", "domain": "appsignal.com", "votes": 5, "user": "amalinovic", "posted_at": "2024-04-24 13:06:58", "comments": 0, "source_title": "Should You Use Ruby on Rails or Hanami? | AppSignal Blog", "source_text": "Should You Use Ruby on Rails or Hanami? | AppSignal Blog\n\n  * Features\n\n### Monitoring features\n\n    * Error tracking\n\n    * Performance monitoring\n\n    * Host monitoring\n\n    * Anomaly detection\n\n    * Uptime monitoring\n\n    * Metric dashboards\n\n    * Workflow\n\n    * Log management\n\n    * Automated Dashboards\n\n  * Languages\n\n### Supported Languages\n\n    * Ruby (on Rails) APM\n\n    * Elixir APM\n\n    * Node.js APM\n\n    * JavaScript Error Tracking\n\n    * Python APM\n\n  * Learn\n  * Docs\n  * Blog\n  * Pricing\n\n  * Login\n  * Start free trial\n\nMenu\n\nruby\n\n# Should You Use Ruby on Rails or Hanami?\n\nAestimo Kirina on Apr 24, 2024\n\nRuby on Rails is the most popular web framework in the Ruby ecosystem and has\na large user base, ranging from freelancers to large established companies.\nWith an active user community and wide-ranging documentation, it can be used\nto build everything from simple applications to complex web platforms.\n\nThat said, a new contestant is taking on Rails\u2019 dominance for the full-stack\nRuby framework title: Hanami. It is a fast, modular Ruby framework with\nimproved performance and maintainability compared to Rails.\n\nIn this article, we'll explore the strengths and weaknesses of each framework\nin terms of performance, features, testing, and more. So whether you are\nlooking to build a customer-facing web app, an internal tool, or a massively\nscalable API, you should leave being better informed about what to use for\nyour next project.\n\nLet's get started with a brief introduction to each framework.\n\n## Introducing Ruby on Rails\n\nRuby on Rails is the most well-known Ruby web application development\nframework with a mission to enhance developer productivity (by making a bunch\nof assumptions about how apps should be built, often referred to as the \"Rails\nway\").\n\nSome of these assumptions include making sure developers do not spend time\nconfiguring stuff, or what is termed as \"convention over configuration\", and\nan emphasis on using DRY (\"don't repeat yourself\") principles. DRY principles\nencourage a developer to avoid repeating code over and over again, but instead\nuse single and focused representations of app functionality to ensure\nmaintainability and organization.\n\n## Introducing Hanami\n\nWhile Rails is very well-known in the Ruby community, Hanami is less so. It's\na fairly new modern Ruby framework trying to take on Rails' dominance of the\nfull-stack web framework space.\n\nHanami is built from the ground up to have a small memory footprint and a\nfocus on modularity, which, in turn, makes for a very fast and nimble\nframework.\n\nObviously, these brief introductions won't really give you all the information\nyou need to decide on the framework that suits you best. For that, we'll need\nto dive deeper into each, starting with how they are structured.\n\n## Structure and Architecture of Rails and Hanami\n\nRails and Hanami are somewhat similar in that both are Ruby frameworks.\nHowever, how each is built and their application architecture is where you'll\nfind most of the differences.\n\nFor starters, with Rails, you have fewer files or abstractions (the building\nblocks you use to build your app), which tend to grow in size as you develop\nyour app. On the other hand, Hanami takes abstractions to a whole new level,\nwith lots of files that tend to be smaller in size.\n\nThe diagrams below illustrate the point more clearly. Let's start with Rails.\n\nNow compare the Rails abstraction diagram with the Hanami one below.\n\nAs you can see, each framework generally follows the model-view-controller\n(MVC) structure. However, Hanami takes abstraction to the next level.\n\nHere's a simplified outline of how each framework is organized:\n\n  * Routes - Each framework has a routes definition with your app's endpoints.\n  * Controllers vs. actions - In Rails, you get controllers with one or a couple of actions in them. Controllers receive and respond to route requests by directing them to the relevant actions. In Hanami, there are no controllers. Instead, you go straight to self-contained actions (each action has its own self-contained class).\n  * Models and persistence - The Rails model layer takes care of data validation and database communication, including any queries your app may have. In Hanami, each of these functionalities is contained in a different part of the persistence layer: data validations are handled by contracts, database communication is done by the repository (repo), while relations and scoping are the responsibility of relations.\n  * View rendering - As with the persistence layer, Ruby on Rails views tend to contain everything you need for rendering data to the outside world in one place. This includes all the HTML structure, view helpers, and view logic. When it comes to view rendering in Hanami, things are more abstract. For starters, you have views that utilize any view helpers the app has and also render the template. The template handles the actual HTML structure, while the parts take care of any presentation logic.\n\nSo, what does all this mean when it comes to building an app? With fewer\nabstractions, Rails is a good choice for getting your app off the ground and\nis more beginner-friendly (as we shall see later on in this article). With\nRails, you can build very robust monolith apps, but your code will get more\nand more complex as you scale. On the other hand, Hanami's more complex\nstructure can be daunting to learn, but it will allow you to build massively\nscalable applications and could make for much better code organization.\n\nNext, let's take a look at each framework's ecosystem.\n\n\u2193 Article continues below\n\n#### Is your app broken or slow? AppSignal lets you know.\n\nMonitoring by AppSignal \u2192\n\n## Ecosystem and Community\n\nAs we mentioned earlier, Rails has a more established framework than Hanami.\nRails has been around for longer and, as such, has a bigger and more mature\ncommunity.\n\nThe differences in ecosystem and community are summarized below:\n\n  * Documentation - It doesn't matter what you're trying to build, if you use Rails, you have access to very well-done documentation. You are guided through all parts of an app build, from authentication, to data persistence, view presentation, and everything in between. Additionally, a wide range of third-party tutorials cover almost everything imaginable in terms of building an application.\n\nThat said, things are not so established on the Hanami side of things. Being a\nrelatively newer framework, Hanami has a comparatively limited documentation\nbase. The Hanami team has done an impressive job with the official guides, but\ncompared to the Rails documentation base, it doesn't come close.\n\n  * Community - Here, as with the documentation, Rails is the clear winner. Rails has been around much longer than Hanami, so it's been adopted the most. It doesn't matter whether you are a beginner or advanced developer, you'll find a Rails community on relevant subreddits, Slack groups, Discords, and so forth. On the other hand, Hanami is still growing, meaning it has a much smaller community.\n  * Gems and libraries - Since both Hanami and Rails are Ruby frameworks, it could be argued that gems that work in Rails will work in Hanami. Although this is technically true, you'll often find that Rails has a more established base of gems and libraries for all sorts of specialized functions.\n\nThat said, because of Hanami's focus on abstractions and specialization, it\nhas some very advanced gems that could take your Rails apps to the next level.\nFor example, the default dry-rb gems in Hanami could bring better code\norganization and abstraction when used in Rails apps.\n\nMoving on, let's compare each framework's learning curve and adoption.\n\n## Ease of Use, Adoption, Governance, and Learning Curve\n\nFor the very reasons outlined in the previous section, Ruby on Rails easily\nbeats Hanami in terms of ease of use, industry adoption, and learning curve,\nspecifically:\n\n  * Learning - Imagine you're a complete beginner who's looking to learn a new programming language. Your very first thought will be to check out online learning resources. If a framework has widely available learning materials covering the app-building process from start to finish, you'll likely choose that language over others. And because Rails has a more established documentation base, it trumps Hanami as the beginner's choice of framework. In addition, Rails is much more friendly for beginners to pick up since it makes so many assumptions under the hood (compared to Hanami, which offers a more abstract way of building apps). Hanami's abstractions can be daunting even for established Rails developers.\n  * Industry adoption - Without including the adoption of other popular and more established frameworks like Python, React, C#, and others, if we consider the adoption of Ruby frameworks, Rails easily eclipses Hanami. The Rails homepage lists some big-name organizations using the framework. On the other hand, as the new kid on the block, Hanami is not so widely adopted. We'll have to wait and see whether that will change in the future.\n  * Job market prospects - In terms of job prospects, you'll find more job openings for Rails developers than Hanami developers.\n  * Governance - Another important aspect that should not be overlooked is governance. A changing landscape guides how open-source frameworks evolve and advance. However, more than that, the core team members of these frameworks often wield immense powers and can dictate what goes into a framework, how it develops, etc.\n\nA good example is January's announcement by David Heinemeier Hansson (DHH),\nthe creator of Rails. He said that, in the future, he would push for Rails to\noffer first-class support for building full-stack progressive web applications\nand native notifications. These features would make Rails very attractive to\nmobile developers.\n\nIn reaction, many developers, some outside the Ruby ecosystem and even others\nwho had dropped Rails over the years, overwhelmingly responded in the\npositive, saying they would gladly pick up the framework or learn it if DHH\nkept his word. This example just goes to show you that governance is a very\nimportant consideration when deciding what framework to pick.\n\nLet's now switch gears and look into something more technical, application\nperformance.\n\n## Performance: Ruby on Rails vs. Hanami\n\nAs a developer, you will be concerned about your app's reliability,\nresponsiveness, and how it will utilize server resources once deployed in\nproduction. These are fundamental concerns that can greatly affect your choice\nof framework.\n\nYou could use many methods to run performance tests on your app, one of the\nmost popular being Apache JMeter. Let's use the benchmark numbers to compare\nHanami and Rails.\n\nHere's a quick benchmark test showing the number of requests each framework\ncan handle per second:\n\nHanami beats Rails hands down, with the ability to handle 3 times more\nrequests than Rails can handle.\n\nThis next screenshot shows the average latency values for each framework:\n\nAgain, Hanami beats Rails with an average latency time that's about 3 times\nshorter.\n\nIf you're looking for a Ruby framework that is blazingly fast (let's say, you\nneed to work on a fast and hugely scalable API), then you'll be hard-pressed\nto find anything better than Hanami in the Ruby landscape.\n\n## Testing\n\nWhen it comes to testing code, both frameworks are very much comparable since\nyou can test either using the versatile RSpec library.\n\nRSpec is included via the hanami-rspec gem for Hanami apps, whereas you need\nto install the rspec-rails gem to use it in your Rails app. The example below\nshows a very basic test spec that is included with your new Hanami app:\n\nruby\n\n    \n    \n    # spec/requests/root_spec.rb RSpec.describe \"Root\", type: :request do it \"is successful\" do get \"/\" expect(last_response).to be_successful expect(last_response.body).to eq(\"Hello from Hanami\") end end\n\nRunning it with $ bundle exec rspec spec/requests/root_spec.rb should result\nin a passing test (assuming you've not edited the default view template):\n\nshell\n\n    \n    \n    . Finished in 0.01812 seconds (files took 0.47734 seconds to load) 1 example, 0 failures\n\nOn the Rails side, you need to handle some things by yourself. Firstly, you\nneed to add the RSpec gem to the development/test block in the Gemfile as\nshown below, then run bundle:\n\nruby\n\n    \n    \n    # Gemfile ... group :development, :test do gem 'rspec-rails' end\n\nThe next step is to run the RSpec install with the command bundle exec rails\ngenerate rspec:install to get it ready for your Rails project.\n\nFinally, before writing and running any tests, you'll likely need to install\nanother gem to define test data for your Rails app: FactoryBot.\n\nAnd assuming you've set up your test suite properly and defined a few tests,\nyou can run a test just as you would in Hanami, with bundle exec rspec\nspec/models/user_spec.rb. You can get your test results just as you would with\na Hanami app:\n\nshell\n\n    \n    \n    Finished in 0.04421 seconds (files took 0.88106 seconds to load) 1 example, 0 failures\n\nFinally, let's see how the frameworks compare when it comes to deployment.\n\n## Deployment\n\nNowadays, there are lots of options for deploying Ruby apps to production.\n\nTo begin with, you could go with a Platform-as-a-Service (PaaS) provider like\nHeroku, or Fly for a more seamless experience. You can also do a bit of\nDevOps: set up a Docker installation on a VPS and deploy your app there.\n\nWhichever option you choose, you can expect deployment to be relatively\nsimilar in both cases. The only caveat is the lack of extensive documentation\nand tutorials for deploying Hanami apps.\n\nAs we pointed out before, being a newer framework, Hanami still doesn't have\nextensive documentation covering the deployment process and the challenges\nthat might crop up. If you don't mind hacking around this, then you should be\nokay.\n\n## Wrapping Up\n\nIn this article, we've looked at two Ruby frameworks \u2014 Ruby on Rails and\nHanami \u2014 comparing them in terms of features, architecture, performance, and\nmore. Ultimately, we have to answer the question: \"Which framework should I\nuse, and why?\". We can summarize as follows:\n\n  * If you're a beginner Ruby developer, start with Rails: it's easier to pick up and learn. If you're a more advanced Ruby developer, develop a Hanami skillset, as it will help you develop even more robust Ruby applications.\n  * If you need to develop an app that should be fast, say an API serving several clients, Hanami's small memory footprint, blazing fast responses, and low latency will serve you well. However, if you just need to develop a monolithic full-stack app to validate a SaaS idea, Rails will definitely get you there faster.\n\nUltimately, what you end up choosing is really up to you. It isn't a bad idea\nto acquire skills in both frameworks. That way, you can decide on the best\nframework to go for, depending on the needs of your project.\n\nHappy coding!\n\nP.S. If you'd like to read Ruby Magic posts as soon as they get off the press,\nsubscribe to our Ruby Magic newsletter and never miss a single post!\n\nP.P.S. Did you know AppSignal has an integration for Rails and Hanami?\n\n# Share this article\n\nRSS\n\n# Aestimo Kirina\n\nOur guest author Aestimo is a full-stack developer, tech writer/author and\nSaaS entrepreneur.\n\nAll articles by Aestimo Kirina\n\nBecome our next author!\n\nFind out more\n\n# Magicians never share their secrets. But we do. Subscribe to our Ruby Magic\nemail series and get in-depth Ruby articles.\n\n# AppSignal monitors your apps\n\nAppSignal provides insights for Ruby, Rails, Elixir, Phoenix, Node.js, Express\nand many other frameworks and libraries. We are located in beautiful\nAmsterdam. We love stroopwafels. If you do too, let us know. We might send you\nsome!\n\nDiscover AppSignal\n\n## Features\n\n  * Error tracking\n\n  * Performance monitoring\n\n  * Host monitoring\n\n  * Anomaly detection\n\n  * Uptime monitoring\n\n  * Metric dashboards\n\n  * Workflow\n\n  * Log management\n\n  * Automated Dashboards\n\n## Resources\n\n  * Plans & pricing\n\n  * Documentation\n\n  * Blog\n\n  * Customer Stories\n\n  * Compare AppSignal to Datadog\n\n  * Compare AppSignal to New Relic\n\n  * Changelog\n\n  * Learning Center\n\n  * Why AppSignal\n\n## Support\n\nDo you need help, have a feature request or just need someone to rubber duck\nwith? Get in touch with one of our engineers.\n\n  * Contact us\n\n  * Live chat\n\n  * Status\n\n  * Security\n\n## About us\n\nAppSignal is located in the beautiful Netherlands. We love stroopwafels. If\nyou do too, let us know. We might send you some!\n\n  * About\n\n  * Jobs\n\n  * Write for Our Blog\n\n  * Diversity\n\n  * Open Source\n\n  * Twitter\n\n## Languages\n\n  * Ruby\n\nActive Record, Capistrano, Delayed::Job, Garbage Collection, Global VM Lock,\nGrape, GraphQL, Hanami, MongoDB, Padrino, Puma, Que, Rake, Resque, Ruby on\nRails, Shoryuken, Sidekiq, Sinatra, Webmachine\n\n  * Elixir\n\nEcto, Erlang, Finch, Oban, Phoenix, Plug\n\n  * Node.js\n\nExpress, Fastify, fs Module, GraphQL, Knex.js, Koa, MongoDB, Mongoose, MySQL,\nNestJS, Next.js, PostgreSQL, Prisma, Redis, Remix, Restify\n\n  * JavaScript\n\nReact, Vue, Angular, Ember, Preact, Stimulus\n\n  * Python\n\nCelery, Django, FastAPI, Flask, Jinja2, Psycopg2, Redis, Request, Starlette,\nWSGI and ASGI\n\n  * Terms & Conditions\n  * Privacy Policy\n  * Cookie Policy\n  * GDPR compliance\n  * Contact us / Imprint\n\n", "frontpage": true}
