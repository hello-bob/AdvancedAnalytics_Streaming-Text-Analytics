{"aid": "40152029", "title": "Ruby might be faster than you think", "url": "https://www.johnhawthorn.com/2024/ruby-might-be-faster-than-you-think/", "domain": "johnhawthorn.com", "votes": 38, "user": "todsacerdoti", "posted_at": "2024-04-25 01:09:40", "comments": 2, "source_title": "Ruby might be faster than you think - John Hawthorn", "source_text": "Ruby might be faster than you think - John Hawthorn\n\nJohn Hawthorn\n\n# Ruby might be faster than you think\n\nI saw a project a couple weeks back which allows writing and running Crystal\nmethods inline inside a Ruby file.\n\nIt\u2019s a neat project, and I don\u2019t want to take away from it but something in\nthe README example looked off to me.\n\nrequire 'crystalruby' require 'benchmark' module Fibonnaci crystalize [n:\n:int32] => :int32 def fib_cr(n) a = 0 b = 1 n.times { a, b = b, a + b } a end\nmodule_function def fib_rb(n) a = 0 b = 1 n.times { a, b = b, a + b } a end\nend puts(Benchmark.realtime { 1_000_000.times { Fibonnaci.fib_rb(30) } })\nputs(Benchmark.realtime { 1_000_000.times { Fibonnaci.fib_cr(30) } })\n\nMy benchmark runs look pretty similar to the README\u2019s. The \u201ccrystalized\u201d\nversion runs about 4x faster than the pure Ruby version.\n\n    \n    \n    $ ruby test.rb 2.113752398872748 0.6535678738728166\n\nBut something is a bit off here. The Ruby implementation has a subtle mistake\nwhich causes signficantly more work than it needs to.\n\nRuby\u2019s multiple assignment a, b = b, a + b is equivalent to a, b = [b, a + b].\nMost of the time that Array allocation doesn\u2019t actually happen, but because in\nthis case it\u2019s the last line of the block, and because Ruby has an implicit\nreturn at the end of the block the Array is required (even though\nInteger#times doesn\u2019t use the return we don\u2019t yet have an optimization which\n\u201cknows\u201d that).\n\nLet\u2019s see how we do avoiding that... (with a slightly unsightly ; nil\nreplacing the return)\n\ndef fib_rb(n) a = 0 b = 1 n.times { a, b = b, a + b; nil } a end\n\n    \n    \n    $ ruby test.rb 1.245176327880472 0.6385665240231901\n\nNot bad. We\u2019re making up the difference. Now we\u2019re only about 2x slower than\ncrystal.\n\nTo make this a bit faster, instead of calling Integer#times, let\u2019s inline the\nloop.\n\ndef fib_rb(n) a = 0 b = 1 while n > 0 a, b = b, a + b n -= 1 end a end\n\n    \n    \n    $ ruby test.rb 0.7689670620020479 0.638991191983223\n\nNearly on par now! Finally, let\u2019s enable YJIT, Ruby\u2019s built-in JIT compiler to\nsee the real comparison.\n\n    \n    \n    $ ruby --yjit test.rb 0.10502525512129068 0.5002881051041186\n\nNow it\u2019s Ruby that\u2019s 5 times faster than Crystal!!! And 20x faster than our\noriginal version. Though most likely that\u2019s some cost from the FFI, or\nsomething similar, though that does seem like a surprising amount of overhead.\n\nI thought it was notable that by making some minor tweaks to Ruby code it can\nnow outperform a precompiled statically typed language in a purpose-built\nexample of when it is slow. I\u2019m hopeful that someday with future advancements\nin the Ruby JIT even the small tweaks might not be necessary.\n\nBy John Hawthorn on 2024-04-24\n\ngithub.com/jhawthorn @jhawthorn@ruby.social\n\n", "frontpage": true}
