{"aid": "40154761", "title": "I developed the fastest XML parser (2020)", "url": "https://tnickel.de/2020/08/30/2020-08-how-the-fastest-xml-parser-is-build/", "domain": "tnickel.de", "votes": 2, "user": "tosh", "posted_at": "2024-04-25 08:03:54", "comments": 0, "source_title": "How I developed the fastest XML parser", "source_text": "How I developed the fastest XML parser | Tobias Nickel\n\n# Tobias Nickel\n\n## software developer from heart\n\n# How I developed the fastest XML parser\n\nBy Tobias Nickel\n\nPublished 2020-08-30\n\nIt was almost 5 years ago that I read the documentation of react.js. The docs\nwere full of JSX and its JS equivalent. I saw this can work, but I thought\npeople are using template engines such as jade and ejs for a long time, every\nexpress js tutorial showed how to use the templates. As React, they also take\nsome input and generate the same UI output every time. Dropping the HTML\nstring into the DOM, however, is not as elegant as react\u2019s DOM reconciliation\nprocess. That process is needed to keep the elements/components state like\nuser inputs or to do transitions of elements.\n\nThis made me work on a framework I called treeact. A framework to do the\nreconciliation for HTML strings. Experimenting with the browsers build-in\nparser, I found that parsing was fast enough, but working with the resulting\nobjects from the DOMnode class hierarchy was not. And that parser is also not\navailable within a web worker. It was a big idea at the time, bring app logic\nto a web worker, and only do UI updates in the main process. (that idea never\nreally caught on, and angular react/redux, vue, svelte apps are all running\nall js in the main threat).\n\nSearching for parsers that could run in the browser, I did not find anything\nfast enough. Sax and xml2js were just too slow for a mobile browser to\nguarantee a smooth user experience.\n\nSo I developed my own parser and made it a separate project. Analyzing pages\nlike GitHub, StackOverflow, that have a very busy UI with lots of elements, I\nfigured I need to parse 3000 elements in 20ms on mobile. At that time my\ngalaxy S3.\n\nSo I needed a lot of experimenting to get the fastest possible results.\nFinding shortcuts and the fastest way to work with strings.\n\n# What makes TXML so fast?\n\nBefore I describe that in detail, you need to know what is compared. Txml is a\nDOM parser. It parses the XML string and creates a tree structure of objects\nthat represent the content of the XML. Parsing the same content results in\nequal results. Different parsers return slightly different DOM\nrepresentations, but all share this requirement. txml return arrays of string\nand node-objects, where each node has tagName, attributes, and children.\n\n  1. Something I found quickly is that regular expressions are too slow. Your code can become very small, but it will not be fast. I found an incredible small xml parser within the alasql module. (not published on npm separately). So if every byte counts, this is maybe the smallest XML parser.\n  2. It was clear to me, I can not slice and substring too much. Because we are constantly allocating new memory. The solution was to use a position pointer, the index within the source string.\n  3. Keep the number of function calls down, during the parsing process. because every function calls create a scope object. There is a function to parse a node with its attributes, a function for name identifiers, a function for strings, and a function for a node list. I experimented with inlining everything to a single function, but the code got too unreadable with repetitions and the gain was too little. Somewhere I read that firefox SpiderMonkey is better optimized for loops and v8 more for function calls, I was able to see that SpiderMonkey profits more from inlining functions, but still too little.\n  4. .indexOf is your friend. With indexOf you can go through a string very quickly. You constantly need to find the next open and close brackets. It is running in v8 with a very quick native code.\n  5. Only parse the parts of interest. txml was made for fast UI rendering, not to test if the developer follows the XML specification. For example, closing tags are almost skipped. They begin with </ and end with >. Do you like to write other crap into the closing tag? I don`t care. Most XML is generated by machines that will be well formatted. And if that is important to you, you most likely also want to validate against the XML schema. That is out of scope for txml.\n  6. Use of .getCharcodeAt() and compare the result to a number. That is much faster than comparing two single-character strings.\n  7. do the parsing inside its own js scope, to keep the scope for the actual parsing small and the needed code near where it was called. This allowed me to add more features, without any compromise and over time making the lib slower and slower.\n  8. monomorphism, this is a trick utilized by Vue.j , angular, and react alike. It means the created nodes always have the same shape. They always have tagName, attributes, and children. The v8 js engine can do huge performance optimizations. and also your code can be cleaner as you don`t need a condition to check if a property is there.\n\nThese optimizations help to make txml faster than all other javascript XML\nparsers at the pure parsing process. These are the optimizations, that make\ntxml 10-15 times faster than xml2js, and still 2-3 times faster than fast-xml-\nparser. These numbers are the results of benchmarks, that are part of fast-\nxml-parser and camaro.\n\nBut there is one more trick, that allows to find information inside a document\neven 100 times faster:\n\n  9. Only parse the elements that are of interest. The user can provide a start position, where the content that should be parsed is located inside a bigger document. The module also has a helper for getElementById or getElementsByClassName. They can be called directly on the string, without parsing the entire document first.\n\nWhile writing this article, I learned to know camaro, and even needed to delay\nthe article to analyse the module and run the benchmark. camaro is fast due to\nc++ compilation to WASM, (however not as fast as txml and no support for\nstreams.) camaro is also fast due to the use of piscina. Piscina can run\nprocessing intensive tasks inside a worker process potentially in parallel.\ntxml can also profit from piscina, but it should be used by the user of txml,\nto reduce the amount of data that needs to transfer between processes. While\ndeveloping txml, I learned a lot about performance in javascript and that\nparsing some data using just javascript, without regex or other libraries is\nnot as hard, but the resulting code is pretty fast.\n\nBy the way, txml is not only fast, but also reliable and secure. txml will\nonly parse the xml, not interpret any information and load external\ninformation or execute external commands, during the process. Txml has been\nused, to parse data from open street map\u2019s planet file, ARML for Augmented\nReality, geoTiff, RSS, WebDAV, SOAP and other API responses, HTML, SVG, Web\nScraping and more.\n\nBy the way, I think whenever you have the chance, please choose JSON over XML,\nit is just so much simpler.\n\njavascriptxmlnpmhigh-performance\n\nContents\n\n  1. 1\\. What makes TXML so fast?\n\nGithub Card\n\n  * name: Tobias Nickel\n  * followers: 62\n  * repositories: 83\n\nTags\n\n  * javascript^32\n  * programming^20\n  * architecture^15\n  * database^9\n  * module^7\n  * project^5\n  * node.js^5\n  * blogging^4\n  * motivation^4\n  * xml^4\n  * nodejs^4\n  * experience^4\n  * tool^4\n  * blockchain^4\n  * software development^4\n  * management^4\n  * code structure^3\n  * business^3\n  * performance^3\n  * server^3\n\nLinks\n\n  * github - TobiasNickel\n  * npm - nickeltobias\n  * dev.to/bias\n  * He For She\n  * Dulin's blog\n  * Wiredcraft\n\natom rss\n\nHello, I'm an awesome JS developer. This is my blog, believe it or not.\n\nTobias Nickel - Privacy Policy\n\n", "frontpage": false}
