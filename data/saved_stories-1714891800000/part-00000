{"aid": "40261496", "title": "I've gone and changed the stack again", "url": "https://www.zarl.dev/articles/goth", "domain": "zarl.dev", "votes": 1, "user": "mooreds", "posted_at": "2024-05-05 00:48:04", "comments": 0, "source_title": "I'm a fickle soul", "source_text": "I'm a fickle soul\n\nzarl.dev\n\n# I'm a fickle soul\n\n## How I've gone and changed the stack again\n\n##### 2 months ago\n\n\ud83d\udc4f (273)\n\n# Intro\n\nSo yes I was having ALL the fun doing front end code with Typescript and\nSvelteKit but I have decided to try and play with something that is the\ncomplete 180 from not only SPA and Client / Server frontends but a solution\nwhere I write minimal JavaScript.\n\nGOing with the GoTH stack (Go, Templ and HTMX) It's a 100% Go solution for not\nonly your backend REST code but also for the creation of your HTML templates /\ncomponents using the Templ framework. Interactivity is provided from HTMX\nwhich is a HATEOAS (Hypermedia as the engine of application state) framework\nwhere you provide Server-side rendered html direct to the browser and HTMX can\ndo dynamic replacement of the DOM and other stuff with just some HTMX\nattributes on your HTML elements - Use JavaScript so I write less JavaScript.\n\nGoTH Stack Overview The GoTH stack revolves around three core components:\n\n  1. Go serves as the backbone of the stack, offering me type safety, performance, and familiarity, given my years with the language. Its versatility makes it a natural choice for backend development tasks.\n\n  2. Templ is the templating framework of choice, mainly due to the type safety and efficiency when generating HTML templates. Templ\u2019s integration which uses code generation with the templ file definitions it does make templating much better than the classic go templates.\n\n  3. HTMX represents the bridge between traditional server-rendered HTML and dynamic client-side interactions. HTMX enables the manipulation of DOM elements with its own html tags which allows the SPA features without the complexities of SPAs.\n\nSo with this stack I found myself super productive, much more productive than\nI was in the JavaScript world but that\u2019s to be expected considering Go would\nbe my language of choice in most cases and the one I have the most experience\nin.\n\n## Backend\n\nStandard stuff here, I decided to go with the Echo HTTP Framework, I\u2019ve used\nit a good bit in the past and am comfortable, and to be honest I prefer the\nhandler semantics with the fact that the handler functions return an error. So\nas per my usual layout we have our API layer structs usually postfixed with\nRequest then we have our business logic representation and finally the\nDatabase representation, usually postfixed with Row. This stop the front end\nbeing coupled to your database row e.g.\n\nArticleRequest -> Article -> ArticleRow\n\nI follow a standardised approach to creating my REST handlers, for each\nendpoint type I have a handler struct that can contain all other dependencies\nit requires to make those calls. Each handler has a RegisterRoutes function to\ncreate the endpoints.\n\nHere is my static handler that mounts my compiled assets, tailwind CSS and\nsome images mainly.\n\n### REST Handlers\n\n    \n    \n    type StaticHandler struct { } func NewStaticHandler() *StaticHandler { return &StaticHandler{} } func (h *StaticHandler) RegisterRoutes(router *echo.Echo) { router.Static(\"/static\", \"assets\") }\n\nHere is a more traditional handler with a Repository field.\n\n    \n    \n    type Article struct { Title string Subtitle string Body string Image string } type ArticleHandler struct { Repo *repo.ArticleRepository } func NewArticleHandler(config repo.Config) (*ArticleHandler, error) { ar, err := repo.NewArticleRepository(config) if err != nil { return nil, err } return &ArticleHandler{ Repo: ar, }, nil } func (h *ArticleHandler) RegisterRoutes(router *echo.Echo) { router.GET(\"/articles\", h.ListArticles) router.GET(\"/articles/:slug\", h.Article) } func (h *ArticleHandler) ListArticles(c echo.Context) error { articleRows, err := h.Repo.GetArticles() if err != nil { return err } articles := make([]article.Article, len(articleRows)) for pos, a := range articleRows { articles[pos] = a.ToArticle() } return render(c, article.ListArticles(articles)) } func (h *ArticleHandler) Article(c echo.Context) error { slug := c.Param(\"slug\") articleRow, err := h.Repo.GetArticleBySlug(slug) if err != nil { return err } a := articleRow.ToArticle() clapped := false cookies := c.Cookies() for _, cookie := range cookies { if cookie.Name == clapID(a.ID) { clapped = true } } return render(c, article.Show(a, clapped)) }\n\nHere is the articles handler for showing the list of Articles and the\nindividual Article, as you can see I have defined my own Article struct that\nis provided to the template, this way I do not have tight coupling with the\ndatabase entity which in this case is an ArticleRow type.\n\n### Repository\n\nAs usual I find the repository pattern useful for laying out the interactions\nwith the database. I will also always return a specific ROW Type entity that\nhas the sql package typed fields so that you can do NULL checks etc. with\ntypes from the database. It's best practice to do this as close to the\ndatabase interactions as possible with the ArticleRow type, you could also\nCOALESE in your SQL statement so all null-able fields are defined a default\nreturn for the NULL scenario.\n\nFor the actual Database I\u2019m just using a SQLite database with segregated\nconnections. As SQLite is single threaded the read connection is still\navailable when the write connection is busy when the locks are on other\ntables, not like this is going to come into play as I\u2019m not writing blog posts\nall day.\n\n### Templates\n\nAs is the way with these things the hotness at the moment is Templ. Its a\nfully go typed templating framework that allows the type safety that the\nnative go templates do not have. This has been very nice to work with and is\ndefinitely a step up from the native templating engine. Templ using a\ngeneration step to take the .templ definitions and then produce the actual go\ncode. What\u2019s nice is there is a LSP for VSCode for Templ for code completion\netc.\n\n### HTMX\n\nSo the main thing here that I wanted to play with was the HTMX library - it\u2019s\nbeen getting much more popular recently and promises to be a low javascript\nway to get a lot of the benefits of a SPA by using the existing HTML syntax\nand the special HTMX tags. There is a few tags so it might take a little while\nto get the surface area covered but for general run of the mill type problems\nits been a god send. Few HTMX tags on your exiting HTML and you are away, then\nwith the Templ framework it is a nice quick feedback loop. The main use I had\nfor HTMX was to add the \u2018Clap\u2019 feature to allow some sort of way to hot-swap\nthe elements and give a better user experience. The strangest thing probably\nis the building out of the HTML API endpoints for the direct HTML but once\ngoing its a nice flow to it. Using the htmxpost for the wrapper for AJAX calls\nfor the too and fro from the server side. This was great for adding the\n\u2018Claps\u2019 feedback feature on the bottom of all the articles.\n\nHere is the GoComponent:\n\n    \n    \n    package claps import ( \"strconv\" ) func clapURL(id int) string { return \"/claps/\" + strconv.Itoa(id) } func clapCountURL(id int) string { return \"/claps/\" + strconv.Itoa(id) + \"/count\" } func countString(count int) string { if count == 0 { return \"\" } return strconv.Itoa(count) } templ ClapHeader(id, count int) { <div class=\"clap_container flex flex-col\"> <div class=\"\"> <span class=\"hands\">\ud83d\udc4f</span> <span class=\"count\" id=\"header_count\" hx-swap-oob=\"true\">({ countString(count) })</span> </div> </div> } templ ClapCount(id, count int) { <span class=\"count\">({ countString(count) })</span> } templ ClapButton(id, count int, clapped bool) { if clapped { @Clapped(count) } else { @Clap(id, count) } } templ Clap(id, count int) { <div id=\"clap\" name=\"clap\" class=\"clap_container\"> <form class=\"clap flex flex-col text-center\"> <button class=\"clap_button\" hx-post={ clapURL(id) } hx-trigger=\"click\" hx-target=\"#clap\">Clap!\ud83d\udc4f</button> <div class=\"p-4\"> <span>\ud83d\udc4f</span> <span id=\"count\" class=\"count\">({ countString(count) })</span> </div> </form> </div> } templ ClappedWithHeader(count int) { @Clapped(count) <span id=\"header_count\" class=\"count\" hx-swap-oob=\"true\">({ countString(count) })</span> } templ Clapped(count int) { <div id=\"clap\" name=\"clap\" class=\"clap_container \"> <form class=\"clap flex flex-col text-center\"> <button disabled class=\"clapped_button\">Thanks!\ud83c\udf89</button> <div class=\"p-4\"> <span>\ud83d\udc4f</span> <span id=\"count\" class=\"count\">({ countString(count) })</span> </div> </form> </div> }\n\nNice simple, type safe golang front end component with reactivity, yes please.\n\ud83d\ude01\n\n### Tailwind\n\nOK, I need tailwind these days - it just makes things much easier and I have\nfound my groove with it - however there was the small task of integrating it\nwith the GO binary and getting everything as part of the build process. For\nthis I added the \u2018npx tailwindcss -i assets/css/style.css -o\nassets/css/app.css \u2013minify\u2019 command to be part of my build process and the css\nrequired was generated and minified.\n\n### Development Process\n\nTo keep the feedback loop nice and quick I\u2019ve been using air to keep the UI\nand the backend refreshed and in sync while I edit the source. This is super\nhelpful and builds the templ templates when it detects any changes I even\nswitch it on sometimes for my css files.\n\n### Build Process\n\nFor my build process I\u2019ve settled on Make, its simple does everything I need\nto do and is well known. It also allows the integration of the code generation\nsteps right into the build process. For the structure of my make file I\nusually go for my run command and my build commands. For my run commands I\nseparate those out into local running and in a container. So we have \u2018run\u2019\n\u2018run-docker\u2019 \u2018stop-docker\u2019, \u2018run\u2019 runs the last local binary built in the\n\u2018dist\u2019 directory and binds to local port \u20188080\u2019, where \u2018run-docker\u2019 and \u2018stop-\ndocker\u2019 are mere aliases for the standard docker compose up/down commands. To\nmake sure I keep track of the binaries and what I think is just good practice\nis the building into the binary the build date and the git sha of the code\nthat it was built from. To achieve this I added some //go generate comments\nand also the //go embed to the code base. They are:\n\n    \n    \n    //go:generate sh -c \"date > build.date\" //go:embed build.date var build string\n    \n    \n    //go:generate sh -c \"printf %s $(git rev-parse HEAD) > git.sha\" //go:embed git.sha var gitsha string\n\nThese can then be logged or served on an API or what ever way make sense to\nsurface the data. I just have them printed on server start up. Makes things\neasy to keep track of.\n\n# Summary\n\nOverall I\u2019ve really enjoyed the HTMX framework and the quick feedback loop got\nset up with air and the make file for the larger scale tasks. Think I will\nkeep the blog running this for the foreseeable until I get bored again.\n\n# Code\n\nThe code for all of this can be found on my github.\n\nCopyright 2023 zarl.dev\n\n", "frontpage": false}
