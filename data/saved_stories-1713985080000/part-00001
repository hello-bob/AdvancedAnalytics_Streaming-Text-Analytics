{"aid": "40143298", "title": "\"Testing can show the presence of bugs but not the absence\"", "url": "https://buttondown.email/hillelwayne/archive/testing-can-show-the-presence-of-bugs-but-not-the/", "domain": "buttondown.email/hillelwayne", "votes": 1, "user": "BerislavLopac", "posted_at": "2024-04-24 11:56:52", "comments": 0, "source_title": "\"Testing can show the presence of bugs but not the absence\"", "source_text": "\"Testing can show the presence of bugs but not the absence\" \u2022 Buttondown\n\nComputer Things\n\nApril 23, 2024\n\n# \"Testing can show the presence of bugs but not the absence\"\n\n## An analysis of the ramifications.\n\n> Program testing can be used to show the presence of bugs, but never to show\n> their absence! \u2014 Edgar Dijkstra, Notes on Structured Programming\n\nDijkstra was famous for his spicy quips; he'd feel right at home on tech\nsocial media. He said things he knows aren't absolutely true but will get\npeople listening to him. In the same essay he discusses how testing could, in\nspecific cases, show the absence of bugs:\n\n  * If a function has a finite set of inputs, like floor(float), you could prove correctness by simply testing all possible inputs.\n  * Even if a function has infinite inputs, tests prove the absence of bugs for tested inputs. You could say \"date_of_easter works for any date within 10,000 years of today\" and have \"proven the absence of bugs\" for the subset of dates people care about.^1\n  * You can use testing to complete a proof. For example, you can divide inputs into \"equivalence classes\", prove that if the function is correct for one value it will also be correct for all values in that class, and then test one value from each class.\n\nIn the majority case, however, testing cannot show the absence of bugs.\nTesting f(16) does not give you any guarantees about all x. f(x).\n\nThere are two possible takeaways. The reasonable one is that we shouldn't be\nblindly confident in testing, should use a variety of approaches as part of\ndefense in depth, and always be careful about what we claim. The unreasonable\ntakeaway is that testing is an inferior verification method, and we should use\nmore \"rigorous\" approaches instead of testing.\n\nIt's unreasonable because methods that show the existence of bugs are more\nrobust than methods that show the absence of them, and this makes them more\nuseful more of the time.\n\n### Comparing tests and proof\n\nLet's say you have a pseudocode function like this:\n\n    \n    \n    fun elem_before_x(s: int[], x: int) returns (r: int | NULL) { let i: int = index(s, x); if (i == NULL) { return NULL; } else return s[i-1]; } Property: if r == NULL then x notin s else some i in 0..<len(s): s[i] == r && s[i+1] == x\n\nThe bug here is that we're out-of-bounds if x is the first element of the\narray. Testing will find this bug if you remember to test that case.\nOtherwise, we'd have a bug and a passing test suite. Tests can't verify the\nabsence of bugs.\n\nSubscribe\n\nNow imagine we do find it and fix it:\n\n    \n    \n    else if (i == 0) { return s.last; }\n\nModifying the property is left as an exercise to the reader. Once again, the\npassing test suite means we haven't verified the absence of the bug. Now, how\ndoes formal verification do on the same problem? I wrote a Dafny version of\nthe same problem, here, both with and without the fix. Looking at v1, we see\nit finds the s[0] error:\n\n    \n    \n    > var v := index.Extract(); > return Some(s[v-1]); (19,16): Error: index out of range | 19 | return Some(s[v-1]);\n\nThis error also goes away in v2: the bug is proved to be absent. But v2 adds a\nnew error:\n\n    \n    \n    > ensures if r.None? then x !in s > else if s[|s|-1] == r.value then s[0] == x > else s[IndexOf(s, r.value)+1] == x (7,20): Error: index out of range | 7 | else if s[|s|-1] == r.value then s[0] == x | ^^^^^^^\n\nWhen would s[|s|-1] be an index out of range? When the list is empty. But we\nknow that's not possible: if we return a non-null value then the list must not\nbe empty, because we found x in it! But the prover doesn't know that, it can't\ninfer the relationship between the returned value and what we know about the\nlist.^2 We have to annotate our code with proof hints for it to recognize that\nif we return a number, the list is nonempty.\n\nIn short: the prover definitely finds the out-of-bounds bug, but also raises a\nspurious \"empty list\" bug. The test might not find the former but also won't\nraise the latter. Tests can have false negatives but not false positives,\nwhile provers can have false positives but not false negatives.\n\n(I'd say \"formal verification can prove the absence of a bug but never the\npresence\", but that's not true. Dafny can sometimes give you a concrete\ncounterexample to a property, and type systems detect true positives like \"you\npassed an array into an Int -> Int function\" all the time.)\n\nKnowing there \"might\" be a bug is not as useful as knowing there is one.\nEmpirically speaking people mostly ignore compiler warnings and plenty of\nretrospectives find people ignore \"might possibly be a bug\" in even mission-\ncritical software. Formal verification often becomes an \"all or nothing\" deal,\neither you totally prove the absence of bugs in programs or you get no\nbenefits at all.\n\nAnd that sucks! It takes a lot of effort to prove something correct,\nmagnitudes more than running some tests. And that's why I consider testing\n\"more robust\": even a little bit of testing may find a true bug, while a\nlittle bit of verification doesn't get you much.\n\n### Correctness is not a thing\n\nI'll end this by getting on my soapbox. Here's something that's really\nimportant to understand about \"proving the absence of bugs\":\n\n> You do not prove something's correct. You prove conformance to\n> specification.\n\nIt's possible for code to conform to the specification and still have bugs.\nTwo common cases are:\n\n  1. The spec is wrong or incomplete, like v2.dfy is in the above example. Spoiler in the footnote.^3\n  2. The spec is based on an assumption that's not true in practice, like \"no other program is writing to the same file.\"\n\nThis is also important because it puts the specification front-and-center. You\ncan write tests without having a specification in mind, but you need a spec to\ndo any kind of formal method. Doing FM trains you to think about specs, which\nin turn helps you write better tests.\n\n#### Things I am interested in\n\n  1. Crossovers from fields besides classical engineering, who worked professionally as something else before switching to software. What ideas from your old job as a journalist/librarian/social worker/acrobat could be useful in software, and vice versa?\n  2. Wargaming in software. Have you designed or participated in a devops/security/system design/whatever simulated game? Was it helpful?\n\nIf you have insights into either of these, feel free to share! Or write about\nthem publicly and share the link with me. You can just reply directly to this\nemail.\n\n  1. Though you could argue this isn't sufficient for security. If easter(-1e8) causes a memory overflow then that's a bug even if a normal user won't ever call it. \u21a9\n\n  2. We're lucky that the Dafny standard library defines a postcondition for index functions saying the output is less than the length of the list. Otherwise the prover would raise a potential out-of-bounds error on s[IndexOf(s, x)]! \u21a9\n\n  3. s[|s|-1] == r.value then s[0] == x isn't true for the input [a, r, x, r]. The good news is that Dafny refuses to verify the code because it didn't match the spec. I only realized this when I was error-checking this piece. (This doesn't refute the point I made above about false positives: the false positive was that s[|s|-1] was out of bounds!) \u21a9\n\nIf you're reading this on the web, you can subscribe here. Updates are once a\nweek. My main website is here.\n\nDon't miss what's next. Subscribe to Computer Things:\n\nSubscribe\n\nBrought to you by Buttondown, the easiest way to start and grow your\nnewsletter.\n\n", "frontpage": false}
