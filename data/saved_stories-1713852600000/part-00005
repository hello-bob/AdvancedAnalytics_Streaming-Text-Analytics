{"aid": "40121276", "title": "Beatrice: A tagless, dependently typed, self-aware programming language", "url": "https://hirrolot.github.io/posts/announcing-beatrice.html", "domain": "hirrolot.github.io", "votes": 2, "user": "vg_head", "posted_at": "2024-04-22 21:29:41", "comments": 0, "source_title": "Announcing Beatrice: A finally tagless, dependently typed, self-aware programming language", "source_text": "Announcing Beatrice: A finally tagless, dependently typed, self-aware\nprogramming language\n\n# Announcing Beatrice: A finally tagless, dependently typed, self-aware\nprogramming language\n\n\ud83c\udf85 Hirrolot's Blog\n\nApr 22, 2024\n\nToday I am pleased to announce Beatrice, which is a finally tagless,\ndependently typed, self-aware functional programming language that I have been\nworking on for quite a while. In this short blog post, I will demonstrate its\nmost prominent features and contrast them to those of mainstream programming\nlanguages.\n\n## Dependent types\n\nIn Beatrice, types can depend on values. This allows many real-world patterns\nto be expressed as ordinary functions. Consider the String.format function\nfrom the standard library, which can be used as follows:\n\n    \n    \n    import { \"std/src/String.bea\" } // \"Be-a-trice\" export main: string = let speak = String.format(via=\"%s-%s-%s\"); speak(x=\"Be\", x=\"a\", x=\"trice\");\n\nThe type of speak is (x: string, x: string, x: string) -> string. If we were\nto call String.format with via=\"%s %b %i32\", the type would be (x: string, x:\nboolean, x: i32) -> string. Thanks to first-class functions, we can even store\nthe application of String.format to via as an ordinary let-binding.\n\nMost often, string formatting is expressed either as an unsafe variadic\nfunction or macro. In some situations, extra compiler magic is required. In\nBeatrice, string formatting is just an ordinary function whose type can be\nstatically inferred and checked. For example, if we attempt to pass a boolean\ninstead of a string:\n\n    \n    \n    import { \"std/src/String.bea\" } // \"Be-a-trice\" export main: string = let speak = String.format(via=\"%s-%s-%s\"); speak(x=true, x=\"a\", x=\"trice\");\n\nwe will receive the following compilation error:\n\n    \n    \n    error: src/Main.bea:7:13: Expected type `string`, got `boolean`: 7 | speak(x=true, x=\"a\", x=\"trice\"); ^^^^\n\nThis example manifests the ability of our type system to embed domain-specific\nlanguages with custom syntax in a typed manner. I invite you to study the\nimplementation of String.format to see how it is done.\n\n## Tagless-final\n\nIn Beatrice, functions are composed directly, and if there are several\ninterrelated functions, they are stored in a record. This style is called\ntagless-final.\n\nConsider our encoding of a functional list:\n\n    \n    \n    List(a: type) -> type = { repr: type, Nil: repr, Cons: (x: a, xs: repr) -> repr };\n\nCommon operations such as count, filter, and map can be defined as follows:\n\n    \n    \n    count(a: type) -> List(a) = { repr=u64, Nil=0, Cons(_x, xs) = (1 + xs) }; filter(a: type, f: (x: a) -> boolean, cont: List(a)) -> List(a) = { repr=cont.repr, Nil=cont.Nil, Cons(x, xs) = if { f(x) -> cont.Cons(x, xs); _ -> xs } }; map(a: type, b: type, f: (x: a) -> b, cont: List(a=b)) -> List(a) = { repr=cont.repr, Nil=cont.Nil, Cons(x, xs) = cont.Cons(x=f(x), xs) };\n\nand used as follows:\n\n    \n    \n    // 3u64 export main: u64 = let pipeline = (map(a=string, b=string, f(s) = (\"x\" ++ s ++ \"x\")) -> filter(a=string, f(s) = (length of s >= 5)) -> count(a=string)); [ \"a\", \"ab\", \"abc\", \"abcd\", \"abcde\" ] with pipeline;\n\nThis mechanism allows us to throw out algebraic data types from the language.\nIn return, we obtain 1) a simpler core language, 2) less interpretive\noverhead, 3) a more compositional style of programming, 4) extensibility in\nboth axes, and 5) apparentness of termination of algorithms. We pay the price\nby losing the ability to do nested pattern matching in a direct way; however,\nit can still be done by explicating the context, which is more apparent in\nterms of termination.\n\nInterestingly, the tagless-final style can be used to model not only data\ntypes but also algebraic effects. Consider the state effect:\n\n    \n    \n    State(s: type, a: type) -> type = { repr: type, return: (self: a) -> repr, get: (cont: (state: s) -> repr) -> repr, set: (self: s, cont: (force: unit) -> repr) -> repr }; new(s: type, a: type) -> State(s, a) = { repr=(self: s) -> a, return(self, _state) = self, get(cont, self) = (cont(state=self)) @ self, set(self, cont, _state) = (cont(force=_)) @ self };\n\nusing a sort of do notation, we can manipulate State as follows:\n\n    \n    \n    test(cont: State(s=i32, a=string)) -> cont.repr = do x <- cont.get; do cont.set @ (x + 7); do x <- cont.get; cont.return @ string of x; // \"12\" export main: string = let state = new(s=i32, a=string); ((test -> state)) @ 5;\n\n## Typed tagless metaprogramming\n\nBeatrice can represent its typed abstract syntax within itself. This allows us\nto manipulate Beatrice programs within Beatrice.\n\nFor example, if we are to invert every control flow condition in a program:\n\n    \n    \n    import { \"std/src/Metacode.bea\", \"std/src/Metasystem/Demetacoder.bea\" } pass: Metacode.T = Demetacoder.run; invertConditions: Metacode.T = { repr(self) = self, reflect=pass.reflect, Const=pass.Const, FreeVar=pass.FreeVar, Fn=pass.Fn, Pair=pass.Pair, FnTy=pass.FnTy, PairTy=pass.PairTy, Appl=pass.Appl, SelectFirst=pass.SelectFirst, Behead=pass.Behead, Let=pass.Let, IfThenElse(_a, cond, m, n) = if { !cond -> m; _ -> n }, BooleanOp=pass.BooleanOp, IntOp1=pass.IntOp1, IntOp2=pass.IntOp2, StringOp1=pass.StringOp1, StringOp2=pass.StringOp2, Break=pass.Break, Continue=pass.Continue, ControlTy=pass.ControlTy, Loop=pass.Loop, TypeOf=pass.TypeOf, Delay=pass.Delay, Panic=pass.Panic, Precompute=pass.Precompute, Transfix=pass.Transfix }; // \"Success\" export main: string = metacode { let x: i32 = 5; if { (x != 5) -> if { ((x * 2) = 30) -> \"Success\"; _ -> \"Failure\" }; _ -> \"Failure\" } } with invertConditions;\n\nDemetacoder.run is a simple metacircular evaluator of Beatrice. By reusing it\neverywhere except for IfThenElse, we were able to compositionally process each\nlanguage form in the input program. The result of this processing is\nguaranteed to be a syntactically correct, well-scoped, and well-typed Beatrice\nprogram.\n\nA similar feature can be found in almost every modern general-purpose\nprogramming language. However, the crucial difference is that our approach\nallows us to catch metaprogramming bugs at the time of definition of the\nprogram transformer, not its usage. For example, if we write the following:\n\n    \n    \n    IfThenElse(_a, cond, m, n) = if { !cond -> \"oops\"; _ -> n },\n\nwe will receive the following compilation error:\n\n    \n    \n    error: src/Main.bea:22:53: Expected type `_a`, got `string`: 22 | IfThenElse(_a, cond, m, n) = if { !cond -> \"oops\"; _ -> n },\n\nOur treatment of metaprogramming is partly inspired by a cybernetical\nprogramming language called Refal-5. Manipulating program\u2019s code (which we\ncall metacode) can be seen as an example of metasystem transition.\n\n## Final words\n\nThere are many other interesting examples of Beatrice, such as ad-hoc\npolymorphism, partial computation, and embedding typed higher-order calculi.\nThis page will give you a more comprehensive overview of the language.\n\nIn designing Beatrice, I attempted to combine every significant aspect of the\nlanguage with symbolic execution (that can work in the presence of unknown\nvalues). Thus, 1) Beatrice\u2019s abstract syntax can be manipulated by executing\nthe transformer\u2019s methods, 2) Beatrice\u2019s terms can be evaluated during type\nchecking, and 3) partial computation can be used to obtain more efficient\ntarget programs. The full power, as well as consequences, of this design\napproach are yet to be explored.\n\nFor a diligent reader, I have prepared a comprehensive design document that\nexplains and discusses nearly every design choice behind Beatrice. A\nmathematically inclined reader is invited to study the formal semantics of\nBeatrice.\n\n## Acknowledgments\n\nI would like to thank @cppenjoy for testing the compiler, helping to write the\nSystem standard library module, and provoking useful discussions regarding the\nlanguage. Beatrice is built on prior art of many researchers and programming\nlanguage enthusiasts, including Oleg Kiselyov, Thierry Coquand, Valentin\nTurchin, Lennart Augustsson, Andr\u00e1s Kov\u00e1cs, Edwin Brady, and many others.\n\n", "frontpage": false}
