{"aid": "40248247", "title": "Best Code Review Techniques", "url": "https://www.awesomecodereviews.com/code-reading/code-review-techniques/", "domain": "awesomecodereviews.com", "votes": 1, "user": "sea-gold", "posted_at": "2024-05-03 14:42:22", "comments": 0, "source_title": "10 Best Code Review Techniques", "source_text": "10 Best Code Review Techniques | Awesome Code Reviews\n\n# 10 Best Code Review Techniques\n\nSystematically reviewing source code is an essential part of ensuring code\nquality and correctness of the code. Yet, most developers review their code ad\nhoc, which means they do not have any formal, or even explicit code review\napproach that they can easily describe. While a few formal code review\ntechniques exist, they are not widely known. In this article, I show you\ndifferent code review techniques you can use to make your code review approach\nmore systematic, explicit, and effective. Those techniques are either\ndedicated code review techniques, or techniques from other development\ndisciples, such as code reading, testing, or debugging, that I adapted to\nfacilitate the task of code reviewing to help you find more bugs, and\nunderstand the code under review better.\n\n## Modern code review is ad-hoc\n\nMost programmers review code in an ad hoc manner. This means there is no\nexplicit, formal, or systematic process that the team agreed upon to review\ncode. Instead, the developers intuitively review source code files based on\ntheir experience.\n\nWhich files, methods and even statements developers look at, and in which\norder, is up to the individual developer, and often even up to their current\nmood. Similarly, which aspect or issues they look for in code is not well\ndefined, and can change from developer to developer.\n\n## Junior developers struggle without concrete review techniques\n\nWhile programmers develop their individual techniques for code reviewing over\ntime, those techniques are implicit, vary from person to person, and often\nonly live in the developers\u2019 heads. Junior developers therefore often wonder\nhow exactly they should review code, and what to look for. They learn how to\nreview code by copying and mimicking what they see their peers do in code\nreview. However, this process to learn code reviews is neither efficient nor\neffective. It also means that each team member will have a slightly (or\nvastly) different approach to review code.\n\n## Transforming implicit to explicit knowledge\n\nOne of the best code review hacks a team can embrace is to transform the\nimplicit knowledge that experienced developers on their team have (basically\nin their head), into explicit knowledge.\n\nDuring such a transformation process, the experienced developer describes in\ndetail what they do during a code review. Over time, those explicit guides to\nreviewing code, can become one overall guideline that describes how code is\nreviewed within a team. Such a guideline serves two purposes: First, it\nstreamlines how a team reviews code, and second, it allows people new to the\nteam to learn quickly what is important during code reviewing.\n\n## Formal, systematic, and explicit review techniques\n\nIn addition to learning from the experience of senior developers, we can also\nlearn from formal, systematic, and explicitly described techniques for code\ninspection, code review and code reading.\n\nIn this blog post, I show you some of the code review techniques I also teach\nin my code review workshops. This can help you to transform your implicit and\nad hoc reviewing techniques into explicit and more systematic approaches.\n\n## Systematic Code Review Approaches\n\nWe will look at the following systematic code review approaches:\n\n  1. Checklist-based Code Reviews\n  2. Test-Driven Code Reviews\n  3. Bottom-up versus Top-Down Code Reading\n  4. Control-flow versus Data-flow Code Reviews\n  5. Pattern Recognition\n  6. Cross-Referencing\n  7. Change-Impact Analysis\n  8. Trace-Based Code Reading\n  9. Abstract-Driven Code Reviews\n  10. Functionality or Use-Case-Driven Code Reviews\n\n## 1\\. Checklist-based Code Reviews\n\nOne of my favorite code review techniques involves using a checklist. They are\nby far the most widely used systematic code review technique because the\napproach is straightforward to implement and does not involve a lot of\nadditional effort. In empirical research, checklist-based code reviews have\nalso been shown as very effective.\n\nChecklist-based code reviews involve using a predefined list of items or\ncriteria to assess the code. A checklist can focus on a variety of factors\nsuch as coding standards, design principles, security guidelines, and\nperformance considerations. You can find a code review checklist that covers a\nwide range of topics here. Sometimes, only one of those factors, for example,\nsecurity, is the focus of such a checklist. This makes sense when you want to\nperform a more thorough review in this specific area. Have a look at this\nsecurity-focused code review checklist as an example.\n\nPros:\n\n  * Provides a systematic and structured method for reviewing code, ensuring consistency and thoroughness.\n  * Helps reviewers focus on important aspects that might be overlooked otherwise.\n  * Assists in educating new team members about coding standards and best practices.\n  * Functions as a memory aid, ensuring important aspects are checked.\n\nCons:\n\n  * Correct usage of the checklist might be unclear or confusing.\n  * Aspects not covered by the list might be overlooked.\n  * May lack flexibility, as not all checklist items are applicable to every piece of code.\n  * It might be not clear where to look, as no order for inspection was given.\n\nLearn more about checklist-based reading here.\n\n## 2\\. Test-Driven Code Reviews\n\nDuring test-driven code reviews, the code reviewer starts by reviewing the\ntest code before they review the production code. The rationale behind this\napproach is to use the test cases as use cases that explain the code. Thus,\nthe code reviewer learns about the production code when they look at the test\ncode, which helps them create a mental model. The tests are used as a\nspecification of what the software is supposed to do, and the code reviewer\nlearns about the assumption the code author had about the code through the\ntests.\n\nPros:\n\n  * Helps improve the test code quality and thus maintainability and quality of the code.\n  * Ensures high test coverage and quality.\n  * Encourages writing meaningful tests that truly validate the code.\n  * Tests can help the developer understand the production code.\n\nCons:\n\n  * Depends heavily on the quality of the tests themselves.\n  * Can\u2019t be done in the absence of tests.\n  * Tests might replicate the misunderstandings of the code author about the code\u2019s specification.\n\nLearn more about test-driven code reviewing here.\n\n## 3\\. Bottom-up and Top-Down Code Reading\n\nAll code reading techniques can be broadly categorized also into bottom-up or\ntop-down reading. Most of the time, we use a combination of those two\napproaches. So, let\u2019s have a more detailed look!\n\n### Bottom-up Code Reading\n\nBottom-up reading means that the developer starts reading, understanding, and\nreviewing small fragments of the code first. Based on those small fragments,\nlike single code statements, or small methods the developer works their way up\nto understand and evaluate more and more of the functionality and quality of\nthe software under review. This way, the developer gradually builds a picture\nof how code elements interact to form the larger system.\n\nBottom-up code reviewing works well when reviewing a small, self-contained\npiece of code, like a function or a class. On the other hand, it also works\nwell, when you have to review a larger piece of software you are completely\nunfamiliar with that lacks documentation.\n\nPros:\n\n  * Developers build a thorough understanding of the nitty-gritty details of the code.\n  * Helps to effectively identify local issues, bugs, and inefficiencies.\n  * The developer needs less overall context about the system, making it suitable for new team members or for reviewing isolated components.\n  * Works well for unclear or unfamiliar legacy code, or code that isn\u2019t documented.\n\nCons:\n\n  * It is a time-consuming approach due to the focus on details.\n  * Reviewers might miss the big picture, as well as architectural or higher-level design problems.\n  * When confronted with a large code change, starting at the lowest level can be overwhelming and inefficient.\n\n### Top-down Reading\n\nIn a top-down reading approach, the software developer starts by reading, for\nexample, a user story or the documentation of the software first. These often\nnon-code artifacts already explain the purpose of the code under review and\ngive the reviewer an overview of what to expect. Then, the reviewer examines\nthe overall structure and components of the systems. The goal is to build a\nmental model of the system before looking at the code in more detail. In a\nlater step, the reviewer tries to find the most significant method(s), that\ndrive the functionality and starts reviewing in more detail from there.\n\nPros:\n\n  * This approach helps build an understanding of the system\u2019s architecture and high-level design.\n  * It is effective in spotting problems with the overall design, structure, and integration points.\n  * The approach is suited for larger code changes or even complete codebases.\n  * It helps prioritize which parts of the code to focus on for a more detailed review.\n\nCons:\n\n  * Reviewers using only a top-down approach might overlook specific low-level coding issues or bugs.\n  * Requires the reviewers to have a good understanding of the overall system, which might not be feasible for newcomers.\n  * By examining only high-level artifacts, the reviewer might make incorrect assumptions about how high-level designs are implemented at the lower levels.\n\nLearn more about top-down code reviews here.\n\n### Combining bottom-up and top-down code reviewing\n\nIn practice, a combination of both approaches is often used. Starting with a\ntop-down review helps understand the system\u2019s architecture and major\ncomponents, setting the stage for a more detailed, bottom-up review of\nspecific areas of interest or concern. This combined approach ensures the\narchitectural integrity and the detailed correctness of the code.\n\n## 4\\. Control-flow and Data-flow Code Reviews\n\nTwo other complementary code review approaches are control-flow and data-flow\ncode reading. Control-flow reading follows the execution of the program,\nwhereby during data-flow reading you follow the data.\n\n### Control-flow Code Reviews\n\nControl-flow reading focuses on understanding how the program\u2019s execution\nprogresses. It examines the order in which statements, instructions, or\nfunction calls are executed and how the program moves from one part to\nanother. This includes looking at loops, conditional statements, function\ncalls, and recursion. Control-flow driven code reviews are great for finding\nlogical errors.\n\nPros:\n\n  * Highly effective in spotting logical problems with the flow of execution, such as loops, conditionals, and sequence of operations.\n  * Essential for understanding the execution order and for debugging issues like infinite loops or unexpected branches in logic.\n  * Helps in understanding the overall structure of the program, particularly the execution order and the interrelation of various components.\n\nCons:\n\n  * Reviewers might miss issues related to data handling or data integrity.\n  * It is less effective for data-intensive applications.\n  * Complex to perform in event-driven systems due to the non-linear progression of execution.\n\n### Data-Flow Code Reviewing\n\nData-flow reading focuses on how data moves through the program. This includes\ntracking the source, use, and modification of variables and data structures,\nunderstanding how data is passed between functions, and examining how data\nstate changes over time. Data-flow code reviewing is particularly useful when\nlooking at the code with a security lens. It helps identify data leaks or\npoints where sensitive data might be compromised.\n\nPros:\n\n  * Effective in identifying problems related to data handling, such as data corruption, improper use of data structures, and issues with data lifecycle.\n  * Particularly useful for uncovering security flaws that stem from the misuse of data, like buffer overflows or injection attacks.\n  * Helps in tracing how data moves through the system, which is crucial for understanding complex interactions and dependencies.\n  * Can identify inefficiencies in how data is processed, leading to opportunities for performance optimization.\n\nCons:\n\n  * Tracing data flow can be challenging, especially in large codebases with numerous data paths and interactions.\n  * Requires a detailed and thorough examination of how data is handled, manipulated, and transformed, which can be time-intensive.\n  * Focusing primarily on data flow can lead to overlooking issues related to control flow, such as logic errors or incorrect program sequencing.\n\n### Combining control-flow and data-flow code reviewing\n\nIn practice, both control-flow and data-flow reading modes are often used\ntogether during code review. Understanding how data is handled (data-flow) is\ncrucial for evaluating the logic and sequence of operations (control-flow).\nFor example, in a function with complex logic, you might use control-flow\nreading to understand the sequence of operations while simultaneously using\ndata-flow reading to see how data is manipulated throughout those operations.\nThis integrated approach provides a comprehensive understanding of the code,\nhelping to identify both logical errors and data-related issues.\n\n## Code Reading, Debugging and Program Understanding techniques\n\nWhile reviewing code, we can make use of general code reading, debugging and\nprogram comprehension techniques. In the following, I\u2019ll briefly highlight\nsome of the most useful techniques.\n\n### 5\\. Pattern Recognition\n\nDuring pattern recognition, the code reviewer uses mostly a top-down approach\nto identify common patterns in the code. Such patterns include design\npatterns, algorithmic patterns, or idiomatic expressions in the programming\nlanguage. Pattern recognition during code reviewing is helpful to create a\nmental model of the software system, but also to identify problems with the\nsoftware\u2019s architecture, or the design of algorithms.\n\nPros:\n\n  * Helps create a mental model of the code change and the structure of the code.\n  * Streamlines the review process and leads to more consistent review approaches even amongst different team members.\n  * Well suited to find problems within the software architecture or design.\n\nCons:\n\n  * Due to the focus on patterns, reviewers might overlook other problems.\n  * Using known and common patterns to judge code, can bias the reviewers and they might dismiss good, new approaches, just because they are not established yet.\n  * Reviewers need a broad knowledge of patterns and anti-patterns to look for.\n\n### 6\\. Cross-Referencing\n\nDuring cross-referencing, the code reviewer systematically reviews the\ndependencies and relationships between code elements, such as classes,\nfunctions or variables. This approach is suitable to understand the\ninterdependencies and also the impact change can have on the system. As manual\ncross-referencing is a tedious task, code reviewers can use tools to extract,\ndisplay or visualize this information. Most IDE\u2019s provide built-in tools that\nhelp with cross-referencing, which is also often used during code refactoring.\nThese tools build an index of all code elements and link them, which helps\nduring navigation.\n\nPros:\n\n  * Finds dependencies, and relationships and reveals how a change impacts the rest of the system.\n  * Allows the reviewer to build a deep understanding of the codebase, and the code change under review.\n  * Reviewers get a good understanding of the control flow and the data flow, thus allowing them to identify errors in execution and data manipulation.\n\nCons:\n\n  * If done manually, cross-referencing is tedious and error-prone.\n  * For larger code changes and systems might be overwhelming for the reviewer.\n  * Focusing too much on relationships and dependencies between artifacts can lead to overlooking other issues.\n\n### 7\\. Change-Impact Analysis\n\nDuring change-impact analysis, the reviewer gathers information to be able to\njudge how the code change will impact the rest of the system.\n\nWhile cross-referencing can be used as part of a change-impact analysis, a\nchange-impact analysis is broader and also involves analyzing more high-level\nartifacts, such as specifications, documentations to understand the impact of\nthe code change. A reviewer will normally start by understanding the rationale\nbehind the code change, and its description (top-down). Then, the reviewer\nwill identify affected components, analyze the dependency graph and assess the\nimpact of this change on the functionality of the overall system. During such\nan analysis the reviewer should also look at the impact on the test system:\ndoes it need tests to change, or the be added?\n\nPros:\n\n  * Discussions on the impact of code changes can improve the understanding a team has of the overall codebase.\n  * Allows to direct reviewing efforts towards impacted and high-risk parts of the codebase.\n  * Reduces the risk of introducing bugs or regressions.\n\nCons:\n\n  * Change impact analysis can be very time-consuming.\n  * The reviewer has to have already a good and deep understanding of the codebase to understand the impact.\n  * It can lead to analysis paralysis, because the reviewer cannot completely envision all potential\n\nimpacts of this code change, and is thus reluctant to approve it.\n\n### 8\\. Trace-Based Code Reading\n\nTrace-based reading, often used during debugging, involves following the\nexecution of code at runtime. The code reviewer can do this by stepping\nthrough the code in a debugger or by examining logs or output traces.\n\nMost code reviewers use a static control-flow approach to review code, instead\nof this dynamic code analysis technique, that focuses on understanding how the\ncode behaves at runtime.\n\nThis dynamic evaluation is useful when the code reviewer is puzzled by a\ncertain part of the program, or expects a bug. It allows us to understand the\nstate of the program at various points of execution, to track the sequence of\nfunction calls, and to observe changes in variable states over time.\n\nPros:\n\n  * Allows the review to see how the system behaves at runtime.\n  * Effective during diagnosing or evaluating \u201cpotential\u201d bugs and problems.\n  * Helps build a mental model of the code, thus helpful if the reviewer is unfamiliar with the system.\n  * Can help catch side effects or anomalies that cannot be found during a static inspection.\n  * Suitable for detecting performance problems.\n\nCons:\n\n  * Setting up the reviewer\u2019s system to run the code might be cumbersome and time-intensive.\n  * Might distract the reviewer from actually reviewing the source code.\n  * The review is limited to the scenarios the reviewer traces.\n\n## Academic Code Reading Techniques\n\nCode review techniques described in academic papers aim at making code reviews\nmore systematic. Those approaches detail exactly where a reviewer should look,\nthe order of inspection, and also which questions to ask and issues to look\nfor.\n\nI summarize the approaches into two types (abstract-driven and functionality-\ndriven) and only highlight aspects that help us to better design our own code\nreading and reviewing approaches.\n\n### 9\\. Abstract-Driven Code Reviews\n\nDuring abstract-driven code reading, the code reviewers read small pieces of\ncode, and write down their understanding of the code (aka create descriptions\nor specifications). Then, the reviewers compare the description they created\nwith the existing specification or documentation of the code. If there was a\nmismatch, they found a problem. To determine the order in which methods or\nfunctions are reviewed, academic approaches often use dependency information.\nCommonly, the reviewers are instructed to start with the methods that have the\nleast dependencies on the other parts of the systems. This is in line with the\nbottom-up code review style.\n\n### 10\\. Functionality or Use-Case-Driven Code Reviews\n\nAnother distinct set of reading techniques does not focus so much on the\nentities of the system (as described before), but rather on concrete use cases\nor functionality of the system. Here the aim is to check whether the code\nbehaves correctly. For that, the reviewer first has to define use cases, and\nthen inspect if the code implements the use cases correctly. This includes\ndesigning the preconditions for the use case, the success and failure\nconditions, and the exceptions. This approach reminds us of systematic testing\napproaches, whereby here the focus is on statically inspecting the code using\ncontrol-flow and data-flow reading techniques, and not on the dynamic\nexecution of the codebase.\n\nWant to learn more about the presented code review techniques and see them in\naction? Have a look at my member-only articles on code review techniques here,\nor sign up for a free remote learning session.\n\nThis article first appeared on https://awesomecodereviews.com. Last updated:\nMay 02, 2024\n\nWritten by Dr. Michaela Greiler who is obsessed with making code reviews your\nsuperpower. Learn more about her workshops.\n\n\u00a9 Michaela Greiler 2024. Built with \u2665 and Gatsby. Illustrations by ls.graphics\n\n", "frontpage": false}
