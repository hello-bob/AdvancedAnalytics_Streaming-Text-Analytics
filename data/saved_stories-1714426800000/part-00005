{"aid": "40199723", "title": "Version Skew", "url": "https://www.industrialempathy.com/posts/version-skew/", "domain": "industrialempathy.com", "votes": 1, "user": "tilt", "posted_at": "2024-04-29 15:39:32", "comments": 0, "source_title": "Version Skew", "source_text": "Version Skew\n\n# Version Skew\n\n7 minute read. 16 comments\n\nThere is a phrase that is very frequently used at Google and other big tech\ncompanies. It\u2019s a nice and short phrase. And the problem it describes is\nbroadly applicable to modern software engineering. Yet it doesn\u2019t seem to be\nused much outside of the Google diaspora, and there doesn\u2019t seem to be an\nalternative naming for the concept either. The phrase is version skew or for\nshort: skew.\n\nVersion skew happens when two or more distributed systems with a dependency\nbetween them get deployed\u2013and because their mutual deployment isn\u2019t atomic,\nthey temporarily operate at different versions.\n\nA more concrete example is: System A calls System B. A change is made to both\nsystems. Both systems get deployed. System B takes a long time to deploy while\nSystem A deploys in seconds. Most instances of System A are now newer than\nSystem B. If System A relies on System B having the new change, the\ndistributed system is now in a broken state.\n\nThis article describes 3 aspects of version skew:\n\n  * Examples of version skew\n  * Skew boundaries\n  * Skew management strategies\n\n## Examples of skew #\n\nThis sounds abstract and complicated but in practice it happens all the time.\nSome examples of version skew:\n\n### Frontend client skew #\n\nYou deploy a new version of your website. But some clients still have the old\nwebsite loaded. They might keep the browser tab open for days or even weeks.\nWhen these old clients make API calls to your backend, the backend needs to\ndeal with being compatible with these old clients.\n\nThe same problem can happen with native mobile apps\u2013only there some users\nmight have auto updates turned off, and may never even update the initial\nversion of their app.\n\n### Microservice skew #\n\nYou might develop a microservice architecture from a monorepo. The repo makes\nit appear like you could make consistent changes between the services in a\nsingle PR. E.g. you may add a new required field to an existing API. But in\npractice the services that depend on this API may not be deployed at the very\nsame time. Even if deployments are fast, they will take seconds, and within\nthese seconds existing clients may not yet include the new required field\nwhile hitting backends that do assume to receive it.\n\n### Configuration skew #\n\nSophisticated systems often have a way to deploy system configuration without\ndeploying new versions of the software itself. Typically, such configuration\nupdates are much faster than software updates.\n\nThis may lead to at least two types of problems:\n\n  * Software may receive configuration it cannot process yet (because the ability was introduced in a newer version.)\n  * Two systems that are actually running at exactly the same version may still run at varying configuration and hence behave in unexpected fashion.\n\n### Experiment or feature flag skew #\n\nAn important special case of configuration skew is experiment or feature flag\nskew. In this case two systems may again run at the same version, but\ncalculate a different set of feature flag values (either through a static set\nof configuration or some experiment system) for the given API call.\n\nConcretely, if system A calls system B, and both systems calculate the value\nfor the feature flag awesome_launch independently, then they might produce\ndifferent output such as that one system thinks the feature launched while the\nother system thinks it is still hidden.\n\n## Skew boundaries #\n\nSkew boundaries are the system boundaries between which some form of version\nskew may appear. Not all skew boundaries are created equal. Some explicitly\nmanage the possibility of skew while others may be extremely difficult to\nreason about. Some examples are:\n\n### Service API skew #\n\nExplicit APIs between services are the most obvious skew boundary.\nRespectively, these boundaries must be actively managed for skew. E.g. one may\nmandate that servers must never introduce new required fields into existing\nAPIs, because they must always assume that there are clients that don\u2019t yet\nknow they need to send this new field.\n\n### HTML skew #\n\nIn traditional AJAX programming it was common to load a bunch of HTML from the\nserver via an AJAX call, and then replace it within the current client.\nRespectively, an old client may load HTML produced by a much newer server.\nWhether this HTML is compatible with the old client is extremely difficult to\nreason about. The HTML might for example assume that the client has CSS for\nstyling (which it doesn\u2019t yet have) and the client may expect to find certain\nDOM elements with JavaScript which are no longer in the new HTML.\n\nHTML as a skew boundary is so difficult to reason about that one may likely\ndecide that the only way to manage this type of skew is by ensuring that it\nnever occurs.\n\n### Database schema skew #\n\nData at rest introduces special skew challenges as updating it's shape usually\ncannot done with any of the skew management strategies that apply to software\nsystems.\n\n  * In schemaful databases such as relational databases a schema change could roll into the database while there are still clients that cannot handle the new schema.\n  * Databases without a fixed schema may host data using logical schemas going back years of incremental changes. Clients may either need to be backward compatible with all versions that were ever deployed or may need to be backward compatible while migrations on existing data are running.\n\n## Skew management strategies #\n\nThere are a broad range of strategies (also called \"Push Safety\" at\nFacebook/Meta) to manage skew that come with varying trade-offs and\napplicability to various situations:\n\n### Version locking #\n\nIn some scenarios it may be possible for clients to explicitly require a\nserver to run at the exact version as themselves. E.g. there might be a\nrouting system that can route their API calls to servers at the desired\nversion. Naturally, this makes deployments substantially more complex if it is\npossible at all as it requires the underlying software system to be able to\nrun 2 or more versions of the same software system at production scale at the\nsame time.\n\nVercel's Skew Protection for deployments is an example of transparent version-\nlocking that eliminates skew between web clients and servers.\n\n### Be backward compatible #\n\nServers must never introduce new required fields in APIs until they know all\nclients are updated.\n\nProtocol buffers, which were carefully designed to allow managing version\nskew, have optional and required fields. Most mature teams will essentially\nmandate that it is not allowed to ever introduce required field into an\nexisting API.\n\nIn protocol buffers it is typically a safe operation to rename a field (there\nare implementation that serialize to human readable JSON which do not have\nthis property), because fields are identified by their ID in production. In\nJSON based APIs renaming a field is a non-backward compatible operation.\n\nRollback windows can help put a boundary on the maximum duration of require\nbackward compatibility. However, backward compatibility may be required for\nthe long-term if\n\n  * Clients cannot be easily or ergonomically forced to update (such as for web and native apps).\n  * The skew is against data that is stored at rest and cannot be easily updated to a new schema including because the newly expected data simply was never collected.\n\n### Be forward compatible #\n\nClients must never require that servers can process recently introduced API\nchanges.\n\nE.g. if an API introduces a new optional argument, then clients cannot assume\nthat the server will actually process it.\n\n### Rollback windows #\n\nOne may decide that servers or clients must never be reverted to an old\nversion after they have been in production for N days. That allows clients to\nreason about when it is safe to assume that a server has a certain capability\nthey rely on.\n\nThe backward and forward compatibility mandates mentioned above would then be\nlifted once a change has been deployed for the duration of the rollback\nwindow.\n\nA common pattern you see in teams using rollback windows is that\n\n  * an engineer would submit a PR that puts a certain behavior in place\n  * wait for it to be deployed\n  * wait for the duration of the rollback window\n  * and finally submit a second PR that relies on the change from the original PR.\n\nAmazon calls a variant of this strategy two-phase deployment.\n\n### Versioning #\n\nMaybe the most obvious skew management strategy is explicit versioning. E.g.\nin REST APIs it is common to include an explicit version string in the path\nname which allows the client to select the version of the API they are\ncompatible with. The main downside of explicit versioning is increased\nmaintenance cost of the varying versions.\n\n#### Example of versioning #\n\n  * POST /v0/user: An avatar picture originally was not required.\n  * POST /v1/user: It's an error to submit a new user without an avatar picture.\n\nOne benefit of versioning over relying purely on backwards compatibility is\nthat while an old version may tolerate certain missing information, the new\nversion can help engineers with proper error messages for missing data.\n\n### Arguments > flags #\n\nFeature flag skew can be avoided by mandating that if a feature flag modifies\nbehavior across multiple systems, then only the client must evaluate the flag.\n\nThe client then proceeds to change the behavior of the server by passing an\nargument to the API call that triggers the behavior of the feature flag,\nrather than reevaluating the feature flag on the server-side.\n\n## Summary #\n\nVersion skew is an everyday experience in software deployment and can lead to\nsubtle or not-so-subtle errors. Mature deployment strategies manage skew\nexplicitly through skew boundaries and skew management strategies that avoid\nskew altogether when possible, and which make the skew easy for humans to\nreason about when it cannot be avoided.\n\nAnd if you'd rather not deal with the problem yourself, checkout my recent\nproject Skew Protection which we shipped on Vercel and which can eliminate the\nproblem space by implementing version locking at the platform layer.\n\n# \ud83d\ude4f\ud83d\ude4f\ud83d\ude4f\n\nSince you've made it this far, sharing this article on your favorite social\nmedia network would be highly appreciated \ud83d\udc96! For feedback, please ping me on\nTwitter.\n\n# Comments #\n\n> Sebastian Markb\u00e5ge said: If you deploy frequently, your users might hit a\n> server that's not backwards compatible with your client code. Vercel\n> supports immutable deploys integrated with Skew Protection which lets you\n> still have a Server that can serve stale Clients. Thread\n\n> Theo - t3.gg said: Huge ship with the potential to significantly change how\n> we deploy code as an industry Thread\n\n> sunil pai, inc. said: omg holy grail feature Thread\n\n> Drake said: so much of what we struggle with in software development boils\n> down to communication and a lack of common vocabulary we need more\n> definition of terms like this to help bridge the gap and build awareness\n> Thread\n\n> Darian Moody said: This is the kind of innovation that Heroku could never.\n> Version Skew is a daily problem for any team releasing multiple times a day\n> (as most of us web folk should be!) Thread\n\n> Yaakov - \u05d9\u05e2\u05e7\u05d1 said: oh there are names for these things\n\n> Maciek Pekala said: We've implemented this for Pleo's tRPC+Lambda based\n> Backend-for-Frontend a while back. Good to see this problem solved by a\n> platform like Vercel and good to learn it has a proper name \ud83d\ude05\n\n> Hugo Dias said: It\u2019s nice to find a good name for something you\u2019ve been\n> doing for years! These are real-world challenges that you, as a developer,\n> need to deal with frequently. Great article, by the way \ud83d\udc4c\n\n> kemar said: \"Version Skew\" The mother of all backward compatible versions\n\n> Andy Ingram \ud83c\udf00 said: Context btw Thread\n\n> Sean Abraham said: Is that a typo in the graphic? Top right box says System\n> B when it looks like it should be System A Thread\n\n> Przemek Smyrdek said: If you're wondering how it's like to work on larger\n> distributed systems, here's a great article about common issues with\n> versioning:\n\n> Dom Sip said: I remember that in the past, 404s and temp version mismatches\n> had to be solved (and tested) using Service Worker and PWA complex logic in\n> about 2-4 sprints. The solution is so elegant! Thanks @vercel and @cramforce\n\n> chungwu said: So... If you were wondering, how can I know the React server\n> action I'm calling from the browser will still be there when the server gets\n> updated... The answer is more fancy infrastructure \ud83d\ude14\n\n> @edwinsf@sfba.social said: Isn't the API du jour to make them forward and\n> backward compatible to avoid version skew... I know that's not true at G\n> Thread\n\n> Nir Gilboa said: Awesome article! Thx for sharing!\n\nPublished 21 Jun 2023\n\nMalte Ubl RSS\n\n", "frontpage": false}
