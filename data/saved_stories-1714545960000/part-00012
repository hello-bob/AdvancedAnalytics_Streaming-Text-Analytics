{"aid": "40215981", "title": "Ash. The hidden champion of low-code tools", "url": "https://www.lukasender.at/ash-the-hidden-champion-of-low-code-tools/", "domain": "lukasender.at", "votes": 4, "user": "borromakot", "posted_at": "2024-04-30 20:35:02", "comments": 0, "source_title": "Ash. The hidden champion of low-code tools", "source_text": "Ash. The hidden champion of low-code tools\n\nLuke's Letters\n\nSign in Subscribe\n\n# Ash. The hidden champion of low-code tools\n\n#### Lukas Ender\n\nApr 30, 2024 \u2014 8 min read\n\nAsh. Harness the mystical power of (the) Elixir.\n\nNow bear with me. The title may be a little provocative to everyone who\nalready knows about Ash.\n\nI'm a software engineer at heart and I love to write code. As such, I found it\na little awkward, even daunting to see all to low-code or no-code tools\nemerging over the last few years.\n\n> Hey... this tool does many things of what I can do with my skills in just a\n> few clicks? \u2013 me (over and over again and will continue to ask this question\n> \ud83d\ude04)\n\nWell, yes. And that's a good thing because they add value. How? They remove\nfriction and do away with all the boilerplate and get you to solve problems\nfaster.\n\nAnd let me ask this: is there much value in writing yet another API endpoint\nby hand and dealing with all boilerplate code just to be able to simply\ncreate, read, update, or delete (CRUD) an entity in 2024?\n\nOf course, there exists many frameworks that try to deal with reducing\nboilerplate code and abstract away the repetitive stuff. Also, CRUD endpoints\nis only one piece of the solution. Having dealt with a couple different\nframeworks over the years myself, I haven't found a better one than Ash.\n\n> If the work doesn\u2019t require creativity, delegate it, automate it, or leave\n> it.\n>\n> \u2014 Naval (@naval) September 30, 2020\n\nThe harder the problem, the more creativity is required. You want to be able\nto focus on new problems that weren't solved before. If the problem was\nalready solved a thousand times before, then there is not much value in\nspending a lot of time to solve it again.\n\nYou need to be able to work on the parts that can't be solved by \"out of the\nbox\" solutions. With the right tools, you can focus on the most valuable parts\nof your work. On being creative and solving valuable problems. Delegate, or\nautomate the rest to other tools and services.\n\nAsh allows you to spend time on being creative. One of the biggest value\npoints of Ash lies in removing the boilerplate without locking you in. A\nframework should not lock you in and allow you to do anything you want and\nneed. It should help and support you, not stand in your way. That's exactly\nwhat Ash sets out to do and offers various nice ways that don't feel like a\n\"hack\", if you need a thing that isn\u2018t outright supported by Ash. This really\nis a strong selling point, but not the biggest one, in my opinion. Keep\nreading to find out what I think is the biggest one.\n\nYou don't have to deal with boilerplate code. You delegate most of the\n\"boring\" boilerplate code to the framework and spend your time on solving\nproblems were no \"out of the box\" solution exists. You can focus on the\ncreative, valuable problems.\n\nHow is this possible? That's quite a big topic in itself. But in short: Ash\nleverages two things perfectly.\n\n  * The power of Elixir itself. Elixir provides a very powerful macro system. You can write code, that will write code at compile time.\n  * It stands on top of giants, e.g. Ecto or Absinthe for GraphQL\n\nBy combining these two things, Ash provides powerful, yet extensive\nabstractions where you can describe what you want to do and let Ash figure out\nhow it should be done.\n\nSounds a little bit abstract, right? Let's get practical for a bit.\n\nIn many cases, you'll probably end up with around three files to build a\nsimple CRUD interface that can interact with an entity, leaving out any setup\nand configuration files. You'll always have those which roughly look and do\nthe same things in all languages and frameworks.\n\n  * An entity that describes what attributes a resources has; e.g. a contact that has a first_name and last_name\n  * A service, providing an API to interact with the resource; functions for create, read, update, and delete that either read or manipulate persisted data.\n  * A controller that exposes a REST or GraphQL API, using the service to interact with the resource.\n\nIt doesn't really matter what framework you'll use. Wether you'll use Phoenix\nand Ecto, Nest.js/Express.js and TypeORM. The implementation approximately\nends up as described above (plus some config files etc.) and you'll be writing\nthe boilerplate code to create a simple CRUD REST API yourself.\n\nWhat's more, you'll have to write this over and over again, for every entity\nand method/action you want to provide. And if you are like me, you'll come up\nwith new \"versions\" and implementation details for writing the next API\nendpoint. You've learned something new and want to apply it. Requirements may\nevolve over time. You'll have to refactor the existing code base so everything\nis aligned again. And that's just speaking of one single code base. When\nyou'll start the next project, you'll need to start all over again, and you'll\nprobably want to take all the learnings from the previous projects with you\nand add the in the new project as well.\n\nLet's see how this is different when using Ash. In the following gist, you'll\nsee a resource definition for the same entity as described above.\n\ndefmodule Example.Contact do  \n---  \n@moduledoc \"\"\"  \nContact information  \n\"\"\"  \nuse Ash.Resource,  \ndata_layer: AshPostgres.DataLayer,  \nextensions: [AshGraphql.Resource]  \nalias Example.ContactMergeWorkflow  \nattributes do  \nuuid_primary_key :id  \nattribute :first_name, :string  \nattribute :last_name, :string  \nend  \nactions do  \ndefaults [:create, :read, :update, :destroy]  \naction :merge, :string do  \nargument :target_contact_id, :uuid do  \nallow_nil? false  \nend  \nargument :duplicate_contact_id, :uuid do  \nallow_nil? false  \nend  \nrun(fn input, _context ->  \nContactMergeWorkflow.merge(  \ninput.arguments.target_contact_id,  \ninput.arguments.duplicate_contact_id  \n)  \nend)  \nend  \nend  \ngraphql do  \ntype :contact  \nqueries do  \nget :contact, :read  \nlist :contacts, :read  \nend  \nmutations do  \ncreate :create_contact, :create  \nupdate :update_contact, :update  \ndestroy :destroy_contact, :destroy  \naction :merge_contacts, :merge  \nend  \nend  \npostgres do  \nrepo Example.Repo  \ntable \"contact\"  \nend  \nend  \n  \nview raw contact.ex hosted with \u2764 by GitHub\n\nThat's about it. You describe your resource. What attributes it has. What Data\nLayer it uses (in this case, Postgres - more on this a little bit), what\nactions it provides, and how the actions will be exposed via GraphQL. At first\nglance, this doesn't look very different than in other frameworks (except\nmaybe for the Domain Specific Language). But lets stop and think for a second\nhere. You describe a resource. Everything else is taken care for you. You'll\nhave a working GraphQL API that allows you to interact with the resource. No\nboilerplate code to connect the GraphQL Layer with the service and the service\nwith the resource.\n\nThe example only shows some of the most basic CRUD options. Ash knows how to\ndeal with them out of the box. It\u2018ll accept attributes, create a changeset and\napplies the changes. You can do much more than just this. For example, you\nmight want to define your own create action that only accepts a subset of the\nattributes. Or, you may want to expose a read action that always applies a\ncertain filter, e.g. to provide an action that always returns the contact of\nthe logged-in user. If you need a completely customized action that doesn't\nstrictly fall into the typical CRUD methods you can add a \"generic\" action as\ndemonstrated by action :merge. It also shows you can provide a custom function\nimplementation. There's pretty much an option for every use case you'll\nencounter.\n\n\ud83d\udca1\n\nNow, like I said, I intentionally left out the config parts; e.g. connection\nsettings for Postgres and setup code for Ash GraphQL. I also did not cover\nmore advanced topics, like validations, calculations and changes.\n\nThis is what I call \"low code\". Look at all the code that I don't have to\nwrite anymore. That's amazing but there's more. Data Layers and APIs to\ninteract with your resources.\n\nAsh has a concept called Data Layer. Think of it as an abstraction layer for\nyour data stores you want to use. The most popular one probably is Ash\nPostgres. But there's also Ash.DataLayer.Ets, Ash Sqlite, Ash CSV. Or the\nAsh.DataLayer.Simple which won't persist any data. The cool thing about all of\nthis is: you only need to configure your resource to use one of the options.\nInteracting with your resources stays the same, no matter what Data Layer a\nresource uses. And that's because of the unified APIs that Ash provides. This\nallows for powerful options.\n\n\ud83d\udca1\n\nAsh provides a unified API for interacting with resources and their underlying\nData Layer. However, different Data Layers may differ in what features it\nactually supports. Imagine you want to build a Data Layer that interacts with\na REST API and the API does not offer a create method. It is up to the Data\nLayer implementation to decide what features are supported.\n\nModel your domain, derive the rest \u2013 ash-hq.org\n\nRemember that \"you'll probably want to take all the learnings from the\nprevious projects with you and add the in the new project as well\"?\n\nSince Ash is declarative and it derives the rest (i.e. the underlying\nimplementation), you'll get the best and latest version of an implementation\ndetail out of the box, every time, in every project. Your job is to describe\nhow a resource looks like. The underlying implementation is generated for you.\nIf someone finds a better way of a certain implementation, a new version of\nAsh is shipped and as soon as you'll upgrade, you'll profit. Most probably,\nyou won't even have to change anything except for upgrading the version in the\nmix.exs file.\n\nYou can also benefit from Ash's extensibility. You can either write your own,\nor use some of the existing extensions. The abstraction layers and unified\nAPIs allow for lots of possibilities. May it be simply defining your own base\nresources that always add \"audit attributes\", or creating your own Data Layer\n(e.g. in our business, we created a very simply version of a Hubspot Data\nLayer that allows to interact with a Hubspot CRM Contact).\n\nAnd last but not least, the community. It's bunch of very open, friendly and\nhelpful people \ud83e\udde1 When you find a bug, you'll report it and it might be fixed\nthe next day. Also, new ideas are very welcome and contributing to the project\nis generally pretty easy. Zach, the creator of Ash, has built something\nremarkable and is leading the project very beautifully. And it shows.\n\nNow that's a \"low-code\" tool to my liking:\n\n  * Reduce boilerplate. Describe and configure most. Let me focus on the most valuable parts\n  * No lock-in. Provide ways to achieve anything, if not already provided by Ash itself\n  * Provide ways to extend your resources and code base in general\n  * Active project development\n  * Helpful and buzzing community\n\nThis all may not fully show the true power of Ash. It is very hard to show, to\nbe honest. Every topic I covered here only shows the top of the iceberg and\nevery aspect might be worth its own post. Profiting from building with Ash is\nsomething you can feel best over time when using it yourself. Also, it's\nalways best to not simply trust someone blindly and try things for yourself.\nIt may not be the right approach for you to build apps and services after all.\nBut then again, it could also change the way you approach software\nengineering.\n\nIf I got you interested in checking out Ash, it's best to jump to the docs get\ngoing. There's also a Discord server with all the amazing people waiting to\nhelp you out or discuss the exciting projects you'll build!\n\nHappy (low) coding!\n\nA word of caution: this letter probably sounds like a love letter (it kind of\nis one). However, there's no magic software. Ditching everything you've built\nso far and replacing it with Ash may look like you\u2019ll soon be touching greener\ngras. It is very green over here. But it's definitely not a silver bullet that\nsolves all of your problems.\n\n## Read more\n\n### Exploring Basic Elixir Concepts and Real-Time Features by Implementing a\nBlock Clock\n\nI'm bullish on two technologies; Elixir and Bitcoin. Both are remarkable and\nbeautiful technologies. Today, I'd like to combine both topics in a simple\nElixir project to explore some of the concepts one will encounter when diving\ndeeper into Elixir.\n\nBy Lukas Ender Apr 2, 2021\n\n### 80/20\n\nSpend 20% of your time, to make the other 80% of your time more effective. No,\nthis will not be a piece about turning you into the ultimate human robot,\nsqueezing every second out of a task in order for you to cram ever more tasks\nin your schedule until\n\nBy Lukas Ender Mar 29, 2021\n\n### Leaving Something Great to Start Something New\n\nAfter roughly seven years, I'm leaving Lovely Systems to start something new.\n\nBy Lukas Ender Jan 1, 2021\n\n### The Antifragile Developer\n\nWhat if you could benefit from stress, chaos and disorder? On becoming\nantifragile as a developer.\n\nBy Lukas Ender Jun 16, 2020\n\nLuke's Letters\n\nPowered by Ghost\n\n## Luke's Letters\n\nBuilding and sharing value.\n\n", "frontpage": false}
