{"aid": "40220769", "title": "How to Solve It (With Raycasting)", "url": "https://alicegg.tech//2024/05/01/how-to-solve-it.html", "domain": "alicegg.tech", "votes": 1, "user": "zer0tonin", "posted_at": "2024-05-01 08:14:18", "comments": 0, "source_title": "How to solve it (with raycasting)", "source_text": "How to solve it (with raycasting)\n\nAlice GG\n\nPosted on May 1, 2024\n\n# How to solve it (with raycasting)\n\nIn 1945, mathematician George P\u00f3lya released the book \u201cHow to solve it\u201d. It\naims at helping math teachers guide their students into solving abstract\nproblems by asking the right questions. It has since had a large influence on\nmath education and computer science, to the point of being mentioned by Marvin\nMinksy as a book that everyone should know.\n\nIn this post, I will try to see how we can use P\u00f3lya\u2019s methodology to solve a\nconcrete software engineering problem: rendering 3D objects (using Golang).\n\n# Understanding the problem\n\nBefore starting to solve the problem, we must make sure that we completely\nunderstand the problem. The first question to ask ourselves is What is the\ndata?\n\nThe data is a 3D object. The object is made out of triangles. Each triangle is\nmade out of 3 vertices (and a normal vector). Those objects are stored in .STL\nfiles. I will parse them with the hschendel/stl lib.\n\nThe second question, which is probably the most important is What is the\nunknown?. Or in programming terms, What should the program output?\n\nOur program should output an image. An image is a 2D matrix of pixels, each\npixel representing a color. The most common way of representing color is the\nRGBA model, which stands for Red, Green, Blue, and Alpha. In Golang, images\ncan be represented using the image.Image data structure from the standard\nlibrary.\n\nThe third question is What is the condition (linking the data to the output)?\n\nThe data gives us information about the space occupied by our 3D object. If\nthe 3D object is in front of our pixel, this pixel should be in a different\ncolor. We will use the method known as \u201craycasting\u201d which consists of sending\na ray from each pixel, and checking what the ray hits.\n\n# Devise a plan\n\nNow that we have understood our problem a little bit better, we should try to\nplan what our solution will look like. The most helpful question to come up\nwith a solution is Do you know a related problem?\n\nRaycasting constists of sending a \u201cray\u201d for each pixel of our image. If this\nray intersects with our 3D object, the pixel needs to be updated to a\ndifferent color. Since our 3D object is made entirely out of triangle, a\nrelated problem would be Does a vector intersect with a triangle?\n\nTo solve this we can implement the M\u00f6ller\u2013Trumbore intersection algorithm.\nThis algorithm transforms the above problem into two new questions Does the\nray intersect with the triangle\u2019s plane? and if yes, Does the ray-plane\nintersection lie outside the triangle?\n\nThis first question is simple to solve, the only way a vector doesn\u2019t\nintersect with a plane is if the vector and plane are parallel. In that case,\nthe dot product of the ray and the triangle\u2019s normal vector would be zero,\nsince the dot product of two perpendicular vectors is 0 and the normal vector\nis itself perpendicular to the triangle\u2019s plane.\n\nIf the ray intersects with our triangle\u2019s plane, then we can check if the\nintersection is inside the plane by switching to barycentric coordinates.\nBarycentric coordinates are a way to represent a point in a plane in relation\nto the vertices of the triangle. Each corner of the triangle will get the\ncoordinates (0,0,1), (0,1,0) and (1,0,0). Any point outside of the triangle\nwill get coordinates outside of the range [0,1].\n\nVisualizing barycentric coordinates\n\nNow that we know an algorithm that can solve our main issue, we can come up\nwith the outline of our program:\n\n    \n    \n    func MTintersect(ray, triangle) bool { if isParallel(ray, triangle) { return false } u , v := projectBaryocentric(vec3, triangle) return u > 0 && u < 1 && v > 0 && u + v < 1 } func main () { solid := readSTL() image := newImage(width, height) for i := range width { for j := range height { image.Set(i, j, white) ray := castRay(i, j) for triangle := range solid.Triangles { ok := MTintersect(ray, triangle) if ok { image.set(i, j, blue) } } } } writePNG(image) }\n\n# Carrying out the plan\n\nThis is the easy part. We just write the code.\n\nThe main suggestion that P\u00f3lya makes, is to check that every step of the\nsolution is correct. While programming, this can be achieved by writing unit\ntests to ensure the correctness of our code.\n\n# Looking back\n\nOnce we have something that seems to work it is tempting to just git push and\ncall it a day. But there are a few more questions we should ask ourselves.\n\nFirst Can we check the result?\n\nA good way to answer that is to test our program ourselves, either by manually\ngoing through a checklist or by writing an integration test that covers our\nproblem.\n\nResults of rendering a few .stl files\n\nThen we should ask ourselves Can we derive the result differently?\n\nThis question is not only a good way to learn about other ways to solve our\nproblem (like Scanline rendering in our case) but also a good opportunity to\ncheck if maybe the code we wrote was not the most intuitive solution and could\nbe refactored.\n\nThe last question is Can you use the result for another problem?\n\nWe can answer this question by checking if our code is written in a way that\nis reusable enough if we ever want to. For example, the raycaster above could\nbe used as the first step into the implementation of a more sophisticated ray\ntracing algorithm, if we wanted to handle reflections and lightning.\n\n# Conclusion\n\nIf you want to check the source code for the raycaster I made before writing\nthis article, it is on my GitHub.\n\nYou can find How to solve it by P\u00f3lya in any good library.\n\nTo learn more about computer graphics check out Ray Tracing in a weekend. And\nfor the details of the M\u00f6ller-Trumbore algorithm, this video is the one that\nmade the most sense to me.\n\nPrevious entry A love letter to Apache Echarts\n\n## Alice GG \u2022 Table of Contents\n\n  * Alice GG\n  * hi@alicegg.tech\n\n  * GitHub\n  * LinkedIn\n  * Mastodon\n  * Twitter\n\nAlice Girard Guittard, Software Engineer and Co-Founder at Tsukumogami\nSoftware, passionate about Software, DevOps and Information Security.\n\n", "frontpage": false}
