{"aid": "40104342", "title": "Antithesis Is Not Enough", "url": "https://seelengrab.github.io/articles/Antithesis%20is%20not%20enough/", "domain": "seelengrab.github.io", "votes": 4, "user": "Sukera", "posted_at": "2024-04-21 09:35:44", "comments": 0, "source_title": "Antithesis is not enough", "source_text": "Antithesis is not enough\n\nVoyage:Antithesis is not enough\n\n  * PBT\n  * Determinism\n  * Antithesis\n  * Supposition.jl\n  * testing\n  * julia\n\n# Antithesis is not enough\n\nOver the past few weeks, Antithesis has been all the rage in the tech world,\nespecially on HackerNews. The proposition (though not the execution) is\nsimple: A deterministic hypervisor to aid in debugging of so-called\nHeisenbugs, i.e. bugs that happen due to nondeterministic effects of OS\nscheduling, I/O times etc. In this article, we're going to take a short look\nat what this enables in terms of debugging, and why the properties of such a\ndeterministic hypervisor alone are not enough.\n\nThat being said, I haven't used Antithesis, so this article may be inaccurate\nin some places. Most of what I could gather about how it works is from their\nblog posts and marketing material (which is hopefully accurate) and comparing\nthat to my experience from writing Supposition.jl, a property based testing\nframework for Julia.\n\n## Determinism in Testing\n\nBefore we get to concrete difficulties, let's first take a small detour about\ndeterminism in testing, with examples using Supposition.jl. The example I'm\nusing in this section is based on the talk Property-testing async code in Rust\nto build reliable distributed systems by Antonio Scandurra. If you're already\nfamiliar with Antithesis and/or deterministic property based testing, you can\nprobably skip this bit. If you're interested in the full example code I'm\nusing here, see this gist.\n\nSo, why is determinism for testing a big deal? Simply put, without determinism\nyou have to be lucky while debugging rare failures. EXTREMELY lucky. Not only\ndoes someone/some CI job have to hit your specific bug, but without\ndeterminism you'll often have a hard time reproducing the failure, slowing\ndown a potential fix immensely. Let's look at an example:\n\n    \n    \n    function run_test(exe::Executor) t = @spawn exe begin @debug \"Starting test\" l = ReentrantLock() data = Ref(0) future1 = @spawn exe begin @debug \"Future 1 scheduled\" @lock l begin if data[] == 0 data[] += 1 end end @debug \"Done with 1!\" end future2 = @spawn exe begin @debug \"Future 2 scheduled\" @lock l begin if data[] == 1 data[] += 1 end end @debug \"Done with 2!\" end wait(future1) wait(future2) @debug \"Done with subtasks!\" @lock l begin data[] end end res = @something block_on(exe, t) Some(nothing) res == 2 end\n\nThis is a very small function making use of the asynchronous runtime used in\nJulia, with some small abstractions sprinkled on top to allow for custom Rust-\nlike executors to be passed in. The task is to spawn two futures and increment\na shared mutable object that's being protected by a lock if some condition is\nfulfilled. The first future only increments if the data is zero, while the\nsecond only increments if the data is one. Finally, we check that the ultimate\nresult is 2, i.e. we expect future1 to execute first, followed by future2.\n\nThis code has a race condition - if future2 executes before future1 does, we\nonly end up with data holding 1 (incremented by future1). There's two ways to\nschedule the two futures, so we'd expect the test to fail 50% of the time.\nHowever, that's not what happens - if we pass in a BaseExecutor (a Rust-like\nexecutor that just falls back on the default Julia runtime), we get very\nconsistent results:\n\n    \n    \n    julia> count( run_test(BaseExecutor()) for _ in 1:1_000 ) 994\n\nOut of 1000 executions, 994 returned true - i.e., almost all executions just\nhappened to schedule the two futures in the \"happy\" order, avoiding the race\ncondition. future1 executed first, incrementing the shared state to 1,\nfollowed by future2, incrementing the shared state to 2. Only a tiny fraction\nof executions managed to hit the race condition! What's worse is that running\nthe test locally is also just as unlikely to produce that failure:\n\n    \n    \n    julia> run_test(BaseExecutor()) true julia> run_test(BaseExecutor()) true julia> run_test(BaseExecutor()) true julia> run_test(BaseExecutor()) true julia> run_test(BaseExecutor()) true\n\nOf course, this is a tiny and artificial example, but these kinds of rare\nfailures are exactly the kinds of heisenbugs that are difficult to debug when\nthey do occur. Note how there is no I/O or even randomness involved - the only\nvariable is the order futures are scheduled in.\n\nWe can do slightly better if we use a deterministic scheduler:\n\n    \n    \n    julia> count( run_test(ConcurrentExecutor(i)) for i in 1:1_000 ) 465\n\nIn contrast to BaseExecutor (which just spawns the future eagerly and blocks\nas usual), ConcurrentExecutor takes a seed value and randomly schedules tasks\nbased on that, instead of a naive FIFO. This is already much better; we get a\nroughly 50% failure rate, which is exactly what we expected to get in the\nfirst place! Moreover, because the scheduling decisions are purely based on\nthe seed, any individual failure is tied to precisely that seed, so we can\nalways perfectly reproduce any given failure:\n\n    \n    \n    # find any failure julia> findfirst( !run_test(ConcurrentExecutor(i)) for i in 1:1_000 ) 2 julia> run_test(ConcurrentExecutor(2)) false julia> run_test(ConcurrentExecutor(2)) false julia> run_test(ConcurrentExecutor(2)) false\n\nEager async\n\nUnlike async in Rust, async code in Julia (through the most commonly used\nAPIs) is executed eagerly, and there's no callback possible to hook into for\nwhen a future yields to the runtime (which is necessary for controlling re-\nscheduling). As such, more complicated examples involving I/O or actual\nreliance on parallel execution of spawned tasks quickly fall apart, which is\nwhy I haven't released these Rust-like executors as a standalone package.\n\nThis is a situation where Antithesis can help, because it makes the underlying\nscheduling decisions reproducible within Antithesis, even for BaseExecutor. If\nsuch a failure occurs in Antithesis-hosted CI, you can at least reproduce it\nin a local Antithesis instance. Of course, this doesn't help at all if a\nfailure occurs on the machine of a user, where you're not necessarily running\nunder a deterministic OS. Moreover, determinism by itself doesn't make it more\nlikely to encounter a failure; for that you need some kind of \"malicious\"\nscheduler like ConcurrentExecutor that actively tries to induce these kinds of\nfailures in a deterministic way. If you have such a deterministic executor in\nyour application, you have a much better chance at reproducing failures\nlocally when they're only occuring on some OS/hardware of your customers.\n\n## Shrinking Examples\n\nOk, so much for asynchronous code, but surely the situation is better when it\ncomes to synchronous code, right? Well.. to answer that, we'll have to learn\nabout what \"shrinking\" is when it comes to property based testing.\n\nSimply put, \"shrinking\" refers to the process of transforming some (possibly\nlarge) input that causes a test failure into a smaller input that causes the\nsame failure. For instance, for the property iseven, any odd number results in\na failure/returning false. This can be 7, 99, 23456721 or any other odd\nnumber. Property based testing libraries take that input and (depending on\ntheir design) \"shrink\" that input to a smaller example. In this case, we'd\nlikely end up with 1:\n\n    \n    \n    julia> using Supposition julia> data = Any[]; # store the failures somewhere julia> function shrinkExample(p) iseven(p) && return true # record failures in our memory push!(data, p) false end shrinkExample (generic function with 2 methods) julia> @check db=false shrinkExample(Data.Integers{UInt8}()); \u250c Error: Property doesn't hold! \u2502 Description = \"shrinkExample\" \u2502 Example = (0x01,) \u2514 @ Supposition ~/Documents/projects/Supposition.jl/src/testset.jl:292 Test Summary: | Fail Total Time shrinkExample | 1 1 0.0s julia> data 6-element Vector{Any}: 0x17 0x0b 0x05 0x03 0x03 0x01\n\nThe initial failure was 0x17 (or 23 in decimal) and successfull shrinks\nreduced the input to 0x01 (or just 1 in decimal), which is a minimal\ncounterexample for iseven on UInt8.\n\nComplexity\n\nThis example is purposefully simple - Supposition.jl can do much more complex\nshrinks of composite objects out of the box. Check out the documentation if\nyou're interested!\n\nFor such a simple property, shrinking was straightforward. The statespace of\nthe input is relatively small (just 256 states), and half of those will result\nin a failure. However, even slightly more complicated examples will give much\nworse results (through no fault of the shrinking process). For example,\nconsider this function that checks whether the third element in a random\nvector is not 0x5:\n\n    \n    \n    function third_is_not_five(v) # we can assume `v` has at least 5 elements, fill those with random data v .= rand(UInt8, 5) v[3] != 0x5 end\n\nWe can run this for a number of inputs and see that this property does fail\nevery so often, albeit inconsistently:\n\n    \n    \n    julia> findfirst(!third_is_not_five(rand(UInt8, 5)) for _ in 1:10_000 ) 409 julia> findfirst(!third_is_not_five(rand(UInt8, 5)) for _ in 1:10_000 ) 423 julia> findfirst(!third_is_not_five(rand(UInt8, 5)) for _ in 1:10_000 ) 741\n\nIf we now try to find a counterexample with Supposition.jl, we find something\nintriguing:\n\n    \n    \n    julia> using Supposition # generate random `Vector{UInt8}` with 5 elements julia> vec = Data.Vectors(Data.Integers{UInt8}();min_size=5,max_size=5); julia> @check third_is_not_five(vec); \u250c Error: Property doesn't hold! \u2502 Description = \"third_is_not_five\" \u2502 Example = (UInt8[0x00, 0x00, 0x00, 0x00, 0x00],) \u2514 @ Supposition ~/Documents/projects/Supposition.jl/src/testset.jl:292 Test Summary: | Fail Total Time third_is_not_five | 1 1 0.0s\n\nSupposition.jl finds the minimum input - it's completely filled with 0x0! This\nmakes sense, because we're replacing the contents of the vector we're putting\ninto third_is_not_five with random data, and only then check whether the\nproperty holds. We can record that data with event!, and inspect it in the\nfinal report afterwards:\n\n    \n    \n    julia> @check function third_is_not_five(v=vec) v .= rand(UInt8, 5) event!(\"ACTUAL DATA\", v) v[3] != 5 end; Events occured: 1 ACTUAL DATA UInt8[0xf7, 0x46, 0x05, 0x71, 0x1e] \u250c Error: Property doesn't hold! \u2502 Description = \"third_is_not_five\" \u2502 Example = (v = UInt8[0x00, 0x00, 0x00, 0x00, 0x00],) \u2514 @ Supposition ~/Documents/projects/Supposition.jl/src/testset.jl:292 Test Summary: | Fail Total Time third_is_not_five | 1 1 0.0s\n\nAnd now we can see that indeed, the third element of the actual data we're\nchecking is 0x05. Unfortunately, all of the other data is a jumbled mess, and\nSupposition.jl did seemingly nothing to shrink that. This is not quite true -\nSupposition.jl is able to reproduce that exact failure again if we rerun the\ntest:\n\n    \n    \n    julia> @check third_is_not_five(vec) Events occured: 1 ACTUAL DATA UInt8[0xf7, 0x46, 0x05, 0x71, 0x1e] \u250c Error: Property doesn't hold! \u2502 Description = \"third_is_not_five\" \u2502 Example = (UInt8[0x00, 0x00, 0x00, 0x00, 0x00],) \u2514 @ Supposition ~/Documents/projects/Supposition.jl/src/testset.jl:292 Test Summary: | Fail Total Time third_is_not_five | 1 1 0.0s\n\nThe problem is that the relationship between the RNG object used by rand (a\nXoshiro256++, for the curious) and that test failure is quite complicated. For\nany individual invocation of rand(UInt8), we'd expect to get 0x05 with a\nprobability of 1/256. For the 10_000 examples Supposition.jl tries by default,\nwe'd expect to see a five 39 times, which is quite rare. In total, there are\n256^5 different Vector{UInt8} of length 5, and only 256^4 of those have a 5 in\nposition 3. Supposition.jl does control the seed of the RNG object, but\nfiguring that relationship out while also shrinking data is, by the nature of\nXoshiro256++ being a good PRNG, very difficult. The relationship between the\nseed and values in the vector is highly nonlinear, and there may not even be a\nseed that produces the minimal example at all!\n\nAntithesis & Meta knowledge\n\nFor Antithesis, this is a problem - from what I could gather, it has no such\n\"meta knowledge\" about the data an application generates, so it must\nimmediately run into the same problems Supposition.jl runs in when we just\ngenerate some data with rand. The people behind Antithesis know this, which is\nwhy their talk about running Super Mario focuses most of its time on how a\nprogrammer can guide Antithesis towards \"better\" executions that get Mario\nfarther into levels, as well as on how to model Super Mario in such a way as\nto make it likely to hit good inputs.\n\nOf course, if we don't rely on the randomness of rand directly but instead\ncheck the generated vector, Supposition.jl has no problems to minimize the\nexample as far as possible:\n\n    \n    \n    julia> @check function third_is_not_five(v=vec) event!(\"ACTUAL DATA\", v) v[3] != 5 end; Events occured: 1 ACTUAL DATA UInt8[0x00, 0x00, 0x05, 0x00, 0x00] \u250c Error: Property doesn't hold! \u2502 Description = \"third_is_not_five\" \u2502 Example = (v = UInt8[0x00, 0x00, 0x05, 0x00, 0x00],) \u2514 @ Supposition ~/Documents/projects/Supposition.jl/src/testset.jl:292 Test Summary: | Fail Total Time third_is_not_five | 1 1 0.0s\n\nThis is because Supposition.jl has much more knowledge about the vector it\ngenerated itself than is known just from the seed of the RNG. This additional\nstructure allows it to shrink properly and more targeted than if it had to\nshrink purely through an RNG seed.\n\nThis too is not a panacea though - if we put in 64-bit UInt instead of 8-bit\nUInt8, the test passes even for a million random inputs:\n\n    \n    \n    julia> uint_vec = Data.Vectors(Data.Integers{UInt}();min_size=5,max_size=5); julia> @check db=false max_examples=1_000_000 function third_is_not_five(v=uint_vec) event!(\"ACTUAL DATA\", v) v[3] != 5 end; Test Summary: | Pass Total Time third_is_not_five | 1 1 1.9s\n\nAnd still the same for ten million inputs:\n\n    \n    \n    julia> @check db=false max_examples=10_000_000 function third_is_not_five(v=uint_vec) event!(\"ACTUAL DATA\", v) v[3] != 5 end; Test Summary: | Pass Total Time third_is_not_five | 1 1 18.6s\n\nThis once again comes back around to probabilities. With UInt, it's\nexceedingly unlikely to hit exactly 5 in the third position at all, so\nSupposition.jl never encounters a counterexample it could shrink. The\nprobabilities for hitting e.g. data races or otherwise extremely rare failures\njust get worse as programs & their statespaces grow larger. There are some\ntechniques you can use to help Supposition.jl along (e.g. nudging the\ngeneration process in a certain direction with target!), but those come at the\ncost of requiring quite a lot of domain specific knowledge to use correctly.\n\n## Conclusion\n\nThe people behind Anthithesis are well aware of these problems, which is why\nthey're not just selling a deterministic hypervisor, but also an API to give\nguidance for debugging. A brief look at the SDKs suggest that they're very\nbare bones for now, and don't seem to provide any shrinking capability of\ntheir own (though some comments on HackerNews suggest that the Antithesis team\nis actively working on that, so this will probably improve with time).\n\nThat said, there's also the fact that a deterministic OS gives you much more\nthan just scheduling reproducibility, such as deterministic RAM contents and\nI/O timing (up to a minimum the operation takes, I guess?), which may be\nimmensely helpful for some failures in e.g. code you as a developer don't have\ncontrol over. This, combined with active fault injection is already a huge\nboon, but as shown above, having a way to produce any fault is not sufficient\nfor producing good faults.\n\nMy gut feeling is that running deterministic property based tests inside of a\nsystem like Antithesis is a good idea. Even better if you can leverage\ndeterminism in your actual application as well, e.g. by using a deterministic\nscheduler/executor to allow exact reproducibility of issues encountered by\nyour users. Even with those capabilities, just running/testing your\napplication under Antithesis (while undoubtedly helpful & a good idea) doesn't\nremove having to think carefully about how & where to ensure your application\nhas the properties you want it to have.\n\nIn terms of testing & reliability overall, these are certainly amazing\ndevelopments. The future of testing is very exciting, and I hope more people\nuse this approach over conventional testing!\n\nCC BY-SA 4.0 Sukera. Last modified: April 21, 2024.\n\nWebsite built with Franklin.jl, the Julia programming language and \u2665!\n\n", "frontpage": false}
