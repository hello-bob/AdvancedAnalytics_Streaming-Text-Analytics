{"aid": "40221153", "title": "Hijack DLLs Through Proxying", "url": "https://www.carlos-menezes.com/post/dll-hijacking", "domain": "carlos-menezes.com", "votes": 1, "user": "thunderbong", "posted_at": "2024-05-01 09:29:27", "comments": 0, "source_title": "Hijack DLLs through proxying - Carlos Menezes", "source_text": "Hijack DLLs through proxying - Carlos Menezes\n\nCarlos Menezes\n\nhome/\n\nposts\n\nMay 01, 2024\n\n# Hijack DLLs through proxying\n\nHijacking the execution flow of a binary by reexporting methods of a DLL it\nloads on it's startup procedure.\n\n# Contents\n\n  * Introduction\n  * DLL hijacking in a nutshell\n\n    * Finding which DLLs the game loads\n  * Crafting a DLL\n\n    * Retrieving exported functions\n    * Creating pragmas\n    * Putting it all together\n\n# Introduction\n\nI delved into this topic because I wanted to create an ASI Loader for Grand\nTheft Auto: San Andreas. An ASI Loader, broadly speaking, enables the loading\nof custom libraries with the .asi extension into the game process. During game\nstartup, the loader scans the game's root folder and loads all the files with\nthe corresponding extensions, typically standard dynamic libraries (.dll) with\nrenamed extensions. Injected DLLs into a process is a fairly easy process if\nyou use an injector (i.e. Extreme Injector), but that quickly becomes\nunpractical if you want to (automatically) load multiple DLLs into a process.\n\n# DLL hijacking in a nutshell\n\nA DLL is a library housing both code and data, accessible by multiple programs\nconcurrently. Leveraging a DLL allows for the modularization of a program into\ndistinct components, thereby enhancing its load time due to the separate\nmodule loading. When a binary executes on a Windows system, it may actively\nload functions and data from various DLLs during it's lifetime. DLL hijacking\ninvolves replacing a legitimate DLL with a another one, thereby intercepting\nthe binary's execution flow. DLL proxying constitutes a form of DLL hijacking,\nwherein a genuine DLL, such as bar.dll, is renamed to bar1.dll. Subsequently,\na DLL is introduced in place of bar.dll, bearing identical exported functions\nas bar1.dll. After the DLL is hijacked, the sequence of events when a program\nfoo.exe invokes an exported function (such as ExportedFunction) from bar.dll\nunfolds as follows:\n\n  1. bar.dll gets loaded into the calling process and it's code is executed;\n  2. bar.dll forwards the call to ExportedFunction to bar1.dll;\n  3. bar1.dll executes ExportedFunction.\n\nBroadly speaking, the following diagram illustrates the execution flow of a\nprogram before and after the DLL is hijacked:\n\n## Finding which DLLs the game loads\n\nThe first part of this process is finding a DLL to hijack. You could do guess\nwork or use a debugger to view what DLLs are loaded, but I've opted for\nSysinternals Procmon, \"an advanced monitoring tool for Windows that shows\nreal-time file system, registry and process/thread activity\". Procmon accepts\na list of display filters which allows you to filter the noise of the output.\nFor this particular case, I want to include the following filters:\n\n  * PROCCESS NAME IS gta_sa.exe INCLUDE (only output logs for the gta_sa.exe process)\n  * PATH ENDS WITH .dll INCLUDE (only output logs where the path of the object subject to an operation ends in .dll)\n  * PATH EXCLUDES <gta_sa.exe location> EXCLUDE (only output logs where the path for the DLL is in the same folder as gta_sa.exe)\n\nGiven these filters and upon launching gta_sa.exe, you will see this output in\nProcmon (enlarged): We see that eax.dll and vorbis.dll are successfully loaded\nfrom the game's folder. One of these may very well be our target: we'll go for\nvorbisFile.dll.\n\n# Crafting a DLL\n\nThe Visual Studio IDE has a template for creating DLLs. If you start a new\nproject with said template, the generator will create a dllmain.cpp file in\nthe root directory. We won't do much with it for now, but it's a good start.\n\n## Retrieving exported functions\n\nThere are countless programs which will take a look at a DLL and tell you\nwhich functions it exports (to put it briefly, these programs parse the EAT,\nthe Export Address Table, of a DLL file which follows the PE Format). I used\nDLL Export Viewer from Nirsoft. The executable allows one to export into an\nHTML file the exported functions from a DLL. Loading vorbisFile.dll into the\nprogram yields the following output: If you go into View -> HTML Report - All\nFunctions, you will be presented with an HTML file which lists all the\nexported functions in tabular form:\n\n## Creating pragmas\n\nWe'll need to export each of these functions in our very own DLL. Otherwise,\nwhen the binary (i.e. gta_sa.exe) tries to call a function from\nvorbisFile.dll, that function won't be found in our DLL, resulting in the\nbinary crashing. To achieve that, we'll use comment pragma. We're interested\nin the linker + exclude combo. To put it briefly, for every exported function,\nwe'll need to add this line in our DLL template:\n\n    \n    \n    #pragma comment(linker,\"/export:<function_name>=<filename>.<function_name>,@<ordinal>\")\n\nBecause this is a tedious process, I created a Python script which operates on\nthe file above (which you must save to your machine). It requires Beautiful\nSoup and Python 3.x. I'm going to rename vorbisFile to vorbisFileHooked:\n\n    \n    \n    from bs4 import BeautifulSoup import os def main(): page = open('./vf.html') # replace this with the file name soup = BeautifulSoup(page.read(), 'html.parser') # Find all the rows in the table rows = soup.find_all('tr') for row in rows: # Extract the function name, dll_orig, and ordinal data = row.find_all('td') if len(data) == 0: print(\"len 0\") continue data = [t.getText().replace('<td bgcolor=\"#FFFFFF\" nowrap=\"\">', '').replace('</td>', '') for t in data] function_name = data[0] ordinal = data[3].split(\" \")[0] full_path = data[5] filename_with_ext = os.path.basename(full_path) filename_without_ext = os.path.splitext(filename_with_ext)[0] dll_orig = \"%sHooked\" % filename_without_ext # vorbisFile --> vorbisFileHooked # Format the extracted data into the desired output format output = \"#pragma comment(linker,\\\"/export:%s=%s.%s,@%s\\\")\" % (function_name, dll_orig, function_name, ordinal) print(output) if __name__ == '__main__': main()\n\nQuickly after, the output is spit:\n\n    \n    \n    #pragma comment(linker,\"/export:ov_bitrate=vorbisFileHooked.ov_bitrate,@1\") #pragma comment(linker,\"/export:ov_bitrate_instant=vorbisFileHooked.ov_bitrate_instant,@2\") #pragma comment(linker,\"/export:ov_clear=vorbisFileHooked.ov_clear,@3\") ... #pragma comment(linker,\"/export:ov_time_total=vorbisFileHooked.ov_time_total,@34\")\n\n## Putting it all together\n\nTo prove that the DLL hijacking worked, we'll show a message box with the text\n\"Hello from the not-so-original vorbisFile.dll\" when it is injected into\ngta_sa.exe and then resume the normal, expected execution flow. If we paste\nthe output generated from the step above into dllmain.cpp (after every\ninclude) and make the change to display the message box, this is how the\nsource should look:\n\n    \n    \n    #include <windows.h> #pragma comment(linker,\"/export:ov_bitrate=vorbisFileHooked.ov_bitrate,@1\") #pragma comment(linker,\"/export:ov_bitrate_instant=vorbisFileHooked.ov_bitrate_instant,@2\") #pragma comment(linker,\"/export:ov_clear=vorbisFileHooked.ov_clear,@3\") // All the other pragmas #pragma comment(linker,\"/export:ov_time_total=vorbisFileHooked.ov_time_total,@34\") BOOL APIENTRY DllMain ( HMODULE hModule, DWORD ul_reason_for_call, LPVOID lpReserved) { if (ul_reason_for_call == DLL_PROCESS_ATTACH) { MessageBoxW(NULL, L\"Hello from the not-so-original vorbisFile.dll\", L\"carlos-menezes.com\", 0); } return TRUE; }\n\nCompile for the 32-bit architecture and rename the build artifact to\nvorbisFile.dll (a). In the root folder, rename the original vorbisFile.dll to\nvorbisFileHooked.dll. Copy (a) into the root folder. Now, when we run\ngta_sa.exe:\n\nI went on and implemented sa-asi-loader using this very same technique and it\nworks flawlessly, loading mods like the Windowed Mode mod with no issues.\n\nTags: windows, systems\n\n\u00a9 2024 carlos-menezes.com\n\n[top]\n\n", "frontpage": false}
