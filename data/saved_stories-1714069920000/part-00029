{"aid": "40156078", "title": "Ray Tracing in Mojo", "url": "https://docs.modular.com/mojo/notebooks/RayTracing", "domain": "modular.com", "votes": 1, "user": "peter_d_sherman", "posted_at": "2024-04-25 11:23:31", "comments": 0, "source_title": "Ray tracing in Mojo", "source_text": "Ray tracing in Mojo | Modular Docs\n\nSkip to main content\n\nMax PlatformDocsCompanyBlogModCon\n\nMax PlatformDocsCompanyBlogModCon\n\nContact salesSign in\n\n# Ray tracing in Mojo\n\nThis tutorial about ray tracing is based on the popular tutorial\nUnderstandable RayTracing in C++. The mathematical explanations are well\ndescribed in that tutorial, so we'll just point you to the appropriate\nsections for reference as we implement a basic ray tracer in Mojo.\n\n## Step 1: Basic definitions\n\nWe'll start by defining a Vec3f struct, which will use to represent a vector\nin 3D space as well as RGB pixels. We'll use a SIMD representation for our\nvector to enable vectorized operations. Note that since the SIMD type only\nallows a power of 2, we always pad the underlying storage with a 0.\n\n    \n    \n    from math import rsqrt\n    \n    @register_passable(\"trivial\") struct Vec3f: var data: SIMD[DType.float32, 4]\n    \n    @always_inline fn __init__(x: Float32, y: Float32, z: Float32) -> Self: return Vec3f {data: SIMD[DType.float32, 4](x, y, z, 0)}\n    \n    @always_inline fn __init__(data: SIMD[DType.float32, 4]) -> Self: return Vec3f {data: data}\n    \n    @always_inline @staticmethod fn zero() -> Vec3f: return Vec3f(0, 0, 0)\n    \n    @always_inline fn __sub__(self, other: Vec3f) -> Vec3f: return self.data - other.data\n    \n    @always_inline fn __add__(self, other: Vec3f) -> Vec3f: return self.data + other.data\n    \n    @always_inline fn __matmul__(self, other: Vec3f) -> Float32: return (self.data * other.data).reduce_add()\n    \n    @always_inline fn __mul__(self, k: Float32) -> Vec3f: return self.data * k\n    \n    @always_inline fn __neg__(self) -> Vec3f: return self.data * -1.0\n    \n    @always_inline fn __getitem__(self, idx: Int) -> SIMD[DType.float32, 1]: return self.data[idx]\n    \n    @always_inline fn cross(self, other: Vec3f) -> Vec3f: var self_zxy = self.data.shuffle[2, 0, 1, 3]() var other_zxy = other.data.shuffle[2, 0, 1, 3]() return (self_zxy * other.data - self.data * other_zxy).shuffle[ 2, 0, 1, 3 ]()\n    \n    @always_inline fn normalize(self) -> Vec3f: return self.data * rsqrt(self @ self)\n\nWe now define our Image struct, which will store the RGB pixels of our images.\nIt also contains a method to convert this Mojo struct into a numpy image,\nwhich will be used for implementing a straightforward displaying mechanism. We\nwill also implement a function for loading PNG files from disk.\n\nFirst install the required libraries:\n\n    \n    \n    %%python from importlib.util import find_spec import shutil import subprocess\n    \n    fix = \"\"\" ------------------------------------------------------------------------- fix following the steps here: https://github.com/modularml/mojo/issues/1085#issuecomment-1771403719 ------------------------------------------------------------------------- \"\"\"\n    \n    def install_if_missing(name: str): if find_spec(name): return\n    \n    print(f\"{name} not found, installing...\") try: if shutil.which('python3'): python = \"python3\" elif shutil.which('python'): python = \"python\" else: raise (\"python not on path\" + fix) subprocess.check_call([python, \"-m\", \"pip\", \"install\", name]) except: raise ImportError(f\"{name} not found\" + fix)\n    \n    install_if_missing(\"numpy\") install_if_missing(\"matplotlib\")\n    \n    \n    from python import Python from python.object import PythonObject\n    \n    struct Image: # reference count used to make the object efficiently copyable var rc: Pointer[Int] # the two dimensional image is represented as a flat array var pixels: Pointer[Vec3f] var height: Int var width: Int\n    \n    fn __init__(inout self, height: Int, width: Int): self.height = height self.width = width self.pixels = Pointer[Vec3f].alloc(self.height * self.width) self.rc = Pointer[Int].alloc(1) self.rc.store(1)\n    \n    fn __copyinit__(inout self, other: Self): other._inc_rc() self.pixels = other.pixels self.rc = other.rc self.height = other.height self.width = other.width\n    \n    fn __del__(owned self): self._dec_rc()\n    \n    fn _get_rc(self) -> Int: return self.rc.load()\n    \n    fn _dec_rc(self): var rc = self._get_rc() if rc > 1: self.rc.store(rc - 1) return self._free()\n    \n    fn _inc_rc(self): var rc = self._get_rc() self.rc.store(rc + 1)\n    \n    fn _free(self): self.rc.free() self.pixels.free()\n    \n    @always_inline fn set(self, row: Int, col: Int, value: Vec3f) -> None: self.pixels.store(self._pos_to_index(row, col), value)\n    \n    @always_inline fn _pos_to_index(self, row: Int, col: Int) -> Int: # Convert a (rol, col) position into an index in the underlying linear storage return row * self.width + col\n    \n    def to_numpy_image(self) -> PythonObject: var np = Python.import_module(\"numpy\") var plt = Python.import_module(\"matplotlib.pyplot\")\n    \n    var np_image = np.zeros((self.height, self.width, 3), np.float32)\n    \n    # We use raw pointers to efficiently copy the pixels to the numpy array var out_pointer = Pointer( __mlir_op.`pop.index_to_pointer`[ _type=__mlir_type[`!kgen.pointer<scalar<f32>>`] ]( SIMD[DType.index, 1]( np_image.__array_interface__[\"data\"][0].__index__() ).value ) ) var in_pointer = Pointer( __mlir_op.`pop.index_to_pointer`[ _type=__mlir_type[`!kgen.pointer<scalar<f32>>`] ](SIMD[DType.index, 1](int(self.pixels)).value) )\n    \n    for row in range(self.height): for col in range(self.width): var index = self._pos_to_index(row, col) for dim in range(3): out_pointer.store( index * 3 + dim, in_pointer[index * 4 + dim] )\n    \n    return np_image\n    \n    def load_image(fname: String) -> Image: var np = Python.import_module(\"numpy\") var plt = Python.import_module(\"matplotlib.pyplot\")\n    \n    var np_image = plt.imread(fname) var rows = np_image.shape[0].__index__() var cols = np_image.shape[1].__index__() var image = Image(rows, cols)\n    \n    var in_pointer = Pointer( __mlir_op.`pop.index_to_pointer`[ _type=__mlir_type[`!kgen.pointer<scalar<f32>>`] ]( SIMD[DType.index, 1]( np_image.__array_interface__[\"data\"][0].__index__() ).value ) ) var out_pointer = Pointer( __mlir_op.`pop.index_to_pointer`[ _type=__mlir_type[`!kgen.pointer<scalar<f32>>`] ](SIMD[DType.index, 1](int(image.pixels)).value) ) for row in range(rows): for col in range(cols): var index = image._pos_to_index(row, col) for dim in range(3): out_pointer.store( index * 4 + dim, in_pointer[index * 3 + dim] ) return image\n\nWe then add a function for quickly displaying an Image into the notebook. Our\nPython interop comes in quite handy.\n\n    \n    \n    def render(image: Image): np = Python.import_module(\"numpy\") plt = Python.import_module(\"matplotlib.pyplot\") colors = Python.import_module(\"matplotlib.colors\") dpi = 32 fig = plt.figure(1, [image.height // 10, image.width // 10], dpi)\n    \n    plt.imshow(image.to_numpy_image()) plt.axis(\"off\") plt.show()\n\nFinally, we test all our code so far with a simple image, which is the one\nrendered in the Step 1 of the C++ tutorial.\n\n    \n    \n    var image = Image(192, 256)\n    \n    for row in range(image.height): for col in range(image.width): image.set( row, col, Vec3f(Float32(row) / image.height, Float32(col) / image.width, 0), )\n    \n    render(image)\n\n## Step 2: Ray tracing\n\nNow we'll perform ray tracing from a camera into a scene with a sphere. Before\nreading the code below, we suggest you read more about how this works\nconceptually from Step 2 of the C++ tutorial.\n\nWe first define the Material and Sphere structs, which are the new data\nstructures we'll need.\n\n    \n    \n    from math import sqrt\n    \n    @register_passable(\"trivial\") struct Material: var color: Vec3f var albedo: Vec3f var specular_component: Float32\n    \n    fn __init__(color: Vec3f) -> Material: return Material { color: color, albedo: Vec3f(0, 0, 0), specular_component: 0 }\n    \n    fn __init__( color: Vec3f, albedo: Vec3f, specular_component: Float32 ) -> Material: return Material { color: color, albedo: albedo, specular_component: specular_component }\n    \n    alias W = 1024 alias H = 768 alias bg_color = Vec3f(0.02, 0.02, 0.02) var shiny_yellow = Material(Vec3f(0.95, 0.95, 0.4), Vec3f(0.7, 0.6, 0), 30.0) var green_rubber = Material(Vec3f( 0.3, 0.7, 0.3), Vec3f(0.9, 0.1, 0), 1.0)\n    \n    @register_passable(\"trivial\") struct Sphere(CollectionElement): var center: Vec3f var radius: Float32 var material: Material\n    \n    fn __init__(c: Vec3f, r: Float32, material: Material) -> Self: return Sphere {center: c, radius: r, material: material}\n    \n    @always_inline fn intersects(self, orig: Vec3f, dir: Vec3f, inout dist: Float32) -> Bool: \"\"\"This method returns True if a given ray intersects this sphere. And if it does, it writes in the `dist` parameter the distance to the origin of the ray. \"\"\" var L = orig - self.center var a = dir @ dir var b = 2 * (dir @ L) var c = L @ L - self.radius * self.radius var discriminant = b * b - 4 * a * c if discriminant < 0: return False if discriminant == 0: dist = -b / 2 * a return True var q = -0.5 * (b + sqrt(discriminant)) if b > 0 else -0.5 * ( b - sqrt(discriminant) ) var t0 = q / a var t1 = c / q if t0 > t1: t0 = t1 if t0 < 0: t0 = t1 if t0 < 0: return False\n    \n    dist = t0 return True\n\nWe then define a cast_ray method, which will be used to figure out the color\nof a particular pixel in the image we'll produce. It basically works by\nidentifying whether this ray intersects the sphere or not.\n\n    \n    \n    fn cast_ray(orig: Vec3f, dir: Vec3f, sphere: Sphere) -> Vec3f: var dist: Float32 = 0 if not sphere.intersects(orig, dir, dist): return bg_color\n    \n    return sphere.material.color\n\nLastly, we parallelize the ray tracing for every pixel row-wise.\n\n    \n    \n    from math import tan, acos from algorithm import parallelize\n    \n    fn create_image_with_sphere(sphere: Sphere, height: Int, width: Int) -> Image: var image = Image(height, width)\n    \n    @parameter fn _process_row(row: Int): var y = -((2.0 * row + 1) / height - 1) for col in range(width): var x = ((2.0 * col + 1) / width - 1) * width / height var dir = Vec3f(x, y, -1).normalize() image.set(row, col, cast_ray(Vec3f.zero(), dir, sphere))\n    \n    parallelize[_process_row](height)\n    \n    return image\n    \n    render( create_image_with_sphere(Sphere(Vec3f(-3, 0, -16), 2, shiny_yellow), H, W) )\n\n## Step 3: More spheres\n\nThis section corresponds to the Step 3 of the C++ tutorial.\n\nWe include here all the necessary changes:\n\n  * We add 3 more spheres to the scene, 2 of them being of ivory material.\n  * When we intersect the ray with the sphere, we render the color of the closest sphere.\n\n    \n    \n    from algorithm import parallelize from math.limit import inf from collections import List\n    \n    fn scene_intersect( orig: Vec3f, dir: Vec3f, spheres: List[Sphere], background: Material, ) -> Material: var spheres_dist = inf[DType.float32]() var material = background\n    \n    for i in range(spheres.size): var dist = inf[DType.float32]() if spheres[i].intersects(orig, dir, dist) and dist < spheres_dist: spheres_dist = dist material = spheres[i].material\n    \n    return material\n    \n    fn cast_ray( orig: Vec3f, dir: Vec3f, spheres: List[Sphere] ) -> Material: var background = Material(Vec3f(0.02, 0.02, 0.02)) return scene_intersect(orig, dir, spheres, background)\n    \n    fn create_image_with_spheres( spheres: List[Sphere], height: Int, width: Int ) -> Image: var image = Image(height, width)\n    \n    @parameter fn _process_row(row: Int): var y = -((2.0 * row + 1) / height - 1) for col in range(width): var x = ((2.0 * col + 1) / width - 1) * width / height var dir = Vec3f(x, y, -1).normalize() image.set(row, col, cast_ray(Vec3f.zero(), dir, spheres).color)\n    \n    parallelize[_process_row](height)\n    \n    return image\n    \n    var spheres = List[Sphere]() spheres.append(Sphere(Vec3f(-3, 0, -16), 2, shiny_yellow)) spheres.append(Sphere(Vec3f(-1.0, -1.5, -12), 1.8, green_rubber)) spheres.append(Sphere(Vec3f( 1.5, -0.5, -18), 3, green_rubber)) spheres.append(Sphere(Vec3f( 7, 5, -18), 4, shiny_yellow))\n    \n    render(create_image_with_spheres(spheres, H, W))\n\n## Step 4: Add lighting\n\nThis section corresponds to the Step 4 of the C++ tutorial. Please read that\nsection for an explanation of the trick used to estimate the light intensity\nof pixel based on the angle of intersection between each ray and the spheres.\nThe changes are minimal and are primarily about handling this intersection\nangle.\n\n    \n    \n    @register_passable(\"trivial\") struct Light(CollectionElement): var position: Vec3f var intensity: Float32\n    \n    fn __init__(p: Vec3f, i: Float32) -> Self: return Light {position: p, intensity: i}\n    \n    \n    from math import max\n    \n    fn scene_intersect( orig: Vec3f, dir: Vec3f, spheres: List[Sphere], inout material: Material, inout hit: Vec3f, inout N: Vec3f, ) -> Bool: var spheres_dist = inf[DType.float32]()\n    \n    for i in range(0, spheres.size): var dist: Float32 = 0 if spheres[i].intersects(orig, dir, dist) and dist < spheres_dist: spheres_dist = dist hit = orig + dir * dist N = (hit - spheres[i].center).normalize() material = spheres[i].material\n    \n    return (spheres_dist != inf[DType.float32]()).__bool__()\n    \n    fn cast_ray( orig: Vec3f, dir: Vec3f, spheres: List[Sphere], lights: List[Light], ) -> Material: var point = Vec3f.zero() var material = Material(Vec3f.zero()) var N = Vec3f.zero() if not scene_intersect(orig, dir, spheres, material, point, N): return bg_color\n    \n    var diffuse_light_intensity: Float32 = 0 for i in range(lights.size): var light_dir = (lights[i].position - point).normalize() diffuse_light_intensity += lights[i].intensity * max(0, light_dir @ N)\n    \n    return material.color * diffuse_light_intensity\n    \n    fn create_image_with_spheres_and_lights( spheres: List[Sphere], lights: List[Light], height: Int, width: Int, ) -> Image: var image = Image(height, width)\n    \n    @parameter fn _process_row(row: Int): var y = -((2.0 * row + 1) / height - 1) for col in range(width): var x = ((2.0 * col + 1) / width - 1) * width / height var dir = Vec3f(x, y, -1).normalize() image.set( row, col, cast_ray(Vec3f.zero(), dir, spheres, lights).color )\n    \n    parallelize[_process_row](height)\n    \n    return image\n    \n    var lights = List[Light]() lights.append(Light(Vec3f(-20, 20, 20), 1.0)) lights.append(Light(Vec3f(20, -20, 20), 0.5))\n    \n    render(create_image_with_spheres_and_lights(spheres, lights, H, W))\n\nClipping input data to the valid range for imshow with RGB data ([0..1] for\nfloats or [0..255] for integers).\n\n## Step 5: Add specular lighting\n\nThis section corresponds to the Step 5 of the C++ tutorial. The changes to the\ncode are quite minimal, but the rendered picture looks much more realistic!\n\n    \n    \n    from math import pow\n    \n    fn reflect(I: Vec3f, N: Vec3f) -> Vec3f: return I - N * (I @ N) * 2.0\n    \n    fn cast_ray( orig: Vec3f, dir: Vec3f, spheres: List[Sphere], lights: List[Light], ) -> Material: var point = Vec3f.zero() var material = Material(Vec3f.zero()) var N = Vec3f.zero() if not scene_intersect(orig, dir, spheres, material, point, N): return bg_color\n    \n    var diffuse_light_intensity: Float32 = 0 var specular_light_intensity: Float32 = 0 for i in range(lights.size): var light_dir = (lights[i].position - point).normalize() diffuse_light_intensity += lights[i].intensity * max(0, light_dir @ N) specular_light_intensity += ( pow( max(0.0, -reflect(-light_dir, N) @ dir), material.specular_component, ) * lights[i].intensity )\n    \n    var result = material.color * diffuse_light_intensity * material.albedo.data[ 0 ] + Vec3f( 1.0, 1.0, 1.0 ) * specular_light_intensity * material.albedo.data[ 1 ] var result_max = max(result[0], max(result[1], result[2])) # Cap the resulting vector if result_max > 1: return result * (1.0 / result_max) return result\n    \n    fn create_image_with_spheres_and_specular_lights( spheres: List[Sphere], lights: List[Light], height: Int, width: Int, ) -> Image: var image = Image(height, width)\n    \n    @parameter fn _process_row(row: Int): var y = -((2.0 * row + 1) / height - 1) for col in range(width): var x = ((2.0 * col + 1) / width - 1) * width / height var dir = Vec3f(x, y, -1).normalize() image.set( row, col, cast_ray(Vec3f.zero(), dir, spheres, lights).color )\n    \n    parallelize[_process_row](height)\n    \n    return image\n    \n    render(create_image_with_spheres_and_specular_lights(spheres, lights, H, W))\n\n## Step 6: Add background\n\nAs a last step, let's use an image for the background instead of a uniform\nfill. The only code that we need to change is the code where we used to return\nbg_color. Now we will determine a point in the background image to which the\nray is directed and draw that.\n\n    \n    \n    from math import abs\n    \n    fn cast_ray( orig: Vec3f, dir: Vec3f, spheres: List[Sphere], lights: List[Light], bg: Image, ) -> Material: var point = Vec3f.zero() var material = Material(Vec3f.zero()) var N = Vec3f.zero() if not scene_intersect(orig, dir, spheres, material, point, N): # Background # Given a direction vector `dir` we need to find a pixel in the image var x = dir[0] var y = dir[1]\n    \n    # Now map x from [-1,1] to [0,w-1] and do the same for y. var w = bg.width var h = bg.height var col = int((1.0 + x) * 0.5 * (w - 1)) var row = int((1.0 + y) * 0.5 * (h - 1)) return Material(bg.pixels[bg._pos_to_index(row, col)])\n    \n    var diffuse_light_intensity: Float32 = 0 var specular_light_intensity: Float32 = 0 for i in range(lights.size): var light_dir = (lights[i].position - point).normalize() diffuse_light_intensity += lights[i].intensity * max(0, light_dir @ N) specular_light_intensity += ( pow( max(0.0, -reflect(-light_dir, N) @ dir), material.specular_component, ) * lights[i].intensity )\n    \n    var result = material.color * diffuse_light_intensity * material.albedo.data[ 0 ] + Vec3f( 1.0, 1.0, 1.0 ) * specular_light_intensity * material.albedo.data[ 1 ] var result_max = max(result[0], max(result[1], result[2])) # Cap the resulting vector if result_max > 1: return result * (1.0 / result_max) return result\n    \n    fn create_image_with_spheres_and_specular_lights( spheres: List[Sphere], lights: List[Light], height: Int, width: Int, bg: Image, ) -> Image: var image = Image(height, width)\n    \n    @parameter fn _process_row(row: Int): var y = -((2.0 * row + 1) / height - 1) for col in range(width): var x = ((2.0 * col + 1) / width - 1) * width / height var dir = Vec3f(x, y, -1).normalize() image.set( row, col, cast_ray(Vec3f.zero(), dir, spheres, lights, bg).color )\n    \n    parallelize[_process_row](height)\n    \n    return image\n    \n    var bg = load_image(\"images/background.png\") render( create_image_with_spheres_and_specular_lights(spheres, lights, H, W, bg) )\n\n## Next steps\n\nWe've only explored the basics of ray tracing here, but you can add shadows,\nreflections and so much more! Fortunately these are explained in the C++\ntutorial, and we leave the corresponding Mojo implementations as an exercise\nfor you.\n\nEdit this page\n\n  * What is MAX\n  * MAX Engine intro\n  * MAX Serving intro\n  * Mojo Manual\n  * Changelog\n\n  * Sign up\n  * Company\n  * Blog\n  * Careers\n\n\u00a9 2024 Modular Inc\n\n", "frontpage": false}
