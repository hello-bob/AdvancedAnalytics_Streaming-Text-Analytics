{"aid": "40283947", "title": "What the heck are Conditions in Kubernetes controllers?", "url": "https://maelvls.dev/kubernetes-conditions/", "domain": "maelvls.dev", "votes": 1, "user": "bo0tzz", "posted_at": "2024-05-07 10:07:58", "comments": 0, "source_title": "What the heck are Conditions in Kubernetes controllers?", "source_text": "What the heck are Conditions in Kubernetes controllers? | maelvls dev blog\n\n## maelvls dev blog\n\nSystems software engineer. I write mostly about Kubernetes and Go. About\n\n12 Nov2019\n\n# What the heck are Conditions in Kubernetes controllers?\n\ncross-post\n\nWhile building a Kubernetes controller using CRDs, I stumbled across\n\u2018conditions\u2019 in the status field. What are conditions and how should I\nimplement them in my controller?\n\nIn this post, I will explain what \u2018status conditions\u2019 are in Kubernetes and\nshow how they can be used in your own controllers.\n\nTable of contents:\n\n  * Pod example\n  * What other projects do\n  * Conditions vs. State machine\n  * Conditions vs. Events\n  * Orthogonality vs. Extensibility\n  * Are Conditions still used?\n  * Conditions vs. Reasons\n  * How many conditions?\n\nIn the following, a \u2018component\u2019 is considered to be one sync loop. A sync loop\n(also called reconciliation loop) is what must be done in order to synchronize\nthe \u2018desired state\u2019 with the \u2018observed state\u2019.\n\nKubernetes itself is made of multiple binaries (kubelet on each node, one\napiserver, one kube-controller-manager and one kube-scheduler). And each of\nthese binaries have multiple components (i.e., sync loops):\n\nbinary| sync loop = component| reads| creates| updates  \n---|---|---|---|---  \nkube-controller-manager| syncDeployment| Pod| ReplicaSet| Deployment  \nkube-controller-manager| syncReplicaSet| Pod  \nkubelet| syncPod| Pod  \nkube-scheduler| scheduleOne| Pod  \nkubelet| syncNodeStatus| Node  \n  \nWe can see that one single object (Pod) can be read, edited and updated by\ndifferent components. When I say \u2018edited\u2019, I mean the sync loop edits the\nstatus (which contains the conditions), not the rest. The status is a way of\ncommunicating between components/sync loops.\n\nAs Brian Grant put it,\n\n> Rather than rigid fine-grained state enumerations that couldn't be evolved,\n> we initially adopted simple basic states that could report open-ended\n> reasons for being in each state (https://t.co/l5WXSjbg3K), and later non-\n> orthogonal, extensible conditions (https://t.co/XiwOcgcSGY).\n>\n> \u2014 Brian Grant (@bgrant0607) March 29, 2019\n\n## Pod example\n\nLet\u2019s read a Pod manifest:\n\n    \n    \n    # kubectl -n cert-manager get pods -oyaml kind: Pod status: conditions: - lastTransitionTime: \"2019-10-22T16:29:24Z\" status: \"True\" type: PodScheduled - lastTransitionTime: \"2019-10-22T16:29:24Z\" status: \"True\" type: Initialized - lastTransitionTime: \"2019-10-22T16:29:31Z\" status: \"True\" type: ContainersReady - lastTransitionTime: \"2019-10-22T16:29:31Z\" status: \"True\" type: Ready containerStatuses: - image: quay.io/jetstack/cert-manager-controller:v0.6.1 ready: true state: { running: { startedAt: \"2019-10-22T16:29:31Z\" } } phase: Running\n\nA condition contains a Status and a Type. It may also contain a Reason and a\nMessage. For example:\n\n    \n    \n    - lastTransitionTime: \"2019-10-22T16:29:31Z\" status: \"True\" type: ContainersReady\n\nThe pod-lifecycle documentation explains the difference between the \u2018phase\u2019\nand \u2018conditions:\n\n  1. The top-level phase is an aggregated state that answers some user-facing questions such as is my pod in a terminal state? but has gaps since the actual state is contained in the conditions.\n  2. The conditions array is a set of types (Ready, PodScheduled...) with a status (True, False or Unknown) that make up the \u2018computed state\u2019 of a Pod at any time. As we will see later, the state is almost always \u2018partial\u2019 (open-ended conditions).\n\nNow, let\u2019s see what I mean by \u2018components\u2019. The status of a Pod is not updated\nby a single Sync loop: it is updated by multiple components: the kubelet, and\nthe kube-scheduler. Here is a list of the condition types per component:\n\nPossible condition types for a Pod| Component that updates this condition type  \n---|---  \nPodScheduled| scheduleOne (kube-scheduler)  \nUnschedulable| scheduleOne (kube-scheduler)  \nInitialized| syncPod (kubelet)  \nContainersReady| syncPod (kubelet)  \nReady| syncPod (kubelet)  \n  \nAlthough conditions are a good way to convey information to the user, they\nalso serve as a way of communicating between components (e.g., between kube-\nscheduler and apiserver) but also to external components (e.g. a custom\ncontroller that wants to trigger something as soon as a pod becomes\n\u2018Unschedulable\u2019, and maybe order more VMs to the cloud provider and add it as\na node.\n\nAs you will see below, the \u2018conditions\u2019 array is considered to be containing\nall the \u2018ground truth\u2019. The \u2018phase\u2019 just an abstraction of these conditions.\n\n## What other projects do\n\n  * cluster-api and its providers (e.g., cluster-api-gcp-provider) do not use Conditions at all:\n\n> (Feng Min, Nov 2018) Brian Grant (@bgrant0607) and Eric Tune (@erictune)\n> have indicated that the API pattern of having \u201cConditions\u201d lists in object\n> statuses is soon to be deprecated. These have generally been used as a\n> timeline of state transitions for the object\u2019s reconciliation, and difficult\n> to consume for clients that just want a meaningful representation of the\n> object\u2019s current state. There are no existing examples of the new pattern to\n> follow instead, just the guidance that we should use top-level fields in the\n> status to represent meaningful information. We can revisit the specifics\n> when new patterns start to emerge in core.\n\nInstead of using a list of conditions, cluster-api projects go like that:\n\n    \n        status: ready: false phase: \"Failed\" failureReason: \"GcpMachineCrashed\" failureMessage: \"VM crashed: ...\"\n\n  * cert-manager uses Conditions, but the only type is \u2018Ready\u2019. The rest of the information is given in Ready\u2019s Reason field. That might be unfortunate for users or other components that are willing to use cert-manager\u2019s API, similarly to what happens with the PodSchedulable condition and its reason, PodReasonUnschedulable. For example, the Issuer\u2019s Sync:\n    \n        kind: Issuer status: conditions: - type: \"Ready\" status: \"False\" reason: \"ErrorConfig\" message: \"Resource validation failed: ...\"\n\n  * Openshift uses conditions a lot but does not use the standard \u2018Ready\u2019 type. For example, cluster-version-operators (CVO) has a kind: ClusterOperator with condition types \u2018Available\u2019, \u2018Progressing\u2019, \u2018Degraded\u2019 and \u2018Upgradeable\u2019.\n\n  * Hyperconverged Cluster Operator (HCO) uses conditions but in a slightly different way that cert-manager or openshift does. Each condition is set by a different component\n\n> It\u2019s important to point out that the Condition types on the HCO don\u2019t\n> represent the condition the HCO is in, rather the condition of the component\n> CRs.\n\n  * Gardener also uses conditions, and like Openshift, it doesn\u2019t rely on the standard \u2018Ready\u2019 type. For example, the kind: ControllerInstallation has conditions types \u2018Valid\u2019 and \u2018Installed\u2019.\n\nWe see a lot of variance across projects. In late 2017, we saw some\nuncertainty about Conditions disappearing. In the remaining of this post, I\nwill try to give answers as to why you should use conditions and how to do so.\n\n## Conditions vs. State machine\n\n> (api-conventions.md, July 2017) Conditions are observations and not,\n> themselves, state machines.\n\nSo, what is the difference between a state in a state machine and an\nobservation? A state machine has a known a fixed state. In comparison,\nconditions offers an \u2018open-world\u2019 perspective with the Unknown value. For\nexample, the status of a Pod is partly constructed by the kube-scheduler,\npartly by the kubelet.\n\nBut when an object gets created, no conditions are present. What does that\nmean?\n\n> (Tim Hockin, May 2015) The absence of a condition should be interpreted the\n> same as Unknown.\n\nIn the end, this set of conditions are just a way of communicating changes of\nstate between components, and this state can always be reconstructed by\nobserving the system:\n\n> (principles.md, 2015) Object status must be 100% reconstructable by\n> observation. Any history kept (E.g., through conditions or other fields in\n> \u2018status\u2019) must be just an optimization and not required for correct\n> operation.\n>\n> Do not define comprehensive state machines for objects with behaviors\n> associated with state transitions and/or \u201cassumed\u201d states that cannot be\n> ascertained by observation.\n\nOne last comment that explains why the Kubernetes docs don\u2019t have any state-\nmachine diagram:\n\n> (Tim Hockin, Apr 2016) This [state-machine-alike diagram representing the\n> Pod states] is not strictly correct though, because a pod can cease to be\n> \u201cready\u201d but not die. We\u2019ve intentionally NOT drawn this as a state-machine\n> because conditions are really orthogonal concepts. We report a singular\n> status as part of kubectl, so maybe we should document THAT, but it\u2019s more\n> complicated than this diagram captures.\n\n## Conditions vs. Events\n\nEvents are meant to save history (for non-machine consumption, i.e., for\nhumans). The set of conditions describes the \u2018current\u2019 state:\n\n> (Brian Grant, Aug 2017 Status, represented as conditions or otherwise,\n> should be complementary to events pertaining to the resource. Events provide\n> additional information for debugging and tracing, akin to log messages, but\n> aren\u2019t intended to be used for event-driven automation.\n\nIt was reminded in 2019:\n\n> (Kenneth Owens, Oct 2019) Events are used to express point in time\n> occurrences, and Conditions are used to express the current state of an\n> ongoing process. For instance, Pod creation is an event, Deployment\n> progressing is a condition.\n\n## Orthogonality vs. Extensibility\n\nIn 2015, the Kubernetes team seemed to be attached to the idea of\n\u2018orthogonality\u2019 between conditions.\n\n> (David Oppenheimer, Apr 2015) To avoid confusion, Conditions should be\n> orthogonal. The ones you suggested \u2013 Instantiated, Initialized, and\n> Terminated \u2013 don\u2019t seem to be orthogonal (in fact I would expect a pod to\n> transition from FFF to TFF to TTF to TTT). What you\u2019ve described sounds more\n> like a state machine than a set of orthogonal conditions, and I think\n> Conditions should only be used for the latter.\n\nIn 2017, things start to get confusing: each condition represents one non-\northogonal \u201cstate\u201d of a resource?! Conditions are orthogonal to each other,\nbut the states that they represent may be non-orthogonal...\n\n> (Brian Grant, Aug 2017) Conditions were created as a way to wean\n> contributors off of the idea of state machines with mutually exclusive\n> states (called \u201cphase\u201d).\n>\n> Each condition should represent a non-orthogonal \u201cstate\u201d of a resource \u2013 is\n> the resource in that state or not (or unknown).\n>\n> Arbitrarily typed/structured status properties specific to a particular\n> resource should just be status fields.\n\nI did not find anywhere a definition of \u2018orthogonal condition\u2019; my guess is\nthat two conditions are orthogonal when they explain two uncorrelated parts of\nthe system.\n\nBut in 2019, the narrative seems to have changed: Brian Grant talks about\n\u2018non-orthogonal & extensible conditions\u2019.\n\n> (Brian Grant, Mar 2019) Rather than rigid fine-grained state enumerations\n> that couldn\u2019t be evolved, we initially adopted simple basic states that\n> could report open-ended reasons for being in each state\n> (http://issues.k8s.io/1146), and later non-orthogonal, extensible conditions\n> (http://issues.k8s.io/7856).\n\nOrthogonality was hard to implement anyway:\n\n> (Steven E. Harris, Aug 2019) The burden is on the status type author to come\n> up with dimensions that are orthogonal; that required careful thought when\n> writing my own condition types.\n\nHere is what I think: you should definitely use conditions, but don\u2019t bother\nwith orthogonality. Just use conditions that represent important changes for\nthe object, beginning with the \u2018Ready\u2019 condition type. \u2018Ready\u2019 is the\nstrongest condition of all and indicates something 100% operational.\n\n## Are Conditions still used?\n\nThere was an extensive discussion, started in 2015, about removing or keeping\nthe \u201cphase\u201d field. In 2017, the same thread turned into \u201cshould we keep using\nconditions?\"; Brian Grant found conditions cumbersome (an array is harder to\ndeal with than top-level fields) and confusing because of the open-ended\nstatuses (True, False, Unknown). In late 2017, Brian Grant did a survey and\nfound out that conditions are still what controller authors should use. In\n2019, Daniel Smith reminded us that conditions are not going away:\n\n> (Daniel Smith, May 2019) Conditions are not going to be removed.\n>\n> The ground truth is set as conditions by the components that are nearby,\n> e.g. kubelet sets \u201cDiskPressure = True\u201d.\n>\n> The set of conditions is summarized into phases (or secondary conditions)\n> for consumption by general controllers. E.g., if there is disk pressure,\n> that can be aggregated into conditionSummary.schedulable: false. The process\n> doing this needs to know all possible gound truth statements; the process of\n> summarizing them isolates the rest of the cluster from needing to know this.\n\n## Conditions vs. Reasons\n\nDo I really need to bother with this .status.conditions array, can I just use\n.status.phase with a simple enum? Or just a reason as part of an existing\n\u2018Ready\u2019 condition?\n\nAt first, Kubernetes would rely on many Reasons:\n\n> (api-conventions.md, July 2017) In condition types, and everywhere else they\n> appear in the API, Reason is intended to be a one-word, CamelCase\n> representation of the category of cause of the current status, and Message\n> is intended to be a human-readable phrase or sentence, which may contain\n> specific details of the individual occurrence.\n>\n> Reason is intended to be used in concise output, such as one-line kubectl\n> get output, and in summarizing occurrences of causes, whereas Message is\n> intended to be presented to users in detailed status explanations, such as\n> kubectl describe output.\n\nLater, they mode to non-orthogonal (read: may-be-corrolated conditions):\n\n> (Brian Grant, Mar 2019) Rather than rigid fine-grained state enumerations\n> that couldn\u2019t be evolved, we initially adopted simple basic states that\n> could report open-ended reasons for being in each state (2014), and later\n> non-orthogonal, extensible conditions (2017).\n\nSince the Pod conditions do not have a \u2018Reason\u2019 field (in the previous Pod\nexample), let\u2019s take a look at the Node conditions instead:\n\n    \n    \n    kind: Node status: conditions: - type: DiskPressure status: \"False\" reason: KubeletHasNoDiskPressure message: kubelet has no disk pressure lastHeartbeatTime: \"2019-11-17T14:18:26Z\" lastTransitionTime: \"2019-10-22T16:27:53Z\" - type: Ready status: \"True\" reason: KubeletReady message: kubelet is posting ready status. AppArmor enabled lastHeartbeatTime: \"2019-11-17T14:18:26Z\" lastTransitionTime: \"2019-10-22T16:27:53Z\"\n\nHere, the \u2018Ready\u2019 condition type has an additional \u2018Reason\u2019 field that gives\nthe user more information about the transition. The Reason field is sometimes\nused by other components: for example, PodReasonUnschedulable is a reason of\nthe PodSchedulable condition type. This reason is set by the kube-scheduler\nand is \u2018consumed\u2019 by the kubelet (or the reverse, I can\u2019t really tell).\n\nSo, Reason of another condition or Condition? If you feel that this state\nmight be interesting to the rest of the system, then use a proper Condition.\n\nRegarding the \u2018phase\u2019 top-level field, I would recommend to offer it to your\nusers when the conditions alone cannot help them answer questions such as has\nmy pod terminated?.\n\n## How many conditions?\n\nIf you think that the \u2018Errored\u2019 state can be useful for other components or\nthe user (e.g. kubectl wait --for=condition=errored), then add it. If you\nthink it is important for other components or for the user to know that\nsomething is in progress, go ahead and add a \u2018InProgress\u2019 condition.\n\nRegarding the naming of condition types, here is some advice:\n\n> (api-conventions.md, July 2017) Condition types should indicate state in the\n> \u201cabnormal-true\u201d polarity. For example, if the condition indicates when a\n> policy is invalid, the \u201cis valid\u201d case is probably the norm, so the\n> condition should be called \u201cInvalid\u201d.\n\nAlso, remember that these types are part of your API and you should keep in\nmind that they require maintaining backwards- and forwards-compatibility.\nAdding a new condition is not free: you must maintain them over time.\n\n> (api-conventions.md, July 2017) The meaning of a Condition can not be\n> changed arbitrarily - it becomes part of the API, and has the same\n> backwards- and forwards-compatibility concerns of any other part of the API.\n\nConditions are also a clean way of letting third-party components (such as the\ncluster-api controller) to add their own \u2018named\u2019 conditions to an existing\nobject, e.g. to a Pod (see pod-readiness-gate):\n\n    \n    \n    Kind: Pod spec: readinessGates: - conditionType: \"www.example.com/feature-1\" status: conditions: - type: Ready # this is a builtin PodCondition status: \"False\" - type: \"www.example.com/feature-1\" # an extra PodCondition status: \"False\"\n\nUpdate 20 Dec 2021: Xiang Yuxuan kindly nudged me about the fact that I was\nwas saying that the 2017 thread was talking about removing conditions, but it\nwas initially to remove the \u2018phase\u2019 field.\n\n\ud83d\udcdd Edit this page\n\nTags: controller go kubernetes\n\n", "frontpage": false}
