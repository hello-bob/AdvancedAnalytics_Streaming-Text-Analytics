{"aid": "40178634", "title": "Speeding up C++ build times", "url": "https://www.figma.com/blog/speeding-up-build-times/", "domain": "figma.com", "votes": 1, "user": "skilled", "posted_at": "2024-04-27 09:34:57", "comments": 0, "source_title": "Speeding Up C++ Build Times | Figma Blog", "source_text": "Speeding Up C++ Build Times | Figma Blog\n\nSkip to main content\n\n### Featured Topics\n\n  * ### Design systems\n\n  * ### Engineering\n\n### Explore topics\n\n  * 3D design\n  * AI\n  * Accessibility\n  * Behind the scenes\n  * Brainstorming\n  * Branding\n  * Career & education\n  * Case study\n  * Collaboration\n  * Config\n  * Culture\n  * Design\n  * Design thinking\n  * Diagramming\n  * Events\n  * Hiring\n  * Infrastructure\n  * Leadership\n  * Localization\n  * Marketing\n  * Meetings\n  * Motion\n  * News\n  * Operations\n  * Plugins & tooling\n  * Portfolio\n  * Product management\n  * Product updates\n  * Productivity\n  * Profiles & interviews\n  * Prototyping\n  * Quality & performance\n  * React\n  * Report\n  * Research\n  * Security\n  * Social impact\n  * Strategy\n  * The Long & Short of It\n  * Thought leadership\n  * Tips & inspiration\n  * Typography\n  * UI/UX\n  * Wireframing\n  * Writing\n\nApril 25, 2024\n\n# Speeding up C++ build times\n\nIsabel RenSoftware Engineer, Figma\n\nKunal DesaiSoftware Engineer, Figma\n\nInside FigmaEngineeringInfrastructureQuality & performance\n\nWhen we learned that engineers were losing hours building our C++ codebase, we\njumped into investigating the root cause. Here\u2019s how we cut build times in\nhalf and shipped a solution for scale.\n\nIf you\u2019ve worked with C++ projects, you\u2019re probably all too familiar with the\nperennial issue of slow build times. They are a major productivity killer,\nleaving developers stuck in a frustrating cycle of wait, debug, and rebuild.\nIn 2023, build times at Figma were increasing at a disproportionate rate:\nWhile the codebase grew by just 10% in a 12-month period, build times had\nincreased by a whopping 50%. It\u2019s no surprise that in our annual internal\ndeveloper survey, C++ build times were a top pain point. After trying a few\nstopgap solutions\u2014like purchasing M1 Maxs for our team\u2014build times gradually\nreverted to their original pace; Ccache and remote caching weren\u2019t enough\neither. We needed to take more drastic measures, quickly.\n\nWe even spun up a channel for engineers to joke about slow build times while,\nof course, brainstorming fixes.\n\n## How C++ builds work\n\nHeader files contain function declarations, definitions of classes, or\nconstant values that can be used across multiple source files. Header files\nare included at the beginning of a source file using the #include directive,\nallowing the compiler to reference the contents during the compilation\nprocess.\n\nBefore we dive into how we improved C++ build times at Figma, it\u2019s important\nto understand how C++ compilation works. In the pre-processing step of C++\ncompilation, all the files that are included (known as header files) get\nmashed into a single mega-file that is passed to the compiler. This includes\nfiles that are transitively included\u2014for example, if file C includes file B,\nand file B includes file A, then file C includes all the bytes of file A\nthrough its transitive dependency.\n\n## Testing our hypothesis\n\nC++ build times are roughly proportional to the number of bytes sent to the\ncompiler after pre-processing. But as we dug in, we noticed that the ratio of\npost pre-processing bytes sent to the compiler to the amount of code added was\ngrowing really fast\u2014a likely suspect for why build times were constantly\nincreasing. This disproportionate increase in compiled bytes led us to believe\nthat there were a lot of places where we were either including headers that we\ndidn\u2019t need at all or had headers that were only used for their transitive\ndependencies. To test the hypothesis, we decided to remove unnecessary\nincludes from our largest files.\n\nCold build time is the amount of time it takes to compile a codebase from\nscratch, as opposed to using cached data from previous compilations to speed\nup the process.\n\nThe results of this effort were promising: We saw a 31% decrease in compiled\nbytes and a 25% decrease in cold build time. From here, it was clear that\nunnecessary includes were a big problem in our codebase and that the number of\nbytes compiled was strongly correlated to our build times. We turned our\nattention to automating the process of preventing unnecessary includes, aiming\nto make C++ builds lightning fast.\n\n## How we came up with the longest acronym ever\n\nInclude What You Use (IWYU) is an open-source tool written by Google to\nminimize the inclusion of unnecessary header files in C++ code. It analyzes\nthe symbols used in a file and makes sure that you directly include the header\nthat exports the symbol used. We attempted to integrate IWYU into our codebase\ntwice, with limited success. The tool strives for each file to have the\nprecise set of includes, which makes it challenging to apply retroactively to\na substantial codebase.\n\nUndaunted, we started creating our own tool. Instead of requiring that you\ninclude the exact set of headers, it would only ensure that the current file\nutilizes something directly from each header it includes. While IWYU was more\nstringent, we took a more relaxed approach so that it would be easier to\nimplement and deploy in our codebase.\n\nOur tool, which we named Don\u2019t Include What You Don\u2019t Use (DIWYDU), uses\nlibclang\u2019s Python bindings to parse every source and header file in our\ncodebase. It analyzes the Abstract Syntax Tree (AST), a tree representation\nthat mirrors our code\u2019s hierarchical structure, and captures the relationships\nbetween its various elements. This allows DIWYDU to accurately identify the\ntypes, functions, and variables that each file directly uses. When DIWYDU\ndiscovers an included header that a file doesn\u2019t directly depend on, it flags\nit. Eliminating these flagged, unnecessary includes improves our build times,\nso we run this tool on all our feature branches.\n\nHowever, DIWYDU has its limitations. For instance, it only analyzes Figma\u2019s\nsource and header files, excluding Standard Template Library (STL) header\nfiles. This is because STL files contain private includes, which are headers\nthat are only used within a specific module rather than being exposed in the\npublic interface (IWYU also struggles with private includes). For example, the\nvector.h header doesn\u2019t actually define the std::vector symbol. Rather, it\u2019s\ndefined in a private include inside the library.\n\nAdditionally, libclang\u2019s Python bindings rely on the underlying C bindings,\nwhich don\u2019t offer the same access to the Clang AST as the actual Clang\ncompiler that uses the C++ library. As a result, we sometimes encounter the\nUNEXPOSED_EXPR type of node in the Clang AST and have to resort to less\nelegant solutions. Making a shift to a C++ based tool could potentially\nresolve this issue.\n\nIn C++, forward declaration is a declaration of an identifier without the\ncomplete definition. It tells the compiler an identifier exists and saves\ncompilation time by avoiding the need to read and process potentially complex\nand lengthy code. This is often used when there are circular dependencies\nbetween two or more classes, or to reduce compile times by reducing the amount\nof code the compiler needs to process.\n\nSometimes engineers include large files that are needed but lead to a large\nincrease in bytes sent to the compiler. These regressions can often be fixed\nby forward declaration or breaking up header files, but because the header is\nactually used in the file, DIWYDU doesn\u2019t detect this kind of regression. We\nneeded another tool to detect these before they reached master.\n\n## Measuring our codebase: Includes.py\n\nOne way to detect and prevent a regression in the number of bytes sent to the\ncompiler is to measure it and inform feature branch authors that their change\nmay have a significant impact on C++ build times. We developed a tool we call\nincludes.py which measures the transitive bytes per source file. It is written\npurely in Python and does not use Clang, which makes it fast to run\u2014usually in\njust a couple of seconds.\n\nThe tool provides the information we need to run this in our Continuous\nIntegration (CI) system and definitively determine the increase in bytes per\nsource file that a given PR causes. If there are significant regressions, we\nissue warnings in PRs to prevent them from being merged initially.\n\nIncludes.py operates by crawling all the first-party header and source files\nin our codebase, including generated files, and counting the number of bytes\nin the files. When it encounters standard library includes, it assumes they\nare 0 bytes. This is a safe assumption to make for our codebase since it\u2019s not\ncommon for engineers at Figma to directly include standard library headers.\nOur use of the standard library is almost entirely confined to a single\ndirectory that exports wrappers around the standard library containers. After\ncounting the bytes in our files, the tool identifies header dependencies and\nconstructs a graph with this information. To approximate the total number of\nbytes sent to the compiler, it sums up the total number of bytes in the\ncurrent file and the total number of bytes in the header files it depends on,\nboth directly and transitively.\n\n## Fwd.h\n\nWhen working with engineers to fix regressions detected by includes.py, we\noften recommended forward declaring symbols. We can forward declare symbols if\nwe only reference the name of a symbol without requiring the knowledge of its\nsize or inheritance structure. This bypasses the need for an include, which\ncan speed up the build process. However, having a lot of forward declarations\ncan affect readability and also makes the codebase less searchable since a\ngiven symbol would appear in numerous places.\n\nOur solution was to create Fwd.h files. We\u2019ve structured our codebase into\nsomething resembling modules (although not official C++ modules), with each\ndirectory being built independently of others. We\u2019ve implemented a policy\nwhere each directory has its own Fwd.h file that contains all the forward\ndeclarations required by other files within that directory. These Fwd.h files\nare then included in every header in that directory.\n\nThis approach not only centralizes forward declarations to one location per\ndirectory but also alleviates the need for engineers working on a file to\nconsider forward declarations or includes. Essentially, everything that can\nbenefit from forward declarations does so organically.\n\nIt\u2019s also worth noting that a source file should never include a Fwd.h file.\nForward declarations are only valuable in header files where they prevent\nunnecessary header includes.\n\nPlain text\n\n    \n    \n    // AnimalFwd.h namespace Figma { struct Animal; struct Dog; struct Cat; enum struct AnimalType; using Feline = Cat; };\n\nAn example Fwd.h file, `AnimalFwd.h`\n\n## A note about caching\n\nThe approach we described is focused on reducing the total number of compiled\nbytes. However, there are other common solutions that we also employed to\nreduce build times, including local caching, remote caching, and precompiled\nheaders.\n\nCharlie Kilpatrick, another engineer on our team, scoped a plan for Bazel\nremote caching, which caches build outputs for retrieval whenever the same\ninputs are used for a given build. It isn\u2019t something we\u2019d used before for\nlocal developer laptop builds, but we figured we\u2019d try using it to see what\nthe performance gains would be. With a bit of logic in place to make sure we\nonly use the remote cache for local builds when it makes sense, we shaved more\nthan two minutes off local builds when the remote cache kicked in.\n\n## Preventing regressions\n\nOvercoming the challenge of slow C++ build times at Figma required a\nmultifaceted approach. We identified unnecessary includes as a major problem\nand developed automated tools like DIWYDU and includes.py to address this\nissue. We also implemented Fwd.h files to improve codebase readability and\nspeed up the build process. The results have been significant: We\u2019ve cut our\nbuild times by 50% and are preventing 50-100 potential slowdowns every single\nday. With these tools, we've been able to automatically identify and quickly\nrectify these regressions, optimizing build times and developer productivity.\n\nIf this work sounds interesting to you, check out our open roles!\n\nThank you to Ojan Vafai, Evan Martin, Russell McClellan, and the many other\ncontributors across engineering who helped along the way.\n\nIllustrations by Rose Wong\n\n## Create and collaborate with Figma\n\nGet started for free\n\n## Use Cases\n\n  * UI design\n  * UX design\n  * Wireframing\n  * Diagramming\n  * Brainstorming\n  * Online whiteboard\n  * Team collaboration\n  * Agile workflows\n  * Strategic planning\n  * Mind mapping\n  * Concept mapping\n  * Org charts\n  * Online sticky notes\n  * Templates\n  * Agencies\n  * Figma for education\n\n## Explore\n\n  * Design\n  * Prototyping\n  * Design systems\n  * Development features\n  * Collaboration features\n  * Design process\n  * FigJam\n  * What's new\n  * Releases\n  * Pricing\n  * Enterprise\n  * Organization\n  * Professional\n  * Customers\n  * Security\n  * Integrations\n  * Contact\n\n## Resources\n\n  * Blog\n  * Best practices\n  * Color wheel\n  * Support\n  * Developers\n  * Resource library\n  * Reports & Insights\n  * Webinars\n  * Downloads\n  * Careers\n  * Our story\n  * Affiliate program\n  * Partners\n  * Legal and Privacy\n  * Modern Slavery Statement\n  * Climate Disclosure Statement\n  * Status\n\n## Compare\n\n  * Sketch\n  * Adobe XD\n  * Invision Studio\n  * Framer\n  * Design on Windows\n  * Miro\n\nEnglish\n\n", "frontpage": false}
