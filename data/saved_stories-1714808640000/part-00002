{"aid": "40252843", "title": "Coverage Guided Fuzzing \u2013 Extending Instrumentation to Hunt Down Bugs Faster", "url": "https://blog.includesecurity.com/2024/04/coverage-guided-fuzzing-extending-instrumentation/", "domain": "includesecurity.com", "votes": 2, "user": "wslh", "posted_at": "2024-05-03 21:55:45", "comments": 0, "source_title": "Coverage Guided Fuzzing \u2013 Extending Instrumentation to Hunt Down Bugs Faster!", "source_text": "Coverage Guided Fuzzing - Extending Instrumentation to Hunt Down Bugs Faster!\n- Include Security Research Blog\n\nSkip to content\n\nTeam Research blog\n\n# Coverage Guided Fuzzing \u2013 Extending Instrumentation to Hunt Down Bugs\nFaster!\n\nApril 25, 2024April 25, 2024 \u2014 Bruno Oliveira\n\nWe at IncludeSec sometimes have the need to develop fuzzing harnesses for our\nclients as part of our security assessment and pentesting work. Using fuzzing\nin an assessment methodology can uncover vulnerabilities in modern and complex\nsoftware during security assessments by providing a faster way to submit\nhighly structured inputs to the applications. This technique is usually\napplied when a more comprehensive effort beyond manual and traditional\nautomated testing are requested by our clients to provide an additional\nanalysis to uncover more esoteric vulnerabilities.\n\n### Introduction\n\nCoverage-guided fuzzing is a useful capability in advanced fuzzers (AFL,\nlibFuzzer, Fuzzilli, and others). This capability permits the fuzzer to\nacknowledge if an input can discover new edges or branches in the binary\nexecution paths. An edge links two branches in a control flow graph (CFG). For\ninstance, if a logical condition involves an if-else statement, there would be\ntwo edges, one for the if and the other for the else statement. It is a\nsignificant part of the fuzzing process, helping determine if the target\nprogram\u2019s executable code is effectively covered by the fuzzer.\n\nA guided fuzzing process usually utilizes a coverage-guided fuzzing (CGF)\ntechnique, employing very basic instrumentation to collect data needed to\nidentify if a new edge or coverage block is hit during the execution of a fuzz\ntest case. The instrumentation is code added during the compilation process,\nutilized for a number of reasons, including software debugging which is how we\nwill use it in this post.\n\nHowever, CGF instrumentation techniques can be extended, such as by adding new\nmetrics, as demonstrated in this paper [1], where the authors consider not\nonly the edge count but when there is a security impact too. Generally,\nextending instrumentation is useful to retrieve more information from the\ntarget programs.\n\nIn this post, we modify the Fuzzilli patch for the software JerryScript.\nJerryScript has a known and publicly available vulnerability/exploit, that we\ncan use to show how extending Fuzzilli\u2019s instrumentation could be helpful for\nmore easily identifying vulnerabilities and providing more useful feedback to\nthe fuzzer for further testing. Our aim is to demonstrate how we can modify\nthe instrumentation and extract useful data for the fuzzing process.\n\n[1] (Not All Coverage Measurements Are Equal: Fuzzing by Coverage Accounting\nfor Input Prioritization \u2013 NDSS Symposium (ndss-symposium.org)\n\n### Fuzzing\n\nFuzzing is the process of submitting random inputs to trigger an unexpected\nbehavior from the application. In recent approaches, the fuzzers consider\nvarious aspects of the target application for generating inputs, including the\nseeds \u2013 sources for generating the inputs. Since modern software has complex\nstructures, we can not reach satisfactory results using simple inputs. In\nother words, by not affecting most of the target program it will be difficult\nto discover new vulnerabilities.\n\nThe diagram below shows an essential structure for a fuzzer with mutation\nstrategy and code coverage capability.\n\n  1. Seeds are selected;\n  2. The mutation process takes the seeds to originate inputs for the execution;\n  3. The execution happens;\n  4. A vulnerability can occur or;\n  5. The input hits a new edge in the target application; the fuzzer keeps mutating the same seed or;\n  6. The input does not hit new edges, and the fuzzer selects a new seed for mutation.\n\nThe code coverage is helpful to identify if the input can reach different\nparts of the target program by pointing to the fuzzer that a new edge or block\nwas found during the execution.\n\n### CLANG\n\nClang [Clang] is a compiler for the C, C++, Objective-C, and Objective-C++\nprogramming languages. It is part of the LLVM project and offers advantages\nover traditional compilers like GCC (GNU Compiler Collection), including more\nexpressive diagnostics, faster compilation times, and extensive analysis\nsupport.\n\nOne significant tool within the Clang compiler is the sanitizer. Sanitizers\nare security libraries or tools that can detect bugs and vulnerabilities\nautomatically by instrumenting the code. The compiler checks the compiled code\nfor security implications when the sanitizer is enabled.\n\nThere are a few types of sanitizers in this context:\n\n  * AddressSanitizer (ASAN): This tool detects memory errors, including vulnerabilities like buffer overflows, use-after-free, double-free, and memory leaks.\n\n  * UndefinedBehaviorSanitizer (UBSAN): Identifies undefined behavior in C/C++ code such as integer overflow, division by zero, null pointer dereferences, and others.\n\n  * MemorySanitizer (MSAN): Detected uninitialized memory reads in C/C++ programs that can lead to unpredictable behavior.\n\n  * ThreadSanitizer (TSAN): Detects uninitialized data races and deadlocks in multithreads C/C++ applications.\n\n  * LeakSanitizer (LSAN): This sanitizer is integrated with AddressSanitizer and helps detect memory leaks, ensuring that all allocated memory is being freed.\n\nThe LLVM documentation (SanitizerCoverage \u2014 Clang 19.0.0git documentation\n(llvm.org)) provides a few examples of what to do with the tool. The shell\nsnippet below shows the command line for the compilation using the ASAN option\nto trace the program counter.\n\nPlain text\n\nCopy to clipboard\n\nOpen code in new window\n\nEnlighterJS 3 Syntax Highlighter\n\n$ clang -o targetprogram -g -fsanitize=address -fsanitize-coverage=trace-pc-\nguard targetprogram.c\n\n$ clang -o targetprogram -g -fsanitize=address -fsanitize-coverage=trace-pc-\nguard targetprogram.c\n\n    \n    \n    $ clang -o targetprogram -g -fsanitize=address -fsanitize-coverage=trace-pc-guard targetprogram.c\n\nFrom clang documentation:\n\n\u201cLLVM has a simple code coverage instrumentation built in (SanitizerCoverage).\nIt inserts calls to user-defined functions on function-, basic-block-, and\nedge- levels. Default implementations of those callbacks are provided and\nimplement simple coverage reporting and visualization, however if you need\njust coverage visualization you may want to use SourceBasedCodeCoverage\ninstead.\u201d\n\nFor example, code coverage in Fuzzilli (googleprojectzero/fuzzilli: A\nJavaScript Engine Fuzzer (github.com)), Google\u2019s state-of-the-art JavaScript\nengine fuzzer, utilizes simple instrumentation to respond to Fuzzilli\u2019s\nprocess, as demonstrated in the code snippet below.\n\nPlain text\n\nCopy to clipboard\n\nOpen code in new window\n\nEnlighterJS 3 Syntax Highlighter\n\nextern \"C\" void __sanitizer_cov_trace_pc_guard(uint32_t *guard) {\n\nuint32_t index = *guard;\n\n__shmem->edges[index / 8] |= 1 << (index % 8);\n\n*guard = 0;\n\n}\n\nextern \"C\" void __sanitizer_cov_trace_pc_guard(uint32_t *guard) { uint32_t\nindex = *guard; __shmem->edges[index / 8] |= 1 << (index % 8); *guard = 0; }\n\n    \n    \n    extern \"C\" void __sanitizer_cov_trace_pc_guard(uint32_t *guard) { uint32_t index = *guard; __shmem->edges[index / 8] |= 1 << (index % 8); *guard = 0; }\n\nThe function __sanitizer_cov_trace_pc_guard() will consistently execute when a\nnew edge is found, so no condition is necessary to interpret the new edge\ndiscovery. Then, the function changes a bit in the shared bitmap\n__shmem->edges to 1 (bitwise OR), and then Fuzzilli analyzes the bitmap after\nexecution.\n\nOther tools, like LLVM-COV (llvm-cov \u2013 emit coverage information \u2014 LLVM\n19.0.0git documentation), capture code coverage information statically,\nproviding a human-readable document after execution; however, fuzzers need to\nbe efficient, and reading documents in the disk would affect the performance.\n\n### Getting More Information\n\nWe can modify Fuzzilli\u2019s instrumentation and observe other resources that\n__sanitizer_cov_trace_pc_guard() can bring to the code coverage. The code\nsnippet below demonstrates the Fuzzilli instrumentation with a few tweaks.\n\nPlain text\n\nCopy to clipboard\n\nOpen code in new window\n\nEnlighterJS 3 Syntax Highlighter\n\nextern \"C\" void __sanitizer_cov_trace_pc_guard(uint32_t *guard) {\n\nuint32_t index = *guard;\n\nvoid *PC = __builtin_return_address(0);\n\nchar PcDescr[1024];\n\n__sanitizer_symbolize_pc(PC, \"%p %F %L\", PcDescr, sizeof(PcDescr));\n\nprintf(\"guard: %p %x PC %s\\n\", guard, *guard, PcDescr);\n\n__shmem->edges[index / 8] |= 1 << (index % 8);\n\n*guard = 0;\n\n}\n\nextern \"C\" void __sanitizer_cov_trace_pc_guard(uint32_t *guard) { uint32_t\nindex = *guard; void *PC = __builtin_return_address(0); char PcDescr[1024];\n__sanitizer_symbolize_pc(PC, \"%p %F %L\", PcDescr, sizeof(PcDescr));\nprintf(\"guard: %p %x PC %s\\n\", guard, *guard, PcDescr); __shmem->edges[index /\n8] |= 1 << (index % 8); *guard = 0; }\n\n    \n    \n    extern \"C\" void __sanitizer_cov_trace_pc_guard(uint32_t *guard) { uint32_t index = *guard; void *PC = __builtin_return_address(0); char PcDescr[1024]; __sanitizer_symbolize_pc(PC, \"%p %F %L\", PcDescr, sizeof(PcDescr)); printf(\"guard: %p %x PC %s\\n\", guard, *guard, PcDescr); __shmem->edges[index / 8] |= 1 << (index % 8); *guard = 0; }\n\nWe already know that the function __sanitizer_cov_trace_pc_guard() is executed\nevery time the instrumented program hits a new edge. In this case, we are\nutilizing the function __builtin_return_address() to collect the return\naddresses from every new edge hit in the target program. Now, the pointer PC\nhas the return address information. We can utilize the\n__sanitizer_symbolize_pc() function to correlate the address to the symbols,\nproviding more information about the source code file used during the\nexecution.\n\nMost fuzzers use only the edge information to guide the fuzzing process.\nHowever, as we will demonstrate in the next section, using the sanitizer\ninterface can provide compelling information for security assessments.\n\n### Lab Exercise\n\nIn our laboratory, we will utilize another JavaScript engine. In this case, an\nold version of JerryScript JavaScript engine to create an environment.\n\n  * Operating System (OS): Ubuntu 22.04\n  * Target Program: JerryScript\n  * Vulnerability: CVE-2023-36109\n\n#### Setting Up the Environment\n\nYou can build JerryScript using the following instructions.\n\nFirst, clone the repository:\n\nPlain text\n\nCopy to clipboard\n\nOpen code in new window\n\nEnlighterJS 3 Syntax Highlighter\n\n$ git clone https://github.com/jerryscript-project/jerryscript.git\n\n$ git clone https://github.com/jerryscript-project/jerryscript.git\n\n    \n    \n    $ git clone https://github.com/jerryscript-project/jerryscript.git\n\nEnter into the JerryScript folder and checkout the\n8ba0d1b6ee5a065a42f3b306771ad8e3c0d819bc commit.\n\nPlain text\n\nCopy to clipboard\n\nOpen code in new window\n\nEnlighterJS 3 Syntax Highlighter\n\n$ git checkout 8ba0d1b6ee5a065a42f3b306771ad8e3c0d819bc\n\n$ git checkout 8ba0d1b6ee5a065a42f3b306771ad8e3c0d819bc\n\n    \n    \n    $ git checkout 8ba0d1b6ee5a065a42f3b306771ad8e3c0d819bc\n\nFuzzilli utilizes the head 8ba0d1b6ee5a065a42f3b306771ad8e3c0d819bc for the\ninstrumentation, and we can take advantage of the configuration done for our\nlab. Apply the patch available in the Fuzziilli\u2019s repository\n(fuzzilli/Targets/Jerryscript/Patches/jerryscript.patch at main \u00b7\ngoogleprojectzero/fuzzilli (github.com))\n\nPlain text\n\nCopy to clipboard\n\nOpen code in new window\n\nEnlighterJS 3 Syntax Highlighter\n\n$ cd jerry-main\n\n$ wget\nhttps://github.com/googleprojectzero/fuzzilli/raw/main/Targets/Jerryscript/Patches/jerryscript.patch\n\n$ patch < jerryscript.patch\n\npatching file CMakeLists.txt\n\npatching file main-fuzzilli.c\n\npatching file main-fuzzilli.h\n\npatching file main-options.c\n\npatching file main-options.h\n\npatching file main-unix.c\n\n$ cd jerry-main $ wget\nhttps://github.com/googleprojectzero/fuzzilli/raw/main/Targets/Jerryscript/Patches/jerryscript.patch\n$ patch < jerryscript.patch patching file CMakeLists.txt patching file main-\nfuzzilli.c patching file main-fuzzilli.h patching file main-options.c patching\nfile main-options.h patching file main-unix.c\n\n    \n    \n    $ cd jerry-main $ wget https://github.com/googleprojectzero/fuzzilli/raw/main/Targets/Jerryscript/Patches/jerryscript.patch $ patch < jerryscript.patch patching file CMakeLists.txt patching file main-fuzzilli.c patching file main-fuzzilli.h patching file main-options.c patching file main-options.h patching file main-unix.c\n\nThe instrumented file is jerry-main/main-fuzzilli.c, provided by the\nFuzzilli\u2019s patch. It comes with the necessary to work with simple code\ncoverage capabilities. Still, we want more, so we can use the same lines we\ndemonstrated in the previous section to update the function\n__sanitizer_cov_trace_pc_guard() before the compilation. Also, adding the\nfollowing header to jerry-main/main-fuzzilli.c file:\n\nPlain text\n\nCopy to clipboard\n\nOpen code in new window\n\nEnlighterJS 3 Syntax Highlighter\n\n#include <sanitizer/common_interface_defs.h>\n\n#include <sanitizer/common_interface_defs.h>\n\n    \n    \n    #include <sanitizer/common_interface_defs.h>\n\nThe file header describes the __sanitizer_symbolize_pc() function, which will\nbe needed in our implementation. We will modify the function in the jerry-\nmain/main-fuzzilli.c file.\n\nPlain text\n\nCopy to clipboard\n\nOpen code in new window\n\nEnlighterJS 3 Syntax Highlighter\n\nvoid __sanitizer_cov_trace_pc_guard(uint32_t *guard) {\n\nuint32_t index = *guard;\n\nif(!index) return;\n\nindex--;\n\nvoid *PC = __builtin_return_address(0);\n\nchar PcDescr[1024];\n\n__sanitizer_symbolize_pc(PC, \"%p %F %L\", PcDescr, sizeof(PcDescr));\n\nprintf(\"guard: %p %x PC %s\\n\", (void *)guard, *guard, PcDescr);\n\n__shmem->edges[index / 8] |= 1 << (index % 8);\n\n*guard = 0;\n\n}\n\nvoid __sanitizer_cov_trace_pc_guard(uint32_t *guard) { uint32_t index =\n*guard; if(!index) return; index--; void *PC = __builtin_return_address(0);\nchar PcDescr[1024]; __sanitizer_symbolize_pc(PC, \"%p %F %L\", PcDescr,\nsizeof(PcDescr)); printf(\"guard: %p %x PC %s\\n\", (void *)guard, *guard,\nPcDescr); __shmem->edges[index / 8] |= 1 << (index % 8); *guard = 0; }\n\n    \n    \n    void __sanitizer_cov_trace_pc_guard(uint32_t *guard) { uint32_t index = *guard; if(!index) return; index--; void *PC = __builtin_return_address(0); char PcDescr[1024]; __sanitizer_symbolize_pc(PC, \"%p %F %L\", PcDescr, sizeof(PcDescr)); printf(\"guard: %p %x PC %s\\n\", (void *)guard, *guard, PcDescr); __shmem->edges[index / 8] |= 1 << (index % 8); *guard = 0; }\n\nWe now change the compilation configuration and disable the strip. The symbols\nare only needed to identify the possible vulnerable functions for our\ndemonstration.\n\nIn the root folder CMakeLists.txt file\n\nPlain text\n\nCopy to clipboard\n\nOpen code in new window\n\nEnlighterJS 3 Syntax Highlighter\n\n# Strip binary\n\nif(ENABLE_STRIP AND NOT CMAKE_BUILD_TYPE STREQUAL \"Debug\")\n\njerry_add_link_flags(-g)\n\nendif()\n\n# Strip binary if(ENABLE_STRIP AND NOT CMAKE_BUILD_TYPE STREQUAL \"Debug\")\njerry_add_link_flags(-g) endif()\n\n    \n    \n    # Strip binary if(ENABLE_STRIP AND NOT CMAKE_BUILD_TYPE STREQUAL \"Debug\") jerry_add_link_flags(-g) endif()\n\nIt defaults with the -s option; change to -g to keep the symbols. Make sure\nthat jerry-main/CMakeLists.txt contains the main-fuzzilli.c file, and then we\nare ready to compile. We can then build it using the Fuzzilli instructions.\n\nPlain text\n\nCopy to clipboard\n\nOpen code in new window\n\nEnlighterJS 3 Syntax Highlighter\n\n$ python jerryscript/tools/build.py --compile-flag=-fsanitize-coverage=trace-\npc-guard --profile=es2015-subset --lto=off --compile-\nflag=-D_POSIX_C_SOURCE=200809 --compile-flag=-Wno-strict-prototypes --stack-\nlimit=15\n\n$ python jerryscript/tools/build.py --compile-flag=-fsanitize-coverage=trace-\npc-guard --profile=es2015-subset --lto=off --compile-\nflag=-D_POSIX_C_SOURCE=200809 --compile-flag=-Wno-strict-prototypes --stack-\nlimit=15\n\n    \n    \n    $ python jerryscript/tools/build.py --compile-flag=-fsanitize-coverage=trace-pc-guard --profile=es2015-subset --lto=off --compile-flag=-D_POSIX_C_SOURCE=200809 --compile-flag=-Wno-strict-prototypes --stack-limit=15\n\nIf you have installed Clang, but the output line CMAKE_C_COMPILER_ID is\ndisplaying GNU or something else, you will have errors during the building.\n\nPlain text\n\nCopy to clipboard\n\nOpen code in new window\n\nEnlighterJS 3 Syntax Highlighter\n\n$ python tools/build.py --compile-flag=-fsanitize-coverage=trace-pc-guard\n--profile=es2015-subset --lto=off --compile-flag=-D_POSIX_C_SOURCE=200809\n--compile-flag=-Wno-strict-prototypes --stack-limit=15\n\n\\-- CMAKE_BUILD_TYPE MinSizeRel\n\n\\-- CMAKE_C_COMPILER_ID GNU\n\n\\-- CMAKE_SYSTEM_NAME Linux\n\n\\-- CMAKE_SYSTEM_PROCESSOR x86_64\n\n$ python tools/build.py --compile-flag=-fsanitize-coverage=trace-pc-guard\n--profile=es2015-subset --lto=off --compile-flag=-D_POSIX_C_SOURCE=200809\n--compile-flag=-Wno-strict-prototypes --stack-limit=15 -- CMAKE_BUILD_TYPE\nMinSizeRel -- CMAKE_C_COMPILER_ID GNU -- CMAKE_SYSTEM_NAME Linux --\nCMAKE_SYSTEM_PROCESSOR x86_64\n\n    \n    \n    $ python tools/build.py --compile-flag=-fsanitize-coverage=trace-pc-guard --profile=es2015-subset --lto=off --compile-flag=-D_POSIX_C_SOURCE=200809 --compile-flag=-Wno-strict-prototypes --stack-limit=15 -- CMAKE_BUILD_TYPE MinSizeRel -- CMAKE_C_COMPILER_ID GNU -- CMAKE_SYSTEM_NAME Linux -- CMAKE_SYSTEM_PROCESSOR x86_64\n\nYou can simply change the CMakeLists.txt file, lines 28-42 to enforce Clang\ninstead of GNU by modifying USING_GCC 1 to USING_CLANG 1, as shown below:\n\nPlain text\n\nCopy to clipboard\n\nOpen code in new window\n\nEnlighterJS 3 Syntax Highlighter\n\n# Determining compiler\n\nif(CMAKE_C_COMPILER_ID MATCHES \"GNU\")\n\nset(USING_CLANG 1)\n\nendif()\n\nif(CMAKE_C_COMPILER_ID MATCHES \"Clang\")\n\nset(USING_CLANG 1)\n\nendif()\n\n# Determining compiler if(CMAKE_C_COMPILER_ID MATCHES \"GNU\") set(USING_CLANG\n1) endif() if(CMAKE_C_COMPILER_ID MATCHES \"Clang\") set(USING_CLANG 1) endif()\n\n    \n    \n    # Determining compiler if(CMAKE_C_COMPILER_ID MATCHES \"GNU\") set(USING_CLANG 1) endif() if(CMAKE_C_COMPILER_ID MATCHES \"Clang\") set(USING_CLANG 1) endif()\n\nThe instrumented binary will be the build/bin/jerry file.\n\n#### Execution\n\nLet\u2019s start by disabling ASLR (Address Space Layout Randomization).\n\nPlain text\n\nCopy to clipboard\n\nOpen code in new window\n\nEnlighterJS 3 Syntax Highlighter\n\n$ echo 0 | sudo tee /proc/sys/kernel/randomize_va_space\n\n$ echo 0 | sudo tee /proc/sys/kernel/randomize_va_space\n    \n    \n    $ echo 0 | sudo tee /proc/sys/kernel/randomize_va_space\n\nAfter testing, we can re-enable the ASLR by setting the value to 2.\n\nPlain text\n\nCopy to clipboard\n\nOpen code in new window\n\nEnlighterJS 3 Syntax Highlighter\n\n$ echo 2 | sudo tee /proc/sys/kernel/randomize_va_space\n\n$ echo 2 | sudo tee /proc/sys/kernel/randomize_va_space\n    \n    \n    $ echo 2 | sudo tee /proc/sys/kernel/randomize_va_space\n\nWe want to track the address to the source code file, and disabling the ASLR\nwill help us stay aware during the analysis and not affect our results. The\nASLR will not impact our lab, but keeping the addresses fixed during the\nfuzzing process will be fundamental.\n\nNow, we can execute JerryScript using the PoC file for the vulnerability\nCVE-2023-36109 (Limesss/CVE-2023-36109: a poc for cve-2023-36109\n(github.com)), as an argument to trigger the vulnerability. As described in\nthe vulnerability description, the vulnerable function is at\necma_stringbuilder_append_raw in jerry-core/ecma/base/ecma-helpers-string.c,\nhighlighted in the command snippet below.\n\nPlain text\n\nCopy to clipboard\n\nOpen code in new window\n\nEnlighterJS 3 Syntax Highlighter\n\n$ ./build/bin/jerry ./poc.js\n\n[...]\n\nguard: 0x55e17d12ac88 7bb PC 0x55e17d07ac6b in ecma_string_get_ascii_size\necma-helpers-string.c\n\nguard: 0x55e17d12ac84 7ba PC 0x55e17d07acfe in ecma_string_get_ascii_size\necma-helpers-string.c\n\nguard: 0x55e17d12ac94 7be PC 0x55e17d07ad46 in ecma_string_get_size\n(/jerryscript/build/bin/jerry+0x44d46) (BuildId:\n9588e1efabff4190fd492d05d3710c7810323407)\n\nguard: 0x55e17d12e87c 16b8 PC 0x55e17d09dfe1 in ecma_regexp_replace_helper\n(/jerryscript/build/bin/jerry+0x67fe1) (BuildId:\n9588e1efabff4190fd492d05d3710c7810323407)\n\nguard: 0x55e17d12ae04 81a PC 0x55e17d07bb64 in ecma_stringbuilder_append_raw\n(/jerryscript/build/bin/jerry+0x45b64) (BuildId:\n9588e1efabff4190fd492d05d3710c7810323407)\n\nguard: 0x55e17d12e890 16bd PC 0x55e17d09e053 in ecma_regexp_replace_helper\n(/jerryscript/build/bin/jerry+0x68053) (BuildId:\n9588e1efabff4190fd492d05d3710c7810323407)\n\nguard: 0x55e17d12e8b8 16c7 PC 0x55e17d09e0f1 in ecma_regexp_replace_helper\n(/jerryscript/build/bin/jerry+0x680f1) (BuildId:\n9588e1efabff4190fd492d05d3710c7810323407)\n\nguard: 0x55e17d133508 29db PC 0x55e17d0cc292 in\necma_builtin_replace_substitute (/jerryscript/build/bin/jerry+0x96292)\n(BuildId: 9588e1efabff4190fd492d05d3710c7810323407)\n\nguard: 0x55e17d133528 29e3 PC 0x55e17d0cc5bd in\necma_builtin_replace_substitute (/jerryscript/build/bin/jerry+0x965bd)\n(BuildId: 9588e1efabff4190fd492d05d3710c7810323407)\n\nguard: 0x55e17d12f078 18b7 PC 0x55e17d040a78 in jmem_heap_realloc_block\n(/jerryscript/build/bin/jerry+0xaa78) (BuildId:\n9588e1efabff4190fd492d05d3710c7810323407)\n\nguard: 0x55e17d12f088 18bb PC 0x55e17d040ab4 in jmem_heap_realloc_block\n(/jerryscript/build/bin/jerry+0xaab4) (BuildId:\n9588e1efabff4190fd492d05d3710c7810323407)\n\nguard: 0x55e17d12f08c 18bc PC 0x55e17d040c26 in jmem_heap_realloc_block\n(/jerryscript/build/bin/jerry+0xac26) (BuildId:\n9588e1efabff4190fd492d05d3710c7810323407)\n\nguard: 0x55e17d12f094 18be PC 0x55e17d040ca3 in jmem_heap_realloc_block\n(/jerryscript/build/bin/jerry+0xaca3) (BuildId:\n9588e1efabff4190fd492d05d3710c7810323407)\n\nUndefinedBehaviorSanitizer:DEADLYSIGNAL\n\n==27636==ERROR: UndefinedBehaviorSanitizer: SEGV on unknown address\n0x55e27da7950c (pc 0x7fe341fa092b bp 0x000000000000 sp 0x7ffc77634f18 T27636)\n\n==27636==The signal is caused by a READ memory access.\n\n#0 0x7fe341fa092b string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-\nerms.S:513\n\n#1 0x55e17d0cc3bb in ecma_builtin_replace_substitute\n(/jerryscript/build/bin/jerry+0x963bb) (BuildId:\n9588e1efabff4190fd492d05d3710c7810323407)\n\n#2 0x55e17d09e103 in ecma_regexp_replace_helper\n(/jerryscript/build/bin/jerry+0x68103) (BuildId:\n9588e1efabff4190fd492d05d3710c7810323407)\n\n#3 0x55e17d084a23 in ecma_builtin_dispatch_call\n(/jerryscript/build/bin/jerry+0x4ea23) (BuildId:\n9588e1efabff4190fd492d05d3710c7810323407)\n\n#4 0x55e17d090ddc in ecma_op_function_call_native ecma-function-object.c\n\n#5 0x55e17d0909c1 in ecma_op_function_call\n(/jerryscript/build/bin/jerry+0x5a9c1) (BuildId:\n9588e1efabff4190fd492d05d3710c7810323407)\n\n#6 0x55e17d0d4743 in ecma_builtin_string_prototype_object_replace_helper ecma-\nbuiltin-string-prototype.c\n\n#7 0x55e17d084a23 in ecma_builtin_dispatch_call\n(/jerryscript/build/bin/jerry+0x4ea23) (BuildId:\n9588e1efabff4190fd492d05d3710c7810323407)\n\n#8 0x55e17d090ddc in ecma_op_function_call_native ecma-function-object.c\n\n#9 0x55e17d0909c1 in ecma_op_function_call\n(/jerryscript/build/bin/jerry+0x5a9c1) (BuildId:\n9588e1efabff4190fd492d05d3710c7810323407)\n\n#10 0x55e17d0b929f in vm_execute (/jerryscript/build/bin/jerry+0x8329f)\n(BuildId: 9588e1efabff4190fd492d05d3710c7810323407)\n\n#11 0x55e17d0b8d4a in vm_run (/jerryscript/build/bin/jerry+0x82d4a) (BuildId:\n9588e1efabff4190fd492d05d3710c7810323407)\n\n#12 0x55e17d0b8dd0 in vm_run_global (/jerryscript/build/bin/jerry+0x82dd0)\n(BuildId: 9588e1efabff4190fd492d05d3710c7810323407)\n\n#13 0x55e17d06d4a5 in jerry_run (/jerryscript/build/bin/jerry+0x374a5)\n(BuildId: 9588e1efabff4190fd492d05d3710c7810323407)\n\n#14 0x55e17d069e32 in main (/jerryscript/build/bin/jerry+0x33e32) (BuildId:\n9588e1efabff4190fd492d05d3710c7810323407)\n\n#15 0x7fe341e29d8f in __libc_start_call_main\ncsu/../sysdeps/nptl/libc_start_call_main.h:58:16\n\n#16 0x7fe341e29e3f in __libc_start_main csu/../csu/libc-start.c:392:3\n\n#17 0x55e17d0412d4 in _start (/jerryscript/build/bin/jerry+0xb2d4) (BuildId:\n9588e1efabff4190fd492d05d3710c7810323407)\n\nUndefinedBehaviorSanitizer can not provide additional info.\n\nSUMMARY: UndefinedBehaviorSanitizer: SEGV\nstring/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S:513\n\n==27636==ABORTING\n\n$ ./build/bin/jerry ./poc.js [...] guard: 0x55e17d12ac88 7bb PC 0x55e17d07ac6b\nin ecma_string_get_ascii_size ecma-helpers-string.c guard: 0x55e17d12ac84 7ba\nPC 0x55e17d07acfe in ecma_string_get_ascii_size ecma-helpers-string.c guard:\n0x55e17d12ac94 7be PC 0x55e17d07ad46 in ecma_string_get_size\n(/jerryscript/build/bin/jerry+0x44d46) (BuildId:\n9588e1efabff4190fd492d05d3710c7810323407) guard: 0x55e17d12e87c 16b8 PC\n0x55e17d09dfe1 in ecma_regexp_replace_helper\n(/jerryscript/build/bin/jerry+0x67fe1) (BuildId:\n9588e1efabff4190fd492d05d3710c7810323407) guard: 0x55e17d12ae04 81a PC\n0x55e17d07bb64 in ecma_stringbuilder_append_raw\n(/jerryscript/build/bin/jerry+0x45b64) (BuildId:\n9588e1efabff4190fd492d05d3710c7810323407) guard: 0x55e17d12e890 16bd PC\n0x55e17d09e053 in ecma_regexp_replace_helper\n(/jerryscript/build/bin/jerry+0x68053) (BuildId:\n9588e1efabff4190fd492d05d3710c7810323407) guard: 0x55e17d12e8b8 16c7 PC\n0x55e17d09e0f1 in ecma_regexp_replace_helper\n(/jerryscript/build/bin/jerry+0x680f1) (BuildId:\n9588e1efabff4190fd492d05d3710c7810323407) guard: 0x55e17d133508 29db PC\n0x55e17d0cc292 in ecma_builtin_replace_substitute\n(/jerryscript/build/bin/jerry+0x96292) (BuildId:\n9588e1efabff4190fd492d05d3710c7810323407) guard: 0x55e17d133528 29e3 PC\n0x55e17d0cc5bd in ecma_builtin_replace_substitute\n(/jerryscript/build/bin/jerry+0x965bd) (BuildId:\n9588e1efabff4190fd492d05d3710c7810323407) guard: 0x55e17d12f078 18b7 PC\n0x55e17d040a78 in jmem_heap_realloc_block\n(/jerryscript/build/bin/jerry+0xaa78) (BuildId:\n9588e1efabff4190fd492d05d3710c7810323407) guard: 0x55e17d12f088 18bb PC\n0x55e17d040ab4 in jmem_heap_realloc_block\n(/jerryscript/build/bin/jerry+0xaab4) (BuildId:\n9588e1efabff4190fd492d05d3710c7810323407) guard: 0x55e17d12f08c 18bc PC\n0x55e17d040c26 in jmem_heap_realloc_block\n(/jerryscript/build/bin/jerry+0xac26) (BuildId:\n9588e1efabff4190fd492d05d3710c7810323407) guard: 0x55e17d12f094 18be PC\n0x55e17d040ca3 in jmem_heap_realloc_block\n(/jerryscript/build/bin/jerry+0xaca3) (BuildId:\n9588e1efabff4190fd492d05d3710c7810323407)\nUndefinedBehaviorSanitizer:DEADLYSIGNAL ==27636==ERROR:\nUndefinedBehaviorSanitizer: SEGV on unknown address 0x55e27da7950c (pc\n0x7fe341fa092b bp 0x000000000000 sp 0x7ffc77634f18 T27636) ==27636==The signal\nis caused by a READ memory access. #0 0x7fe341fa092b\nstring/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S:513 #1\n0x55e17d0cc3bb in ecma_builtin_replace_substitute\n(/jerryscript/build/bin/jerry+0x963bb) (BuildId:\n9588e1efabff4190fd492d05d3710c7810323407) #2 0x55e17d09e103 in\necma_regexp_replace_helper (/jerryscript/build/bin/jerry+0x68103) (BuildId:\n9588e1efabff4190fd492d05d3710c7810323407) #3 0x55e17d084a23 in\necma_builtin_dispatch_call (/jerryscript/build/bin/jerry+0x4ea23) (BuildId:\n9588e1efabff4190fd492d05d3710c7810323407) #4 0x55e17d090ddc in\necma_op_function_call_native ecma-function-object.c #5 0x55e17d0909c1 in\necma_op_function_call (/jerryscript/build/bin/jerry+0x5a9c1) (BuildId:\n9588e1efabff4190fd492d05d3710c7810323407) #6 0x55e17d0d4743 in\necma_builtin_string_prototype_object_replace_helper ecma-builtin-string-\nprototype.c #7 0x55e17d084a23 in ecma_builtin_dispatch_call\n(/jerryscript/build/bin/jerry+0x4ea23) (BuildId:\n9588e1efabff4190fd492d05d3710c7810323407) #8 0x55e17d090ddc in\necma_op_function_call_native ecma-function-object.c #9 0x55e17d0909c1 in\necma_op_function_call (/jerryscript/build/bin/jerry+0x5a9c1) (BuildId:\n9588e1efabff4190fd492d05d3710c7810323407) #10 0x55e17d0b929f in vm_execute\n(/jerryscript/build/bin/jerry+0x8329f) (BuildId:\n9588e1efabff4190fd492d05d3710c7810323407) #11 0x55e17d0b8d4a in vm_run\n(/jerryscript/build/bin/jerry+0x82d4a) (BuildId:\n9588e1efabff4190fd492d05d3710c7810323407) #12 0x55e17d0b8dd0 in vm_run_global\n(/jerryscript/build/bin/jerry+0x82dd0) (BuildId:\n9588e1efabff4190fd492d05d3710c7810323407) #13 0x55e17d06d4a5 in jerry_run\n(/jerryscript/build/bin/jerry+0x374a5) (BuildId:\n9588e1efabff4190fd492d05d3710c7810323407) #14 0x55e17d069e32 in main\n(/jerryscript/build/bin/jerry+0x33e32) (BuildId:\n9588e1efabff4190fd492d05d3710c7810323407) #15 0x7fe341e29d8f in\n__libc_start_call_main csu/../sysdeps/nptl/libc_start_call_main.h:58:16 #16\n0x7fe341e29e3f in __libc_start_main csu/../csu/libc-start.c:392:3 #17\n0x55e17d0412d4 in _start (/jerryscript/build/bin/jerry+0xb2d4) (BuildId:\n9588e1efabff4190fd492d05d3710c7810323407) UndefinedBehaviorSanitizer can not\nprovide additional info. SUMMARY: UndefinedBehaviorSanitizer: SEGV\nstring/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S:513\n==27636==ABORTING\n\n    \n    \n    $ ./build/bin/jerry ./poc.js [...] guard: 0x55e17d12ac88 7bb PC 0x55e17d07ac6b in ecma_string_get_ascii_size ecma-helpers-string.c guard: 0x55e17d12ac84 7ba PC 0x55e17d07acfe in ecma_string_get_ascii_size ecma-helpers-string.c guard: 0x55e17d12ac94 7be PC 0x55e17d07ad46 in ecma_string_get_size (/jerryscript/build/bin/jerry+0x44d46) (BuildId: 9588e1efabff4190fd492d05d3710c7810323407) guard: 0x55e17d12e87c 16b8 PC 0x55e17d09dfe1 in ecma_regexp_replace_helper (/jerryscript/build/bin/jerry+0x67fe1) (BuildId: 9588e1efabff4190fd492d05d3710c7810323407) guard: 0x55e17d12ae04 81a PC 0x55e17d07bb64 in ecma_stringbuilder_append_raw (/jerryscript/build/bin/jerry+0x45b64) (BuildId: 9588e1efabff4190fd492d05d3710c7810323407) guard: 0x55e17d12e890 16bd PC 0x55e17d09e053 in ecma_regexp_replace_helper (/jerryscript/build/bin/jerry+0x68053) (BuildId: 9588e1efabff4190fd492d05d3710c7810323407) guard: 0x55e17d12e8b8 16c7 PC 0x55e17d09e0f1 in ecma_regexp_replace_helper (/jerryscript/build/bin/jerry+0x680f1) (BuildId: 9588e1efabff4190fd492d05d3710c7810323407) guard: 0x55e17d133508 29db PC 0x55e17d0cc292 in ecma_builtin_replace_substitute (/jerryscript/build/bin/jerry+0x96292) (BuildId: 9588e1efabff4190fd492d05d3710c7810323407) guard: 0x55e17d133528 29e3 PC 0x55e17d0cc5bd in ecma_builtin_replace_substitute (/jerryscript/build/bin/jerry+0x965bd) (BuildId: 9588e1efabff4190fd492d05d3710c7810323407) guard: 0x55e17d12f078 18b7 PC 0x55e17d040a78 in jmem_heap_realloc_block (/jerryscript/build/bin/jerry+0xaa78) (BuildId: 9588e1efabff4190fd492d05d3710c7810323407) guard: 0x55e17d12f088 18bb PC 0x55e17d040ab4 in jmem_heap_realloc_block (/jerryscript/build/bin/jerry+0xaab4) (BuildId: 9588e1efabff4190fd492d05d3710c7810323407) guard: 0x55e17d12f08c 18bc PC 0x55e17d040c26 in jmem_heap_realloc_block (/jerryscript/build/bin/jerry+0xac26) (BuildId: 9588e1efabff4190fd492d05d3710c7810323407) guard: 0x55e17d12f094 18be PC 0x55e17d040ca3 in jmem_heap_realloc_block (/jerryscript/build/bin/jerry+0xaca3) (BuildId: 9588e1efabff4190fd492d05d3710c7810323407) UndefinedBehaviorSanitizer:DEADLYSIGNAL ==27636==ERROR: UndefinedBehaviorSanitizer: SEGV on unknown address 0x55e27da7950c (pc 0x7fe341fa092b bp 0x000000000000 sp 0x7ffc77634f18 T27636) ==27636==The signal is caused by a READ memory access. #0 0x7fe341fa092b string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S:513 #1 0x55e17d0cc3bb in ecma_builtin_replace_substitute (/jerryscript/build/bin/jerry+0x963bb) (BuildId: 9588e1efabff4190fd492d05d3710c7810323407) #2 0x55e17d09e103 in ecma_regexp_replace_helper (/jerryscript/build/bin/jerry+0x68103) (BuildId: 9588e1efabff4190fd492d05d3710c7810323407) #3 0x55e17d084a23 in ecma_builtin_dispatch_call (/jerryscript/build/bin/jerry+0x4ea23) (BuildId: 9588e1efabff4190fd492d05d3710c7810323407) #4 0x55e17d090ddc in ecma_op_function_call_native ecma-function-object.c #5 0x55e17d0909c1 in ecma_op_function_call (/jerryscript/build/bin/jerry+0x5a9c1) (BuildId: 9588e1efabff4190fd492d05d3710c7810323407) #6 0x55e17d0d4743 in ecma_builtin_string_prototype_object_replace_helper ecma-builtin-string-prototype.c #7 0x55e17d084a23 in ecma_builtin_dispatch_call (/jerryscript/build/bin/jerry+0x4ea23) (BuildId: 9588e1efabff4190fd492d05d3710c7810323407) #8 0x55e17d090ddc in ecma_op_function_call_native ecma-function-object.c #9 0x55e17d0909c1 in ecma_op_function_call (/jerryscript/build/bin/jerry+0x5a9c1) (BuildId: 9588e1efabff4190fd492d05d3710c7810323407) #10 0x55e17d0b929f in vm_execute (/jerryscript/build/bin/jerry+0x8329f) (BuildId: 9588e1efabff4190fd492d05d3710c7810323407) #11 0x55e17d0b8d4a in vm_run (/jerryscript/build/bin/jerry+0x82d4a) (BuildId: 9588e1efabff4190fd492d05d3710c7810323407) #12 0x55e17d0b8dd0 in vm_run_global (/jerryscript/build/bin/jerry+0x82dd0) (BuildId: 9588e1efabff4190fd492d05d3710c7810323407) #13 0x55e17d06d4a5 in jerry_run (/jerryscript/build/bin/jerry+0x374a5) (BuildId: 9588e1efabff4190fd492d05d3710c7810323407) #14 0x55e17d069e32 in main (/jerryscript/build/bin/jerry+0x33e32) (BuildId: 9588e1efabff4190fd492d05d3710c7810323407) #15 0x7fe341e29d8f in __libc_start_call_main csu/../sysdeps/nptl/libc_start_call_main.h:58:16 #16 0x7fe341e29e3f in __libc_start_main csu/../csu/libc-start.c:392:3 #17 0x55e17d0412d4 in _start (/jerryscript/build/bin/jerry+0xb2d4) (BuildId: 9588e1efabff4190fd492d05d3710c7810323407) UndefinedBehaviorSanitizer can not provide additional info. SUMMARY: UndefinedBehaviorSanitizer: SEGV string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S:513 ==27636==ABORTING\n\nUsing this technique, we could identify the root cause of the vulnerability in\nthe function ecma_stringbuilder_append_raw() address in the stack trace.\n\nHowever, if we rely only on the sanitizer to check the stack trace, we won\u2019t\nbe able to see the vulnerable function name in our output:\n\nPlain text\n\nCopy to clipboard\n\nOpen code in new window\n\nEnlighterJS 3 Syntax Highlighter\n\n$ ./build/bin/jerry ./poc.js\n\n[COV] no shared memory bitmap available, skipping\n\n[COV] edge counters initialized. Shared memory: (null) with 14587 edges\n\nUndefinedBehaviorSanitizer:DEADLYSIGNAL\n\n==54331==ERROR: UndefinedBehaviorSanitizer: SEGV on unknown address\n0x5622ae01350c (pc 0x7fc1925a092b bp 0x000000000000 sp 0x7ffed516b838 T54331)\n\n==54331==The signal is caused by a READ memory access.\n\n#0 0x7fc1925a092b string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-\nerms.S:513\n\n#1 0x5621ad66636b in ecma_builtin_replace_substitute\n(/jerryscript/build/bin/jerry+0x9636b) (BuildId:\n15a3c1cd9721e9f1b4e15fade2028ddca6dc542a)\n\n#2 0x5621ad6380b3 in ecma_regexp_replace_helper\n(/jerryscript/build/bin/jerry+0x680b3) (BuildId:\n15a3c1cd9721e9f1b4e15fade2028ddca6dc542a)\n\n#3 0x5621ad61e9d3 in ecma_builtin_dispatch_call\n(/jerryscript/build/bin/jerry+0x4e9d3) (BuildId:\n15a3c1cd9721e9f1b4e15fade2028ddca6dc542a)\n\n#4 0x5621ad62ad8c in ecma_op_function_call_native ecma-function-object.c\n\n#5 0x5621ad62a971 in ecma_op_function_call\n(/jerryscript/build/bin/jerry+0x5a971) (BuildId:\n15a3c1cd9721e9f1b4e15fade2028ddca6dc542a)\n\n#6 0x5621ad66e6f3 in ecma_builtin_string_prototype_object_replace_helper ecma-\nbuiltin-string-prototype.c\n\n#7 0x5621ad61e9d3 in ecma_builtin_dispatch_call\n(/jerryscript/build/bin/jerry+0x4e9d3) (BuildId:\n15a3c1cd9721e9f1b4e15fade2028ddca6dc542a)\n\n#8 0x5621ad62ad8c in ecma_op_function_call_native ecma-function-object.c\n\n#9 0x5621ad62a971 in ecma_op_function_call\n(/jerryscript/build/bin/jerry+0x5a971) (BuildId:\n15a3c1cd9721e9f1b4e15fade2028ddca6dc542a)\n\n#10 0x5621ad65324f in vm_execute (/jerryscript/build/bin/jerry+0x8324f)\n(BuildId: 15a3c1cd9721e9f1b4e15fade2028ddca6dc542a)\n\n#11 0x5621ad652cfa in vm_run (/jerryscript/build/bin/jerry+0x82cfa) (BuildId:\n15a3c1cd9721e9f1b4e15fade2028ddca6dc542a)\n\n#12 0x5621ad652d80 in vm_run_global (/jerryscript/build/bin/jerry+0x82d80)\n(BuildId: 15a3c1cd9721e9f1b4e15fade2028ddca6dc542a)\n\n#13 0x5621ad607455 in jerry_run (/jerryscript/build/bin/jerry+0x37455)\n(BuildId: 15a3c1cd9721e9f1b4e15fade2028ddca6dc542a)\n\n#14 0x5621ad603e32 in main (/jerryscript/build/bin/jerry+0x33e32) (BuildId:\n15a3c1cd9721e9f1b4e15fade2028ddca6dc542a)\n\n#15 0x7fc192429d8f in __libc_start_call_main\ncsu/../sysdeps/nptl/libc_start_call_main.h:58:16\n\n#16 0x7fc192429e3f in __libc_start_main csu/../csu/libc-start.c:392:3\n\n#17 0x5621ad5db2d4 in _start (/jerryscript/build/bin/jerry+0xb2d4) (BuildId:\n15a3c1cd9721e9f1b4e15fade2028ddca6dc542a)\n\nUndefinedBehaviorSanitizer can not provide additional info.\n\nSUMMARY: UndefinedBehaviorSanitizer: SEGV\nstring/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S:513\n\n==54331==ABORTING\n\n$ ./build/bin/jerry ./poc.js [COV] no shared memory bitmap available, skipping\n[COV] edge counters initialized. Shared memory: (null) with 14587 edges\nUndefinedBehaviorSanitizer:DEADLYSIGNAL ==54331==ERROR:\nUndefinedBehaviorSanitizer: SEGV on unknown address 0x5622ae01350c (pc\n0x7fc1925a092b bp 0x000000000000 sp 0x7ffed516b838 T54331) ==54331==The signal\nis caused by a READ memory access. #0 0x7fc1925a092b\nstring/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S:513 #1\n0x5621ad66636b in ecma_builtin_replace_substitute\n(/jerryscript/build/bin/jerry+0x9636b) (BuildId:\n15a3c1cd9721e9f1b4e15fade2028ddca6dc542a) #2 0x5621ad6380b3 in\necma_regexp_replace_helper (/jerryscript/build/bin/jerry+0x680b3) (BuildId:\n15a3c1cd9721e9f1b4e15fade2028ddca6dc542a) #3 0x5621ad61e9d3 in\necma_builtin_dispatch_call (/jerryscript/build/bin/jerry+0x4e9d3) (BuildId:\n15a3c1cd9721e9f1b4e15fade2028ddca6dc542a) #4 0x5621ad62ad8c in\necma_op_function_call_native ecma-function-object.c #5 0x5621ad62a971 in\necma_op_function_call (/jerryscript/build/bin/jerry+0x5a971) (BuildId:\n15a3c1cd9721e9f1b4e15fade2028ddca6dc542a) #6 0x5621ad66e6f3 in\necma_builtin_string_prototype_object_replace_helper ecma-builtin-string-\nprototype.c #7 0x5621ad61e9d3 in ecma_builtin_dispatch_call\n(/jerryscript/build/bin/jerry+0x4e9d3) (BuildId:\n15a3c1cd9721e9f1b4e15fade2028ddca6dc542a) #8 0x5621ad62ad8c in\necma_op_function_call_native ecma-function-object.c #9 0x5621ad62a971 in\necma_op_function_call (/jerryscript/build/bin/jerry+0x5a971) (BuildId:\n15a3c1cd9721e9f1b4e15fade2028ddca6dc542a) #10 0x5621ad65324f in vm_execute\n(/jerryscript/build/bin/jerry+0x8324f) (BuildId:\n15a3c1cd9721e9f1b4e15fade2028ddca6dc542a) #11 0x5621ad652cfa in vm_run\n(/jerryscript/build/bin/jerry+0x82cfa) (BuildId:\n15a3c1cd9721e9f1b4e15fade2028ddca6dc542a) #12 0x5621ad652d80 in vm_run_global\n(/jerryscript/build/bin/jerry+0x82d80) (BuildId:\n15a3c1cd9721e9f1b4e15fade2028ddca6dc542a) #13 0x5621ad607455 in jerry_run\n(/jerryscript/build/bin/jerry+0x37455) (BuildId:\n15a3c1cd9721e9f1b4e15fade2028ddca6dc542a) #14 0x5621ad603e32 in main\n(/jerryscript/build/bin/jerry+0x33e32) (BuildId:\n15a3c1cd9721e9f1b4e15fade2028ddca6dc542a) #15 0x7fc192429d8f in\n__libc_start_call_main csu/../sysdeps/nptl/libc_start_call_main.h:58:16 #16\n0x7fc192429e3f in __libc_start_main csu/../csu/libc-start.c:392:3 #17\n0x5621ad5db2d4 in _start (/jerryscript/build/bin/jerry+0xb2d4) (BuildId:\n15a3c1cd9721e9f1b4e15fade2028ddca6dc542a) UndefinedBehaviorSanitizer can not\nprovide additional info. SUMMARY: UndefinedBehaviorSanitizer: SEGV\nstring/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S:513\n==54331==ABORTING\n\n    \n    \n    $ ./build/bin/jerry ./poc.js [COV] no shared memory bitmap available, skipping [COV] edge counters initialized. Shared memory: (null) with 14587 edges UndefinedBehaviorSanitizer:DEADLYSIGNAL ==54331==ERROR: UndefinedBehaviorSanitizer: SEGV on unknown address 0x5622ae01350c (pc 0x7fc1925a092b bp 0x000000000000 sp 0x7ffed516b838 T54331) ==54331==The signal is caused by a READ memory access. #0 0x7fc1925a092b string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S:513 #1 0x5621ad66636b in ecma_builtin_replace_substitute (/jerryscript/build/bin/jerry+0x9636b) (BuildId: 15a3c1cd9721e9f1b4e15fade2028ddca6dc542a) #2 0x5621ad6380b3 in ecma_regexp_replace_helper (/jerryscript/build/bin/jerry+0x680b3) (BuildId: 15a3c1cd9721e9f1b4e15fade2028ddca6dc542a) #3 0x5621ad61e9d3 in ecma_builtin_dispatch_call (/jerryscript/build/bin/jerry+0x4e9d3) (BuildId: 15a3c1cd9721e9f1b4e15fade2028ddca6dc542a) #4 0x5621ad62ad8c in ecma_op_function_call_native ecma-function-object.c #5 0x5621ad62a971 in ecma_op_function_call (/jerryscript/build/bin/jerry+0x5a971) (BuildId: 15a3c1cd9721e9f1b4e15fade2028ddca6dc542a) #6 0x5621ad66e6f3 in ecma_builtin_string_prototype_object_replace_helper ecma-builtin-string-prototype.c #7 0x5621ad61e9d3 in ecma_builtin_dispatch_call (/jerryscript/build/bin/jerry+0x4e9d3) (BuildId: 15a3c1cd9721e9f1b4e15fade2028ddca6dc542a) #8 0x5621ad62ad8c in ecma_op_function_call_native ecma-function-object.c #9 0x5621ad62a971 in ecma_op_function_call (/jerryscript/build/bin/jerry+0x5a971) (BuildId: 15a3c1cd9721e9f1b4e15fade2028ddca6dc542a) #10 0x5621ad65324f in vm_execute (/jerryscript/build/bin/jerry+0x8324f) (BuildId: 15a3c1cd9721e9f1b4e15fade2028ddca6dc542a) #11 0x5621ad652cfa in vm_run (/jerryscript/build/bin/jerry+0x82cfa) (BuildId: 15a3c1cd9721e9f1b4e15fade2028ddca6dc542a) #12 0x5621ad652d80 in vm_run_global (/jerryscript/build/bin/jerry+0x82d80) (BuildId: 15a3c1cd9721e9f1b4e15fade2028ddca6dc542a) #13 0x5621ad607455 in jerry_run (/jerryscript/build/bin/jerry+0x37455) (BuildId: 15a3c1cd9721e9f1b4e15fade2028ddca6dc542a) #14 0x5621ad603e32 in main (/jerryscript/build/bin/jerry+0x33e32) (BuildId: 15a3c1cd9721e9f1b4e15fade2028ddca6dc542a) #15 0x7fc192429d8f in __libc_start_call_main csu/../sysdeps/nptl/libc_start_call_main.h:58:16 #16 0x7fc192429e3f in __libc_start_main csu/../csu/libc-start.c:392:3 #17 0x5621ad5db2d4 in _start (/jerryscript/build/bin/jerry+0xb2d4) (BuildId: 15a3c1cd9721e9f1b4e15fade2028ddca6dc542a) UndefinedBehaviorSanitizer can not provide additional info. SUMMARY: UndefinedBehaviorSanitizer: SEGV string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S:513 ==54331==ABORTING\n\nThis behavior happens because the vulnerability occurs far from the last\nexecution in the program. Usually, the primary action would be debugging to\nidentify the address of the vulnerable function in memory.\n\n#### Additional Considerations\n\nThe vulnerable address or address space could be used as a guide during\nfuzzing. We can then compare the PC to the specific address space and instruct\nthe fuzzer to focus on a path by mutating the same input in an attempt to\ncause other vulnerabilities in the same function or file. For example, we can\nalso feed data related to historical vulnerability identification, correlate\ndangerous files to their address space in a specific project and include them\ninto the instrumentation, and give feedback to the fuzzer to achieve a more\nfocused fuzzing campaign.\n\nWe do not necessarily need to use __sanitizer_symbolize_pc for the fuzzing\nprocess; this is done only to demonstrate the function and file utilized by\neach address. Our methodology would only require void *PC =\n__builtin_return_address(0). The PC will point to the current PC address in\nthe execution, which is the only information needed for the comparison and\nguiding process.\n\nAs we demonstrated above, we can retrieve more information about the stack\ntrace and identify vulnerable execution paths. So, let\u2019s look at Fuzzilli\u2019s\nbasic algorithm, described in their NDSS paper.\n\nIn line 12, it is defined that if a new edge is found, the JavaScript code is\nconverted back to its Intermediate Language (IL) (line 13), and the input is\nadded to the corpus for further mutations in line 14.\n\nWhat can we change to improve the algorithm? Since we have more information\nabout historical vulnerability identification and stack traces, I think that\u2019s\na good exercise for the readers.\n\n#### Conclusion\n\nWe demonstrated that we can track the real-time stack trace of a target\nprogram by extending Fuzzilli\u2019s instrumentation. By having better visibility\ninto the return address information and its associated source code files, it\u2019s\neasier to supply the fuzzer with additional paths that can produce interesting\nresults.\n\nUltimately, this instrumentation technique can be applied to any fuzzer that\ncan take advantage of code coverage capabilities. We intend to use this\nmodified instrumentation output technique in a part 2 blog post at a later\ndate, showing how it can be used to direct the fuzzer to potentially\ninteresting execution paths.\n\n### Share this:\n\n  * Twitter\n  * Facebook\n\n### Like this:\n\nLike Loading...\n\nCategories Uncategorized Tags appsec, fuzzing, hacking, OWASP, security\nresearch, vulnerability, webappsec\n\n## Discover more from Include Security Research Blog\n\nSubscribe now to keep reading and get access to the full archive.\n\nContinue reading\n\nLoading Comments...\n\n%d\n\n", "frontpage": false}
