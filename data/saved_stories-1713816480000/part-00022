{"aid": "40112589", "title": "Hexceptional Encoding: Mastering the Art of Hex Conversion in Rust", "url": "https://aayushyavajpayee.substack.com/p/hexceptional-encoding-mastering-the", "domain": "aayushyavajpayee.substack.com", "votes": 1, "user": "Ygg2", "posted_at": "2024-04-22 09:04:39", "comments": 0, "source_title": "Hexceptional Encoding: Mastering the Art of Hex Conversion in Rust", "source_text": "Hexceptional Encoding: Mastering the Art of Hex Conversion in Rust\n\n# Aayushya\u2019s Substack\n\nShare this post\n\n#### Hexceptional Encoding: Mastering the Art of Hex Conversion in Rust\n\naayushyavajpayee.substack.com\n\n#### Discover more from Aayushya\u2019s Substack\n\nMy personal Substack\n\nContinue reading\n\nSign in\n\n# Hexceptional Encoding: Mastering the Art of Hex Conversion in Rust\n\n### From micro-seconds to nano-seconds, we'll leave no byte unturned\n\nAayushya Vajpayee\n\nApr 20, 2024\n\n3\n\nShare this post\n\n#### Hexceptional Encoding: Mastering the Art of Hex Conversion in Rust\n\naayushyavajpayee.substack.com\n\nShare\n\nHex encoding is a widely used technique in the software industry for\nrepresenting binary data in a human-readable format. It converts each byte of\nbinary data into a two-character hexadecimal representation. Some of the use-\ncases of hex encoding are:\n\n  * Data Storage and network Transmission: Hex encoding is essential for storing or sending binary data in formats like json, xml etc, which can't directly handle binary.\n\n  * Checksums and Hash Digests: Hex encoding is commonly used to represent checksums and hash digests. Checksums are used to verify the integrity of data, ensuring that it has not been corrupted during storage or transmission. Hash digests, such as SHA-256 or MD5, are often used for data integrity checks, password storage, and digital signatures. By hex encoding checksums and hash digests, they can be easily compared, stored, and communicated as human-readable strings.\n\nFor this blog, I will take point 2 as an example to show various approaches as\nI recently contributed to optimising such a method in supabase edge-runtime\nwhere this hex encoding function is used to prepare cache keys, doing checksum\non files etc. Here is the pull request link if you like to explore the changes\nthere.\n\nThanks for reading Aayushya\u2019s Substack! Subscribe for free to receive new\nposts and support my work.\n\n####\n\nEncoding SHA256 Digest to hex using String Concatenation\n\nLet's calculate the SHA256 digest of input data and returns the result as a\nhexadecimal string. Here's an implementation using string concatenation:\n\nIn this, we first create a new sha256 context using Context::new(&SHA256) of\nring crate. Then, we iterate over the input slices feeding them to the\ncontext. Using ctx.finish() we obtain the digest. This part will be common to\nall our techniques. Lets focus on the part where we are converting the digest\nto hex encoding. We iterate over each byte of the digest using\ndigest.as_ref().iter() and format each byte as a two-character hexadecimal\nstring using format!(\"{byte:02x}\"). These are collected into the out vector.\nFinally, we join the vector using out.join(\"\") and get hex encoded output.\n\nTo an untrained eye, this may look alright, but there are lot of memory\nallocations happening here. sha256 digest is 32 bytes and the corresponding\nhex string is 64 chars long. The code iter().map(|byte| format!(\"{byte:02x}\"))\niterates over every byte and since the digest consists of 32 bytes, there will\nbe 32 formatted strings. Each string is a separate memory allocation.\nTherefore, this step performs 32 memory allocations. Collecting into a vector\nusing collect is 1 separate memory allocation, and then out.join(\u201c\u201c) is one\nanother memory allocation to create the final string. In total, there are\natleast 34 separate memory allocations happening just to convert to hex\nencoding. Lets see benchmarks (generated using criterion crate) how this\nstring concatenation performs:\n\nwe get a mean time of 2.7 micro seconds. Let\u2019s see how much of a difference\ncan minimising memory allocations cause.\n\n####\n\nEncoding SHA256 Digest to hex using write! macro\n\nHere is the code that uses rust\u2019s write macro:\n\nIn this approach, instead of creating a vector of formatted strings and\njoining them, we use the write! macro to directly write the formatted bytes\ninto a mutable String called out. We initialize out with a capacity of 64,\nwhich is the expected length of the hex-encoded digest string.\n\nThe write! macro allows us to write formatted text directly into a string,\navoiding the need for intermediate allocations. By using for_each and write!,\nwe iterate over each byte of the digest and write its formatted representation\ninto out.\n\nCompared to the string concatenation approach, with write!, we can use just\none allocation by writing directly into a pre-allocated string. This reduces\nthe number of allocations from 34 (in the previous approach) to just 1 for the\nout itself and no joining of strings after too. Here is what the benchmark\noutcome looks now:\n\nwe get a mean time of 956 ns (~3x improvement). Nice, with this you learned in\nwhat order of time (us\u2192ns) can avoiding memory allocations improve\nperformance. Generally, for web servers performance bottlenecks come from\nnetwork related calls (in the order of milliseconds) and these type of\noptimisations may not make much impact. However, for systems like databases,\nor batch processing applications, and real-time data processing, where\nmillions of operations need to be done, these optimisations can make\nsignificant impact. At last I want to show how fast are dedicated crates for\nhex encoding in rust\n\n####\n\nEncoding SHA256 Digest to hex using hex and faster-hex crate\n\nHex crate is pretty well known crate that uses simple bit operations and a\nstatic table lookup to convert a byte to hex character. A very simplistic\nrepresentation of what the crate internally does to encode the bytes looks\nlike this:\n\nfor every byte do 4 right shifts and lookup hex table to encode.\n\nfaster-hex crate does much more low level optimisations like simd\nvectorisation, etc to significantly speedup things. Using hex and faster hex\ncrate in our code like this:\n\njust a one line change for both. Let me show you the complete benchmark\nresults now:\n\nfaster-hex is almost 10x faster than string concatenate. Wow! . All the\nbenchmarking code is available here on github Happy (en)Coding!!\n\nLeave a comment\n\nShare Aayushya\u2019s Substack\n\n3\n\nShare this post\n\n#### Hexceptional Encoding: Mastering the Art of Hex Conversion in Rust\n\naayushyavajpayee.substack.com\n\nShare\n\nComments\n\nNo posts\n\nReady for more?\n\n\u00a9 2024 Aayushya Vajpayee\n\nPrivacy \u2219 Terms \u2219 Collection notice\n\nStart WritingGet the app\n\nSubstack is the home for great culture\n\nShare\n\n## Create your profile\n\n## Only paid subscribers can comment on this post\n\nAlready a paid subscriber? Sign in\n\n#### Check your email\n\nFor your security, we need to re-authenticate you.\n\nClick the link we sent to , or click here to sign in.\n\n", "frontpage": false}
