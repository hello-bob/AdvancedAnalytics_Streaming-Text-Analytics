{"aid": "40110813", "title": "What's New in Go 1.22: Cmp.or", "url": "https://blog.carlana.net/post/2024/golang-cmp-or-uses-and-history/", "domain": "carlana.net", "votes": 1, "user": "todsacerdoti", "posted_at": "2024-04-22 01:44:35", "comments": 0, "source_title": "What\u2019s New in Go 1.22: cmp.Or", "source_text": "What\u2019s New in Go 1.22: cmp.Or \u00b7 The Ethically-Trained Programmer\n\n# The Ethically-Trained Programmer\n\n\u201cIt should be noted that no ethically-trained software engineer would ever\nconsent to write a DestroyBaghdad procedure. Basic professional ethics would\ninstead require him to write a DestroyCity procedure, to which Baghdad could\nbe given as a parameter.\u201d \u2014 Nathaniel Borenstein, 1992\n\n# What\u2019s New in Go 1.22: cmp.Or\n\nMonday, April 22, 2024\n\nGo 1.22 has been released for a couple of months as of this writing. It\u2019s long\npast time to wrap up my series on what I worked on for 1.22. Sorry for the\nlong delay, I\u2019ve been busy with life stuff. Be sure to catch up on my posts\nabout reflect.TypeFor and slices.Concat if you missed those.\n\nThe final function I proposed and implemented for Go 1.22 is cmp.Or. On Go\nTime, I called it \u201cthe hidden gem of 1.22\u201d. It\u2019s a simple function with a lot\nof potential uses and a surprisingly long backstory.\n\nFirst let\u2019s take a look at the code:\n\n    \n    \n    // Or returns the first of its arguments that is not equal to the zero value. // If no argument is non-zero, it returns the zero value. func Or[T comparable](vals ...T) T { var zero T for _, val := range vals { if val != zero { return val } } return zero }\n\nAs is usual for my contributions to Go, it\u2019s very short and simple. It just\ncompares its arguments and returns the first one that isn\u2019t 0 or nil or \"\" or\nwhatever the zero value is for its type.\n\nHow do you use it?\n\nThe primary use for cmp.Or is for taking strings and returning the first one\nthat isn\u2019t blank. For example, searching public open source Go repositories, I\nfound a lot of code online that tries to fetch an environmental variable but\nreturn a default value if it\u2019s blank. With cmp.Or, this would look like\ncmp.Or(os.Getenv(\"SOME_VARIABLE\"), \"default\").\n\nIt also works with numbers and pointers.\n\nHere are a handful of actual uses from a real codebase of mine:\n\n    \n    \n    body := cmp.Or(page.Body, rawContent) name := cmp.Or(jwt.Username(), \"Almanack\") credits = append(credits, cmp.Or(credit.Name, credit.Byline)) metadata.InternalID = cmp.Or( xhtml.InnerText(rows.Value(\"slug\")), xhtml.InnerText(rows.Value(\"internal id\")), metadata.InternalID, ) scope.SetTag(\"username\", cmp.Or(userinfo.Username(), \"anonymous\")) currentUl = cmp.Or( xhtml.Closest(currentUl.Parent, xhtml.WithAtom(atom.Ul)), currentUl, )\n\nAs you can see, most uses just look at strings to provide a fallback value,\nbut the final example is looking for a non-nil *html.Node.\n\nThe other major use for cmp.Or is to use with cmp.Compare to create multipart\ncomparisons:\n\n    \n    \n    type Order struct { Product string Customer string Price float64 } orders := []Order{ {\"foo\", \"alice\", 1.00}, {\"bar\", \"bob\", 3.00}, {\"baz\", \"carol\", 4.00}, {\"foo\", \"alice\", 2.00}, {\"bar\", \"carol\", 1.00}, {\"foo\", \"bob\", 4.00}, } // Sort by customer first, product second, and last by higher price slices.SortFunc(orders, func(a, b Order) int { return cmp.Or( cmp.Compare(a.Customer, b.Customer), cmp.Compare(a.Product, b.Product), cmp.Compare(b.Price, a.Price), ) })\n    \n    \n    foo alice 2.00 foo alice 1.00 bar bob 3.00 foo bob 4.00 bar carol 1.00 baz carol 4.00\n\nNote that because cmp.Or cannot do short-circuit evaluation, this will compare\nthe product name and price of each item, even if the customer name is\ndifferent, which makes doing so redundant.\n\nThe road that led to cmp.Or is long. All the way back in 2016, Stephen\nKampmann proposed strings.First, but this was before the modern Go proposal\nsystem, so the proposal wasn\u2019t actually evaluated. In 2020, I proposed a new\noperator, ??, that would work like cmp.Or but with short circuiting. It could\nbe used like port := os.Getenv(\"PORT\") ?? DefaultPort. Ian Lance Taylor noted\nat the time that if Go ever got generics, this could be implemented (without\nshort-circuiting) as a generic helper function. Shortly after opening the\nissue for ??, I ended up writing a stringutils.First helper function for my\nown personal use, and I soon found myself using it everywhere in my code.\n\nWhen generics were finally added to beta versions of Go in 2021, I wrote a\npackage called truthy that uses reflect.Value.IsZero() to report whether any\nvalue is zero, but I found that using reflection caused allocations (this was\neventually improved) and was 50x slower than a normal comparison (this has\nimproved to only being 25x in Go 1.22). Using just generics with comparable\nlike cmp.Or and not reflection has about a 2x penalty in the current version\nof Go.\n\nIn 2022, I made a proposal for a generic universal zero value that was closed\nas a duplicate of an existing discussion, but Russ Cox made essentially the\nsame proposal in 2023 and it was accepted. According to the proposal, the\nbuilt in constant zero would be available in generic functions for return or\ncomparison. However, after the proposal was accepted, it was retracted due to\ncontinued community push back against the idea of having both nil and zero in\nthe language. I still think this is a shame and hope that someday cmp.Or can\nbe made fully generic and work for any type, but for now, it only works for\ncomparable types.\n\nThe crosseyed *new(T) lives on...\n\nInitially, I proposed just to add strings.First to the standard library, but\nin the course of the discussion, several commenters preferred a generic\nversion of the function and Russ Cox proposed the name cmp.Or, which was\nultimately accepted.\n\nSo that wraps up my work on Go 1.22! Come back this summer for the story of\nreflect.Value.Seq().\n\n## See more in this series...\n\n  * golang\n  * Ian Lance Taylor\n  * open source\n  * Russ Cox\n  * Stephen Kampmann\n\n## Related Articles\n\n  * What I worked on for Go 1.21\n  * What\u2019s New in Go 1.20, Part II: Major Standard Library Changes\n  * What\u2019s New in Go 1.22: slices.Concat\n  * What\u2019s New in Go 1.20, Part III: Minor Standard Library Changes\n  * What\u2019s New in Go 1.20, Part I: Language Changes\n\n## Comments\n\nType Comment Here (at least 3 chars)\n\n", "frontpage": false}
