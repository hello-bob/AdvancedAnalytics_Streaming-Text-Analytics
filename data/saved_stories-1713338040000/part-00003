{"aid": "40056344", "title": "Contravariance? Never", "url": "https://shaky.sh/more-ts-contravariance-never/", "domain": "shaky.sh", "votes": 1, "user": "ingve", "posted_at": "2024-04-16 19:46:12", "comments": 0, "source_title": "Contravariance? Never!", "source_text": "Contravariance? Never!\n\n# shaky.sh\n\n# Contravariance? Never!\n\nMarch 2024\n\n## The set of things I understand about contravariance is both unknown and\nnever\n\nYesterday some colleagues and I were discussing the relationship between any,\nunknown, and never in TypeScript. The mental model that's been helpful for me\nis Set Theory:\n\n  * unknown is the set of all possible values.\n\n    * If a function takes an unknown argument, you can pass it any value.\n  * never is the empty set.\n\n    * If a function takes a never argument, there's no value you can pass it.^1\n  * any does not conform to set theory.\n\n    * It's the equivalent of the compiler throwing up its hands and saying \"okay, fine, you drive!\"\n\n## An Example\n\nThe catalysts of our converstaion were the Parameters and ReturnType utility\ntypes built into TypeScript. If you aren't familiar, here they are as defined\nin es5.d.ts in the TypeScript source\n\n    \n    \n    type Parameters<T extends (...args: any) => any> = T extends (...args: infer P) => any ? P : never;\n    \n    type ReturnType<T extends (...args: any) => any> = T extends (...args: any) => infer R ? R : any;\n\nThe unknown type was introduced in TS 3.0 as a type-safe version of any, so it\nseemed weird to me that these core utility types are still using any when\nthere are better options. Can't we just replace any with unknonwn in\nParameters and ReturnTypes and move on?\n\nActually, no. Try it, and you'll see that something is wrong:\n\n    \n    \n    type ParametersNoAny<T extends (...args: unknown[]) => unknown> = T extends (...args: infer P) => unknown ? P : never;\n    \n    type ReturnTypeNoAny<T extends (...args: unknown[]) => unknown> = T extends (...args: unknown[]) => infer R ? R : unknown;\n    \n    function testFn(a1: string, a2: number): boolean { return parseInt(a1, 10) === a2; }\n    \n    type Args = ParametersNoAny<typeof testFn>; // error! type Ret = ReturnTypeNoAny<typeof testFn>; // error!\n\nWhen we try to pass typeof testFn to either of our new utilities, we get this\ntype error:\n\n    \n    \n    Type '(a1: string, a2: number) => boolean' does not satisfy the constraint '(...args: unknown[]) => unknown'. Types of parameters 'a1' and 'args' are incompatible. Type 'unknown' is not assignable to type 'string'.\n\nWhen I first saw this error, it seemed backwards to me. I don't want to assign\nunknown to string, I want to go the other way, right? I'm passing my string-\narged function into these utilities, so I'm trying to assign string where the\nconstraint is unknown, which should accept everything, right? Right?!?\n\nActually, this is a situation where it's helpful to understand contravariance.\nI wrote a post about covariance and contravariance in TypeScript last year,\nbut I still don't feel like I have a really good grasp of when it's relevant\nor even in play. But let's make an attempt, using the real-world example of\npacking boxes.\n\n## What kind of box do you want?\n\nLet's think of ParametersNoAny and ReturnTypeNoAny as you when helping a\nfriend move, and generic argument as the boxes you pack their stuff into.\n\nThe constraint on the generic parameter (T extends ...) is a request for a box\nthat fits a specific item. And right now, that item is unknown[]: in other\nwords, you want a box that can fit any number of any items. In our terms,\nthat's the set of all possible sets of arguments. There are no functions^2 in\nthe set of \"functions that accept all possible sets of arguments\"! No wonder\nwe get an error when we pass in a function that only accepts a string and a\nnumber.\n\nThe solution here is to say that these functions should take never[]\narguments:\n\n    \n    \n    type ParametersNoAny<T extends (...args: never[]) => unknown> = T extends (...args: infer P) => unknown ? P : never;\n    \n    type ReturnTypeNoAny<T extends (...args: never[]) => unknown> = T extends (...args: never[]) => infer R ? R : unknown;\n\nNow, we are asking for a box that can fit no items. Not a box that must fit no\nitems, but a box that can. To put it another way, you want a box that doesn't\nneed to work for a specific item or set of items: any box will do. Your friend\ncan pass you a box that fits a toaster, or a screwdriver, or a set of tires,\nand you'll be happy with whatever it is.\n\n## It works!\n\nWith these changes, our utility types now work! No errors, and they correctly\ninfer the types we want.\n\n    \n    \n    type Args = ParametersNoAny<typeof testFn>; // [a1: string, a2: number] type Ret = ReturnTypeNoAny<typeof testFn>; // boolean\n\nSo glad I finally understand contravariance ... for this week.\n\n  1. and yet you must pass it a variable. But that's a different post. \u21a9\ufe0e\n\n  2. expect functions that take (...args: unknown[]), I guess. \u21a9\ufe0e\n\n  * Reply to this post via email or webmention.\n\n\u00a9 2024 Andrew Burgess\n\n", "frontpage": false}
