{"aid": "40143247", "title": "Fundamentals of I/O in Go: Part 3", "url": "https://andreiboar.com/posts/fundamentals-of-i-o-in-go-part-3-b7c8a9970a51/", "domain": "andreiboar.com", "votes": 2, "user": "zuzuleinen", "posted_at": "2024-04-24 11:51:57", "comments": 0, "source_title": "Fundamentals of I/O in Go: Part 3", "source_text": "Fundamentals of I/O in Go: Part 3 \u00b7 Andrei Boar\n\n# Fundamentals of I/O in Go: Part 3\n\nApril 24, 2024\n\nGo \u2022 I/O\n\n# Intro Link to heading\n\nWelcome to the final part of the Fundamentals of I/O series, where we will\nlearn about buffered I/O. If you haven\u2019t already, I recommend checking out the\nfirst two parts:\n\n  * Part One: fundamentals and io functions\n  * Part Two: useful types from the io package\n\nBefore looking into I/O buffering in Go, let\u2019s see what problems it solves.\n\n# System calls: what are they? Link to heading\n\nWhen programs want to do something(e.g., open a file, send data via the\nnetwork, create a process, etc.), they ask the operating system to do it via\nsystem calls(syscalls).\n\nSystem calls are the API provided by the operating system to programs so they\ncan manage resources.\n\nThese system calls are similar to regular function calls, but they involve\nsome extra steps that cause the CPU to switch from user mode to kernel mode so\nit can execute a privileged action.\n\nsource: https://wizardzines.com/comics/syscalls/\n\n# System calls: how can we see them? Link to heading\n\nstrace is a Linux utility that lets you inspect the system calls performed by\nyour program under the hood.\n\nYou run it with strace followed by the program you want to trace.\n\nSay you want to trace the pwd program. strace pwd displays all the system\ncalls performed by pwd:\n\n    \n    \n    execve(\"/usr/bin/pwd\", [\"pwd\"], 0x7ffd23593820 /* 71 vars */) = 0 brk(NULL) = 0x61cc90c5f000 arch_prctl(0x3001 /* ARCH_??? */, 0x7fff64ee0a80) = -1 EINVAL (Invalid argument) mmap(NULL, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x71c13fd72000 access(\"/etc/ld.so.preload\", R_OK) = -1 ENOENT (No such file or directory) openat(AT_FDCWD, \"/etc/ld.so.cache\", O_RDONLY|O_CLOEXEC) = 3 newfstatat(3, \"\", {st_mode=S_IFREG|0644, st_size=79587, ...}, AT_EMPTY_PATH) = 0 mmap(NULL, 79587, PROT_READ, MAP_PRIVATE, 3, 0) = 0x71c13fd5e000 close(3) = 0 openat(AT_FDCWD, \"/lib/x86_64-linux-gnu/libc.so.6\", O_RDONLY|O_CLOEXEC) = 3 ---- getcwd(\"/home/andrei\", 4096) = 13 newfstatat(1, \"\", {st_mode=S_IFCHR|0620, st_rdev=makedev(0x88, 0x3), ...}, AT_EMPTY_PATH) = 0 write(1, \"/home/andrei\\n\", 13/home/andrei ) = 13 close(1) = 0 close(2) = 0 exit_group(0) = ?\n\nThis output can be pretty verbose because, most of the time, you don\u2019t want to\nsee all the syscalls. You can filter for a specific syscall by using the -e\noption.\n\nFor example, to see only the write system calls we run:\n\n    \n    \n    strace -e write pwd\n\nRunning this on my home directory, I get the following output:\n\n    \n    \n    write(1, \"/home/andrei\\n\", 13/home/andrei ) = 13 +++ exited with 0 +++\n\nwhich means that the 13 bytes of /home/andrei\\n are successfully written to\nfile with the descriptor 1 (the standard output in Linux). That\u2019s all you need\nto know for this article, but if you want to learn more, check out this zine\nmade by Julia Evans.\n\nI like strace because it helps me see what a program is doing even if I can\u2019t\naccess the source code. Some people call strace the Sysadmin\u2019s Microscope, but\nI view it more as a stethoscope. A compiled program is like a black box, but\nthat doesn\u2019t mean we cannot hear what\u2019s inside with the help of strace.\n\nNow that we know what system calls are and how to trace them let\u2019s examine\nbuffered I/O.\n\n# Buffered I/O Link to heading\n\nSystem calls are expensive due to their extra steps, so it\u2019s a good idea to\ndecrease them.\n\nBuffered I/O minimizes the number of system calls when doing I/O operations by\ntemporarily storing the data we read/write inside a buffer.\n\nIn real life, we use buffers all the time. We don\u2019t wash one piece of clothing\nat a time. Instead, we collect all the clothes in a laundry basket(buffer),\nand when it\u2019s full, we put them in the washing machine and wash them all in\none go.\n\nphoto: Michael Hession\n\nbufio is the package from the standard library that helps us with buffered\nI/O.\n\nYou should not think that the functions from the io package covered in Part\nOne don\u2019t use buffering because some do. If we check io.Copy, for example, we\nsee that a buffer is internally allocated. What bufio gives us extra are\nconvenient tools for more control over the buffering.\n\nLet\u2019s cover the three main types from the bufio package: bufio.Writer,\nbufio.Reader and bufio.Scanner.\n\n# bufio.Writer Link to heading\n\nLet\u2019s see some writes without buffering:\n\n    \n    \n    package main import ( \"os\" ) func main() { f := os.Stdout // f is a *os.File thus an io.Writer f.WriteString(\"a\") f.WriteString(\"b\") f.WriteString(\"c\") }\n\nrun in Playground\n\nIf we compile this program as writer_file and run strace -e write\n./writer_file, we get this output containing 3 write system calls:\n\n    \n    \n    --- SIGURG {si_signo=SIGURG, si_code=SI_TKILL, si_pid=61172, si_uid=1000} --- write(1, \"a\", 1a) = 1 write(1, \"b\", 1b) = 1 write(1, \"c\", 1c) = 1 +++ exited with 0 +++\n\nNow let\u2019s try the same code with a buffered writer created by putting the f\nio.Reader in the bufio.NewWriter(f) function:\n\n    \n    \n    package main import ( \"bufio\" \"os\" ) func main() { f := os.Stdout w := bufio.NewWriter(f) w.WriteString(\"a\") w.WriteString(\"b\") w.WriteString(\"c\") // Perform 1 write system call w.Flush() }\n\nrun in Playground\n\nWe see the same behavior, but if we run the strace with this compiled program,\nwe have 1 write instead of 3:\n\n    \n    \n    --- SIGURG {si_signo=SIGURG, si_code=SI_TKILL, si_pid=61488, si_uid=1000} --- write(1, \"abc\", 3abc) = 3 +++ exited with 0 +++\n\nWe can see how wrapping an io.Writer into a bufio.NewWriter decreases the\nnumber of system calls and how easy is to apply buffering by putting an\nio.Writer inside only one function.\n\nThe reason we had to call w.Flush() was because the bufio.NewWriter function\ncreates a Writer with a default size of 4096 bytes:\n\n    \n    \n    // NewWriter returns a new [Writer] whose buffer has the default size. // If the argument io.Writer is already a [Writer] with large enough buffer size, // it returns the underlying [Writer]. func NewWriter(w io.Writer) *Writer { return NewWriterSize(w, defaultBufSize) }\n\nIf data is less than the buffer size, it won\u2019t get written unless we call\n.Flush(). In our case, we had 3 bytes(abc) < 4096 bytes.\n\nYou can customize the size of the buffer by calling NewWriterSize.\n\nIn the following example, with a buffer of 3 bytes, abc are printed when we\nadd d. Once we add d, we need to call the Flush() to get it printed because we\nstill have space in the buffer.\n\n    \n    \n    package main import ( \"bufio\" \"os\" ) func main() { f := os.Stdout w := bufio.NewWriterSize(f, 3) // Will print abc. d is added the buffer and will not be printed without an explicit .Flush() w.WriteString(\"a\") w.WriteString(\"b\") w.WriteString(\"c\") // ----------------- w.WriteString(\"d\") }\n\nrun in Playground\n\nWhen adding data to a buffer, there are 3 scenarios:\n\nThe buffer has available space -> Data is added to the buffer.\n\nThe buffer is full -> Flush(write) the buffer\u2019s content into the io.Writer,\nand add any new data to the buffer.\n\nThe data exceeds the size of the buffer -> Skip the buffer and add data\nstraight to the destination.\n\n    \n    \n    package main import ( \"bufio\" \"fmt\" ) type Writer int // Writer implements io.Writer interface func (w *Writer) Write(p []byte) (n int, err error) { fmt.Printf(\"Writing: %s\\n\", p) return len(p), nil } func main() { bw := bufio.NewWriterSize(new(Writer), 4) bw.Write([]byte{'a'}) // buffer has space bw.Write([]byte{'b'}) // buffer has space bw.Write([]byte{'c'}) // buffer has space bw.Write([]byte{'d'}) // buffer has space bw.Write([]byte{'e'}) // buffer is full. flush `abcd` and add `e` to the buffer bw.Flush() // flush `e` to underlying Writer bw.Write([]byte(\"abcdefghij\")) // `abcdefghij` is bigger than 4 so we flush all to underlying Writer }\n\nrun in Playground\n\n# bufio.Reader Link to heading\n\nbufio.Reader is similar to bufio.Writer, but instead of buffering data before\nwriting, it buffers data fetched from read system calls, allowing us to read\nmore data in a single read operation.\n\nIf we have an io.Reader, we can create a bufio.Reader from it by calling the\nbufio.NewReader() function with that io.Reader as argument:\n\n    \n    \n    var r io.Reader bufferedReader := bufio.NewReader(r)\n\nOnce we have our buffered reader, we can call several read methods on it, such\nas:\n\nsource: https://pkg.go.dev/bufio#Reader\n\nIt\u2019s important to remember that any read system call from a buffered reader\nhappens in chunks equal to its internal buffer.\n\nFor example, in the following program, we read 4096 bytes at a time, even\nthough we get one byte at a time from the internal buffer:\n\n    \n    \n    package main import ( \"bufio\" \"fmt\" \"io\" \"log\" \"os\" ) func main() { fileName := \"input.txt\" file, err := os.Open(fileName) if err != nil { log.Fatalf(\"Error opening file: %v\", err) } defer file.Close() reader := bufio.NewReader(file) var bytesRead int64 for { _, err := reader.ReadByte() if err != nil && err != io.EOF { log.Fatalf(\"Error reading file: %v\", err) } if err == io.EOF { break } bytesRead++ } fmt.Printf(\"Total bytes read with bufio.Reader: %d\\n\", bytesRead) }\n\nIf we export the output of strace , we will see a bunch of lines like these:\n\n    \n    \n    read(3, \"The quick brown fox jumps over t\"..., 4096) = 4096 read(3, \"he quick brown fox jumps over th\"..., 4096) = 4096 read(3, \"e quick brown fox jumps over the\"..., 4096) = 4096 read(3, \" quick brown fox jumps over the \"..., 4096) = 4096\n\nThese lines show that we call read system call every 4096 bytes and not for\neach byte, even though looking at the method name, ReadByte(), you would think\nwe perform a read for each byte.\n\nThat\u2019s the cool stuff about the buffered reader: even if we read smaller\nchunks in our code, we read from the internal buffer as long as it has\nelements.\n\nSame as with bufio.Writer, the default buffer size of bufio.Reader is 4096\nbytes. If we want to change it, we have the NewReaderSize function.\n\n# bufio.Scanner Link to heading\n\nThe bufio.Scanner is used to read a stream of data by tokens. Tokens are\ndefined by what separates them. For example, words are tokens split by space,\nsentences by dots, or lines split by \\n character.\n\nHere is an example that reads a file line by line:\n\n    \n    \n    package main import ( \"bufio\" \"fmt\" \"log\" \"os\" ) func main() { f, err := os.Open(\"input.txt\") if err != nil { log.Fatal(err) } defer f.Close() s := bufio.NewScanner(f) for s.Scan() { fmt.Println(s.Text()) } if err = s.Err(); err != nil { fmt.Fprintln(os.Stderr, \"reading standard input:\", err) } }\n\nA split function defines the tokens. By default, the bufio.Scanner uses\nScanLines split function, which splits tokens into lines.\n\nThe standard library offers ScanRunes, ScanWords, and ScanBytes split\nfunctions, and you set a split function by calling the .Split() method on the\nscanner:\n\n    \n    \n    package main import ( \"bufio\" \"fmt\" \"log\" \"os\" ) func main() { f, err := os.Open(\"input.txt\") if err != nil { log.Fatal(err) } defer f.Close() s := bufio.NewScanner(f) s.Split(bufio.ScanWords) // use words as tokens for s.Scan() { fmt.Println(s.Text()) } if err = s.Err(); err != nil { fmt.Fprintln(os.Stderr, \"reading standard input:\", err) } }\n\nIf the split functions from the standard library don\u2019t suffice, you can create\nyour own as long as they match the SplitFunc signature:\n\nFor example, here is an implementation that splits content by the + sign:\n\n    \n    \n    package main import ( \"bufio\" \"bytes\" \"fmt\" \"log\" \"strings\" ) func main() { r := strings.NewReader(\"a+b+c+d+e\") s := bufio.NewScanner(r) s.Split(CustomSplit) // set our CustomSplit function to scanner for s.Scan() { fmt.Println(s.Text()) } if err := s.Err(); err != nil { log.Fatalf(\"error on scan: %s\", err) } } func CustomSplit(data []byte, atEOF bool) (advance int, token []byte, err error) { if atEOF && len(data) == 0 { return 0, nil, nil } if i := bytes.IndexRune(data, '+'); i >= 0 { return i + 1, data[0:i], nil } if atEOF { return len(data), data, nil } return 0, nil, nil }\n\nThis example is overkill and used only for showcase. When you have a string,\nyou should use the strings.Split() function, or bytes.Split() if you\u2019re\ndealing with bytes. Use bufio.Scanner only when you deal with files or other\ndata streams, not strings or slices of bytes.\n\nWe can see that this bufio.Scanner is a very specialized type of buffered\nreader that sees data as information split by tokens, and for most cases, you\ncan go with it, but sometimes, when you need more control, you should go with\nthe bufio.Reader instead, as the std library suggests:\n\n> Scanning stops unrecoverably at EOF, the first I/O error, or a token too\n> large to fit in the Scanner.Buffer. When a scan stops, the reader may have\n> advanced arbitrarily far past the last token. Programs that need more\n> control over error handling or large tokens, or must run sequential scans on\n> a reader, should use bufio.Reader instead.\n\n# Conclusion Link to heading\n\nThat was it! It was a long read, but I\u2019m happy to say this article ended our\nFundamentals of I/O in Go series.\n\nI hope you liked them and learned something new. It\u2019s normal if you didn\u2019t get\neverything right from the first read. I suggest you go through them again and\ntry the examples yourself.\n\nIf you have questions or want to say Hi!, contact me on LinkedIn.\n\n\u00a9 2024 Andrei Boar \u00b7 Hugo & Coder.\n\n", "frontpage": false}
