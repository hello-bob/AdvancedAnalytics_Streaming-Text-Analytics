{"aid": "40141777", "title": "Piet", "url": "https://www.dangermouse.net/esoteric/piet.html", "domain": "dangermouse.net", "votes": 64, "user": "andsoitis", "posted_at": "2024-04-24 07:52:58", "comments": 8, "source_title": "DM's Esoteric Programming Languages - Piet", "source_text": "DM's Esoteric Programming Languages - Piet\n\n# Piet\n\nComposition with Red, Yellow and Blue. 1921, Piet Mondrian.  \n---  \n  \n## Introduction\n\nPiet is a programming language in which programs look like abstract paintings.\nThe language is named after Piet Mondrian, who pioneered the field of\ngeometric abstract art. I would have liked to call the language Mondrian, but\nsomeone beat me to it with a rather mundane-looking scripting language. Oh\nwell, we can't all be esoteric language writers I suppose.\n\nNotes:\n\n  * I wrote the Piet specification a long time ago, and the language has taken on a bit of a life of its own, with a small community of coders writing Piet programs, interpreters, IDEs, and even compilers. I have not written any \"authoritative\" interpreter, and the different ones available sometimes interpret the specification slightly differently.\n  * Over the years I have tended to field questions about the spec with \"whatever you think makes the most sense\", rather than any definitive clarification - thus the slightly different versions out there. I have now added some clarifications to this specification to address some of the questions I have been asked over the years. Hopefully they are sensible and most implementations will already be compliant, but it's possible some do not comply. Caveat emptor.\n  * Some people like to use Piet to set puzzles in various competitions. This web page and the linked resources can help you solve those puzzles, if you have a reasonable grasp of computer coding. If you do not, or it looks too difficult, I suggest asking some of your friends who may be computer programmers to help you. Please do not email to ask me for help. Although I wish you the best in solving your puzzle, I do not have time to help everyone in this situation.\n\n## Design Principles\n\n  * Program code will be in the form of abstract art.\n\n## Language Concepts\n\n### Colours\n\n#FFC0C0 light red| #FFFFC0 light yellow| #C0FFC0 light green| #C0FFFF light\ncyan| #C0C0FF light blue| #FFC0FF light magenta  \n---|---|---|---|---|---  \n#FF0000 red| #FFFF00 yellow| #00FF00 green| #00FFFF cyan| #0000FF blue|\n#FF00FF magenta  \n#C00000 dark red| #C0C000 dark yellow| #00C000 dark green| #00C0C0 dark cyan|\n#0000C0 dark blue| #C000C0 dark magenta  \n#FFFFFF white| #000000 black  \n  \nPiet uses 20 distinct colours, as shown in the table at right. The 18 colours\nin the first 3 rows of the table are related cyclically in the following two\nways:\n\n  * Hue Cycle: red -> yellow -> green -> cyan -> blue -> magenta -> red\n  * Lightness Cycle: light -> normal -> dark -> light\n\nNote that \"light\" is considered to be one step \"darker\" than \"dark\", and vice\nversa. White and black do not fall into either cycle.\n\nAdditional colours (such as orange, brown) may be used, though their effect is\nimplementation-dependent. In the simplest case, non-standard colours are\ntreated by the language interpreter as the same as white, so may be used\nfreely wherever white is used. (Another possibility is that they are treated\nthe same as black.)\n\n### Codels\n\nPiet code takes the form of graphics made up of the recognised colours.\nIndividual pixels of colour are significant in the language, so it is common\nfor programs to be enlarged for viewing so that the details are easily\nvisible. In such enlarged programs, the term \"codel\" is used to mean a block\nof colour equivalent to a single pixel of code, to avoid confusion with the\nactual pixels of the enlarged graphic, of which many may make up one codel.\n\n### Colour Blocks\n\nThe basic unit of Piet code is the colour block. A colour block is a\ncontiguous block of any number of codels of one colour, bounded by blocks of\nother colours or by the edge of the program graphic. Blocks of colour adjacent\nonly diagonally are not considered contiguous. A colour block may be any shape\nand may have \"holes\" of other colours inside it, which are not considered part\nof the block.\n\n### Stack\n\nPiet uses a stack for storage of all data values. Data values exist only as\nintegers, though they may be read in or printed as Unicode character values\nwith appropriate commands.\n\nThe stack is notionally infinitely deep, but implementations may elect to\nprovide a finite maximum stack size. If a finite stack overflows, it should be\ntreated as a runtime error, and handling this will be implementation\ndependent.\n\n### Program Execution\n\nDP| CC| Codel chosen  \n---|---|---  \nright| left| uppermost  \nright| lowermost  \ndown| left| rightmost  \nright| leftmost  \nleft| left| lowermost  \nright| uppermost  \nup| left| leftmost  \nright| rightmost  \n  \nThe Piet language interpreter begins executing a program in the colour block\nwhich includes the upper left codel of the program. The interpreter maintains\na Direction Pointer (DP), initially pointing to the right. The DP may point\neither right, left, down or up. The interpreter also maintains a Codel Chooser\n(CC), initially pointing left. The CC may point either left or right. The\ndirections of the DP and CC will often change during program execution.\n\nAs it executes the program, the interpreter traverses the colour blocks of the\nprogram under the following rules:\n\n  1. The interpreter finds the edge of the current colour block which is furthest in the direction of the DP. (This edge may be disjoint if the block is of a complex shape.)\n  2. The interpreter finds the codel of the current colour block on that edge which is furthest to the CC's direction of the DP's direction of travel. (Visualise this as standing on the program and walking in the direction of the DP; see table at right.)\n  3. The interpreter travels from that codel into the colour block containing the codel immediately in the direction of the DP.\n\nThe interpreter continues doing this until the program terminates.\n\n## Syntax Elements\n\n### Numbers\n\nEach non-black, non-white colour block in a Piet program represents an integer\nequal to the number of codels in that block. Note that non-positive integers\ncannot be represented, although they can be constructed with operators. When\nthe interpreter encounters a number, it does not necessarily do anything with\nit. In particular, it is not automatically pushed on to the stack - there is\nan explicit command for that (see below).\n\nThe maximum size of integers is notionally infinite, though implementations\nmay implement a finite maximum integer size. An integer overflow is a runtime\nerror, and handling this will be implementation dependent.\n\n### Black Blocks and Edges\n\nBlack colour blocks and the edges of the program restrict program flow. If the\nPiet interpreter attempts to move into a black block or off an edge, it is\nstopped and the CC is toggled. The interpreter then attempts to move from its\ncurrent block again. If it fails a second time, the DP is moved clockwise one\nstep. These attempts are repeated, with the CC and DP being changed between\nalternate attempts. If after eight attempts the interpreter cannot leave its\ncurrent colour block, there is no way out and the program terminates.\n\n### White Blocks\n\nWhite colour blocks are \"free\" zones through which the interpreter passes\nunhindered. If it moves from a colour block into a white area, the interpreter\n\"slides\" through the white codels in the direction of the DP until it reaches\na non-white colour block. If the interpreter slides into a black block or an\nedge, it is considered restricted (see above), otherwise it moves into the\ncolour block so encountered. Sliding across white blocks into a new colour\ndoes not cause a command to be executed (see below). In this way, white blocks\ncan be used to change the current colour without executing a command, which is\nvery useful for coding loops.\n\nSliding across white blocks takes the interpreter in a straight line until it\nhits a coloured pixel or edge. It does not use the procedure described above\nfor determining where the interpreter emerges from non-white coloured blocks.\n\nPrecisely what happens when the interpeter slides across a white block and\nhits a black block or an edge was not clear in the original specification. My\ninterpretation follows from a literal reading of the above text:\n\n  * The interpreter \"slides\" across the white block in a straight line.\n  * If it hits a restriction, the CC is toggled. Since this results in no difference in where the interpreter is trying to go, the DP is immediately stepped clockwise.\n  * The interpreter now begins sliding from its current white codel, in the new direction of the DP, until it either enters a coloured block or encounters another restriction.\n  * Each time the interpreter hits a restriction while within the white block, it toggles the CC and steps the DP clockwise, then tries to slide again. This process repeats until the interpreter either enters a coloured block (where execution then continues); or until the interpreter begins retracing its route. If it retraces its route entirely within a white block, there is no way out of the white block and execution should terminate.\n\n### Commands\n\nLightness change  \n---  \nHue change| None| 1 Darker| 2 Darker  \nNone| push| pop  \n1 Step| add| subtract| multiply  \n2 Steps| divide| mod| not  \n3 Steps| greater| pointer| switch  \n4 Steps| duplicate| roll| in(number)  \n5 Steps| in(char)| out(number)| out(char)  \n  \nCommands are defined by the transition of colour from one colour block to the\nnext as the interpreter travels through the program. The number of steps along\nthe Hue Cycle and Lightness Cycle in each transition determine the command\nexecuted, as shown in the table at right. If the transition between colour\nblocks occurs via a slide across a white block, no command is executed. The\nindividual commands are explained below.\n\n  * push: Pushes the value of the colour block just exited on to the stack. Note that values of colour blocks are not automatically pushed on to the stack - this push operation must be explicitly carried out.\n  * pop: Pops the top value off the stack and discards it.\n  * add: Pops the top two values off the stack, adds them, and pushes the result back on the stack.\n  * subtract: Pops the top two values off the stack, calculates the second top value minus the top value, and pushes the result back on the stack.\n  * multiply: Pops the top two values off the stack, multiplies them, and pushes the result back on the stack.\n  * divide: Pops the top two values off the stack, calculates the integer division of the second top value by the top value, and pushes the result back on the stack. If a divide by zero occurs, it is handled as an implementation-dependent error, though simply ignoring the command is recommended.\n  * mod: Pops the top two values off the stack, calculates the second top value modulo the top value, and pushes the result back on the stack. The result has the same sign as the divisor (the top value). If the top value is zero, this is a divide by zero error, which is handled as an implementation-dependent error, though simply ignoring the command is recommended. (See note below.)\n  * not: Replaces the top value of the stack with 0 if it is non-zero, and 1 if it is zero.\n  * greater: Pops the top two values off the stack, and pushes 1 on to the stack if the second top value is greater than the top value, and pushes 0 if it is not greater.\n  * pointer: Pops the top value off the stack and rotates the DP clockwise that many steps (anticlockwise if negative).\n  * switch: Pops the top value off the stack and toggles the CC that many times (the absolute value of that many times if negative).\n  * duplicate: Pushes a copy of the top value on the stack on to the stack.\n  * roll: Pops the top two values off the stack and \"rolls\" the remaining stack entries to a depth equal to the second value popped, by a number of rolls equal to the first value popped. A single roll to depth n is defined as burying the top value on the stack n deep and bringing all values above it up by 1 place. A negative number of rolls rolls in the opposite direction. A negative depth is an error and the command is ignored. If a roll is greater than an implementation-dependent maximum stack depth, it is handled as an implementation-dependent error, though simply ignoring the command is recommended.\n  * in: Reads a value from STDIN as either a number or character, depending on the particular incarnation of this command and pushes it on to the stack. If no input is waiting on STDIN, this is an error and the command is ignored. If an integer read does not receive an integer value, this is an error and the command is ignored.\n  * out: Pops the top value off the stack and prints it to STDOUT as either a number or character, depending on the particular incarnation of this command.\n\nAny operations which cannot be performed (such as popping values when not\nenough are on the stack) are simply ignored, and processing continues with the\nnext command.\n\nNote on the mod command: In the original specification of Piet the result of a\nmodulo operation with a negative dividend (the second top value popped off the\nstack) was not explicitly defined. I assumed that everyone would assume that\nthe result of (p mod q) would always be equal to ((p + Nq) mod q) for any\ninteger N. So:\n\n  * 5 mod 3 = 2\n  * 2 mod 3 = 2\n  * -1 mod 3 = 2\n  * -4 mod 3 = 2\n\nThe mod command is thus identical to floored division in Wikipedia's page on\nthe modulus operation.\n\n## Sample Programs and Resources\n\n  * Sample programs\n  * Third-party Piet interpreters and development tools\n\nSupport me on Patreon\n\nHome | Esoteric Programming Languages Last updated: Thursday, 27 September, 2018; 04:00:52 PDT. Copyright \u00a9 1990-2022, David Morgan-Mar. dmm@dangermouse.net Hosted by: DreamHost\n\n", "frontpage": true}
