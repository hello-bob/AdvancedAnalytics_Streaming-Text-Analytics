{"aid": "40264194", "title": "Lost in Translation: The Bug That Spoke Russian and Crashed My App", "url": "https://imzaldih.com/en/post/bug-spoke-russian-crashed-app/", "domain": "imzaldih.com", "votes": 2, "user": "zaldih", "posted_at": "2024-05-05 12:01:01", "comments": 0, "source_title": "Lost in Translation: The Bug That Spoke Russian and Crashed My App", "source_text": "Lost in Translation: The Bug That Spoke Russian and Crashed My App\n\n# Lost in Translation: The Bug That Spoke Russian and Crashed My App\n\n26/04/2024\n\nSpy looking at screens.\n\nOther languages: Espa\u00f1ol\n\n## Introduction\n\nA few years ago, I was working on Lipo Manager to add some long-pending\nfeatures. The app is quite simple but more than enough for managing LiPos (a\ntype of battery). Some of these changes were driven by community feedback,\nrequesting features that hadn\u2019t been implemented yet: visual improvements,\noptimization, multi-language support, dependency updates, and fixing the\noccasional NullPointerException.\n\nAfter a day of work, I managed to finish everything and, after a few tests, I\nreleased the new version.\n\n## \u201cI Can\u2019t Enter the App\u201d\n\nA few days later, I received a message from a user via Telegram:\n\n> \u201cI updated my phone and the app stopped working.\u201d\n\nHmm...\n\nOne of the first steps every developer knows is that to solve a bug, you must\nfirst try to replicate it. Therefore, it\u2019s useful to know the environment in\nwhich it occurs. I asked for system information, to which he readily agreed.\n\nThe first thing I wanted to know was whether the user\u2019s Android version was\neither very new (beta) or very old. Generally, I wanted to verify if it was a\nversion I hadn\u2019t tested and if there was any issue with a library the app\nuses. To my surprise, his phone was running Android 13. Exactly the same\nversion and APIs I had tested the app with the most.\n\nI needed to dig deeper.\n\n## Checking Logs in the Play Console\n\nGoogle provides developers with many tools to manage apps published on the\nPlay Store. One of them is Android Vitals, which collects information about\neach installation, and in case of any exceptions, Android collects all traces\nand makes them available to the developer along with many more details.\n\nI won\u2019t comment on whether this breaches privacy or not, but when things go\nwrong, it\u2019s impractical to ask the user to connect via ADB to their phone,\nextract traces, and send them to us. So, in the end, it\u2019s a very useful tool.\n\nThe traces from a couple of users showed me this:\n\n    \n    \n    java.lang.RuntimeException: Unable to start activity ComponentInfo{com.dropvoid.lipomanager/com.dropvoid.lipomanager.MainActivity}: android.database.sqlite.SQLiteException: not an error (code 0 SQLITE_OK) at android.app.ActivityThread.performLaunchActivity(ActivityThread.java:3782) ... at android.app.ActivityThread.main(ActivityThread.java:8176) at java.lang.reflect.Method.invoke(Native Method) at com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:552) at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:971) Caused by: android.database.sqlite.SQLiteException: not an error (code 0 SQLITE_OK) at android.database.sqlite.SQLiteConnection.nativeRegisterLocalizedCollators(Native Method) at android.database.sqlite.SQLiteConnection.setLocaleFromConfiguration(SQLiteConnection.java:460) at android.database.sqlite.SQLiteConnection.open(SQLiteConnection.java:272) ... at android.database.sqlite.SQLiteDatabase.open(SQLiteDatabase.java:1067) at android.database.sqlite.SQLiteDatabase.openDatabase(SQLiteDatabase.java:931) at android.database.sqlite.SQLiteDatabase.openDatabase(SQLiteDatabase.java:920) at android.database.sqlite.SQLiteOpenHelper.getDatabaseLocked(SQLiteOpenHelper.java:373) at android.database.sqlite.SQLiteOpenHelper.getWritableDatabase(SQLiteOpenHelper.java:316) at com.orm.SugarDb.getDB(SugarDb.java:38) at com.orm.SugarRecord.getSugarDataBase(SugarRecord.java:35) at com.orm.SugarRecord.find(SugarRecord.java:201) at com.orm.SugarRecord.listAll(SugarRecord.java:127) at com.dropvoid.lipomanager.services.BatteryService.loadAllBatteries(BatteryService.java:21) ...\n\nA database issue? My first thought was that the problem might be related to\nupdating SugarORM. This library is used by the app as an ORM to manage the\ndatabase. However, since I hadn\u2019t experienced any issues, I doubted it was\ndirectly responsible. So, what was the condition causing this?\n\n## The Odyssey Begins\n\nAlright. We just need to replicate the problem and start following the trail\nto the bug, right? Simple. A routine. It would be solved soon.\n\n+15 hours later\n\n(Unfortunately) everything was fine. There was no way to make this explode.\nAnd that was all I wanted.\n\nThe internet wasn\u2019t shedding much light, as everyone seemed to point to causes\nlike file permission issues or sync failures among others. None of these\nseemed to be the cause or make sense in my case. In any case, I couldn\u2019t know\nbecause there was no way to replicate the problem.\n\nSince I couldn\u2019t replicate it, I couldn\u2019t roll back the changes either. Mostly\nbecause I wasn\u2019t even sure if this problem had been around for a long time.\n\nGoogle also provided me with the Android version, phone model, etc. Not even\nby emulating exactly the previous characteristics could I make any progress.\n\nAt this point, I had abused the application in every possible way, and\nironically, I was annoyed that it was so robust; I had corrupted the database,\ninserted thousands of records, isolated everything related to the database\nfrom the rest of the application, simulated dozens of version migrations...\nnone of that caused the problem I was looking for.\n\nThe BatteryService.loadAllBatteries() method was too simple and didn\u2019t have\nmuch logic. Plus, it was one of the first methods called when opening the app,\nso there weren\u2019t many chances of a race condition or something like that.\n\nEvery time my desperation grew and I re-read the traces, the message seemed\nmore insulting: \u201cSQLiteException: not an Error. Everything OK\u201c.\n\nAt this point, I was stuck. I had wasted too much time on all of this, and I\nbegan to feel defeated. I didn\u2019t know what else to do.\n\nWith resignation, I started to close everything down...\n\n## Plot Twist\n\nI only had a few windows left to close. Right in front of me was the Google\nPlay page, and I wanted to take one last look at the user\u2019s device details in\ncase I had missed something. I almost had it memorized after so much time\nstruggling with it; device, versions, traces, installed apps, features,\ncountry... country?\n\nThe user\u2019s country was the one detail I had overlooked, but now it turned out\nto be the only aspect I hadn\u2019t considered at all. What importance did it have\nthat this user was Russian? Was a Russian phone different? Well, let\u2019s try it\nout and run a few more tests. If anything...\n\n* Change the phone language to Russian.\n\nGod help me when I have to switch this back to English.\n\n* Open the app...\n\nOMG THERE IT IS. FINALLY.\n\n## Doors Open\n\nIn a mix of frustration and happiness, I had managed to replicate the problem.\nNow I had more information to continue investigating, but it didn\u2019t matter.\nNow I knew it was some kind of issue with character encoding, and all I wanted\nwas to get this working.\n\nNow I could search on Google and quickly found this Stack Overflow question.\n\nIn my code, one of the first routines was to load the device language to, if\nthere\u2019s a translation file available, load it as the app\u2019s language.\n\n    \n    \n    public void updateAppLanguage(Context context) { String languageCode = Locale.getDefault().getDisplayLanguage(); Locale locale = new Locale(languageCode); Locale.setDefault(locale); ...\n\nIf the device is in Russian, Locale.getDefault() returns \u201c\u0440\u0443\u0441\u0441\u043a\u0438\u0439\u201d, and it\nseems that SQLite doesn\u2019t like this for some reason.\n\nThe definitive solution was to manually check this specific case:\n\n    \n    \n    public void updateAppLanguage(Context context) { String languageCode = Locale.getDefault().getDisplayLanguage(); // Sql crashes at startup when the language is \u0440\u0443\u0441\u0441\u043a\u0438\u0439. // We switch to RU and manage it manually with languages. if (languageCode.equals(\"\u0440\u0443\u0441\u0441\u043a\u0438\u0439\")) { languageCode = \"ru\"; } Locale locale = new Locale(languageCode); Locale.setDefault(locale); ...\n\nThree lines of code fixed the huge problem that had been giving me so many\nheadaches. Once again.\n\nI did more tests, and it seems that out of the over 100 languages Android\nsupports, only Russian encoding broke SQLite. Not even Chinese, which we\ntypically think of as the most complicated (and also I tested changing to this\nlanguage much earlier before trying the other).\n\nWith the patch applied, I could finally release the update, and everyone was\nhappy.\n\n## Conclusion\n\nThis bug has probably been one of the most frustrating ones I\u2019ve dealt with.\nTwo of the most influential factors were that I wasn\u2019t familiar with native\napp development. The second factor was that the error itself was confusing and\nclarified very little. In fact, I\u2019m not sure if I was at fault due to\nignorance for not checking the charset, or if it was Android/SugarORM for not\nconsidering this case.\n\nIf you\u2019re starting to develop an app, I don\u2019t recommend any ORM for storing\npersistent data. Android launched its own (ROOM). Probably if I had known this\nfrom the beginning, I wouldn\u2019t have had this problem.\n\nAnd finally, if you ever find yourself lost and without a way out trying to\nfind the bug in your program, ask it if it speaks Russian.\n\nsitio en construcci\u00f3n\n\n", "frontpage": false}
